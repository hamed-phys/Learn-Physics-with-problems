<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Driven Charge in a Plane Wave (1D Constraint): Fields, Motion, and Radiation</title>
  <style>
    /* -----------------------------
       Design system (light/dark friendly)
    ------------------------------ */
    :root{
      --bg: #0b0f17;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.085);
      --text: rgba(255,255,255,0.90);
      --muted: rgba(255,255,255,0.72);
      --faint: rgba(255,255,255,0.55);
      --border: rgba(255,255,255,0.14);
      --shadow: 0 12px 30px rgba(0,0,0,0.35);

      --accent: #7dd3fc;   /* sky */
      --accent2: #a78bfa;  /* violet */
      --good: #34d399;     /* green */
      --warn: #fbbf24;     /* amber */
      --bad:  #fb7185;     /* rose */

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --serif: ui-serif, "Iowan Old Style", "Palatino Linotype", Palatino, Garamond, Georgia, serif;

      --radius: 18px;
      --radius2: 26px;
      --gap: clamp(14px, 2vw, 22px);

      --eq-bg: rgba(0,0,0,0.25);
      --eq-border: rgba(255,255,255,0.14);
      --grid: rgba(255,255,255,0.10);
      --grid2: rgba(255,255,255,0.06);
    }

    @media (prefers-color-scheme: light){
      :root{
        --bg: #f7fafc;
        --panel: rgba(0,0,0,0.04);
        --panel2: rgba(0,0,0,0.06);
        --text: rgba(10,15,23,0.92);
        --muted: rgba(10,15,23,0.72);
        --faint: rgba(10,15,23,0.56);
        --border: rgba(10,15,23,0.16);
        --shadow: 0 12px 30px rgba(0,0,0,0.12);

        --eq-bg: rgba(0,0,0,0.04);
        --eq-border: rgba(10,15,23,0.14);
        --grid: rgba(10,15,23,0.10);
        --grid2: rgba(10,15,23,0.06);
      }
    }

    *{ box-sizing: border-box; }
    html, body{ height: 100%; }
    body{
      margin: 0;
      font-family: var(--sans);
      color: var(--text);
      background:
        radial-gradient(1200px 800px at 15% 10%, rgba(125,211,252,0.12), transparent 60%),
        radial-gradient(1000px 700px at 85% 15%, rgba(167,139,250,0.12), transparent 55%),
        radial-gradient(900px 700px at 50% 100%, rgba(52,211,153,0.10), transparent 60%),
        var(--bg);
      line-height: 1.55;
      letter-spacing: 0.1px;
    }

    a{ color: var(--accent); text-decoration: none; }
    a:hover{ text-decoration: underline; }

    header{
      padding: clamp(22px, 3vw, 42px) 0 clamp(12px, 2vw, 20px);
    }
    .wrap{
      width: min(1100px, calc(100% - 2*clamp(14px, 3vw, 28px)));
      margin: 0 auto;
    }

    .hero{
      display: grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: var(--gap);
      align-items: start;
    }
    @media (max-width: 900px){
      .hero{ grid-template-columns: 1fr; }
    }

    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
      border: 1px solid var(--border);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      padding: clamp(18px, 2.5vw, 26px);
      position: relative;
      overflow: hidden;
    }
    .titleCard::before{
      content:"";
      position:absolute; inset:-2px -2px auto auto;
      width: 220px; height: 220px;
      background: radial-gradient(circle at 30% 30%, rgba(125,211,252,0.35), transparent 60%);
      transform: translate(30px, -40px);
      filter: blur(0px);
      pointer-events: none;
    }
    .kicker{
      font-family: var(--mono);
      font-size: 0.92rem;
      color: var(--muted);
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: var(--panel);
    }
    .kdot{
      width: 10px; height: 10px; border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, var(--accent), rgba(125,211,252,0.25));
      box-shadow: 0 0 0 4px rgba(125,211,252,0.12);
    }
    h1{
      margin: 14px 0 8px;
      font-size: clamp(1.7rem, 2.8vw, 2.4rem);
      line-height: 1.15;
      letter-spacing: -0.6px;
    }
    .subtitle{
      margin: 0;
      color: var(--muted);
      font-size: 1.02rem;
      max-width: 70ch;
    }

    .metaCard{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      padding: 18px;
    }
    .metaGrid{
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .pillRow{
      display:flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .pill{
      font-family: var(--mono);
      font-size: 0.92rem;
      color: var(--muted);
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
    }
    .mini{
      font-size: 0.92rem;
      color: var(--muted);
    }

    main{
      padding-bottom: 44px;
    }

    section{
      margin-top: 18px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .sectionHead{
      padding: 18px 20px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      display:flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 14px;
      flex-wrap: wrap;
    }
    .sectionHead h2{
      margin: 0;
      font-size: 1.25rem;
      letter-spacing: -0.2px;
    }
    .sectionHead .note{
      color: var(--muted);
      font-size: 0.95rem;
    }
    .content{
      padding: 18px 20px;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--gap);
      align-items: start;
    }
    @media (max-width: 900px){
      .grid2{ grid-template-columns: 1fr; }
    }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--gap);
    }
    @media (max-width: 900px){
      .callouts{ grid-template-columns: 1fr; }
    }

    .callout{
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 14px 14px 12px;
      background: rgba(255,255,255,0.04);
      position: relative;
    }
    .callout strong{
      display:block;
      margin-bottom: 6px;
      letter-spacing: -0.2px;
    }
    .callout.good{ border-color: rgba(52,211,153,0.35); }
    .callout.good::before{
      content:"";
      position:absolute; inset: 0 auto 0 0;
      width: 5px; border-radius: var(--radius) 0 0 var(--radius);
      background: linear-gradient(180deg, rgba(52,211,153,0.7), rgba(52,211,153,0.12));
    }
    .callout.warn{ border-color: rgba(251,191,36,0.35); }
    .callout.warn::before{
      content:"";
      position:absolute; inset: 0 auto 0 0;
      width: 5px; border-radius: var(--radius) 0 0 var(--radius);
      background: linear-gradient(180deg, rgba(251,191,36,0.7), rgba(251,191,36,0.12));
    }
    .callout.info{ border-color: rgba(125,211,252,0.35); }
    .callout.info::before{
      content:"";
      position:absolute; inset: 0 auto 0 0;
      width: 5px; border-radius: var(--radius) 0 0 var(--radius);
      background: linear-gradient(180deg, rgba(125,211,252,0.75), rgba(125,211,252,0.12));
    }

    .eq{
      margin: 12px 0;
      padding: 12px 12px;
      border-radius: 14px;
      background: var(--eq-bg);
      border: 1px solid var(--eq-border);
      overflow-x: auto;
      font-family: var(--mono);
      font-size: 0.95rem;
      line-height: 1.55;
    }
    .eq .line{ white-space: nowrap; }
    .eq .dim{ color: var(--faint); }
    .eq .hi{ color: var(--accent); }
    .eq .hi2{ color: var(--accent2); }
    .eq .ok{ color: var(--good); }

    .steps{
      margin: 0;
      padding-left: 18px;
    }
    .steps li{ margin: 6px 0; }
    .muted{ color: var(--muted); }

    figure{
      margin: 0;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      background: rgba(255,255,255,0.03);
    }
    figcaption{
      padding: 10px 12px;
      color: var(--muted);
      font-size: 0.92rem;
      border-top: 1px solid var(--border);
      background: rgba(255,255,255,0.03);
    }

    canvas{
      display:block;
      width: 100%;
      height: auto;
      background: transparent;
    }

    .controls{
      display:flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 12px;
      padding: 12px;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.03);
    }
    .control{
      display:flex;
      flex-direction: column;
      gap: 6px;
      min-width: 220px;
      flex: 1 1 240px;
    }
    label{
      font-size: 0.92rem;
      color: var(--muted);
      display:flex;
      justify-content: space-between;
      gap: 10px;
      align-items: baseline;
      font-family: var(--mono);
    }
    input[type="range"]{
      width: 100%;
      accent-color: var(--accent);
    }
    .btn{
      appearance: none;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor: pointer;
      font-family: var(--mono);
      transition: transform 120ms ease, box-shadow 120ms ease, border-color 120ms ease;
      box-shadow: 0 6px 18px rgba(0,0,0,0.18);
    }
    .btn:hover{
      transform: translateY(-1px);
      border-color: rgba(125,211,252,0.40);
      box-shadow: 0 10px 22px rgba(0,0,0,0.22);
    }
    .btn:active{
      transform: translateY(0px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.18);
    }

    .finalBox{
      border: 1px solid rgba(52,211,153,0.40);
      background: linear-gradient(180deg, rgba(52,211,153,0.12), rgba(255,255,255,0.03));
      border-radius: var(--radius2);
      padding: 16px 18px;
      position: relative;
      overflow: hidden;
    }
    .finalBox::before{
      content:"";
      position:absolute;
      inset: -80px -120px auto auto;
      width: 260px; height: 260px;
      background: radial-gradient(circle at 30% 30%, rgba(52,211,153,0.28), transparent 60%);
      transform: rotate(15deg);
      pointer-events: none;
    }
    .finalBox h3{
      margin: 0 0 10px;
      font-size: 1.15rem;
      letter-spacing: -0.2px;
    }

    .twoCol{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--gap);
      align-items: start;
    }
    @media (max-width: 900px){
      .twoCol{ grid-template-columns: 1fr; }
    }

    footer{
      margin-top: 18px;
      padding: 18px 0 26px;
      color: var(--muted);
      font-size: 0.92rem;
    }
    .footCard{
      border: 1px solid var(--border);
      border-radius: var(--radius2);
      background: rgba(255,255,255,0.03);
      padding: 14px 16px;
    }

    /* Subtle animation for emphasis */
    @keyframes glow {
      0%{ box-shadow: 0 0 0 rgba(125,211,252,0.0); }
      50%{ box-shadow: 0 0 18px rgba(125,211,252,0.18); }
      100%{ box-shadow: 0 0 0 rgba(125,211,252,0.0); }
    }
    .pulse{
      animation: glow 3.8s ease-in-out infinite;
    }

    /* Table-like layout without <table> for responsiveness */
    .kv{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .kvRow{
      display:grid;
      grid-template-columns: 190px 1fr;
      gap: 12px;
      align-items: start;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 14px;
      background: rgba(255,255,255,0.03);
    }
    @media (max-width: 620px){
      .kvRow{ grid-template-columns: 1fr; }
    }
    .k{ font-family: var(--mono); color: var(--muted); }
    .v{ font-family: var(--mono); color: var(--text); overflow-wrap: anywhere; }

    .small{
      font-size: 0.92rem;
      color: var(--muted);
    }

    /* Visually hidden utility (for accessibility if needed) */
    .sr-only{
      position:absolute;
      width:1px; height:1px;
      padding:0; margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      white-space:nowrap;
      border:0;
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="hero">
        <div class="titleCard pulse">
          <div class="kicker"><span class="kdot" aria-hidden="true"></span><span>Electromagnetism • Plane Waves • Radiation</span></div>
          <h1>Driven Charge in a Vacuum Plane Wave (1D Constraint):<br/>Fields, Motion, and Far-Field Radiation</h1>
          <p class="subtitle">
            We analyze a charged particle constrained to slide frictionlessly along the <strong>x-axis</strong>, illuminated by a plane wave propagating in <strong>+z</strong>.
            Using vacuum plane-wave constraints, the Lorentz force, and the far-field radiation formula, we derive <em>u</em>, the wave’s electric field,
            the charge’s acceleration, and the radiated field/polarization toward three observation directions.
          </p>
        </div>

        <aside class="metaCard" aria-label="Article quick metadata">
          <div class="metaGrid">
            <div class="pillRow">
              <span class="pill">No external libraries</span>
              <span class="pill">Canvas plots & diagrams</span>
              <span class="pill">Interactive controls</span>
            </div>
            <p class="mini">
              <strong>Given magnetic field:</strong><br/>
              <span class="muted">B</span><sub>wave</sub>(<span class="muted">r</span>,t) =
              <span class="muted">B</span><sub>0</sub>(ŷ + u ẑ) cos(kz − ωt)
            </p>
            <p class="mini">
              <strong>Propagation:</strong> open space (vacuum), plane wave, traveling along <strong>+z</strong>.
              <br/><strong>Constraint:</strong> particle motion only along <strong>x</strong>.
            </p>
          </div>
        </aside>
      </div>
    </div>
  </header>

  <main>
    <div class="wrap">

      <!-- Quick Summary -->
      <section>
        <div class="sectionHead">
          <h2>Quick Summary</h2>
          <div class="note">What you should remember in 30 seconds</div>
        </div>
        <div class="content">
          <div class="callouts">
            <div class="callout info">
              <strong>Vacuum plane waves are transverse</strong>
              A wave traveling in <strong>+z</strong> cannot have <strong>B</strong><sub>z</sub> ≠ 0. Therefore <strong>u = 0</strong>.
            </div>
            <div class="callout good">
              <strong>E and B form a right-handed triad</strong>
              With <strong>B</strong> ∥ ŷ and propagation ∥ ẑ, we must have <strong>E</strong> ∥ x̂ and |E| = c|B|, so
              <strong>E</strong> = cB<sub>0</sub> x̂ cos(kz − ωt).
            </div>
            <div class="callout warn">
              <strong>1D constraint simplifies the force</strong>
              Since v ∥ x̂ and B ∥ ŷ, v×B ∥ ẑ has <em>no x-component</em>. Thus the x-acceleration is driven only by E<sub>x</sub>.
            </div>
            <div class="callout info">
              <strong>Radiation pattern of an accelerated charge</strong>
              Far-field: <strong>E</strong><sub>rad</sub> ∝ n̂×(n̂×a).
              Along the acceleration direction (x̂) radiation vanishes; toward ŷ or ẑ it is linearly polarized along x̂.
            </div>
          </div>
        </div>
      </section>

      <!-- Problem Restatement -->
      <section>
        <div class="sectionHead">
          <h2>Problem Restatement & Known Data</h2>
          <div class="note">Translate the prompt into a clear model</div>
        </div>
        <div class="content">
          <article>
            <p>
              A particle of mass <strong>m</strong> and charge <strong>q</strong> moves frictionlessly but is constrained to the <strong>x-axis</strong>.
              It is illuminated by an electromagnetic plane wave traveling through vacuum in the <strong>+z</strong> direction.
              The wave’s magnetic field is
            </p>
            <div class="eq" role="group" aria-label="Given magnetic field equation">
              <div class="line"><span class="hi">B</span><sub>wave</sub>(<span class="dim">r</span>,t) = <span class="hi">B</span><sub>0</sub>(ŷ + u ẑ) cos(kz − ωt)</div>
            </div>
            <p class="muted">
              Here B<sub>0</sub> is constant and u is an unknown (constant) parameter. The wave propagates in open space (vacuum).
              We must compute u, the corresponding electric field, the charge’s acceleration, and the far-field radiated electric field in three directions.
            </p>

            <div class="kv" aria-label="Given and unknown quantities">
              <div class="kvRow">
                <div class="k">Given</div>
                <div class="v">m, q, B<sub>0</sub>, k, ω; propagation along +z; motion constrained to x̂</div>
              </div>
              <div class="kvRow">
                <div class="k">Unknowns</div>
                <div class="v">u; E<sub>wave</sub>(r,t); a(t); E<sub>rad</sub>(r,t) & polarization along x̂, ŷ, ẑ</div>
              </div>
            </div>
          </article>
        </div>
      </section>

      <!-- Core physics principles -->
      <section>
        <div class="sectionHead">
          <h2>Key Physical Principles (Why they apply)</h2>
          <div class="note">The “rules of the game”</div>
        </div>
        <div class="content">
          <div class="grid2">
            <article>
              <h3 style="margin:0 0 10px; letter-spacing:-0.2px;">1) Vacuum plane-wave constraints</h3>
              <p class="muted" style="margin-top:0;">
                In free space, a plane wave with wavevector <strong>k</strong> = k ẑ must be <strong>transverse</strong>:
                both <strong>E</strong> and <strong>B</strong> are perpendicular to the propagation direction.
              </p>
              <div class="eq" aria-label="Plane wave constraints">
                <div class="line">k̂ · E = 0, &nbsp; k̂ · B = 0</div>
                <div class="line">E ⟂ B, &nbsp; and &nbsp; E × B points along +k̂</div>
                <div class="line">|E| = c|B|</div>
              </div>
              <p class="muted">
                These follow from Maxwell’s equations in vacuum. They let us determine <em>u</em> and <strong>E</strong> without heavy calculus.
              </p>
            </article>

            <article>
              <h3 style="margin:0 0 10px; letter-spacing:-0.2px;">2) Lorentz force + 1D constraint</h3>
              <p class="muted" style="margin-top:0;">
                A charge in EM fields obeys
                <span style="font-family:var(--mono);">F = q(E + v×B)</span>.
                The constraint forces motion only along x̂, so we only keep the x-component of the net force.
              </p>
              <div class="eq" aria-label="Lorentz force and constraint">
                <div class="line">F = q(E + v×B)</div>
                <div class="line">v = v<sub>x</sub>(t) x̂, &nbsp; a = a<sub>x</sub>(t) x̂</div>
              </div>
              <p class="muted">
                Crucially: if v ∥ x̂ and B ∥ ŷ, then v×B ∥ ẑ → it does not contribute to x-acceleration.
              </p>
            </article>
          </div>

          <article style="margin-top:var(--gap);">
            <h3 style="margin:0 0 10px; letter-spacing:-0.2px;">3) Far-field radiation from acceleration</h3>
            <p class="muted" style="margin-top:0;">
              For nonrelativistic motion, the dominant radiated electric field in the far zone is
              proportional to the component of acceleration perpendicular to the observation direction n̂.
            </p>
            <div class="eq" aria-label="Far-field radiation formula">
              <div class="line">E<sub>rad</sub>(r,t) = (q / (4π ε<sub>0</sub> c²)) · [ n̂ × ( n̂ × a(t<sub>ret</sub>) ) ] / r</div>
              <div class="line dim">t<sub>ret</sub> = t − r/c</div>
            </div>
            <p class="muted">
              This immediately predicts a “donut” pattern: no radiation along the acceleration axis; maximum perpendicular.
              Polarization is the direction of E<sub>rad</sub>, always transverse to n̂.
            </p>
          </article>
        </div>
      </section>

      <!-- Full derivation -->
      <section>
        <div class="sectionHead">
          <h2>Full Solution (Step-by-Step Derivation)</h2>
          <div class="note">Rigorous, beginner-friendly, no skipped steps</div>
        </div>
        <div class="content">
          <article>
            <h3 style="margin:0 0 10px; letter-spacing:-0.2px;">(a) Determine the parameter u</h3>
            <p class="muted" style="margin-top:0;">
              The phase cos(kz − ωt) indicates propagation along +z (wavevector k = k ẑ). In vacuum, plane waves are transverse:
              <strong>k̂ · B = 0</strong>.
            </p>
            <div class="eq" aria-label="Compute u using transversality">
              <div class="line">Given: B = B<sub>0</sub>( ŷ + u ẑ ) cos(kz − ωt)</div>
              <div class="line">k̂ = ẑ ⇒ k̂ · B ∝ ẑ · ( ŷ + u ẑ ) = u</div>
              <div class="line">Transversality requires k̂ · B = 0 ⇒ u = 0</div>
            </div>
            <div class="callout good" style="margin-top:12px;">
              <strong>Result (a)</strong>
              <span style="font-family:var(--mono);">
                u = 0, &nbsp; so &nbsp; B<sub>wave</sub>(r,t) = B<sub>0</sub> ŷ cos(kz − ωt).
              </span>
            </div>

            <h3 style="margin:18px 0 10px; letter-spacing:-0.2px;">(b) Find the electric field E<sub>wave</sub>(r,t)</h3>
            <p class="muted" style="margin-top:0;">
              For a vacuum plane wave: E ⟂ B, and E×B points along propagation (+z). Since B ∥ ŷ, E must be along ±x̂.
              Choose the sign so that x̂×ŷ = ẑ, i.e., E ∥ x̂. Magnitudes satisfy |E| = c|B|.
            </p>
            <div class="eq" aria-label="Construct electric field from B field">
              <div class="line">B(r,t) = B<sub>0</sub> ŷ cos(kz − ωt)</div>
              <div class="line">Choose E ∥ x̂ so that E × B ∥ ẑ</div>
              <div class="line">|E| = c|B| ⇒ E<sub>0</sub> = c B<sub>0</sub></div>
              <div class="line ok">E(r,t) = c B<sub>0</sub> x̂ cos(kz − ωt)</div>
            </div>
            <div class="callout good" style="margin-top:12px;">
              <strong>Result (b)</strong>
              <span style="font-family:var(--mono);">
                E<sub>wave</sub>(r,t) = c B<sub>0</sub> x̂ cos(kz − ωt).
              </span>
            </div>

            <h3 style="margin:18px 0 10px; letter-spacing:-0.2px;">(c) Acceleration a(t) of the charge (1D along x̂)</h3>
            <p class="muted" style="margin-top:0;">
              The Lorentz force is F = q(E + v×B). Because motion is constrained to x̂, we take v = v<sub>x</sub>(t) x̂ and compute v×B.
            </p>
            <div class="eq" aria-label="Compute v cross B direction and acceleration">
              <div class="line">v = v<sub>x</sub> x̂, &nbsp; B = B<sub>0</sub> ŷ cos(kz − ωt)</div>
              <div class="line">v×B = v<sub>x</sub> B<sub>0</sub> (x̂×ŷ) cos(...) = v<sub>x</sub> B<sub>0</sub> ẑ cos(...)</div>
              <div class="line dim">So (v×B)<sub>x</sub> = 0 → it does not affect x-motion</div>
              <div class="line">Thus F<sub>x</sub> = q E<sub>x</sub> = q c B<sub>0</sub> cos(kz − ωt)</div>
              <div class="line ok">m a<sub>x</sub>(t) = q c B<sub>0</sub> cos(kz − ωt) evaluated at the particle</div>
            </div>
            <p class="muted">
              Since the particle moves only along x, its z-coordinate is constant (call it z = z<sub>0</sub>).
              Therefore the wave phase at the particle is cos(k z<sub>0</sub> − ω t).
            </p>
            <div class="eq" aria-label="Acceleration as a function of time">
              <div class="line ok">a(t) = a<sub>x</sub>(t) x̂, &nbsp; a<sub>x</sub>(t) = (q c B<sub>0</sub>/m) cos(k z<sub>0</sub> − ω t)</div>
            </div>
            <div class="callout good" style="margin-top:12px;">
              <strong>Result (c)</strong>
              <span style="font-family:var(--mono);">
                a(t) = (q c B<sub>0</sub>/m) cos(k z<sub>0</sub> − ω t) x̂.
              </span>
            </div>

            <h3 style="margin:18px 0 10px; letter-spacing:-0.2px;">(d) Radiated E-field and polarization toward x̂, ŷ, ẑ</h3>
            <p class="muted" style="margin-top:0;">
              Use the nonrelativistic far-field expression:
              E<sub>rad</sub>(r,t) = (q/(4π ε<sub>0</sub> c²)) [n̂×(n̂×a(t<sub>ret</sub>))]/r, where t<sub>ret</sub> = t − r/c.
              Here a ∥ x̂ always, so the geometry is clean.
            </p>

            <div class="twoCol">
              <div>
                <div class="callout info">
                  <strong>Vector identity shortcut</strong>
                  For any vectors n̂ and a:
                  <span style="font-family:var(--mono);">n̂×(n̂×a) = a − (a·n̂) n̂</span>.
                  So only the component of a perpendicular to n̂ radiates.
                </div>
              </div>
              <div>
                <div class="callout warn">
                  <strong>Radiation “donut”</strong>
                  If the observer looks along the acceleration axis (n̂ ∥ a), then a is parallel to n̂ and the perpendicular component is zero → no radiation.
                </div>
              </div>
            </div>

            <div class="eq" aria-label="Radiation field in three directions">
              <div class="line"><span class="hi">Case 1:</span> n̂ = x̂ ⇒ n̂×(n̂×a) = 0 ⇒ E<sub>rad</sub>(r x̂,t) = 0</div>
              <div class="line"><span class="hi">Case 2:</span> n̂ = ŷ ⇒ n̂×(n̂×a) = −a<sub>x</sub>(t<sub>ret</sub>) x̂</div>
              <div class="line"><span class="hi">Case 3:</span> n̂ = ẑ ⇒ n̂×(n̂×a) = −a<sub>x</sub>(t<sub>ret</sub>) x̂</div>
            </div>

            <div class="eq" aria-label="Radiation field results with prefactor">
              <div class="line ok">E<sub>rad</sub>(r x̂,t) = 0</div>
              <div class="line ok">E<sub>rad</sub>(r ŷ,t) = −(q/(4π ε<sub>0</sub> c²)) · a<sub>x</sub>(t−r/c) · x̂ / r</div>
              <div class="line ok">E<sub>rad</sub>(r ẑ,t) = −(q/(4π ε<sub>0</sub> c²)) · a<sub>x</sub>(t−r/c) · x̂ / r</div>
            </div>

            <div class="callout good" style="margin-top:12px;">
              <strong>Polarization</strong>
              Along ŷ or ẑ, the radiated E-field points along x̂ → <strong>linearly polarized in x̂</strong>.
              Along x̂ the field is zero → no polarization (no radiation).
            </div>

            <h4 style="margin:18px 0 8px; letter-spacing:-0.2px;">Sanity checks</h4>
            <ul class="steps">
              <li><strong>Units:</strong> E = cB gives V/m; a = (qE)/m gives m/s²; E<sub>rad</sub> ∝ q a/(ε<sub>0</sub> c² r) gives V/m.</li>
              <li><strong>Limiting cases:</strong> q→0 or B<sub>0</sub>→0 ⇒ a→0 ⇒ E<sub>rad</sub>→0. Observer along x̂ ⇒ no radiation (dipole donut).</li>
              <li><strong>Interpretation:</strong> The wave’s E drives x-oscillation; radiation is strongest perpendicular to that axis and polarized along the projected acceleration.</li>
            </ul>
          </article>
        </div>
      </section>

      <!-- Final Answer box -->
      <section>
        <div class="sectionHead">
          <h2>Final Answer</h2>
          <div class="note">All results in one place</div>
        </div>
        <div class="content">
          <div class="finalBox" role="region" aria-label="Final answer box">
            <h3>Complete results</h3>

            <div class="eq" aria-label="Final boxed results">
              <div class="line"><span class="hi">(a)</span> <span class="ok">u = 0</span></div>
              <div class="line"><span class="hi">(a)</span> B<sub>wave</sub>(r,t) = B<sub>0</sub> ŷ cos(kz − ωt)</div>
              <div class="line"><span class="hi">(b)</span> E<sub>wave</sub>(r,t) = c B<sub>0</sub> x̂ cos(kz − ωt)</div>
              <div class="line"><span class="hi">(c)</span> a(t) = (q c B<sub>0</sub>/m) cos(k z<sub>0</sub> − ωt) x̂</div>
              <div class="line"><span class="hi">(d)</span> E<sub>rad</sub>(r,t) = (q/(4π ε<sub>0</sub> c²)) [ n̂×(n̂×a(t−r/c)) ] / r</div>
              <div class="line dim">Directions:</div>
              <div class="line"><span class="hi">n̂=x̂:</span> E<sub>rad</sub> = 0</div>
              <div class="line"><span class="hi">n̂=ŷ:</span> E<sub>rad</sub> = −(q a<sub>x</sub>(t−r/c)/(4π ε<sub>0</sub> c² r)) x̂</div>
              <div class="line"><span class="hi">n̂=ẑ:</span> E<sub>rad</sub> = −(q a<sub>x</sub>(t−r/c)/(4π ε<sub>0</sub> c² r)) x̂</div>
              <div class="line dim">Polarization:</div>
              <div class="line"><span class="hi">Along ŷ, ẑ:</span> linear x̂-polarized; <span class="hi">Along x̂:</span> none (zero field).</div>
            </div>

            <p class="small" style="margin:10px 0 0;">
              Note: z<sub>0</sub> is the fixed z-position of the track/particle (often z<sub>0</sub>=0). A different z<sub>0</sub> shifts phase only.
            </p>
          </div>
        </div>
      </section>

      <!-- Visualizations -->
      <section>
        <div class="sectionHead">
          <h2>Visualizations (Canvas, No Libraries)</h2>
          <div class="note">Interactive physics: fields, acceleration, and radiation pattern</div>
        </div>
        <div class="content">
          <div class="grid2">

            <!-- Diagram canvas -->
            <figure aria-label="Physical setup diagram">
              <canvas id="setupCanvas" width="900" height="520" role="img" aria-label="Diagram of plane wave geometry, field directions, and particle constraint"></canvas>
              <figcaption>
                <strong>Figure A — Geometry.</strong> The plane wave propagates along +z; the vacuum constraints force B ⟂ z ⇒ u=0, so B ∥ y. Then E ∥ x so that E×B ∥ z.
                The charge is constrained to move along x (track), hence a ∥ x.
              </figcaption>
            </figure>

            <!-- Time-series plot -->
            <figure aria-label="Time series plot of acceleration and radiation amplitude">
              <canvas id="timeCanvas" width="900" height="520" role="img" aria-label="Plot of acceleration versus time and radiation amplitude versus time with axes and gridlines"></canvas>
              <figcaption>
                <strong>Figure B — Time response.</strong> a<sub>x</sub>(t) = (q c B<sub>0</sub>/m) cos(k z<sub>0</sub> − ωt).
                The far-field radiated amplitude toward ŷ or ẑ scales as |E<sub>rad</sub>| ∝ |a<sub>x</sub>(t−r/c)|/r.
              </figcaption>
            </figure>

          </div>

          <div style="height:var(--gap)"></div>

          <!-- Radiation pattern plot -->
          <figure aria-label="Radiation angular pattern plot">
            <canvas id="patternCanvas" width="1100" height="520" role="img" aria-label="Polar plot of radiation pattern showing donut shape with axes and labels"></canvas>
            <figcaption>
              <strong>Figure C — Radiation pattern.</strong> For a(t) ∥ x̂, the far-field magnitude scales as
              |E<sub>rad</sub>| ∝ |a| sin(θ), where θ is the angle from the x-axis (acceleration axis). This yields a “donut” with zeros at θ=0,π and maximum at θ=π/2.
            </figcaption>
          </figure>

          <!-- Controls -->
          <div class="controls" aria-label="Interactive controls for the plots">
            <div class="control">
              <label for="b0Range">
                <span>B<sub>0</sub> (µT)</span>
                <span id="b0Val">5.0</span>
              </label>
              <input id="b0Range" type="range" min="0.5" max="50" step="0.5" value="5" aria-label="Magnetic field amplitude B0 in microtesla" />
              <div class="small">Updates E<sub>0</sub>=cB<sub>0</sub>, a<sub>0</sub>=q c B<sub>0</sub>/m, and radiation amplitude.</div>
            </div>

            <div class="control">
              <label for="omegaRange">
                <span>ω / (2π) (MHz)</span>
                <span id="omegaVal">5.0</span>
              </label>
              <input id="omegaRange" type="range" min="0.5" max="20" step="0.5" value="5" aria-label="Wave frequency in megahertz" />
              <div class="small">Changes oscillation rate (time-domain plot). Pattern shape stays sin(θ).</div>
            </div>

            <div class="control">
              <label for="rRange">
                <span>Observer distance r (m)</span>
                <span id="rVal">10</span>
              </label>
              <input id="rRange" type="range" min="1" max="100" step="1" value="10" aria-label="Observer distance r in meters" />
              <div class="small">Radiation amplitude scales ∝ 1/r. Retarded time shift is included in the plotted E<sub>rad</sub>(t).</div>
            </div>

            <button class="btn" id="toggleAnim" aria-label="Toggle animation">
              Pause animation
            </button>
          </div>

          <div class="callout warn" style="margin-top:12px;">
            <strong>About numeric values used in plots</strong>
            The derivation above is symbolic. For visualization we choose a small, nonrelativistic example (electron-like mass scale by default),
            but you can interpret the sliders as changing B<sub>0</sub>, ω, and r while the formulas remain exactly the derived ones.
          </div>
        </div>
      </section>

      <footer>
        <div class="wrap">
          <div class="footCard">
            <strong>Accessibility note:</strong> All interactive inputs include ARIA labels; plots include axes, labels, gridlines, and titles drawn directly on the canvases.
            Colors are chosen for high contrast in both dark and light modes.
          </div>
        </div>
      </footer>

    </div>
  </main>

  <script>
    (() => {
      // -----------------------------
      // Physical constants and defaults
      // -----------------------------
      const c = 299792458;                 // m/s
      const eps0 = 8.8541878128e-12;       // F/m
      const pi = Math.PI;

      // Choose representative particle parameters for visualization.
      // (Derivation is general in m,q.)
      const q = 1.602176634e-19;           // C
      const m = 9.1093837015e-31;          // kg (electron mass)

      // Track location (phase reference): z0 fixed; only phase shift
      const z0 = 0; // meters

      // -----------------------------
      // DOM references
      // -----------------------------
      const setupCanvas = document.getElementById('setupCanvas');
      const timeCanvas = document.getElementById('timeCanvas');
      const patternCanvas = document.getElementById('patternCanvas');

      const b0Range = document.getElementById('b0Range');
      const omegaRange = document.getElementById('omegaRange');
      const rRange = document.getElementById('rRange');

      const b0Val = document.getElementById('b0Val');
      const omegaVal = document.getElementById('omegaVal');
      const rVal = document.getElementById('rVal');

      const toggleAnimBtn = document.getElementById('toggleAnim');

      // -----------------------------
      // Canvas helpers
      // -----------------------------
      function dprScale(canvas) {
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        // keep intrinsic size ratio, but ensure crispness
        canvas.width = Math.round(rect.width * dpr);
        canvas.height = Math.round(rect.height * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        return ctx;
      }

      function clear(ctx, w, h) {
        ctx.clearRect(0, 0, w, h);
      }

      function getThemeColors() {
        // read computed colors from CSS variables
        const s = getComputedStyle(document.documentElement);
        return {
          text: s.getPropertyValue('--text').trim() || '#fff',
          muted: s.getPropertyValue('--muted').trim() || 'rgba(255,255,255,0.72)',
          faint: s.getPropertyValue('--faint').trim() || 'rgba(255,255,255,0.55)',
          border: s.getPropertyValue('--border').trim() || 'rgba(255,255,255,0.14)',
          grid: s.getPropertyValue('--grid').trim() || 'rgba(255,255,255,0.10)',
          grid2: s.getPropertyValue('--grid2').trim() || 'rgba(255,255,255,0.06)',
          accent: s.getPropertyValue('--accent').trim() || '#7dd3fc',
          accent2: s.getPropertyValue('--accent2').trim() || '#a78bfa',
          good: s.getPropertyValue('--good').trim() || '#34d399',
          warn: s.getPropertyValue('--warn').trim() || '#fbbf24',
          bad: s.getPropertyValue('--bad').trim() || '#fb7185',
          panel: s.getPropertyValue('--panel').trim() || 'rgba(255,255,255,0.06)'
        };
      }

      function roundNice(x) {
        // for tick labels
        if (x === 0) return "0";
        const ax = Math.abs(x);
        if (ax >= 1e9) return (x/1e9).toFixed(2) + "G";
        if (ax >= 1e6) return (x/1e6).toFixed(2) + "M";
        if (ax >= 1e3) return (x/1e3).toFixed(2) + "k";
        if (ax >= 1) return x.toFixed(2);
        if (ax >= 1e-3) return (x*1e3).toFixed(2) + "m";
        if (ax >= 1e-6) return (x*1e6).toFixed(2) + "µ";
        if (ax >= 1e-9) return (x*1e9).toFixed(2) + "n";
        return x.toExponential(2);
      }

      function drawGridAxes(ctx, x0, y0, w, h, xMin, xMax, yMin, yMax, opts) {
        const C = getThemeColors();
        const {
          title = "",
          xLabel = "",
          yLabel = "",
          xTicks = 6,
          yTicks = 5
        } = opts || {};

        // background subtle panel
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.02)';
        ctx.fillRect(x0, y0, w, h);
        ctx.restore();

        // grid
        ctx.save();
        ctx.lineWidth = 1;
        for (let i=0; i<=xTicks; i++){
          const t = i/xTicks;
          const x = x0 + t*w;
          ctx.strokeStyle = (i===0 || i===xTicks) ? C.grid : C.grid2;
          ctx.beginPath();
          ctx.moveTo(x, y0);
          ctx.lineTo(x, y0+h);
          ctx.stroke();
        }
        for (let j=0; j<=yTicks; j++){
          const t = j/yTicks;
          const y = y0 + t*h;
          ctx.strokeStyle = (j===0 || j===yTicks) ? C.grid : C.grid2;
          ctx.beginPath();
          ctx.moveTo(x0, y);
          ctx.lineTo(x0+w, y);
          ctx.stroke();
        }
        ctx.restore();

        // axes border
        ctx.save();
        ctx.strokeStyle = C.border;
        ctx.lineWidth = 1.25;
        ctx.strokeRect(x0, y0, w, h);
        ctx.restore();

        // title and labels
        ctx.save();
        ctx.fillStyle = C.text;
        ctx.font = '600 16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        ctx.fillText(title, x0, y0 - 10);

        ctx.fillStyle = C.muted;
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        ctx.fillText(xLabel, x0 + w - ctx.measureText(xLabel).width, y0 + h + 22);

        // y label rotated
        ctx.save();
        ctx.translate(x0 - 38, y0 + 10);
        ctx.rotate(-Math.PI/2);
        ctx.fillText(yLabel, 0, 0);
        ctx.restore();

        // tick labels
        ctx.fillStyle = C.faint;
        ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

        for (let i=0; i<=xTicks; i++){
          const t = i/xTicks;
          const x = x0 + t*w;
          const val = xMin + t*(xMax-xMin);
          const s = roundNice(val);
          const tw = ctx.measureText(s).width;
          ctx.fillText(s, x - tw/2, y0 + h + 14);
        }
        for (let j=0; j<=yTicks; j++){
          const t = j/yTicks;
          const y = y0 + (1-t)*h;
          const val = yMin + t*(yMax-yMin);
          const s = roundNice(val);
          ctx.fillText(s, x0 - 8 - ctx.measureText(s).width, y + 4);
        }

        ctx.restore();

        // mapping functions
        const X = (x) => x0 + (x - xMin)/(xMax - xMin)*w;
        const Y = (y) => y0 + (1 - (y - yMin)/(yMax - yMin))*h;
        return {X, Y};
      }

      function drawLegend(ctx, x, y, items) {
        const C = getThemeColors();
        ctx.save();
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        let yy = y;
        items.forEach(it => {
          ctx.fillStyle = it.color;
          ctx.fillRect(x, yy-9, 14, 6);
          ctx.fillStyle = C.muted;
          ctx.fillText(it.label, x+20, yy-4);
          yy += 18;
        });
        ctx.restore();
      }

      function arrow(ctx, x1, y1, x2, y2, color, label) {
        const C = getThemeColors();
        ctx.save();
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x1,y1);
        ctx.lineTo(x2,y2);
        ctx.stroke();
        const ang = Math.atan2(y2-y1, x2-x1);
        const head = 10;
        ctx.beginPath();
        ctx.moveTo(x2,y2);
        ctx.lineTo(x2 - head*Math.cos(ang - 0.35), y2 - head*Math.sin(ang - 0.35));
        ctx.lineTo(x2 - head*Math.cos(ang + 0.35), y2 - head*Math.sin(ang + 0.35));
        ctx.closePath();
        ctx.fill();
        if (label){
          ctx.fillStyle = C.text;
          ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
          ctx.fillText(label, x2 + 8, y2 + 4);
        }
        ctx.restore();
      }

      // -----------------------------
      // Physics functions (from solution)
      // -----------------------------
      function computeParams() {
        // B0 slider in microtesla -> tesla
        const B0 = parseFloat(b0Range.value) * 1e-6; // T
        // frequency slider in MHz: f = ω/2π in MHz -> ω
        const f = parseFloat(omegaRange.value) * 1e6; // Hz
        const omega = 2*pi*f; // rad/s

        // In vacuum: k = ω/c
        const k = omega / c; // rad/m

        // observer distance
        const r = parseFloat(rRange.value); // m

        // Wave E0
        const E0 = c * B0; // V/m

        // Acceleration amplitude a0 = q E0 / m = q c B0 / m
        const a0 = (q * c * B0) / m; // m/s^2

        // Radiation prefactor: q/(4π ε0 c^2) * 1/r
        const radPref = (q / (4*pi*eps0*c*c)) / r; // (C)/(F/m * m^2/s^2 * m) -> V·s^2/m^2? yields V/m after *a

        return {B0, E0, omega, k, r, a0, radPref};
      }

      function ax(t, params) {
        // a_x(t) = a0 cos(k z0 - ω t)
        return params.a0 * Math.cos(params.k * z0 - params.omega * t);
      }

      function EradAmp(t, params) {
        // For observation along y or z: E_rad = - radPref * a_x(t - r/c) * xhat
        const tret = t - params.r / c;
        return -params.radPref * ax(tret, params); // V/m (m/s^2 * prefactor)
      }

      // -----------------------------
      // Draw setup diagram
      // -----------------------------
      function drawSetup() {
        const ctx = dprScale(setupCanvas);
        const rect = setupCanvas.getBoundingClientRect();
        const W = rect.width;
        const H = rect.height;

        const C = getThemeColors();
        clear(ctx, W, H);

        // Title
        ctx.save();
        ctx.fillStyle = C.text;
        ctx.font = '700 16px ui-sans-serif, system-ui';
        ctx.fillText('Figure A — Plane wave geometry + constrained charge', 16, 26);
        ctx.fillStyle = C.muted;
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        ctx.fillText('Propagation: +z,  B ⟂ z ⇒ u=0,  choose E so E×B → +z,  motion constrained to x', 16, 46);
        ctx.restore();

        // Draw coordinate axes (3D-ish)
        const origin = {x: 140, y: H*0.62};
        arrow(ctx, origin.x, origin.y, origin.x + 190, origin.y, C.accent, 'x̂');
        arrow(ctx, origin.x, origin.y, origin.x + 120, origin.y - 130, C.accent2, 'ẑ');
        arrow(ctx, origin.x, origin.y, origin.x, origin.y - 160, C.good, 'ŷ');

        // Draw "track" along x (thick line)
        ctx.save();
        ctx.strokeStyle = C.border;
        ctx.lineWidth = 10;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(origin.x - 40, origin.y + 58);
        ctx.lineTo(origin.x + 360, origin.y + 58);
        ctx.stroke();

        ctx.fillStyle = C.muted;
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        ctx.fillText('Track (constraint): motion only along x̂', origin.x - 40, origin.y + 88);
        ctx.restore();

        // Particle on track
        const px = origin.x + 155 + 60*Math.sin(perfTime*0.9);
        const py = origin.y + 58;
        ctx.save();
        ctx.beginPath();
        ctx.arc(px, py, 14, 0, 2*pi);
        ctx.fillStyle = C.accent;
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.25)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = C.text;
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        ctx.fillText('q, m', px - 16, py + 36);
        ctx.restore();

        // Field arrows near particle
        const fx = px + 140;
        const fy = py - 30;

        // E arrow (x direction)
        arrow(ctx, fx, fy, fx + 110, fy, C.accent, 'E ∥ x̂');
        // B arrow (y direction)
        arrow(ctx, fx, fy + 70, fx, fy + 70 - 110, C.good, 'B ∥ ŷ');

        // Poynting direction
        arrow(ctx, fx + 140, fy + 70, fx + 220, fy + 10, C.accent2, 'S ∥ ẑ');

        // Transversality note box
        ctx.save();
        const bx = W*0.52, by = H*0.18, bw = W*0.45-20, bh = H*0.30;
        ctx.fillStyle = 'rgba(255,255,255,0.03)';
        ctx.strokeStyle = C.border;
        ctx.lineWidth = 1.25;
        roundRect(ctx, bx, by, bw, bh, 16);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = C.text;
        ctx.font = '700 13px ui-sans-serif, system-ui';
        ctx.fillText('Vacuum plane-wave constraint', bx + 14, by + 26);

        ctx.fillStyle = C.muted;
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        ctx.fillText('k̂ = ẑ ⇒ k̂·B = 0', bx + 14, by + 52);
        ctx.fillText('Given B ∝ (ŷ + u ẑ) ⇒ u = 0', bx + 14, by + 74);
        ctx.fillText('|E| = c|B| and E×B → +ẑ', bx + 14, by + 96);
        ctx.restore();

        // Radiation note box
        ctx.save();
        const bx2 = W*0.52, by2 = H*0.55, bw2 = W*0.45-20, bh2 = H*0.30;
        ctx.fillStyle = 'rgba(255,255,255,0.03)';
        ctx.strokeStyle = C.border;
        ctx.lineWidth = 1.25;
        roundRect(ctx, bx2, by2, bw2, bh2, 16);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = C.text;
        ctx.font = '700 13px ui-sans-serif, system-ui';
        ctx.fillText('Radiation geometry (a ∥ x̂)', bx2 + 14, by2 + 26);

        ctx.fillStyle = C.muted;
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        ctx.fillText('E_rad ∝ n̂×(n̂×a)', bx2 + 14, by2 + 52);
        ctx.fillText('Along n̂=x̂ ⇒ E_rad = 0 (no radiation)', bx2 + 14, by2 + 74);
        ctx.fillText('Along n̂=ŷ or ẑ ⇒ E_rad ∥ x̂ (linear)', bx2 + 14, by2 + 96);
        ctx.restore();
      }

      function roundRect(ctx, x, y, w, h, r){
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr, y);
        ctx.arcTo(x+w, y, x+w, y+h, rr);
        ctx.arcTo(x+w, y+h, x, y+h, rr);
        ctx.arcTo(x, y+h, x, y, rr);
        ctx.arcTo(x, y, x+w, y, rr);
        ctx.closePath();
      }

      // -----------------------------
      // Draw time series plot
      // -----------------------------
      function drawTimePlot(tNow) {
        const ctx = dprScale(timeCanvas);
        const rect = timeCanvas.getBoundingClientRect();
        const W = rect.width;
        const H = rect.height;

        const C = getThemeColors();
        clear(ctx, W, H);

        const params = computeParams();

        // time window: show several cycles
        const f = params.omega/(2*pi);
        const T = 1/f;
        const tSpan = 3.0 * T;      // show 3 periods
        const tMin = tNow - tSpan;
        const tMax = tNow;

        // y ranges based on amplitude
        const a0 = params.a0;
        const e0 = Math.abs(params.radPref) * a0; // peak |E_rad| (toward y or z) at sinθ=1
        // display in scaled units: a in 10^?; E in V/m small. We'll plot two traces with separate scale labels on legend.
        // We'll normalize both for plotting on same axis but show mapping on labels.
        const aScale = Math.pow(10, Math.floor(Math.log10(Math.max(a0, 1e-30))));
        const eScale = Math.pow(10, Math.floor(Math.log10(Math.max(e0, 1e-30))));

        const aNormAmp = a0 / aScale;
        const eNormAmp = e0 / eScale;

        const yMax = 1.25 * Math.max(aNormAmp, eNormAmp);
        const yMin = -yMax;

        // plot frame
        const padL = 70, padR = 18, padT = 44, padB = 54;
        const x0 = padL, y0 = padT, w = W - padL - padR, h = H - padT - padB;

        const map = drawGridAxes(ctx, x0, y0, w, h, 0, tSpan, yMin, yMax, {
          title: 'Figure B — Time-domain response (normalized to show both traces)',
          xLabel: 'time window Δt (s)',
          yLabel: 'normalized amplitude',
          xTicks: 6,
          yTicks: 5
        });

        // legend
        drawLegend(ctx, x0 + 12, y0 + 18, [
          {color: C.accent, label: `a_x(t) / ${roundNice(aScale)} (m/s²)`},
          {color: C.accent2, label: `E_rad(t) / ${roundNice(eScale)} (V/m)  (toward ŷ or ẑ)`}
        ]);

        // axes lines at zero
        ctx.save();
        ctx.strokeStyle = C.border;
        ctx.lineWidth = 1.25;
        ctx.beginPath();
        ctx.moveTo(x0, map.Y(0));
        ctx.lineTo(x0+w, map.Y(0));
        ctx.stroke();
        ctx.restore();

        // function to convert absolute time -> window coordinate
        const Xwin = (t) => map.X(t - tMin); // since xMin=0, xMax=tSpan

        // draw trace: a_x normalized
        ctx.save();
        ctx.strokeStyle = C.accent;
        ctx.lineWidth = 2.2;
        ctx.beginPath();
        const N = 900;
        for (let i=0; i<=N; i++){
          const tt = tMin + (i/N)*tSpan;
          const y = ax(tt, params) / aScale;
          const x = Xwin(tt);
          if (i===0) ctx.moveTo(x, map.Y(y));
          else ctx.lineTo(x, map.Y(y));
        }
        ctx.stroke();
        ctx.restore();

        // draw trace: E_rad normalized (toward y or z)
        ctx.save();
        ctx.strokeStyle = C.accent2;
        ctx.lineWidth = 2.2;
        ctx.setLineDash([8,6]);
        ctx.beginPath();
        for (let i=0; i<=N; i++){
          const tt = tMin + (i/N)*tSpan;
          const y = EradAmp(tt, params) / eScale;
          const x = Xwin(tt);
          if (i===0) ctx.moveTo(x, map.Y(y));
          else ctx.lineTo(x, map.Y(y));
        }
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();

        // annotate current time marker
        ctx.save();
        const xNow = Xwin(tNow);
        ctx.strokeStyle = C.warn;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(xNow, y0);
        ctx.lineTo(xNow, y0+h);
        ctx.stroke();

        ctx.fillStyle = C.warn;
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        ctx.fillText('now', xNow + 6, y0 + 16);
        ctx.restore();

        // show numeric panel
        ctx.save();
        const bx = x0 + 12, by = y0 + h - 82, bw = 330, bh = 70;
        ctx.fillStyle = 'rgba(255,255,255,0.03)';
        ctx.strokeStyle = C.border;
        ctx.lineWidth = 1.1;
        roundRect(ctx, bx, by, bw, bh, 14);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = C.text;
        ctx.font = '700 12px ui-sans-serif, system-ui';
        ctx.fillText('Instantaneous values (visualization)', bx + 12, by + 20);

        const aNow = ax(tNow, params);
        const eNow = EradAmp(tNow, params);
        ctx.fillStyle = C.muted;
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        ctx.fillText(`a_x(now) = ${roundNice(aNow)} m/s²`, bx + 12, by + 42);
        ctx.fillText(`E_rad(now) ≈ ${roundNice(eNow)} V/m (toward ŷ,ẑ)`, bx + 12, by + 60);
        ctx.restore();
      }

      // -----------------------------
      // Draw radiation pattern (polar-style on Cartesian canvas)
      // -----------------------------
      function drawPattern() {
        const ctx = dprScale(patternCanvas);
        const rect = patternCanvas.getBoundingClientRect();
        const W = rect.width;
        const H = rect.height;

        const C = getThemeColors();
        clear(ctx, W, H);

        const params = computeParams();

        const padL = 70, padR = 22, padT = 44, padB = 58;
        const x0 = padL, y0 = padT, w = W - padL - padR, h = H - padT - padB;

        // We'll plot in an x-y plane representing angular coordinates around the x-axis (acceleration axis).
        // For visualization, define angle theta from +x axis. Radiation amplitude ~ sin(theta).
        // Create a polar plot centered in frame.
        ctx.save();
        ctx.fillStyle = C.text;
        ctx.font = '700 16px ui-sans-serif, system-ui';
        ctx.fillText('Figure C — Angular radiation pattern for a ∥ x̂', x0, y0 - 10);
        ctx.fillStyle = C.muted;
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        ctx.fillText('|E_rad| ∝ |a| sin(θ)  (θ measured from x-axis)', x0, y0 + 12);
        ctx.restore();

        // Frame background
        ctx.save();
        ctx.strokeStyle = C.border;
        ctx.lineWidth = 1.25;
        ctx.fillStyle = 'rgba(255,255,255,0.02)';
        ctx.fillRect(x0, y0, w, h);
        ctx.strokeRect(x0, y0, w, h);
        ctx.restore();

        const cx = x0 + w*0.5;
        const cy = y0 + h*0.55;
        const R = Math.min(w, h) * 0.36;

        // Grid circles and radial lines
        ctx.save();
        ctx.strokeStyle = C.grid2;
        ctx.lineWidth = 1;
        for (let i=1; i<=4; i++){
          ctx.beginPath();
          ctx.arc(cx, cy, (i/4)*R, 0, 2*pi);
          ctx.stroke();
        }
        for (let a=0; a<12; a++){
          const ang = (a/12)*2*pi;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(cx + R*Math.cos(ang), cy + R*Math.sin(ang));
          ctx.stroke();
        }
        ctx.restore();

        // Axes labels: x axis direction (acceleration axis) drawn horizontally to the right, -x to left.
        ctx.save();
        ctx.strokeStyle = C.grid;
        ctx.lineWidth = 1.25;
        ctx.beginPath();
        ctx.moveTo(cx - R - 30, cy);
        ctx.lineTo(cx + R + 30, cy);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(cx, cy - R - 30);
        ctx.lineTo(cx, cy + R + 30);
        ctx.stroke();

        ctx.fillStyle = C.muted;
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        ctx.fillText('+x̂ (accel axis)', cx + R - 10, cy - 10);
        ctx.fillText('−x̂', cx - R - 24, cy - 10);
        ctx.fillText('⊥', cx + 8, cy - R - 16);
        ctx.restore();

        // Pattern curve: r(θ) = sin(θ) (scaled) for θ in [0,2π]
        // Here θ is measured from +x axis (to the right). We'll draw two lobes (donut cross-section).
        ctx.save();
        ctx.strokeStyle = C.accent;
        ctx.lineWidth = 2.6;
        ctx.beginPath();
        const N = 1200;
        for (let i=0; i<=N; i++){
          const theta = (i/N)*2*pi;
          const amp = Math.abs(Math.sin(theta)); // magnitude
          const rr = amp * R;
          const x = cx + rr*Math.cos(theta);
          const y = cy + rr*Math.sin(theta);
          if (i===0) ctx.moveTo(x,y);
          else ctx.lineTo(x,y);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.restore();

        // Legend and scaling hint
        const peakE = Math.abs(params.radPref) * params.a0; // max magnitude toward θ=pi/2
        ctx.save();
        ctx.fillStyle = C.text;
        ctx.font = '700 12px ui-sans-serif, system-ui';
        ctx.fillText('Scaling (toward ŷ or ẑ):', x0 + 12, y0 + h - 32);
        ctx.fillStyle = C.muted;
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        ctx.fillText(`|E_rad|_max ≈ (q/(4π ε0 c²)) |a0| / r = ${roundNice(peakE)} V/m`, x0 + 12, y0 + h - 12);
        ctx.restore();

        // annotate the three asked directions conceptually:
        // n̂ = x̂ => θ=0 => zero; n̂=ŷ => θ=pi/2 => max; n̂=ẑ also perpendicular => max in magnitude (in 3D).
        ctx.save();
        ctx.fillStyle = C.warn;
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

        // points
        const pX = {x: cx + 0, y: cy}; // θ=0 => r=0 at center
        ctx.fillText('n̂=x̂ → 0', pX.x + 6, pX.y + 16);

        const pY = {x: cx, y: cy - R}; // θ=pi/2 => r=R
        ctx.fillText('n̂ ⟂ x̂ → max', pY.x + 10, pY.y - 6);

        // draw small marker at top
        ctx.beginPath();
        ctx.arc(pY.x, pY.y, 4, 0, 2*pi);
        ctx.fill();

        ctx.restore();
      }

      // -----------------------------
      // Animation loop
      // -----------------------------
      let running = true;
      let t0 = performance.now();
      let perfTime = 0;

      function tick() {
        const now = performance.now();
        perfTime = (now - t0) / 1000; // seconds
        if (running) {
          drawSetup();
          drawTimePlot(perfTime);
          drawPattern();
        }
        requestAnimationFrame(tick);
      }

      // -----------------------------
      // UI updates
      // -----------------------------
      function updateLabels() {
        b0Val.textContent = parseFloat(b0Range.value).toFixed(1);
        omegaVal.textContent = parseFloat(omegaRange.value).toFixed(1);
        rVal.textContent = parseInt(rRange.value, 10).toString();
      }

      function redrawOnce() {
        // draw with current perfTime even if paused
        drawSetup();
        drawTimePlot(perfTime);
        drawPattern();
      }

      function onResize() {
        // Canvases are responsive by CSS; re-render crisp
        redrawOnce();
      }

      [b0Range, omegaRange, rRange].forEach(el => {
        el.addEventListener('input', () => {
          updateLabels();
          redrawOnce();
        });
      });

      toggleAnimBtn.addEventListener('click', () => {
        running = !running;
        toggleAnimBtn.textContent = running ? 'Pause animation' : 'Resume animation';
        if (!running) redrawOnce();
      });

      window.addEventListener('resize', onResize);

      // Initialize
      updateLabels();
      // First render: ensure canvases have computed sizes
      requestAnimationFrame(() => {
        redrawOnce();
        tick();
      });

    })();
  </script>
</body>
</html>
