<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Boundary Conditions at Conductors — Parallel-Plate Waveguide Modes</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --card:#111c3a;
      --text:#e9eefc;
      --muted:#b8c3e6;
      --faint:#7f8ab3;
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.07);
      --accent:#8be9fd;
      --accent2:#a78bfa;
      --good:#6ee7b7;
      --warn:#fde68a;
      --bad:#fb7185;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius: 18px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 900px at 15% -10%, rgba(167,139,250,.18), transparent 55%),
        radial-gradient(900px 700px at 85% 0%, rgba(139,233,253,.16), transparent 55%),
        radial-gradient(1200px 900px at 50% 120%, rgba(110,231,183,.10), transparent 60%),
        linear-gradient(180deg, var(--bg), #070a14 70%);
      line-height:1.55;
      overflow-x:hidden;
    }

    header{
      position:relative;
      padding:40px 18px 18px;
      max-width:1200px;
      margin:0 auto;
    }
    .titlebar{
      background:linear-gradient(135deg, rgba(139,233,253,.13), rgba(167,139,250,.10));
      border:1px solid var(--line);
      border-radius:calc(var(--radius) + 6px);
      box-shadow:var(--shadow);
      padding:24px 22px;
      overflow:hidden;
    }
    .titlebar:before{
      content:"";
      position:absolute;
      inset:-2px;
      background:radial-gradient(800px 260px at 30% 10%, rgba(139,233,253,.18), transparent 70%);
      pointer-events:none;
      filter:blur(6px);
    }
    h1{
      margin:0 0 6px;
      font-size:clamp(1.35rem, 2.2vw + 1rem, 2.35rem);
      letter-spacing:.2px;
      position:relative;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size:clamp(.95rem, 1vw + .7rem, 1.12rem);
      position:relative;
    }

    .layout{
      max-width:1200px;
      margin:18px auto 60px;
      padding:0 18px;
      display:grid;
      grid-template-columns: 280px 1fr;
      gap:18px;
      align-items:start;
    }

    nav.toc{
      position:sticky;
      top:16px;
      background:rgba(15,23,48,.72);
      backdrop-filter: blur(10px);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:14px 14px 10px;
    }
    nav.toc h2{
      margin:4px 6px 8px;
      font-size:1.02rem;
      color:var(--text);
      letter-spacing:.2px;
    }
    .toc a{
      display:block;
      padding:9px 10px;
      margin:6px 0;
      border-radius:12px;
      color:var(--muted);
      text-decoration:none;
      border:1px solid transparent;
      transition:transform .15s ease, background .15s ease, border-color .15s ease;
    }
    .toc a:hover{
      background:rgba(255,255,255,.06);
      border-color:var(--line);
      transform:translateY(-1px);
      color:var(--text);
    }
    .toc .mini{
      margin-top:10px;
      padding-top:10px;
      border-top:1px dashed var(--line2);
      color:var(--faint);
      font-size:.92rem;
    }

    main{
      min-width:0;
    }

    section, article{
      background:rgba(17,28,58,.62);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:18px;
      margin-bottom:18px;
      position:relative;
      overflow:hidden;
    }
    section:before, article:before{
      content:"";
      position:absolute;
      inset:-1px;
      background:radial-gradient(900px 260px at 10% 0%, rgba(139,233,253,.10), transparent 50%);
      pointer-events:none;
    }
    h2{
      margin:0 0 10px;
      font-size:1.25rem;
      letter-spacing:.2px;
      position:relative;
    }
    h3{
      margin:14px 0 8px;
      font-size:1.05rem;
      color:var(--text);
      position:relative;
    }
    p, li{ color:var(--muted); position:relative; }
    ul{ margin:8px 0 8px 22px; }
    .grid2{
      display:grid;
      grid-template-columns: 1.25fr .85fr;
      gap:14px;
      align-items:start;
    }
    .grid3{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:12px;
      align-items:stretch;
    }
    .card{
      background:rgba(15,23,48,.70);
      border:1px solid var(--line);
      border-radius:16px;
      padding:14px;
      box-shadow: 0 10px 22px rgba(0,0,0,.25);
      position:relative;
      overflow:hidden;
    }
    .card:after{
      content:"";
      position:absolute;
      width:180px; height:180px;
      right:-90px; top:-90px;
      background:radial-gradient(circle, rgba(167,139,250,.20), transparent 65%);
      filter:blur(1px);
      pointer-events:none;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size:.88rem;
      color:var(--text);
      background:rgba(255,255,255,.06);
      border:1px solid var(--line);
      padding:6px 10px;
      border-radius:999px;
      margin-bottom:10px;
    }
    .dot{
      width:10px; height:10px;
      border-radius:50%;
      background:var(--accent);
      box-shadow:0 0 0 4px rgba(139,233,253,.12);
    }
    .callout{
      border-left:4px solid var(--accent);
      padding:10px 12px;
      background:rgba(139,233,253,.07);
      border-radius:14px;
      border:1px solid rgba(139,233,253,.18);
    }
    .warn{
      border-left-color:var(--warn);
      background:rgba(253,230,138,.07);
      border-color:rgba(253,230,138,.18);
    }
    .good{
      border-left-color:var(--good);
      background:rgba(110,231,183,.07);
      border-color:rgba(110,231,183,.18);
    }

    code, pre{
      font-family:var(--mono);
      color:#f2f6ff;
    }
    pre{
      margin:10px 0 0;
      background:rgba(7,10,20,.65);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      overflow:auto;
    }
    .eqline{
      display:flex;
      gap:10px;
      align-items:stretch;
      margin-top:10px;
    }
    .eqline pre{ flex:1; margin:0; }
    .copyBtn{
      flex:0 0 auto;
      align-self:stretch;
      border-radius:14px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      cursor:pointer;
      transition:transform .15s ease, background .15s ease, border-color .15s ease;
      min-width:96px;
      font-weight:600;
    }
    .copyBtn:hover{
      transform:translateY(-1px);
      background:rgba(255,255,255,.09);
      border-color:rgba(255,255,255,.20);
    }
    .copyBtn:active{ transform:translateY(0px) scale(.99); }
    .copyNote{
      margin-top:6px;
      font-size:.9rem;
      color:var(--faint);
    }

    figure{
      margin:0;
      position:relative;
    }
    .canvasWrap{
      border:1px solid var(--line);
      border-radius:16px;
      overflow:hidden;
      background:rgba(7,10,20,.45);
      box-shadow: 0 10px 22px rgba(0,0,0,.25);
    }
    canvas{
      display:block;
      width:100%;
      height:320px;
    }
    .canvasCaption{
      display:flex;
      justify-content:space-between;
      gap:12px;
      padding:10px 12px;
      border-top:1px solid var(--line);
      color:var(--faint);
      font-size:.92rem;
      background:rgba(15,23,48,.55);
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    .control{
      background:rgba(15,23,48,.70);
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px;
    }
    label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      color:var(--muted);
      font-size:.95rem;
      margin-bottom:8px;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    select, button.small{
      width:100%;
      border-radius:12px;
      padding:10px 10px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--text);
      outline:none;
    }
    button.small{
      cursor:pointer;
      font-weight:700;
      transition:transform .15s ease, background .15s ease;
    }
    button.small:hover{ transform:translateY(-1px); background:rgba(255,255,255,.09); }
    .metaRow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:10px;
      color:var(--faint);
      font-size:.92rem;
    }
    .pill{
      border:1px solid var(--line);
      background:rgba(255,255,255,.05);
      border-radius:999px;
      padding:6px 10px;
    }

    footer{
      max-width:1200px;
      margin:0 auto 40px;
      padding:0 18px;
      color:var(--faint);
      font-size:.92rem;
    }
    .foot{
      border:1px solid var(--line);
      background:rgba(15,23,48,.55);
      border-radius:var(--radius);
      padding:14px 16px;
      box-shadow:var(--shadow);
    }

    /* Subtle motion */
    @media (prefers-reduced-motion: no-preference){
      section, article, nav.toc{
        animation:fadeUp .35s ease both;
      }
      nav.toc{ animation-delay:.05s; }
      section:nth-of-type(1){ animation-delay:.06s; }
      section:nth-of-type(2){ animation-delay:.08s; }
      section:nth-of-type(3){ animation-delay:.10s; }
      @keyframes fadeUp{
        from{ opacity:0; transform:translateY(6px); }
        to{ opacity:1; transform:translateY(0); }
      }
    }

    /* Responsive */
    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
      nav.toc{ position:relative; top:auto; }
      .grid2{ grid-template-columns: 1fr; }
      canvas{ height:300px; }
    }
    @media (max-width: 560px){
      .grid3{ grid-template-columns: 1fr; }
      .controls{ grid-template-columns:1fr; }
      .copyBtn{ min-width:86px; }
      canvas{ height:280px; }
    }

    /* Print-friendly */
    @media print{
      body{ background:#fff; color:#000; }
      nav.toc{ display:none; }
      section, article, .titlebar, .foot{ box-shadow:none; background:#fff; border:1px solid #bbb; }
      .canvasWrap{ border:1px solid #bbb; }
      .copyBtn, .controls, button.small{ display:none !important; }
      p, li{ color:#111; }
      code, pre{ color:#000; background:#f4f4f4; }
    }
  </style>
</head>

<body>
<header>
  <div class="titlebar">
    <h1>Problem 1 — Boundary Conditions at Conductors (Parallel-Plate Waveguide)</h1>
    <p class="subtitle">Two perfectly conducting planes at <code>x=0</code> and <code>x=L</code>. A wave propagates along <code>-z</code> between the plates. Determine the allowed modes, fields, dispersion, velocities, and cutoffs.</p>
  </div>
</header>

<div class="layout">
  <nav class="toc" aria-label="Table of contents">
    <h2>On this page</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#viz">Interactive Visualizations</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <div class="mini">
      Tip: Use the sliders to change <code>L</code>, mode <code>n</code>, and frequency ratio <code>r = ω/ωc</code>. All plots update live.
    </div>
  </nav>

  <main>
    <section id="quick">
      <h2>Quick Summary</h2>
      <div class="grid3">
        <div class="card">
          <div class="badge"><span class="dot"></span><span>Allowed transverse variation</span></div>
          <p>Perfect conductors force the <strong>tangential</strong> electric field to vanish at <code>x=0</code> and <code>x=L</code>, so</p>
          <div class="eqline">
            <pre data-copy="Ey(x,z,t) ∝ sin(nπx/L)">Ey(x,z,t) ∝ sin(nπx/L)</pre>
            <button class="copyBtn" data-copy-target>Copy</button>
          </div>
        </div>
        <div class="card">
          <div class="badge"><span class="dot"></span><span>Dispersion (waveguide)</span></div>
          <p>For vacuum between plates:</p>
          <div class="eqline">
            <pre data-copy="kz = √[(ω/c)^2 − (nπ/L)^2],  ωc = nπc/L">k<sub>z</sub> = √[(ω/c)² − (nπ/L)²],  ω<sub>c</sub> = nπc/L</pre>
            <button class="copyBtn" data-copy-target>Copy</button>
          </div>
          <p class="copyNote">Propagation requires <code>ω &gt; ωc</code>.</p>
        </div>
        <div class="card">
          <div class="badge"><span class="dot"></span><span>Velocities & cutoff</span></div>
          <p>Along <code>z</code> in mode <code>n</code>:</p>
          <div class="eqline">
            <pre data-copy="vp,z = ω/kz = c/√[1−(ωc/ω)^2],   vg,z = dω/dkz = c√[1−(ωc/ω)^2]">v<sub>p,z</sub> = ω/k<sub>z</sub> = c/√[1−(ω<sub>c</sub>/ω)²],   v<sub>g,z</sub> = dω/dk<sub>z</sub> = c√[1−(ω<sub>c</sub>/ω)²]</pre>
            <button class="copyBtn" data-copy-target>Copy</button>
          </div>
          <p class="copyNote">Lowest propagating frequency: <code>ωmin = πc/L</code> (for <code>n=1</code>).</p>
        </div>
      </div>
    </section>

    <section id="viz">
      <h2>Interactive Visualizations</h2>

      <div class="grid2">
        <article class="card" style="padding:14px;">
          <h3 style="margin-top:0;">Controls (updates all canvases)</h3>

          <div class="controls" role="group" aria-label="Interactive controls">
            <div class="control">
              <label for="Lslider">
                <span>Plate spacing <strong>L</strong> (example)</span>
                <span id="Lread" class="pill">0.030 m</span>
              </label>
              <input id="Lslider" type="range" min="0.005" max="0.080" step="0.001" value="0.030" />
              <div class="metaRow">
                <span class="pill">Range: 5–80 mm</span>
                <span class="pill">Vacuum between plates</span>
              </div>
            </div>

            <div class="control">
              <label for="nSelect">
                <span>Mode index <strong>n</strong></span>
                <span id="nread" class="pill">n = 1</span>
              </label>
              <select id="nSelect" aria-label="Mode index">
                <option value="1" selected>n = 1</option>
                <option value="2">n = 2</option>
                <option value="3">n = 3</option>
                <option value="4">n = 4</option>
                <option value="5">n = 5</option>
              </select>
              <div class="metaRow">
                <span class="pill">k<sub>x</sub>=nπ/L</span>
                <span class="pill">Cutoff ω<sub>c</sub>=nπc/L</span>
              </div>
            </div>

            <div class="control" style="grid-column:1 / -1;">
              <label for="rSlider">
                <span>Frequency ratio <strong>r = ω/ω<sub>c</sub></strong></span>
                <span id="rread" class="pill">r = 2.00</span>
              </label>
              <input id="rSlider" type="range" min="1.01" max="6.00" step="0.01" value="2.00" />
              <div class="metaRow" id="derivedPills"></div>
            </div>

            <div class="control" style="grid-column:1 / -1;">
              <button class="small" id="resetBtn" type="button">Reset example values</button>
              <div class="metaRow">
                <span class="pill">Plot 1: dispersion ω vs k<sub>z</sub></span>
                <span class="pill">Plot 2: v<sub>p</sub>, v<sub>g</sub> vs r</span>
                <span class="pill">Plot 3: mode shape E<sub>y</sub>(x)</span>
              </div>
            </div>
          </div>
        </article>

        <article class="card" style="padding:14px;">
          <h3 style="margin-top:0;">What you’re seeing</h3>
          <div class="callout">
            <p style="margin:0;">
              The plates impose <strong>boundary conditions</strong> that quantize the transverse wavenumber <code>k<sub>x</sub></code>.
              That creates a <strong>cutoff</strong> and makes the propagation constant <code>k<sub>z</sub></code> depend on <code>ω</code>.
              The phase velocity can exceed <code>c</code>, but the group velocity stays below <code>c</code> (and carries energy).
            </p>
          </div>
          <div class="callout warn" style="margin-top:10px;">
            <p style="margin:0;">
              Note: values in plots are <strong>example values</strong> (since the problem is symbolic). The final answers below remain symbolic in <code>n, L, c, ω</code>.
            </p>
          </div>
        </article>
      </div>

      <div class="grid2" style="margin-top:14px;">
        <figure class="canvasWrap">
          <canvas id="setupCanvas" aria-label="Diagram of parallel plates and wave"></canvas>
          <figcaption class="canvasCaption">
            <span><strong>Diagram:</strong> geometry, directions, and boundary conditions</span>
            <span class="pill">High-DPI & responsive</span>
          </figcaption>
        </figure>

        <figure class="canvasWrap">
          <canvas id="dispCanvas" aria-label="Dispersion plot"></canvas>
          <figcaption class="canvasCaption">
            <span><strong>Main plot:</strong> dispersion relation (ω vs k<sub>z</sub>)</span>
            <span class="pill">Includes cutoff</span>
          </figcaption>
        </figure>

        <figure class="canvasWrap" style="grid-column:1 / -1;">
          <canvas id="secondaryCanvas" aria-label="Secondary plot"></canvas>
          <figcaption class="canvasCaption">
            <span><strong>Secondary:</strong> velocities & mode shape</span>
            <span class="pill">v<sub>p</sub>, v<sub>g</sub>, and E<sub>y</sub>(x)</span>
          </figcaption>
        </figure>
      </div>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>1) Restate the problem in plain words</h3>
      <p>
        Two very large, perfectly conducting plates are parallel to the <code>yz</code>-plane and located at
        <code>x=0</code> and <code>x=L</code>. An electromagnetic wave travels between them along the negative
        <code>z</code>-direction. The electric field is linearly polarized along <code>y</code>. Because the plates are large,
        we can treat the fields as independent of <code>y</code> (but they may depend on <code>x</code>, <code>z</code>, and <code>t</code>).
        We must enforce conductor boundary conditions to find the allowed waveguide modes and the corresponding dispersion and velocities.
      </p>

      <h3>2) Given quantities, unknowns, and what must be found</h3>
      <div class="grid2">
        <div class="card">
          <div class="badge"><span class="dot"></span><span>Given</span></div>
          <ul>
            <li>Perfect conductors at <code>x=0</code> and <code>x=L</code></li>
            <li>Wave frequency <code>ω</code></li>
            <li>Field polarization (for parts a–d): <code>E</code> along <code>ŷ</code></li>
            <li>Propagation direction: negative <code>z</code></li>
            <li>Vacuum/air between plates ⇒ wave speed <code>c</code></li>
            <li>Fields independent of <code>y</code></li>
          </ul>
        </div>
        <div class="card">
          <div class="badge"><span class="dot"></span><span>Unknowns / To find</span></div>
          <ul>
            <li>(a) The allowed electric field <code>E(x,y,z,t)</code> in the <code>n</code>-th mode</li>
            <li>(b) The corresponding magnetic field: direction + magnitude relationships</li>
            <li>(c) Phase velocity <code>v<sub>p,z</sub></code> and group velocity <code>v<sub>g,z</sub></code> vs <code>ω</code> (mode <code>n</code>)</li>
            <li>(d) Lowest <code>ω</code> that allows propagation in <code>z</code> (cutoff)</li>
            <li>(e) If polarization is along <code>x</code> instead, find <code>v<sub>p,z</sub></code> and <code>v<sub>g,z</sub></code></li>
          </ul>
        </div>
      </div>

      <h3>3) Relevant physical laws and why they apply</h3>
      <ul>
        <li>
          <strong>Conductor boundary condition (PEC):</strong> The tangential electric field at a perfect conductor must vanish:
          <code>E<sub>t</sub>=0</code> at the surface. Here the surface normal is <code>±x̂</code>, so the tangential directions are <code>ŷ</code> and <code>ẑ</code>.
          This directly constrains components like <code>E<sub>y</sub></code> at <code>x=0,L</code>.
        </li>
        <li>
          <strong>Maxwell’s equations in source-free region:</strong> Between plates we assume no free charge/current, so we use
          <code>∇×E = −∂B/∂t</code> and <code>∇×B = (1/c²)∂E/∂t</code> (in vacuum).
          These relate <code>E</code> and <code>B</code>, and yield the wave equation + dispersion relation.
        </li>
        <li>
          <strong>Waveguide mode concept:</strong> Confinement in <code>x</code> quantizes transverse structure (standing wave in <code>x</code>) and produces a cutoff frequency.
        </li>
      </ul>

      <h3>4) 2–3 possible approaches (compare)</h3>
      <div class="grid3">
        <div class="card">
          <div class="badge"><span class="dot"></span><span>Approach A: Solve wave equation + BC</span></div>
          <p>
            Assume harmonic dependence in <code>z</code> and <code>t</code>, solve the Helmholtz equation in <code>x</code>,
            apply <code>E<sub>t</sub>=0</code> at <code>x=0,L</code> to get <code>k<sub>x</sub>=nπ/L</code>,
            then use dispersion <code>k²=(ω/c)²</code>.
          </p>
          <p><strong>Pros:</strong> Direct, systematic, minimal assumptions. <strong>Cons:</strong> Requires careful bookkeeping of components.</p>
        </div>
        <div class="card">
          <div class="badge"><span class="dot"></span><span>Approach B: Use standard waveguide TE/TM formulas</span></div>
          <p>
            Recognize this as a parallel-plate waveguide and identify TE/TM/TEM modes.
            Use known results for cutoff and velocity relations.
          </p>
          <p><strong>Pros:</strong> Fast. <strong>Cons:</strong> Must be confident about which mode class matches the polarization + BC.</p>
        </div>
        <div class="card">
          <div class="badge"><span class="dot"></span><span>Approach C: Use phasors + Maxwell curl equations</span></div>
          <p>
            Start with a guessed form for <code>E</code>, then derive <code>B</code> from <code>∇×E</code> and enforce the other curl equation to obtain dispersion.
          </p>
          <p><strong>Pros:</strong> Efficient for fields. <strong>Cons:</strong> Easy to slip on sign/phase conventions.</p>
        </div>
      </div>

      <h3>5) Best approach (and why)</h3>
      <p class="callout good">
        We’ll use <strong>Approach A</strong> (wave equation + boundary conditions) because the problem explicitly asks to use boundary conditions on the conductor planes.
        This method cleanly produces the allowed <code>x</code>-dependence, then Maxwell’s equations give <code>B</code>, dispersion, velocities, and cutoff.
      </p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

      <h3>Minimal step-by-step plan (no algebra yet)</h3>
      <ol style="color:var(--muted);">
        <li>
          <strong>Set geometry & components.</strong>
          <div class="copyNote">Goal: Decide which field components can be nonzero given polarization and symmetry (<code>∂/∂y=0</code>).</div>
          <div class="copyNote">Tool: Conductor BC (<code>E<sub>t</sub>=0</code>), and propagation along <code>z</code>.</div>
        </li>
        <li>
          <strong>Write a separable traveling-wave ansatz.</strong>
          <div class="copyNote">Goal: Encode propagation in <code>-z</code> and harmonic time dependence.</div>
          <div class="copyNote">Tool: Use <code>e^{i(kz z − ωt)}</code> or equivalent real form with correct direction.</div>
        </li>
        <li>
          <strong>Apply boundary conditions at <code>x=0</code> and <code>x=L</code>.</strong>
          <div class="copyNote">Goal: Quantize transverse wavenumber <code>k<sub>x</sub></code> and pick sin/cos form.</div>
          <div class="copyNote">Tool: Tangential <code>E</code> must vanish on a PEC.</div>
        </li>
        <li>
          <strong>Use the wave equation (or Helmholtz form) to relate <code>k<sub>x</sub></code>, <code>k<sub>z</sub></code>, and <code>ω</code>.</strong>
          <div class="copyNote">Goal: Obtain the dispersion relation and cutoff.</div>
          <div class="copyNote">Tool: <code>k² = (ω/c)²</code> in vacuum, with <code>k² = kx² + kz²</code>.</div>
        </li>
        <li>
          <strong>Derive <code>B</code> from <code>∇×E = −∂B/∂t</code>.</strong>
          <div class="copyNote">Goal: Find the magnetic-field directions and relative magnitudes.</div>
          <div class="copyNote">Tool: Maxwell curl equation + your chosen time dependence convention.</div>
        </li>
        <li>
          <strong>Compute phase and group velocities in the <code>z</code>-direction.</strong>
          <div class="copyNote">Goal: <code>v<sub>p,z</sub>=ω/kz</code> and <code>v<sub>g,z</sub>=dω/dkz</code> using dispersion.</div>
        </li>
        <li>
          <strong>Repeat velocity reasoning for <code>x</code>-polarization.</strong>
          <div class="copyNote">Goal: Recognize the TEM case (no cutoff) for parallel plates when <code>E</code> is normal to plates.</div>
        </li>
      </ol>

      <h3>Common mistakes & quick tips</h3>
      <div class="grid2">
        <div class="callout warn">
          <ul style="margin:0 0 0 18px;">
            <li><strong>BC confusion:</strong> On a PEC, it’s <code>E<sub>t</sub>=0</code> (tangential), not necessarily the normal component.</li>
            <li><strong>Direction sign:</strong> For a wave moving in <code>-z</code>, use phase <code>kz z + ωt</code> in a cosine (or <code>e^{-ikz z}</code> in phasors).</li>
            <li><strong>Cutoff condition:</strong> Propagation requires real <code>kz</code>. If <code>kz</code> is imaginary, the field is evanescent in <code>z</code>.</li>
          </ul>
        </div>
        <div class="callout good">
          <ul style="margin:0 0 0 18px;">
            <li><strong>Define symbols once:</strong> Use <code>k<sub>x</sub>=nπ/L</code>, <code>k<sub>z</sub></code>, <code>ω</code>, <code>c</code> consistently.</li>
            <li><strong>Energy vs phase:</strong> It’s okay if <code>v<sub>p</sub>&gt;c</code>; energy transport follows <code>v<sub>g</sub>&lt;c</code> in a passive waveguide.</li>
            <li><strong>Sanity check:</strong> As <code>ω→∞</code>, confinement becomes less important and <code>v<sub>g</sub>→c</code>.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution</h2>

      <h3>Physical intuition (before the math)</h3>
      <p>
        The plates enforce that the electric field component parallel to them must be zero right on the metal surface.
        Since the plates are at fixed <code>x</code>, any electric field along <code>y</code> is tangential to the plates. Therefore,
        a nonzero <code>E<sub>y</sub></code> in the region <code>0&lt;x&lt;L</code> must form a <strong>standing wave in <code>x</code></strong> with nodes at <code>x=0</code> and <code>x=L</code>.
        This quantizes the transverse wavenumber <code>k<sub>x</sub></code> and leaves a reduced “budget” of wavenumber for propagation along <code>z</code>.
        If the frequency is too low, there isn’t enough total wavenumber to support real propagation in <code>z</code>, producing a cutoff.
      </p>

      <h3>Definitions and conventions</h3>
      <ul>
        <li>Plates: perfect conductors at <code>x=0</code> and <code>x=L</code>.</li>
        <li>Assume vacuum between plates: wave speed <code>c</code>.</li>
        <li>Fields independent of <code>y</code>: <code>∂/∂y = 0</code>.</li>
        <li>We take the dominant electric field polarization for parts (a–d) to be <code>E = E<sub>y</sub>(x,z,t) ŷ</code>.</li>
        <li>Wave propagates in <code>-z</code>: use a real traveling-wave phase <code>cos(k<sub>z</sub> z + ωt)</code> (constant phase implies motion toward decreasing <code>z</code>).</li>
      </ul>

      <h3>(a) Electric field in the <code>n</code>-th mode</h3>
      <p><strong>Step 1: Apply PEC boundary condition.</strong></p>
      <p>
        On a perfect conductor, the tangential electric field must vanish:
        <code>E<sub>t</sub>=0</code>.
        The plates have normal <code>x̂</code>, so tangential directions are <code>ŷ</code> and <code>ẑ</code>.
        Since the wave is <code>ŷ</code>-polarized, <code>E<sub>y</sub></code> is tangential, hence
      </p>
      <div class="eqline">
        <pre data-copy="Ey(0,z,t)=0,   Ey(L,z,t)=0">E<sub>y</sub>(0,z,t)=0,   E<sub>y</sub>(L,z,t)=0</pre>
        <button class="copyBtn" data-copy-target>Copy</button>
      </div>

      <p><strong>Step 2: Choose a separable form and enforce nodes.</strong></p>
      <p>
        A standing wave in <code>x</code> with nodes at both ends is a sine:
        <code>sin(k<sub>x</sub>x)</code>. The boundary at <code>x=L</code> demands
        <code>sin(k<sub>x</sub>L)=0</code>, so
      </p>
      <div class="eqline">
        <pre data-copy="kx = nπ/L,   n=1,2,3,...">k<sub>x</sub> = nπ/L,   n=1,2,3,...</pre>
        <button class="copyBtn" data-copy-target>Copy</button>
      </div>

      <p><strong>Step 3: Write the traveling dependence in <code>z</code> and <code>t</code>.</strong></p>
      <p>
        For propagation in <code>-z</code>, one convenient real form is:
        <code>cos(k<sub>z</sub> z + ωt)</code>. Therefore an allowed modal electric field is
      </p>

      <div class="eqline">
        <pre data-copy="E(x,z,t) = ŷ E_n0 sin(nπx/L) cos(kz z + ωt)">E(x,z,t) = ŷ E<sub>n0</sub> sin(nπx/L) cos(k<sub>z</sub> z + ωt)</pre>
        <button class="copyBtn" data-copy-target>Copy</button>
      </div>

      <p class="copyNote">
        Here <code>E<sub>n0</sub></code> is the mode amplitude (you may set it so the maximum of <code>|E<sub>y</sub>|</code> equals the given amplitude <code>E0</code>).
      </p>

      <h3>(b) Corresponding magnetic field (magnitude and direction)</h3>
      <p>
        Use Maxwell–Faraday:
        <code>∇×E = −∂B/∂t</code>.
        With <code>E = ŷ E<sub>y</sub>(x,z,t)</code> and <code>∂/∂y=0</code>,
        the curl becomes
      </p>
      <div class="eqline">
        <pre data-copy="∇×E = (−∂Ey/∂z) x̂ + (∂Ey/∂x) ẑ">∇×E = (−∂E<sub>y</sub>/∂z) x̂ + (∂E<sub>y</sub>/∂x) ẑ</pre>
        <button class="copyBtn" data-copy-target>Copy</button>
      </div>

      <p>Compute the derivatives for</p>
      <div class="eqline">
        <pre data-copy="Ey = E_n0 sin(kx x) cos(kz z + ωt),  kx=nπ/L">E<sub>y</sub> = E<sub>n0</sub> sin(k<sub>x</sub> x) cos(k<sub>z</sub> z + ωt),  k<sub>x</sub>=nπ/L</pre>
        <button class="copyBtn" data-copy-target>Copy</button>
      </div>

      <p>
        <strong>Derivative in <code>z</code>:</strong> <code>−∂E<sub>y</sub>/∂z = +k<sub>z</sub> E<sub>n0</sub> sin(k<sub>x</sub>x) sin(k<sub>z</sub>z+ωt)</code><br/>
        <strong>Derivative in <code>x</code>:</strong> <code>∂E<sub>y</sub>/∂x = k<sub>x</sub> E<sub>n0</sub> cos(k<sub>x</sub>x) cos(k<sub>z</sub>z+ωt)</code>
      </p>

      <p>
        Now integrate <code>−∂B/∂t = ∇×E</code> componentwise:
        we want <code>B</code> such that its time derivative produces the sine/cosine time factors above.
        A consistent choice is
      </p>

      <div class="eqline">
        <pre data-copy="B(x,z,t) = x̂ (kz/ω) E_n0 sin(kx x) cos(kz z + ωt)  +  ẑ (kx/ω) E_n0 cos(kx x) sin(kz z + ωt)">B(x,z,t) = x̂ (k<sub>z</sub>/ω) E<sub>n0</sub> sin(k<sub>x</sub> x) cos(k<sub>z</sub> z + ωt)  +  ẑ (k<sub>x</sub>/ω) E<sub>n0</sub> cos(k<sub>x</sub> x) sin(k<sub>z</sub> z + ωt)</pre>
        <button class="copyBtn" data-copy-target>Copy</button>
      </div>

      <p class="callout">
        <strong>Direction summary:</strong> <code>B</code> has an <code>x̂</code> component (in phase with <code>E<sub>y</sub></code>) and a <code>ẑ</code> component (quadrature in time, due to the standing variation in <code>x</code>).
        There is no <code>ŷ</code> component for this mode choice.
      </p>

      <p>
        If you only need a typical magnitude scale, the transverse magnetic component satisfies
        <code>|B<sub>x</sub>| ≈ (k<sub>z</sub>/ω)|E<sub>y</sub>|</code>, and since <code>k<sub>z</sub>/ω = 1/v<sub>p,z</sub></code>, it reflects the wave impedance modification in a guide.
      </p>

      <h3>(c) Phase velocity and group velocity in the <code>n</code>-th mode</h3>
      <p><strong>Step 1: Use the vacuum dispersion for the total wavenumber.</strong></p>
      <p>
        In vacuum, harmonic fields satisfy the Helmholtz relation:
        <code>k² = (ω/c)²</code>.
        Here confinement gives
        <code>k² = k<sub>x</sub>² + k<sub>z</sub>²</code>
        with <code>k<sub>x</sub>=nπ/L</code>. Thus
      </p>

      <div class="eqline">
        <pre data-copy="kz = √[(ω/c)^2 − (nπ/L)^2]">k<sub>z</sub> = √[(ω/c)² − (nπ/L)²]</pre>
        <button class="copyBtn" data-copy-target>Copy</button>
      </div>

      <p><strong>Step 2: Phase velocity along z.</strong></p>
      <p>
        By definition (for propagation along <code>z</code>),
        <code>v<sub>p,z</sub> = ω/k<sub>z</sub></code>, so
      </p>

      <div class="eqline">
        <pre data-copy="vp,z(ω) = ω/kz = c / √[1 − (ωc/ω)^2],   where ωc = nπc/L">v<sub>p,z</sub>(ω) = ω/k<sub>z</sub> = c / √[1 − (ω<sub>c</sub>/ω)²],   where ω<sub>c</sub> = nπc/L</pre>
        <button class="copyBtn" data-copy-target>Copy</button>
      </div>

      <p><strong>Step 3: Group velocity along z.</strong></p>
      <p>
        Start from the dispersion written as
        <code>ω² = c²(k<sub>z</sub>² + k<sub>x</sub>²)</code>
        with constant <code>k<sub>x</sub></code> for a fixed mode.
        Differentiate with respect to <code>k<sub>z</sub></code>:
      </p>
      <p>
        <code>2ω (dω/dk<sub>z</sub>) = 2c² k<sub>z</sub></code>
        ⇒
        <code>v<sub>g,z</sub> = dω/dk<sub>z</sub> = c² k<sub>z</sub>/ω</code>.
        Substitute <code>k<sub>z</sub>/ω</code> from above:
      </p>

      <div class="eqline">
        <pre data-copy="vg,z(ω) = c √[1 − (ωc/ω)^2],   with ωc = nπc/L">v<sub>g,z</sub>(ω) = c √[1 − (ω<sub>c</sub>/ω)²],   with ω<sub>c</sub> = nπc/L</pre>
        <button class="copyBtn" data-copy-target>Copy</button>
      </div>

      <p class="callout good">
        A classic waveguide identity follows immediately:
        <strong><code>v<sub>p,z</sub> · v<sub>g,z</sub> = c²</code></strong>
        (for vacuum-filled, lossless waveguides).
      </p>

      <h3>(d) Lowest angular frequency for propagation</h3>
      <p>
        Propagation in <code>z</code> requires a real <code>k<sub>z</sub></code>, i.e.
        <code>(ω/c)² − (nπ/L)² &gt; 0</code>.
        So the cutoff angular frequency for mode <code>n</code> is
      </p>

      <div class="eqline">
        <pre data-copy="ωc(n) = nπc/L">ω<sub>c</sub>(n) = nπc/L</pre>
        <button class="copyBtn" data-copy-target>Copy</button>
      </div>

      <p>
        The <strong>lowest</strong> frequency that allows any propagation corresponds to the smallest allowed <code>n</code>, i.e. <code>n=1</code>:
      </p>

      <div class="eqline">
        <pre data-copy="ωmin = πc/L (for the first propagating mode)">ω<sub>min</sub> = πc/L (for the first propagating mode)</pre>
        <button class="copyBtn" data-copy-target>Copy</button>
      </div>

      <h3>(e) If the radiation is polarized in the <code>x</code>-direction</h3>
      <p>
        If the electric field is primarily along <code>x̂</code>, then it is <strong>normal</strong> to the conducting plates.
        The PEC boundary condition does <em>not</em> force the normal electric field to vanish; instead, it is supported by induced surface charge.
        In a parallel-plate geometry this corresponds to the <strong>TEM mode</strong> (like a transmission line), which has:
      </p>
      <ul>
        <li><code>E</code> transverse (here along <code>x̂</code>)</li>
        <li><code>B</code> transverse (here along <code>ŷ</code>)</li>
        <li>No cutoff: the fields can be uniform across the gap (idealized), so <code>k<sub>x</sub>=0</code></li>
        <li>Dispersion like free space: <code>k<sub>z</sub>=ω/c</code></li>
      </ul>

      <p>Therefore the velocities along <code>z</code> are simply:</p>

      <div class="eqline">
        <pre data-copy="(x-polarized TEM)  kz = ω/c  ⇒  vp,z = c  and  vg,z = c">(x-polarized TEM)  k<sub>z</sub> = ω/c  ⇒  v<sub>p,z</sub> = c  and  v<sub>g,z</sub> = c</pre>
        <button class="copyBtn" data-copy-target>Copy</button>
      </div>

      <h3>Final boxed results (all parts)</h3>
      <div class="callout good" style="border-width:2px;">
        <div class="eqline">
          <pre data-copy="(a)  E = ŷ E_n0 sin(nπx/L) cos(kz z + ωt),  with kx=nπ/L
(b)  B = x̂ (kz/ω) E_n0 sin(kx x) cos(kz z + ωt) + ẑ (kx/ω) E_n0 cos(kx x) sin(kz z + ωt)
(c)  kz = √[(ω/c)^2 − (nπ/L)^2],  vp,z = c/√[1−(ωc/ω)^2],  vg,z = c√[1−(ωc/ω)^2]
(d)  ωc(n)=nπc/L,  ωmin = πc/L
(e)  x-polarized TEM: vp,z = c,  vg,z = c (no cutoff)">⬛ FINAL RESULTS
(a)  E = ŷ E_n0 sin(nπx/L) cos(kz z + ωt),  with kx=nπ/L
(b)  B = x̂ (kz/ω) E_n0 sin(kx x) cos(kz z + ωt) + ẑ (kx/ω) E_n0 cos(kx x) sin(kz z + ωt)
(c)  kz = √[(ω/c)^2 − (nπ/L)^2],  vp,z = c/√[1−(ωc/ω)^2],  vg,z = c√[1−(ωc/ω)^2]
(d)  ωc(n)=nπc/L,  ωmin = πc/L
(e)  x-polarized TEM: vp,z = c,  vg,z = c (no cutoff)</pre>
          <button class="copyBtn" data-copy-target>Copy</button>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <div class="grid2">
        <div class="callout">
          <p style="margin:0;"><strong>Units</strong></p>
          <ul>
            <li><code>nπ/L</code> has units of <code>1/m</code>, as a wavenumber should.</li>
            <li><code>kz</code> has units <code>1/m</code>. <code>ω/c</code> also has units <code>1/m</code>.</li>
            <li><code>v<sub>p</sub>=ω/kz</code> and <code>v<sub>g</sub></code> both have units <code>m/s</code>.</li>
          </ul>
        </div>
        <div class="callout good">
          <p style="margin:0;"><strong>Limits & physical meaning</strong></p>
          <ul>
            <li><strong>Near cutoff:</strong> <code>ω→ωc+</code> ⇒ <code>kz→0</code>, so <code>v<sub>p</sub>→∞</code> while <code>v<sub>g</sub>→0</code> (energy barely propagates).</li>
            <li><strong>High frequency:</strong> <code>ω≫ωc</code> ⇒ <code>kz≈ω/c</code>, so <code>v<sub>p</sub>→c</code> and <code>v<sub>g</sub>→c</code> (approaches free space).</li>
            <li><strong>x-polarized case:</strong> TEM ⇒ no cutoff and both velocities equal <code>c</code>.</li>
          </ul>
        </div>
      </div>
    </section>

  </main>
</div>

<footer>
  <div class="foot">
    <strong>Note:</strong> This article uses example numerical values only for visualization. All final results are symbolic in <code>n</code>, <code>L</code>, <code>c</code>, and <code>ω</code>, as requested.
  </div>
</footer>

<script>
/* ===========================
   Utility: crisp canvas + axes
   =========================== */

function setupHiDPICanvas(canvas, cssHeight){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  const cssW = Math.max(300, rect.width);
  const cssH = cssHeight || rect.height || 320;
  canvas.style.height = cssH + "px";
  canvas.width = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);
  const ctx = canvas.getContext("2d");
  ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  return {ctx, w: cssW, h: cssH, dpr};
}

function lerp(a,b,t){ return a + (b-a)*t; }

function niceTicks(min, max, count){
  // simple "nice" tick generator (no external libs)
  const span = max - min;
  if(span <= 0) return {ticks:[min], step:1};
  const raw = span / Math.max(1, count);
  const mag = Math.pow(10, Math.floor(Math.log10(raw)));
  const norm = raw / mag;
  let step;
  if(norm < 1.5) step = 1 * mag;
  else if(norm < 3) step = 2 * mag;
  else if(norm < 7) step = 5 * mag;
  else step = 10 * mag;
  const start = Math.ceil(min/step)*step;
  const ticks = [];
  for(let x = start; x <= max + 1e-12; x += step) ticks.push(x);
  return {ticks, step};
}

function drawPanelBackground(ctx, w, h){
  // subtle gradient background
  const g = ctx.createLinearGradient(0,0,w,h);
  g.addColorStop(0, "rgba(255,255,255,0.03)");
  g.addColorStop(1, "rgba(255,255,255,0.00)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,w,h);
}

function drawTitle(ctx, w, title){
  ctx.save();
  ctx.fillStyle = "rgba(233,238,252,0.95)";
  ctx.font = "700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText(title, 14, 22);
  ctx.restore();
}

function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, opts={}){
  const {x, y, w, h} = box;
  const padL = 56, padR = 16, padT = 30, padB = 44;
  const plot = {
    x: x + padL, y: y + padT,
    w: w - padL - padR, h: h - padT - padB
  };

  // Grid + ticks
  const xTickInfo = niceTicks(xMin, xMax, opts.xTicks || 6);
  const yTickInfo = niceTicks(yMin, yMax, opts.yTicks || 6);

  // gridlines
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.07)";
  ctx.lineWidth = 1;

  // vertical grid
  for(const tx of xTickInfo.ticks){
    const px = plot.x + (tx - xMin)/(xMax - xMin) * plot.w;
    ctx.beginPath();
    ctx.moveTo(px, plot.y);
    ctx.lineTo(px, plot.y + plot.h);
    ctx.stroke();
  }
  // horizontal grid
  for(const ty of yTickInfo.ticks){
    const py = plot.y + plot.h - (ty - yMin)/(yMax - yMin) * plot.h;
    ctx.beginPath();
    ctx.moveTo(plot.x, py);
    ctx.lineTo(plot.x + plot.w, py);
    ctx.stroke();
  }

  // axes lines
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.beginPath();
  ctx.moveTo(plot.x, plot.y);
  ctx.lineTo(plot.x, plot.y + plot.h);
  ctx.lineTo(plot.x + plot.w, plot.y + plot.h);
  ctx.stroke();

  // tick labels
  ctx.fillStyle = "rgba(184,195,230,0.95)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
  ctx.textAlign = "right";
  ctx.textBaseline = "middle";
  for(const ty of yTickInfo.ticks){
    const py = plot.y + plot.h - (ty - yMin)/(yMax - yMin) * plot.h;
    ctx.fillText(formatNumber(ty, opts.yFmt), plot.x - 8, py);
  }

  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  for(const tx of xTickInfo.ticks){
    const px = plot.x + (tx - xMin)/(xMax - xMin) * plot.w;
    ctx.fillText(formatNumber(tx, opts.xFmt), px, plot.y + plot.h + 8);
  }

  // axis labels
  ctx.fillStyle = "rgba(233,238,252,0.95)";
  ctx.font = "700 12.5px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillText(xLabel, plot.x + plot.w/2, plot.y + plot.h + 26);

  ctx.save();
  ctx.translate(plot.x - 42, plot.y + plot.h/2);
  ctx.rotate(-Math.PI/2);
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  ctx.restore();

  function xToPx(val){ return plot.x + (val - xMin)/(xMax - xMin)*plot.w; }
  function yToPx(val){ return plot.y + plot.h - (val - yMin)/(yMax - yMin)*plot.h; }

  return {plot, xToPx, yToPx};
}

function formatNumber(x, mode){
  if(!isFinite(x)) return "∞";
  const ax = Math.abs(x);
  if(mode === "sci"){
    if(ax === 0) return "0";
    const exp = Math.floor(Math.log10(ax));
    const mant = x / Math.pow(10, exp);
    return mant.toFixed(2) + "e" + exp;
  }
  if(mode === "auto"){
    if(ax >= 1000 || (ax > 0 && ax < 0.01)) return formatNumber(x, "sci");
    if(ax >= 10) return x.toFixed(1);
    if(ax >= 1) return x.toFixed(2);
    return x.toFixed(3);
  }
  // default
  return x.toFixed(2);
}

function strokeLine(ctx, pts, color, width=2){
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.lineJoin = "round";
  ctx.lineCap = "round";
  ctx.beginPath();
  for(let i=0;i<pts.length;i++){
    const p = pts[i];
    if(i===0) ctx.moveTo(p[0], p[1]);
    else ctx.lineTo(p[0], p[1]);
  }
  ctx.stroke();
  ctx.restore();
}

function drawLegend(ctx, items, x, y){
  ctx.save();
  ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";
  let yy = y;
  for(const it of items){
    ctx.fillStyle = it.color;
    ctx.fillRect(x, yy-6, 14, 3);
    ctx.fillStyle = "rgba(233,238,252,0.92)";
    ctx.fillText(it.label, x+20, yy-4);
    yy += 18;
  }
  ctx.restore();
}

/* ===========================
   Physics (symbolic relations)
   =========================== */
const C = 299792458; // m/s

function omega_c(n, L){ return n * Math.PI * C / L; }
function kx(n, L){ return n * Math.PI / L; }
function kz_from_omega(omega, n, L){
  const val = (omega/C)**2 - (kx(n,L))**2;
  return val > 0 ? Math.sqrt(val) : 0;
}
function vpz(omega, n, L){
  const kz = kz_from_omega(omega, n, L);
  return kz > 0 ? omega / kz : Infinity;
}
function vgz(omega, n, L){
  const oc = omega_c(n,L);
  if(omega <= oc) return 0;
  return C * Math.sqrt(1 - (oc/omega)**2);
}

/* ===========================
   Canvases: diagram + plots
   =========================== */
const canv = {
  setup: document.getElementById("setupCanvas"),
  disp: document.getElementById("dispCanvas"),
  sec: document.getElementById("secondaryCanvas")
};

function drawSetupDiagram(state){
  const {ctx,w,h} = setupHiDPICanvas(canv.setup, 320);
  ctx.clearRect(0,0,w,h);
  drawPanelBackground(ctx,w,h);
  drawTitle(ctx,w,"Parallel plates + wave (mode constraints)");

  const margin = 22;
  const x0 = margin, y0 = 42;
  const W = w - 2*margin, H = h - margin - 52;

  // Plate positions in the diagram (as vertical slabs)
  const plateLeft = x0 + 0.18*W;
  const plateRight = x0 + 0.82*W;
  const plateTop = y0 + 0.10*H;
  const plateBot = y0 + 0.92*H;

  // region
  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,0.03)";
  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(plateLeft, plateTop, plateRight-plateLeft, plateBot-plateTop, 16);
  ctx.fill();
  ctx.stroke();
  ctx.restore();

  // plates
  ctx.save();
  ctx.fillStyle = "rgba(233,238,252,0.18)";
  ctx.strokeStyle = "rgba(255,255,255,0.16)";
  ctx.lineWidth = 1;
  const plateW = 10;
  ctx.fillRect(plateLeft-plateW, plateTop, plateW, plateBot-plateTop);
  ctx.fillRect(plateRight, plateTop, plateW, plateBot-plateTop);
  ctx.restore();

  // labels x=0 and x=L
  ctx.save();
  ctx.fillStyle = "rgba(233,238,252,0.95)";
  ctx.font = "700 12.5px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.textAlign = "center";
  ctx.fillText("PEC plate @ x=0", plateLeft-plateW, plateTop-10);
  ctx.fillText("PEC plate @ x=L", plateRight+plateW, plateTop-10);
  ctx.restore();

  // draw axes arrows
  const origin = {x: x0 + 0.10*W, y: y0 + 0.82*H};

  function arrow(x1,y1,x2,y2,color,label){
    const ang = Math.atan2(y2-y1, x2-x1);
    const head = 10;
    ctx.save();
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2 - head*Math.cos(ang - Math.PI/7), y2 - head*Math.sin(ang - Math.PI/7));
    ctx.lineTo(x2 - head*Math.cos(ang + Math.PI/7), y2 - head*Math.sin(ang + Math.PI/7));
    ctx.closePath();
    ctx.fill();
    ctx.font = "700 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(label, x2 + 10*Math.cos(ang), y2 + 10*Math.sin(ang) - 4);
    ctx.restore();
  }

  arrow(origin.x, origin.y, origin.x+70, origin.y, "rgba(139,233,253,0.95)", "x");
  arrow(origin.x, origin.y, origin.x, origin.y-70, "rgba(167,139,250,0.95)", "y");
  arrow(origin.x, origin.y, origin.x+52, origin.y-52, "rgba(110,231,183,0.95)", "z");

  // Wave propagation in -z (arrow)
  ctx.save();
  const midX = (plateLeft + plateRight)/2;
  const midY = (plateTop + plateBot)/2;
  arrow(midX+70, midY+60, midX+12, midY+2, "rgba(253,230,138,0.95)", "propagate −z");
  ctx.restore();

  // Electric field polarization along y (arrow)
  ctx.save();
  arrow(midX-30, midY+55, midX-30, midY+5, "rgba(139,233,253,0.95)", "E ∥ y");
  ctx.restore();

  // Draw mode shape nodes at plates (sin profile sketch)
  ctx.save();
  ctx.strokeStyle = "rgba(139,233,253,0.75)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  const n = state.n;
  const steps = 240;
  for(let i=0;i<=steps;i++){
    const t = i/steps;
    const x = lerp(plateLeft, plateRight, t);
    const val = Math.sin(n*Math.PI*t); // nodes at t=0,1
    const y = midY - val*48;
    if(i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.restore();

  // Text notes
  ctx.save();
  ctx.fillStyle = "rgba(184,195,230,0.95)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
  ctx.textAlign = "left";
  ctx.fillText("Boundary: Ey(0)=Ey(L)=0  ⇒  Ey ∝ sin(nπx/L)", x0+18, y0+18);
  ctx.fillText(`Example: n=${state.n}  |  L=${state.L.toFixed(3)} m`, x0+18, y0+36);
  ctx.restore();
}

function drawDispersionPlot(state){
  const {ctx,w,h} = setupHiDPICanvas(canv.disp, 320);
  ctx.clearRect(0,0,w,h);
  drawPanelBackground(ctx,w,h);
  drawTitle(ctx,w,"Dispersion: ω vs k_z (mode n)");

  const n = state.n, L = state.L;
  const oc = omega_c(n,L);
  const omegaMax = state.omega * 1.35; // around current omega
  const omegaMin = 0;

  // kz range: from 0 to ωmax/c
  const kzMax = omegaMax / C;
  const kzMin = 0;

  const axes = drawAxes(
    ctx,
    {x:0,y:0,w:w,h:h},
    kzMin, kzMax,
    omegaMin, omegaMax,
    "k_z (rad/m)",
    "ω (rad/s)",
    {xFmt:"auto", yFmt:"sci", xTicks:6, yTicks:6}
  );

  // plot curve ω(kz) = c sqrt(kz^2 + kx^2)
  const kxv = kx(n,L);
  const pts = [];
  const N = 260;
  for(let i=0;i<=N;i++){
    const kzv = lerp(kzMin, kzMax, i/N);
    const om = C*Math.sqrt(kzv*kzv + kxv*kxv);
    pts.push([axes.xToPx(kzv), axes.yToPx(om)]);
  }
  strokeLine(ctx, pts, "rgba(139,233,253,0.95)", 2.5);

  // cutoff line ω=ωc
  ctx.save();
  ctx.strokeStyle = "rgba(253,230,138,0.85)";
  ctx.setLineDash([6,6]);
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(axes.plot.x, axes.yToPx(oc));
  ctx.lineTo(axes.plot.x + axes.plot.w, axes.yToPx(oc));
  ctx.stroke();
  ctx.restore();

  // current point (kz, omega)
  const kzNow = kz_from_omega(state.omega,n,L);
  ctx.save();
  ctx.fillStyle = "rgba(110,231,183,0.95)";
  ctx.beginPath();
  ctx.arc(axes.xToPx(kzNow), axes.yToPx(state.omega), 4.5, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // legend
  drawLegend(ctx, [
    {color:"rgba(139,233,253,0.95)", label:"ω = c√(kz² + kx²)"},
    {color:"rgba(253,230,138,0.85)", label:"cutoff ωc"},
    {color:"rgba(110,231,183,0.95)", label:"current (ω,kz)"}
  ], 14, 46);

  // annotate ωc
  ctx.save();
  ctx.fillStyle = "rgba(184,195,230,0.95)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
  ctx.textAlign = "left";
  ctx.fillText(`ωc = nπc/L = ${formatNumber(oc, "sci")} rad/s`, 14, h-16);
  ctx.restore();
}

function drawSecondary(state){
  const {ctx,w,h} = setupHiDPICanvas(canv.sec, 340);
  ctx.clearRect(0,0,w,h);
  drawPanelBackground(ctx,w,h);
  drawTitle(ctx,w,"Secondary: velocities vs r and mode shape E_y(x)");

  const n = state.n, L = state.L;
  const oc = omega_c(n,L);

  // Split canvas into two panels
  const pad = 14;
  const mid = Math.floor(w*0.58);
  const leftBox = {x:0, y:0, w:mid, h:h};
  const rightBox = {x:mid, y:0, w:w-mid, h:h};

  // Left: vp and vg vs r
  const rMin = 1.01, rMax = 6.0;
  const vpMin = 0, vpMax = 3.2*C; // clip
  const vgMin = 0, vgMax = 1.05*C;

  const axesL = drawAxes(
    ctx, leftBox,
    rMin, rMax,
    0, 3.2, // plot in units of c for readability
    "r = ω/ωc (dimensionless)",
    "Velocity / c",
    {xFmt:"auto", yFmt:"auto", xTicks:6, yTicks:6}
  );

  // curves
  const ptsVp = [];
  const ptsVg = [];
  const N = 240;
  for(let i=0;i<=N;i++){
    const r = lerp(rMin, rMax, i/N);
    const omega = r * oc;
    const vp = vpz(omega,n,L);
    const vg = vgz(omega,n,L);
    const vpNorm = Math.min(3.2, vp / C);
    const vgNorm = Math.min(3.2, vg / C);
    ptsVp.push([axesL.xToPx(r), axesL.yToPx(vpNorm)]);
    ptsVg.push([axesL.xToPx(r), axesL.yToPx(vgNorm)]);
  }
  strokeLine(ctx, ptsVp, "rgba(167,139,250,0.95)", 2.5);
  strokeLine(ctx, ptsVg, "rgba(110,231,183,0.95)", 2.5);

  // current markers
  const rNow = state.r;
  const vpNow = vpz(state.omega,n,L);
  const vgNow = vgz(state.omega,n,L);
  const vpN = Math.min(3.2, vpNow/C);
  const vgN = Math.min(3.2, vgNow/C);

  ctx.save();
  ctx.fillStyle = "rgba(167,139,250,0.95)";
  ctx.beginPath();
  ctx.arc(axesL.xToPx(rNow), axesL.yToPx(vpN), 4.2, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = "rgba(110,231,183,0.95)";
  ctx.beginPath();
  ctx.arc(axesL.xToPx(rNow), axesL.yToPx(vgN), 4.2, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  drawLegend(ctx, [
    {color:"rgba(167,139,250,0.95)", label:"vp,z / c"},
    {color:"rgba(110,231,183,0.95)", label:"vg,z / c"}
  ], leftBox.x + 14, 46);

  // Right: mode shape Ey(x)
  const axesR = drawAxes(
    ctx, rightBox,
    0, L,
    -1.1, 1.1,
    "x (m)",
    "Ey / Ey,max",
    {xFmt:"auto", yFmt:"auto", xTicks:5, yTicks:5}
  );

  const ptsMode = [];
  const M = 300;
  for(let i=0;i<=M;i++){
    const x = (i/M)*L;
    const val = Math.sin(n*Math.PI*x/L); // normalized already to max=1
    ptsMode.push([axesR.xToPx(x), axesR.yToPx(val)]);
  }
  strokeLine(ctx, ptsMode, "rgba(139,233,253,0.95)", 2.5);

  // nodes highlight
  ctx.save();
  ctx.fillStyle = "rgba(253,230,138,0.95)";
  const nodes = n+1;
  for(let k=0;k<nodes;k++){
    const x = (k/n)*L; // x = kL/n ; includes 0 and L
    const px = axesR.xToPx(x);
    const py = axesR.yToPx(0);
    ctx.beginPath();
    ctx.arc(px, py, 3.5, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();

  drawLegend(ctx, [
    {color:"rgba(139,233,253,0.95)", label:"Ey ∝ sin(nπx/L)"},
    {color:"rgba(253,230,138,0.95)", label:"nodes (Ey=0)"}
  ], rightBox.x + 14, 46);

  // Divider
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(mid, 28);
  ctx.lineTo(mid, h-18);
  ctx.stroke();
  ctx.restore();
}

/* ===========================
   State + UI wiring
   =========================== */

const UI = {
  L: document.getElementById("Lslider"),
  n: document.getElementById("nSelect"),
  r: document.getElementById("rSlider"),
  Lread: document.getElementById("Lread"),
  nread: document.getElementById("nread"),
  rread: document.getElementById("rread"),
  derived: document.getElementById("derivedPills"),
  reset: document.getElementById("resetBtn")
};

let state = {
  L: parseFloat(UI.L.value),
  n: parseInt(UI.n.value, 10),
  r: parseFloat(UI.r.value),
  omega: 0
};

function refreshDerived(){
  const oc = omega_c(state.n, state.L);
  state.omega = state.r * oc;
  const kzNow = kz_from_omega(state.omega, state.n, state.L);
  const vp = vpz(state.omega, state.n, state.L);
  const vg = vgz(state.omega, state.n, state.L);

  UI.Lread.textContent = state.L.toFixed(3) + " m";
  UI.nread.textContent = "n = " + state.n;
  UI.rread.textContent = "r = " + state.r.toFixed(2);

  UI.derived.innerHTML = "";
  const pills = [
    `ωc = ${formatNumber(oc, "sci")} rad/s`,
    `ω = ${formatNumber(state.omega, "sci")} rad/s`,
    `kz = ${formatNumber(kzNow, "auto")} rad/m`,
    `vp,z/c = ${isFinite(vp) ? (vp/C).toFixed(2) : "∞"}`,
    `vg,z/c = ${(vg/C).toFixed(2)}`
  ];
  for(const t of pills){
    const span = document.createElement("span");
    span.className = "pill";
    span.textContent = t;
    UI.derived.appendChild(span);
  }
}

function redrawAll(){
  refreshDerived();
  drawSetupDiagram(state);
  drawDispersionPlot(state);
  drawSecondary(state);
}

// Event listeners
UI.L.addEventListener("input", () => {
  state.L = parseFloat(UI.L.value);
  redrawAll();
});
UI.n.addEventListener("change", () => {
  state.n = parseInt(UI.n.value, 10);
  // keep r >= 1.01 to ensure propagating in plots
  state.r = Math.max(1.01, parseFloat(UI.r.value));
  redrawAll();
});
UI.r.addEventListener("input", () => {
  state.r = parseFloat(UI.r.value);
  redrawAll();
});
UI.reset.addEventListener("click", () => {
  UI.L.value = "0.030";
  UI.n.value = "1";
  UI.r.value = "2.00";
  state.L = 0.030;
  state.n = 1;
  state.r = 2.00;
  redrawAll();
});

// Redraw on resize (debounced)
let resizeTimer = null;
window.addEventListener("resize", () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(redrawAll, 120);
});

/* ===========================
   Copy buttons (plain text)
   =========================== */
function attachCopyButtons(){
  const btns = document.querySelectorAll("[data-copy-target]");
  btns.forEach(btn => {
    btn.addEventListener("click", async () => {
      const pre = btn.parentElement.querySelector("pre[data-copy]");
      if(!pre) return;
      const text = pre.getAttribute("data-copy") || pre.textContent || "";
      try{
        await navigator.clipboard.writeText(text);
        const old = btn.textContent;
        btn.textContent = "Copied!";
        btn.style.borderColor = "rgba(110,231,183,0.55)";
        btn.style.background = "rgba(110,231,183,0.10)";
        setTimeout(() => {
          btn.textContent = old;
          btn.style.borderColor = "";
          btn.style.background = "";
        }, 900);
      }catch(e){
        // fallback
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
        btn.textContent = "Copied!";
        setTimeout(() => btn.textContent = "Copy", 900);
      }
    });
  });
}

/* ===========================
   Smooth scroll for TOC
   =========================== */
function smoothTOC(){
  const links = document.querySelectorAll('nav.toc a[href^="#"]');
  links.forEach(a => {
    a.addEventListener("click", (e) => {
      e.preventDefault();
      const id = a.getAttribute("href").slice(1);
      const el = document.getElementById(id);
      if(el){
        el.scrollIntoView({behavior:"smooth", block:"start"});
      }
    });
  });
}

// init
attachCopyButtons();
smoothTOC();
redrawAll();
</script>
</body>
</html>
