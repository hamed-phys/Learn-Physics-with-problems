<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Reflection of Light at an Air–Glass Interface (Fresnel Reflection)</title>
  <style>
    :root{
      --bg: #0b0f17;
      --card: rgba(255,255,255,0.06);
      --card2: rgba(255,255,255,0.085);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.72);
      --faint: rgba(255,255,255,0.55);
      --line: rgba(255,255,255,0.14);
      --accent: #7dd3fc;
      --accent2: #a7f3d0;
      --warn: #fbbf24;
      --good: #34d399;
      --bad: #fb7185;
      --shadow: 0 18px 60px rgba(0,0,0,0.45);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing: border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background:
        radial-gradient(1200px 800px at 12% 20%, rgba(125,211,252,0.16), transparent 55%),
        radial-gradient(900px 700px at 85% 15%, rgba(167,243,208,0.12), transparent 60%),
        radial-gradient(800px 900px at 50% 100%, rgba(251,191,36,0.08), transparent 55%),
        linear-gradient(180deg, #070a10, #0b0f17 35%, #070a10);
      line-height: 1.55;
      overflow-x: hidden;
    }

    a{ color: var(--accent); text-decoration: none; }
    a:hover{ text-decoration: underline; }

    header{
      position: relative;
      padding: clamp(18px, 3.5vw, 34px) 0 10px 0;
    }
    .wrap{
      width: min(1200px, calc(100% - 36px));
      margin: 0 auto;
    }

    .hero{
      display: grid;
      grid-template-columns: 1.35fr 0.65fr;
      gap: 18px;
      align-items: stretch;
    }
    @media (max-width: 980px){
      .hero{ grid-template-columns: 1fr; }
    }

    .titleCard{
      background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 20px 20px 16px 20px;
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
      transform: translateZ(0);
      animation: floatIn 700ms ease-out both;
    }
    .titleCard::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(900px 220px at 18% 10%, rgba(125,211,252,0.18), transparent 65%),
                  radial-gradient(800px 220px at 85% 0%, rgba(167,243,208,0.12), transparent 60%);
      pointer-events:none;
      filter: blur(0px);
    }

    @keyframes floatIn{
      from{ opacity:0; transform: translateY(10px); }
      to{ opacity:1; transform: translateY(0px); }
    }

    h1{
      margin: 0 0 8px 0;
      font-size: clamp(22px, 2.2vw, 34px);
      letter-spacing: -0.02em;
    }
    .subtitle{
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }

    .metaRow{
      display:flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 12px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 7px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--muted);
      font-size: 12.5px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .dot{
      width: 7px; height: 7px; border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(125,211,252,0.12);
    }

    .quick{
      background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.04));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow);
      animation: floatIn 800ms ease-out both;
      animation-delay: 60ms;
      position: relative;
      overflow: hidden;
    }
    .quick h2{
      margin:0 0 10px 0;
      font-size: 15px;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.82);
    }
    .quick ul{
      margin: 0;
      padding-left: 18px;
      color: var(--muted);
      font-size: 13.5px;
    }
    .quick li{ margin: 6px 0; }

    main{
      padding: 10px 0 44px 0;
    }

    .layout{
      display: grid;
      grid-template-columns: 290px 1fr;
      gap: 18px;
      align-items: start;
    }
    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
    }

    nav.toc{
      position: sticky;
      top: 14px;
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      max-height: calc(100vh - 28px);
      overflow: auto;
    }
    nav.toc h3{
      margin: 0 0 10px 0;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(255,255,255,0.78);
    }
    .toc a{
      display: block;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid transparent;
      color: rgba(255,255,255,0.76);
      font-size: 13.5px;
      margin: 6px 0;
      transition: 180ms ease;
    }
    .toc a:hover{
      background: rgba(125,211,252,0.10);
      border-color: rgba(125,211,252,0.20);
      color: rgba(255,255,255,0.90);
      text-decoration: none;
    }

    .content{
      display: grid;
      grid-template-columns: 1fr;
      gap: 18px;
      min-width: 0;
    }

    section.card{
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    section.card h2{
      margin: 0 0 10px 0;
      font-size: 18px;
      letter-spacing: -0.01em;
    }
    section.card h3{
      margin: 14px 0 8px 0;
      font-size: 15px;
      color: rgba(255,255,255,0.86);
    }
    p{ margin: 10px 0; color: var(--muted); }
    ul,ol{ color: var(--muted); }
    li{ margin: 6px 0; }

    .grid2{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
      align-items: start;
    }
    @media (max-width: 900px){
      .grid2{ grid-template-columns: 1fr; }
    }

    .callout{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      padding: 14px;
    }
    .callout strong{ color: rgba(255,255,255,0.92); }
    .callout .label{
      display:flex;
      align-items:center;
      gap:10px;
      margin-bottom: 10px;
      color: rgba(255,255,255,0.85);
      font-weight: 650;
      letter-spacing: -0.01em;
    }
    .badge{
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.05);
      color: rgba(255,255,255,0.80);
    }

    .equationBlock{
      position: relative;
      border-radius: 16px;
      border: 1px solid rgba(125,211,252,0.20);
      background: linear-gradient(180deg, rgba(125,211,252,0.08), rgba(255,255,255,0.03));
      padding: 14px 14px 12px 14px;
      overflow: hidden;
    }
    pre.eq{
      margin: 0;
      font-family: var(--mono);
      font-size: 13px;
      color: rgba(255,255,255,0.88);
      white-space: pre-wrap;
      word-break: break-word;
      line-height: 1.45;
    }
    .copyBtn{
      position:absolute;
      top:10px;
      right:10px;
      border: 1px solid rgba(255,255,255,0.20);
      background: rgba(0,0,0,0.20);
      color: rgba(255,255,255,0.86);
      padding: 7px 10px;
      border-radius: 12px;
      font-size: 12px;
      cursor: pointer;
      transition: 180ms ease;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(125,211,252,0.16);
      border-color: rgba(125,211,252,0.30);
    }
    .copyBtn:active{ transform: translateY(0px); }

    .controls{
      display:flex;
      flex-wrap: wrap;
      gap: 10px 12px;
      align-items: end;
      justify-content: space-between;
    }
    .control{
      min-width: 220px;
      flex: 1 1 220px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      border-radius: 16px;
      padding: 12px;
    }
    .control label{
      display:flex;
      justify-content: space-between;
      gap: 10px;
      align-items: baseline;
      font-size: 12.5px;
      color: rgba(255,255,255,0.82);
      margin-bottom: 8px;
    }
    .control .val{
      font-family: var(--mono);
      color: rgba(255,255,255,0.86);
      font-size: 12.5px;
    }
    input[type="range"]{
      width: 100%;
      accent-color: var(--accent);
    }
    input[type="number"]{
      width: 100%;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.20);
      color: rgba(255,255,255,0.88);
      outline: none;
      font-family: var(--mono);
    }

    .vizGrid{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      .vizGrid{ grid-template-columns: 1fr; }
    }

    figure.viz{
      margin: 0;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
      padding: 12px;
      overflow: hidden;
    }
    figure.viz figcaption{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      margin-top: 10px;
      color: rgba(255,255,255,0.72);
      font-size: 12.5px;
    }
    canvas{
      width: 100%;
      height: 280px;
      display: block;
      border-radius: 14px;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .big canvas{ height: 340px; }
    .small canvas{ height: 250px; }

    .answerBox{
      border-radius: 18px;
      border: 1px solid rgba(167,243,208,0.24);
      background: linear-gradient(180deg, rgba(167,243,208,0.10), rgba(255,255,255,0.03));
      padding: 14px;
      position: relative;
      overflow: hidden;
    }
    .answerBox::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(700px 280px at 20% 0%, rgba(167,243,208,0.18), transparent 60%);
      pointer-events:none;
    }
    .answerGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
      position: relative;
      z-index: 1;
    }
    @media (max-width: 900px){
      .answerGrid{ grid-template-columns: 1fr; }
    }
    .metric{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.22);
      padding: 12px;
    }
    .metric .k{
      font-size: 12px;
      color: rgba(255,255,255,0.70);
      margin-bottom: 6px;
    }
    .metric .v{
      font-family: var(--mono);
      font-size: 15px;
      color: rgba(255,255,255,0.90);
    }

    .foot{
      margin-top: 18px;
      border-top: 1px solid rgba(255,255,255,0.12);
      padding-top: 14px;
      color: rgba(255,255,255,0.60);
      font-size: 12.5px;
    }

    /* subtle motion */
    .glowHover{
      transition: 180ms ease;
    }
    .glowHover:hover{
      box-shadow: 0 20px 70px rgba(125,211,252,0.10);
      transform: translateY(-1px);
    }

    /* print */
    @media print{
      body{
        background: white !important;
        color: #111 !important;
      }
      nav.toc{ display:none !important; }
      .wrap{ width: 100% !important; margin: 0 !important; }
      section.card, .titleCard, .quick{
        box-shadow: none !important;
        background: white !important;
        border: 1px solid #ddd !important;
      }
      canvas{ border: 1px solid #ddd !important; background: white !important; }
      .copyBtn{ display:none !important; }
      a{ color: #0b61a4 !important; text-decoration: underline !important; }
    }
  </style>
</head>

<body>
<header>
  <div class="wrap hero">
    <article class="titleCard">
      <h1>Problem 5 — Reflection of light (Fresnel reflection)</h1>
      <p class="subtitle">
        Unpolarized light in air (λ = 500 nm) hits a glass plate at θ<sub>i</sub> = 40°. Glass index: n<sub>2</sub> = 1.5.
        Find the reflected fraction of 10 kW from the <em>front face</em> and the degree of linear polarization of the reflected beam.
      </p>
      <div class="metaRow">
        <span class="pill"><span class="dot"></span>Interface optics • Fresnel coefficients</span>
        <span class="pill"><span class="dot" style="background:var(--accent2); box-shadow:0 0 0 4px rgba(167,243,208,0.12)"></span>Unpolarized → partially polarized after reflection</span>
        <span class="pill"><span class="dot" style="background:var(--warn); box-shadow:0 0 0 4px rgba(251,191,36,0.12)"></span>Angle-dependent (Brewster angle insight)</span>
      </div>
    </article>

    <aside class="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li>Use Snell’s law to get the transmitted angle θ<sub>t</sub>.</li>
        <li>Use Fresnel reflection coefficients for s and p polarizations: R<sub>s</sub>, R<sub>p</sub>.</li>
        <li>For unpolarized incident light: R = (R<sub>s</sub> + R<sub>p</sub>)/2.</li>
        <li>Reflected power: P<sub>r</sub> = R·P<sub>in</sub>.</li>
        <li>Degree of linear polarization (DoLP) of reflected light:
          DoLP = (R<sub>s</sub> − R<sub>p</sub>)/(R<sub>s</sub> + R<sub>p</sub>).</li>
      </ul>
    </aside>
  </div>
</header>

<main>
  <div class="wrap layout">
    <nav class="toc" aria-label="Table of contents">
      <h3>Table of Contents</h3>
      <a href="#interactive">Interactive Explorer</a>
      <a href="#part1">PART 1 — Problem Analysis</a>
      <a href="#part2">PART 2 — Strategy & Tips</a>
      <a href="#part3">PART 3 — Full Solution</a>
      <a href="#sanity">Sanity Checks</a>
      <a href="#final">Final Answers (boxed)</a>
    </nav>

    <div class="content">
      <!-- Interactive block -->
      <section id="interactive" class="card glowHover">
        <h2>Interactive Explorer (same parameters as the solution)</h2>
        <p>
          Use the slider(s) to change incidence angle and glass index. The diagram and both plots update live, and the computed
          reflectance, reflected power, and polarization update accordingly.
        </p>

        <div class="controls" role="group" aria-label="Interactive controls">
          <div class="control">
            <label for="thetaSlider">
              <span>Incidence angle θ<sub>i</sub> (degrees)</span>
              <span class="val" id="thetaVal">40.0°</span>
            </label>
            <input id="thetaSlider" type="range" min="0" max="85" step="0.1" value="40" />
          </div>

          <div class="control">
            <label for="n2Slider">
              <span>Glass refractive index n<sub>2</sub></span>
              <span class="val" id="n2Val">1.50</span>
            </label>
            <input id="n2Slider" type="range" min="1.10" max="2.20" step="0.01" value="1.50" />
          </div>

          <div class="control">
            <label for="powerInput">
              <span>Incident power P<sub>in</sub> (kW)</span>
              <span class="val" id="powerHint">given: 10 kW</span>
            </label>
            <input id="powerInput" type="number" min="0" step="0.1" value="10" />
          </div>
        </div>

        <div class="answerBox" style="margin-top:14px;">
          <button class="copyBtn" id="copyLive">Copy live results</button>
          <div class="answerGrid">
            <div class="metric">
              <div class="k">Transmitted angle θ<sub>t</sub> (Snell)</div>
              <div class="v" id="thetaTOut">25.37°</div>
            </div>
            <div class="metric">
              <div class="k">Reflectance (unpolarized) R = (R<sub>s</sub>+R<sub>p</sub>)/2</div>
              <div class="v" id="Rout">0.04573</div>
            </div>
            <div class="metric">
              <div class="k">Reflected power P<sub>r</sub> = R·P<sub>in</sub></div>
              <div class="v" id="PrOut">0.457 kW</div>
            </div>
            <div class="metric">
              <div class="k">Degree of linear polarization (DoLP)</div>
              <div class="v" id="DoLPOut">0.687</div>
            </div>
          </div>
        </div>

        <div class="vizGrid" style="margin-top:14px;">
          <figure class="viz big">
            <canvas id="setupCanvas" aria-label="Diagram of incidence and reflection at an interface"></canvas>
            <figcaption>
              <span><strong>Diagram:</strong> air → glass interface geometry (s/p meaning shown)</span>
              <span class="val" id="setupNote">n1=1.00 → n2=1.50</span>
            </figcaption>
          </figure>

          <figure class="viz big">
            <canvas id="mainPlot" aria-label="Plot of Fresnel reflectance vs incidence angle"></canvas>
            <figcaption>
              <span><strong>Main plot:</strong> R<sub>s</sub>, R<sub>p</sub>, and unpolarized R vs θ<sub>i</sub></span>
              <span class="val" id="brewsterNote">Brewster angle shown (if applicable)</span>
            </figcaption>
          </figure>

          <figure class="viz small">
            <canvas id="secondaryPlot" aria-label="Plot of degree of linear polarization vs incidence angle"></canvas>
            <figcaption>
              <span><strong>Secondary plot:</strong> DoLP of reflected light vs θ<sub>i</sub></span>
              <span class="val" id="secondaryNote">DoLP = (Rs−Rp)/(Rs+Rp)</span>
            </figcaption>
          </figure>

          <figure class="viz small">
            <canvas id="sweepPlot" aria-label="Parameter sweep plot of unpolarized reflectance vs refractive index"></canvas>
            <figcaption>
              <span><strong>Parameter sweep:</strong> R (unpolarized) vs n<sub>2</sub> at current θ<sub>i</sub></span>
              <span class="val" id="sweepNote">θi fixed (slider)</span>
            </figcaption>
          </figure>
        </div>
      </section>

      <!-- PART 1 -->
      <section id="part1" class="card">
        <h2>PART 1 — Problem Analysis (no solving yet)</h2>

        <h3>1) Restate the problem (in my own words)</h3>
        <p>
          An unpolarized light beam in air (wavelength 500 nm, but we treat the interface as non-dispersive here)
          hits a flat glass surface at an incidence angle of 40° (measured from the normal). The glass has refractive
          index 1.5. We must determine (a) what fraction of the incident power (10 kW) is reflected from the <em>front</em>
          air–glass interface, and (b) how strongly linearly polarized the reflected light becomes.
        </p>

        <div class="grid2">
          <div class="callout">
            <div class="label"><span class="badge">Given</span> Quantities</div>
            <ul>
              <li>Incident medium (air): n<sub>1</sub> = 1.00</li>
              <li>Glass: n<sub>2</sub> = 1.50</li>
              <li>Incidence angle: θ<sub>i</sub> = 40°</li>
              <li>Incident power: P<sub>in</sub> = 10 kW</li>
              <li>Wavelength: λ = 500 nm (does not enter Fresnel power ratios if n is given and non-absorbing)</li>
              <li>Light is <strong>unpolarized</strong></li>
            </ul>
          </div>

          <div class="callout">
            <div class="label"><span class="badge">Unknowns</span> What we need</div>
            <ul>
              <li>Reflected power fraction from the front face: R (unpolarized)</li>
              <li>Reflected power: P<sub>r</sub> = R·P<sub>in</sub></li>
              <li>Degree of linear polarization of reflected light: DoLP</li>
            </ul>
            <p style="margin-top:8px;">
              <strong>Must be found/proved:</strong> numerical values at θ<sub>i</sub>=40°, n<sub>2</sub>=1.5.
            </p>
          </div>
        </div>

        <h3>2) Relevant physical principles (and why they apply)</h3>
        <ul>
          <li>
            <strong>Snell’s law</strong> (refraction at an interface): relates θ<sub>i</sub> and θ<sub>t</sub> because the tangential
            component of the wavevector is conserved across a planar boundary.
          </li>
          <li>
            <strong>Fresnel equations</strong> (reflection/transmission amplitudes): apply because the interface is planar and we match
            electromagnetic boundary conditions (tangential E and H) for s and p polarizations.
          </li>
          <li>
            <strong>Unpolarized light averaging</strong>: unpolarized means equal incident intensities in s and p; thus the reflected fraction is
            the average of the two polarization reflectances.
          </li>
          <li>
            <strong>Polarization after reflection</strong>: because R<sub>s</sub> ≠ R<sub>p</sub> in general, the reflected beam becomes partially
            linearly polarized.
          </li>
        </ul>

        <h3>3) Candidate approaches (2–3) and comparison</h3>
        <ol>
          <li>
            <strong>Direct Fresnel-power method (best)</strong>: compute θ<sub>t</sub> via Snell, then compute R<sub>s</sub>, R<sub>p</sub>, average for unpolarized,
            then compute DoLP. Most direct, minimal assumptions, standard for dielectric interfaces.
          </li>
          <li>
            <strong>Brewster-angle reasoning + approximation</strong>: near Brewster angle, R<sub>p</sub> → 0, giving intuition for polarization. However, still needs
            Fresnel formulas for accurate numeric values at 40°.
          </li>
          <li>
            <strong>Field boundary-condition derivation from Maxwell</strong>: most fundamental and educational, but longer than necessary for this problem; it reproduces Fresnel coefficients.
          </li>
        </ol>

        <h3>4) Chosen approach and justification</h3>
        <p>
          We use the <strong>direct Fresnel-power method</strong> because the problem gives refractive indices and angle, and asks for reflected fraction and polarization.
          Fresnel reflectance formulas are exactly designed for this situation and yield the required quantitative answers efficiently and rigorously.
        </p>
      </section>

      <!-- PART 2 -->
      <section id="part2" class="card">
        <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

        <h3>Minimal step-by-step plan (no algebra yet)</h3>
        <ol>
          <li>
            <strong>Goal:</strong> determine the transmitted angle θ<sub>t</sub>. <br/>
            <strong>Tool:</strong> Snell’s law: n<sub>1</sub> sinθ<sub>i</sub> = n<sub>2</sub> sinθ<sub>t</sub>.
          </li>
          <li>
            <strong>Goal:</strong> compute reflection coefficients for s and p polarizations. <br/>
            <strong>Tool:</strong> Fresnel reflectance (power) formulas R<sub>s</sub>, R<sub>p</sub>.
          </li>
          <li>
            <strong>Goal:</strong> get reflected fraction for unpolarized incident light. <br/>
            <strong>Tool:</strong> average: R = (R<sub>s</sub> + R<sub>p</sub>)/2.
          </li>
          <li>
            <strong>Goal:</strong> convert reflectance into reflected power. <br/>
            <strong>Tool:</strong> P<sub>r</sub> = R·P<sub>in</sub>.
          </li>
          <li>
            <strong>Goal:</strong> compute the reflected beam’s degree of linear polarization. <br/>
            <strong>Tool:</strong> DoLP = (I<sub>s</sub> − I<sub>p</sub>)/(I<sub>s</sub> + I<sub>p</sub>) with
            I<sub>s</sub>∝R<sub>s</sub>, I<sub>p</sub>∝R<sub>p</sub> for unpolarized input.
          </li>
          <li>
            <strong>Goal:</strong> sanity checks. <br/>
            <strong>Tool:</strong> check 0 ≤ R ≤ 1, units, and limits (normal incidence, Brewster angle behavior).
          </li>
        </ol>

        <h3>Common mistakes & quick tips</h3>
        <ul>
          <li><strong>Angle definition:</strong> θ<sub>i</sub> is measured from the normal (as stated). Don’t use grazing-angle by mistake.</li>
          <li><strong>Unpolarized averaging:</strong> average the <em>intensities</em> (R<sub>s</sub>, R<sub>p</sub>), not the field amplitudes.</li>
          <li><strong>DoLP formula:</strong> use reflected intensities: DoLP = (R<sub>s</sub>−R<sub>p</sub>)/(R<sub>s</sub>+R<sub>p</sub>) for unpolarized incidence.</li>
          <li><strong>Wavelength:</strong> λ does not enter unless n depends on λ (dispersion) or absorption exists; here n is given as a constant.</li>
        </ul>
      </section>

      <!-- PART 3 -->
      <section id="part3" class="card">
        <h2>PART 3 — Full Solution</h2>

        <h3>Physical intuition first</h3>
        <p>
          A dielectric interface reflects because the electromagnetic wave must satisfy boundary conditions at the boundary. The reflection depends on how the electric field is oriented
          relative to the plane of incidence:
        </p>
        <ul>
          <li>
            <strong>s-polarization</strong>: electric field perpendicular to the plane of incidence. It generally reflects more strongly.
          </li>
          <li>
            <strong>p-polarization</strong>: electric field parallel to the plane of incidence. It can reflect much less and even vanish at the <em>Brewster angle</em>.
          </li>
        </ul>
        <p>
          Since the incident beam is unpolarized (equal s and p intensity on average), the reflected beam contains unequal s and p parts → it becomes partially linearly polarized.
        </p>

        <h3>Step 1 — Refraction angle from Snell’s law</h3>
        <div class="equationBlock">
          <button class="copyBtn" data-copy="snell">Copy</button>
          <pre class="eq" id="snellEq">Snell's law:
n1 sin(θi) = n2 sin(θt)

So:
sin(θt) = (n1/n2) sin(θi)</pre>
        </div>
        <p>
          With n<sub>1</sub>=1.00, n<sub>2</sub>=1.50, θ<sub>i</sub>=40°:
        </p>
        <div class="equationBlock">
          <button class="copyBtn" data-copy="thetaT">Copy</button>
          <pre class="eq" id="thetaTEq">sin(θt) = (1.00/1.50) sin(40°) = 0.4285
θt = arcsin(0.4285) ≈ 25.37°</pre>
        </div>

        <h3>Step 2 — Fresnel reflectances for s and p</h3>
        <p>
          For a non-magnetic, lossless interface, the <em>power</em> reflectances (fraction of incident intensity reflected) are:
        </p>

        <div class="equationBlock">
          <button class="copyBtn" data-copy="fresnel">Copy</button>
          <pre class="eq" id="fresnelEq">Fresnel power reflectances (air→glass):

Rs = | (n1 cosθi − n2 cosθt) / (n1 cosθi + n2 cosθt) |^2
Rp = | (n2 cosθi − n1 cosθt) / (n2 cosθi + n1 cosθt) |^2

Unpolarized reflectance:
R = (Rs + Rp)/2</pre>
        </div>

        <p>
          Compute cosines:
          cosθ<sub>i</sub> = cos(40°) and cosθ<sub>t</sub> = cos(25.37°).
        </p>

        <p>
          Plugging into the Fresnel formulas gives (numerical evaluation):
        </p>
        <div class="equationBlock">
          <button class="copyBtn" data-copy="RsRp">Copy</button>
          <pre class="eq" id="RsRpEq">At θi = 40°, n1 = 1.00, n2 = 1.50:

Rs ≈ 0.07716
Rp ≈ 0.01431</pre>
        </div>

        <h3>Step 3 — Fraction reflected for unpolarized light (part a)</h3>
        <p>
          Unpolarized incident light has equal average incident intensities in s and p, so the reflected fraction is the average:
        </p>
        <div class="equationBlock">
          <button class="copyBtn" data-copy="Runpol">Copy</button>
          <pre class="eq" id="RunpolEq">R = (Rs + Rp)/2
  = (0.07716 + 0.01431)/2
  ≈ 0.04573</pre>
        </div>

        <p>
          Therefore the reflected power from the <strong>front face</strong> is:
        </p>
        <div class="equationBlock">
          <button class="copyBtn" data-copy="Pr">Copy</button>
          <pre class="eq" id="PrEq">Pr = R · Pin
   = 0.04573 × 10 kW
   ≈ 0.457 kW  (≈ 457 W)</pre>
        </div>

        <h3>Step 4 — Degree of linear polarization of the reflected light (part b)</h3>
        <p>
          For unpolarized incidence, the reflected intensities are proportional to R<sub>s</sub> and R<sub>p</sub>:
          I<sub>s</sub> = (1/2)R<sub>s</sub>I<sub>0</sub>, I<sub>p</sub> = (1/2)R<sub>p</sub>I<sub>0</sub>.
          The factor 1/2 cancels in the polarization ratio.
        </p>
        <div class="equationBlock">
          <button class="copyBtn" data-copy="dolp">Copy</button>
          <pre class="eq" id="DoLPEq">Degree of linear polarization (DoLP) of reflected beam:

DoLP = (Is − Ip)/(Is + Ip)
     = (Rs − Rp)/(Rs + Rp)

Using Rs ≈ 0.07716, Rp ≈ 0.01431:
DoLP ≈ (0.07716 − 0.01431)/(0.07716 + 0.01431)
     ≈ 0.687  (≈ 68.7%)</pre>
        </div>
        <p>
          Interpretation: the reflected light is significantly linearly polarized, dominated by the s-component (perpendicular to the plane of incidence).
        </p>
      </section>

      <section id="sanity" class="card">
        <h2>Sanity Checks</h2>
        <div class="grid2">
          <div class="callout">
            <div class="label"><span class="badge">Units</span> Check</div>
            <ul>
              <li>R, R<sub>s</sub>, R<sub>p</sub>, DoLP are dimensionless (fractions).</li>
              <li>P<sub>r</sub> has units of power: kW or W. We compute P<sub>r</sub> = R·P<sub>in</sub>, so units match.</li>
            </ul>
          </div>
          <div class="callout">
            <div class="label"><span class="badge">Limits</span> & Physical behavior</div>
            <ul>
              <li><strong>Normal incidence (θ<sub>i</sub>→0):</strong> R<sub>s</sub>=R<sub>p</sub> → reflected light remains unpolarized (DoLP→0).</li>
              <li><strong>Brewster angle:</strong> for air→glass, tanθ<sub>B</sub>=n<sub>2</sub>/n<sub>1</sub>≈1.5 ⇒ θ<sub>B</sub>≈56.3°. Near θ<sub>B</sub>, R<sub>p</sub> becomes very small, so DoLP increases.</li>
              <li><strong>Magnitude:</strong> R≈4.6% is reasonable for an air–glass interface at a moderate angle.</li>
            </ul>
          </div>
        </div>
        <p class="foot">
          Note: This problem asks only about the <em>front face</em> reflection. Multiple internal reflections in a finite-thickness plate
          are ignored unless explicitly stated (and they would require thickness/coherence details).
        </p>
      </section>

      <section id="final" class="card">
        <h2>Final Answers (boxed)</h2>

        <div class="answerBox">
          <button class="copyBtn" id="copyFinal">Copy final answers</button>
          <div class="answerGrid">
            <div class="metric">
              <div class="k">(a) Fraction reflected (unpolarized) at θ<sub>i</sub>=40°, n<sub>2</sub>=1.5</div>
              <div class="v" id="finalR">R ≈ 0.04573 (≈ 4.57%)</div>
            </div>
            <div class="metric">
              <div class="k">(a) Reflected power for P<sub>in</sub>=10 kW</div>
              <div class="v" id="finalPr">P<sub>r</sub> ≈ 0.457 kW (≈ 457 W)</div>
            </div>
            <div class="metric">
              <div class="k">(b) Degree of linear polarization of reflected light</div>
              <div class="v" id="finalDoLP">DoLP ≈ 0.687 (≈ 68.7%)</div>
            </div>
            <div class="metric">
              <div class="k">Helpful intermediate (Snell)</div>
              <div class="v" id="finalThetaT">θ<sub>t</sub> ≈ 25.37°</div>
            </div>
          </div>
        </div>

        <p class="foot">
          If you change θ<sub>i</sub>, n<sub>2</sub>, or P<sub>in</sub> in the explorer above, the numbers update live and the plots/diagram remain consistent with the same physics.
        </p>
      </section>

      <footer class="card">
        <h2 style="margin-bottom:6px;">Footer</h2>
        <p style="margin-top:0;">
          Built as a self-contained HTML article: no external libraries, no MathJax. Interactive visuals rendered via &lt;canvas&gt; and vanilla JavaScript.
        </p>
      </footer>
    </div>
  </div>
</main>

<script>
/* ===========================
   Fresnel + plotting utilities
   =========================== */

(function(){
  const $ = (id)=>document.getElementById(id);

  // Controls
  const thetaSlider = $("thetaSlider");
  const n2Slider = $("n2Slider");
  const powerInput = $("powerInput");

  // Outputs
  const thetaVal = $("thetaVal");
  const n2Val = $("n2Val");
  const thetaTOut = $("thetaTOut");
  const Rout = $("Rout");
  const PrOut = $("PrOut");
  const DoLPOut = $("DoLPOut");
  const setupNote = $("setupNote");
  const brewsterNote = $("brewsterNote");
  const sweepNote = $("sweepNote");

  const finalR = $("finalR");
  const finalPr = $("finalPr");
  const finalDoLP = $("finalDoLP");
  const finalThetaT = $("finalThetaT");

  const n1 = 1.0; // air, fixed for this problem

  function deg2rad(d){ return d*Math.PI/180; }
  function rad2deg(r){ return r*180/Math.PI; }
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

  function fresnel(n1, n2, thetaI){
    // thetaI in radians, measured from normal
    const si = Math.sin(thetaI), ci = Math.cos(thetaI);
    const st = (n1/n2)*si;

    // handle total internal reflection
    if(st > 1){
      return {
        tir: true,
        thetaT: NaN,
        Rs: 1,
        Rp: 1,
        R: 1,
        DoLP: 0
      };
    }
    const thetaT = Math.asin(clamp(st, -1, 1));
    const ct = Math.cos(thetaT);

    const rs = (n1*ci - n2*ct)/(n1*ci + n2*ct);
    const rp = (n2*ci - n1*ct)/(n2*ci + n1*ct);

    const Rs = rs*rs;
    const Rp = rp*rp;
    const R = 0.5*(Rs + Rp);
    const denom = (Rs + Rp);
    const DoLP = denom > 0 ? (Rs - Rp)/denom : 0;

    return { tir:false, thetaT, Rs, Rp, R, DoLP };
  }

  // Canvas + high-DPI setup
  function setupHiDPICanvas(canvas){
    const ctx = canvas.getContext("2d");
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.max(1, Math.floor(rect.width * dpr));
      canvas.height = Math.max(1, Math.floor(rect.height * dpr));
      ctx.setTransform(dpr,0,0,dpr,0,0); // work in CSS pixels
    }
    resize();
    return {ctx, resize};
  }

  // Plot helper
  function drawPlot(ctx, w, h, opts){
    // opts: title, xLabel, yLabel, xMin,xMax,yMin,yMax, series:[{name,color?, data:[{x,y}], strokeStyle, lineWidth}], vlineX (optional)
    // We do not set explicit colors; instead we use auto palette based on strokeStyle from computed theme-friendly defaults.
    ctx.clearRect(0,0,w,h);

    // background
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.fillRect(0,0,w,h);

    const padL=52, padR=16, padT=34, padB=44;
    const plotW = w - padL - padR;
    const plotH = h - padT - padB;

    // axes & grid
    const xMin=opts.xMin, xMax=opts.xMax, yMin=opts.yMin, yMax=opts.yMax;
    const xToPx = (x)=> padL + ( (x - xMin) / (xMax - xMin) )*plotW;
    const yToPx = (y)=> padT + plotH - ( (y - yMin) / (yMax - yMin) )*plotH;

    // gridlines
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;
    const xTicks = opts.xTicks ?? 6;
    const yTicks = opts.yTicks ?? 5;

    for(let i=0;i<=xTicks;i++){
      const x = xMin + (i/xTicks)*(xMax-xMin);
      const xp = xToPx(x);
      ctx.beginPath(); ctx.moveTo(xp, padT); ctx.lineTo(xp, padT+plotH); ctx.stroke();
    }
    for(let j=0;j<=yTicks;j++){
      const y = yMin + (j/yTicks)*(yMax-yMin);
      const yp = yToPx(y);
      ctx.beginPath(); ctx.moveTo(padL, yp); ctx.lineTo(padL+plotW, yp); ctx.stroke();
    }

    // axes
    ctx.strokeStyle = "rgba(255,255,255,0.28)";
    ctx.lineWidth = 1.25;
    ctx.beginPath();
    ctx.moveTo(padL, padT);
    ctx.lineTo(padL, padT+plotH);
    ctx.lineTo(padL+plotW, padT+plotH);
    ctx.stroke();

    // tick labels
    ctx.fillStyle = "rgba(255,255,255,0.72)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    for(let i=0;i<=xTicks;i++){
      const x = xMin + (i/xTicks)*(xMax-xMin);
      const xp = xToPx(x);
      ctx.fillText(formatTick(x, opts.xTickFmt), xp, padT+plotH+8);
      // tick mark
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.beginPath(); ctx.moveTo(xp, padT+plotH); ctx.lineTo(xp, padT+plotH+5); ctx.stroke();
    }

    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    for(let j=0;j<=yTicks;j++){
      const y = yMin + (j/yTicks)*(yMax-yMin);
      const yp = yToPx(y);
      ctx.fillText(formatTick(y, opts.yTickFmt), padL-8, yp);
      // tick mark
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.beginPath(); ctx.moveTo(padL-5, yp); ctx.lineTo(padL, yp); ctx.stroke();
    }

    // title
    ctx.fillStyle = "rgba(255,255,255,0.90)";
    ctx.font = "13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(opts.title ?? "", padL, 10);

    // labels
    ctx.fillStyle = "rgba(255,255,255,0.72)";
    ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.fillText(opts.xLabel ?? "", padL + plotW/2, h-6);

    // y label rotated
    ctx.save();
    ctx.translate(16, padT + plotH/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText(opts.yLabel ?? "", 0, 0);
    ctx.restore();

    // optional vertical line
    if(typeof opts.vlineX === "number"){
      const xvp = xToPx(opts.vlineX);
      ctx.strokeStyle = "rgba(251,191,36,0.65)";
      ctx.setLineDash([6,5]);
      ctx.beginPath(); ctx.moveTo(xvp, padT); ctx.lineTo(xvp, padT+plotH); ctx.stroke();
      ctx.setLineDash([]);
    }

    // series draw
    const palette = [
      "rgba(125,211,252,0.95)", // accent
      "rgba(167,243,208,0.95)", // accent2
      "rgba(255,255,255,0.82)"  // neutral
    ];
    const used = new Set();
    function nextColor(){
      for(const c of palette){
        if(!used.has(c)){ used.add(c); return c; }
      }
      return "rgba(255,255,255,0.82)";
    }

    // legend
    let legendX = padL + 6, legendY = padT + 6;
    const legendPad = 8;

    opts.series.forEach((s, idx)=>{
      const stroke = s.strokeStyle || nextColor();
      s._stroke = stroke;

      // line
      ctx.strokeStyle = stroke;
      ctx.lineWidth = s.lineWidth ?? 2;

      ctx.beginPath();
      const data = s.data;
      for(let i=0;i<data.length;i++){
        const xp = xToPx(data[i].x);
        const yp = yToPx(data[i].y);
        if(i===0) ctx.moveTo(xp, yp);
        else ctx.lineTo(xp, yp);
      }
      ctx.stroke();

      // legend item
      ctx.fillStyle = "rgba(0,0,0,0.38)";
      const label = s.name ?? `series${idx+1}`;
      const textW = measureText(ctx, label, "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial");
      const boxW = 18 + 8 + textW + legendPad*2;
      const boxH = 24;

      ctx.fillRect(legendX, legendY, boxW, boxH);
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.strokeRect(legendX, legendY, boxW, boxH);

      // swatch
      ctx.fillStyle = stroke;
      ctx.fillRect(legendX + legendPad, legendY + 9, 18, 6);

      // text
      ctx.fillStyle = "rgba(255,255,255,0.82)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText(label, legendX + legendPad + 18 + 8, legendY + boxH/2);

      legendY += boxH + 6;
    });

    // marker at current x (if provided)
    if(typeof opts.markerX === "number"){
      const xm = xToPx(opts.markerX);
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.lineWidth = 1.25;
      ctx.setLineDash([4,4]);
      ctx.beginPath(); ctx.moveTo(xm, padT); ctx.lineTo(xm, padT+plotH); ctx.stroke();
      ctx.setLineDash([]);

      // dot markers for each series
      opts.series.forEach((s)=>{
        const data = s.data;
        // find nearest point (data has uniform x)
        let i = Math.round((opts.markerX - xMin)/(xMax-xMin) * (data.length-1));
        i = clamp(i, 0, data.length-1);
        const xp = xToPx(data[i].x);
        const yp = yToPx(data[i].y);
        ctx.fillStyle = s._stroke || "rgba(255,255,255,0.9)";
        ctx.beginPath(); ctx.arc(xp, yp, 4, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,0.35)";
        ctx.lineWidth = 1;
        ctx.stroke();
      });
    }

    function formatTick(val, fmt){
      if(fmt === "deg") return `${val.toFixed(0)}°`;
      if(fmt === "frac2") return val.toFixed(2);
      if(fmt === "frac3") return val.toFixed(3);
      if(fmt === "idx2") return val.toFixed(2);
      return String(val.toFixed(2));
    }
    function measureText(ctx, text, font){
      const prev = ctx.font;
      ctx.font = font;
      const w = ctx.measureText(text).width;
      ctx.font = prev;
      return w;
    }
  }

  // Diagram helper
  function drawSetup(ctx, w, h, state){
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.fillRect(0,0,w,h);

    const pad = 18;
    const cx = w*0.50, cy = h*0.50;

    // Interface horizontal line
    const yInterface = h*0.55;
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(pad, yInterface);
    ctx.lineTo(w-pad, yInterface);
    ctx.stroke();

    // Medium labels
    ctx.font = "13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillStyle = "rgba(255,255,255,0.78)";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(`air  (n₁ = ${state.n1.toFixed(2)})`, pad+2, pad+2);
    ctx.textBaseline = "bottom";
    ctx.fillText(`glass (n₂ = ${state.n2.toFixed(2)})`, pad+2, h-pad-2);

    // Normal line at point of incidence
    const px = w*0.58;
    ctx.strokeStyle = "rgba(251,191,36,0.75)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,4]);
    ctx.beginPath();
    ctx.moveTo(px, yInterface-140);
    ctx.lineTo(px, yInterface+140);
    ctx.stroke();
    ctx.setLineDash([]);

    // Rays (incident, reflected, transmitted)
    const thetaI = state.thetaI;
    const thetaT = state.thetaT;
    const rayLen = 220;

    // incident ray coming from upper-left towards point (px, yInterface)
    const incDir = {x: Math.sin(thetaI), y: Math.cos(thetaI)}; // direction in air towards interface measured from normal
    // Actually from the normal: to go downwards, we need +y; to go from left to right: +x
    const incStart = {
      x: px - incDir.x*rayLen,
      y: yInterface - incDir.y*rayLen
    };

    // reflected: same angle above interface, y component negative
    const refDir = {x: Math.sin(thetaI), y: -Math.cos(thetaI)};
    const refEnd = { x: px + refDir.x*(rayLen*0.75), y: yInterface + refDir.y*(rayLen*0.75) };

    // transmitted: goes into glass (below interface), angle thetaT from normal
    let transEnd = null;
    let tir = state.tir;
    if(!tir){
      const trDir = {x: Math.sin(thetaT), y: Math.cos(thetaT)};
      transEnd = { x: px + trDir.x*(rayLen*0.85), y: yInterface + trDir.y*(rayLen*0.85) };
    }

    // draw incident
    drawArrow(ctx, incStart.x, incStart.y, px, yInterface, "rgba(125,211,252,0.95)", 3);
    // draw reflected
    drawArrow(ctx, px, yInterface, refEnd.x, refEnd.y, "rgba(167,243,208,0.95)", 3);

    // draw transmitted or indicate TIR
    if(!tir){
      drawArrow(ctx, px, yInterface, transEnd.x, transEnd.y, "rgba(255,255,255,0.80)", 3);
    } else {
      ctx.fillStyle = "rgba(251,113,133,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      ctx.fillText("Total internal reflection (no transmitted ray)", w*0.52, yInterface+120);
    }

    // angle arc for theta_i
    drawAngleArc(ctx, px, yInterface, -Math.PI/2, -Math.PI/2 + thetaI, 42, "rgba(125,211,252,0.95)");
    ctx.fillStyle = "rgba(255,255,255,0.86)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillText(`θi = ${rad2deg(thetaI).toFixed(1)}°`, px+50, yInterface-55);

    // angle arc for theta_t
    if(!tir){
      drawAngleArc(ctx, px, yInterface, Math.PI/2, Math.PI/2 - thetaT, 42, "rgba(255,255,255,0.82)");
      ctx.fillStyle = "rgba(255,255,255,0.86)";
      ctx.textAlign = "left";
      ctx.fillText(`θt = ${rad2deg(thetaT).toFixed(2)}°`, px+50, yInterface+55);
    }

    // label plane of incidence and s/p (conceptual)
    ctx.fillStyle = "rgba(255,255,255,0.70)";
    ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.textAlign = "right";
    ctx.textBaseline = "top";
    ctx.fillText("Plane of incidence (page)", w-pad, pad+4);
    ctx.textBaseline = "bottom";
    ctx.fillText("s ⟂ plane, p ∥ plane", w-pad, h-pad-4);

    function drawArrow(ctx, x1,y1,x2,y2,color,width){
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();

      const ang = Math.atan2(y2-y1, x2-x1);
      const head = 10;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(x2,y2);
      ctx.lineTo(x2 - head*Math.cos(ang - Math.PI/7), y2 - head*Math.sin(ang - Math.PI/7));
      ctx.lineTo(x2 - head*Math.cos(ang + Math.PI/7), y2 - head*Math.sin(ang + Math.PI/7));
      ctx.closePath();
      ctx.fill();
    }
    function drawAngleArc(ctx, x,y, a1,a2, r, color){
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x,y, r, a1, a2, false);
      ctx.stroke();
    }
  }

  // Canvas handles
  const setupC = $("setupCanvas");
  const mainC = $("mainPlot");
  const secC = $("secondaryPlot");
  const sweepC = $("sweepPlot");

  const setupHandle = setupHiDPICanvas(setupC);
  const mainHandle = setupHiDPICanvas(mainC);
  const secHandle = setupHiDPICanvas(secC);
  const sweepHandle = setupHiDPICanvas(sweepC);

  function getState(){
    const thetaDeg = parseFloat(thetaSlider.value);
    const n2 = parseFloat(n2Slider.value);
    const pinKW = parseFloat(powerInput.value || "0");
    const thetaI = deg2rad(thetaDeg);
    const fr = fresnel(n1, n2, thetaI);
    return {
      n1, n2, pinKW,
      thetaDeg, thetaI,
      thetaT: fr.thetaT,
      Rs: fr.Rs, Rp: fr.Rp, R: fr.R, DoLP: fr.DoLP,
      tir: fr.tir
    };
  }

  function fmt(x, d=5){ return Number.isFinite(x) ? x.toFixed(d) : "—"; }
  function fmtKW(x){ return Number.isFinite(x) ? `${x.toFixed(3)} kW` : "—"; }
  function fmtW(x){ return Number.isFinite(x) ? `${(x*1000).toFixed(0)} W` : "—"; } // x in kW
  function fmtDeg(x){ return Number.isFinite(x) ? `${x.toFixed(2)}°` : "—"; }

  function updateText(state){
    thetaVal.textContent = `${state.thetaDeg.toFixed(1)}°`;
    n2Val.textContent = `${state.n2.toFixed(2)}`;
    setupNote.textContent = `n1=${state.n1.toFixed(2)} → n2=${state.n2.toFixed(2)}`;

    if(!state.tir){
      thetaTOut.textContent = fmtDeg(rad2deg(state.thetaT));
      finalThetaT.innerHTML = `θ<sub>t</sub> ≈ ${rad2deg(state.thetaT).toFixed(2)}°`;
    } else {
      thetaTOut.textContent = "TIR";
      finalThetaT.innerHTML = `θ<sub>t</sub>: total internal reflection`;
    }

    Rout.textContent = fmt(state.R, 5);
    const prKW = state.R * state.pinKW;
    PrOut.textContent = `${prKW.toFixed(3)} kW (${(prKW*1000).toFixed(0)} W)`;
    DoLPOut.textContent = fmt(state.DoLP, 3);

    // Brewster angle for n1->n2 (only if n2>0)
    const thetaB = Math.atan2(state.n2, state.n1); // tan(thetaB)=n2/n1
    brewsterNote.textContent = `Brewster angle θB ≈ ${rad2deg(thetaB).toFixed(1)}° (Rp→0 near θB)`;
    sweepNote.textContent = `θi fixed at ${state.thetaDeg.toFixed(1)}°`;

    // Final (problem's given values are θi=40°, n2=1.5, Pin=10kW; but we keep it live)
    finalR.textContent = `R ≈ ${state.R.toFixed(5)} (≈ ${(state.R*100).toFixed(2)}%)`;
    finalPr.innerHTML = `P<sub>r</sub> ≈ ${(prKW).toFixed(3)} kW (≈ ${(prKW*1000).toFixed(0)} W)`;
    finalDoLP.textContent = `DoLP ≈ ${state.DoLP.toFixed(3)} (≈ ${(state.DoLP*100).toFixed(1)}%)`;
  }

  function updatePlots(state){
    // Resize canvases for responsive layouts
    setupHandle.resize();
    mainHandle.resize();
    secHandle.resize();
    sweepHandle.resize();

    // Get sizes in CSS pixels
    const r1 = setupC.getBoundingClientRect();
    const r2 = mainC.getBoundingClientRect();
    const r3 = secC.getBoundingClientRect();
    const r4 = sweepC.getBoundingClientRect();

    // Diagram
    drawSetup(setupHandle.ctx, r1.width, r1.height, state);

    // Main plot: Rs, Rp, Runpol vs theta
    const N = 400;
    const xMin = 0, xMax = 85;
    let dataS = [], dataP = [], dataU = [];
    for(let i=0;i<N;i++){
      const th = xMin + (i/(N-1))*(xMax-xMin);
      const fr = fresnel(state.n1, state.n2, deg2rad(th));
      dataS.push({x: th, y: fr.Rs});
      dataP.push({x: th, y: fr.Rp});
      dataU.push({x: th, y: fr.R});
    }

    const ymax = Math.min(1, Math.max(
      ...dataS.map(d=>d.y),
      ...dataP.map(d=>d.y),
      ...dataU.map(d=>d.y),
      0.05
    ));
    const yMax = clamp(ymax*1.10, 0.08, 1.0);

    drawPlot(mainHandle.ctx, r2.width, r2.height, {
      title: "Fresnel reflectance vs incidence angle (air → glass)",
      xLabel: "Incidence angle θi (degrees from normal)",
      yLabel: "Reflectance R (fraction of power)",
      xMin, xMax,
      yMin: 0,
      yMax: yMax,
      xTickFmt: "deg",
      yTickFmt: yMax <= 0.2 ? "frac2" : "frac2",
      series: [
        {name:"Rs (s-pol)", data: dataS},
        {name:"Rp (p-pol)", data: dataP},
        {name:"R unpolarized", data: dataU}
      ],
      vlineX: rad2deg(Math.atan2(state.n2, state.n1)),
      markerX: state.thetaDeg
    });

    // Secondary plot: DoLP vs theta
    let dataD = [];
    for(let i=0;i<N;i++){
      const th = xMin + (i/(N-1))*(xMax-xMin);
      const fr = fresnel(state.n1, state.n2, deg2rad(th));
      dataD.push({x: th, y: fr.DoLP});
    }
    drawPlot(secHandle.ctx, r3.width, r3.height, {
      title: "Degree of linear polarization of reflected light",
      xLabel: "Incidence angle θi (degrees)",
      yLabel: "DoLP (dimensionless)",
      xMin, xMax,
      yMin: 0,
      yMax: 1,
      xTickFmt: "deg",
      yTickFmt: "frac2",
      series: [
        {name:"DoLP", data: dataD}
      ],
      markerX: state.thetaDeg
    });

    // Sweep plot: R vs n2 at current theta
    const nMin = 1.10, nMax = 2.20;
    const M = 300;
    let dataN = [];
    let maxR = 0;
    for(let i=0;i<M;i++){
      const nn = nMin + (i/(M-1))*(nMax-nMin);
      const fr = fresnel(state.n1, nn, state.thetaI);
      dataN.push({x: nn, y: fr.R});
      maxR = Math.max(maxR, fr.R);
    }
    drawPlot(sweepHandle.ctx, r4.width, r4.height, {
      title: "Unpolarized reflectance vs glass index (θi fixed)",
      xLabel: "Glass refractive index n2",
      yLabel: "R (unpolarized)",
      xMin: nMin, xMax: nMax,
      yMin: 0,
      yMax: clamp(maxR*1.15, 0.06, 1.0),
      xTickFmt: "idx2",
      yTickFmt: "frac2",
      series: [
        {name:"R(n2)", data: dataN}
      ],
      markerX: state.n2
    });
  }

  function updateAll(){
    const state = getState();
    updateText(state);
    updatePlots(state);
  }

  // Copy buttons (equations + results)
  function copyText(text){
    if(navigator.clipboard && navigator.clipboard.writeText){
      navigator.clipboard.writeText(text).then(()=>toast("Copied ✅")).catch(()=>fallbackCopy(text));
    } else {
      fallbackCopy(text);
    }
  }
  function fallbackCopy(text){
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    ta.style.top = "0";
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    try{ document.execCommand("copy"); toast("Copied ✅"); }
    catch(e){ toast("Copy failed"); }
    document.body.removeChild(ta);
  }

  // Simple toast
  let toastEl = null, toastTimer = null;
  function toast(msg){
    if(!toastEl){
      toastEl = document.createElement("div");
      toastEl.style.position = "fixed";
      toastEl.style.left = "50%";
      toastEl.style.bottom = "18px";
      toastEl.style.transform = "translateX(-50%)";
      toastEl.style.padding = "10px 14px";
      toastEl.style.borderRadius = "999px";
      toastEl.style.border = "1px solid rgba(255,255,255,0.18)";
      toastEl.style.background = "rgba(0,0,0,0.55)";
      toastEl.style.color = "rgba(255,255,255,0.92)";
      toastEl.style.font = "12.5px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      toastEl.style.backdropFilter = "blur(10px)";
      toastEl.style.webkitBackdropFilter = "blur(10px)";
      toastEl.style.boxShadow = "0 12px 40px rgba(0,0,0,0.35)";
      toastEl.style.zIndex = "9999";
      toastEl.style.opacity = "0";
      toastEl.style.transition = "200ms ease";
      document.body.appendChild(toastEl);
    }
    toastEl.textContent = msg;
    toastEl.style.opacity = "1";
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>{ toastEl.style.opacity = "0"; }, 1200);
  }

  // Wire equation copy buttons
  document.querySelectorAll(".copyBtn[data-copy]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const key = btn.getAttribute("data-copy");
      const map = {
        snell: $("snellEq").innerText,
        thetaT: $("thetaTEq").innerText,
        fresnel: $("fresnelEq").innerText,
        RsRp: $("RsRpEq").innerText,
        Runpol: $("RunpolEq").innerText,
        Pr: $("PrEq").innerText,
        dolp: $("DoLPEq").innerText
      };
      copyText(map[key] || "");
    });
  });

  $("copyFinal").addEventListener("click", ()=>{
    const state = getState();
    const prKW = state.R * state.pinKW;
    const txt =
`Final answers (current slider values):
- θi = ${state.thetaDeg.toFixed(1)} deg, n1 = ${state.n1.toFixed(2)}, n2 = ${state.n2.toFixed(2)}, Pin = ${state.pinKW.toFixed(3)} kW
- θt = ${state.tir ? "TIR" : rad2deg(state.thetaT).toFixed(2) + " deg"}
- R (unpolarized) = ${state.R.toFixed(5)}  (${(state.R*100).toFixed(2)}%)
- Reflected power Pr = ${prKW.toFixed(3)} kW  (${(prKW*1000).toFixed(0)} W)
- DoLP = ${state.DoLP.toFixed(3)}  (${(state.DoLP*100).toFixed(1)}%)`;
    copyText(txt);
  });

  $("copyLive").addEventListener("click", ()=>{
    const state = getState();
    const prKW = state.R * state.pinKW;
    const txt =
`Live results:
theta_i = ${state.thetaDeg.toFixed(1)} deg
n1 = ${state.n1.toFixed(2)}, n2 = ${state.n2.toFixed(2)}
theta_t = ${state.tir ? "TIR" : rad2deg(state.thetaT).toFixed(2) + " deg"}
Rs = ${state.Rs.toFixed(5)}, Rp = ${state.Rp.toFixed(5)}
R_unpolarized = ${state.R.toFixed(5)}
Pin = ${state.pinKW.toFixed(3)} kW
Pr = ${prKW.toFixed(3)} kW (${(prKW*1000).toFixed(0)} W)
DoLP = ${state.DoLP.toFixed(3)}`;
    copyText(txt);
  });

  // Control events
  [thetaSlider, n2Slider, powerInput].forEach(el=>{
    el.addEventListener("input", updateAll);
  });

  // Handle window resize
  window.addEventListener("resize", ()=>{
    updateAll();
  });

  // Initialize: set to the problem's given values and compute once
  thetaSlider.value = "40";
  n2Slider.value = "1.50";
  powerInput.value = "10";
  updateAll();
})();
</script>
</body>
</html>
