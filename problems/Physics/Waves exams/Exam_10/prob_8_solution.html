<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interferometric Radio Telescope (10-Element East–West Array) — Full Solution</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#0f1624;
      --panel2:#111b2c;
      --text:#e9eef7;
      --muted:#a9b4c7;
      --faint:#7f8aa3;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --border:rgba(255,255,255,0.10);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --radius: 16px;
      --radius2: 22px;
    }
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 15% 10%, rgba(125,211,252,0.10), transparent 55%),
        radial-gradient(900px 650px at 85% 20%, rgba(167,139,250,0.10), transparent 60%),
        radial-gradient(900px 700px at 55% 95%, rgba(52,211,153,0.07), transparent 60%),
        var(--bg);
      line-height:1.55;
    }

    /* Layout */
    header{
      position:relative;
      padding:56px 20px 20px;
      border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.03), transparent);
      overflow:hidden;
    }
    header::before{
      content:"";
      position:absolute;
      inset:-80px -120px auto -120px;
      height:220px;
      background: radial-gradient(600px 200px at 50% 30%, rgba(125,211,252,0.12), transparent 65%);
      filter: blur(0px);
      pointer-events:none;
    }
    .wrap{
      max-width:1180px;
      margin:0 auto;
      padding:0 20px 60px;
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:22px;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr}
    }

    .title{
      max-width:1180px;
      margin:0 auto;
      padding:0 20px;
    }
    h1{
      margin:0 0 10px;
      font-size: clamp(1.6rem, 2.6vw, 2.35rem);
      letter-spacing:-0.02em;
    }
    .subtitle{
      color:var(--muted);
      margin:0;
      max-width: 78ch;
    }

    main{padding-top:18px}
    section{
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.015));
      border:1px solid var(--border);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      overflow:hidden;
      animation: floatIn 520ms ease-out both;
    }
    @keyframes floatIn{
      from{transform: translateY(6px); opacity:0.0}
      to{transform: translateY(0); opacity:1}
    }
    .sec-head{
      padding:18px 18px 10px;
      border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.04), transparent);
    }
    .sec-body{padding:18px}
    h2{
      margin:0;
      font-size:1.25rem;
      letter-spacing:-0.01em;
    }
    h3{
      margin:18px 0 8px;
      font-size:1.05rem;
      color:#f1f5ff;
    }
    p{margin:10px 0}
    ul{margin:10px 0 10px 20px; color:var(--text)}
    li{margin:6px 0}
    .muted{color:var(--muted)}
    .faint{color:var(--faint)}
    .divider{
      height:1px;
      background: var(--border);
      margin:16px 0;
    }

    /* Sidebar TOC */
    aside{
      position:sticky;
      top:14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.015));
      border:1px solid var(--border);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      overflow:hidden;
      max-height: calc(100vh - 28px);
    }
    .toc-head{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .toc-title{font-weight:700; font-size:0.95rem}
    .pill{
      font-size:0.75rem;
      padding:5px 9px;
      border-radius:999px;
      color: rgba(255,255,255,0.85);
      border:1px solid var(--border);
      background: rgba(255,255,255,0.02);
    }
    nav.toc{
      padding:10px 12px 14px;
      display:grid;
      gap:8px;
    }
    nav.toc a{
      text-decoration:none;
      color:var(--muted);
      border:1px solid transparent;
      padding:8px 10px;
      border-radius:12px;
      background: rgba(255,255,255,0.00);
      transition: 180ms ease;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    nav.toc a:hover{
      color:var(--text);
      border-color: rgba(255,255,255,0.10);
      background: rgba(125,211,252,0.06);
    }
    nav.toc small{color:var(--faint)}
    @media (max-width: 980px){
      aside{position:relative; top:auto; max-height:none}
    }

    /* Cards + grids */
    .grid-2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    .grid-3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 860px){
      .grid-2,.grid-3{grid-template-columns:1fr}
    }
    .card{
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--radius);
      padding:14px;
    }
    .card h4{
      margin:0 0 8px;
      font-size:0.95rem;
      color:#f4f7ff;
    }
    .callout{
      border-left: 4px solid var(--accent);
      background: rgba(125,211,252,0.06);
    }
    .callout.good{border-left-color: var(--good); background: rgba(52,211,153,0.06)}
    .callout.warn{border-left-color: var(--warn); background: rgba(251,191,36,0.06)}
    .callout.bad{border-left-color: var(--bad); background: rgba(251,113,133,0.06)}

    /* Equation blocks */
    .eq{
      margin:10px 0;
      padding:12px 12px;
      border-radius: 14px;
      border:1px solid var(--border);
      background: rgba(0,0,0,0.22);
      font-family:var(--mono);
      font-size:0.92rem;
      overflow:auto;
      position:relative;
    }
    .eq .copy{
      position:absolute;
      top:8px;
      right:8px;
      font-family:var(--sans);
      font-size:0.78rem;
      padding:7px 10px;
      border-radius: 999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,0.03);
      color: rgba(255,255,255,0.85);
      cursor:pointer;
      transition:180ms ease;
    }
    .eq .copy:hover{background: rgba(125,211,252,0.10); border-color: rgba(125,211,252,0.28)}
    .eq pre{margin:0; white-space:pre; padding-right:110px}
    .boxed{
      border:1px solid rgba(125,211,252,0.35);
      background: rgba(125,211,252,0.08);
      border-radius: 18px;
      padding:14px;
    }
    .boxed h3{margin-top:0}
    .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:5px 10px;
      border-radius: 999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,0.02);
      color: var(--muted);
      font-size:0.8rem;
      margin-right:8px;
      margin-bottom:8px;
    }
    .dot{
      width:8px; height:8px; border-radius:999px; background: var(--accent);
      box-shadow: 0 0 0 4px rgba(125,211,252,0.12);
    }

    /* Controls */
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 860px){ .controls{grid-template-columns:1fr} }
    .control{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.02);
      border-radius: var(--radius);
      padding:12px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:0.85rem;
      color:var(--muted);
      margin-bottom:8px;
    }
    input[type="range"]{width:100%}
    select{
      width:100%;
      padding:10px 10px;
      border-radius: 12px;
      border:1px solid var(--border);
      background: rgba(0,0,0,0.22);
      color: var(--text);
      outline:none;
    }
    .readout{
      font-family:var(--mono);
      font-size:0.85rem;
      color: rgba(255,255,255,0.88);
    }

    /* Canvas figures */
    figure{
      margin:0;
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(0,0,0,0.22), rgba(0,0,0,0.12));
      border-radius: var(--radius2);
      overflow:hidden;
    }
    figcaption{
      padding:10px 12px;
      border-top:1px solid var(--border);
      color: var(--muted);
      font-size:0.85rem;
    }
    canvas{
      display:block;
      width:100%;
      height: 360px;
      background: transparent;
    }
    .canvas-short canvas{height: 300px}
    .canvas-tall canvas{height: 400px}

    /* Footer + print */
    footer{
      max-width:1180px;
      margin:28px auto 0;
      padding:0 20px 40px;
      color: var(--faint);
      font-size:0.9rem;
    }
    @media print{
      body{background:#fff; color:#000}
      header, aside{display:none !important}
      section{box-shadow:none; border:1px solid #ddd}
      .eq{background:#f6f6f6}
      a{color:#000; text-decoration:none}
      canvas{display:none}
      figcaption::after{content:" (Canvas hidden in print view)"; color:#666}
    }
  </style>
</head>

<body>
  <header>
    <div class="title">
      <h1>Problem 8 — Interferometric Radio Telescope (10-Element East–West Array)</h1>
      <p class="subtitle">
        A structured physics-tutor solution (analysis → strategy → full derivation) with interactive array-factor
        visualizations. All equations use the same parameters as the plots.
      </p>
    </div>
  </header>

  <div class="wrap">
    <main>
      <!-- Quick Summary -->
      <section id="summary">
        <div class="sec-head">
          <h2>Quick Summary</h2>
        </div>
        <div class="sec-body">
          <div class="grid-2">
            <div class="card callout">
              <h4>Key ideas</h4>
              <ul>
                <li>A 10-element uniformly spaced array has an <b>array factor</b> that creates narrow interference fringes.</li>
                <li>Maxima occur when the inter-element phase step satisfies <code>k d θ = 2π m</code> (small angles).</li>
                <li>Angular resolution is controlled mainly by the <b>largest baseline</b> (≈ <code>B<sub>max</sub> = (N−1)d</code>), not dish diameter.</li>
                <li>Dish diameter sets the <b>primary beam</b> (field of view envelope), roughly <code>~1.22 λ/D</code>.</li>
              </ul>
            </div>
            <div class="card callout good">
              <h4>Numerical results for the given values</h4>
              <ul>
                <li><span class="tag"><span class="dot"></span>Given</span> <code>N=10</code>, <code>d=800 m</code>, <code>λ=0.06 m</code>, <code>D=25 m</code></li>
                <li><b>First-order peak location</b>: <code>θ₁ = λ/d = 7.5×10⁻⁵ rad</code></li>
                <li><b>Zero-order main-lobe width (null-to-null)</b>: <code>Δθ ≈ 2λ/(N d) = 1.5×10⁻⁵ rad</code></li>
                <li><b>Second-order main-lobe width</b> (from array factor): approximately the same as zero-order</li>
                <li><b>Increase D to 100 m</b>: interferometer resolution ~unchanged; primary beam narrows by factor 4</li>
              </ul>
            </div>
          </div>

          <div class="divider"></div>

          <div class="card">
            <h4>Interactive controls (affect all canvases + derived numbers)</h4>
            <div class="controls">
              <div class="control">
                <label>
                  <span>Spacing <b>d</b> (m)</span>
                  <span class="readout" id="dRead"></span>
                </label>
                <input id="dSlider" type="range" min="100" max="1200" step="10" value="800" />
                <div class="faint">Inter-element separation (E–W). Controls fringe spacing and array main-lobe width.</div>
              </div>
              <div class="control">
                <label>
                  <span>Dish diameter <b>D</b> (m)</span>
                  <span class="readout" id="DRead"></span>
                </label>
                <input id="DSlider" type="range" min="10" max="120" step="1" value="25" />
                <div class="faint">Controls the single-dish (primary beam) envelope ~ 1.22 λ/D.</div>
              </div>
              <div class="control">
                <label>
                  <span>Highlighted order <b>m</b></span>
                  <span class="readout" id="mRead"></span>
                </label>
                <select id="mSelect">
                  <option value="0">m = 0 (zero order)</option>
                  <option value="1" selected>m = 1 (first order)</option>
                  <option value="2">m = 2 (second order)</option>
                  <option value="3">m = 3 (third order)</option>
                </select>
                <div class="faint">Marks the chosen interference maximum θ<sub>m</sub> = m λ/d on the plots.</div>
              </div>
            </div>

            <div class="divider"></div>

            <div class="grid-3">
              <div class="card">
                <h4>Derived (from current controls)</h4>
                <ul class="muted">
                  <li><span class="faint">First-order location:</span> <span class="readout" id="theta1Out"></span></li>
                  <li><span class="faint">Zero-order width (null-to-null):</span> <span class="readout" id="width0Out"></span></li>
                  <li><span class="faint">Array “resolution” ~ λ/B<sub>max</sub>:</span> <span class="readout" id="resOut"></span></li>
                  <li><span class="faint">Primary beam ~ 1.22 λ/D:</span> <span class="readout" id="pbOut"></span></li>
                </ul>
              </div>
              <div class="card callout warn">
                <h4>What the plots show</h4>
                <ul>
                  <li><b>Diagram</b>: array geometry and arrival angle θ in the E–W direction.</li>
                  <li><b>Main plot</b>: intensity vs θ from array factor and with dish envelope.</li>
                  <li><b>Secondary plot</b>: how beam widths compare (array vs dish) as D changes.</li>
                </ul>
              </div>
              <div class="card">
                <h4>Given constants (fixed by the problem)</h4>
                <ul class="muted">
                  <li>Number of dishes: <b>N = 10</b></li>
                  <li>Wavelength: <b>λ = 6 cm = 0.06 m</b></li>
                  <li>Default spacing: <b>d = 800 m</b> (slider can vary for visualization)</li>
                  <li>Default diameter: <b>D = 25 m</b> (slider can vary for part d discussion)</li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Visualizations -->
      <section id="viz">
        <div class="sec-head">
          <h2>Interactive Visualizations</h2>
        </div>
        <div class="sec-body">
          <div class="grid-2">
            <figure class="canvas-short">
              <canvas id="setupCanvas" aria-label="Setup diagram canvas"></canvas>
              <figcaption>
                <b>Diagram:</b> 10 dishes along East–West with spacing d. A plane wave arrives from the south with small E–W
                angle θ, producing an inter-element phase step ψ = k d θ.
              </figcaption>
            </figure>

            <figure class="canvas-short">
              <canvas id="mainPlot" aria-label="Main intensity plot canvas"></canvas>
              <figcaption>
                <b>Main quantitative plot:</b> Array-factor intensity and the total intensity including the dish primary beam envelope.
                Marker shows θ<sub>m</sub> = m λ/d for the selected order.
              </figcaption>
            </figure>
          </div>

          <div style="height:14px"></div>

          <figure class="canvas-tall">
            <canvas id="secondaryPlot" aria-label="Secondary plot canvas"></canvas>
            <figcaption>
              <b>Secondary plot:</b> Beam width comparison versus dish diameter D (array resolution is baseline-limited and nearly constant;
              dish primary beam narrows as 1/D). The current D is highlighted.
            </figcaption>
          </figure>
        </div>
      </section>

      <!-- PART 1 -->
      <section id="part1">
        <div class="sec-head">
          <h2>PART 1 — Problem Analysis (no solving yet)</h2>
        </div>
        <div class="sec-body">
          <h3>1) Restate the problem (in my words)</h3>
          <p>
            We have an interferometric radio telescope made of <b>N = 10</b> identical dishes arranged along the <b>East–West</b> line,
            equally spaced by <b>d = 800 m</b>. The system operates at wavelength <b>λ = 6 cm</b>. First, imagine the dishes are
            transmitters emitting spherical waves <em>in phase</em>. We want the far-field intensity pattern as a function of the small
            observation angle θ (with <code>sinθ ≈ θ</code>).
          </p>
          <p>
            Then we switch back to the real receiving case: a radio source moves in the sky from East to West. Starting at the central
            (zero-order) maximum, how far (in radians) must it move to reach the first-order maximum? Next, estimate the angular widths
            of the zero-order and second-order maxima (narrower = better resolution). Finally, discuss whether increasing dish diameter
            from 25 m to 100 m improves the <em>array</em> angular resolution, and by how much.
          </p>

          <h3>2) Given quantities</h3>
          <ul>
            <li>Number of telescopes: <b>N = 10</b></li>
            <li>Spacing (east–west): <b>d = 800 m</b></li>
            <li>Dish diameter: <b>D = 25 m</b> (later compare to 100 m)</li>
            <li>Wavelength: <b>λ = 6 cm = 0.06 m</b></li>
            <li>Small-angle regime: <b>sinθ ≈ θ</b></li>
          </ul>

          <h3>3) Unknowns</h3>
          <ul>
            <li>(a) Intensity pattern <b>I(θ)</b> for a 10-element in-phase linear array</li>
            <li>(b) Angular shift Δθ to go from m=0 peak to m=1 peak</li>
            <li>(c) Approximate widths (in radians) of the m=0 and m=2 maxima</li>
            <li>(d) Whether increasing D changes the <b>array</b> angular resolution, and by how much</li>
          </ul>

          <h3>4) What must be found/proved</h3>
          <ul>
            <li>Derive and interpret the <b>array factor</b> and its maxima/minima</li>
            <li>Compute peak locations θ<sub>m</sub> and main-lobe widths Δθ</li>
            <li>Separate the roles of <b>interferometer baselines</b> (resolution) vs <b>dish diameter</b> (primary beam / field of view)</li>
          </ul>

          <h3>5) Relevant physical principles (and why they apply)</h3>
          <div class="grid-2">
            <div class="card">
              <h4>Superposition + interference (phasor addition)</h4>
              <p class="muted">
                In the far field, the complex electric fields from each element add:
                <b>E<sub>tot</sub>(θ) = Σ E₀ e^{iφ<sub>n</sub>(θ)}</b>.
                Intensity is proportional to |E|², producing constructive/destructive interference.
              </p>
            </div>
            <div class="card">
              <h4>Far-field (Fraunhofer) approximation</h4>
              <p class="muted">
                For a distant observer/source, rays from different dishes are nearly parallel.
                Path difference between adjacent dishes is approximately <b>d sinθ ≈ dθ</b>, giving a phase step
                <b>ψ = k d θ</b>, where <b>k = 2π/λ</b>.
              </p>
            </div>
          </div>
          <div class="grid-2" style="margin-top:14px">
            <div class="card">
              <h4>Uniform linear array factor</h4>
              <p class="muted">
                With equal spacing and equal amplitudes, the sum is a geometric series with closed form
                (producing the familiar <b>sin(Nx)/sin(x)</b> pattern).
              </p>
            </div>
            <div class="card">
              <h4>Single-dish diffraction envelope (primary beam)</h4>
              <p class="muted">
                Each dish also has its own angular response (Airy pattern for a circular aperture).
                The interferometer response is effectively <b>(array factor) × (element pattern)</b>.
              </p>
            </div>
          </div>

          <h3>6) Candidate approaches (2–3) and comparison</h3>
          <ul>
            <li>
              <b>Geometric path-difference + phasor sum (best)</b>:
              compute phase difference between adjacent dishes, sum complex exponentials, square magnitude.
              Works cleanly for a uniform array and directly yields peak locations and widths.
            </li>
            <li>
              <b>Grating analogy</b>:
              treat the array as a diffraction grating with spacing d.
              Quickly gives maxima at <code>d sinθ = mλ</code>, but less direct for widths and finite-N effects.
            </li>
            <li>
              <b>Fourier optics / aperture synthesis viewpoint</b>:
              interpret the synthesized beam as the Fourier transform of the baseline distribution.
              Powerful conceptually, but more machinery than needed for this finite, uniform array.
            </li>
          </ul>

          <h3>7) Chosen approach and justification</h3>
          <p class="boxed">
            We will use <b>path difference → phase step → uniform-array phasor sum</b>, because it gives:
            (i) exact closed-form intensity for N equal elements, (ii) immediate conditions for maxima/minima,
            and (iii) straightforward small-angle approximations for widths (resolution) and peak positions.
          </p>
        </div>
      </section>

      <!-- PART 2 -->
      <section id="part2">
        <div class="sec-head">
          <h2>PART 2 — Strategy & Tips (roadmap only)</h2>
        </div>
        <div class="sec-body">
          <h3>Roadmap (no algebra yet)</h3>
          <ol>
            <li>
              <b>Define geometry & angle θ</b><br/>
              <span class="muted">Goal:</span> relate θ to extra path between adjacent dishes.<br/>
              <span class="muted">Tool:</span> small-angle path difference <code>Δℓ ≈ d sinθ ≈ dθ</code>.
            </li>
            <li>
              <b>Convert path difference to phase step ψ</b><br/>
              <span class="muted">Goal:</span> write the phase of the n-th dish relative to the first.<br/>
              <span class="muted">Tool:</span> <code>ψ = kΔℓ</code>, with <code>k = 2π/λ</code>.
            </li>
            <li>
              <b>Write the total complex field as a sum</b><br/>
              <span class="muted">Goal:</span> get <code>E(θ)=Σ e^{inψ}</code> for a uniform array.<br/>
              <span class="muted">Tool:</span> superposition of phasors.
            </li>
            <li>
              <b>Evaluate the geometric series (array factor)</b><br/>
              <span class="muted">Goal:</span> closed form in terms of sine ratios.<br/>
              <span class="muted">Tool:</span> geometric-series sum formula.
            </li>
            <li>
              <b>Find maxima locations (orders m)</b><br/>
              <span class="muted">Goal:</span> determine θ where all phasors align (constructive interference).<br/>
              <span class="muted">Tool:</span> condition <code>ψ = 2πm</code>.
            </li>
            <li>
              <b>Estimate main-lobe width (resolution)</b><br/>
              <span class="muted">Goal:</span> find first zeros around a given maximum.<br/>
              <span class="muted">Tool:</span> set numerator sine = 0 → <code>Nψ/2 = ±π</code> near the maximum.
            </li>
            <li>
              <b>Include the single-dish envelope (if needed)</b><br/>
              <span class="muted">Goal:</span> interpret how dish diameter affects field of view and sidelobes.<br/>
              <span class="muted">Tool:</span> primary beam scale <code>~1.22 λ/D</code> (Airy).
            </li>
            <li>
              <b>Answer each subquestion (a–d)</b><br/>
              <span class="muted">Goal:</span> provide symbolic formulas and plug numbers for given parameters.
            </li>
          </ol>

          <div class="divider"></div>

          <div class="grid-2">
            <div class="card callout warn">
              <h4>Common mistakes</h4>
              <ul>
                <li>Using <code>d = 800 m</code> as the <em>maximum baseline</em>. The maximum baseline is <code>B<sub>max</sub> = (N−1)d</code>.</li>
                <li>Mixing up <b>peak spacing</b> (≈ λ/d) with <b>main-lobe width</b> (≈ λ/(N d)).</li>
                <li>Thinking a bigger dish diameter increases interferometer resolution; it mainly narrows the primary beam.</li>
              </ul>
            </div>
            <div class="card callout good">
              <h4>Quick tips</h4>
              <ul>
                <li>Always define <code>k = 2π/λ</code> and keep θ in <b>radians</b>.</li>
                <li>For small angles, <code>sinθ ≈ θ</code> makes the math clean and accurate here.</li>
                <li>For widths, look for the <b>first zeros</b> of the array factor around the maximum.</li>
              </ul>
            </div>
          </div>
        </div>
      </section>

      <!-- PART 3 -->
      <section id="part3">
        <div class="sec-head">
          <h2>PART 3 — Full Solution</h2>
        </div>
        <div class="sec-body">
          <h3>Physical intuition first</h3>
          <p>
            A linear interferometer works like a diffraction grating: each dish samples the incoming wave at a different
            position. If the incoming wavefront is tilted by a small angle θ in the E–W direction, adjacent dishes see a
            small extra path <code>dθ</code>, hence a phase step. When that phase step is an integer multiple of 2π, all
            received (or transmitted) phasors line up and the signal adds strongly (a bright “order”).
          </p>
          <p>
            Because there are only <b>N = 10</b> elements, the maxima are not infinitely sharp; they have a finite width.
            More elements (or a larger effective aperture / baseline) makes the main lobe narrower, improving angular resolution.
          </p>

          <div class="divider"></div>

          <h3>Define symbols (used everywhere below)</h3>
          <ul>
            <li><b>N</b> = number of dishes (10)</li>
            <li><b>d</b> = spacing between adjacent dishes (800 m)</li>
            <li><b>λ</b> = wavelength (0.06 m)</li>
            <li><b>k</b> = wavenumber = <code>2π/λ</code></li>
            <li><b>θ</b> = small E–W observation angle in radians (use <code>sinθ ≈ θ</code>)</li>
            <li><b>ψ</b> = phase step between adjacent dishes = <code>k d θ</code></li>
          </ul>

          <div class="divider"></div>

          <!-- (a) -->
          <h3>(a) Intensity pattern of 10 in-phase transmitters</h3>

          <p>
            In the far field, the path difference between adjacent elements is approximately:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy equation">Copy</button>
            <pre>Δℓ ≈ d sinθ ≈ dθ   (small angles)</pre>
          </div>

          <p>
            That corresponds to a phase difference:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy equation">Copy</button>
            <pre>ψ = kΔℓ = (2π/λ) dθ</pre>
          </div>

          <p>
            If all 10 sources emit with the same amplitude <code>E₀</code> and are initially in phase, the total complex field is
            a phasor sum:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy equation">Copy</button>
            <pre>E(θ) = E₀ Σ_{n=0}^{N-1} e^{i n ψ}</pre>
          </div>

          <p>
            This is a geometric series. Its magnitude squared gives the <b>array-factor intensity</b>:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy equation">Copy</button>
            <pre>AF(θ) = Σ_{n=0}^{N-1} e^{i n ψ}
|AF(θ)|^2 = [ sin(Nψ/2) / sin(ψ/2) ]^2</pre>
          </div>

          <p>
            Therefore, up to an overall scale <code>I₀</code>,
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy equation">Copy</button>
            <pre>I(θ) = I₀ · [ sin(Nψ/2) / sin(ψ/2) ]^2
with  ψ = (2π/λ) dθ</pre>
          </div>

          <p class="muted">
            Sketch-wise: the pattern has a strong central peak at θ=0 (zero order), repeated maxima at θ≈mλ/d,
            and sidelobes between them. Finite N makes maxima have finite width; larger N makes them narrower.
          </p>

          <div class="divider"></div>

          <!-- (b) -->
          <h3>(b) Angular motion from zero-order peak to first-order peak (receiving case)</h3>
          <p>
            Receiving works the same way: the interferometer <em>adds the received E-fields</em> from all dishes.
            A maximum occurs when adjacent dishes differ by a phase step of an integer number of full cycles:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy equation">Copy</button>
            <pre>Constructive interference (order m):  ψ = 2πm</pre>
          </div>

          <p>
            Substitute <code>ψ = (2π/λ)dθ</code>:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy equation">Copy</button>
            <pre>(2π/λ) dθ_m = 2πm  ⇒  θ_m = m(λ/d)</pre>
          </div>

          <p>
            The source starts at the peak of the zero-order maximum (m=0, θ=0). To reach the first-order maximum (m=1),
            it must move by:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy equation">Copy</button>
            <pre>Δθ = θ_1 − θ_0 = λ/d</pre>
          </div>

          <p>
            Numerically:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy number">Copy</button>
            <pre>λ = 0.06 m,  d = 800 m
Δθ = 0.06 / 800 = 0.000075 rad = 7.5×10^-5 rad</pre>
          </div>

          <div class="divider"></div>

          <!-- (c) -->
          <h3>(c) Approximate width of the zero-order maximum and the second-order maximum</h3>
          <p>
            The main lobe around a maximum is bounded by the first zeros of the numerator <code>sin(Nψ/2)</code>.
            Consider the central (m=0) maximum at ψ=0. The first zeros occur when:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy equation">Copy</button>
            <pre>sin(Nψ/2) = 0  ⇒  Nψ/2 = ±π  ⇒  ψ = ±(2π/N)</pre>
          </div>

          <p>
            Convert ψ to θ using <code>ψ = (2π/λ) dθ</code>:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy equation">Copy</button>
            <pre>(2π/λ) d θ_null = 2π/N  ⇒  θ_null ≈ (λ)/(N d)</pre>
          </div>

          <p>
            So the <b>null-to-null width</b> of the m=0 main lobe is approximately:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy equation">Copy</button>
            <pre>Δθ_0 (null-to-null) ≈ 2 θ_null = 2λ/(N d)</pre>
          </div>

          <p>
            Numerically for N=10, d=800 m, λ=0.06 m:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy number">Copy</button>
            <pre>Δθ_0 ≈ 2(0.06)/(10·800) = 0.12/8000 = 1.5×10^-5 rad</pre>
          </div>

          <p>
            What about the <b>second-order</b> maximum (m=2)? Around any maximum, the array factor locally looks the same
            because it depends on deviations δψ from the condition ψ=2πm. The first zeros around ψ=2πm occur at:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy equation">Copy</button>
            <pre>ψ = 2πm ± 2π/N  ⇒  same Δψ = ±2π/N</pre>
          </div>

          <p>
            Therefore, the <b>array-factor</b> width of the second-order main lobe is approximately the same:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy equation">Copy</button>
            <pre>Δθ_2 (null-to-null) ≈ 2λ/(N d)  (same as m=0, from the array factor)</pre>
          </div>

          <p class="muted">
            Important nuance: the <em>total</em> detected pattern is often the product of the array factor and the single-dish primary
            beam. If the dish envelope is narrower than the array maxima spacing, it can suppress high-order peaks far from center.
            But the intrinsic interferometric fringe/main-lobe width set by the array factor is still ≈ 2λ/(N d).
          </p>

          <div class="divider"></div>

          <!-- (d) -->
          <h3>(d) If the dish diameter were 100 m instead of 25 m, would angular resolution increase?</h3>
          <p>
            The interferometer’s finest angular detail is primarily set by the <b>largest baseline</b>:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy equation">Copy</button>
            <pre>B_max = (N−1)d
Interferometric resolution scale:  θ_res ~ λ / B_max</pre>
          </div>

          <p>
            Changing the dish diameter <b>D</b> does not change the telescope positions, hence does not change <code>B<sub>max</sub></code>.
            So the <b>interferometric angular resolution</b> is essentially unchanged.
          </p>

          <p>
            What does change with D is the <b>primary beam</b> (single-dish diffraction envelope), roughly:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy equation">Copy</button>
            <pre>θ_primary ~ 1.22 λ / D</pre>
          </div>

          <p>
            Increasing D from 25 m to 100 m makes <code>θ_primary</code> smaller by a factor of 4:
          </p>
          <div class="eq" data-copy>
            <button class="copy" title="Copy result">Copy</button>
            <pre>θ_primary(100 m) / θ_primary(25 m) = (1/D) ratio = 25/100 = 1/4</pre>
          </div>

          <div class="boxed">
            <h3>Final boxed answers (a–d)</h3>

            <div class="eq" data-copy>
              <button class="copy" title="Copy final answers">Copy</button>
              <pre>(a) For N in-phase elements spaced by d (small angles):
    ψ = (2π/λ)dθ
    I(θ) = I0 [ sin(Nψ/2) / sin(ψ/2) ]^2   (array factor)

(b) Peak locations (order m):
    θm = m(λ/d)
    From m=0 to m=1:  Δθ = λ/d = 0.06/800 = 7.5×10^-5 rad

(c) Main-lobe width (null-to-null) near any order (array factor):
    Δθ ≈ 2λ/(N d) = 2(0.06)/(10·800) = 1.5×10^-5 rad
    So Δθ0 ≈ Δθ2 ≈ 1.5×10^-5 rad (array factor widths)

(d) Increasing dish diameter 25 m → 100 m:
    Interferometric resolution ~ λ/Bmax is unchanged (Bmax=(N−1)d fixed),
    but the primary beam narrows by factor 4 (θ_primary ~ 1.22λ/D).</pre>
            </div>
          </div>

          <div class="divider"></div>

          <h3>Sanity checks</h3>
          <div class="grid-2">
            <div class="card">
              <h4>Units</h4>
              <ul class="muted">
                <li><code>λ/d</code> is meters / meters → dimensionless, appropriate for radians.</li>
                <li><code>2λ/(N d)</code> also dimensionless → radians.</li>
                <li><code>λ/B<sub>max</sub></code> → radians as expected for resolution scale.</li>
              </ul>
            </div>
            <div class="card">
              <h4>Limiting cases + interpretation</h4>
              <ul class="muted">
                <li>If <b>d</b> increases, <code>θ₁=λ/d</code> decreases → fringes get tighter (better angular discrimination).</li>
                <li>If <b>N</b> increases with same d, <code>Δθ ~ 1/N</code> shrinks → narrower main lobe (better resolution).</li>
                <li>If <b>D</b> increases, the primary beam narrows (smaller field of view), but baseline-limited resolution stays ~ fixed.</li>
              </ul>
            </div>
          </div>
        </div>
      </section>
    </main>

    <!-- Sticky TOC -->
    <aside>
      <div class="toc-head">
        <div class="toc-title">Table of Contents</div>
        <div class="pill">Sticky</div>
      </div>
      <nav class="toc" aria-label="Table of contents">
        <a href="#summary"><span>Quick Summary</span><small>numbers + controls</small></a>
        <a href="#viz"><span>Visualizations</span><small>canvas + sliders</small></a>
        <a href="#part1"><span>PART 1 — Analysis</span><small>set up</small></a>
        <a href="#part2"><span>PART 2 — Strategy</span><small>roadmap</small></a>
        <a href="#part3"><span>PART 3 — Solution</span><small>derivation</small></a>
      </nav>
    </aside>
  </div>

  <footer>
    <div class="divider"></div>
    <p>
      Built with vanilla HTML/CSS/JS. The plots use the same parameters as the derivation (N=10, λ=0.06 m; sliders adjust d and D for exploration).
      Small-angle approximation <code>sinθ ≈ θ</code> is used consistently.
    </p>
  </footer>

  <script>
    // ---------- Utility: copy buttons ----------
    (function(){
      function copyText(text){
        if (navigator.clipboard && navigator.clipboard.writeText){
          navigator.clipboard.writeText(text).catch(()=>fallbackCopy(text));
        } else {
          fallbackCopy(text);
        }
      }
      function fallbackCopy(text){
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position='fixed';
        ta.style.left='-9999px';
        ta.style.top='-9999px';
        document.body.appendChild(ta);
        ta.focus(); ta.select();
        try{ document.execCommand('copy'); }catch(e){}
        document.body.removeChild(ta);
      }
      document.querySelectorAll('.eq[data-copy]').forEach(block=>{
        const btn = block.querySelector('.copy');
        const pre = block.querySelector('pre');
        btn.addEventListener('click', ()=>{
          copyText(pre.innerText.trim());
          btn.textContent = 'Copied';
          setTimeout(()=>btn.textContent='Copy', 900);
        });
      });
    })();

    // ---------- Math helpers ----------
    function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function fmt(x, sig=3){
      // engineering-ish formatter
      const ax = Math.abs(x);
      if (ax === 0) return "0";
      if (ax >= 0.001 && ax < 1000) return x.toPrecision(sig);
      // scientific
      const e = Math.floor(Math.log10(ax));
      const m = x / Math.pow(10,e);
      return `${m.toPrecision(sig)}e${e>=0?'+':''}${e}`;
    }

    // Bessel J1 approximation (Cephes-like polynomial/rational)
    // Good enough for visualization (not used to grade the analytic results).
    function besselJ1(x){
      const ax = Math.abs(x);
      if (ax < 1e-5) return 0.5*x; // small-x
      // For moderate x, use series for |x|<8, asymptotic otherwise
      if (ax < 8.0){
        const y = x*x;
        // Polynomial approximation for J1 on [0,8]
        // J1(x) ~ x*(p(y)/q(y))
        const p = ((((-1.4258509801366645672e+11*y + 6.6781041261492395835e+11)*y
                    - 1.1548696764841276794e+12)*y + 9.8062904098958257677e+11)*y
                    - 4.4615792982775076130e+11)*y + 1.0650724020080236441e+11;
        const q = ((((( 4.1868604460820175290e+12*y + 4.2091902282580133541e+10)*y
                    + 2.0228375140097033958e+11)*y + 1.1160387717777991682e+11)*y
                    + 2.0642468290441640465e+10)*y + 2.7394295778072276301e+09;
        return x * (p/q);
      } else {
        // Asymptotic: J1(x) ~ sqrt(2/(pi x)) * cos(x - 3pi/4)
        const t = ax;
        const s = Math.sqrt(2/(Math.PI*t));
        const phase = t - 3*Math.PI/4;
        const val = s * Math.cos(phase);
        return x < 0 ? -val : val;
      }
    }

    // Airy intensity for circular aperture (normalized): [2 J1(u)/u]^2 with u = pi D sinθ / λ
    function airyIntensity(theta, lambda, D){
      const u = Math.PI * D * theta / lambda; // small-angle sinθ≈θ
      if (Math.abs(u) < 1e-8) return 1.0;
      const j1 = besselJ1(u);
      const a = 2*j1/u;
      return a*a;
    }

    // Uniform linear array factor intensity normalized to 1 at theta=0
    function arrayFactorIntensity(theta, lambda, d, N){
      const k = 2*Math.PI/lambda;
      const psi = k*d*theta;
      const half = psi/2;
      const denom = Math.sin(half);
      if (Math.abs(denom) < 1e-12) return 1.0; // limit -> N^2 then normalized below
      const num = Math.sin(N*half);
      const af = num/denom;      // amplitude ratio
      const I = (af*af)/(N*N);   // normalize: peak at 1
      return I;
    }

    // ---------- Canvas plotting framework ----------
    function setupHiDPICanvas(canvas){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect.width * dpr));
      const h = Math.max(2, Math.floor(rect.height * dpr));
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {ctx, w: rect.width, h: rect.height, dpr};
    }

    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, opts){
      const {
        title="",
        xLabel="",
        yLabel="",
        grid=true,
        ticksX=6,
        ticksY=5
      } = opts || {};

      // Background panel
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.fillRect(box.x, box.y, box.w, box.h);

      // Gridlines + ticks
      ctx.strokeStyle = 'rgba(255,255,255,0.10)';
      ctx.lineWidth = 1;

      function xToPx(x){ return box.x + (x - xMin)/(xMax-xMin)*box.w; }
      function yToPx(y){ return box.y + box.h - (y - yMin)/(yMax-yMin)*box.h; }

      if (grid){
        for (let i=0;i<=ticksX;i++){
          const t=i/ticksX;
          const x = lerp(xMin, xMax, t);
          const px = xToPx(x);
          ctx.beginPath();
          ctx.moveTo(px, box.y);
          ctx.lineTo(px, box.y+box.h);
          ctx.stroke();
        }
        for (let j=0;j<=ticksY;j++){
          const t=j/ticksY;
          const y = lerp(yMin, yMax, t);
          const py = yToPx(y);
          ctx.beginPath();
          ctx.moveTo(box.x, py);
          ctx.lineTo(box.x+box.w, py);
          ctx.stroke();
        }
      }

      // Border
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.strokeRect(box.x, box.y, box.w, box.h);

      // Labels
      ctx.fillStyle = 'rgba(233,238,247,0.92)';
      ctx.font = '600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(title, box.x + 10, box.y + 20);

      ctx.fillStyle = 'rgba(169,180,199,0.92)';
      ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(xLabel, box.x + box.w - ctx.measureText(xLabel).width - 10, box.y + box.h - 10);

      // y label (rotated)
      ctx.save();
      ctx.translate(box.x + 14, box.y + 22);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();

      // Numeric ticks
      ctx.fillStyle = 'rgba(169,180,199,0.86)';
      ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

      for (let i=0;i<=ticksX;i++){
        const t=i/ticksX;
        const x = lerp(xMin, xMax, t);
        const px = xToPx(x);
        const label = fmt(x,3);
        const tw = ctx.measureText(label).width;
        ctx.fillText(label, px - tw/2, box.y + box.h + 16);
      }
      for (let j=0;j<=ticksY;j++){
        const t=j/ticksY;
        const y = lerp(yMin, yMax, t);
        const py = yToPx(y);
        const label = fmt(y,3);
        ctx.fillText(label, box.x - 8 - ctx.measureText(label).width, py + 4);
      }

      ctx.restore();
      return {xToPx, yToPx};
    }

    function drawLine(ctx, box, xToPx, yToPx, xs, ys, style){
      ctx.save();
      ctx.strokeStyle = style.stroke || 'rgba(125,211,252,0.95)';
      ctx.lineWidth = style.width || 2;
      ctx.beginPath();
      for (let i=0;i<xs.length;i++){
        const px = xToPx(xs[i]);
        const py = yToPx(ys[i]);
        if (i===0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawLegend(ctx, x, y, items){
      ctx.save();
      ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillStyle = 'rgba(233,238,247,0.90)';
      const pad = 10, lineH = 18;
      let w=0;
      items.forEach(it => {
        const mw = ctx.measureText(it.label).width;
        w = Math.max(w, mw + 42);
      });
      const h = pad*2 + items.length*lineH;
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      roundRect(ctx, x, y, w, h, 12);
      ctx.fill();
      ctx.stroke();

      items.forEach((it, idx)=>{
        const yy = y + pad + idx*lineH + 6;
        ctx.strokeStyle = it.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x+12, yy);
        ctx.lineTo(x+30, yy);
        ctx.stroke();

        ctx.fillStyle = 'rgba(233,238,247,0.92)';
        ctx.fillText(it.label, x+36, yy+4);
      });

      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    // ---------- Problem parameters ----------
    const N = 10;
    const lambda = 0.06; // meters (fixed)
    let d = 800;         // meters (slider)
    let D = 25;          // meters (slider)
    let mHighlight = 1;  // selected order

    // ---------- DOM elements ----------
    const dSlider = document.getElementById('dSlider');
    const DSlider = document.getElementById('DSlider');
    const mSelect = document.getElementById('mSelect');

    const dRead = document.getElementById('dRead');
    const DRead = document.getElementById('DRead');
    const mRead = document.getElementById('mRead');

    const theta1Out = document.getElementById('theta1Out');
    const width0Out = document.getElementById('width0Out');
    const resOut = document.getElementById('resOut');
    const pbOut = document.getElementById('pbOut');

    const setupCanvas = document.getElementById('setupCanvas');
    const mainPlot = document.getElementById('mainPlot');
    const secondaryPlot = document.getElementById('secondaryPlot');

    function updateReadouts(){
      dRead.textContent = `${d.toFixed(0)}`;
      DRead.textContent = `${D.toFixed(0)}`;
      mRead.textContent = `${mHighlight}`;

      const theta1 = lambda / d;
      const width0 = 2*lambda/(N*d);

      const Bmax = (N-1)*d;
      const thetaRes = lambda / Bmax;
      const thetaPB = 1.22*lambda / D;

      theta1Out.textContent = `${fmt(theta1,3)} rad`;
      width0Out.textContent = `${fmt(width0,3)} rad`;
      resOut.textContent = `${fmt(thetaRes,3)} rad  (Bmax=${fmt(Bmax,3)} m)`;
      pbOut.textContent = `${fmt(thetaPB,3)} rad`;
    }

    // ---------- Drawing: setup diagram ----------
    function drawSetup(){
      const {ctx, w, h} = setupHiDPICanvas(setupCanvas);
      ctx.clearRect(0,0,w,h);

      const pad = 18;
      const box = {x: pad, y: pad, w: w-2*pad, h: h-2*pad};

      // Title and panel
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.fillRect(box.x, box.y, box.w, box.h);
      ctx.strokeStyle = 'rgba(255,255,255,0.16)';
      ctx.strokeRect(box.x, box.y, box.w, box.h);

      ctx.fillStyle = 'rgba(233,238,247,0.92)';
      ctx.font = '600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('Setup: East–West array and arrival angle θ', box.x+10, box.y+20);

      // Coordinate axes
      const cx = box.x + box.w*0.12;
      const cy = box.y + box.h*0.78;
      ctx.strokeStyle = 'rgba(255,255,255,0.16)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + 110, cy);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx, cy - 90);
      ctx.stroke();

      ctx.fillStyle = 'rgba(169,180,199,0.9)';
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.fillText('E (x)', cx+82, cy+18);
      ctx.fillText('N (y)', cx-22, cy-74);

      // Array line with dishes
      const left = box.x + box.w*0.15;
      const right = box.x + box.w*0.92;
      const yArr = box.y + box.h*0.62;

      ctx.strokeStyle = 'rgba(125,211,252,0.55)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(left, yArr);
      ctx.lineTo(right, yArr);
      ctx.stroke();

      // dishes positions
      for (let i=0;i<N;i++){
        const t = i/(N-1);
        const x = lerp(left, right, t);
        const r = 7;
        ctx.fillStyle = 'rgba(125,211,252,0.95)';
        ctx.beginPath();
        ctx.arc(x, yArr, r, 0, Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 1;
        ctx.stroke();

        if (i===0 || i===N-1){
          ctx.fillStyle = 'rgba(169,180,199,0.9)';
          ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace';
          ctx.fillText(i===0 ? 'n=0' : `n=${N-1}`, x-12, yArr-14);
        }
      }

      // Spacing annotation (between first two)
      const x0 = lerp(left, right, 0/(N-1));
      const x1 = lerp(left, right, 1/(N-1));
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x0, yArr+18);
      ctx.lineTo(x1, yArr+18);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x0, yArr+14);
      ctx.lineTo(x0, yArr+22);
      ctx.moveTo(x1, yArr+14);
      ctx.lineTo(x1, yArr+22);
      ctx.stroke();
      ctx.fillStyle = 'rgba(169,180,199,0.9)';
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.fillText(`spacing d = ${d.toFixed(0)} m`, (x0+x1)/2 - 46, yArr+40);

      // Incoming wave from the south with E–W angle θ
      const theta_m = mHighlight * lambda / d; // rad
      const thetaVis = clamp(theta_m * 5000, -0.5, 0.5); // amplify for visibility
      const originX = box.x + box.w*0.82;
      const originY = box.y + box.h*0.20;
      const len = 170;

      // direction: mostly northward (up), with small x component
      const dx = Math.sin(thetaVis) * len;
      const dy = Math.cos(thetaVis) * len;

      ctx.strokeStyle = 'rgba(167,139,250,0.95)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(originX, originY + len);
      ctx.lineTo(originX - dx, originY + len - dy);
      ctx.stroke();

      // arrowhead
      const ax = originX - dx;
      const ay = originY + len - dy;
      const ang = Math.atan2(-dy, -dx);
      ctx.beginPath();
      ctx.moveTo(ax, ay);
      ctx.lineTo(ax + 10*Math.cos(ang+0.55), ay + 10*Math.sin(ang+0.55));
      ctx.lineTo(ax + 10*Math.cos(ang-0.55), ay + 10*Math.sin(ang-0.55));
      ctx.closePath();
      ctx.fillStyle = 'rgba(167,139,250,0.95)';
      ctx.fill();

      ctx.fillStyle = 'rgba(233,238,247,0.92)';
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.fillText('Incoming wave', originX-110, originY+38);

      // theta marker
      const baseX = box.x + box.w*0.78;
      const baseY = box.y + box.h*0.36;
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 2;
      // reference (north)
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.lineTo(baseX, baseY+60);
      ctx.stroke();
      // tilted line
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.lineTo(baseX - dx*0.35, baseY + dy*0.35);
      ctx.stroke();
      // arc
      ctx.strokeStyle = 'rgba(167,139,250,0.75)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(baseX, baseY, 26, Math.PI/2, Math.PI/2 - thetaVis, thetaVis>0);
      ctx.stroke();

      ctx.fillStyle = 'rgba(169,180,199,0.92)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace';
      ctx.fillText(`θ (E–W)`, baseX+10, baseY+18);

      // phase step note
      ctx.fillStyle = 'rgba(169,180,199,0.92)';
      ctx.font = '12px ui-sans-serif, system-ui';
      const psi = (2*Math.PI/lambda)*d*(mHighlight*lambda/d); // = 2πm
      ctx.fillText(`Phase step: ψ = k d θ`, box.x+10, box.y+box.h-32);
      ctx.fillStyle = 'rgba(233,238,247,0.92)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace';
      ctx.fillText(`(k=2π/λ)`, box.x+168, box.y+box.h-32);

      ctx.restore();
    }

    // ---------- Drawing: main plot (intensity vs theta) ----------
    function drawMainPlot(){
      const {ctx, w, h} = setupHiDPICanvas(mainPlot);
      ctx.clearRect(0,0,w,h);

      // Plot range: show several orders around 0
      // peak spacing ~ λ/d, so cover about +/- 3*λ/d
      const span = 3.5*lambda/d;
      const xMin = -span, xMax = span;
      const yMin = 0, yMax = 1.05;

      const padL = 62, padR = 18, padT = 18, padB = 46;
      const box = {x: padL, y: padT, w: w - padL - padR, h: h - padT - padB};

      const {xToPx, yToPx} = drawAxes(ctx, box, xMin, xMax, yMin, yMax, {
        title: 'Intensity pattern vs angle θ (small-angle radians)',
        xLabel: 'θ (rad)',
        yLabel: 'Normalized I(θ)',
        ticksX: 6,
        ticksY: 5,
        grid: true
      });

      // Compute curves
      const nPts = 900;
      const xs = new Array(nPts);
      const yAF = new Array(nPts);
      const yTotal = new Array(nPts);

      for (let i=0;i<nPts;i++){
        const t = i/(nPts-1);
        const th = lerp(xMin, xMax, t);
        xs[i] = th;
        const af = arrayFactorIntensity(th, lambda, d, N);
        const elem = airyIntensity(th, lambda, D);
        yAF[i] = af;
        yTotal[i] = af * elem;
      }

      // Draw curves
      drawLine(ctx, box, xToPx, yToPx, xs, yAF, {stroke:'rgba(125,211,252,0.95)', width:2});
      drawLine(ctx, box, xToPx, yToPx, xs, yTotal, {stroke:'rgba(52,211,153,0.95)', width:2});

      // Highlight selected order marker
      const theta_m = mHighlight * (lambda/d);
      ctx.save();
      ctx.strokeStyle = 'rgba(167,139,250,0.95)';
      ctx.lineWidth = 2;
      const xm = xToPx(theta_m);
      ctx.beginPath();
      ctx.moveTo(xm, box.y);
      ctx.lineTo(xm, box.y+box.h);
      ctx.stroke();

      ctx.fillStyle = 'rgba(167,139,250,0.95)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace';
      const label = `θ_m = mλ/d = ${fmt(theta_m,3)} rad`;
      const lw = ctx.measureText(label).width;
      ctx.fillText(label, clamp(xm - lw - 8, box.x+6, box.x+box.w-lw-6), box.y+box.h-8);
      ctx.restore();

      // Legend
      drawLegend(ctx, box.x + 12, box.y + 28, [
        {label:'Array factor (normalized)', color:'rgba(125,211,252,0.95)'},
        {label:'Array × dish envelope', color:'rgba(52,211,153,0.95)'},
        {label:`Order marker (m=${mHighlight})`, color:'rgba(167,139,250,0.95)'}
      ]);

      // Note: show peak spacing and main lobe width
      const spacing = lambda/d;
      const width = 2*lambda/(N*d);

      ctx.save();
      ctx.fillStyle = 'rgba(169,180,199,0.90)';
      ctx.font = '12px ui-sans-serif, system-ui';
      const note1 = `Peak spacing ≈ λ/d = ${fmt(spacing,3)} rad`;
      const note2 = `Main-lobe width (null-to-null) ≈ 2λ/(N d) = ${fmt(width,3)} rad`;
      ctx.fillText(note1, box.x + 12, box.y + box.h + 34);
      ctx.fillText(note2, box.x + 12, box.y + box.h + 50);
      ctx.restore();
    }

    // ---------- Drawing: secondary plot (beam widths vs D sweep) ----------
    function drawSecondaryPlot(){
      const {ctx, w, h} = setupHiDPICanvas(secondaryPlot);
      ctx.clearRect(0,0,w,h);

      // x-axis: Dish diameter D from 10 to 120 m
      const xMin = 10, xMax = 120;

      // y-axis: width in radians (log-ish behavior). We'll plot on linear axis but choose bounds.
      const Bmax = (N-1)*d;
      const thetaRes = lambda / Bmax;          // baseline-limited resolution scale
      const thetaAFWidth = 2*lambda/(N*d);     // array factor null-to-null width
      const thetaPB10 = 1.22*lambda/10;
      const thetaPB120 = 1.22*lambda/120;
      const yMax = Math.max(thetaPB10, thetaAFWidth)*1.15;
      const yMin = Math.min(thetaPB120, thetaRes)*0.0; // start at 0 for clarity

      const padL = 72, padR = 18, padT = 18, padB = 48;
      const box = {x: padL, y: padT, w: w - padL - padR, h: h - padT - padB};

      const {xToPx, yToPx} = drawAxes(ctx, box, xMin, xMax, yMin, yMax, {
        title: 'Beam width scales vs dish diameter D',
        xLabel: 'Dish diameter D (m)',
        yLabel: 'Angular width (rad)',
        ticksX: 6,
        ticksY: 5,
        grid: true
      });

      // Curves: primary beam ~ 1.22 λ/D, plus constants for array widths
      const nPts = 400;
      const xs = new Array(nPts);
      const yPB = new Array(nPts);
      for (let i=0;i<nPts;i++){
        const t = i/(nPts-1);
        const DD = lerp(xMin, xMax, t);
        xs[i] = DD;
        yPB[i] = 1.22*lambda/DD;
      }

      // Draw primary beam curve
      drawLine(ctx, box, xToPx, yToPx, xs, yPB, {stroke:'rgba(52,211,153,0.95)', width:2});

      // Draw horizontal lines for array widths (do not depend on D)
      ctx.save();
      ctx.strokeStyle = 'rgba(125,211,252,0.95)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(xToPx(xMin), yToPx(thetaAFWidth));
      ctx.lineTo(xToPx(xMax), yToPx(thetaAFWidth));
      ctx.stroke();

      ctx.strokeStyle = 'rgba(167,139,250,0.95)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(xToPx(xMin), yToPx(thetaRes));
      ctx.lineTo(xToPx(xMax), yToPx(thetaRes));
      ctx.stroke();
      ctx.restore();

      // Highlight current D
      ctx.save();
      const xD = xToPx(D);
      ctx.strokeStyle = 'rgba(255,255,255,0.75)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(xD, box.y);
      ctx.lineTo(xD, box.y+box.h);
      ctx.stroke();

      const pbNow = 1.22*lambda/D;
      ctx.fillStyle = 'rgba(255,255,255,0.86)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace';
      ctx.fillText(`D = ${D.toFixed(0)} m`, clamp(xD+8, box.x+8, box.x+box.w-90), box.y+18);
      ctx.fillText(`θ_primary = ${fmt(pbNow,3)} rad`, clamp(xD+8, box.x+8, box.x+box.w-160), box.y+36);
      ctx.restore();

      // Legend
      drawLegend(ctx, box.x + 12, box.y + 30, [
        {label:'Primary beam ~ 1.22λ/D', color:'rgba(52,211,153,0.95)'},
        {label:'Array main-lobe width ~ 2λ/(N d)', color:'rgba(125,211,252,0.95)'},
        {label:'Baseline resolution ~ λ/Bmax', color:'rgba(167,139,250,0.95)'}
      ]);

      // Annotation text
      ctx.save();
      ctx.fillStyle = 'rgba(169,180,199,0.90)';
      ctx.font = '12px ui-sans-serif, system-ui';
      const t1 = `Bmax = (N−1)d = ${fmt(Bmax,3)} m`;
      const t2 = `λ = 0.06 m; array widths depend on N and d, not on D`;
      ctx.fillText(t1, box.x + 12, box.y + box.h + 34);
      ctx.fillText(t2, box.x + 12, box.y + box.h + 50);
      ctx.restore();
    }

    // ---------- Update all ----------
    function redrawAll(){
      updateReadouts();
      drawSetup();
      drawMainPlot();
      drawSecondaryPlot();
    }

    // ---------- Event listeners ----------
    dSlider.addEventListener('input', ()=>{
      d = Number(dSlider.value);
      redrawAll();
    });
    DSlider.addEventListener('input', ()=>{
      D = Number(DSlider.value);
      redrawAll();
    });
    mSelect.addEventListener('change', ()=>{
      mHighlight = Number(mSelect.value);
      redrawAll();
    });

    // Resize observer for responsiveness
    const ro = new ResizeObserver(()=>redrawAll());
    ro.observe(setupCanvas);
    ro.observe(mainPlot);
    ro.observe(secondaryPlot);

    // Init
    redrawAll();
  </script>
</body>
</html>
