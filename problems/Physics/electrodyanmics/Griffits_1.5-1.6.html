<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="color-scheme" content="light dark" />
  <title>Vector Identities: BAC–CAB, Jacobi Identity, and When Cross Products “Associate”</title>
  <style>
    :root{
      --bg: #0b0d12;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.09);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.72);
      --faint: rgba(255,255,255,0.55);
      --line: rgba(255,255,255,0.14);
      --accent: #7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --shadow: 0 12px 30px rgba(0,0,0,0.35);
      --radius: 18px;
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg:#f7f8fb;
        --panel: rgba(0,0,0,0.04);
        --panel2: rgba(0,0,0,0.06);
        --text: rgba(0,0,0,0.9);
        --muted: rgba(0,0,0,0.68);
        --faint: rgba(0,0,0,0.55);
        --line: rgba(0,0,0,0.12);
        --shadow: 0 10px 22px rgba(0,0,0,0.12);
      }
    }
    *{ box-sizing:border-box; }
    html{ scroll-behavior:smooth; }
    body{
      margin:0;
      background: radial-gradient(1200px 600px at 20% -10%, rgba(125,211,252,0.18), transparent 55%),
                  radial-gradient(900px 500px at 95% 10%, rgba(167,139,250,0.16), transparent 60%),
                  var(--bg);
      color:var(--text);
      font-family:var(--sans);
      line-height:1.55;
    }
    header{
      padding: 28px 18px 8px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.3fr 0.7fr;
      gap:16px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .hero{ grid-template-columns: 1fr; }
    }
    .titleCard{
      background: linear-gradient(180deg, var(--panel2), var(--panel));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 20px 18px;
      position:relative;
      overflow:hidden;
    }
    .titleCard::after{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(700px 220px at 30% 0%, rgba(125,211,252,0.22), transparent 55%),
                  radial-gradient(700px 220px at 80% 10%, rgba(167,139,250,0.18), transparent 55%);
      pointer-events:none;
      opacity:0.55;
    }
    .titleCard > *{ position:relative; z-index:1; }
    h1{
      margin:0 0 10px;
      font-size: clamp(1.35rem, 2.6vw, 2.05rem);
      letter-spacing:0.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      max-width: 80ch;
    }
    .quick{
      margin-top:14px;
      padding: 12px 12px;
      border:1px dashed var(--line);
      border-radius: 14px;
      background: rgba(0,0,0,0.02);
    }
    .quick h2{
      margin:0 0 6px;
      font-size:1rem;
      letter-spacing:0.2px;
    }
    .quick ul{
      margin:0;
      padding-left: 18px;
      color:var(--muted);
    }
    .toc{
      background: linear-gradient(180deg, var(--panel2), var(--panel));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px;
      position: sticky;
      top: 12px;
      height: fit-content;
      align-self:start;
    }
    .toc h2{
      margin:0 0 8px;
      font-size:1rem;
      letter-spacing:0.25px;
    }
    .toc a{
      display:block;
      padding: 8px 10px;
      margin: 6px 0;
      border-radius: 12px;
      text-decoration:none;
      color:var(--text);
      border:1px solid transparent;
      background: transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
    }
    .toc a:hover{
      background: rgba(125,211,252,0.10);
      border-color: rgba(125,211,252,0.18);
      transform: translateY(-1px);
    }

    main{
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px 18px 34px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    section{
      background: linear-gradient(180deg, var(--panel2), var(--panel));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 18px;
      overflow:hidden;
    }
    section h2{
      margin:0 0 10px;
      font-size: 1.15rem;
      letter-spacing:0.2px;
    }
    section h3{
      margin: 14px 0 8px;
      font-size: 1.0rem;
      color: var(--text);
    }
    p{ margin: 8px 0; color: var(--muted); }
    ul{ color:var(--muted); }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      .grid2{ grid-template-columns: 1fr; }
    }
    .callout{
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 12px 12px;
      background: rgba(0,0,0,0.02);
    }
    .callout strong{ color: var(--text); }
    .eq{
      font-family: var(--mono);
      font-size: 0.95rem;
      color: var(--text);
      background: rgba(0,0,0,0.06);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 10px 10px;
      overflow-x:auto;
      position:relative;
    }
    .eqRow{
      display:flex;
      gap:10px;
      align-items:stretch;
      flex-wrap:wrap;
    }
    .btn{
      appearance:none;
      border:1px solid var(--line);
      background: rgba(125,211,252,0.10);
      color: var(--text);
      border-radius: 14px;
      padding: 9px 12px;
      font-weight: 650;
      cursor:pointer;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); border-color: rgba(125,211,252,0.30); background: rgba(125,211,252,0.14); }
    .btn:active{ transform: translateY(0px); }
    .btn.secondary{ background: rgba(167,139,250,0.10); }
    .btn.secondary:hover{ border-color: rgba(167,139,250,0.30); background: rgba(167,139,250,0.14); }
    .copyTag{
      font-family: var(--mono);
      font-size: 0.82rem;
      color: var(--faint);
    }
    .boxed{
      border: 1px solid rgba(52,211,153,0.35);
      background: rgba(52,211,153,0.08);
      border-radius: 16px;
      padding: 12px 12px;
      margin-top: 10px;
    }
    .boxed .eq{ background: rgba(0,0,0,0.03); }
    .note{
      border-left: 4px solid rgba(251,191,36,0.75);
      padding-left: 10px;
      margin: 10px 0;
      color: var(--muted);
    }

    figure{
      margin: 0;
      border: 1px solid var(--line);
      border-radius: 16px;
      overflow:hidden;
      background: rgba(0,0,0,0.03);
    }
    figcaption{
      padding: 10px 12px;
      border-top: 1px solid var(--line);
      color: var(--muted);
      font-size: 0.93rem;
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
    }
    .vizGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .vizGrid{ grid-template-columns: 1fr; }
      canvas{ height: 300px; }
    }
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap: 10px 12px;
      align-items:center;
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 12px 12px;
      background: rgba(0,0,0,0.02);
    }
    label{
      display:flex;
      gap: 8px;
      align-items:center;
      color: var(--muted);
      font-weight: 600;
    }
    input[type="range"]{
      width: 240px;
      max-width: 60vw;
      accent-color: var(--accent);
    }
    select{
      border:1px solid var(--line);
      border-radius: 12px;
      padding: 8px 10px;
      background: rgba(0,0,0,0.03);
      color: var(--text);
      font-weight: 650;
    }
    .readout{
      font-family: var(--mono);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 12px;
      border:1px solid var(--line);
      background: rgba(0,0,0,0.04);
    }
    footer{
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px 18px 28px;
      color: var(--faint);
      font-size: 0.92rem;
    }

    @media print{
      body{ background:#fff; color:#000; }
      .toc{ position:static; box-shadow:none; }
      section, .titleCard{ box-shadow:none; }
      .btn{ display:none; }
      canvas{ height: 260px; }
    }
  </style>
</head>
<body>
<header>
  <div class="hero">
    <div class="titleCard">
      <h1>Problems 1.5–1.6: BAC–CAB, Jacobi Identity, and When Triple Cross Products “Associate”</h1>
      <p class="subtitle">
        We prove the standard vector identity (BAC–CAB) in components, use it to prove the cyclic sum
        <span class="eq" style="display:inline-block; padding:4px 8px; border-radius:10px;">A×(B×C)+B×(C×A)+C×(A×B)=0</span>,
        and then determine exactly when
        <span class="eq" style="display:inline-block; padding:4px 8px; border-radius:10px;">A×(B×C)=(A×B)×C</span>
        can hold.
      </p>

      <div class="quick" aria-label="Quick Summary">
        <h2>Quick Summary</h2>
        <ul>
          <li>The BAC–CAB rule: <span class="eq" style="display:inline-block; padding:2px 6px;">A×(B×C)=B(A·C)−C(A·B)</span>.</li>
          <li>Using it, the cyclic sum identity (Jacobi identity for ×) holds for all vectors in 3D.</li>
          <li>Cross product is <em>not</em> associative in general; the “associator” is <span class="eq" style="display:inline-block; padding:2px 6px;">A×(B×C)−(A×B)×C = A(B·C)−C(A·B)</span>.</li>
          <li>Associativity holds iff <span class="eq" style="display:inline-block; padding:2px 6px;">A(B·C)=C(A·B)</span> (usually meaning <span class="eq" style="display:inline-block; padding:2px 6px;">A∥C</span>, or both dot products are zero).</li>
        </ul>
      </div>

      <div class="eqRow" style="margin-top:14px;">
        <button class="btn" data-copy="A×(B×C)=B(A·C)−C(A·B)">Copy BAC–CAB</button>
        <button class="btn secondary" data-copy="A×(B×C)+B×(C×A)+C×(A×B)=0">Copy Jacobi identity</button>
        <button class="btn" data-copy="A×(B×C)=(A×B)×C  ⇔  A(B·C)=C(A·B)">Copy associativity condition</button>
      </div>
      <div class="copyTag" id="copyStatus" style="margin-top:8px;">Copy buttons place plain text on your clipboard.</div>
    </div>

    <nav class="toc" aria-label="Table of Contents">
      <h2>Contents</h2>
      <a href="#part1">PART 1 — Problem Analysis</a>
      <a href="#part2">PART 2 — Strategy & Tips</a>
      <a href="#part3">PART 3 — Full Solution</a>
      <a href="#viz">Interactive Visualizations</a>
      <a href="#checks">Sanity Checks</a>
    </nav>
  </div>
</header>

<main>
  <section id="part1">
    <h2>PART 1 — Problem Analysis (no solving yet)</h2>

    <h3>1) Rewrite the problem in my own words</h3>
    <p>
      (Problem 1.5) Prove the vector triple product identity (often called BAC–CAB) by writing both sides in
      component form.
    </p>
    <p>
      (Problem 1.6) Prove that the cyclic sum of “double cross products” is zero:
      <span class="eq">A×(B×C) + B×(C×A) + C×(A×B) = 0</span>.
      Then determine when the cross product “associates,” i.e.
      <span class="eq">A×(B×C) = (A×B)×C</span>.
    </p>

    <div class="grid2">
      <div class="callout">
        <h3>Given quantities</h3>
        <ul>
          <li>Three vectors <span class="eq" style="display:inline-block; padding:2px 6px;">A, B, C</span> in ordinary 3D Euclidean space.</li>
          <li>Standard dot product <span class="eq" style="display:inline-block; padding:2px 6px;">A·B</span> and cross product <span class="eq" style="display:inline-block; padding:2px 6px;">A×B</span>.</li>
        </ul>
      </div>
      <div class="callout">
        <h3>Unknowns / what must be proved</h3>
        <ul>
          <li>Prove <span class="eq" style="display:inline-block; padding:2px 6px;">A×(B×C)=B(A·C)−C(A·B)</span> using components.</li>
          <li>Prove <span class="eq" style="display:inline-block; padding:2px 6px;">A×(B×C)+B×(C×A)+C×(A×B)=0</span>.</li>
          <li>Find conditions on <span class="eq" style="display:inline-block; padding:2px 6px;">A,B,C</span> such that <span class="eq" style="display:inline-block; padding:2px 6px;">A×(B×C)=(A×B)×C</span>.</li>
        </ul>
      </div>
    </div>

    <h3>2) Relevant principles and why they apply</h3>
    <p>
      These are purely geometric/algebraic identities of the 3D cross product. The cleanest way to prove them
      in components uses the Levi–Civita symbol <span class="eq" style="display:inline-block; padding:2px 6px;">ε<sub>ijk</sub></span>
      and the Kronecker delta <span class="eq" style="display:inline-block; padding:2px 6px;">δ<sub>ij</sub></span>.
      That machinery directly translates “×” and “·” into index notation and exposes cancellations.
    </p>

    <h3>3) Possible approaches (compare 2–3)</h3>
    <ul>
      <li><strong>Component / index method (ε–δ):</strong> Most direct, rigorous, and matches the problem statement.</li>
      <li><strong>Geometric decomposition:</strong> Decompose vectors into components parallel/perpendicular to another vector; more intuition, less compact.</li>
      <li><strong>Determinant identities:</strong> Use determinant representation of × and properties of determinants; good but can hide steps.</li>
    </ul>

    <div class="callout">
      <strong>Chosen approach:</strong> the component (ε–δ) method, because it is systematic, shows every step, and immediately yields both identities.
    </div>
  </section>

  <section id="part2">
    <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

    <h3>Step-by-step plan (roadmap)</h3>
    <ol style="color:var(--muted);">
      <li>
        <strong>Goal:</strong> Translate cross products into components.<br/>
        <span class="copyTag">Tool:</span> <span class="eq">(X×Y)<sub>i</sub> = ε<sub>ijk</sub> X<sub>j</sub> Y<sub>k</sub></span>.
      </li>
      <li>
        <strong>Goal:</strong> Expand <span class="eq">A×(B×C)</span> in indices.<br/>
        <span class="copyTag">Tool:</span> Apply the formula twice.
      </li>
      <li>
        <strong>Goal:</strong> Reduce the product of two ε’s.<br/>
        <span class="copyTag">Tool:</span> <span class="eq">ε<sub>ijk</sub>ε<sub>klm</sub> = δ<sub>il</sub>δ<sub>jm</sub> − δ<sub>im</sub>δ<sub>jl</sub></span>.
      </li>
      <li>
        <strong>Goal:</strong> Recognize dot products and collect terms to get BAC–CAB.<br/>
        <span class="copyTag">Tool:</span> <span class="eq">X·Y = X<sub>j</sub>Y<sub>j</sub></span>.
      </li>
      <li>
        <strong>Goal:</strong> Use BAC–CAB three times (cyclic permutations) and add results.<br/>
        <span class="copyTag">Tool:</span> Term-by-term cancellation.
      </li>
      <li>
        <strong>Goal:</strong> Compare <span class="eq">A×(B×C)</span> with <span class="eq">(A×B)×C</span> and solve the condition for equality.<br/>
        <span class="copyTag">Tool:</span> BAC–CAB again.
      </li>
    </ol>

    <h3>Common mistakes & quick tips</h3>
    <ul>
      <li><strong>Index confusion:</strong> keep dummy indices (summed) distinct from free indices (the component you’re computing).</li>
      <li><strong>Wrong ε–δ identity:</strong> memorize or quickly re-derive it; the sign matters.</li>
      <li><strong>Associativity trap:</strong> cross product is bilinear and anti-commutative, but <em>not</em> associative—so don’t assume it.</li>
      <li><strong>Fast check:</strong> if you ever get a scalar from a cross product, something’s off (× produces a vector).</li>
    </ul>

    <div class="note">
      No algebra is shown above—only the plan. The full derivations are in PART 3.
    </div>
  </section>

  <section id="part3">
    <h2>PART 3 — Full Solution</h2>

    <h3>Physical / geometric intuition first</h3>
    <p>
      The vector <span class="eq">B×C</span> is perpendicular to the plane spanned by <span class="eq">B</span> and <span class="eq">C</span>.
      Crossing <span class="eq">A</span> with <span class="eq">B×C</span> produces a vector perpendicular to <span class="eq">A</span> and also
      lying in the <span class="eq">B</span>–<span class="eq">C</span> plane. So <span class="eq">A×(B×C)</span> must be some linear combination of
      <span class="eq">B</span> and <span class="eq">C</span>. BAC–CAB tells you the exact coefficients:
      it “projects” <span class="eq">A</span> onto <span class="eq">C</span> and <span class="eq">B</span> via dot products.
    </p>

    <h3>Definitions (so symbols are consistent)</h3>
    <div class="callout">
      <p style="margin:0; color:var(--muted);">
        We use index notation with Einstein summation (repeat an index → sum over 1,2,3):
      </p>
      <div class="eq" style="margin-top:10px;">
        (X×Y)<sub>i</sub> = ε<sub>ijk</sub> X<sub>j</sub> Y<sub>k</sub>, &nbsp;&nbsp;
        X·Y = X<sub>j</sub>Y<sub>j</sub>, &nbsp;&nbsp;
        δ<sub>ij</sub> = 1 if i=j else 0.
      </div>
      <div class="eq" style="margin-top:10px;">
        Key identity: ε<sub>ijk</sub>ε<sub>klm</sub> = δ<sub>il</sub>δ<sub>jm</sub> − δ<sub>im</sub>δ<sub>jl</sub>.
      </div>
    </div>

    <article>
      <h3>Problem 1.5 — Prove BAC–CAB in components</h3>

      <p>
        Start from the left-hand side and write everything in components:
      </p>
      <div class="eq">
        [A×(B×C)]<sub>i</sub> = ε<sub>ijk</sub> A<sub>j</sub> (B×C)<sub>k</sub>.
      </div>

      <p>Now expand <span class="eq" style="display:inline-block; padding:2px 6px;">(B×C)<sub>k</sub></span>:</p>
      <div class="eq">
        (B×C)<sub>k</sub> = ε<sub>klm</sub> B<sub>l</sub> C<sub>m</sub>.
      </div>

      <p>Substitute into the first expression:</p>
      <div class="eq">
        [A×(B×C)]<sub>i</sub> = ε<sub>ijk</sub> A<sub>j</sub> (ε<sub>klm</sub> B<sub>l</sub> C<sub>m</sub>)
        = (ε<sub>ijk</sub>ε<sub>klm</sub>) A<sub>j</sub> B<sub>l</sub> C<sub>m</sub>.
      </div>

      <p>Use the ε–δ contraction identity:</p>
      <div class="eq">
        ε<sub>ijk</sub>ε<sub>klm</sub> = δ<sub>il</sub>δ<sub>jm</sub> − δ<sub>im</sub>δ<sub>jl</sub>.
      </div>

      <p>Therefore</p>
      <div class="eq">
        [A×(B×C)]<sub>i</sub>
        = (δ<sub>il</sub>δ<sub>jm</sub> − δ<sub>im</sub>δ<sub>jl</sub>) A<sub>j</sub> B<sub>l</sub> C<sub>m</sub>.
      </div>

      <p>Distribute and simplify using the deltas:</p>
      <div class="eq">
        = δ<sub>il</sub>δ<sub>jm</sub> A<sub>j</sub> B<sub>l</sub> C<sub>m</sub> − δ<sub>im</sub>δ<sub>jl</sub> A<sub>j</sub> B<sub>l</sub> C<sub>m</sub>
      </div>
      <div class="eq">
        = B<sub>i</sub>(A<sub>j</sub>C<sub>j</sub>) − C<sub>i</sub>(A<sub>j</sub>B<sub>j</sub>)
        = B<sub>i</sub>(A·C) − C<sub>i</sub>(A·B).
      </div>

      <p>Recombine into vector form:</p>
      <div class="boxed">
        <div class="eq" id="eq-baccab">
          A×(B×C) = B(A·C) − C(A·B).
        </div>
        <p style="margin:8px 0 0; color:var(--muted);">
          This is the BAC–CAB rule (“B A C minus C A B”).
        </p>
      </div>
    </article>

    <article>
      <h3>Problem 1.6 — Prove the cyclic sum is zero</h3>

      <p>
        Apply BAC–CAB to each term (carefully changing which vector plays the role of A, B, C):
      </p>

      <div class="eq">
        A×(B×C) = B(A·C) − C(A·B)
      </div>
      <div class="eq">
        B×(C×A) = C(B·A) − A(B·C)
      </div>
      <div class="eq">
        C×(A×B) = A(C·B) − B(C·A)
      </div>

      <p>
        Now add the three equations. Group terms with the same vector factor:
      </p>
      <div class="eq">
        A×(B×C) + B×(C×A) + C×(A×B)
        = [B(A·C) − C(A·B)] + [C(B·A) − A(B·C)] + [A(C·B) − B(C·A)].
      </div>

      <p>
        Use symmetry of the dot product: <span class="eq" style="display:inline-block; padding:2px 6px;">B·A = A·B</span> and <span class="eq" style="display:inline-block; padding:2px 6px;">C·A = A·C</span>, etc.
        Then each vector’s coefficient cancels:
      </p>
      <ul>
        <li>
          <span class="eq">B(A·C)</span> cancels with <span class="eq">−B(C·A) = −B(A·C)</span>.
        </li>
        <li>
          <span class="eq">−C(A·B)</span> cancels with <span class="eq">C(B·A) = C(A·B)</span>.
        </li>
        <li>
          <span class="eq">−A(B·C)</span> cancels with <span class="eq">A(C·B) = A(B·C)</span>.
        </li>
      </ul>

      <div class="boxed">
        <div class="eq" id="eq-jacobi">
          A×(B×C) + B×(C×A) + C×(A×B) = 0.
        </div>
        <p style="margin:8px 0 0; color:var(--muted);">
          This is the Jacobi identity for the cross product (a hallmark of a Lie algebra).
        </p>
      </div>
    </article>

    <article>
      <h3>When does A×(B×C) = (A×B)×C?</h3>

      <p>
        Start from BAC–CAB for the left side:
      </p>
      <div class="eq">
        A×(B×C) = B(A·C) − C(A·B).
      </div>

      <p>
        Now compute the right side using BAC–CAB again, but with
        <span class="eq" style="display:inline-block; padding:2px 6px;">X=A×B</span> and <span class="eq" style="display:inline-block; padding:2px 6px;">Y=C</span> in the pattern <span class="eq" style="display:inline-block; padding:2px 6px;">(X×C)=?</span>.
        We use the identity in the form:
        <span class="eq" style="display:inline-block; padding:2px 6px;">(A×B)×C = B(A·C) − A(B·C)</span>
        (same rule, just permuted).
      </p>

      <div class="eq">
        (A×B)×C = B(A·C) − A(B·C).
      </div>

      <p>
        Set them equal and cancel the common term <span class="eq" style="display:inline-block; padding:2px 6px;">B(A·C)</span> on both sides:
      </p>
      <div class="eq">
        B(A·C) − C(A·B) = B(A·C) − A(B·C)
        &nbsp;&Rightarrow;&nbsp;
        C(A·B) = A(B·C).
      </div>

      <div class="boxed">
        <div class="eq" id="eq-assoc">
          A×(B×C) = (A×B)×C  ⇔  A(B·C) = C(A·B).
        </div>
        <p style="margin:8px 0 0; color:var(--muted);">
          This condition says the vectors <span class="eq" style="display:inline-block; padding:2px 6px;">A</span> and <span class="eq" style="display:inline-block; padding:2px 6px;">C</span> must be aligned in exactly the way their dot products with <span class="eq" style="display:inline-block; padding:2px 6px;">B</span> scale them.
        </p>
      </div>

      <h3>Interpreting the condition</h3>
      <p>
        The vector equation <span class="eq">A(B·C)=C(A·B)</span> has two main possibilities:
      </p>
      <ul>
        <li>
          <strong>Generic case (nonzero scalars):</strong> if <span class="eq">(A·B)</span> and <span class="eq">(B·C)</span> are not both zero, then
          <span class="eq">A(B·C)</span> is a scalar multiple of <span class="eq">A</span> and <span class="eq">C(A·B)</span> is a scalar multiple of <span class="eq">C</span>.
          For these to be equal, <strong><span class="eq">A</span> and <span class="eq">C</span> must be parallel (linearly dependent)</strong>.
        </li>
        <li>
          <strong>Degenerate dot-product case:</strong> if <span class="eq">A·B = 0</span> and <span class="eq">B·C = 0</span>, then both sides are the zero vector, so the equality holds even if <span class="eq">A</span> and <span class="eq">C</span> are not parallel.
          (Geometrically: <span class="eq">B</span> is perpendicular to both <span class="eq">A</span> and <span class="eq">C</span>.)
        </li>
      </ul>

      <div class="callout">
        <strong>Takeaway:</strong> Cross product “associates” only in special alignments: typically <span class="eq" style="display:inline-block; padding:2px 6px;">A∥C</span>, or when both <span class="eq" style="display:inline-block; padding:2px 6px;">A·B</span> and <span class="eq" style="display:inline-block; padding:2px 6px;">B·C</span> vanish.
      </div>
    </article>
  </section>

  <section id="viz">
    <h2>Interactive Visualizations</h2>
    <p>
      The identities are exact, but numerical computation shows tiny floating-point error. Use the controls to change the geometry.
      All plots update live.
    </p>

    <div class="controls" role="group" aria-label="Interactive controls">
      <label>
        Angle γ (between A and C)
        <input id="gamma" type="range" min="0" max="180" value="50" step="1" />
      </label>
      <span class="readout" id="gammaRead">γ = 50°</span>

      <label>
        B-configuration
        <select id="bMode">
          <option value="general" selected>General (B in xy-plane)</option>
          <option value="perp">B ⟂ A and B ⟂ C (forces associativity)</option>
          <option value="align">A ∥ C (forces associativity)</option>
        </select>
      </label>

      <button class="btn" id="randomize">Randomize example values</button>
    </div>

    <div class="vizGrid" style="margin-top:14px;">
      <figure>
        <canvas id="diagram" aria-label="Vector diagram canvas"></canvas>
        <figcaption>
          <strong>Diagram:</strong> Vectors A, B, C from the origin (example values). Also displays the current magnitudes
          |J| for the Jacobi sum and |D| for the associator.
        </figcaption>
      </figure>

      <figure>
        <canvas id="plot1" aria-label="Main plot canvas"></canvas>
        <figcaption>
          <strong>Main plot:</strong> Magnitude of the Jacobi sum vector J(γ) = A×(B×C)+B×(C×A)+C×(A×B) vs γ.
          Ideally 0 for all γ; the plotted curve shows numerical round-off (~1e−15 to 1e−16).
        </figcaption>
      </figure>

      <figure style="grid-column: 1 / -1;">
        <canvas id="plot2" aria-label="Secondary plot canvas"></canvas>
        <figcaption>
          <strong>Secondary plot:</strong> Associator magnitude |D(γ)| where D(γ)=A×(B×C)−(A×B)×C, showing when “associativity” happens.
          The vertical marker indicates the current γ.
        </figcaption>
      </figure>
    </div>
  </section>

  <section id="checks">
    <h2>Sanity Checks</h2>

    <h3>Units</h3>
    <p>
      If vectors represent physical quantities, dot products and cross products carry consistent units:
      <span class="eq">A×(B×C)</span> has units of <span class="eq">A·(B·C)</span> effectively (vector times scalar).
      In BAC–CAB, each term is “vector × scalar”: <span class="eq">B(A·C)</span> and <span class="eq">C(A·B)</span> match units.
    </p>

    <h3>Limiting cases</h3>
    <ul>
      <li>
        If <span class="eq">A</span> is perpendicular to both <span class="eq">B</span> and <span class="eq">C</span>, then <span class="eq">A·B=A·C=0</span>, and BAC–CAB gives <span class="eq">A×(B×C)=0</span>. That matches the geometry: <span class="eq">B×C</span> is parallel to <span class="eq">A</span>, so crossing with <span class="eq">A</span> gives zero.
      </li>
      <li>
        If <span class="eq">A∥C</span>, then the condition for associativity holds (and you see |D|→0 in the plot when you choose “A ∥ C” mode).
      </li>
    </ul>

    <h3>Physical interpretation</h3>
    <p>
      BAC–CAB says: “Double cross product with A pulls out the component of A along C (giving a B term) and subtracts the component of A along B (giving a C term).”
      The Jacobi identity then expresses a deep symmetry: the cross product behaves like a Lie bracket, and this cyclic sum must vanish.
    </p>

    <div class="boxed">
      <strong>Final Results (boxed):</strong>
      <div class="eq" style="margin-top:10px;">
        1) A×(B×C) = B(A·C) − C(A·B)<br/>
        2) A×(B×C) + B×(C×A) + C×(A×B) = 0<br/>
        3) A×(B×C) = (A×B)×C  ⇔  A(B·C) = C(A·B)
      </div>
      <div class="eqRow" style="margin-top:12px;">
        <button class="btn" data-copy="1) A×(B×C) = B(A·C) − C(A·B)\n2) A×(B×C) + B×(C×A) + C×(A×B) = 0\n3) A×(B×C) = (A×B)×C  ⇔  A(B·C) = C(A·B)">Copy final answer</button>
      </div>
    </div>
  </section>
</main>

<footer>
  Built with vanilla HTML/CSS/JS. Canvas plots are illustrative (example vectors) while the symbolic proofs above are exact.
</footer>

<script>
/* ===========================
   Clipboard helpers
=========================== */
(function(){
  const status = document.getElementById('copyStatus');
  function setStatus(msg, ok=true){
    status.textContent = msg;
    status.style.color = ok ? 'var(--faint)' : 'var(--bad)';
    setTimeout(()=>{ status.style.color = 'var(--faint)'; }, 1200);
  }
  async function copyText(text){
    try{
      await navigator.clipboard.writeText(text);
      setStatus('Copied ✓');
    }catch(e){
      // Fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      try{
        document.execCommand('copy');
        setStatus('Copied ✓');
      }catch(err){
        setStatus('Copy failed (browser blocked clipboard).', false);
      }
      document.body.removeChild(ta);
    }
  }
  document.querySelectorAll('[data-copy]').forEach(btn=>{
    btn.addEventListener('click', ()=> copyText(btn.getAttribute('data-copy')));
  });
})();

/* ===========================
   Vector math utilities
=========================== */
function v(x,y,z){ return {x,y,z}; }
function add(a,b){ return v(a.x+b.x, a.y+b.y, a.z+b.z); }
function sub(a,b){ return v(a.x-b.x, a.y-b.y, a.z-b.z); }
function mul(s,a){ return v(s*a.x, s*a.y, s*a.z); }
function dot(a,b){ return a.x*b.x + a.y*b.y + a.z*b.z; }
function cross(a,b){
  return v(
    a.y*b.z - a.z*b.y,
    a.z*b.x - a.x*b.z,
    a.x*b.y - a.y*b.x
  );
}
function norm(a){ return Math.hypot(a.x,a.y,a.z); }
function unit(a){
  const n = norm(a);
  return n>0 ? mul(1/n,a) : v(0,0,0);
}

/* ===========================
   HiDPI canvas setup
=========================== */
function setupCanvas(canvas){
  const ctx = canvas.getContext('2d');
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(10, Math.floor(rect.width));
    const h = Math.max(10, Math.floor(rect.height));
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return {w, h, dpr};
  }
  return {ctx, resize};
}

/* ===========================
   Plotting primitives
=========================== */
function drawAxes(ctx, box, xMin, xMax, yMin, yMax, opts){
  const {x, y, w, h} = box;
  const padL = opts.padL ?? 54;
  const padR = opts.padR ?? 16;
  const padT = opts.padT ?? 28;
  const padB = opts.padB ?? 44;

  const px = x + padL;
  const py = y + padT;
  const pw = w - padL - padR;
  const ph = h - padT - padB;

  // background
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.00)';
  ctx.fillRect(x,y,w,h);

  // title
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text').trim() || '#fff';
  ctx.font = '700 14px ui-sans-serif, system-ui';
  ctx.fillText(opts.title ?? '', x + 12, y + 18);

  // grid & ticks
  const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--line').trim() || 'rgba(255,255,255,0.12)';
  const muted = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || 'rgba(255,255,255,0.7)';
  ctx.strokeStyle = gridColor;
  ctx.lineWidth = 1;

  const xTicks = opts.xTicks ?? 7;
  const yTicks = opts.yTicks ?? 5;

  function mapX(xv){ return px + (xv - xMin) * (pw / (xMax - xMin)); }
  function mapY(yv){ return py + ph - (yv - yMin) * (ph / (yMax - yMin)); }

  // gridlines
  for(let i=0;i<=xTicks;i++){
    const t = xMin + (xMax-xMin)*i/xTicks;
    const X = mapX(t);
    ctx.beginPath();
    ctx.moveTo(X, py);
    ctx.lineTo(X, py+ph);
    ctx.stroke();
  }
  for(let j=0;j<=yTicks;j++){
    const t = yMin + (yMax-yMin)*j/yTicks;
    const Y = mapY(t);
    ctx.beginPath();
    ctx.moveTo(px, Y);
    ctx.lineTo(px+pw, Y);
    ctx.stroke();
  }

  // axes border
  ctx.strokeStyle = gridColor;
  ctx.lineWidth = 1.2;
  ctx.strokeRect(px, py, pw, ph);

  // labels
  ctx.fillStyle = muted;
  ctx.font = '600 12px ui-sans-serif, system-ui';
  ctx.fillText(opts.xLabel ?? '', px + pw/2 - 24, py + ph + 34);

  // y label rotated
  ctx.save();
  ctx.translate(x + 16, py + ph/2 + 20);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(opts.yLabel ?? '', 0, 0);
  ctx.restore();

  // tick labels
  ctx.fillStyle = muted;
  ctx.font = '600 11px ui-sans-serif, system-ui';

  for(let i=0;i<=xTicks;i++){
    const t = xMin + (xMax-xMin)*i/xTicks;
    const X = mapX(t);
    const label = (opts.xFmt ? opts.xFmt(t) : t.toFixed(0));
    ctx.fillText(label, X - 10, py + ph + 18);
  }
  for(let j=0;j<=yTicks;j++){
    const t = yMin + (yMax-yMin)*j/yTicks;
    const Y = mapY(t);
    const label = (opts.yFmt ? opts.yFmt(t) : t.toExponential ? t.toExponential(0) : String(t));
    ctx.fillText(label, px - 48, Y + 4);
  }

  ctx.restore();
  return {px, py, pw, ph, mapX, mapY};
}

function drawLine(ctx, axes, xs, ys, style){
  ctx.save();
  ctx.strokeStyle = style.stroke ?? '#fff';
  ctx.lineWidth = style.width ?? 2;
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const X = axes.mapX(xs[i]);
    const Y = axes.mapY(ys[i]);
    if(i===0) ctx.moveTo(X,Y);
    else ctx.lineTo(X,Y);
  }
  ctx.stroke();
  ctx.restore();
}

function drawMarker(ctx, axes, x, y, style){
  ctx.save();
  ctx.fillStyle = style.fill ?? '#fff';
  ctx.strokeStyle = style.stroke ?? 'rgba(0,0,0,0.0)';
  ctx.lineWidth = style.width ?? 1.5;
  const X = axes.mapX(x);
  const Y = axes.mapY(y);
  ctx.beginPath();
  ctx.arc(X, Y, style.r ?? 4.5, 0, Math.PI*2);
  ctx.fill();
  if(style.stroke && style.stroke !== 'rgba(0,0,0,0.0)') ctx.stroke();
  ctx.restore();
}

function drawVLine(ctx, axes, x, style){
  ctx.save();
  ctx.strokeStyle = style.stroke ?? '#fff';
  ctx.lineWidth = style.width ?? 2;
  const X = axes.mapX(x);
  ctx.beginPath();
  ctx.moveTo(X, axes.py);
  ctx.lineTo(X, axes.py + axes.ph);
  ctx.stroke();
  ctx.restore();
}

function drawLegend(ctx, x, y, items){
  const line = getComputedStyle(document.documentElement).getPropertyValue('--line').trim() || 'rgba(255,255,255,0.12)';
  const panel = 'rgba(0,0,0,0.06)';
  const text = getComputedStyle(document.documentElement).getPropertyValue('--text').trim() || '#fff';
  ctx.save();
  ctx.font = '700 12px ui-sans-serif, system-ui';
  const pad = 10;
  const rowH = 18;
  const w = Math.max(...items.map(it => ctx.measureText(it.label).width)) + 46;
  const h = items.length*rowH + pad*2 - 4;
  ctx.fillStyle = panel;
  ctx.strokeStyle = line;
  ctx.lineWidth = 1;
  roundRect(ctx, x, y, w, h, 12);
  ctx.fill();
  ctx.stroke();

  for(let i=0;i<items.length;i++){
    const yy = y + pad + i*rowH;
    ctx.strokeStyle = items[i].color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x+12, yy+6);
    ctx.lineTo(x+30, yy+6);
    ctx.stroke();
    ctx.fillStyle = text;
    ctx.fillText(items[i].label, x+36, yy+10);
  }
  ctx.restore();
}
function roundRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}

/* ===========================
   Scene / parameters
=========================== */
const state = {
  gammaDeg: 50,
  bMode: 'general',
  // example values (can be randomized)
  betaDeg: 60, // B angle in xy plane for general mode
  aMag: 1.0,
  bMag: 1.1,
  cMag: 0.9
};

const elGamma = document.getElementById('gamma');
const elGammaRead = document.getElementById('gammaRead');
const elBMode = document.getElementById('bMode');
document.getElementById('randomize').addEventListener('click', ()=>{
  // random but reasonable
  state.betaDeg = 20 + Math.random()*140;
  state.aMag = 0.6 + Math.random()*1.6;
  state.bMag = 0.6 + Math.random()*1.6;
  state.cMag = 0.6 + Math.random()*1.6;
  renderAll();
});

elGamma.addEventListener('input', ()=>{
  state.gammaDeg = Number(elGamma.value);
  elGammaRead.textContent = `γ = ${state.gammaDeg}°`;
  renderAll();
});
elBMode.addEventListener('change', ()=>{
  state.bMode = elBMode.value;
  renderAll();
});

/* ===========================
   Build example vectors A,B,C
   A fixed along +x.
   C rotated in xz-plane with angle γ from A.
=========================== */
function buildVectors(gammaDeg){
  const g = gammaDeg * Math.PI/180;

  // A along x
  const A = v(state.aMag, 0, 0);

  // Default C in xz plane
  let C = v(state.cMag*Math.cos(g), 0, state.cMag*Math.sin(g));

  // B depends on mode
  let B;
  if(state.bMode === 'general'){
    const b = state.betaDeg * Math.PI/180;
    B = v(state.bMag*Math.cos(b), state.bMag*Math.sin(b), 0);
  } else if(state.bMode === 'perp'){
    // Force B ⟂ A and B ⟂ C by construction.
    // Choose B parallel to A×C (if A and C not parallel). If parallel, choose z.
    const AxC = cross(A, C);
    if(norm(AxC) < 1e-12){
      B = v(0, state.bMag, 0); // perpendicular to A (x) and also to C (parallel x)
    } else {
      B = mul(state.bMag, unit(AxC));
    }
  } else { // 'align'
    // Force A ∥ C: set C parallel to A regardless of slider angle
    C = v(state.cMag, 0, 0);
    const b = state.betaDeg * Math.PI/180;
    B = v(state.bMag*Math.cos(b), state.bMag*Math.sin(b), 0);
  }

  return {A,B,C};
}

/* ===========================
   Compute identities
=========================== */
function jacobiSum(A,B,C){
  return add(add(cross(A, cross(B,C)), cross(B, cross(C,A))), cross(C, cross(A,B)));
}
function associator(A,B,C){
  return sub(cross(A, cross(B,C)), cross(cross(A,B), C));
}

/* ===========================
   Canvases
=========================== */
const diagram = setupCanvas(document.getElementById('diagram'));
const plot1 = setupCanvas(document.getElementById('plot1'));
const plot2 = setupCanvas(document.getElementById('plot2'));

/* ===========================
   Diagram draw (2D projection)
=========================== */
function drawDiagram(){
  const {ctx, resize} = diagram;
  const {w,h} = resize();

  const {A,B,C} = buildVectors(state.gammaDeg);
  const J = jacobiSum(A,B,C);
  const D = associator(A,B,C);

  // Simple 3D->2D projection
  // screen x = x + 0.55 z, screen y = -y + 0.25 z
  function proj(p){
    return {
      X: p.x + 0.55*p.z,
      Y: -p.y + 0.25*p.z
    };
  }

  const pad = 18;
  const cx = w/2;
  const cy = h/2 + 8;

  // scale to fit
  const scale = Math.min(w,h) * 0.30 / Math.max(1e-9, Math.max(norm(A), norm(B), norm(C)));

  const line = getComputedStyle(document.documentElement).getPropertyValue('--line').trim() || 'rgba(255,255,255,0.12)';
  const text = getComputedStyle(document.documentElement).getPropertyValue('--text').trim() || '#fff';
  const muted = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || 'rgba(255,255,255,0.7)';

  ctx.clearRect(0,0,w,h);

  // Title
  ctx.fillStyle = text;
  ctx.font = '800 14px ui-sans-serif, system-ui';
  ctx.fillText('Vector Geometry (example values)', pad, 20);

  // Axes (projected)
  ctx.strokeStyle = line;
  ctx.lineWidth = 1.2;
  const axesLen = Math.min(w,h)*0.28;
  function drawAxis(vec, label){
    const p = proj(vec);
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + p.X*axesLen, cy + p.Y*axesLen);
    ctx.stroke();
    ctx.fillStyle = muted;
    ctx.font = '700 12px ui-sans-serif, system-ui';
    ctx.fillText(label, cx + p.X*axesLen + 4, cy + p.Y*axesLen + 4);
  }
  // Use unit basis
  drawAxis(v(1,0,0), 'x');
  drawAxis(v(0,1,0), 'y');
  drawAxis(v(0,0,1), 'z');

  function drawVec(vec, label, color){
    const p = proj(vec);
    const x2 = cx + p.X*scale;
    const y2 = cy + p.Y*scale;

    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    // arrow head
    const ang = Math.atan2(y2-cy, x2-cx);
    const ah = 10;
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - ah*Math.cos(ang-0.45), y2 - ah*Math.sin(ang-0.45));
    ctx.lineTo(x2 - ah*Math.cos(ang+0.45), y2 - ah*Math.sin(ang+0.45));
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();

    ctx.fillStyle = text;
    ctx.font = '800 13px ui-sans-serif, system-ui';
    ctx.fillText(label, x2 + 8, y2 + 4);
  }

  const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#7dd3fc';
  const accent2 = getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim() || '#a78bfa';
  const good = getComputedStyle(document.documentElement).getPropertyValue('--good').trim() || '#34d399';

  drawVec(A, 'A', accent);
  drawVec(B, 'B', accent2);
  drawVec(C, 'C', '#ffffff');

  // Readouts
  const jMag = norm(J);
  const dMag = norm(D);
  const assocOK = dMag < 1e-10;

  ctx.fillStyle = muted;
  ctx.font = '700 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace';
  ctx.fillText(`|J| = ${jMag.toExponential(2)} (should be 0)`, pad, h - 44);
  ctx.fillStyle = assocOK ? good : muted;
  ctx.fillText(`|D| = ${dMag.toExponential(2)} (associativity error)`, pad, h - 24);

  // Mini legend
  drawLegend(ctx, w - 190, 10, [
    {label:'A', color: accent},
    {label:'B', color: accent2},
    {label:'C', color: '#ffffff'}
  ]);
}

/* ===========================
   Plot computations
=========================== */
function computeCurves(){
  const xs = []; // gamma degrees
  const j = [];
  const d = [];
  for(let g=0; g<=180; g+=2){
    const {A,B,C} = buildVectors(g);
    xs.push(g);
    j.push(norm(jacobiSum(A,B,C)));
    d.push(norm(associator(A,B,C)));
  }
  return {xs, j, d};
}

function drawPlot1(curves){
  const {ctx, resize} = plot1;
  const {w,h} = resize();
  ctx.clearRect(0,0,w,h);

  // y range: show tiny errors; clamp for nice axis
  const yMax = Math.max(...curves.j, 1e-16);
  const yMin = 0;

  const axes = drawAxes(ctx, {x:0,y:0,w,h}, 0, 180, yMin, yMax*1.2, {
    title: 'Jacobi Sum Magnitude |J(γ)|',
    xLabel: 'γ (degrees)',
    yLabel: '|J| (arb.)',
    xTicks: 6,
    yTicks: 4,
    xFmt: t => t.toFixed(0),
    yFmt: t => (t===0 ? '0' : t.toExponential(1))
  });

  // Draw curve
  drawLine(ctx, axes, curves.xs, curves.j, {stroke: '#ffffff', width: 2});

  // Current marker
  const {A,B,C} = buildVectors(state.gammaDeg);
  const J = norm(jacobiSum(A,B,C));
  drawMarker(ctx, axes, state.gammaDeg, J, {fill: '#ffffff', r: 5});

  drawLegend(ctx, axes.px + axes.pw - 180, axes.py + 10, [
    {label:'|J(γ)|', color:'#ffffff'}
  ]);
}

function drawPlot2(curves){
  const {ctx, resize} = plot2;
  const {w,h} = resize();
  ctx.clearRect(0,0,w,h);

  const yMax = Math.max(...curves.d, 1e-9);
  const yMin = 0;

  const axes = drawAxes(ctx, {x:0,y:0,w,h}, 0, 180, yMin, yMax*1.12, {
    title: 'Associator Magnitude |D(γ)| = |A×(B×C) − (A×B)×C|',
    xLabel: 'γ (degrees)',
    yLabel: '|D| (arb.)',
    xTicks: 6,
    yTicks: 5,
    xFmt: t => t.toFixed(0),
    yFmt: t => (t===0 ? '0' : t.toExponential(1))
  });

  // Draw curve
  const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#7dd3fc';
  drawLine(ctx, axes, curves.xs, curves.d, {stroke: accent, width: 2.5});

  // Vertical marker at current gamma
  const accent2 = getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim() || '#a78bfa';
  drawVLine(ctx, axes, state.gammaDeg, {stroke: accent2, width: 2});

  // Marker point
  const {A,B,C} = buildVectors(state.gammaDeg);
  const D = norm(associator(A,B,C));
  drawMarker(ctx, axes, state.gammaDeg, D, {fill: accent2, r: 5});

  // Label “near-zero” region (visual cue)
  const line = getComputedStyle(document.documentElement).getPropertyValue('--line').trim() || 'rgba(255,255,255,0.12)';
  const muted = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || 'rgba(255,255,255,0.7)';
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.05)';
  ctx.strokeStyle = line;
  ctx.lineWidth = 1;
  const yZeroBand = axes.mapY(yMax*0.02);
  roundRect(ctx, axes.px + 10, yZeroBand, axes.pw - 20, axes.py + axes.ph - yZeroBand - 10, 12);
  ctx.fill();
  ctx.stroke();
  ctx.fillStyle = muted;
  ctx.font = '700 12px ui-sans-serif, system-ui';
  ctx.fillText('Near-zero |D| means A×(B×C) ≈ (A×B)×C', axes.px + 18, yZeroBand + 18);
  ctx.restore();

  drawLegend(ctx, axes.px + axes.pw - 260, axes.py + 10, [
    {label:'|D(γ)|', color: accent},
    {label:'current γ', color: accent2}
  ]);
}

/* ===========================
   Render all
=========================== */
let cachedCurves = null;
function renderAll(){
  // Update readout
  elGammaRead.textContent = `γ = ${state.gammaDeg}°`;

  // Cache curves unless mode changes? For simplicity, recompute when needed.
  cachedCurves = computeCurves();

  drawDiagram();
  drawPlot1(cachedCurves);
  drawPlot2(cachedCurves);
}

// Resize handling
const ro = new ResizeObserver(()=> renderAll());
ro.observe(document.getElementById('diagram'));
ro.observe(document.getElementById('plot1'));
ro.observe(document.getElementById('plot2'));

// Initial
renderAll();
</script>
</body>
</html>
