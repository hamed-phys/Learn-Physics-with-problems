<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="color-scheme" content="dark"/>
  <title>Vector Algebra: Distributivity of Dot/Cross & Non-Associativity of Cross</title>
  <style>
    :root{
      --bg0:#07080b;
      --bg1:#0c0f16;
      --card:#101726cc;
      --card2:#0e1422cc;
      --text:#e9eefc;
      --muted:#aeb7d6;
      --faint:#7f8ab3;
      --line:#233055;
      --line2:#1a2340;
      --accent:#7bdcff;
      --accent2:#9cffc7;
      --warn:#ffd38a;
      --danger:#ff8aa0;
      --ok:#b9ffb3;
      --shadow: 0 18px 45px rgba(0,0,0,.45);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 900px at 20% 10%, rgba(123,220,255,.12), transparent 60%),
        radial-gradient(1000px 800px at 80% 30%, rgba(156,255,199,.10), transparent 55%),
        radial-gradient(900px 700px at 50% 95%, rgba(255,138,160,.08), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      position:relative;
      padding: 36px 18px 18px;
      border-bottom:1px solid var(--line2);
      background: linear-gradient(180deg, rgba(16,23,38,.65), rgba(16,23,38,.25));
      backdrop-filter: blur(10px);
    }
    .wrap{max-width:1100px; margin:0 auto; padding:0 10px;}
    .title{
      display:flex; gap:14px; align-items:flex-start; flex-wrap:wrap;
    }
    .badge{
      font-family:var(--mono);
      font-size:12px;
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      color:var(--muted);
      background:rgba(7,8,11,.35);
      box-shadow: 0 10px 25px rgba(0,0,0,.25);
      white-space:nowrap;
    }
    h1{
      margin:0;
      font-size:clamp(22px, 2.6vw, 34px);
      letter-spacing:.2px;
      line-height:1.15;
    }
    .sub{
      margin-top:8px;
      color:var(--muted);
      max-width:72ch;
    }

    /* Layout with sticky TOC */
    main{padding: 18px 18px 60px;}
    .grid{
      max-width:1100px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 280px 1fr;
      gap:16px;
      align-items:start;
      padding: 0 10px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr;}
    }

    nav.toc{
      position:sticky;
      top:14px;
      border:1px solid var(--line2);
      background: rgba(16,23,38,.55);
      backdrop-filter: blur(10px);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .toc .toc-h{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--line2);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .toc h2{
      margin:0;
      font-size:14px;
      letter-spacing:.4px;
      color:var(--muted);
      text-transform:uppercase;
    }
    .toc a{
      display:block;
      padding:10px 14px;
      border-top:1px solid rgba(35,48,85,.35);
      color:var(--text);
      font-size:14px;
      text-decoration:none;
    }
    .toc a:hover{background: rgba(123,220,255,.08)}
    .toc a small{color:var(--muted)}
    .toc .mini{
      font-family:var(--mono);
      font-size:12px;
      color:var(--muted);
      padding: 2px 8px;
      border:1px solid var(--line);
      border-radius:999px;
      background: rgba(7,8,11,.35);
      cursor:pointer;
      user-select:none;
    }

    section.card{
      border:1px solid var(--line2);
      background: rgba(16,23,38,.55);
      backdrop-filter: blur(10px);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding:16px 16px 10px;
      border-bottom:1px solid var(--line2);
      background: linear-gradient(180deg, rgba(123,220,255,.08), transparent);
    }
    .card h2{
      margin:0;
      font-size:18px;
      letter-spacing:.2px;
    }
    .card .bd{padding:16px;}
    .muted{color:var(--muted)}
    .faint{color:var(--faint)}
    .kicker{
      font-family:var(--mono);
      color:var(--muted);
      font-size:12px;
      letter-spacing:.3px;
      text-transform:uppercase;
      margin-bottom:6px;
    }

    .qs{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 720px){
      .qs{grid-template-columns:1fr;}
    }
    ul{margin:10px 0 0 20px}
    li{margin:6px 0}
    .callout{
      border:1px solid var(--line);
      background: rgba(7,8,11,.35);
      border-radius: 14px;
      padding:12px 12px;
      margin: 12px 0;
    }
    .callout.ok{border-color: rgba(185,255,179,.35)}
    .callout.warn{border-color: rgba(255,211,138,.35)}
    .callout.danger{border-color: rgba(255,138,160,.35)}
    .callout b{color:var(--text)}
    .cols{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .cols{grid-template-columns:1fr;}
    }

    /* Equation blocks + copy buttons */
    .eq{
      position:relative;
      border:1px solid var(--line);
      background: rgba(7,8,11,.35);
      border-radius: 14px;
      padding: 12px 12px 12px 12px;
      margin: 12px 0;
      overflow:auto;
    }
    .eq pre{
      margin:0;
      font-family: var(--mono);
      font-size: 13px;
      line-height:1.5;
      white-space:pre;
    }
    .copyBtn{
      position:absolute;
      top:10px; right:10px;
      font-family:var(--mono);
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(16,23,38,.7);
      color: var(--text);
      cursor:pointer;
      user-select:none;
    }
    .copyBtn:hover{background: rgba(123,220,255,.12); border-color: rgba(123,220,255,.35)}
    .copyBtn:active{transform: translateY(1px)}
    .copyNote{
      font-size:12px;
      color: var(--muted);
      margin-top:8px;
      font-family:var(--mono);
    }

    /* Visual lab */
    .lab{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .controls{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:10px;
      align-items:end;
      border:1px solid var(--line2);
      border-radius: 16px;
      padding:12px;
      background: rgba(7,8,11,.28);
    }
    .ctrl{
      grid-column: span 6;
      min-width: 0;
    }
    .ctrl.small{grid-column: span 3;}
    @media (max-width: 980px){
      .ctrl{grid-column: span 12;}
      .ctrl.small{grid-column: span 6;}
    }
    label{
      display:block;
      font-size:12px;
      color:var(--muted);
      margin-bottom:6px;
      letter-spacing:.2px;
    }
    input[type="range"]{width:100%}
    select, button{
      width:100%;
      padding:10px 10px;
      border-radius: 12px;
      border:1px solid var(--line);
      background: rgba(16,23,38,.65);
      color: var(--text);
      outline:none;
      cursor:pointer;
      font-family: var(--sans);
    }
    button:hover{border-color: rgba(123,220,255,.35); background: rgba(123,220,255,.10)}
    .readout{
      font-family:var(--mono);
      font-size:12px;
      color: var(--muted);
      margin-top:6px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .canvasGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 980px){
      .canvasGrid{grid-template-columns:1fr;}
    }
    figure.viz{
      margin:0;
      border:1px solid var(--line2);
      border-radius: 16px;
      background: rgba(7,8,11,.28);
      overflow:hidden;
    }
    figure.viz figcaption{
      padding:10px 12px;
      border-top:1px solid var(--line2);
      color:var(--muted);
      font-size:13px;
    }
    canvas{
      display:block;
      width:100%;
      height:340px;
      background: rgba(10,12,18,.22);
    }
    .miniRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 720px){
      .miniRow{grid-template-columns:1fr;}
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-family:var(--mono);
      font-size:12px;
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      background: rgba(7,8,11,.35);
      color: var(--muted);
    }

    .boxFinal{
      border:1px solid rgba(185,255,179,.35);
      background: rgba(185,255,179,.08);
      border-radius: 16px;
      padding:14px 14px;
      margin: 12px 0;
    }
    .boxFinal h3{margin:0 0 8px 0; font-size:16px}
    .boxFinal .eq{margin:10px 0 0 0; border-color: rgba(185,255,179,.35)}
    footer{
      border-top:1px solid var(--line2);
      padding:18px;
      color:var(--muted);
      font-size:13px;
    }
    .printHint{
      font-family:var(--mono);
      font-size:12px;
      color:var(--faint);
      margin-top:10px;
    }

    /* subtle motion */
    @media (prefers-reduced-motion: no-preference){
      .card{animation: pop .45s ease-out}
      @keyframes pop{
        from{transform: translateY(6px); opacity:.0}
        to{transform: translateY(0); opacity:1}
      }
    }

    @media print{
      header, nav.toc{position:static; box-shadow:none}
      body{background:#fff; color:#000}
      section.card{background:#fff; border-color:#ccc; box-shadow:none}
      .eq, figure.viz, .controls, .callout{background:#fff}
      a{color:#000; text-decoration:underline}
      .copyBtn{display:none}
      canvas{height:260px}
    }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="title">
      <span class="badge">Vector Algebra • Dot & Cross Products</span>
      <span class="badge">Distributivity • Associativity Test</span>
    </div>
    <h1>Show dot/cross distributivity (coplanar & general) and test cross-product associativity</h1>
    <p class="sub">
      We prove distributive laws using the geometric definitions (projection for dot, oriented area for cross),
      then show the cross product is <em>not</em> associative via a clean counterexample and a general identity.
    </p>
  </div>
</header>

<main>
  <div class="grid">
    <nav class="toc" aria-label="Table of Contents">
      <div class="toc-h">
        <h2>Contents</h2>
        <span class="mini" id="btnTop" title="Scroll to top">↑ top</span>
      </div>
      <a href="#quick">Quick Summary <small>3–6 bullets</small></a>
      <a href="#analysis">PART 1 — Problem Analysis</a>
      <a href="#strategy">PART 2 — Strategy & Tips</a>
      <a href="#solution">PART 3 — Full Solution</a>
      <a href="#vizlab">Interactive Visual Lab</a>
      <a href="#final">Final Results</a>
    </nav>

    <div class="stack" style="display:grid; gap:16px;">

      <section class="card" id="quick">
        <div class="hd">
          <div class="kicker">Quick Summary</div>
          <h2>What you should take away</h2>
        </div>
        <div class="bd">
          <div class="qs">
            <div class="callout ok">
              <b>Dot product distributive:</b>
              <ul>
                <li>(A + B) · C = A · C + B · C (always, coplanar or not)</li>
                <li>Geometric meaning: projection is linear</li>
              </ul>
            </div>
            <div class="callout ok">
              <b>Cross product distributive:</b>
              <ul>
                <li>(A + B) × C = A × C + B × C and A × (B + C) = A × B + A × C</li>
                <li>Geometric meaning: oriented area is additive</li>
              </ul>
            </div>
            <div class="callout danger">
              <b>Cross product is NOT associative:</b>
              <ul>
                <li>(A × B) × C ≠ A × (B × C) in general</li>
                <li>Counterexample: A = i, B = j, C = j → LHS = −i, RHS = 0</li>
              </ul>
            </div>
            <div class="callout warn">
              <b>Key identity (vector triple product):</b>
              <div class="eq" style="margin:10px 0 0;">
                <button class="copyBtn" data-copy="A×(B×C)=B(A·C)−C(A·B)">copy</button>
                <pre>A×(B×C) = B (A·C) − C (A·B)</pre>
              </div>
              <div class="muted">This explains why associativity fails: the two nestings produce different linear combinations.</div>
            </div>
          </div>
          <div class="printHint">Print-friendly: use your browser print (copy buttons hide automatically).</div>
        </div>
      </section>

      <section class="card" id="analysis">
        <div class="hd">
          <div class="kicker">PART 1 — Problem Analysis</div>
          <h2>Restate the tasks and identify what must be proved</h2>
        </div>
        <div class="bd">
          <article>
            <h3 style="margin-top:0">1) Rewrite the problem in plain words</h3>
            <p>
              Using the geometric definitions of the dot product and cross product (and diagrams),
              prove that both operations are <em>distributive</em> over vector addition.
              Do this first when three vectors are coplanar, then in full 3D.
              Finally, test whether the cross product is <em>associative</em>; if it is, prove it, and if not,
              give a counterexample.
            </p>

            <div class="cols">
              <div class="callout">
                <h4 style="margin:0 0 8px 0">Given quantities</h4>
                <ul>
                  <li>Vectors <span class="pill">A</span>, <span class="pill">B</span>, <span class="pill">C</span> in ℝ³ (or ℝ² for coplanar).</li>
                  <li>Definitions:
                    <ul>
                      <li>Dot: <span class="pill">A·B = |A||B|cosθ</span> (projection interpretation)</li>
                      <li>Cross: <span class="pill">|A×B| = |A||B|sinθ</span>, direction by right-hand rule (oriented area)</li>
                    </ul>
                  </li>
                </ul>
              </div>
              <div class="callout">
                <h4 style="margin:0 0 8px 0">Unknowns / what must be found</h4>
                <ul>
                  <li>Prove distributivity:
                    <ul>
                      <li>(A + B) · C = A · C + B · C</li>
                      <li>(A + B) × C = A × C + B × C (and similarly A × (B + C))</li>
                    </ul>
                  </li>
                  <li>Determine associativity:
                    <ul>
                      <li>Is (A×B)×C equal to A×(B×C)?</li>
                      <li>If not, provide a clear counterexample.</li>
                    </ul>
                  </li>
                </ul>
              </div>
            </div>

            <h3>2) Relevant principles and why they apply</h3>
            <ul>
              <li><b>Linearity of projection</b>: the dot product measures how much one vector points along another (scalar projection), and projections add when vectors add.</li>
              <li><b>Additivity of (oriented) area</b>: the cross product magnitude is parallelogram area; if you split a parallelogram formed by (A+B) and C into two parallelograms (A,C) and (B,C), areas add with sign/orientation.</li>
              <li><b>Right-hand rule / orientation</b>: keeps track of sign (direction) of the area normal for cross products.</li>
              <li><b>Vector triple product identity</b>: gives an explicit algebraic form for A×(B×C), making the failure of associativity transparent.</li>
            </ul>

            <h3>3) Possible approaches</h3>
            <ul>
              <li><b>Geometric (diagrams)</b>: use projection (dot) and oriented area (cross); best for “why”.</li>
              <li><b>Component/coordinate proof</b>: write vectors in components and expand; best for “always true in 3D”, but less intuitive.</li>
              <li><b>Mixed approach</b>: geometric proof in coplanar case + component argument to extend to general 3D, then use triple-product identity for associativity.</li>
            </ul>

            <div class="callout ok">
              <b>Chosen approach:</b> Mixed approach. We’ll prove distributivity with clean geometry in a plane (coplanar),
              then extend to 3D by decomposing vectors into parallel/perpendicular components (or by components).
              For associativity, we’ll give a counterexample and connect it to the triple-product identity.
            </div>
          </article>
        </div>
      </section>

      <section class="card" id="strategy">
        <div class="hd">
          <div class="kicker">PART 2 — Strategy & Tips</div>
          <h2>Roadmap (no algebra yet)</h2>
        </div>
        <div class="bd">
          <ol>
            <li><b>Dot product (coplanar)</b> — Goal: show projection is additive. Tool: scalar projection definition and similar triangles.</li>
            <li><b>Dot product (general 3D)</b> — Goal: reduce to coplanar geometry. Tool: decompose A and B into components along C and perpendicular to C.</li>
            <li><b>Cross product (coplanar)</b> — Goal: show oriented area additivity. Tool: parallelogram decomposition + right-hand rule sign.</li>
            <li><b>Cross product (general 3D)</b> — Goal: argue additivity holds in ℝ³. Tool: choose a coordinate system with C as an axis, or use component expansion with determinant form.</li>
            <li><b>Associativity test</b> — Goal: decide true/false. Tool: compute one explicit counterexample using unit vectors.</li>
            <li><b>Explain why it fails</b> — Goal: conceptual understanding. Tool: triple-product identity A×(B×C)=B(A·C)−C(A·B).</li>
            <li><b>Sanity checks</b> — Goal: confirm results. Tool: limiting cases (e.g., B=0, C parallel A), and dimensional/units consistency.</li>
          </ol>

          <div class="miniRow">
            <div class="callout warn">
              <b>Common mistakes</b>
              <ul>
                <li>Confusing <span class="pill">A×B</span> with a scalar area (it’s a vector normal with magnitude = area).</li>
                <li>For cross product, forgetting orientation: area can be “signed” via right-hand rule.</li>
                <li>Assuming associativity because multiplication of numbers is associative (vector products aren’t).</li>
              </ul>
            </div>
            <div class="callout ok">
              <b>Quick tips</b>
              <ul>
                <li>For dot distributivity: think “projection is linear”.</li>
                <li>For cross distributivity: think “parallelogram area splits into two”.</li>
                <li>For associativity: test with basis vectors i, j, k.</li>
              </ul>
            </div>
          </div>
        </div>
      </section>

      <section class="card" id="solution">
        <div class="hd">
          <div class="kicker">PART 3 — Full Solution</div>
          <h2>Derivations, explanations, and checks</h2>
        </div>
        <div class="bd">
          <article>
            <h3 style="margin-top:0">Physical intuition (geometry-first)</h3>
            <div class="callout">
              <ul>
                <li><b>Dot product</b> measures “how much of one vector lies along another.” If you add two vectors first, their “along C” parts add, so the dot product must distribute.</li>
                <li><b>Cross product</b> measures “oriented area.” The parallelogram built from (A+B) and C is exactly the union (with matching orientation) of parallelograms from A with C and B with C, so the cross product distributes.</li>
                <li><b>Associativity</b> would mean “taking a perpendicular area vector and crossing again” behaves like ordinary multiplication — but it doesn’t; the second cross depends on a different plane and produces a different direction.</li>
              </ul>
            </div>

            <h3>1.1 Dot product distributive</h3>

            <h4>Case (a): A, B, C coplanar</h4>
            <p>
              Let θ<sub>A</sub> be the angle between A and C, and θ<sub>B</sub> the angle between B and C. Using the definition
              <span class="pill">A·C = |A||C|cosθ</span>, interpret <span class="pill">|A|cosθ</span> as the scalar projection of A onto the direction of C.
            </p>

            <div class="eq">
              <button class="copyBtn" data-copy="(A+B)·C = A·C + B·C">copy</button>
              <pre>(A + B) · C  =  A · C  +  B · C</pre>
            </div>

            <p>
              In a plane, draw C as a reference direction. Drop perpendiculars from the tips of A and B to the line along C.
              The scalar projection of A onto C is <span class="pill">proj_C(A) = |A|cosθ_A</span>, and similarly for B.
              When you add vectors head-to-tail, the component along C adds:
            </p>
            <ul>
              <li>Along-C component of (A+B) = (along-C component of A) + (along-C component of B).</li>
              <li>Multiply by |C| to convert “component along unit direction of C” into dot product with C.</li>
            </ul>
            <p>
              Therefore
              <span class="pill">(A+B)·C = |C| (proj_C(A) + proj_C(B)) = |C|proj_C(A) + |C|proj_C(B) = A·C + B·C</span>.
            </p>

            <h4>Case (b): General 3D</h4>
            <p>
              Even in 3D, only the components <em>parallel</em> to C contribute to the dot product with C.
              Decompose A and B into parts parallel and perpendicular to C:
            </p>

            <div class="eq">
              <button class="copyBtn" data-copy="A = A∥ + A⊥,  with A∥ ∥ C and A⊥ ⟂ C (similarly for B)">copy</button>
              <pre>A = A∥ + A⊥,   where A∥ ∥ C and A⊥ ⟂ C  (and similarly B = B∥ + B⊥)</pre>
            </div>

            <p>
              Then
              <span class="pill">A⊥·C = 0</span> and <span class="pill">B⊥·C = 0</span>.
              So:
            </p>

            <div class="eq">
              <button class="copyBtn" data-copy="(A+B)·C = (A∥+A⊥+B∥+B⊥)·C = A∥·C + B∥·C = A·C + B·C">copy</button>
              <pre>(A+B)·C
= (A∥ + A⊥ + B∥ + B⊥)·C
= A∥·C + A⊥·C + B∥·C + B⊥·C
= A∥·C + B∥·C
= A·C + B·C</pre>
            </div>

            <div class="callout ok">
              <b>Conclusion:</b> Dot product is distributive in all cases, coplanar or general 3D.
            </div>

            <h3>1.1 Cross product distributive</h3>

            <h4>Case (a): coplanar A, B, C</h4>
            <p>
              In a plane, the cross product points perpendicular to that plane (either “out of the page” or “into the page”),
              with magnitude equal to the parallelogram area:
              <span class="pill">|A×C| = |A||C|sinθ</span>.
            </p>

            <p>
              Consider the parallelogram built from (A+B) and C. Geometrically, placing A and B tail-to-tail,
              the shape for (A+B, C) can be partitioned into two parallelograms: one from (A,C) and one from (B,C),
              with the same orientation (right-hand rule).
              Hence the oriented area vectors add:
            </p>

            <div class="eq">
              <button class="copyBtn" data-copy="(A+B)×C = A×C + B×C">copy</button>
              <pre>(A + B) × C  =  A × C  +  B × C</pre>
            </div>

            <p class="muted">
              Orientation note: if A and B contribute areas with opposite orientation relative to C, the vector addition naturally subtracts,
              matching the right-hand rule sign.
            </p>

            <h4>Case (b): general 3D</h4>
            <p>
              The cross product is bilinear (linear in each argument separately). One clean way to see this rigorously is to use components.
              Write A=(A<sub>x</sub>,A<sub>y</sub>,A<sub>z</sub>), B=(B<sub>x</sub>,B<sub>y</sub>,B<sub>z</sub>), C=(C<sub>x</sub>,C<sub>y</sub>,C<sub>z</sub>).
              Using the determinant/component definition:
            </p>

            <div class="eq">
              <button class="copyBtn" data-copy="A×C = (AyCz−AzCy, AzCx−AxCz, AxCy−AyCx)">copy</button>
              <pre>A×C = ( Ay Cz − Az Cy ,  Az Cx − Ax Cz ,  Ax Cy − Ay Cx )</pre>
            </div>

            <p>
              Now compute (A+B)×C component-wise (showing one component; the others are identical in structure):
            </p>

            <div class="eq">
              <button class="copyBtn" data-copy="[(A+B)×C]x = (Ay+By)Cz − (Az+Bz)Cy = (AyCz−AzCy) + (ByCz−BzCy)">copy</button>
              <pre>[(A+B)×C]x
= (Ay+By) Cz − (Az+Bz) Cy
= (Ay Cz − Az Cy) + (By Cz − Bz Cy)
= [A×C]x + [B×C]x</pre>
            </div>

            <p>
              Doing the same for y and z components gives
              <span class="pill">(A+B)×C = A×C + B×C</span>.
              Similarly, <span class="pill">A×(B+C) = A×B + A×C</span>.
            </p>

            <div class="callout ok">
              <b>Conclusion:</b> Cross product is distributive (and bilinear) in all cases.
            </div>

            <h3>1.2 Is the cross product associative?</h3>
            <p>
              We test whether
              <span class="pill">(A×B)×C ?= A×(B×C)</span>.
              It is <b>not</b> true in general.
            </p>

            <h4>Counterexample (simple and decisive)</h4>
            <p>
              Choose standard unit vectors i, j, k in ℝ³.
              Let <span class="pill">A=i</span>, <span class="pill">B=j</span>, <span class="pill">C=j</span>.
            </p>

            <div class="eq">
              <button class="copyBtn" data-copy="A=i, B=j, C=j; (A×B)×C = (i×j)×j = k×j = −i, but A×(B×C)=i×(j×j)=i×0=0">copy</button>
              <pre>A = i,  B = j,  C = j

(A×B)×C = (i×j)×j = k×j = −i

A×(B×C) = i×(j×j) = i×0 = 0</pre>
            </div>

            <div class="callout danger">
              <b>Therefore:</b> (A×B)×C ≠ A×(B×C). The cross product is <b>not associative</b>.
            </div>

            <h4>Why it fails (triple-product identity)</h4>
            <p>
              A standard identity (provable by components) is:
            </p>

            <div class="eq">
              <button class="copyBtn" data-copy="A×(B×C)=B(A·C)−C(A·B)">copy</button>
              <pre>A×(B×C) = B (A·C) − C (A·B)</pre>
            </div>

            <p>
              This shows <span class="pill">A×(B×C)</span> lies in the plane spanned by B and C.
              Meanwhile, <span class="pill">(A×B)×C</span> lies in the plane spanned by (A×B) and C, which is generally different.
              Unless special alignments occur, the two expressions cannot match for all vectors.
            </p>

            <h4>Sanity checks</h4>
            <ul>
              <li><b>Units:</b> If vectors carry units U, then dot has U², cross has U². Both sides of distributive laws match.</li>
              <li><b>Limiting cases:</b>
                <ul>
                  <li>If B=0, then (A+0)·C = A·C and (A+0)×C = A×C.</li>
                  <li>If A ∥ C, then A×C=0; distributivity becomes (B×C) on both sides.</li>
                </ul>
              </li>
              <li><b>Physical interpretation:</b> cross-product non-associativity matters in torque/rotation algebra; that’s why vector identities (triple products) are used instead of “associating freely.”</li>
            </ul>
          </article>
        </div>
      </section>

      <section class="card" id="vizlab">
        <div class="hd">
          <div class="kicker">Interactive Visual Lab</div>
          <h2>Explore coplanar vs general case and see associativity failure</h2>
        </div>
        <div class="bd">
          <div class="lab">
            <div class="controls" role="group" aria-label="Interactive controls">
              <div class="ctrl">
                <label for="cz">Out-of-plane component of C:  C<sub>z</sub>  (0 ⇒ coplanar case)</label>
                <input id="cz" type="range" min="0" max="1.5" step="0.01" value="0.00"/>
                <div class="readout" id="czRead">Cz = 0.00 (coplanar)</div>
              </div>

              <div class="ctrl">
                <label for="theta">Angle sweep for B around z-axis (used in plots): θ<sub>B</sub> (degrees)</label>
                <input id="theta" type="range" min="0" max="180" step="1" value="60"/>
                <div class="readout" id="thetaRead">θB = 60° (current B direction in diagram)</div>
              </div>

              <div class="ctrl small">
                <label for="mode">Diagram mode</label>
                <select id="mode">
                  <option value="both" selected>Show A,B,C and (A+B)</option>
                  <option value="dot">Emphasize dot (projection on C)</option>
                  <option value="cross">Emphasize cross (oriented area)</option>
                  <option value="assoc">Emphasize associativity defect</option>
                </select>
                <div class="readout">Changes labels/overlays</div>
              </div>

              <div class="ctrl small">
                <label for="reset">Action</label>
                <button id="reset" type="button">Reset example values</button>
                <div class="readout">A=(1.2,0.3,0.2), |C|≈1.2</div>
              </div>
            </div>

            <div class="canvasGrid">
              <figure class="viz">
                <canvas id="diag" aria-label="Vector diagram canvas"></canvas>
                <figcaption>
                  <b>Diagram:</b> 3D vectors projected to screen. Toggle coplanar/general with C<sub>z</sub>.
                  Labels show dot/cross values and the associativity defect.
                </figcaption>
              </figure>

              <figure class="viz">
                <canvas id="plot1" aria-label="Main plot canvas"></canvas>
                <figcaption>
                  <b>Main plot:</b> Distributivity check vs sweep angle θ (LHS and RHS overlap). Units: arbitrary (a.u.).
                </figcaption>
              </figure>
            </div>

            <figure class="viz">
              <canvas id="plot2" aria-label="Secondary plot canvas"></canvas>
              <figcaption>
                <b>Secondary plot:</b> Associativity defect magnitude ‖(A×B)×C − A×(B×C)‖ vs θ. Nonzero ⇒ not associative.
              </figcaption>
            </figure>

            <div class="callout">
              <div class="pill">Example values used in plots</div>
              <div class="muted" style="margin-top:8px">
                We use fixed example vectors (clearly for visualization only): A = (1.2, 0.3, 0.2), and
                C = (0.4, 1.1, C<sub>z</sub>). The slider changes C<sub>z</sub>, and θ changes B’s direction:
                B(θ) = (cosθ, sinθ, 0.25).
              </div>
            </div>

          </div>
        </div>
      </section>

      <section class="card" id="final">
        <div class="hd">
          <div class="kicker">Final Results</div>
          <h2>Boxed answers (copy-ready)</h2>
        </div>
        <div class="bd">
          <div class="boxFinal">
            <h3>Distributivity</h3>
            <div class="eq">
              <button class="copyBtn" data-copy="Dot product: (A+B)·C = A·C + B·C (coplanar and general 3D).">copy</button>
              <pre>Dot product:
(A + B) · C = A · C + B · C     (coplanar and general 3D)</pre>
            </div>
            <div class="eq">
              <button class="copyBtn" data-copy="Cross product: (A+B)×C = A×C + B×C and A×(B+C)=A×B + A×C (coplanar and general 3D).">copy</button>
              <pre>Cross product:
(A + B) × C = A × C + B × C
A × (B + C) = A × B + A × C     (coplanar and general 3D)</pre>
            </div>
          </div>

          <div class="boxFinal">
            <h3>Associativity of cross product</h3>
            <div class="eq">
              <button class="copyBtn" data-copy="Not associative in general: (A×B)×C ≠ A×(B×C). Counterexample: A=i, B=j, C=j ⇒ (A×B)×C = −i, while A×(B×C)=0.">copy</button>
              <pre>Not associative in general:
(A×B)×C ≠ A×(B×C)

Counterexample:
A = i, B = j, C = j
(A×B)×C = (i×j)×j = k×j = −i
A×(B×C) = i×(j×j) = i×0 = 0</pre>
            </div>
            <div class="eq">
              <button class="copyBtn" data-copy="Useful identity: A×(B×C)=B(A·C)−C(A·B).">copy</button>
              <pre>Useful identity (explains the failure):
A×(B×C) = B(A·C) − C(A·B)</pre>
            </div>
          </div>

          <div class="copyNote" id="copyStatus" aria-live="polite"></div>
        </div>
      </section>

    </div>
  </div>
</main>

<footer>
  <div class="wrap">
    <div class="muted">
      Built with vanilla HTML/CSS/JS. No external libraries. Canvases are responsive and use devicePixelRatio for crisp rendering.
    </div>
  </div>
</footer>

<script>
/* ============================
   Utilities: vectors & math
============================ */
const V = {
  add: (a,b)=>[a[0]+b[0], a[1]+b[1], a[2]+b[2]],
  sub: (a,b)=>[a[0]-b[0], a[1]-b[1], a[2]-b[2]],
  dot: (a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2],
  cross: (a,b)=>[
    a[1]*b[2]-a[2]*b[1],
    a[2]*b[0]-a[0]*b[2],
    a[0]*b[1]-a[1]*b[0]
  ],
  scale: (a,s)=>[a[0]*s,a[1]*s,a[2]*s],
  norm: (a)=>Math.hypot(a[0],a[1],a[2]),
  unit: (a)=>{ const n=Math.hypot(a[0],a[1],a[2])||1; return [a[0]/n,a[1]/n,a[2]/n]; }
};

function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function deg2rad(d){ return d*Math.PI/180; }
function fmt(x, digits=3){
  const ax=Math.abs(x);
  if(ax !== 0 && (ax<1e-3 || ax>1e4)) return x.toExponential(2);
  return x.toFixed(digits);
}

/* ============================
   Canvas setup helpers
============================ */
function setupCanvas(canvas){
  const ctx = canvas.getContext('2d');
  function resize(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(320, rect.width);
    const h = Math.max(240, rect.height);
    canvas.width = Math.floor(w*dpr);
    canvas.height = Math.floor(h*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return {w, h, dpr};
  }
  return {ctx, resize};
}

function clearPanel(ctx, w, h){
  ctx.clearRect(0,0,w,h);
  // subtle vignette
  const g = ctx.createRadialGradient(w*0.35,h*0.25,10, w*0.5,h*0.5, Math.max(w,h)*0.75);
  g.addColorStop(0, 'rgba(123,220,255,0.07)');
  g.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,w,h);
}

/* ============================
   Plotting primitives (no external libs)
============================ */
function drawAxes(ctx, box, xLabel, yLabel, title){
  const {x,y,w,h} = box;
  ctx.save();
  ctx.translate(x,y);

  // Title
  ctx.fillStyle = 'rgba(233,238,252,0.92)';
  ctx.font = '600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText(title, 8, 18);

  // Plot area
  const padL = 56, padR=14, padT=30, padB=44;
  const px = padL, py = padT, pw = w - padL - padR, ph = h - padT - padB;

  // Background
  ctx.fillStyle = 'rgba(7,8,11,0.32)';
  ctx.strokeStyle = 'rgba(26,35,64,0.9)';
  ctx.lineWidth = 1;
  roundRect(ctx, px, py, pw, ph, 12, true, true);

  // Grid & ticks (10 x 8)
  ctx.strokeStyle = 'rgba(35,48,85,0.40)';
  ctx.lineWidth = 1;
  const nx=10, ny=8;
  for(let i=0;i<=nx;i++){
    const gx = px + (pw*i/nx);
    ctx.beginPath();
    ctx.moveTo(gx, py);
    ctx.lineTo(gx, py+ph);
    ctx.stroke();
  }
  for(let j=0;j<=ny;j++){
    const gy = py + (ph*j/ny);
    ctx.beginPath();
    ctx.moveTo(px, gy);
    ctx.lineTo(px+pw, gy);
    ctx.stroke();
  }

  // Labels
  ctx.fillStyle = 'rgba(174,183,214,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillText(xLabel, px + pw/2 - ctx.measureText(xLabel).width/2, py+ph+32);

  ctx.save();
  ctx.translate(16, py + ph/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
  ctx.restore();

  ctx.restore();
  return {padL:56, padR:14, padT:30, padB:44, px:x+56, py:y+30, pw:w-56-14, ph:h-30-44};
}

function roundRect(ctx, x, y, w, h, r, fill, stroke){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

function mapX(x, xmin, xmax, px, pw){
  return px + (x - xmin) * (pw / (xmax - xmin));
}
function mapY(y, ymin, ymax, py, ph){
  return py + ph - (y - ymin) * (ph / (ymax - ymin));
}

function drawLineSeries(ctx, plot, xs, ys, style){
  const {px,py,pw,ph, xmin,xmax,ymin,ymax} = plot;
  ctx.save();
  ctx.strokeStyle = style;
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const X = mapX(xs[i], xmin, xmax, px, pw);
    const Y = mapY(ys[i], ymin, ymax, py, ph);
    if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
  }
  ctx.stroke();
  ctx.restore();
}

function drawLegend(ctx, x, y, items){
  ctx.save();
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillStyle = 'rgba(174,183,214,0.95)';
  const pad=10, gap=10, lineLen=22, lh=18;
  const w = Math.max(...items.map(it=>ctx.measureText(it.label).width)) + pad*2 + lineLen + gap;
  const h = items.length*lh + pad*2;
  ctx.fillStyle = 'rgba(7,8,11,0.40)';
  ctx.strokeStyle = 'rgba(35,48,85,0.7)';
  roundRect(ctx, x, y, w, h, 12, true, true);

  for(let i=0;i<items.length;i++){
    const yy = y + pad + (i+0.7)*lh;
    ctx.strokeStyle = items[i].color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x+pad, yy-4);
    ctx.lineTo(x+pad+lineLen, yy-4);
    ctx.stroke();

    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.fillText(items[i].label, x+pad+lineLen+gap, yy);
  }
  ctx.restore();
}

function drawTicks(ctx, plot, xticks=6, yticks=5){
  const {px,py,pw,ph, xmin,xmax,ymin,ymax} = plot;
  ctx.save();
  ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillStyle = 'rgba(174,183,214,0.95)';
  ctx.strokeStyle = 'rgba(35,48,85,0.65)';
  ctx.lineWidth = 1;

  // x ticks
  for(let i=0;i<=xticks;i++){
    const xv = xmin + (xmax-xmin)*i/xticks;
    const X = mapX(xv, xmin, xmax, px, pw);
    ctx.beginPath();
    ctx.moveTo(X, py+ph);
    ctx.lineTo(X, py+ph+6);
    ctx.stroke();
    const t = (Math.abs(xv) < 1e-9) ? "0" : String(Math.round(xv));
    const tw = ctx.measureText(t).width;
    ctx.fillText(t, X - tw/2, py+ph+18);
  }

  // y ticks
  for(let j=0;j<=yticks;j++){
    const yv = ymin + (ymax-ymin)*j/yticks;
    const Y = mapY(yv, ymin, ymax, py, ph);
    ctx.beginPath();
    ctx.moveTo(px-6, Y);
    ctx.lineTo(px, Y);
    ctx.stroke();
    const t = fmt(yv, 2);
    const tw = ctx.measureText(t).width;
    ctx.fillText(t, px-10-tw, Y+4);
  }

  ctx.restore();
}

/* ============================
   3D -> 2D projection for diagram
============================ */
function project3D(p, w, h){
  // Simple isometric-like projection
  const s = Math.min(w,h) * 0.26;
  const [x,y,z] = p;
  const X = (x - y) * 0.85;
  const Y = (x + y) * 0.45 - z * 1.05;
  return [w*0.5 + X*s, h*0.58 + Y*s];
}

function drawArrow(ctx, from, to, color, label){
  const [x0,y0]=from, [x1,y1]=to;
  const dx=x1-x0, dy=y1-y0;
  const L=Math.hypot(dx,dy) || 1;
  const ux=dx/L, uy=dy/L;

  ctx.save();
  ctx.strokeStyle=color;
  ctx.fillStyle=color;
  ctx.lineWidth=2.5;
  ctx.beginPath();
  ctx.moveTo(x0,y0);
  ctx.lineTo(x1,y1);
  ctx.stroke();

  // arrowhead
  const ah=10, aw=6;
  const bx=x1-ux*ah, by=y1-uy*ah;
  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.lineTo(bx - uy*aw, by + ux*aw);
  ctx.lineTo(bx + uy*aw, by - ux*aw);
  ctx.closePath();
  ctx.fill();

  if(label){
    ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillStyle='rgba(233,238,252,0.92)';
    const tx = x1 + (-uy)*10;
    const ty = y1 + (ux)*10;
    ctx.fillText(label, tx, ty);
  }
  ctx.restore();
}

function drawText(ctx, x, y, text, color='rgba(174,183,214,0.95)'){
  ctx.save();
  ctx.fillStyle=color;
  ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillText(text, x, y);
  ctx.restore();
}

/* ============================
   Model: example vectors + sweep
============================ */
let state = {
  cz: 0.00,
  thetaDeg: 60,
  mode: 'both'
};

function getVectors(thetaDeg, cz){
  // Example values (for plotting/demo only)
  const A = [1.2, 0.3, 0.2];
  const th = deg2rad(thetaDeg);
  const B = [Math.cos(th), Math.sin(th), 0.25];
  const C = [0.4, 1.1, cz];
  return {A,B,C};
}

/* ============================
   Compute quantities for plots
============================ */
function computeSeries(cz){
  const xs = [];
  const dotL = [], dotR = [];
  const crossL = [], crossR = [];
  const assocDef = [];

  for(let t=0;t<=180;t+=2){
    const {A,B,C} = getVectors(t, cz);

    // dot distributivity check values
    const lhsDot = V.dot(V.add(A,B), C);
    const rhsDot = V.dot(A,C) + V.dot(B,C);

    // cross distributivity check values (magnitudes)
    const lhsCross = V.norm(V.cross(V.add(A,B), C));
    const rhsCross = V.norm(V.add(V.cross(A,C), V.cross(B,C)));

    // associativity defect magnitude
    const left = V.cross(V.cross(A,B), C);
    const right = V.cross(A, V.cross(B,C));
    const def = V.norm(V.sub(left,right));

    xs.push(t);
    dotL.push(lhsDot);
    dotR.push(rhsDot);
    crossL.push(lhsCross);
    crossR.push(rhsCross);
    assocDef.push(def);
  }
  return {xs, dotL, dotR, crossL, crossR, assocDef};
}

/* ============================
   Rendering
============================ */
const diag = setupCanvas(document.getElementById('diag'));
const plot1 = setupCanvas(document.getElementById('plot1'));
const plot2 = setupCanvas(document.getElementById('plot2'));

function renderDiagram(){
  const {ctx} = diag;
  const {w,h} = diag.resize();
  clearPanel(ctx, w, h);

  const {A,B,C} = getVectors(state.thetaDeg, state.cz);
  const ApB = V.add(A,B);

  // origin
  const O = project3D([0,0,0], w, h);

  // axes
  const X = project3D([1.2,0,0], w, h);
  const Y = project3D([0,1.2,0], w, h);
  const Z = project3D([0,0,1.2], w, h);
  drawArrow(ctx, O, X, 'rgba(123,220,255,0.55)', 'x');
  drawArrow(ctx, O, Y, 'rgba(156,255,199,0.55)', 'y');
  drawArrow(ctx, O, Z, 'rgba(255,211,138,0.55)', 'z');

  // vectors
  const pA = project3D(A, w, h);
  const pB = project3D(B, w, h);
  const pC = project3D(C, w, h);
  const pApB = project3D(ApB, w, h);

  const colA = 'rgba(123,220,255,0.95)';
  const colB = 'rgba(156,255,199,0.95)';
  const colC = 'rgba(255,211,138,0.95)';
  const colS = 'rgba(233,238,252,0.90)';
  const colD = 'rgba(255,138,160,0.95)';

  drawArrow(ctx, O, pA, colA, 'A');
  drawArrow(ctx, O, pB, colB, 'B');
  drawArrow(ctx, O, pC, colC, 'C');

  if(state.mode === 'both' || state.mode === 'dot' || state.mode === 'cross'){
    drawArrow(ctx, O, pApB, colS, 'A+B');
  }

  // Overlay: dot projection on C
  if(state.mode === 'dot'){
    const uC = V.unit(C);
    const projA = V.scale(uC, V.dot(A,uC));
    const projB = V.scale(uC, V.dot(B,uC));
    const projS = V.scale(uC, V.dot(ApB,uC));

    const pProjA = project3D(projA, w, h);
    const pProjB = project3D(projB, w, h);
    const pProjS = project3D(projS, w, h);

    // show projections as faint along C
    drawArrow(ctx, O, pProjA, 'rgba(123,220,255,0.55)', 'projC(A)');
    drawArrow(ctx, O, pProjB, 'rgba(156,255,199,0.55)', 'projC(B)');
    drawArrow(ctx, O, pProjS, 'rgba(233,238,252,0.55)', 'projC(A+B)');
  }

  // Overlay: cross product vectors (normals)
  if(state.mode === 'cross'){
    const AxC = V.cross(A,C);
    const BxC = V.cross(B,C);
    const SxC = V.cross(ApB,C);

    // scale normals for display
    const s1 = 0.55 / (V.norm(SxC) || 1);
    const s2 = 0.55 / (Math.max(V.norm(AxC), V.norm(BxC)) || 1);

    const pSxC = project3D(V.scale(SxC, s1), w, h);
    const pAxC = project3D(V.scale(AxC, s2), w, h);
    const pBxC = project3D(V.scale(BxC, s2), w, h);

    drawArrow(ctx, O, pAxC, 'rgba(123,220,255,0.65)', 'A×C');
    drawArrow(ctx, O, pBxC, 'rgba(156,255,199,0.65)', 'B×C');
    drawArrow(ctx, O, pSxC, 'rgba(233,238,252,0.75)', '(A+B)×C');
  }

  // Overlay: associativity defect
  if(state.mode === 'assoc'){
    const left = V.cross(V.cross(A,B), C);
    const right = V.cross(A, V.cross(B,C));
    const def = V.sub(left,right);

    const s = 0.75 / (Math.max(V.norm(left), V.norm(right), V.norm(def)) || 1);
    drawArrow(ctx, O, project3D(V.scale(left,s), w, h), 'rgba(123,220,255,0.65)', '(A×B)×C');
    drawArrow(ctx, O, project3D(V.scale(right,s), w, h), 'rgba(156,255,199,0.65)', 'A×(B×C)');
    drawArrow(ctx, O, project3D(V.scale(def,s), w, h), colD, 'Δ');
  }

  // numeric readout block
  const dotErr = Math.abs(V.dot(V.add(A,B),C) - (V.dot(A,C) + V.dot(B,C)));
  const crossErr = V.norm(V.sub(V.cross(V.add(A,B),C), V.add(V.cross(A,C), V.cross(B,C))));
  const assoc = V.norm(V.sub(V.cross(V.cross(A,B),C), V.cross(A, V.cross(B,C))));

  ctx.save();
  ctx.fillStyle = 'rgba(7,8,11,0.48)';
  ctx.strokeStyle = 'rgba(35,48,85,0.7)';
  roundRect(ctx, 12, 12, Math.min(430, w-24), 94, 14, true, true);
  drawText(ctx, 24, 36, `Dot distributivity error |LHS−RHS| = ${fmt(dotErr,6)} (a.u.^2)`);
  drawText(ctx, 24, 56, `Cross distributivity error ‖LHS−RHS‖ = ${fmt(crossErr,6)} (a.u.^2)`);
  drawText(ctx, 24, 76, `Associativity defect ‖(A×B)×C − A×(B×C)‖ = ${fmt(assoc,4)} (a.u.^3)`);
  ctx.restore();

  // Coplanar indicator
  const note = (Math.abs(state.cz) < 1e-12) ? "Coplanar case (Cz=0)" : "General 3D case (Cz≠0)";
  drawText(ctx, 16, h-16, note, 'rgba(174,183,214,0.85)');
}

function renderPlot1(){
  const {ctx} = plot1;
  const {w,h} = plot1.resize();
  clearPanel(ctx, w, h);

  // data
  const S = computeSeries(state.cz);

  // We plot dot LHS/RHS and cross magnitude LHS/RHS on same axes by normalizing to comparable scale
  // (still meaningful: overlap shows distributivity).
  const dotAll = S.dotL.concat(S.dotR);
  const crossAll = S.crossL.concat(S.crossR);

  const dotMax = Math.max(...dotAll.map(v=>Math.abs(v)), 1e-6);
  const crossMax = Math.max(...crossAll.map(v=>Math.abs(v)), 1e-6);

  const dotL = S.dotL.map(v=>v/dotMax);
  const dotR = S.dotR.map(v=>v/dotMax);
  const crossL = S.crossL.map(v=>v/crossMax);
  const crossR = S.crossR.map(v=>v/crossMax);

  // Determine y range
  const yAll = dotL.concat(dotR, crossL, crossR);
  let ymin = Math.min(...yAll), ymax = Math.max(...yAll);
  ymin = Math.min(ymin, -0.15);
  ymax = Math.max(ymax,  1.15);

  const plotArea = drawAxes(ctx, {x:0,y:0,w,h}, "sweep angle θB (deg)", "normalized value (a.u.)", "Distributive laws: LHS vs RHS (overlap ⇒ true)");
  const plot = {...plotArea, xmin:0, xmax:180, ymin, ymax};

  drawTicks(ctx, plot, 6, 5);

  // series colors (fixed)
  const c1='rgba(123,220,255,0.95)'; // dot LHS
  const c2='rgba(123,220,255,0.55)'; // dot RHS
  const c3='rgba(156,255,199,0.95)'; // cross LHS
  const c4='rgba(156,255,199,0.55)'; // cross RHS

  drawLineSeries(ctx, plot, S.xs, dotL, c1);
  drawLineSeries(ctx, plot, S.xs, dotR, c2);
  drawLineSeries(ctx, plot, S.xs, crossL, c3);
  drawLineSeries(ctx, plot, S.xs, crossR, c4);

  // vertical marker at current theta
  const X = mapX(state.thetaDeg, plot.xmin, plot.xmax, plot.px, plot.pw);
  ctx.save();
  ctx.strokeStyle = 'rgba(233,238,252,0.65)';
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.moveTo(X, plot.py);
  ctx.lineTo(X, plot.py+plot.ph);
  ctx.stroke();
  ctx.restore();

  drawLegend(ctx, plot.px + 10, plot.py + 10, [
    {label:"Dot LHS: (A+B)·C", color:c1},
    {label:"Dot RHS: A·C+B·C", color:c2},
    {label:"Cross LHS: |(A+B)×C|", color:c3},
    {label:"Cross RHS: |A×C+B×C|", color:c4},
  ]);

  // Note about normalization
  ctx.save();
  ctx.fillStyle='rgba(174,183,214,0.85)';
  ctx.font='11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillText(`Normalization: dot / ${fmt(dotMax,3)}, cross / ${fmt(crossMax,3)} (example scale)`, plot.px+10, plot.py+plot.ph-10);
  ctx.restore();
}

function renderPlot2(){
  const {ctx} = plot2;
  const {w,h} = plot2.resize();
  clearPanel(ctx, w, h);

  const S = computeSeries(state.cz);

  const ymin = 0;
  let ymax = Math.max(...S.assocDef, 1e-6);
  ymax *= 1.15;

  const plotArea = drawAxes(ctx, {x:0,y:0,w,h}, "sweep angle θB (deg)", "‖Δ‖ (a.u.^3)", "Cross product associativity defect Δ = (A×B)×C − A×(B×C)");
  const plot = {...plotArea, xmin:0, xmax:180, ymin, ymax};

  drawTicks(ctx, plot, 6, 5);

  const col='rgba(255,138,160,0.95)';
  drawLineSeries(ctx, plot, S.xs, S.assocDef, col);

  // marker at current theta
  const X = mapX(state.thetaDeg, plot.xmin, plot.xmax, plot.px, plot.pw);
  const idx = Math.round(state.thetaDeg/2);
  const yv = S.assocDef[clamp(idx,0,S.assocDef.length-1)];
  const Y = mapY(yv, plot.ymin, plot.ymax, plot.py, plot.ph);

  ctx.save();
  ctx.strokeStyle = 'rgba(233,238,252,0.65)';
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.moveTo(X, plot.py);
  ctx.lineTo(X, plot.py+plot.ph);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = col;
  ctx.beginPath();
  ctx.arc(X, Y, 4, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  drawLegend(ctx, plot.px + 10, plot.py + 10, [
    {label:"‖Δ(θ)‖", color:col}
  ]);

  // annotate coplanar hint
  const note = (Math.abs(state.cz) < 1e-12)
    ? "With Cz=0 (coplanar), Δ may still be nonzero → non-associativity is not a “3D-only” issue."
    : "With Cz≠0, Δ typically changes; non-associativity persists in general 3D.";
  ctx.save();
  ctx.fillStyle='rgba(174,183,214,0.85)';
  ctx.font='11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillText(note, plot.px+10, plot.py+plot.ph-10);
  ctx.restore();
}

function renderAll(){
  renderDiagram();
  renderPlot1();
  renderPlot2();
}

/* ============================
   UI wiring
============================ */
const cz = document.getElementById('cz');
const theta = document.getElementById('theta');
const mode = document.getElementById('mode');
const czRead = document.getElementById('czRead');
const thetaRead = document.getElementById('thetaRead');

function updateReads(){
  const czv = parseFloat(state.cz);
  czRead.textContent = `Cz = ${czv.toFixed(2)} ` + (Math.abs(czv)<1e-12 ? "(coplanar)" : "(general 3D)");
  thetaRead.textContent = `θB = ${Math.round(state.thetaDeg)}° (current B direction in diagram)`;
}

cz.addEventListener('input', ()=>{
  state.cz = parseFloat(cz.value);
  updateReads();
  renderAll();
});
theta.addEventListener('input', ()=>{
  state.thetaDeg = parseFloat(theta.value);
  updateReads();
  renderAll();
});
mode.addEventListener('change', ()=>{
  state.mode = mode.value;
  renderAll();
});
document.getElementById('reset').addEventListener('click', ()=>{
  state.cz = 0.00;
  state.thetaDeg = 60;
  state.mode = 'both';
  cz.value = state.cz;
  theta.value = state.thetaDeg;
  mode.value = state.mode;
  updateReads();
  renderAll();
});

// TOC top button
document.getElementById('btnTop').addEventListener('click', ()=>{
  window.scrollTo({top:0, behavior:'smooth'});
});

// Copy buttons
const copyStatus = document.getElementById('copyStatus');
document.addEventListener('click', async (e)=>{
  const btn = e.target.closest('.copyBtn');
  if(!btn) return;
  const text = btn.getAttribute('data-copy') || '';
  try{
    await navigator.clipboard.writeText(text);
    copyStatus.textContent = `Copied: ${text}`;
    setTimeout(()=>{ if(copyStatus.textContent.startsWith("Copied:")) copyStatus.textContent=""; }, 1600);
  }catch(err){
    copyStatus.textContent = "Copy failed (browser blocked clipboard). Select and copy manually.";
    setTimeout(()=>{ copyStatus.textContent=""; }, 2000);
  }
});

// Resize handling
window.addEventListener('resize', ()=>renderAll());

// init
updateReads();
renderAll();
</script>
</body>
</html>
