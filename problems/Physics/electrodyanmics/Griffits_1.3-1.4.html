<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vector Geometry: (1.3) Angle Between Cube Diagonals, (1.4) Unit Normal to a Plane via Cross Product</title>
  <style>
    :root{
      --bg:#07090d;
      --panel:#0c1018;
      --panel2:#0a0d14;
      --text:#e9eefc;
      --muted:#a8b3d1;
      --faint:#66739a;
      --accent:#7aa7ff;
      --accent2:#9bffcf;
      --warn:#ffcf66;
      --ok:#79ffa8;
      --bad:#ff6b8b;
      --stroke:rgba(255,255,255,.10);
      --stroke2:rgba(255,255,255,.16);
      --shadow: 0 12px 30px rgba(0,0,0,.45);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:
        radial-gradient(1200px 700px at 20% 5%, rgba(122,167,255,.10), transparent 60%),
        radial-gradient(900px 600px at 80% 15%, rgba(155,255,207,.07), transparent 55%),
        radial-gradient(800px 600px at 55% 92%, rgba(255,207,102,.06), transparent 60%),
        var(--bg);
      color:var(--text);
      font-family:var(--sans);
      line-height:1.55;
    }
    a{ color:var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }

    header{
      position:relative;
      padding: 42px 18px 20px;
      overflow:hidden;
    }
    .wrap{
      max-width: 1180px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 1fr;
      gap:16px;
    }
    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 22px 22px 18px;
    }
    h1{
      margin:0 0 8px;
      font-size: clamp(22px, 2.4vw, 34px);
      letter-spacing:.2px;
      line-height:1.15;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      max-width: 70ch;
    }

    .layout{
      max-width:1180px;
      margin: 0 auto;
      padding: 0 18px 50px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:16px;
      align-items:start;
    }

    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
      max-height: calc(100vh - 28px);
      overflow:auto;
    }
    nav.toc h2{
      font-size: 14px;
      margin:0 0 10px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing:.12em;
    }
    .toc a{
      display:block;
      padding: 8px 10px;
      border-radius: 12px;
      color: var(--text);
      border: 1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      font-size: 14px;
    }
    .toc a:hover{
      background: rgba(122,167,255,.10);
      border-color: rgba(122,167,255,.25);
      transform: translateX(2px);
      text-decoration:none;
    }
    .toc .hint{
      margin-top:10px;
      color: var(--faint);
      font-size: 12px;
      padding: 0 8px 6px;
    }

    main{
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    section.card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.025));
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px;
    }
    section.card h2{
      margin: 0 0 10px;
      font-size: 18px;
      letter-spacing:.2px;
    }
    section.card h3{
      margin: 14px 0 8px;
      font-size: 15px;
      color: var(--muted);
      letter-spacing:.15px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 14px;
    }
    .grid3{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }
    .callouts{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
      margin-top: 10px;
    }
    .callout{
      background: rgba(0,0,0,.22);
      border: 1px solid var(--stroke);
      border-radius: 16px;
      padding: 12px 12px 10px;
    }
    .callout b{ color: var(--accent2); }
    .muted{ color: var(--muted); }
    .small{ font-size: 13px; color: var(--muted); }
    ul{ margin: 8px 0 0 20px; }
    li{ margin: 4px 0; }

    .eq{
      position:relative;
      background: rgba(0,0,0,.30);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding: 12px 12px 10px;
      margin: 10px 0;
      overflow:hidden;
    }
    .eq pre{
      margin:0;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: var(--mono);
      font-size: 13px;
      color: #eaf1ff;
      line-height:1.45;
    }
    .btnRow{
      display:flex;
      flex-wrap:wrap;
      gap: 10px;
      margin-top: 10px;
      align-items:center;
    }
    button.copyBtn{
      appearance:none;
      border:1px solid rgba(122,167,255,.35);
      background: rgba(122,167,255,.10);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      font-weight: 600;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    button.copyBtn:hover{
      transform: translateY(-1px);
      border-color: rgba(122,167,255,.55);
      background: rgba(122,167,255,.16);
    }
    .copyStatus{
      font-size: 12px;
      color: var(--faint);
      min-height: 16px;
    }

    .vizCard{
      background: linear-gradient(180deg, rgba(0,0,0,.25), rgba(0,0,0,.12));
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      padding: 12px;
    }
    .vizTitle{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      padding: 4px 6px 10px;
    }
    .vizTitle h3{
      margin:0;
      font-size: 14px;
      color: var(--text);
    }
    .vizTitle span{
      color: var(--muted);
      font-size: 12px;
    }
    canvas{
      width: 100%;
      height: 320px;
      display:block;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.28);
    }
    .controls{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .control{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      border-radius: 14px;
      padding: 10px 10px 8px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size: 12px;
      color: var(--muted);
      margin-bottom:6px;
    }
    input[type="range"]{ width:100%; }
    select{
      width:100%;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.30);
      color: var(--text);
      padding: 8px 10px;
      outline:none;
    }
    .pill{
      font-family: var(--mono);
      color: var(--accent2);
      font-size: 12px;
    }
    .hr{
      height:1px;
      background: rgba(255,255,255,.10);
      margin: 14px 0;
    }

    .finalBox{
      border:1px solid rgba(155,255,207,.35);
      background: rgba(155,255,207,.08);
      border-radius: 16px;
      padding: 12px;
      margin-top: 10px;
    }
    .finalBox h3{
      margin:0 0 6px;
      color: var(--accent2);
    }
    .finalBox pre{
      margin:0;
      font-family: var(--mono);
      font-size: 13px;
      white-space: pre-wrap;
    }

    footer{
      max-width:1180px;
      margin: 0 auto;
      padding: 10px 18px 30px;
      color: var(--faint);
      font-size: 12px;
    }

    /* responsive */
    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
      nav.toc{ position:relative; top:auto; }
      canvas{ height: 300px; }
      .grid2{ grid-template-columns: 1fr; }
    }
    @media (prefers-reduced-motion: reduce){
      *{ transition:none !important; animation:none !important; scroll-behavior:auto !important; }
    }
    html{ scroll-behavior:smooth; }

    /* print */
    @media print{
      body{ background:white; color:black; }
      nav.toc{ display:none; }
      section.card, .titleCard{ box-shadow:none; background:white; border: 1px solid #ddd; }
      .vizCard{ display:none; }
      .eq{ background:white; border:1px solid #ddd; }
      button.copyBtn, .copyStatus{ display:none; }
      a{ color:black; text-decoration:underline; }
    }
  </style>
</head>

<body>
<header>
  <div class="wrap">
    <div class="titleCard">
      <h1>Vector Geometry Toolkit (Chapter 1): Cube Diagonals & Plane Normals</h1>
      <p class="subtitle">
        We solve two classic 3D-vector problems using dot products and cross products:
        <span class="muted">(1.3)</span> the angle between body diagonals of a cube, and
        <span class="muted">(1.4)</span> the components of a unit normal vector to a plane defined by axis intercepts.
      </p>

      <div class="callouts">
        <div class="callout">
          <b>Quick Summary</b>
          <ul>
            <li>Cube body diagonals can be represented by vectors like <span class="pill">(1,1,1)</span>.</li>
            <li>Angle between two distinct body diagonals satisfies <span class="pill">cos θ = 1/3</span> → <span class="pill">θ = arccos(1/3)</span>.</li>
            <li>A plane through intercepts <span class="pill">(a,0,0)</span>, <span class="pill">(0,b,0)</span>, <span class="pill">(0,0,c)</span> has normal proportional to <span class="pill">(bc, ac, ab)</span>.</li>
            <li>Unit normal: <span class="pill">n̂ = (bc,ac,ab)/√(b²c²+a²c²+a²b²)</span>.</li>
          </ul>
        </div>
        <div class="callout">
          <b>Given figure (Problem 1.4)</b>
          <div class="small">
            The plane intersects the axes at <span class="pill">x=1</span>, <span class="pill">y=2</span>, <span class="pill">z=3</span>.
            We’ll also keep a symbolic form <span class="pill">(a,b,c)</span> for insight and plotting.
          </div>
          <div class="small" style="margin-top:8px;">
            Interactive visuals below let you vary <span class="pill">L</span> (cube side) and <span class="pill">(a,b,c)</span> (plane intercepts).
          </div>
        </div>
      </div>

    </div>
  </div>
</header>

<div class="layout">
  <nav class="toc" aria-label="Table of contents">
    <h2>Contents</h2>
    <a href="#viz">Interactive Visualizations</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#final">Final Answers (Copy-ready)</a>
    <div class="hint">Tip: Use the sliders to see how the plane normal changes with intercepts.</div>
  </nav>

  <main>
    <section id="viz" class="card">
      <h2>Interactive Visualizations</h2>
      <p class="muted" style="margin-top:0">
        The same parameters are used throughout: cube side length <b>L</b> (example/demo parameter) and plane intercepts <b>a, b, c</b>
        (with the problem’s default <b>a=1</b>, <b>b=2</b>, <b>c=3</b>). All canvases update live.
      </p>

      <div class="grid2">
        <div class="vizCard">
          <div class="vizTitle">
            <h3>Diagram: Cube body diagonals + Plane with normal</h3>
            <span>Canvas (labeled, interactive)</span>
          </div>
          <canvas id="diagram"></canvas>

          <div class="controls" aria-label="Interactive controls">
            <div class="control">
              <label>
                <span>Cube side length <b>L</b> (units)</span>
                <span class="pill" id="Lread">1.00</span>
              </label>
              <input id="L" type="range" min="0.5" max="4" step="0.01" value="1.0" />
            </div>

            <div class="control">
              <label>
                <span>Sweep variable (for Plot 2)</span>
                <span class="pill" id="sweepRead">b</span>
              </label>
              <select id="sweepVar">
                <option value="a">Sweep a</option>
                <option value="b" selected>Sweep b</option>
                <option value="c">Sweep c</option>
              </select>
            </div>

            <div class="control">
              <label>
                <span>Plane intercept <b>a</b> (x-axis)</span>
                <span class="pill" id="aread">1.00</span>
              </label>
              <input id="a" type="range" min="0.2" max="5" step="0.01" value="1.0" />
            </div>

            <div class="control">
              <label>
                <span>Plane intercept <b>b</b> (y-axis)</span>
                <span class="pill" id="bread">2.00</span>
              </label>
              <input id="b" type="range" min="0.2" max="6" step="0.01" value="2.0" />
            </div>

            <div class="control">
              <label>
                <span>Plane intercept <b>c</b> (z-axis)</span>
                <span class="pill" id="cread">3.00</span>
              </label>
              <input id="c" type="range" min="0.2" max="7" step="0.01" value="3.0" />
            </div>

            <div class="control">
              <label>
                <span>Reset to problem values</span>
                <span class="pill">a=1,b=2,c=3</span>
              </label>
              <button class="copyBtn" id="resetBtn" type="button">Reset</button>
              <div class="small" id="liveInfo" style="margin-top:8px;"></div>
            </div>
          </div>
        </div>

        <div class="vizCard">
          <div class="vizTitle">
            <h3>Plot 1 (Main): Angle between cube body diagonals</h3>
            <span>θ(L) in degrees</span>
          </div>
          <canvas id="plot1"></canvas>

          <div class="vizTitle" style="margin-top:10px;">
            <h3>Plot 2 (Secondary): Unit normal components vs sweep</h3>
            <span>n̂x, n̂y, n̂z (dimensionless)</span>
          </div>
          <canvas id="plot2"></canvas>
        </div>
      </div>
    </section>

    <section id="part1" class="card">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <article>
        <h3>Rewrite the problems (clear statement)</h3>
        <ul>
          <li><b>Problem 1.3:</b> A cube has four body diagonals (lines connecting opposite vertices). Find the angle between any two distinct body diagonals.</li>
          <li><b>Problem 1.4:</b> A plane intersects the coordinate axes at <span class="pill">x=1</span>, <span class="pill">y=2</span>, <span class="pill">z=3</span>. Use a cross product to find the components of the <b>unit</b> vector <b>n̂</b> perpendicular to this plane.</li>
        </ul>

        <h3>Given quantities</h3>
        <div class="grid2">
          <div class="callout">
            <b>Problem 1.3 (Cube)</b>
            <ul>
              <li>Cube geometry (right angles, equal edges)</li>
              <li>Side length can be called <span class="pill">L</span> (no numeric value needed)</li>
            </ul>
          </div>
          <div class="callout">
            <b>Problem 1.4 (Plane)</b>
            <ul>
              <li>Axis intercepts: <span class="pill">a=1</span>, <span class="pill">b=2</span>, <span class="pill">c=3</span></li>
              <li>Points on plane: <span class="pill">(1,0,0)</span>, <span class="pill">(0,2,0)</span>, <span class="pill">(0,0,3)</span></li>
            </ul>
          </div>
        </div>

        <h3>Unknowns</h3>
        <ul>
          <li><b>Problem 1.3:</b> the angle <span class="pill">θ</span> between two body diagonals (in symbolic form, and a numerical value).</li>
          <li><b>Problem 1.4:</b> the unit normal vector components <span class="pill">n̂ = (n̂x, n̂y, n̂z)</span>.</li>
        </ul>

        <h3>Relevant principles and why they apply</h3>
        <ul>
          <li><b>Dot product gives angles:</b> For nonzero vectors <span class="pill">u</span>, <span class="pill">v</span>,
            <span class="pill">u·v = |u||v| cosθ</span>. This directly converts geometry into an angle. Perfect for Problem 1.3.</li>
          <li><b>Cross product gives a normal:</b> For two non-parallel vectors in a plane, <span class="pill">u×v</span> is perpendicular to that plane.
            Then normalize to get a unit vector. This is exactly Problem 1.4’s instruction.</li>
        </ul>

        <h3>Possible approaches (2–3) and comparison</h3>
        <ul>
          <li><b>(A) Coordinate vectors (best):</b> Place the cube with vertices on axes, write diagonal direction vectors, use dot product. For the plane, use intercept points and cross product. Fast and systematic.</li>
          <li><b>(B) Symmetry / known angles:</b> Use symmetry arguments of vectors <span class="pill">(±1,±1,±1)</span>. Quick but easier to make sign/selection mistakes without explicit computation.</li>
          <li><b>(C) Plane equation method (for 1.4):</b> Find plane equation <span class="pill">x/a + y/b + z/c = 1</span>, then normal is proportional to gradient.
            Works, but the problem specifically requests cross product; cross product also shows the geometric construction.</li>
        </ul>

        <p><b>Chosen approach:</b> (A) Coordinate vectors with dot and cross products. It is the most direct, transparent, and matches the problem statement for both parts.</p>
      </article>
    </section>

    <section id="part2" class="card">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

      <h3>Step-by-step plan (minimal, no algebra yet)</h3>
      <ol>
        <li><b>Set coordinates (cube):</b> Place a cube with one corner at the origin and edges along the axes. <span class="muted">Tool:</span> coordinate geometry.</li>
        <li><b>Write two body-diagonal direction vectors:</b> Choose vectors from the cube’s center to two vertices. <span class="muted">Tool:</span> vector representation.</li>
        <li><b>Compute the angle:</b> Use <span class="pill">u·v = |u||v|cosθ</span>. <span class="muted">Tool:</span> dot product.</li>
        <li><b>Set plane points:</b> Use the intercept points <span class="pill">(a,0,0)</span>, <span class="pill">(0,b,0)</span>, <span class="pill">(0,0,c)</span>. <span class="muted">Tool:</span> geometry of intercepts.</li>
        <li><b>Build two vectors in the plane:</b> Subtract one intercept point from the others to get two in-plane directions. <span class="muted">Tool:</span> vector subtraction.</li>
        <li><b>Cross product to get a normal:</b> Compute <span class="pill">n = u×v</span>. <span class="muted">Tool:</span> cross product.</li>
        <li><b>Normalize:</b> Form <span class="pill">n̂ = n/|n|</span>. <span class="muted">Tool:</span> magnitude and normalization.</li>
        <li><b>Plug in given numbers:</b> Use <span class="pill">a=1, b=2, c=3</span> for the final numeric unit normal. <span class="muted">Tool:</span> substitution.</li>
      </ol>

      <h3>Common mistakes & quick tips</h3>
      <ul>
        <li><b>Mistake:</b> Using vectors along cube edges instead of body diagonals. <b>Tip:</b> body diagonal changes all three coordinates.</li>
        <li><b>Mistake:</b> Forgetting to normalize the cross product. <b>Tip:</b> the problem asks for a <i>unit</i> vector.</li>
        <li><b>Mistake:</b> Cross product order confusion. <b>Tip:</b> <span class="pill">u×v</span> and <span class="pill">v×u</span> point in opposite directions; both are valid normals, just sign-flipped.</li>
        <li><b>Mistake:</b> Losing track of components. <b>Tip:</b> Use a clean determinant or component formula and check dimensions (unit normal is dimensionless).</li>
      </ul>
    </section>

    <section id="part3" class="card">
      <h2>PART 3 — Full Solution</h2>

      <article>
        <h3>Physical intuition</h3>
        <ul>
          <li><b>Cube diagonals:</b> Any body diagonal points equally along +x, +y, +z (up to signs). So two different diagonals are “almost aligned” but not fully; symmetry suggests a fixed angle independent of cube size.</li>
          <li><b>Plane normal:</b> A plane is determined by two independent directions lying in it. The cross product of those directions must be perpendicular to the plane, giving a natural normal direction.</li>
        </ul>

        <div class="hr"></div>

        <h3>Problem 1.3 — Angle between body diagonals of a cube</h3>
        <p>
          Place a cube of side length <span class="pill">L</span> with one vertex at the origin and edges along the axes.
          The cube’s center is at
          <span class="pill">C = (L/2, L/2, L/2)</span>.
        </p>

        <p>
          Body diagonals are lines connecting opposite vertices; all of them pass through the center. Therefore, we can represent each diagonal’s
          <b>direction</b> by a vector from the center to a vertex.
        </p>

        <p>
          Choose two vertices:
          <span class="pill">V1 = (0,0,0)</span> and <span class="pill">V2 = (0,0,L)</span>.
          (These correspond to two different body diagonals through the center.)
        </p>

        <p>Direction vectors from the center:</p>
        <div class="eq" id="eq1">
<pre>u = V1 - C = (0,0,0) - (L/2, L/2, L/2) = (-L/2, -L/2, -L/2)
v = V2 - C = (0,0,L) - (L/2, L/2, L/2) = (-L/2, -L/2, +L/2)</pre>
        </div>

        <p>
          Compute the dot product:
        </p>
        <div class="eq" id="eq2">
<pre>u·v = (-L/2)(-L/2) + (-L/2)(-L/2) + (-L/2)(+L/2)
    = (L^2/4) + (L^2/4) - (L^2/4)
    = L^2/4</pre>
        </div>

        <p>
          Compute magnitudes:
        </p>
        <div class="eq" id="eq3">
<pre>|u| = sqrt[(-L/2)^2 + (-L/2)^2 + (-L/2)^2] = sqrt(3 L^2/4) = (L/2) sqrt(3)
|v| = sqrt[(-L/2)^2 + (-L/2)^2 + (+L/2)^2] = sqrt(3 L^2/4) = (L/2) sqrt(3)</pre>
        </div>

        <p>
          Use <span class="pill">u·v = |u||v| cosθ</span>:
        </p>
        <div class="eq" id="eq4">
<pre>cos θ = (u·v)/(|u||v|)
      = (L^2/4) / [ (L/2 sqrt(3)) (L/2 sqrt(3)) ]
      = (L^2/4) / (3 L^2/4)
      = 1/3</pre>
        </div>

        <p>
          Therefore,
          <span class="pill">θ = arccos(1/3)</span>.
          Numerically,
          <span class="pill">θ ≈ 70.53°</span>.
        </p>

        <div class="finalBox">
          <h3>Result (Problem 1.3)</h3>
<pre>Angle between two distinct cube body diagonals:
  θ = arccos(1/3) ≈ 70.53°</pre>
        </div>

        <h3>Sanity checks (Problem 1.3)</h3>
        <ul>
          <li><b>Units:</b> cosine is dimensionless; L cancels → angle independent of cube size (as expected).</li>
          <li><b>Limiting cases:</b> Changing L doesn’t change θ; the cube just scales.</li>
          <li><b>Interpretation:</b> Diagonals are not orthogonal (90°) and not parallel (0°); the symmetry-fixed value ~70.5° makes sense.</li>
        </ul>

        <div class="hr"></div>

        <h3>Problem 1.4 — Unit normal to the plane via cross product</h3>
        <p>
          The plane in the figure intersects the axes at:
          <span class="pill">A=(a,0,0)</span>, <span class="pill">B=(0,b,0)</span>, <span class="pill">C=(0,0,c)</span>.
          For the actual problem: <span class="pill">a=1</span>, <span class="pill">b=2</span>, <span class="pill">c=3</span>.
        </p>

        <p>
          Two vectors that lie in the plane can be formed using differences of points:
        </p>
        <div class="eq" id="eq5">
<pre>u = B - A = (0,b,0) - (a,0,0) = (-a,  b,  0)
v = C - A = (0,0,c) - (a,0,0) = (-a,  0,  c)</pre>
        </div>

        <p>
          A normal vector is the cross product <span class="pill">n = u × v</span>.
          Using the component formula
          <span class="pill">u×v = (u_y v_z - u_z v_y, u_z v_x - u_x v_z, u_x v_y - u_y v_x)</span>:
        </p>

        <div class="eq" id="eq6">
<pre>u = (-a, b, 0),   v = (-a, 0, c)

n_x = u_y v_z - u_z v_y = b·c - 0·0 = bc
n_y = u_z v_x - u_x v_z = 0·(-a) - (-a)·c = ac
n_z = u_x v_y - u_y v_x = (-a)·0 - b·(-a) = ab

So: n = (bc, ac, ab)</pre>
        </div>

        <p>
          The <b>unit</b> normal is <span class="pill">n̂ = n / |n|</span>. Its magnitude is:
        </p>

        <div class="eq" id="eq7">
<pre>|n| = sqrt( (bc)^2 + (ac)^2 + (ab)^2 )
    = sqrt( b^2 c^2 + a^2 c^2 + a^2 b^2 )</pre>
        </div>

        <p>
          Therefore, the unit normal vector components are:
        </p>
        <div class="eq" id="eq8">
<pre>n̂ = (bc, ac, ab) / sqrt(b^2 c^2 + a^2 c^2 + a^2 b^2)</pre>
        </div>

        <p>
          Now substitute the given values <span class="pill">a=1</span>, <span class="pill">b=2</span>, <span class="pill">c=3</span>:
        </p>

        <div class="eq" id="eq9">
<pre>n = (bc, ac, ab) = (2·3, 1·3, 1·2) = (6, 3, 2)

|n| = sqrt(6^2 + 3^2 + 2^2) = sqrt(36 + 9 + 4) = sqrt(49) = 7

n̂ = (6,3,2) / 7 = (6/7, 3/7, 2/7)</pre>
        </div>

        <div class="finalBox">
          <h3>Result (Problem 1.4)</h3>
<pre>For intercepts (1,2,3):
  n̂ = (6/7, 3/7, 2/7)

(Any overall sign ± is acceptable, depending on normal orientation.)</pre>
        </div>

        <h3>Sanity checks (Problem 1.4)</h3>
        <ul>
          <li><b>Units:</b> Components of n̂ are dimensionless (ratios of lengths cancel upon normalization).</li>
          <li><b>Limiting cases:</b> If <span class="pill">a=b=c</span>, symmetry gives <span class="pill">n̂ ∝ (1,1,1)</span>, which matches <span class="pill">(bc,ac,ab) = (a^2,a^2,a^2)</span>.</li>
          <li><b>Interpretation:</b> Larger intercept on one axis tends to reduce the corresponding unit-normal component (the plane becomes “flatter” relative to that axis). You can see this in Plot 2.</li>
        </ul>
      </article>
    </section>

    <section id="final" class="card">
      <h2>Final Answers (Copy-ready)</h2>
      <p class="muted" style="margin-top:0">Use the buttons to copy plain-text equations/results.</p>

      <div class="grid2">
        <div>
          <h3>Key equations</h3>

          <div class="eq" id="copyEqDot">
<pre>Dot product angle formula:
u·v = |u||v| cos θ</pre>
          </div>
          <div class="btnRow">
            <button class="copyBtn" data-copy="#copyEqDot">Copy</button>
            <span class="copyStatus" id="status1"></span>
          </div>

          <div class="eq" id="copyEqNormal">
<pre>Plane intercept normal (through (a,0,0),(0,b,0),(0,0,c)):
n = (bc, ac, ab)
n̂ = (bc, ac, ab) / sqrt(b^2 c^2 + a^2 c^2 + a^2 b^2)</pre>
          </div>
          <div class="btnRow">
            <button class="copyBtn" data-copy="#copyEqNormal">Copy</button>
            <span class="copyStatus" id="status2"></span>
          </div>
        </div>

        <div>
          <h3>Final results</h3>

          <div class="eq" id="copyFinal">
<pre>(1.3) Angle between body diagonals of a cube:
θ = arccos(1/3) ≈ 70.53°

(1.4) Unit normal to plane through x=1, y=2, z=3:
n̂ = (6/7, 3/7, 2/7)   (or the negative)</pre>
          </div>

          <div class="btnRow">
            <button class="copyBtn" data-copy="#copyFinal">Copy Final Answer</button>
            <span class="copyStatus" id="status3"></span>
          </div>

          <div class="callout" style="margin-top:12px;">
            <b>Orientation note</b>
            <div class="small">
              A plane has two opposite normals. If your cross product order is reversed, you get <span class="pill">-n̂</span>.
              Both are correct unless a direction is explicitly specified.
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>
</div>

<footer>
  Built with vanilla HTML/CSS/JS. Canvases are high-DPI aware and responsive. Print hides interactive panels for clean notes.
</footer>

<script>
(function(){
  // ----------------------------
  // Utilities
  // ----------------------------
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp = (a,b,t)=>a+(b-a)*t;

  function fmt(x, n=2){
    return (Math.round(x*Math.pow(10,n))/Math.pow(10,n)).toFixed(n);
  }

  function setHiDPICanvas(canvas){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(2, Math.floor(rect.width * dpr));
    const h = Math.max(2, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w;
      canvas.height = h;
    }
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return {ctx, wCSS: rect.width, hCSS: rect.height, dpr};
  }

  function drawPanelTitle(ctx, x, y, text){
    ctx.save();
    ctx.font = '600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillStyle = 'rgba(233,238,252,.92)';
    ctx.fillText(text, x, y);
    ctx.restore();
  }

  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, opts){
    const {
      xLabel='x',
      yLabel='y',
      title='',
      xUnit='',
      yUnit='',
      grid=true,
      ticks=5
    } = opts || {};

    const {x,y,w,h} = box;

    // background gradient
    ctx.save();
    const g = ctx.createLinearGradient(x, y, x, y+h);
    g.addColorStop(0, 'rgba(255,255,255,0.03)');
    g.addColorStop(1, 'rgba(0,0,0,0.10)');
    ctx.fillStyle = g;
    ctx.fillRect(x, y, w, h);

    // frame
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, w, h);

    // title
    if(title){
      drawPanelTitle(ctx, x+8, y+18, title);
    }

    // mapping
    const px = (X)=> x + (X - xMin) / (xMax - xMin) * w;
    const py = (Y)=> y + h - (Y - yMin) / (yMax - yMin) * h;

    // grid + ticks
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillStyle = 'rgba(168,179,209,0.92)';
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;

    const n = ticks;
    for(let i=0;i<=n;i++){
      const tx = x + i/n*w;
      const tval = lerp(xMin, xMax, i/n);
      if(grid){
        ctx.beginPath();
        ctx.moveTo(tx, y);
        ctx.lineTo(tx, y+h);
        ctx.stroke();
      }
      // tick
      ctx.strokeStyle = 'rgba(255,255,255,0.16)';
      ctx.beginPath();
      ctx.moveTo(tx, y+h);
      ctx.lineTo(tx, y+h+6);
      ctx.stroke();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';

      const label = (Math.abs(xMax-xMin) < 0.01) ? tval.toExponential(2) : (Math.abs(tval)>=1000 ? tval.toFixed(0) : tval.toFixed(2));
      ctx.fillText(label, tx-12, y+h+18);
    }

    for(let i=0;i<=n;i++){
      const ty = y + i/n*h;
      const tval = lerp(yMax, yMin, i/n);
      if(grid){
        ctx.beginPath();
        ctx.moveTo(x, ty);
        ctx.lineTo(x+w, ty);
        ctx.stroke();
      }
      // tick
      ctx.strokeStyle = 'rgba(255,255,255,0.16)';
      ctx.beginPath();
      ctx.moveTo(x-6, ty);
      ctx.lineTo(x, ty);
      ctx.stroke();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';

      const label = (Math.abs(tval)>=1000 ? tval.toFixed(0) : tval.toFixed(2));
      ctx.fillText(label, x-52, ty+4);
    }

    // axis labels
    ctx.fillStyle = 'rgba(233,238,252,0.86)';
    ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    const xLab = xLabel + (xUnit ? ` (${xUnit})` : '');
    const yLab = yLabel + (yUnit ? ` (${yUnit})` : '');

    ctx.fillText(xLab, x + w - 10 - ctx.measureText(xLab).width, y + h + 36);

    ctx.save();
    ctx.translate(x-64, y + 12);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLab, 0, 0);
    ctx.restore();

    ctx.restore();
    return {px, py};
  }

  function plotLine(ctx, map, xs, ys, strokeStyle, width=2){
    ctx.save();
    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = width;
    ctx.beginPath();
    for(let i=0;i<xs.length;i++){
      const X = map.px(xs[i]);
      const Y = map.py(ys[i]);
      if(i===0) ctx.moveTo(X,Y);
      else ctx.lineTo(X,Y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawLegend(ctx, items, x, y){
    ctx.save();
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillStyle = 'rgba(233,238,252,0.9)';
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1;

    const pad = 10;
    const rowH = 18;
    const w = Math.max(...items.map(it=>ctx.measureText(it.label).width)) + 54;
    const h = items.length*rowH + pad*2;

    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(x, y, w, h);
    ctx.strokeRect(x, y, w, h);

    for(let i=0;i<items.length;i++){
      const yy = y + pad + i*rowH + 6;
      ctx.strokeStyle = items[i].color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x+10, yy);
      ctx.lineTo(x+30, yy);
      ctx.stroke();
      ctx.lineWidth = 1;
      ctx.fillStyle = 'rgba(233,238,252,0.9)';
      ctx.fillText(items[i].label, x+38, yy+4);
    }
    ctx.restore();
  }

  // 3D-ish projection for diagrams (simple isometric-like)
  function proj3D(p){
    // p = [x,y,z] in arbitrary units
    const x = p[0], y = p[1], z = p[2];
    const sx = 0.92, sy = 0.55, sz = 0.95;
    return [ (x - y)*sx, (x + y)*sy - z*sz ];
  }

  function add(p,q){ return [p[0]+q[0], p[1]+q[1], p[2]+q[2]]; }
  function sub(p,q){ return [p[0]-q[0], p[1]-q[1], p[2]-q[2]]; }
  function dot(p,q){ return p[0]*q[0]+p[1]*q[1]+p[2]*q[2]; }
  function norm(p){ return Math.sqrt(dot(p,p)); }
  function scale(p,s){ return [p[0]*s,p[1]*s,p[2]*s]; }

  function cross(u,v){
    return [
      u[1]*v[2]-u[2]*v[1],
      u[2]*v[0]-u[0]*v[2],
      u[0]*v[1]-u[1]*v[0]
    ];
  }

  // ----------------------------
  // Parameters + derived results
  // ----------------------------
  const el = {
    diagram: document.getElementById('diagram'),
    plot1: document.getElementById('plot1'),
    plot2: document.getElementById('plot2'),
    L: document.getElementById('L'),
    a: document.getElementById('a'),
    b: document.getElementById('b'),
    c: document.getElementById('c'),
    sweepVar: document.getElementById('sweepVar'),
    resetBtn: document.getElementById('resetBtn'),
    Lread: document.getElementById('Lread'),
    aread: document.getElementById('aread'),
    bread: document.getElementById('bread'),
    cread: document.getElementById('cread'),
    sweepRead: document.getElementById('sweepRead'),
    liveInfo: document.getElementById('liveInfo')
  };

  function getParams(){
    const L = parseFloat(el.L.value);
    const a = parseFloat(el.a.value);
    const b = parseFloat(el.b.value);
    const c = parseFloat(el.c.value);
    const sweep = el.sweepVar.value;
    return {L,a,b,c,sweep};
  }

  function cubeAngleDeg(){
    // Choose u = (1,1,1), v = (1,1,-1) directions; independent of L
    const u = [1,1,1], v = [1,1,-1];
    const cosT = dot(u,v)/(norm(u)*norm(v)); // = 1/3
    const theta = Math.acos(clamp(cosT,-1,1));
    return theta*180/Math.PI;
  }

  function planeUnitNormal(a,b,c){
    // For plane through (a,0,0),(0,b,0),(0,0,c)
    const n = [b*c, a*c, a*b];
    const mag = norm(n);
    return {n, mag, nhat: scale(n, 1/(mag || 1))};
  }

  function updateReadouts(p){
    el.Lread.textContent = fmt(p.L,2);
    el.aread.textContent = fmt(p.a,2);
    el.bread.textContent = fmt(p.b,2);
    el.cread.textContent = fmt(p.c,2);
    el.sweepRead.textContent = p.sweep;

    const ang = cubeAngleDeg();
    const nu = planeUnitNormal(p.a,p.b,p.c);
    el.liveInfo.innerHTML =
      `Live: <span class="pill">θ ≈ ${fmt(ang,2)}°</span> &nbsp; | &nbsp; ` +
      `n̂ = <span class="pill">(${fmt(nu.nhat[0],3)}, ${fmt(nu.nhat[1],3)}, ${fmt(nu.nhat[2],3)})</span>`;
  }

  // ----------------------------
  // Drawing: Diagram
  // ----------------------------
  function drawDiagram(){
    const p = getParams();
    updateReadouts(p);

    const {ctx, wCSS, hCSS} = setHiDPICanvas(el.diagram);
    ctx.clearRect(0,0,wCSS,hCSS);

    // Split canvas: left cube, right plane
    const pad = 14;
    const mid = wCSS*0.52;
    const boxL = {x: pad, y: pad, w: mid - pad*1.2, h: hCSS - pad*2};
    const boxR = {x: mid + pad*0.6, y: pad, w: wCSS - mid - pad*1.6, h: hCSS - pad*2};

    // Background frames
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.lineWidth = 1;
    [boxL, boxR].forEach(b=>{
      ctx.fillRect(b.x,b.y,b.w,b.h);
      ctx.strokeRect(b.x,b.y,b.w,b.h);
    });
    ctx.restore();

    // Titles
    drawPanelTitle(ctx, boxL.x+10, boxL.y+18, 'Cube (side L) + two body diagonals');
    drawPanelTitle(ctx, boxR.x+10, boxR.y+18, 'Plane intercepts (a,b,c) + unit normal n̂');

    // ---- Cube drawing ----
    const L = p.L;
    const cube = [
      [0,0,0], [L,0,0], [L,L,0], [0,L,0],
      [0,0,L], [L,0,L], [L,L,L], [0,L,L]
    ];
    const edges = [
      [0,1],[1,2],[2,3],[3,0],
      [4,5],[5,6],[6,7],[7,4],
      [0,4],[1,5],[2,6],[3,7]
    ];

    // project and normalize to fit boxL
    const projPts = cube.map(proj3D);
    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    projPts.forEach(([x,y])=>{
      minX=Math.min(minX,x); maxX=Math.max(maxX,x);
      minY=Math.min(minY,y); maxY=Math.max(maxY,y);
    });
    const sx = (boxL.w*0.72)/(maxX-minX || 1);
    const sy = (boxL.h*0.72)/(maxY-minY || 1);
    const s = Math.min(sx,sy);
    const cx = (minX+maxX)/2, cy=(minY+maxY)/2;
    const ox = boxL.x + boxL.w*0.5;
    const oy = boxL.y + boxL.h*0.56;

    function mapL(i){
      const [x,y] = projPts[i];
      return [ ox + (x-cx)*s, oy + (y-cy)*s ];
    }

    // edges
    ctx.save();
    ctx.strokeStyle = 'rgba(233,238,252,0.55)';
    ctx.lineWidth = 1.4;
    edges.forEach(([i,j])=>{
      const a = mapL(i), b = mapL(j);
      ctx.beginPath();
      ctx.moveTo(a[0],a[1]);
      ctx.lineTo(b[0],b[1]);
      ctx.stroke();
    });
    ctx.restore();

    // diagonals: choose V1 (0) and V2 (4) as endpoints from center line? and another diagonal (1)-(7)
    const center = [L/2,L/2,L/2];
    const V1 = cube[0];      // (0,0,0)
    const V2 = cube[6];      // (L,L,L)  same diagonal line as V1
    const V3 = cube[4];      // (0,0,L)
    const V4 = cube[2];      // (L,L,0)

    function mapPointP(pt){
      const [x,y] = proj3D(pt);
      return [ ox + (x-cx)*s, oy + (y-cy)*s ];
    }
    const c2 = mapPointP(center);

    // draw two distinct diagonals through center: along V1-V2 and along V3-V4
    ctx.save();
    ctx.lineWidth = 2.6;

    // diagonal 1
    ctx.strokeStyle = 'rgba(122,167,255,0.95)';
    let a1 = mapPointP(V1), b1 = mapPointP(V2);
    ctx.beginPath(); ctx.moveTo(a1[0],a1[1]); ctx.lineTo(b1[0],b1[1]); ctx.stroke();

    // diagonal 2
    ctx.strokeStyle = 'rgba(155,255,207,0.92)';
    let a2 = mapPointP(V3), b2 = mapPointP(V4);
    ctx.beginPath(); ctx.moveTo(a2[0],a2[1]); ctx.lineTo(b2[0],b2[1]); ctx.stroke();

    // center point
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.beginPath(); ctx.arc(c2[0],c2[1], 3.2, 0, Math.PI*2); ctx.fill();

    // labels
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillStyle = 'rgba(233,238,252,0.88)';
    ctx.fillText('d₁', (a1[0]+b1[0])/2 + 6, (a1[1]+b1[1])/2 - 6);
    ctx.fillText('d₂', (a2[0]+b2[0])/2 + 6, (a2[1]+b2[1])/2 - 6);
    ctx.fillText('center', c2[0]+6, c2[1]-6);
    ctx.restore();

    // ---- Plane drawing ----
    const a = p.a, b = p.b, c = p.c;
    const A = [a,0,0], B=[0,b,0], C=[0,0,c];

    // For a diagram, draw axes and triangle in a pseudo-3D view
    const pts = [ [0,0,0], [a*1.05,0,0], [0,b*1.05,0], [0,0,c*1.05], A, B, C ];
    const projR = pts.map(proj3D);

    minX=Infinity;maxX=-Infinity;minY=Infinity;maxY=-Infinity;
    projR.forEach(([x,y])=>{
      minX=Math.min(minX,x); maxX=Math.max(maxX,x);
      minY=Math.min(minY,y); maxY=Math.max(maxY,y);
    });

    const sxR = (boxR.w*0.78)/(maxX-minX || 1);
    const syR = (boxR.h*0.78)/(maxY-minY || 1);
    const sR = Math.min(sxR,syR);
    const cXR = (minX+maxX)/2, cYR=(minY+maxY)/2;
    const oXR = boxR.x + boxR.w*0.52;
    const oYR = boxR.y + boxR.h*0.62;

    function mapR(pt){
      const [x,y] = proj3D(pt);
      return [ oXR + (x-cXR)*sR, oYR + (y-cYR)*sR ];
    }

    // axes
    ctx.save();
    ctx.lineWidth = 1.8;
    ctx.strokeStyle = 'rgba(233,238,252,0.60)';
    const O = mapR([0,0,0]);
    const X = mapR([a*1.05,0,0]);
    const Y = mapR([0,b*1.05,0]);
    const Z = mapR([0,0,c*1.05]);

    function arrow(p1,p2){
      ctx.beginPath(); ctx.moveTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.stroke();
      const dx = p2[0]-p1[0], dy = p2[1]-p1[1];
      const Lh = Math.sqrt(dx*dx+dy*dy) || 1;
      const ux = dx/Lh, uy = dy/Lh;
      const ah = 8;
      const left = [p2[0]-ux*ah - uy*ah*0.45, p2[1]-uy*ah + ux*ah*0.45];
      const right= [p2[0]-ux*ah + uy*ah*0.45, p2[1]-uy*ah - ux*ah*0.45];
      ctx.beginPath();
      ctx.moveTo(p2[0],p2[1]); ctx.lineTo(left[0],left[1]); ctx.lineTo(right[0],right[1]); ctx.closePath();
      ctx.fillStyle = 'rgba(233,238,252,0.60)';
      ctx.fill();
    }

    arrow(O,X); arrow(O,Y); arrow(O,Z);

    // triangle plane
    const Ap = mapR(A), Bp = mapR(B), Cp = mapR(C);

    ctx.fillStyle = 'rgba(122,167,255,0.12)';
    ctx.strokeStyle = 'rgba(122,167,255,0.85)';
    ctx.lineWidth = 2.0;
    ctx.beginPath();
    ctx.moveTo(Ap[0],Ap[1]);
    ctx.lineTo(Bp[0],Bp[1]);
    ctx.lineTo(Cp[0],Cp[1]);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // normal vector from centroid
    const centroid = scale(add(add(A,B),C), 1/3);
    const nu = planeUnitNormal(a,b,c);
    const nh = nu.nhat;

    const centP = mapR(centroid);
    const normalEnd = mapR(add(centroid, scale(nh, Math.min(a,b,c)*0.9))); // scale for display
    ctx.strokeStyle = 'rgba(155,255,207,0.92)';
    ctx.lineWidth = 2.6;
    arrow(centP, normalEnd);

    // labels
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillStyle = 'rgba(233,238,252,0.88)';
    ctx.fillText('x', X[0]+6, X[1]+2);
    ctx.fillText('y', Y[0]+6, Y[1]+2);
    ctx.fillText('z', Z[0]+6, Z[1]+2);
    ctx.fillText(`A(${fmt(a,2)},0,0)`, Ap[0]+6, Ap[1]-6);
    ctx.fillText(`B(0,${fmt(b,2)},0)`, Bp[0]+6, Bp[1]-6);
    ctx.fillText(`C(0,0,${fmt(c,2)})`, Cp[0]+6, Cp[1]-6);
    ctx.fillStyle = 'rgba(155,255,207,0.92)';
    ctx.fillText('n̂', normalEnd[0]+6, normalEnd[1]-6);
    ctx.restore();
  }

  // ----------------------------
  // Plot 1: theta vs L (constant line)
  // ----------------------------
  function drawPlot1(){
    const p = getParams();
    const {ctx, wCSS, hCSS} = setHiDPICanvas(el.plot1);
    ctx.clearRect(0,0,wCSS,hCSS);

    const margin = {l:72,r:18,t:26,b:52};
    const box = {x:margin.l, y:margin.t, w:wCSS-margin.l-margin.r, h:hCSS-margin.t-margin.b};

    const Lmin = 0.5, Lmax = 4.0;
    const theta = cubeAngleDeg();
    // small y-range around theta for readable scale
    const yMin = theta - 6;
    const yMax = theta + 6;

    const map = drawAxes(ctx, box, Lmin, Lmax, yMin, yMax, {
      title: 'Angle between cube body diagonals',
      xLabel: 'L',
      xUnit: 'units',
      yLabel: 'θ',
      yUnit: 'deg',
      ticks: 5,
      grid: true
    });

    // generate data
    const N = 200;
    const xs = [], ys = [];
    for(let i=0;i<N;i++){
      const L = lerp(Lmin,Lmax,i/(N-1));
      xs.push(L);
      ys.push(theta);
    }

    // line
    plotLine(ctx, map, xs, ys, 'rgba(122,167,255,0.95)', 2.6);

    // mark current L
    const x0 = p.L;
    const y0 = theta;
    ctx.save();
    ctx.fillStyle = 'rgba(155,255,207,0.95)';
    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(map.px(x0), map.py(y0), 4.2, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    drawLegend(ctx, [
      {label:`θ = arccos(1/3) ≈ ${fmt(theta,2)}°`, color:'rgba(122,167,255,0.95)'},
      {label:`current L = ${fmt(p.L,2)}`, color:'rgba(155,255,207,0.95)'}
    ], box.x + 10, box.y + 10);
  }

  // ----------------------------
  // Plot 2: n-hat components vs sweep variable
  // ----------------------------
  function drawPlot2(){
    const p = getParams();
    const {ctx, wCSS, hCSS} = setHiDPICanvas(el.plot2);
    ctx.clearRect(0,0,wCSS,hCSS);

    const margin = {l:72,r:18,t:26,b:52};
    const box = {x:margin.l, y:margin.t, w:wCSS-margin.l-margin.r, h:hCSS-margin.t-margin.b};

    // sweep chosen variable around its current value
    const base = (p.sweep==='a')?p.a : (p.sweep==='b')?p.b : p.c;
    const sMin = Math.max(0.2, base*0.5);
    const sMax = base*2.0;

    // y range for unit components [-1,1] but our components are positive (for positive a,b,c)
    const yMin = -0.05;
    const yMax = 1.05;

    const map = drawAxes(ctx, box, sMin, sMax, yMin, yMax, {
      title: `Unit normal components vs ${p.sweep}`,
      xLabel: p.sweep,
      xUnit: 'units',
      yLabel: 'n̂ component',
      yUnit: '',
      ticks: 5,
      grid: true
    });

    const N = 250;
    const xs = [];
    const nx=[], ny=[], nz=[];
    for(let i=0;i<N;i++){
      const s = lerp(sMin, sMax, i/(N-1));
      let a=p.a, b=p.b, c=p.c;
      if(p.sweep==='a') a=s;
      if(p.sweep==='b') b=s;
      if(p.sweep==='c') c=s;
      const nu = planeUnitNormal(a,b,c).nhat;
      xs.push(s);
      nx.push(nu[0]);
      ny.push(nu[1]);
      nz.push(nu[2]);
    }

    plotLine(ctx, map, xs, nx, 'rgba(122,167,255,0.95)', 2.4);
    plotLine(ctx, map, xs, ny, 'rgba(155,255,207,0.92)', 2.4);
    plotLine(ctx, map, xs, nz, 'rgba(255,207,102,0.92)', 2.4);

    // mark current parameter point
    const x0 = base;
    const nu0 = planeUnitNormal(p.a,p.b,p.c).nhat;
    const ys0 = [nu0[0], nu0[1], nu0[2]];
    const cols = ['rgba(122,167,255,0.95)','rgba(155,255,207,0.92)','rgba(255,207,102,0.92)'];

    ctx.save();
    for(let k=0;k<3;k++){
      ctx.fillStyle = cols[k];
      ctx.beginPath();
      ctx.arc(map.px(x0), map.py(ys0[k]), 3.8, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    drawLegend(ctx, [
      {label:'n̂x', color:'rgba(122,167,255,0.95)'},
      {label:'n̂y', color:'rgba(155,255,207,0.92)'},
      {label:'n̂z', color:'rgba(255,207,102,0.92)'}
    ], box.x + 10, box.y + 10);
  }

  function redrawAll(){
    drawDiagram();
    drawPlot1();
    drawPlot2();
  }

  // ----------------------------
  // Copy buttons
  // ----------------------------
  function hookCopyButtons(){
    const buttons = document.querySelectorAll('button.copyBtn[data-copy]');
    buttons.forEach((btn, idx)=>{
      btn.addEventListener('click', async ()=>{
        const sel = btn.getAttribute('data-copy');
        const node = document.querySelector(sel);
        const text = node ? node.innerText.trim() : '';
        const status = document.getElementById(['status1','status2','status3'][idx] || 'status3');

        try{
          await navigator.clipboard.writeText(text);
          if(status) status.textContent = 'Copied ✓';
          setTimeout(()=>{ if(status) status.textContent=''; }, 1200);
        }catch(e){
          if(status) status.textContent = 'Copy failed (browser permissions)';
          setTimeout(()=>{ if(status) status.textContent=''; }, 2000);
        }
      });
    });
  }

  // ----------------------------
  // Events
  // ----------------------------
  function hookControls(){
    const onChange = ()=>redrawAll();
    ['input','change'].forEach(evt=>{
      el.L.addEventListener(evt, onChange);
      el.a.addEventListener(evt, onChange);
      el.b.addEventListener(evt, onChange);
      el.c.addEventListener(evt, onChange);
      el.sweepVar.addEventListener(evt, onChange);
    });

    el.resetBtn.addEventListener('click', ()=>{
      el.a.value = 1.0;
      el.b.value = 2.0;
      el.c.value = 3.0;
      el.sweepVar.value = 'b';
      redrawAll();
    });

    window.addEventListener('resize', ()=>{
      // Re-render to match new canvas sizes
      redrawAll();
    }, {passive:true});
  }

  // init
  hookCopyButtons();
  hookControls();
  redrawAll();

})();
</script>
</body>
</html>
