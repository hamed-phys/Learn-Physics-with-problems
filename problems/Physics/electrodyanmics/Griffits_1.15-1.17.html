<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <title>Vector Calculus: Divergence (Problems 1.15–1.17)</title>
  <style>
    :root{
      --bg: #0b0f14;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.085);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --faint: rgba(255,255,255,0.50);
      --accent: #7dd3fc;
      --accent2:#a7f3d0;
      --danger:#fb7185;
      --ok:#34d399;
      --border: rgba(255,255,255,0.12);
      --shadow: 0 12px 32px rgba(0,0,0,0.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
      --radius: 18px;
      --radius2: 14px;
      --maxw: 1100px;
    }

    @media (prefers-color-scheme: light){
      :root{
        --bg: #f7fafc;
        --panel: rgba(0,0,0,0.04);
        --panel2: rgba(0,0,0,0.06);
        --text: rgba(0,0,0,0.88);
        --muted: rgba(0,0,0,0.64);
        --faint: rgba(0,0,0,0.45);
        --border: rgba(0,0,0,0.10);
        --shadow: 0 12px 30px rgba(0,0,0,0.10);
      }
    }

    *{ box-sizing:border-box; }
    html{ scroll-behavior:smooth; }
    body{
      margin:0;
      font-family: var(--sans);
      background: radial-gradient(1200px 800px at 15% 0%, rgba(125,211,252,0.14), transparent 55%),
                  radial-gradient(900px 700px at 90% 10%, rgba(167,243,208,0.10), transparent 60%),
                  var(--bg);
      color: var(--text);
      line-height: 1.55;
    }

    header{
      padding: 34px 18px 18px;
    }
    .wrap{
      max-width: var(--maxw);
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    .hero{
      background: linear-gradient(180deg, var(--panel2), var(--panel));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 18px 18px 14px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position: relative;
    }
    .hero:before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(700px 260px at 10% 10%, rgba(125,211,252,0.20), transparent 60%),
                  radial-gradient(700px 260px at 90% 0%, rgba(167,243,208,0.14), transparent 60%);
      pointer-events:none;
      opacity:0.85;
      filter: blur(0.2px);
    }
    .hero > *{ position:relative; }

    h1{
      margin: 0 0 6px;
      font-size: clamp(1.3rem, 2.2vw, 2.0rem);
      letter-spacing: 0.2px;
    }
    .sub{
      margin: 0 0 14px;
      color: var(--muted);
      font-size: 0.98rem;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 14px;
      align-items: start;
    }
    @media (max-width: 920px){
      .grid2{ grid-template-columns: 1fr; }
    }

    .card{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: 0 10px 26px rgba(0,0,0,0.18);
    }

    .quick ul{
      margin: 10px 0 0 18px;
      padding:0;
      color: var(--muted);
    }
    .quick li{ margin: 6px 0; }

    main{
      padding: 0 18px 40px;
    }

    /* Sticky mini TOC */
    .toc{
      position: sticky;
      top: 12px;
      align-self: start;
      padding: 14px;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      background: linear-gradient(180deg, var(--panel2), var(--panel));
      box-shadow: var(--shadow);
    }
    .toc h2{
      margin: 0 0 10px;
      font-size: 1.02rem;
      color: var(--text);
    }
    .toc a{
      display:block;
      padding: 7px 10px;
      margin: 5px 0;
      text-decoration:none;
      color: var(--muted);
      border-radius: 12px;
      border: 1px solid transparent;
      transition: transform .14s ease, background .14s ease, border-color .14s ease;
      font-size: 0.95rem;
    }
    .toc a:hover{
      background: rgba(125,211,252,0.10);
      border-color: rgba(125,211,252,0.22);
      color: var(--text);
      transform: translateX(2px);
    }

    section{
      scroll-margin-top: 70px;
    }
    section > h2{
      margin: 14px 0 10px;
      font-size: 1.22rem;
      letter-spacing: 0.2px;
    }

    .callout{
      border-left: 4px solid rgba(125,211,252,0.75);
      padding: 12px 12px;
      background: rgba(125,211,252,0.07);
      border-radius: 14px;
      border: 1px solid rgba(125,211,252,0.18);
      color: var(--muted);
    }
    .warn{
      border-left-color: rgba(251,113,133,0.85);
      background: rgba(251,113,133,0.08);
      border-color: rgba(251,113,133,0.20);
    }

    .eqblk{
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.18);
      border-radius: var(--radius2);
      padding: 12px;
      overflow: auto;
      position: relative;
    }
    @media (prefers-color-scheme: light){
      .eqblk{ background: rgba(0,0,0,0.03); }
    }
    .eq{
      font-family: var(--mono);
      white-space: pre-wrap;
      color: var(--text);
      font-size: 0.95rem;
    }

    .btnbar{
      display:flex;
      gap:10px;
      flex-wrap: wrap;
      align-items:center;
      margin-top:10px;
    }
    button{
      appearance:none;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 999px;
      padding: 9px 12px;
      font-weight: 600;
      cursor: pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    button:hover{
      transform: translateY(-1px);
      background: rgba(125,211,252,0.10);
      border-color: rgba(125,211,252,0.30);
    }
    button:active{ transform: translateY(0px) scale(0.99); }
    .mini{
      font-size: 0.9rem;
      padding: 7px 10px;
      font-weight: 600;
    }
    .copyStatus{
      font-size: 0.9rem;
      color: var(--muted);
    }

    .viz{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    .vizGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 920px){
      .vizGrid{ grid-template-columns: 1fr; }
    }

    figure{
      margin: 0;
      padding: 12px;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      background: var(--panel);
      box-shadow: 0 12px 26px rgba(0,0,0,0.16);
    }
    figcaption{
      margin-top: 10px;
      color: var(--muted);
      font-size: 0.95rem;
    }
    canvas{
      width: 100%;
      height: 320px;
      display:block;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.16);
    }
    @media (prefers-color-scheme: light){
      canvas{ background: rgba(255,255,255,0.65); border-color: rgba(0,0,0,0.08); }
    }

    .controls{
      display:grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 12px;
      align-items: center;
      margin-top: 10px;
    }
    @media (max-width: 920px){
      .controls{ grid-template-columns: 1fr; }
    }
    .ctrl{
      padding: 12px;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      background: linear-gradient(180deg, var(--panel2), var(--panel));
    }
    label{
      display:block;
      font-weight: 700;
      margin-bottom: 6px;
    }
    input[type="range"]{
      width: 100%;
      accent-color: var(--accent);
    }
    .row{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      color: var(--muted);
      font-size: 0.95rem;
      margin-top: 6px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
    }
    .kpi{
      font-family: var(--mono);
      color: var(--text);
      font-weight: 700;
    }

    .boxFinal{
      border: 1px solid rgba(52,211,153,0.22);
      background: rgba(52,211,153,0.08);
      border-left: 4px solid rgba(52,211,153,0.85);
      padding: 12px;
      border-radius: 14px;
    }

    .cols{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 920px){
      .cols{ grid-template-columns: 1fr; }
    }

    .muted{ color: var(--muted); }
    .small{ font-size: 0.95rem; }
    .hr{
      height:1px;
      background: var(--border);
      margin: 14px 0;
    }

    footer{
      padding: 18px;
      color: var(--faint);
      text-align:center;
    }

    @media print{
      body{ background: #fff; color:#000; }
      .toc, .controls, button{ display:none !important; }
      .hero, .card, figure{ box-shadow:none; }
      canvas{ border:1px solid #bbb; background:#fff; }
      a{ color:#000; text-decoration:none; }
    }

    /* subtle appear animation */
    @keyframes rise {
      from { opacity: 0; transform: translateY(8px); }
      to   { opacity: 1; transform: translateY(0); }
    }
    .anim{ animation: rise .35s ease both; }
  </style>
</head>

<body>
<header>
  <div class="wrap">
    <div class="hero anim">
      <h1>Problems 1.15–1.17: Divergence, a Surprising Field, and Rotational Invariance</h1>
      <p class="sub">We compute divergences of polynomial vector fields, analyze <span class="eq">v = r̂ / r²</span> (including its delta-function divergence at the origin), and prove divergence is invariant under 2D rotations.</p>

      <div class="grid2">
        <div class="card quick">
          <h2 style="margin:0 0 8px;font-size:1.05rem;">Quick Summary</h2>
          <ul>
            <li><span class="eq">∇·v</span> is “source density”: positive means net outflow from a tiny volume, negative means net inflow.</li>
            <li>Problem 1.15 results: <span class="eq">∇·v_a = 2x</span>, <span class="eq">∇·v_b = y</span>, <span class="eq">∇·v_c = 2y + 2z</span>.</li>
            <li>The field <span class="eq">v = r̂ / r²</span> has <span class="eq">∇·v = 0</span> for <span class="eq">r ≠ 0</span>, but it has a singular source at the origin.</li>
            <li>In the distributional sense: <span class="eq">∇·(r̂ / r²) = 4π δ³(r)</span> because its flux through any sphere is <span class="eq">4π</span>.</li>
            <li>In 2D, under a rotation, <span class="eq">∂v_x/∂x + ∂v_y/∂y</span> stays the same number (a scalar invariant).</li>
          </ul>
        </div>

        <nav class="toc anim" aria-label="Mini table of contents">
          <h2>Contents</h2>
          <a href="#part1">PART 1 — Problem Analysis</a>
          <a href="#part2">PART 2 — Strategy & Tips</a>
          <a href="#part3">PART 3 — Full Solution</a>
          <a href="#viz">Interactive Visualizations</a>
          <a href="#final">Final Answers (boxed)</a>
        </nav>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="wrap">

    <!-- ===================== PART 1 ===================== -->
    <section id="part1" class="card anim">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <article>
        <h3 style="margin:10px 0 6px;">Rewrite the problems in plain words</h3>
        <p class="muted">
          <strong>Problem 1.15:</strong> For each given vector field in Cartesian components, compute its divergence
          <span class="eq">∇·v</span>.
        </p>
        <p class="muted">
          <strong>Problem 1.16:</strong> Consider the radial field <span class="eq">v(r) = r̂ / r²</span>. Sketch what it looks like
          (direction + how magnitude changes with distance) and compute its divergence. The “surprise” is that it looks like it has a
          source but <span class="eq">∇·v = 0</span> away from the origin; the resolution involves the singularity at <span class="eq">r=0</span>.
        </p>
        <p class="muted">
          <strong>Problem 1.17:</strong> In 2D, prove that divergence is unchanged by rotating coordinates, i.e.
          <span class="eq">∂v_x/∂x + ∂v_y/∂y = ∂v_x′/∂x′ + ∂v_y′/∂y′</span>.
        </p>

        <div class="cols">
          <div>
            <h3 style="margin:10px 0 6px;">Given quantities</h3>
            <ul class="muted">
              <li>Three Cartesian vector fields for 1.15:
                <div class="eqblk" style="margin-top:8px;">
                  <div class="eq">v_a = x^2 x̂ + 3 x z^2 ŷ − 2 x z ẑ
v_b = x y x̂ + 2 y z ŷ + 3 z x ẑ
v_c = y^2 x̂ + (2 x y + z^2) ŷ + 2 y z ẑ</div>
                </div>
              </li>
              <li>Radial field for 1.16: <span class="eq">v(r) = r̂ / r²</span> in 3D.</li>
              <li>A 2D rotation for 1.17: coordinates (x,y) and (x′,y′) related by angle θ.</li>
            </ul>
          </div>
          <div>
            <h3 style="margin:10px 0 6px;">Unknowns / what must be found</h3>
            <ul class="muted">
              <li>Compute <span class="eq">∇·v_a</span>, <span class="eq">∇·v_b</span>, <span class="eq">∇·v_c</span>.</li>
              <li>Compute and interpret <span class="eq">∇·(r̂/r²)</span> (including at the origin).</li>
              <li>Prove divergence is rotation-invariant (a scalar) in 2D.</li>
            </ul>
          </div>
        </div>

        <h3 style="margin:12px 0 6px;">Relevant principles and why they apply</h3>
        <ul class="muted">
          <li><strong>Divergence in Cartesian form:</strong>
            <span class="eq">∇·v = ∂v_x/∂x + ∂v_y/∂y + ∂v_z/∂z</span>. This directly applies to 1.15.</li>
          <li><strong>Geometric/flux meaning (Gauss’ theorem):</strong>
            <span class="eq">∫_V (∇·v) dV = ∮_∂V v·dA</span>. This is the cleanest way to understand 1.16’s “surprise”.</li>
          <li><strong>Coordinate transformations + chain rule:</strong>
            Under rotations, components mix, and derivatives transform by the Jacobian. This is exactly what 1.17 asks you to show.</li>
        </ul>

        <h3 style="margin:12px 0 6px;">Possible approaches (compare briefly)</h3>
        <ol class="muted">
          <li><strong>Direct differentiation</strong> (best for 1.15): quickest and unambiguous in Cartesian coordinates.</li>
          <li><strong>Spherical-coordinate divergence formula</strong> (possible for 1.16): works for <span class="eq">r≠0</span>, but it hides the singularity at the origin unless you discuss distributions.</li>
          <li><strong>Flux/Gauss theorem</strong> (best for 1.16): immediately shows a nonzero total source at the origin because the flux through any sphere is constant.</li>
          <li><strong>Matrix/Jacobian method</strong> (best for 1.17): systematically proves invariance without “guessing”.</li>
        </ol>

        <div class="callout">
          <strong>Best overall approach:</strong> Use direct Cartesian differentiation for 1.15, Gauss’ theorem plus a “softened” field for 1.16 (to make the delta-function idea concrete), and the chain rule/Jacobian for 1.17.
        </div>
      </article>
    </section>

    <!-- ===================== PART 2 ===================== -->
    <section id="part2" class="card anim">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

      <article>
        <h3 style="margin:10px 0 6px;">Minimal plan (5–10 steps)</h3>
        <ol class="muted">
          <li><strong>Goal:</strong> Compute divergences in 1.15. <strong>Tool:</strong> <span class="eq">∇·v = ∂v_x/∂x + ∂v_y/∂y + ∂v_z/∂z</span>.</li>
          <li><strong>Goal:</strong> Understand geometry of <span class="eq">r̂/r²</span>. <strong>Tool:</strong> interpret as radial arrows with magnitude ∝ <span class="eq">1/r²</span>.</li>
          <li><strong>Goal:</strong> Compute <span class="eq">∇·(r̂/r²)</span> for <span class="eq">r≠0</span>. <strong>Tool:</strong> spherical symmetry (or known divergence formula for purely radial fields).</li>
          <li><strong>Goal:</strong> Resolve the “surprise” at <span class="eq">r=0</span>. <strong>Tool:</strong> Gauss theorem: compute flux through a sphere and infer a delta-function source.</li>
          <li><strong>Goal:</strong> Prove 2D rotational invariance. <strong>Tool:</strong> rotation relations for coordinates and vector components + chain rule for derivatives.</li>
          <li><strong>Goal:</strong> Sanity-check results. <strong>Tool:</strong> dimensional reasoning, special cases, and geometric meaning.</li>
        </ol>

        <h3 style="margin:12px 0 6px;">Common mistakes & quick tips</h3>
        <ul class="muted">
          <li><strong>Mixing up components:</strong> Divergence uses <em>matching</em> derivatives: <span class="eq">∂v_x/∂x</span>, not <span class="eq">∂v_x/∂y</span>.</li>
          <li><strong>Forgetting what depends on what:</strong> In 1.15, treat <span class="eq">x,y,z</span> as independent variables when differentiating.</li>
          <li><strong>For 1.16:</strong> It is true that <span class="eq">∇·(r̂/r²)=0</span> for <span class="eq">r≠0</span>, but that does <em>not</em> mean the total source is zero—because the origin is singular and must be handled separately.</li>
          <li><strong>For 1.17:</strong> Don’t assume invariance; show it by writing derivatives in primed coordinates via the chain rule.</li>
        </ul>

        <div class="callout warn">
          <strong>Key subtlety (1.16):</strong> Gauss’ theorem requires the field to be well-behaved inside the volume. The field <span class="eq">r̂/r²</span> is not well-behaved at the origin, so you must treat the origin separately (leading to a delta-function).
        </div>
      </article>
    </section>

    <!-- ===================== PART 3 ===================== -->
    <section id="part3" class="card anim">
      <h2>PART 3 — Full Solution</h2>

      <article>
        <h3 style="margin:10px 0 6px;">Physical intuition first</h3>
        <p class="muted">
          Think of <span class="eq">∇·v</span> as the <em>net outward flow per unit volume</em> from an infinitesimal box.
          If more “field lines” exit than enter, divergence is positive (a source). If more enter than exit, it’s negative (a sink).
        </p>

        <div class="hr"></div>

        <h3 style="margin:10px 0 6px;">Problem 1.15 — Divergences of the given vector fields</h3>
        <p class="muted">
          In Cartesian coordinates, for <span class="eq">v = v_x x̂ + v_y ŷ + v_z ẑ</span>,
        </p>
        <div class="eqblk">
          <div class="eq" id="eq_div_def">∇·v = ∂v_x/∂x + ∂v_y/∂y + ∂v_z/∂z</div>
          <div class="btnbar">
            <button class="mini" data-copy="#eq_div_def">Copy equation</button>
            <span class="copyStatus" aria-live="polite"></span>
          </div>
        </div>

        <h4 style="margin:12px 0 6px;">(a)  v<sub>a</sub> = x² x̂ + 3 x z² ŷ − 2 x z ẑ</h4>
        <p class="muted">Identify components: <span class="eq">v_x=x²</span>, <span class="eq">v_y=3 x z²</span>, <span class="eq">v_z=−2 x z</span>.</p>
        <div class="eqblk">
          <div class="eq" id="eq_15a">
∂v_x/∂x = ∂(x²)/∂x = 2x
∂v_y/∂y = ∂(3 x z²)/∂y = 0   (no y dependence)
∂v_z/∂z = ∂(−2 x z)/∂z = −2x

Therefore:  ∇·v_a = 2x + 0 + (−2x) = 0?  (Careful: check again!)
Wait: v_z = −2 x z, so ∂v_z/∂z = −2x, yes.
So ∇·v_a = 2x − 2x = 0.
But we must also include ∂v_y/∂y = 0.
Final: ∇·v_a = 0.</div>
          <div class="btnbar">
            <button class="mini" data-copy="#eq_15a">Copy steps</button>
            <span class="copyStatus" aria-live="polite"></span>
          </div>
        </div>

        <div class="callout" style="margin-top:10px;">
          <strong>Sanity check:</strong> This field has “stretching” in x (from x²) but also a compensating z-component term (−2xz) whose z-derivative cancels the x-derivative. Net local source density is zero everywhere.
        </div>

        <h4 style="margin:12px 0 6px;">(b)  v<sub>b</sub> = x y x̂ + 2 y z ŷ + 3 z x ẑ</h4>
        <p class="muted">Components: <span class="eq">v_x=xy</span>, <span class="eq">v_y=2yz</span>, <span class="eq">v_z=3zx</span>.</p>
        <div class="eqblk">
          <div class="eq" id="eq_15b">
∂v_x/∂x = ∂(x y)/∂x = y
∂v_y/∂y = ∂(2 y z)/∂y = 2z
∂v_z/∂z = ∂(3 z x)/∂z = 3x

Therefore:  ∇·v_b = y + 2z + 3x.</div>
          <div class="btnbar">
            <button class="mini" data-copy="#eq_15b">Copy steps</button>
            <span class="copyStatus" aria-live="polite"></span>
          </div>
        </div>

        <h4 style="margin:12px 0 6px;">(c)  v<sub>c</sub> = y² x̂ + (2 x y + z²) ŷ + 2 y z ẑ</h4>
        <p class="muted">Components: <span class="eq">v_x=y²</span>, <span class="eq">v_y=2xy+z²</span>, <span class="eq">v_z=2yz</span>.</p>
        <div class="eqblk">
          <div class="eq" id="eq_15c">
∂v_x/∂x = ∂(y²)/∂x = 0
∂v_y/∂y = ∂(2 x y + z²)/∂y = 2x
∂v_z/∂z = ∂(2 y z)/∂z = 2y

Therefore:  ∇·v_c = 0 + 2x + 2y = 2x + 2y.</div>
          <div class="btnbar">
            <button class="mini" data-copy="#eq_15c">Copy steps</button>
            <span class="copyStatus" aria-live="polite"></span>
          </div>
        </div>

        <div class="hr"></div>

        <h3 style="margin:10px 0 6px;">Problem 1.16 — Sketch and divergence of v = r̂ / r²</h3>
        <h4 style="margin:10px 0 6px;">(i) Sketch / description</h4>
        <p class="muted">
          <span class="eq">r̂</span> points radially outward from the origin. The magnitude is <span class="eq">|v| = 1/r²</span>, so arrows are huge near the origin
          and fall off quickly with distance. This is exactly the same radial dependence as the electric field of a point charge (up to constants).
        </p>

        <h4 style="margin:10px 0 6px;">(ii) Divergence for r ≠ 0</h4>
        <p class="muted">
          For a purely radial field <span class="eq">v = f(r) r̂</span> (spherically symmetric), for <span class="eq">r≠0</span>:
        </p>
        <div class="eqblk">
          <div class="eq" id="eq_radial_div">∇·(f(r) r̂) = (1/r²) d/dr [ r² f(r) ]   (valid for r ≠ 0)</div>
          <div class="btnbar">
            <button class="mini" data-copy="#eq_radial_div">Copy equation</button>
            <span class="copyStatus" aria-live="polite"></span>
          </div>
        </div>

        <p class="muted">
          Here, <span class="eq">f(r)=1/r²</span>. Then <span class="eq">r² f(r)=1</span>, so its derivative is zero:
        </p>
        <div class="eqblk">
          <div class="eq" id="eq_16_rne0">
For r ≠ 0:
r² f(r) = r² (1/r²) = 1
d/dr [1] = 0
So  ∇·(r̂/r²) = 0   for r ≠ 0.</div>
          <div class="btnbar">
            <button class="mini" data-copy="#eq_16_rne0">Copy steps</button>
            <span class="copyStatus" aria-live="polite"></span>
          </div>
        </div>

        <h4 style="margin:10px 0 6px;">(iii) Why this “may surprise you” (the origin matters)</h4>
        <p class="muted">
          If <span class="eq">∇·v = 0</span> everywhere, you might expect zero net flux through any closed surface. But for this field,
          the flux through a sphere of radius <span class="eq">R</span> is:
        </p>
        <div class="eqblk">
          <div class="eq" id="eq_flux_sphere">
On a sphere of radius R:
v = r̂/R²,   dA = r̂ R² dΩ
v·dA = (r̂/R²)·(r̂ R² dΩ) = dΩ
Φ(R) = ∮ v·dA = ∮ dΩ = 4π.</div>
          <div class="btnbar">
            <button class="mini" data-copy="#eq_flux_sphere">Copy steps</button>
            <span class="copyStatus" aria-live="polite"></span>
          </div>
        </div>

        <p class="muted">
          So every sphere encloses the same nonzero flux <span class="eq">4π</span>. That means there is a net “source” at the origin.
          The resolution is: the divergence is zero for <span class="eq">r≠0</span>, but at <span class="eq">r=0</span> the field is singular and contributes a delta function.
        </p>

        <div class="boxFinal">
          <div class="eq" id="eq_delta_final"><strong>Distributional result:</strong>
∇·(r̂/r²) = 4π δ³(r).</div>
          <div class="btnbar">
            <button class="mini" data-copy="#eq_delta_final">Copy final result</button>
            <span class="copyStatus" aria-live="polite"></span>
          </div>
          <p class="muted small" style="margin:10px 0 0;">
            Meaning: it is zero everywhere except at the origin, but integrates over any volume containing the origin to give <span class="eq">4π</span>.
          </p>
        </div>

        <h4 style="margin:10px 0 6px;">(iv) A “softened” field to make the delta-function visible</h4>
        <p class="muted">
          To visualize the singular behavior, replace <span class="eq">r</span> by <span class="eq">√(r²+ε²)</span> (an example regularization):
        </p>
        <div class="eqblk">
          <div class="eq" id="eq_soft_field">
Define (example regularization):
v_ε(r) = r / (r² + ε²)^(3/2)
This approaches r̂/r² when r ≫ ε.</div>
          <div class="btnbar">
            <button class="mini" data-copy="#eq_soft_field">Copy equation</button>
            <span class="copyStatus" aria-live="polite"></span>
          </div>
        </div>
        <p class="muted">
          For this smooth field, the divergence is an ordinary function (no singularity):
        </p>
        <div class="eqblk">
          <div class="eq" id="eq_soft_div">
∇·v_ε(r) = 3 ε² / (r² + ε²)^(5/2).</div>
          <div class="btnbar">
            <button class="mini" data-copy="#eq_soft_div">Copy equation</button>
            <span class="copyStatus" aria-live="polite"></span>
          </div>
        </div>
        <p class="muted">
          As <span class="eq">ε → 0</span>, this becomes a spike near <span class="eq">r=0</span> whose total integral stays fixed:
          <span class="eq">∫(∇·v_ε) dV = 4π</span>, matching the delta-function statement.
        </p>

        <div class="hr"></div>

        <h3 style="margin:10px 0 6px;">Problem 1.17 — Divergence transforms as a scalar under 2D rotations</h3>

        <h4 style="margin:10px 0 6px;">Setup: rotation relations</h4>
        <p class="muted">
          Let a rotation by angle <span class="eq">θ</span> relate coordinates:
        </p>
        <div class="eqblk">
          <div class="eq" id="eq_rot_coords">
x =  x′ cosθ − y′ sinθ
y =  x′ sinθ + y′ cosθ</div>
          <div class="btnbar">
            <button class="mini" data-copy="#eq_rot_coords">Copy equations</button>
            <span class="copyStatus" aria-live="polite"></span>
          </div>
        </div>

        <p class="muted">
          Vector components rotate the same way:
        </p>
        <div class="eqblk">
          <div class="eq" id="eq_rot_vec">
v_x = v_x′ cosθ − v_y′ sinθ
v_y = v_x′ sinθ + v_y′ cosθ</div>
          <div class="btnbar">
            <button class="mini" data-copy="#eq_rot_vec">Copy equations</button>
            <span class="copyStatus" aria-live="polite"></span>
          </div>
        </div>

        <h4 style="margin:10px 0 6px;">Chain rule for derivatives</h4>
        <p class="muted">
          We need to express <span class="eq">∂/∂x</span> and <span class="eq">∂/∂y</span> in terms of <span class="eq">∂/∂x′</span>, <span class="eq">∂/∂y′</span>.
          Invert the rotation (or differentiate x,y w.r.t. x′,y′). From the inverse rotation:
        </p>
        <div class="eqblk">
          <div class="eq" id="eq_rot_inverse">
x′ = x cosθ + y sinθ
y′ = −x sinθ + y cosθ</div>
          <div class="btnbar">
            <button class="mini" data-copy="#eq_rot_inverse">Copy equations</button>
            <span class="copyStatus" aria-live="polite"></span>
          </div>
        </div>

        <p class="muted">
          Therefore, by the chain rule:
        </p>
        <div class="eqblk">
          <div class="eq" id="eq_chain_ops">
∂/∂x = (∂x′/∂x) ∂/∂x′ + (∂y′/∂x) ∂/∂y′ = (cosθ) ∂/∂x′ + (−sinθ) ∂/∂y′
∂/∂y = (∂x′/∂y) ∂/∂x′ + (∂y′/∂y) ∂/∂y′ = (sinθ) ∂/∂x′ + (cosθ) ∂/∂y′</div>
          <div class="btnbar">
            <button class="mini" data-copy="#eq_chain_ops">Copy steps</button>
            <span class="copyStatus" aria-live="polite"></span>
          </div>
        </div>

        <h4 style="margin:10px 0 6px;">Compute divergence and show invariance</h4>
        <p class="muted">
          Start with <span class="eq">∇·v = ∂v_x/∂x + ∂v_y/∂y</span>.
          Substitute the rotated components from <span class="eq">v_x, v_y</span> and the derivative operators from above.
        </p>

        <div class="eqblk">
          <div class="eq" id="eq_rot_invariance">
Compute ∂v_x/∂x:
v_x = v_x′ cosθ − v_y′ sinθ
∂/∂x = cosθ ∂/∂x′ − sinθ ∂/∂y′

So:
∂v_x/∂x = (cosθ ∂/∂x′ − sinθ ∂/∂y′)(v_x′ cosθ − v_y′ sinθ)
        = cos²θ (∂v_x′/∂x′) − cosθ sinθ (∂v_y′/∂x′)
          − sinθ cosθ (∂v_x′/∂y′) + sin²θ (∂v_y′/∂y′)

Compute ∂v_y/∂y:
v_y = v_x′ sinθ + v_y′ cosθ
∂/∂y = sinθ ∂/∂x′ + cosθ ∂/∂y′

So:
∂v_y/∂y = (sinθ ∂/∂x′ + cosθ ∂/∂y′)(v_x′ sinθ + v_y′ cosθ)
        = sin²θ (∂v_x′/∂x′) + sinθ cosθ (∂v_y′/∂x′)
          + cosθ sinθ (∂v_x′/∂y′) + cos²θ (∂v_y′/∂y′)

Now add them:
∂v_x/∂x + ∂v_y/∂y
= (cos²θ + sin²θ) (∂v_x′/∂x′) + (sin²θ + cos²θ) (∂v_y′/∂y′)
  + [−cosθ sinθ + sinθ cosθ](∂v_y′/∂x′)
  + [−sinθ cosθ + cosθ sinθ](∂v_x′/∂y′)

Cross terms cancel, and cos²θ + sin²θ = 1:

⇒  ∇·v = ∂v_x′/∂x′ + ∂v_y′/∂y′  (invariant under rotation).</div>
          <div class="btnbar">
            <button class="mini" data-copy="#eq_rot_invariance">Copy derivation</button>
            <span class="copyStatus" aria-live="polite"></span>
          </div>
        </div>

        <div class="callout">
          <strong>Interpretation:</strong> Divergence is a scalar invariant: it measures net expansion/compression at a point, which should not depend on how you rotate your axes.
        </div>

        <h3 style="margin:12px 0 6px;">Sanity checks</h3>
        <ul class="muted">
          <li><strong>Units:</strong> If <span class="eq">v</span> has units U, then <span class="eq">∇·v</span> has units U/length. For <span class="eq">r̂/r²</span> (units 1/length²), divergence is 0 for <span class="eq">r≠0</span>, and the delta term has units 1/length³ (so that its integral is dimensionless), consistent.</li>
          <li><strong>Limiting cases (1.16):</strong> Flux through a sphere stays <span class="eq">4π</span> for any radius: consistent with a point source at the origin.</li>
          <li><strong>Coordinate independence (1.17):</strong> A physical “source density” should not change when you rotate your coordinate system—your proof confirms that.</li>
        </ul>
      </article>
    </section>

    <!-- ===================== VISUALIZATION ===================== -->
    <section id="viz" class="card anim">
      <h2>Interactive Visualizations</h2>
      <p class="muted">
        We visualize the “surprising” field from Problem 1.16 using a smooth regularization
        <span class="eq">v_ε(r) = r / (r²+ε²)^(3/2)</span>.
        The slider changes <span class="eq">ε</span> and updates:
        (1) a labeled geometry diagram, (2) a plot of <span class="eq">∇·v_ε(r)</span>, and (3) a plot of flux <span class="eq">Φ_ε(R)</span> through a sphere.
      </p>

      <div class="controls">
        <div class="ctrl">
          <label for="eps">Regularization scale ε (example parameter, length units)</label>
          <input id="eps" type="range" min="0.02" max="1.00" step="0.01" value="0.20" />
          <div class="row">
            <span class="pill">ε = <span class="kpi" id="epsVal">0.20</span></span>
            <span class="pill">Peak(∇·v<sub>ε</sub>) ≈ <span class="kpi" id="peakVal">—</span></span>
            <span class="pill">Φ<sub>ε</sub>(R→∞) → <span class="kpi">4π</span></span>
          </div>
          <div class="row">
            <label style="display:flex;gap:10px;align-items:center;font-weight:700;margin:0;">
              <input id="showIdeal" type="checkbox" checked />
              <span>Show “ideal” reference (∇·v = 0 for r ≠ 0; Φ = 4π)</span>
            </label>
          </div>
        </div>

        <div class="ctrl">
          <label for="rmax">Plot range R<sub>max</sub> (length units)</label>
          <input id="rmax" type="range" min="1" max="10" step="0.5" value="6" />
          <div class="row">
            <span class="pill">R<sub>max</sub> = <span class="kpi" id="rmaxVal">6.0</span></span>
            <span class="pill">Note: units are arbitrary “example units”</span>
          </div>
          <div class="btnbar">
            <button class="mini" id="resetBtn">Reset</button>
          </div>
        </div>
      </div>

      <div class="viz">
        <figure>
          <canvas id="cnvDiagram" aria-label="Diagram: radial field and Gaussian sphere"></canvas>
          <figcaption>
            Diagram: radial field lines (<span class="eq">r̂</span>) and a Gaussian sphere of radius <span class="eq">R</span>.
            The magnitude decreases as <span class="eq">1/r²</span>.
          </figcaption>
        </figure>

        <div class="vizGrid">
          <figure>
            <canvas id="cnvPlot1" aria-label="Main plot: divergence vs radius"></canvas>
            <figcaption>
              Main plot: <span class="eq">∇·v_ε(r) = 3ε²/(r²+ε²)^(5/2)</span>. As ε decreases, it concentrates near <span class="eq">r=0</span> (approaching <span class="eq">4π δ³(r)</span> in 3D).
            </figcaption>
          </figure>

          <figure>
            <canvas id="cnvPlot2" aria-label="Secondary plot: flux through a sphere vs radius"></canvas>
            <figcaption>
              Secondary plot: flux through a sphere of radius <span class="eq">R</span>.
              Ideal field gives <span class="eq">Φ(R)=4π</span> for any <span class="eq">R&gt;0</span>.
              Regularized field gives <span class="eq">Φ_ε(R)=4π R³/(R²+ε²)^(3/2)</span>, approaching <span class="eq">4π</span> as <span class="eq">R≫ε</span>.
            </figcaption>
          </figure>
        </div>
      </div>
    </section>

    <!-- ===================== FINAL ANSWERS ===================== -->
    <section id="final" class="card anim">
      <h2>Final Answers (boxed)</h2>

      <div class="boxFinal">
        <div class="eq" id="eq_final_all"><strong>Problem 1.15</strong>
∇·v_a = 0
∇·v_b = y + 2z + 3x
∇·v_c = 2x + 2y

<strong>Problem 1.16</strong>
For r ≠ 0:  ∇·(r̂/r²) = 0
In the distributional sense:  ∇·(r̂/r²) = 4π δ³(r)

<strong>Problem 1.17 (2D rotation)</strong>
∂v_x/∂x + ∂v_y/∂y = ∂v_x′/∂x′ + ∂v_y′/∂y′</div>
        <div class="btnbar">
          <button class="mini" data-copy="#eq_final_all">Copy final answers</button>
          <span class="copyStatus" aria-live="polite"></span>
        </div>
      </div>

      <div class="callout" style="margin-top:12px;">
        <strong>Extra intuition (1.16):</strong> The field looks like it’s “created” at the origin. That’s true—but the “creation” is infinitely concentrated at one point, so you only see it as a delta function at <span class="eq">r=0</span>.
      </div>
    </section>

  </div>
</main>

<footer>
  <div class="wrap">
    <div class="muted small">Self-contained article (vanilla HTML/CSS/JS). Canvas plots are interactive and update live.</div>
  </div>
</footer>

<script>
/* ==============================
   Copy buttons (plain text)
============================== */
(function(){
  function getText(sel){
    const el = document.querySelector(sel);
    if(!el) return "";
    return el.innerText.replace(/\u00A0/g," ").trim();
  }
  async function copyText(text){
    try{
      await navigator.clipboard.writeText(text);
      return true;
    }catch(e){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.style.position="fixed";
      ta.style.opacity="0";
      document.body.appendChild(ta);
      ta.select();
      try{
        document.execCommand("copy");
        document.body.removeChild(ta);
        return true;
      }catch(err){
        document.body.removeChild(ta);
        return false;
      }
    }
  }

  document.addEventListener("click", async (e)=>{
    const btn = e.target.closest("button[data-copy]");
    if(!btn) return;
    const sel = btn.getAttribute("data-copy");
    const text = getText(sel);
    const ok = await copyText(text);
    const status = btn.parentElement.querySelector(".copyStatus");
    if(status){
      status.textContent = ok ? "Copied ✓" : "Copy failed";
      setTimeout(()=> status.textContent="", 1200);
    }
  });
})();

/* ==============================
   Canvas utilities: HiDPI + resize
============================== */
function setupHiDPICanvas(canvas){
  const ctx = canvas.getContext("2d");
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width * dpr));
    const h = Math.max(1, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w;
      canvas.height = h;
    }
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  }
  resize();
  return {ctx, resize};
}

/* ==============================
   Plotting: axes, ticks, grid
============================== */
function niceStep(range){
  const rough = range / 6;
  const pow = Math.pow(10, Math.floor(Math.log10(rough)));
  const frac = rough / pow;
  let niceFrac = 1;
  if(frac < 1.5) niceFrac = 1;
  else if(frac < 3) niceFrac = 2;
  else if(frac < 7) niceFrac = 5;
  else niceFrac = 10;
  return niceFrac * pow;
}
function drawAxes(ctx, box, xMin, xMax, yMin, yMax, opts){
  const {
    title="", xLabel="", yLabel="",
    grid=true, ticks=true
  } = opts || {};
  const {x, y, w, h} = box;
  ctx.save();

  // background
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);

  // Title
  ctx.font = "700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--text").trim() || "#fff";
  ctx.fillText(title, x, y-10);

  // frame
  ctx.strokeStyle = "rgba(128,128,128,0.28)";
  ctx.lineWidth = 1;
  ctx.strokeRect(x, y, w, h);

  const xRange = xMax - xMin;
  const yRange = yMax - yMin;
  const xStep = niceStep(xRange);
  const yStep = niceStep(yRange);

  function X(v){ return x + (v - xMin) / xRange * w; }
  function Y(v){ return y + h - (v - yMin) / yRange * h; }

  // grid + ticks
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  ctx.fillStyle = "rgba(128,128,128,0.95)";
  ctx.strokeStyle = "rgba(128,128,128,0.18)";

  if(grid || ticks){
    // x ticks
    const xStart = Math.ceil(xMin / xStep) * xStep;
    for(let xv = xStart; xv <= xMax + 1e-12; xv += xStep){
      const xx = X(xv);
      if(grid){
        ctx.beginPath();
        ctx.moveTo(xx, y);
        ctx.lineTo(xx, y+h);
        ctx.stroke();
      }
      if(ticks){
        ctx.strokeStyle = "rgba(128,128,128,0.35)";
        ctx.beginPath();
        ctx.moveTo(xx, y+h);
        ctx.lineTo(xx, y+h+5);
        ctx.stroke();
        ctx.strokeStyle = "rgba(128,128,128,0.18)";

        const label = (Math.abs(xv) < 1e-9) ? "0" : (Math.round(xv*100)/100).toString();
        ctx.fillText(label, xx-8, y+h+18);
      }
    }

    // y ticks
    const yStart = Math.ceil(yMin / yStep) * yStep;
    for(let yv = yStart; yv <= yMax + 1e-12; yv += yStep){
      const yy = Y(yv);
      if(grid){
        ctx.beginPath();
        ctx.moveTo(x, yy);
        ctx.lineTo(x+w, yy);
        ctx.stroke();
      }
      if(ticks){
        ctx.strokeStyle = "rgba(128,128,128,0.35)";
        ctx.beginPath();
        ctx.moveTo(x-5, yy);
        ctx.lineTo(x, yy);
        ctx.stroke();
        ctx.strokeStyle = "rgba(128,128,128,0.18)";

        const label = (Math.abs(yv) < 1e-9) ? "0" : (Math.round(yv*100)/100).toString();
        ctx.fillText(label, x-46, yy+4);
      }
    }
  }

  // axis labels
  ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillStyle = "rgba(128,128,128,0.95)";
  ctx.fillText(xLabel, x + w - ctx.measureText(xLabel).width, y + h + 36);

  ctx.save();
  ctx.translate(x - 54, y + 12);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  ctx.restore();
  return {X, Y};
}
function drawLegend(ctx, items, x, y){
  // items: [{label, styleFn(ctx)}]
  ctx.save();
  ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  const pad = 8;
  let maxW = 0;
  for(const it of items){
    maxW = Math.max(maxW, ctx.measureText(it.label).width);
  }
  const boxW = maxW + 54;
  const boxH = items.length * 18 + pad*2;
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.strokeStyle = "rgba(128,128,128,0.25)";
  // in light mode, dark fill can be too strong
  const isLight = matchMedia("(prefers-color-scheme: light)").matches;
  ctx.fillStyle = isLight ? "rgba(255,255,255,0.75)" : "rgba(0,0,0,0.25)";
  ctx.beginPath();
  roundRect(ctx, x, y, boxW, boxH, 12);
  ctx.fill();
  ctx.stroke();

  items.forEach((it,i)=>{
    const yy = y + pad + i*18 + 6;
    ctx.save();
    it.styleFn(ctx);
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(x+10, yy);
    ctx.lineTo(x+30, yy);
    ctx.stroke();
    ctx.restore();

    ctx.fillStyle = isLight ? "rgba(0,0,0,0.75)" : "rgba(255,255,255,0.85)";
    ctx.fillText(it.label, x+36, yy+4);
  });
  ctx.restore();
}
function roundRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

/* ==============================
   Physics functions for 1.16 (regularized)
   v_eps = r / (r^2 + eps^2)^(3/2)
   div v_eps = 3 eps^2 / (r^2 + eps^2)^(5/2)
   flux Phi_eps(R) = 4π R^3 / (R^2 + eps^2)^(3/2)
============================== */
function div_eps(r, eps){
  const den = Math.pow(r*r + eps*eps, 2.5);
  return (3*eps*eps) / den;
}
function phi_eps(R, eps){
  const den = Math.pow(R*R + eps*eps, 1.5);
  return 4*Math.PI * (R*R*R) / den;
}

/* ==============================
   Render: diagram + plots
============================== */
const cnvDiagram = document.getElementById("cnvDiagram");
const cnvPlot1 = document.getElementById("cnvPlot1");
const cnvPlot2 = document.getElementById("cnvPlot2");

const D = setupHiDPICanvas(cnvDiagram);
const P1 = setupHiDPICanvas(cnvPlot1);
const P2 = setupHiDPICanvas(cnvPlot2);

const epsSlider = document.getElementById("eps");
const rmaxSlider = document.getElementById("rmax");
const showIdeal = document.getElementById("showIdeal");
const epsVal = document.getElementById("epsVal");
const rmaxVal = document.getElementById("rmaxVal");
const peakVal = document.getElementById("peakVal");

function drawDiagram(eps, Rmax){
  const ctx = D.ctx;
  const w = cnvDiagram.getBoundingClientRect().width;
  const h = cnvDiagram.getBoundingClientRect().height;

  ctx.clearRect(0,0, w, h);

  // background
  const isLight = matchMedia("(prefers-color-scheme: light)").matches;
  ctx.fillStyle = isLight ? "rgba(255,255,255,0.9)" : "rgba(0,0,0,0.16)";
  ctx.fillRect(0,0,w,h);

  // axes and origin
  const cx = w*0.32, cy = h*0.55;
  const sphereR = Math.min(w,h)*0.22;

  // subtle glow
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = isLight ? "rgba(125,211,252,0.16)" : "rgba(125,211,252,0.12)";
  ctx.beginPath();
  ctx.arc(cx, cy, sphereR*1.15, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // sphere outline
  ctx.strokeStyle = isLight ? "rgba(0,0,0,0.28)" : "rgba(255,255,255,0.28)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(cx, cy, sphereR, 0, Math.PI*2);
  ctx.stroke();

  // dashed "hidden" great circle
  ctx.setLineDash([6,6]);
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(cx, cy, sphereR, sphereR*0.45, 0, 0, Math.PI*2);
  ctx.stroke();
  ctx.setLineDash([]);

  // radial arrows around
  const n = 14;
  for(let i=0;i<n;i++){
    const ang = i*(2*Math.PI/n);
    const x1 = cx + Math.cos(ang)*(sphereR*0.25);
    const y1 = cy + Math.sin(ang)*(sphereR*0.25);
    const x2 = cx + Math.cos(ang)*(sphereR*1.35);
    const y2 = cy + Math.sin(ang)*(sphereR*1.35);

    // magnitude cue: arrows shorter for farther radii; stylized
    ctx.strokeStyle = isLight ? "rgba(52,211,153,0.75)" : "rgba(167,243,208,0.75)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    // arrow head
    const ah = 10;
    const ax = x2, ay = y2;
    const backAng1 = ang + Math.PI - 0.35;
    const backAng2 = ang + Math.PI + 0.35;
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax + Math.cos(backAng1)*ah, ay + Math.sin(backAng1)*ah);
    ctx.lineTo(ax + Math.cos(backAng2)*ah, ay + Math.sin(backAng2)*ah);
    ctx.closePath();
    ctx.fillStyle = isLight ? "rgba(52,211,153,0.75)" : "rgba(167,243,208,0.75)";
    ctx.fill();
  }

  // origin point
  ctx.fillStyle = isLight ? "rgba(251,113,133,0.85)" : "rgba(251,113,133,0.82)";
  ctx.beginPath();
  ctx.arc(cx, cy, 5, 0, Math.PI*2);
  ctx.fill();

  // labels
  ctx.font = "700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillStyle = isLight ? "rgba(0,0,0,0.82)" : "rgba(255,255,255,0.88)";
  ctx.fillText("Gaussian sphere (radius R)", cx - sphereR*0.65, cy - sphereR - 16);
  ctx.fillText("Origin (singularity)", cx - 58, cy + 26);

  ctx.font = "600 13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  ctx.fillStyle = isLight ? "rgba(0,0,0,0.70)" : "rgba(255,255,255,0.75)";
  ctx.fillText("v = r̂ / r²  (radial, ~1/r²)", w*0.56, h*0.20);
  ctx.fillText("regularized: vε = r/(r²+ε²)^(3/2)", w*0.50, h*0.28);
  ctx.fillText("ε = " + eps.toFixed(2) + " (example)", w*0.50, h*0.36);

  // indicate eps "core"
  const coreR = sphereR * Math.min(0.55, (eps / (Rmax || 6)) * 2.8);
  ctx.strokeStyle = isLight ? "rgba(125,211,252,0.65)" : "rgba(125,211,252,0.70)";
  ctx.lineWidth = 2;
  ctx.setLineDash([5,5]);
  ctx.beginPath();
  ctx.arc(cx, cy, Math.max(10, coreR), 0, Math.PI*2);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillStyle = isLight ? "rgba(125,211,252,0.90)" : "rgba(125,211,252,0.92)";
  ctx.fillText("core ~ ε", cx + Math.max(10, coreR) + 10, cy - 4);
}

function drawPlot1(eps, Rmax, showIdealRef){
  const ctx = P1.ctx;
  const w = cnvPlot1.getBoundingClientRect().width;
  const h = cnvPlot1.getBoundingClientRect().height;

  const padL = 62, padR = 16, padT = 36, padB = 54;
  const box = {x: padL, y: padT, w: w - padL - padR, h: h - padT - padB};

  // data
  const N = 500;
  const rMin = 0.0;
  const rMax = Rmax;

  // y range: auto from peak near r=0
  const peak = div_eps(0, eps); // at r=0
  const yMax = peak * 1.08;
  const yMin = -0.05 * yMax;

  peakVal.textContent = (Math.round(peak*1000)/1000).toString();

  const {X,Y} = drawAxes(ctx, box, rMin, rMax, yMin, yMax, {
    title: "Divergence density vs radius",
    xLabel: "r (length units)",
    yLabel: "∇·vε  (1/length³)",
    grid: true,
    ticks: true
  });

  // ideal reference line at 0 (for r>0)
  if(showIdealRef){
    ctx.save();
    ctx.strokeStyle = "rgba(251,113,133,0.65)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(X(rMin), Y(0));
    ctx.lineTo(X(rMax), Y(0));
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  // curve
  ctx.save();
  ctx.strokeStyle = "rgba(125,211,252,0.95)";
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  for(let i=0;i<N;i++){
    const r = rMin + (rMax-rMin)*i/(N-1);
    const yv = div_eps(r, eps);
    const xx = X(r);
    const yy = Y(yv);
    if(i===0) ctx.moveTo(xx,yy);
    else ctx.lineTo(xx,yy);
  }
  ctx.stroke();
  ctx.restore();

  // legend
  drawLegend(ctx, [
    {label:"∇·vε(r)", styleFn:(c)=>{ c.strokeStyle="rgba(125,211,252,0.95)"; }},
    ...(showIdealRef ? [{label:"ideal: ∇·v = 0 (r≠0)", styleFn:(c)=>{ c.strokeStyle="rgba(251,113,133,0.65)"; c.setLineDash([6,6]); }}] : [])
  ], box.x + 10, box.y + 10);

  // annotation about area under curve
  ctx.save();
  ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillStyle = matchMedia("(prefers-color-scheme: light)").matches ? "rgba(0,0,0,0.70)" : "rgba(255,255,255,0.75)";
  ctx.fillText("As ε→0, this spikes near r=0 but total ∫(∇·vε)dV stays 4π.", box.x + 10, box.y + box.h - 10);
  ctx.restore();
}

function drawPlot2(eps, Rmax, showIdealRef){
  const ctx = P2.ctx;
  const w = cnvPlot2.getBoundingClientRect().width;
  const h = cnvPlot2.getBoundingClientRect().height;

  const padL = 62, padR = 16, padT = 36, padB = 54;
  const box = {x: padL, y: padT, w: w - padL - padR, h: h - padT - padB};

  const N = 500;
  const Rmin = 0.0;
  const Rmax2 = Rmax;

  // flux range
  const ideal = 4*Math.PI;
  const yMin = -0.08*ideal;
  const yMax = 1.15*ideal;

  const {X,Y} = drawAxes(ctx, box, Rmin, Rmax2, yMin, yMax, {
    title: "Flux through sphere vs radius",
    xLabel: "R (length units)",
    yLabel: "Φ(R) (dimensionless)",
    grid: true,
    ticks: true
  });

  // ideal reference 4π
  if(showIdealRef){
    ctx.save();
    ctx.strokeStyle = "rgba(52,211,153,0.75)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(X(Rmin), Y(ideal));
    ctx.lineTo(X(Rmax2), Y(ideal));
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  // regularized flux curve
  ctx.save();
  ctx.strokeStyle = "rgba(167,243,208,0.95)";
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  for(let i=0;i<N;i++){
    const R = Rmin + (Rmax2-Rmin)*i/(N-1);
    const yv = phi_eps(R, eps);
    const xx = X(R);
    const yy = Y(yv);
    if(i===0) ctx.moveTo(xx,yy);
    else ctx.lineTo(xx,yy);
  }
  ctx.stroke();
  ctx.restore();

  // mark R = eps
  ctx.save();
  ctx.strokeStyle = "rgba(125,211,252,0.55)";
  ctx.lineWidth = 1.8;
  ctx.setLineDash([4,5]);
  ctx.beginPath();
  ctx.moveTo(X(eps), box.y);
  ctx.lineTo(X(eps), box.y + box.h);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();

  // legend
  drawLegend(ctx, [
    {label:"Φε(R)", styleFn:(c)=>{ c.strokeStyle="rgba(167,243,208,0.95)"; }},
    ...(showIdealRef ? [{label:"ideal Φ=4π", styleFn:(c)=>{ c.strokeStyle="rgba(52,211,153,0.75)"; c.setLineDash([6,6]); }}] : []),
    {label:"R = ε", styleFn:(c)=>{ c.strokeStyle="rgba(125,211,252,0.55)"; c.setLineDash([4,5]); }}
  ], box.x + 10, box.y + 10);

  // annotation
  ctx.save();
  ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillStyle = matchMedia("(prefers-color-scheme: light)").matches ? "rgba(0,0,0,0.70)" : "rgba(255,255,255,0.75)";
  ctx.fillText("Φε(R) rises from 0 near R=0 and approaches 4π for R≫ε.", box.x + 10, box.y + box.h - 10);
  ctx.restore();
}

function renderAll(){
  const eps = parseFloat(epsSlider.value);
  const Rmax = parseFloat(rmaxSlider.value);
  const showRef = !!showIdeal.checked;
  epsVal.textContent = eps.toFixed(2);
  rmaxVal.textContent = Rmax.toFixed(1);
  drawDiagram(eps, Rmax);
  drawPlot1(eps, Rmax, showRef);
  drawPlot2(eps, Rmax, showRef);
}

function handleResize(){
  D.resize(); P1.resize(); P2.resize();
  renderAll();
}

window.addEventListener("resize", handleResize);
epsSlider.addEventListener("input", renderAll);
rmaxSlider.addEventListener("input", renderAll);
showIdeal.addEventListener("change", renderAll);
document.getElementById("resetBtn").addEventListener("click", ()=>{
  epsSlider.value = "0.20";
  rmaxSlider.value = "6";
  showIdeal.checked = true;
  renderAll();
});

// initial
renderAll();
</script>
</body>
</html>
