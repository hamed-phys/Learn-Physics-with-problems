<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Phase-Plane Analysis of Two Nonlinear Systems (Critical Points, Linearization, Portraits)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#101833;
      --card2:#0f1730;
      --text:#e9eeff;
      --muted:#b9c3ff;
      --thin: rgba(233,238,255,.12);
      --thin2: rgba(233,238,255,.08);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#86efac;
      --warn:#fde68a;
      --bad:#fca5a5;
      --shadow: 0 18px 50px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background: radial-gradient(1200px 600px at 20% 0%, rgba(125,211,252,.18), transparent 55%),
                  radial-gradient(900px 700px at 90% 20%, rgba(167,139,250,.16), transparent 50%),
                  radial-gradient(900px 700px at 60% 100%, rgba(134,239,172,.10), transparent 55%),
                  var(--bg);
      line-height:1.45;
    }

    header{
      padding: 28px 18px 16px;
      max-width: 1160px;
      margin: 0 auto;
    }
    .title{
      display:flex; gap:16px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-weight: 780;
      letter-spacing: -0.02em;
      font-size: clamp(1.35rem, 1.1rem + 1.4vw, 2.2rem);
    }
    .subtitle{
      margin:8px 0 0;
      color: var(--muted);
      max-width: 70ch;
      font-size: 1rem;
    }

    .layout{
      max-width: 1160px;
      margin: 0 auto;
      padding: 0 18px 56px;
      display:grid;
      grid-template-columns: 300px 1fr;
      gap: 18px;
      align-items:start;
    }

    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(16,24,51,.92), rgba(16,24,51,.75));
      border: 1px solid var(--thin);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
      backdrop-filter: blur(10px);
    }
    nav.toc h2{
      margin:0 0 10px;
      font-size:.95rem;
      letter-spacing:.02em;
      color: var(--muted);
      text-transform: uppercase;
    }
    nav.toc a{
      display:block;
      padding: 8px 10px;
      margin: 4px 0;
      border-radius: 12px;
      text-decoration:none;
      color: var(--text);
      border: 1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size: .95rem;
    }
    nav.toc a:hover{
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.28);
      transform: translateX(2px);
    }
    nav.toc .mini{
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px dashed var(--thin);
      color: var(--muted);
      font-size: .9rem;
    }

    main{
      display:flex;
      flex-direction:column;
      gap: 18px;
    }

    section, article{
      background: linear-gradient(180deg, rgba(16,24,51,.86), rgba(16,24,51,.72));
      border: 1px solid var(--thin);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 18px 16px;
      backdrop-filter: blur(10px);
      overflow:hidden;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap: 14px;
    }
    .grid3{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 14px;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns:1fr}
      nav.toc{position:relative; top:auto}
      .grid2, .grid3{grid-template-columns:1fr}
    }

    h2{
      margin: 0 0 10px;
      font-size: 1.28rem;
      letter-spacing: -0.01em;
    }
    h3{
      margin: 14px 0 8px;
      font-size: 1.05rem;
      color: var(--muted);
    }
    p{margin: 10px 0}
    ul{margin: 10px 0 10px 20px}
    li{margin: 6px 0}
    .muted{color: var(--muted)}
    .eq{
      font-family: var(--mono);
      background: rgba(233,238,255,.06);
      border: 1px solid var(--thin2);
      padding: 2px 6px;
      border-radius: 10px;
      white-space: nowrap;
    }
    .block-eq{
      font-family: var(--mono);
      background: rgba(233,238,255,.06);
      border: 1px solid var(--thin2);
      padding: 10px 12px;
      border-radius: 14px;
      overflow:auto;
      margin: 10px 0;
    }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
    }
    @media (max-width: 720px){
      .callouts{grid-template-columns:1fr}
    }
    .callout{
      border: 1px solid var(--thin);
      border-radius: 16px;
      padding: 12px 12px;
      background: linear-gradient(180deg, rgba(15,23,48,.9), rgba(15,23,48,.65));
    }
    .callout.good{border-color: rgba(134,239,172,.35)}
    .callout.warn{border-color: rgba(253,230,138,.35)}
    .callout.bad{border-color: rgba(252,165,165,.35)}
    .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: .88rem;
      border: 1px solid var(--thin);
      background: rgba(233,238,255,.05);
      color: var(--muted);
      margin-bottom: 8px;
    }
    .tag .dot{
      width:10px;height:10px;border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(125,211,252,.12);
    }

    .controls{
      display:flex;
      flex-wrap:wrap;
      gap: 10px 12px;
      align-items:flex-end;
      padding: 10px 12px;
      border: 1px solid var(--thin);
      border-radius: 16px;
      background: rgba(15,23,48,.7);
    }
    .controls label{
      display:flex;
      flex-direction:column;
      gap: 6px;
      font-size: .92rem;
      color: var(--muted);
      min-width: 180px;
    }
    .controls select, .controls input[type="range"], .controls button{
      font-family: var(--sans);
      border-radius: 12px;
      border: 1px solid var(--thin);
      background: rgba(233,238,255,.06);
      color: var(--text);
      padding: 8px 10px;
      outline:none;
    }
    .controls input[type="range"]{padding: 0; height: 34px}
    .controls button{
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .controls button:hover{
      transform: translateY(-1px);
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.28);
    }
    .checkbox{
      flex-direction:row !important;
      align-items:center;
      min-width:auto !important;
      gap: 10px !important;
      margin-bottom: 4px;
    }
    .checkbox input{width:18px;height:18px}

    figure{
      margin: 0;
      border-radius: 16px;
      border: 1px solid var(--thin);
      background: rgba(9,13,30,.55);
      overflow:hidden;
    }
    figcaption{
      padding: 10px 12px;
      border-top: 1px solid var(--thin);
      color: var(--muted);
      font-size: .92rem;
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
    }
    .canvasTall{height: 360px}
    .canvasShort{height: 280px}

    .copyRow{
      display:flex;
      flex-wrap:wrap;
      gap: 10px;
      align-items:center;
      margin: 10px 0 0;
    }
    .copyBtn{
      display:inline-flex;
      align-items:center;
      gap:10px;
      border: 1px solid rgba(125,211,252,.35);
      background: rgba(125,211,252,.10);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 14px;
      cursor:pointer;
      font-size:.95rem;
      user-select:none;
      transition: transform .12s ease, background .12s ease;
    }
    .copyBtn:hover{transform: translateY(-1px); background: rgba(125,211,252,.14)}
    .copyBtn:active{transform: translateY(0px)}
    .copyHint{color: var(--muted); font-size:.9rem}
    .hidden{display:none}

    .resultBox{
      border: 1px solid rgba(167,139,250,.32);
      background: rgba(167,139,250,.08);
      padding: 12px 12px;
      border-radius: 16px;
      margin-top: 10px;
    }
    .boxed{
      border: 1px solid rgba(134,239,172,.35);
      background: rgba(134,239,172,.08);
      padding: 12px 12px;
      border-radius: 16px;
      margin-top: 12px;
    }
    .boxed h3{margin-top:0;color: var(--good)}
    .small{
      font-size: .92rem;
      color: var(--muted);
    }

    footer{
      max-width: 1160px;
      margin: 0 auto;
      padding: 16px 18px 36px;
      color: var(--muted);
      font-size: .92rem;
    }

    @media print{
      nav.toc{display:none}
      body{background:#fff;color:#000}
      section, article{box-shadow:none;background:#fff;border:1px solid #bbb}
      .eq,.block-eq{background:#f3f3f3;border-color:#ddd}
      figure{background:#fff}
      .controls{display:none}
      .copyRow{display:none}
    }
  </style>
</head>
<body>
<header>
  <div class="title">
    <div>
      <h1>Nonlinear Phase-Plane Analysis (Problems 13 &amp; 14): Critical Points, Linearization, and Portrait Sketches</h1>
      <p class="subtitle">
        We analyze two planar autonomous systems by finding equilibria, using the Jacobian to classify them, computing eigenvectors,
        and building qualitative phase portraits. Interactive canvases below let you explore how the geometry changes with a parameter <span class="eq">k</span>
        (the original problems correspond to <span class="eq">k = 1</span>).
      </p>
    </div>
  </div>
</header>

<div class="layout">
  <nav class="toc" aria-label="Table of contents">
    <h2>Table of Contents</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy &amp; Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#viz">Interactive Visualizations</a>
    <div class="mini">
      <div><span class="eq">System 13</span>: x′ = x − 2y, y′ = 4x − x³</div>
      <div><span class="eq">System 14</span>: x′ = y, y′ = 2x − x²</div>
    </div>
  </nav>

  <main>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><strong>System 13:</strong> equilibria at <span class="eq">(0,0)</span> and <span class="eq">(±2, ±1)</span>.
          <span class="eq">(0,0)</span> is an <strong>unstable spiral</strong>; <span class="eq">(±2, ±1)</span> are <strong>saddles</strong> (all hyperbolic → structurally stable).</li>
        <li><strong>System 14:</strong> equilibria at <span class="eq">(0,0)</span> and <span class="eq">(2,0)</span>.
          <span class="eq">(0,0)</span> is a <strong>saddle</strong> (hyperbolic); <span class="eq">(2,0)</span> is a <strong>center</strong> in the linearization (non-hyperbolic → not structurally stable).</li>
        <li>System 14 has an <strong>energy integral</strong>:
          <span class="eq">E = ½y² − x² + (1/3)x³</span> (for the original coefficients), giving closed orbits around <span class="eq">(2,0)</span>.</li>
        <li>Eigenvectors give the <strong>stable/unstable separatrix directions</strong> at each saddle (unique local geometry).</li>
        <li>Interactive plots show nullclines, vector fields, and trajectories; you can click the phase plane to launch trajectories.</li>
      </ul>

      <div class="copyRow">
        <div class="copyBtn" data-copy-target="copyKeyEq">Copy key equations</div>
        <div class="copyBtn" data-copy-target="copyFinal">Copy final classifications</div>
        <div class="copyHint">Copies plain text to clipboard.</div>
      </div>

      <pre id="copyKeyEq" class="hidden">
System 13 (original): x' = x - 2y,  y' = 4x - x^3.
Jacobian: J(x,y) = [[1, -2], [4 - 3x^2, 0]].

System 14 (original): x' = y,  y' = 2x - x^2.
Jacobian: J(x,y) = [[0, 1], [2 - 2x, 0]].
Energy (System 14): E = (1/2) y^2 + V(x), with V(x) = -x^2 + (1/3)x^3.
      </pre>

      <pre id="copyFinal" class="hidden">
FINAL (k=1):
System 13:
Equilibria: (0,0), (2,1), (-2,-1).
(0,0): unstable spiral (focus), eigenvalues (1 ± i√31)/2, structurally stable (hyperbolic).
(±2, ±1): saddles, eigenvalues (1 ± √65)/2, structurally stable (hyperbolic).

System 14:
Equilibria: (0,0), (2,0).
(0,0): saddle, eigenvalues ±√2, structurally stable (hyperbolic).
(2,0): center in linearization, eigenvalues ± i√2, NOT structurally stable (non-hyperbolic); nonlinear system has closed orbits via conserved energy.
      </pre>
    </section>

    <article id="part1">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>Rewrite the problem (in my own words)</h3>
      <p>
        For each given planar autonomous differential-equation system, we must:
      </p>
      <ul>
        <li>(a) Find all <strong>critical points</strong> (equilibria), i.e., points where <span class="eq">x′ = 0</span> and <span class="eq">y′ = 0</span>.</li>
        <li>(b) Linearize the system at each equilibrium using the <strong>Jacobian</strong>, find eigenvalues, and classify each equilibrium by
          <strong>stability type</strong> (sink/source/saddle/center/spiral) and <strong>structural stability</strong> (hyperbolic vs non-hyperbolic).</li>
        <li>(c) Compute eigenvectors as needed and combine everything into a reasonable sketch of the <strong>phase-plane portrait</strong>.
          Decide whether more than one qualitative local portrait is possible near each equilibrium and explain why.</li>
      </ul>

      <h3>Given quantities</h3>
      <ul>
        <li><strong>System 13:</strong> <span class="eq">x′ = x − 2y</span>, <span class="eq">y′ = 4x − x³</span>.</li>
        <li><strong>System 14:</strong> <span class="eq">x′ = y</span>, <span class="eq">y′ = 2x − x²</span>.</li>
      </ul>
      <p class="muted">
        For interactive plotting, we will also use a parameterized form with <span class="eq">k</span> multiplying the nonlinear term:
        System 13: <span class="eq">y′ = 4x − kx³</span>, System 14: <span class="eq">y′ = 2x − kx²</span>.
        The original problems correspond to <span class="eq">k = 1</span>.
      </p>

      <h3>Unknowns and what must be found</h3>
      <ul>
        <li>Unknowns: equilibrium locations <span class="eq">(x*, y*)</span>, eigenvalues <span class="eq">λ</span>, eigenvectors <span class="eq">v</span>, qualitative trajectories.</li>
        <li>We must find: all equilibria and classify each by linearization and structural stability, then produce a coherent phase portrait sketch.</li>
      </ul>

      <h3>Relevant principles/laws and why they apply</h3>
      <div class="callouts">
        <div class="callout good">
          <div class="tag"><span class="dot"></span> Linearization principle</div>
          <p>
            Near an equilibrium, a smooth nonlinear system is approximated by its linearization
            <span class="eq">u′ = Ju</span>, where <span class="eq">J</span> is the Jacobian at the equilibrium.
            If the equilibrium is <strong>hyperbolic</strong> (no eigenvalues with zero real part), the nonlinear and linear phase portraits are locally topologically equivalent.
          </p>
        </div>
        <div class="callout warn">
          <div class="tag"><span class="dot" style="background:var(--warn)"></span> Structural stability</div>
          <p>
            Hyperbolic equilibria are <strong>structurally stable</strong> under small perturbations (their qualitative type persists).
            Non-hyperbolic cases (e.g., centers, repeated/zero-real-part eigenvalues) can change type under tiny changes, so linearization alone may be inconclusive.
          </p>
        </div>
      </div>

      <h3>2–3 possible approaches</h3>
      <ol>
        <li><strong>Direct equilibrium + Jacobian eigenanalysis:</strong> fastest, standard for planar systems; gives type and eigenvector directions.</li>
        <li><strong>Nullcline geometry:</strong> sketch <span class="eq">x′=0</span> and <span class="eq">y′=0</span>; their intersections are equilibria; vector directions follow sign regions.</li>
        <li><strong>First integral / energy method (when available):</strong> for System 14, the form <span class="eq">x′=y</span> suggests a second-order conservative ODE and an energy integral.</li>
      </ol>

      <h3>Chosen best approach (and why)</h3>
      <p>
        We will use <strong>equilibria + Jacobian eigenanalysis</strong> for both systems (required by the prompt), supplemented by
        <strong>nullclines</strong> for global sketching. For System 14, we will additionally use an <strong>energy integral</strong> to resolve the non-hyperbolic center and to sketch the separatrix.
      </p>
    </article>

    <article id="part2">
      <h2>PART 2 — Strategy &amp; Tips (roadmap only)</h2>

      <h3>Minimal step-by-step plan (5–10 steps)</h3>
      <ol>
        <li><strong>Find equilibria:</strong> solve <span class="eq">x′=0</span>, <span class="eq">y′=0</span> simultaneously.</li>
        <li><strong>Compute Jacobian:</strong> <span class="eq">J = ∂(x′,y′)/∂(x,y)</span>.</li>
        <li><strong>Evaluate J at each equilibrium:</strong> obtain constant matrices <span class="eq">J*</span>.</li>
        <li><strong>Eigenvalues:</strong> solve <span class="eq">det(J* − λI)=0</span>.</li>
        <li><strong>Classify stability:</strong> use eigenvalue real parts (saddle if opposite signs; spiral/source/sink if complex with Re≷0; center if purely imaginary).</li>
        <li><strong>Structural stability:</strong> hyperbolic iff no eigenvalues with zero real part.</li>
        <li><strong>Eigenvectors:</strong> for saddles and nodes, compute eigenvectors to draw invariant directions (separatrices).</li>
        <li><strong>Global sketch:</strong> draw nullclines, equilibria, local behaviors, and connect separatrices consistently.</li>
        <li><strong>Non-hyperbolic check (System 14):</strong> use energy integral to confirm closed orbits and separatrix shape.</li>
      </ol>

      <h3>Common mistakes &amp; quick tips</h3>
      <div class="callouts">
        <div class="callout bad">
          <div class="tag"><span class="dot" style="background:var(--bad)"></span> Mistake to avoid</div>
          <ul>
            <li>Calling a point a “center” just because eigenvalues are imaginary, without checking nonlinear terms or conserved quantities.</li>
            <li>Forgetting that structural stability is about <strong>hyperbolicity</strong>, not about “stable/unstable” alone.</li>
            <li>Mixing up nullclines: <span class="eq">x′=0</span> vs <span class="eq">y′=0</span>; always label them.</li>
          </ul>
        </div>
        <div class="callout good">
          <div class="tag"><span class="dot"></span> Fast checks</div>
          <ul>
            <li><strong>Saddle test:</strong> determinant <span class="eq">det(J*) &lt; 0</span> ⇒ eigenvalues have opposite signs ⇒ saddle.</li>
            <li><strong>Spiral test:</strong> trace <span class="eq">tr(J*)</span> gives sign of real part when eigenvalues are complex.</li>
            <li>Draw eigenvectors for saddles first—these anchor the whole phase portrait.</li>
          </ul>
        </div>
      </div>
    </article>

    <article id="part3">
      <h2>PART 3 — Full Solution</h2>

      <section>
        <h3>Physical intuition (why the portraits look the way they do)</h3>
        <p>
          Even though these are “math” systems, a physics intuition helps:
        </p>
        <ul>
          <li><strong>System 13</strong> has linear coupling <span class="eq">x′ = x − 2y</span> (a shear/tilt) plus a nonlinear restoring/anti-restoring term in <span class="eq">y′</span> due to <span class="eq">−x³</span>. This creates one equilibrium near the origin with a rotating tendency (complex eigenvalues) and additional equilibria where the cubic balances the linear term (leading to saddles).</li>
          <li><strong>System 14</strong> has the canonical form <span class="eq">x′ = y</span>, i.e. “velocity,” and <span class="eq">y′</span> depends only on <span class="eq">x</span>, i.e. “acceleration.” This is exactly a 1D conservative mechanical system <span class="eq">x″ = 2x − x²</span>, so it possesses an energy integral and phase curves are energy level sets.</li>
        </ul>
      </section>

      <section class="grid2">
        <div>
          <h3>Problem 13: x′ = x − 2y,  y′ = 4x − x³</h3>

          <h3>(a) Critical points</h3>
          <p>
            Set <span class="eq">x′=0</span> and <span class="eq">y′=0</span>.
          </p>
          <div class="block-eq">
            x′ = x − 2y = 0  ⇒  y = x/2. <br/>
            y′ = 4x − x³ = x(4 − x²) = 0  ⇒  x = 0, ±2.
          </div>
          <p>Thus equilibria are:</p>
          <ul>
            <li><span class="eq">(0,0)</span></li>
            <li><span class="eq">(2,1)</span></li>
            <li><span class="eq">(−2,−1)</span></li>
          </ul>

          <h3>(b) Jacobian, eigenvalues, classification, structural stability</h3>
          <p>Compute the Jacobian <span class="eq">J = ∂(x′,y′)/∂(x,y)</span>:</p>
          <div class="block-eq">
            x′ = x − 2y  ⇒  ∂x′/∂x = 1,  ∂x′/∂y = −2 <br/>
            y′ = 4x − x³ ⇒  ∂y′/∂x = 4 − 3x²,  ∂y′/∂y = 0 <br/><br/>
            J(x,y) = [[1, −2], [4 − 3x², 0]]
          </div>

          <h3>Equilibrium (0,0)</h3>
          <div class="block-eq">
            J(0,0) = [[1, −2],[4, 0]].
            Characteristic polynomial: det(J − λI) = det([[1−λ, −2],[4, −λ]])<br/>
            = (1−λ)(−λ) − (−2)(4) = −λ(1−λ) + 8 = λ² − λ + 8.
          </div>
          <p>
            Solve <span class="eq">λ² − λ + 8 = 0</span>:
            discriminant <span class="eq">Δ = (−1)² − 32 = −31</span>,
            so
            <span class="eq">λ = (1 ± i√31)/2</span>.
          </p>
          <div class="resultBox">
            <p><strong>Type:</strong> complex with <span class="eq">Re(λ)=1/2&gt;0</span> ⇒ <strong>unstable spiral (source focus)</strong>.</p>
            <p><strong>Structural stability:</strong> hyperbolic (no zero real parts) ⇒ <strong>structurally stable</strong>.</p>
          </div>

          <h3>Equilibria (2,1) and (−2,−1)</h3>
          <p>At <span class="eq">x=±2</span>, compute <span class="eq">4 − 3x² = 4 − 12 = −8</span>:</p>
          <div class="block-eq">
            J(±2, ±1) = [[1, −2], [−8, 0]].
            det(J − λI) = det([[1−λ, −2], [−8, −λ]])<br/>
            = (1−λ)(−λ) − (−2)(−8) = −λ(1−λ) − 16 = λ² − λ − 16.
          </div>
          <p>
            Solve <span class="eq">λ² − λ − 16 = 0</span>:
            <span class="eq">λ = (1 ± √65)/2</span>.
            One eigenvalue is positive, the other negative.
          </p>
          <div class="resultBox">
            <p><strong>Type:</strong> opposite-sign eigenvalues ⇒ <strong>saddle</strong> (unstable overall).</p>
            <p><strong>Structural stability:</strong> hyperbolic ⇒ <strong>structurally stable</strong>.</p>
          </div>

          <h3>(c) Eigenvectors and portrait sketch logic</h3>
          <p>
            For a saddle, eigenvectors give the invariant stable/unstable directions. For
            <span class="eq">J = [[1, −2], [−8, 0]]</span>, an eigenvector <span class="eq">v = (v₁, v₂)</span> satisfies:
          </p>
          <div class="block-eq">
            (1−λ)v₁ − 2v₂ = 0  ⇒  v₂ = (1−λ)/2 · v₁.
          </div>
          <p>
            So for each eigenvalue <span class="eq">λ</span>, you can take <span class="eq">v₁=1</span> and
            <span class="eq">v = (1, (1−λ)/2)</span>.
            The eigenvector corresponding to <span class="eq">λ&lt;0</span> is the <strong>stable</strong> separatrix direction;
            the one for <span class="eq">λ&gt;0</span> is the <strong>unstable</strong> separatrix direction.
          </p>

          <div class="boxed">
            <h3>System 13 final (boxed)</h3>
            <p><strong>Equilibria:</strong> <span class="eq">(0,0)</span>, <span class="eq">(2,1)</span>, <span class="eq">(−2,−1)</span>.</p>
            <p><strong>(0,0):</strong> unstable spiral (eigs <span class="eq">(1 ± i√31)/2</span>), structurally stable.</p>
            <p><strong>(±2,±1):</strong> saddles (eigs <span class="eq">(1 ± √65)/2</span>), structurally stable; eigenvectors
              <span class="eq">v = (1, (1−λ)/2)</span>.</p>
          </div>

          <h3>Is there more than one possible local portrait near each critical point?</h3>
          <p>
            For System 13, <em>no</em> (up to topological equivalence), because all equilibria are <strong>hyperbolic</strong>.
            The Hartman–Grobman theorem guarantees the nonlinear flow near each equilibrium is qualitatively the same as the linearized flow.
            So the spiral-out behavior at the origin and saddle behavior at <span class="eq">(±2,±1)</span> are locally unique.
          </p>
        </div>

        <div>
          <h3>Problem 14: x′ = y,  y′ = 2x − x²</h3>

          <h3>(a) Critical points</h3>
          <p>Set <span class="eq">x′=0</span> and <span class="eq">y′=0</span>:</p>
          <div class="block-eq">
            x′ = y = 0  ⇒  y = 0. <br/>
            y′ = 2x − x² = x(2 − x) = 0  ⇒  x = 0, 2.
          </div>
          <p>Equilibria:</p>
          <ul>
            <li><span class="eq">(0,0)</span></li>
            <li><span class="eq">(2,0)</span></li>
          </ul>

          <h3>(b) Jacobian, eigenvalues, classification, structural stability</h3>
          <p>Jacobian:</p>
          <div class="block-eq">
            x′ = y  ⇒  ∂x′/∂x = 0,  ∂x′/∂y = 1 <br/>
            y′ = 2x − x² ⇒ ∂y′/∂x = 2 − 2x,  ∂y′/∂y = 0 <br/><br/>
            J(x,y) = [[0, 1],[2 − 2x, 0]]
          </div>

          <h3>Equilibrium (0,0)</h3>
          <div class="block-eq">
            J(0,0) = [[0,1],[2,0]].
            det(J − λI) = det([[-λ,1],[2,−λ]]) = λ² − 2.
          </div>
          <p>So <span class="eq">λ = ±√2</span> (real, opposite signs).</p>
          <div class="resultBox">
            <p><strong>Type:</strong> <strong>saddle</strong>.</p>
            <p><strong>Structural stability:</strong> hyperbolic ⇒ <strong>structurally stable</strong>.</p>
          </div>

          <h3>Equilibrium (2,0)</h3>
          <div class="block-eq">
            J(2,0) = [[0,1],[−2,0]].
            det(J − λI) = det([[-λ,1],[−2,−λ]]) = λ² + 2.
          </div>
          <p>So <span class="eq">λ = ± i√2</span> (purely imaginary).</p>
          <div class="resultBox">
            <p><strong>Linearized type:</strong> <strong>center</strong> (closed ellipses in the linear system).</p>
            <p><strong>Structural stability:</strong> <strong>not</strong> structurally stable (non-hyperbolic).</p>
          </div>

          <h3>Extra (needed here): nonlinear check via energy integral</h3>
          <p>
            Since <span class="eq">x′ = y</span>, we have <span class="eq">x″ = y′ = 2x − x²</span>.
            This is a conservative “particle” moving in a potential <span class="eq">V(x)</span> defined by:
          </p>
          <div class="block-eq">
            x″ = - dV/dx  ⇒  dV/dx = -(2x − x²) = -2x + x².
            Integrate:  V(x) = -x² + (1/3)x³ + C.
          </div>
          <p>Choose <span class="eq">C=0</span>. Then the conserved energy is:</p>
          <div class="block-eq">
            E = (1/2) y² + V(x) = (1/2) y² - x² + (1/3)x³ = constant along trajectories.
          </div>
          <p>
            Equilibria correspond to <span class="eq">V′(x)=0</span> ⇒ <span class="eq">x=0,2</span>.
            Check curvature: <span class="eq">V″(x)= -2 + 2x</span>, so
            <span class="eq">V″(0)=-2&lt;0</span> (unstable peak ⇒ saddle) and <span class="eq">V″(2)=2&gt;0</span> (stable well ⇒ center).
          </p>

          <h3>(c) Eigenvectors and portrait sketch logic</h3>
          <p><strong>Saddle at (0,0):</strong> For <span class="eq">J(0,0)</span> with eigenvalues <span class="eq">±√2</span>, eigenvectors satisfy:</p>
          <div class="block-eq">
            [[-λ, 1],[2, -λ]] v = 0  ⇒  -λ v₁ + v₂ = 0  ⇒  v₂ = λ v₁.
          </div>
          <p>
            So take <span class="eq">v = (1, λ)</span>. The <span class="eq">λ=+√2</span> direction is unstable,
            and <span class="eq">λ=-√2</span> direction is stable (the separatrices).
          </p>
          <p>
            <strong>Center at (2,0):</strong> eigenvectors are complex; the energy integral shows nearby trajectories are closed loops (periodic orbits).
          </p>

          <div class="boxed">
            <h3>System 14 final (boxed)</h3>
            <p><strong>Equilibria:</strong> <span class="eq">(0,0)</span>, <span class="eq">(2,0)</span>.</p>
            <p><strong>(0,0):</strong> saddle (eigs <span class="eq">±√2</span>), structurally stable; eigenvectors <span class="eq">(1, ±√2)</span>.</p>
            <p><strong>(2,0):</strong> center in linearization (eigs <span class="eq">± i√2</span>), <strong>not</strong> structurally stable; nonlinear system has closed orbits because
              <span class="eq">E = ½y² − x² + (1/3)x³</span> is conserved.</p>
          </div>

          <h3>Is there more than one possible local portrait near each critical point?</h3>
          <p>
            Near <span class="eq">(0,0)</span> (hyperbolic saddle), the portrait is locally unique (linearization decides).
            Near <span class="eq">(2,0)</span>, the equilibrium is <strong>non-hyperbolic</strong> (purely imaginary eigenvalues), so linearization alone does not guarantee uniqueness.
            Indeed, a tiny perturbation like adding small damping (e.g., <span class="eq">x′=y</span>, <span class="eq">y′=2x−x²−εy</span>) would turn the center into a spiral sink/source.
            That is why the center is <strong>not structurally stable</strong>.
          </p>
        </div>
      </section>

      <section>
        <h3>Sanity checks (units, limiting cases, interpretation)</h3>
        <ul>
          <li><strong>Units:</strong> None are specified; these systems are dimensionless. In the interactive plots we also use dimensionless <span class="eq">k</span>.</li>
          <li><strong>Limiting behavior (System 13):</strong> for small <span class="eq">x</span>, the system is approximately linear and shows spiral-out behavior consistent with <span class="eq">Re(λ)=1/2&gt;0</span>.</li>
          <li><strong>Limiting behavior (System 14):</strong> near <span class="eq">x=2</span>, expand <span class="eq">x = 2 + ξ</span>:
            <span class="eq">y′ = 2(2+ξ) − (2+ξ)² = -2ξ - ξ²</span> so for small <span class="eq">ξ</span>, <span class="eq">ξ″ ≈ -2ξ</span>, a harmonic oscillator ⇒ closed orbits.</li>
          <li><strong>Physical interpretation (System 14):</strong> motion in a cubic potential; the saddle at the potential “hilltop” has a separatrix (energy level through the saddle),
            and the center at the well bottom has periodic motion.</li>
        </ul>
      </section>
    </article>

    <section id="viz">
      <h2>Interactive Visualizations</h2>
      <p class="muted">
        The original problems have no free parameters; the plots introduce a <strong>demo parameter</strong> <span class="eq">k</span> multiplying the nonlinear term
        (<span class="eq">−kx³</span> or <span class="eq">−kx²</span>) to let you explore how equilibria and stability change.
        Set <span class="eq">k = 1</span> to match the problems exactly.
      </p>

      <div class="controls" role="group" aria-label="Interactive controls">
        <label>
          Choose system
          <select id="sysSel">
            <option value="13">System 13: x′=x−2y, y′=4x−k x³</option>
            <option value="14">System 14: x′=y, y′=2x−k x²</option>
          </select>
        </label>
        <label>
          Nonlinearity strength k (dimensionless)
          <input id="kSlider" type="range" min="0.20" max="3.00" step="0.01" value="1.00"/>
          <div class="small">k = <span id="kVal">1.00</span> (problem uses k=1)</div>
        </label>
        <label class="checkbox">
          <input id="vfToggle" type="checkbox" checked />
          show vector field
        </label>
        <label class="checkbox">
          <input id="nullToggle" type="checkbox" checked />
          show nullclines
        </label>
        <button id="clearBtn" type="button">Clear trajectories</button>
      </div>

      <div class="grid3" style="margin-top:12px">
        <figure>
          <canvas id="cDiagram" class="canvasShort" aria-label="Diagram canvas"></canvas>
          <figcaption>
            <strong>Diagram:</strong> Phase-plane geometry—axes, nullclines, and equilibria (labeled). This is the “setup diagram” for the dynamical system.
          </figcaption>
        </figure>
        <figure>
          <canvas id="cMain" class="canvasShort" aria-label="Main quantitative plot"></canvas>
          <figcaption>
            <strong>Main quantitative plot:</strong> Eigenvalue real parts vs <span class="eq">k</span> (stability indicator).
          </figcaption>
        </figure>
        <figure>
          <canvas id="cSecondary" class="canvasShort" aria-label="Secondary plot"></canvas>
          <figcaption>
            <strong>Secondary plot:</strong> System 14 shows potential <span class="eq">V(x)</span> vs <span class="eq">x</span>; System 13 shows nullcline function shapes.
          </figcaption>
        </figure>
      </div>

      <figure style="margin-top:14px">
        <canvas id="cPhase" class="canvasTall" aria-label="Phase portrait canvas"></canvas>
        <figcaption>
          <strong>Phase portrait:</strong> vector field + nullclines + trajectories. <strong>Click</strong> the plot to launch a trajectory from that initial condition.
          (Trajectories are computed with RK4 forward and backward in time.)
        </figcaption>
      </figure>

      <div class="resultBox" id="readout">
        <strong>Live readout (based on current k):</strong>
        <div class="small" id="readoutText">—</div>
      </div>

      <p class="small">
        Plot axes are dimensionless. The phase-plane window auto-scales by system. On high-DPI screens the canvases render crisply.
      </p>
    </section>
  </main>
</div>

<footer>
  <p>
    Tip: For your homework/quiz write-up, you can keep the analysis symbolic and then substitute <span class="eq">k=1</span> (the original problems).
    The interactive parameter is only for intuition and visualization.
  </p>
</footer>

<script>
/* ---------------------------
   Utility: copying
---------------------------- */
(function setupCopy(){
  const buttons = document.querySelectorAll('.copyBtn');
  buttons.forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const id = btn.getAttribute('data-copy-target');
      const el = document.getElementById(id);
      if(!el) return;
      const text = el.textContent.trim();
      try{
        await navigator.clipboard.writeText(text);
        const old = btn.textContent;
        btn.textContent = 'Copied ✓';
        setTimeout(()=>btn.textContent = old, 900);
      }catch(e){
        // fallback
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        try{ document.execCommand('copy'); }catch(_){}
        document.body.removeChild(ta);
        const old = btn.textContent;
        btn.textContent = 'Copied ✓';
        setTimeout(()=>btn.textContent = old, 900);
      }
    });
  });
})();

/* ---------------------------
   Canvas plotting helpers
---------------------------- */
function getDPR(ctx){
  return Math.max(1, Math.floor(window.devicePixelRatio || 1));
}
function resizeCanvas(canvas, heightCSS){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(10, rect.width);
  const h = heightCSS ?? rect.height;
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return {ctx, w, h, dpr};
}
function clear(ctx, w, h){
  ctx.clearRect(0,0,w,h);
}
function lerp(a,b,t){return a+(b-a)*t;}
function clamp(x,a,b){return Math.max(a, Math.min(b,x));}

/* Axis mapping: world -> screen */
function makeView(w, h, xmin, xmax, ymin, ymax, pad=38){
  const vx = {xmin, xmax, ymin, ymax, pad};
  vx.xToS = x => pad + (x - xmin) * (w - 2*pad) / (xmax - xmin);
  vx.yToS = y => h - pad - (y - ymin) * (h - 2*pad) / (ymax - ymin);
  vx.sToX = sx => xmin + (sx - pad) * (xmax - xmin) / (w - 2*pad);
  vx.sToY = sy => ymin + (h - pad - sy) * (ymax - ymin) / (h - 2*pad);
  return vx;
}
function drawGridAxes(ctx, view, title, xlabel, ylabel){
  const {pad, xmin, xmax, ymin, ymax} = view;
  const w = ctx.canvas.width / (window.devicePixelRatio||1);
  const h = ctx.canvas.height / (window.devicePixelRatio||1);

  // background
  ctx.save();
  ctx.fillStyle = 'rgba(9,13,30,.35)';
  ctx.fillRect(0,0,w,h);
  ctx.restore();

  // grid
  ctx.save();
  ctx.strokeStyle = 'rgba(233,238,255,.08)';
  ctx.lineWidth = 1;

  const nTicks = 6;
  for(let i=0;i<=nTicks;i++){
    const tx = lerp(xmin, xmax, i/nTicks);
    const sx = view.xToS(tx);
    ctx.beginPath(); ctx.moveTo(sx, pad); ctx.lineTo(sx, h-pad); ctx.stroke();
  }
  for(let j=0;j<=nTicks;j++){
    const ty = lerp(ymin, ymax, j/nTicks);
    const sy = view.yToS(ty);
    ctx.beginPath(); ctx.moveTo(pad, sy); ctx.lineTo(w-pad, sy); ctx.stroke();
  }
  ctx.restore();

  // axes box
  ctx.save();
  ctx.strokeStyle = 'rgba(233,238,255,.16)';
  ctx.lineWidth = 1.2;
  ctx.strokeRect(pad, pad, w-2*pad, h-2*pad);
  ctx.restore();

  // ticks + labels
  ctx.save();
  ctx.fillStyle = 'rgba(233,238,255,.85)';
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for(let i=0;i<=nTicks;i++){
    const tx = lerp(xmin, xmax, i/nTicks);
    const sx = view.xToS(tx);
    ctx.fillText(tx.toFixed(1), sx, h-pad+8);
  }
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for(let j=0;j<=nTicks;j++){
    const ty = lerp(ymin, ymax, j/nTicks);
    const sy = view.yToS(ty);
    ctx.fillText(ty.toFixed(1), pad-8, sy);
  }

  // title
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.font = '13px ui-sans-serif, system-ui';
  ctx.fillStyle = 'rgba(233,238,255,.95)';
  ctx.fillText(title, pad, 10);

  // axis labels
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillStyle = 'rgba(185,195,255,.92)';
  ctx.textAlign = 'center';
  ctx.fillText(xlabel, pad + (w-2*pad)/2, h-18);

  ctx.save();
  ctx.translate(14, pad + (h-2*pad)/2);
  ctx.rotate(-Math.PI/2);
  ctx.textAlign = 'center';
  ctx.fillText(ylabel, 0, 0);
  ctx.restore();

  ctx.restore();
}
function drawLegend(ctx, items){
  const w = ctx.canvas.width / (window.devicePixelRatio||1);
  const x0 = 18, y0 = 38;
  ctx.save();
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  let y=y0;
  items.forEach(it=>{
    ctx.fillStyle = it.color;
    ctx.fillRect(x0, y-6, 18, 3);
    ctx.fillStyle = 'rgba(233,238,255,.9)';
    ctx.fillText(it.label, x0+26, y-4);
    y += 18;
  });
  ctx.restore();
}
function drawPoint(ctx, view, x, y, color, r=4){
  ctx.save();
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(view.xToS(x), view.yToS(y), r, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}
function drawText(ctx, x, y, text, color='rgba(233,238,255,.9)'){
  ctx.save();
  ctx.fillStyle = color;
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillText(text, x, y);
  ctx.restore();
}

/* ---------------------------
   Systems, Jacobians, equilibria
---------------------------- */
function f13(x,y,k){ // x' , y'
  return {dx: x - 2*y, dy: 4*x - k*x*x*x};
}
function J13(x,k){
  // [[1,-2],[4-3k x^2, 0]]
  return [[1, -2],[4 - 3*k*x*x, 0]];
}
function eq13(k){
  const a = 2/Math.sqrt(k);
  return [
    {x:0, y:0, name:'E0'},
    {x:a, y:a/2, name:'E+'},
    {x:-a, y:-a/2, name:'E-'}
  ];
}

function f14(x,y,k){
  return {dx: y, dy: 2*x - k*x*x};
}
function J14(x,k){
  // [[0,1],[2-2k x, 0]]
  return [[0,1],[2 - 2*k*x, 0]];
}
function eq14(k){
  return [
    {x:0, y:0, name:'E0'},
    {x:2/k, y:0, name:'E1'}
  ];
}

/* eigenvalues for 2x2 matrix */
function eig2(A){
  const a=A[0][0], b=A[0][1], c=A[1][0], d=A[1][1];
  const tr = a+d;
  const det = a*d - b*c;
  const disc = tr*tr - 4*det;
  if(disc >= 0){
    const s = Math.sqrt(disc);
    return [{re:(tr+s)/2, im:0},{re:(tr-s)/2, im:0}];
  }else{
    const s = Math.sqrt(-disc);
    return [{re:tr/2, im:s/2},{re:tr/2, im:-s/2}];
  }
}
function classifyFromEig(eigs){
  // simple planar classification
  const [l1,l2]=eigs;
  const tol=1e-10;
  const isComplex = (Math.abs(l1.im)>tol || Math.abs(l2.im)>tol);
  if(isComplex){
    const re = l1.re;
    if(Math.abs(re)<1e-6) return {type:'center (linearized)', stability:'neutral', structural:'non-hyperbolic'};
    return {type: re>0 ? 'unstable spiral (focus)' : 'stable spiral (focus)', stability: re>0 ? 'unstable' : 'stable', structural:'hyperbolic'};
  }else{
    const s1=l1.re, s2=l2.re;
    if(s1*s2<0) return {type:'saddle', stability:'unstable', structural:'hyperbolic'};
    if(s1>0 && s2>0) return {type:'unstable node', stability:'unstable', structural:'hyperbolic'};
    if(s1<0 && s2<0) return {type:'stable node', stability:'stable', structural:'hyperbolic'};
    if(Math.abs(s1)<1e-6 || Math.abs(s2)<1e-6) return {type:'degenerate (linear test inconclusive)', stability:'depends', structural:'non-hyperbolic'};
    return {type:'node', stability:'depends', structural:'hyperbolic'};
  }
}

/* eigenvector for real eigenvalue (2x2), returns normalized */
function eigenvector(A, lambda){
  const a=A[0][0], b=A[0][1], c=A[1][0], d=A[1][1];
  // Solve (A - λI)v = 0. Pick the larger row to avoid tiny numbers.
  const r1 = [a-lambda, b];
  const r2 = [c, d-lambda];
  let v;
  if(Math.abs(r1[0]) + Math.abs(r1[1]) > Math.abs(r2[0]) + Math.abs(r2[1])){
    // r1·v=0 -> (a-λ)v1 + b v2 = 0
    if(Math.abs(b) > 1e-12) v = [1, -(a-lambda)/b];
    else v = [0,1];
  }else{
    if(Math.abs(d-lambda) > 1e-12) v = [-(d-lambda)/c, 1];
    else v = [1,0];
  }
  const n = Math.hypot(v[0],v[1]) || 1;
  return [v[0]/n, v[1]/n];
}

/* ---------------------------
   Trajectory integration (RK4)
---------------------------- */
function rk4Step(f, x, y, dt, k){
  const k1 = f(x,y,k);
  const k2 = f(x + 0.5*dt*k1.dx, y + 0.5*dt*k1.dy, k);
  const k3 = f(x + 0.5*dt*k2.dx, y + 0.5*dt*k2.dy, k);
  const k4 = f(x + dt*k3.dx, y + dt*k3.dy, k);
  const xn = x + (dt/6)*(k1.dx + 2*k2.dx + 2*k3.dx + k4.dx);
  const yn = y + (dt/6)*(k1.dy + 2*k2.dy + 2*k3.dy + k4.dy);
  return [xn, yn];
}
function integrateTrajectory(f, x0, y0, k, dt, steps, bounds){
  const pts=[];
  let x=x0, y=y0;
  for(let i=0;i<steps;i++){
    pts.push([x,y]);
    [x,y] = rk4Step(f,x,y,dt,k);
    if(x<bounds.xmin-2 || x>bounds.xmax+2 || y<bounds.ymin-2 || y>bounds.ymax+2) break;
  }
  return pts;
}

/* ---------------------------
   Rendering: nullclines & vector field
---------------------------- */
function drawNullclines(ctx, view, sys, k){
  ctx.save();
  ctx.lineWidth = 2;
  // x' = 0 nullcline (blue)
  ctx.strokeStyle = 'rgba(125,211,252,.9)';
  ctx.beginPath();
  if(sys===13){
    // x - 2y = 0 => y=x/2
    for(let i=0;i<=240;i++){
      const x = lerp(view.xmin, view.xmax, i/240);
      const y = x/2;
      const sx = view.xToS(x), sy=view.yToS(y);
      if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);
    }
  }else{
    // y = 0
    const y=0;
    ctx.moveTo(view.xToS(view.xmin), view.yToS(y));
    ctx.lineTo(view.xToS(view.xmax), view.yToS(y));
  }
  ctx.stroke();

  // y' = 0 nullcline (purple)
  ctx.strokeStyle = 'rgba(167,139,250,.9)';
  ctx.beginPath();
  if(sys===13){
    // 4x - k x^3 = 0 => x=0, ±2/sqrt(k) : vertical lines
    const xs = [0, 2/Math.sqrt(k), -2/Math.sqrt(k)];
    xs.forEach((xv, idx)=>{
      if(!isFinite(xv)) return;
      ctx.moveTo(view.xToS(xv), view.yToS(view.ymin));
      ctx.lineTo(view.xToS(xv), view.yToS(view.ymax));
    });
  }else{
    // 2x - kx^2 = 0 => x=0 and x=2/k
    const xs=[0, 2/k];
    xs.forEach(xv=>{
      ctx.moveTo(view.xToS(xv), view.yToS(view.ymin));
      ctx.lineTo(view.xToS(xv), view.yToS(view.ymax));
    });
  }
  ctx.stroke();
  ctx.restore();
}

function drawVectorField(ctx, view, sys, k){
  const w = ctx.canvas.width / (window.devicePixelRatio||1);
  const h = ctx.canvas.height / (window.devicePixelRatio||1);
  const pad=view.pad;
  const nx=17, ny=13;
  ctx.save();
  ctx.strokeStyle = 'rgba(233,238,255,.20)';
  ctx.lineWidth = 1;

  for(let j=0;j<ny;j++){
    for(let i=0;i<nx;i++){
      const sx = lerp(pad, w-pad, (i+0.5)/nx);
      const sy = lerp(pad, h-pad, (j+0.5)/ny);
      const x = view.sToX(sx);
      const y = view.sToY(sy);
      const v = (sys===13) ? f13(x,y,k) : f14(x,y,k);
      const mag = Math.hypot(v.dx, v.dy) || 1e-9;
      // normalize and scale
      const L = 14;
      const ux = v.dx/mag, uy = v.dy/mag;
      const ex = sx + L*ux, ey = sy - L*uy; // screen y inverted
      // small segment + arrow head
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(ex, ey);
      ctx.stroke();

      const ah = 4;
      const ang = Math.atan2(-(ey-sy), (ex-sx)); // in screen coords
      const a1 = ang + 2.6;
      const a2 = ang - 2.6;
      ctx.beginPath();
      ctx.moveTo(ex, ey);
      ctx.lineTo(ex + ah*Math.cos(a1), ey - ah*Math.sin(a1));
      ctx.moveTo(ex, ey);
      ctx.lineTo(ex + ah*Math.cos(a2), ey - ah*Math.sin(a2));
      ctx.stroke();
    }
  }
  ctx.restore();
}

function drawTrajectory(ctx, view, pts, color='rgba(134,239,172,.9)'){
  if(pts.length<2) return;
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<pts.length;i++){
    const [x,y]=pts[i];
    const sx=view.xToS(x), sy=view.yToS(y);
    if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);
  }
  ctx.stroke();
  ctx.restore();
}

/* ---------------------------
   Main plot: eigenvalue real parts vs k
---------------------------- */
function sampleEigenRealParts(sys, kMin, kMax, n=160){
  const rows=[];
  for(let i=0;i<n;i++){
    const k = lerp(kMin,kMax,i/(n-1));
    const eqs = (sys===13)? eq13(k) : eq14(k);
    eqs.forEach((e, idx)=>{
      const A = (sys===13)? J13(e.x,k) : J14(e.x,k);
      const eigs = eig2(A);
      // store two real parts
      rows.push({k, label:`${e.name}: Re(λ1)`, val:eigs[0].re, which: 0, idx});
      rows.push({k, label:`${e.name}: Re(λ2)`, val:eigs[1].re, which: 1, idx});
    });
  }
  return rows;
}
function drawMainPlot(ctx, sys, kNow){
  const {w,h} = (()=>{const dpr=window.devicePixelRatio||1; return {w:ctx.canvas.width/dpr, h:ctx.canvas.height/dpr};})();
  const kMin=0.2, kMax=3.0;
  // determine y-range by sampling
  const data = sampleEigenRealParts(sys, kMin, kMax, 140);
  let ymin=1e9, ymax=-1e9;
  data.forEach(d=>{ymin=Math.min(ymin,d.val); ymax=Math.max(ymax,d.val);});
  const padY = 0.15*(ymax-ymin || 1);
  ymin -= padY; ymax += padY;

  const view = makeView(w,h, kMin,kMax, ymin,ymax, 42);
  drawGridAxes(ctx, view, "Eigenvalue real parts vs k (stability indicator)", "k (dimensionless)", "Re(λ) (1/time)");

  // plot lines (group by label)
  const groups = new Map();
  data.forEach(d=>{
    if(!groups.has(d.label)) groups.set(d.label, []);
    groups.get(d.label).push(d);
  });

  const colors = [
    'rgba(125,211,252,.95)','rgba(167,139,250,.95)','rgba(134,239,172,.95)',
    'rgba(253,230,138,.95)','rgba(252,165,165,.95)','rgba(185,195,255,.95)'
  ];

  let gi=0;
  const legendItems=[];
  for(const [label, arr] of groups.entries()){
    // keep legend small: only show first 6
    const color = colors[gi % colors.length];
    gi++;
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.7;
    ctx.beginPath();
    arr.forEach((d, i)=>{
      const sx = view.xToS(d.k);
      const sy = view.yToS(d.val);
      if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);
    });
    ctx.stroke();
    ctx.restore();
    if(legendItems.length<6) legendItems.push({label, color});
  }

  // zero line
  ctx.save();
  ctx.strokeStyle = 'rgba(233,238,255,.35)';
  ctx.setLineDash([5,5]);
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(view.xToS(kMin), view.yToS(0));
  ctx.lineTo(view.xToS(kMax), view.yToS(0));
  ctx.stroke();
  ctx.restore();

  // vertical marker at kNow
  ctx.save();
  ctx.strokeStyle = 'rgba(233,238,255,.55)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(view.xToS(kNow), view.yToS(ymin));
  ctx.lineTo(view.xToS(kNow), view.yToS(ymax));
  ctx.stroke();
  ctx.restore();

  drawLegend(ctx, legendItems);
}

/* ---------------------------
   Secondary plot
---------------------------- */
function drawSecondary(ctx, sys, kNow){
  const dpr=window.devicePixelRatio||1;
  const w = ctx.canvas.width/dpr, h=ctx.canvas.height/dpr;

  if(sys===14){
    // Potential V(x) = -x^2 + (k/3) x^3 (up to constant) in our k-parameterized version
    // because y' = 2x - kx^2 => x'' = -dV/dx => dV/dx = -(2x - kx^2) = -2x + kx^2 => V = -x^2 + (k/3)x^3
    const xmin=-1.2, xmax=Math.max(4.5, 5.0/kNow);
    // sample to set y-range
    const N=220;
    let ymin=1e9, ymax=-1e9;
    const xs=[], vs=[];
    for(let i=0;i<N;i++){
      const x=lerp(xmin,xmax,i/(N-1));
      const V = -x*x + (kNow/3)*x*x*x;
      xs.push(x); vs.push(V);
      ymin=Math.min(ymin,V); ymax=Math.max(ymax,V);
    }
    const padY=0.2*(ymax-ymin||1);
    const view = makeView(w,h, xmin,xmax, ymin-padY,ymax+padY, 42);
    drawGridAxes(ctx, view, "System 14: Potential V(x) (energy landscape)", "x (dimensionless)", "V(x) (energy units)");

    // plot V
    ctx.save();
    ctx.strokeStyle = 'rgba(167,139,250,.95)';
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    xs.forEach((x,i)=>{
      const sx=view.xToS(x), sy=view.yToS(vs[i]);
      if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);
    });
    ctx.stroke();
    ctx.restore();

    // mark equilibria x=0 and x=2/k
    const xe=[0, 2/kNow];
    xe.forEach((xv, idx)=>{
      const Vv = -xv*xv + (kNow/3)*xv*xv*xv;
      drawPoint(ctx, view, xv, Vv, idx===0?'rgba(252,165,165,.95)':'rgba(134,239,172,.95)', 4);
      ctx.save();
      ctx.fillStyle='rgba(233,238,255,.9)';
      ctx.font='12px ui-sans-serif, system-ui';
      ctx.fillText(idx===0?'(saddle at x=0)':'(center at x=2/k)', view.xToS(xv)+8, view.yToS(Vv)-10);
      ctx.restore();
    });

    drawLegend(ctx, [
      {label:'V(x) = -x² + (k/3)x³', color:'rgba(167,139,250,.95)'},
      {label:'equilibria (x=0, x=2/k)', color:'rgba(233,238,255,.75)'}
    ]);

  }else{
    // System 13: show the two nullcline relations as y(x) curves:
    // x' = 0 => y = x/2 (line)
    // y' = 0 => x = 0, ±2/sqrt(k) (vertical), but for a curve plot we show dy/dx? Instead show g(x)=4x-kx^3 (y' RHS) vs x.
    const xmin=-4.2, xmax=4.2;
    const N=260;
    let ymin=1e9, ymax=-1e9;
    const xs=[], g=[];
    for(let i=0;i<N;i++){
      const x=lerp(xmin,xmax,i/(N-1));
      const val = 4*x - kNow*x*x*x;
      xs.push(x); g.push(val);
      ymin=Math.min(ymin,val); ymax=Math.max(ymax,val);
    }
    const padY=0.18*(ymax-ymin||1);
    const view = makeView(w,h, xmin,xmax, ymin-padY,ymax+padY, 42);
    drawGridAxes(ctx, view, "System 13: y′ RHS g(x)=4x−k x³ (zeros give y′=0 nullclines)", "x (dimensionless)", "g(x)=y′ when y ignored (units)");

    // plot g(x)
    ctx.save();
    ctx.strokeStyle='rgba(167,139,250,.95)';
    ctx.lineWidth=2.2;
    ctx.beginPath();
    xs.forEach((x,i)=>{
      const sx=view.xToS(x), sy=view.yToS(g[i]);
      if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);
    });
    ctx.stroke();
    ctx.restore();

    // zero line
    ctx.save();
    ctx.strokeStyle='rgba(233,238,255,.35)';
    ctx.setLineDash([5,5]);
    ctx.lineWidth=1.2;
    ctx.beginPath();
    ctx.moveTo(view.xToS(xmin), view.yToS(0));
    ctx.lineTo(view.xToS(xmax), view.yToS(0));
    ctx.stroke();
    ctx.restore();

    // mark zeros: x=0, ±2/sqrt(k)
    const xz=[0, 2/Math.sqrt(kNow), -2/Math.sqrt(kNow)];
    xz.forEach((xv, idx)=>{
      drawPoint(ctx, view, xv, 0, 'rgba(134,239,172,.95)', 4);
    });

    drawLegend(ctx, [
      {label:'g(x)=4x−k x³', color:'rgba(167,139,250,.95)'},
      {label:'zeros → y′=0 at x=0, ±2/√k', color:'rgba(134,239,172,.95)'}
    ]);
  }
}

/* ---------------------------
   Diagram plot: nullclines & equilibria
---------------------------- */
function drawDiagram(ctx, sys, kNow, bounds){
  const dpr=window.devicePixelRatio||1;
  const w = ctx.canvas.width/dpr, h=ctx.canvas.height/dpr;
  const view = makeView(w,h, bounds.xmin,bounds.xmax, bounds.ymin,bounds.ymax, 42);
  drawGridAxes(ctx, view, "Diagram: nullclines + equilibria", "x", "y");

  // nullclines
  drawNullclines(ctx, view, sys, kNow);

  // equilibria
  const eqs = (sys===13)? eq13(kNow) : eq14(kNow);
  eqs.forEach((e, idx)=>{
    drawPoint(ctx, view, e.x, e.y, 'rgba(253,230,138,.95)', 4.5);
    ctx.save();
    ctx.fillStyle='rgba(233,238,255,.9)';
    ctx.font='12px ui-sans-serif, system-ui';
    const sx=view.xToS(e.x)+6, sy=view.yToS(e.y)-10;
    ctx.fillText(`${e.name} (${e.x.toFixed(2)}, ${e.y.toFixed(2)})`, sx, sy);
    ctx.restore();
  });

  drawLegend(ctx, [
    {label:"x′=0 nullcline", color:'rgba(125,211,252,.9)'},
    {label:"y′=0 nullcline", color:'rgba(167,139,250,.9)'},
    {label:"equilibria", color:'rgba(253,230,138,.95)'}
  ]);
}

/* ---------------------------
   Phase portrait
---------------------------- */
function defaultBounds(sys, k){
  if(sys===13){
    // equilibria at x=±2/√k, y=±1/√k
    const a=2/Math.sqrt(k);
    const b=a/2;
    const Mx=Math.max(4.2, a*1.9);
    const My=Math.max(3.2, b*3.2);
    return {xmin:-Mx, xmax:Mx, ymin:-My, ymax:My};
  }else{
    // x eq at 2/k; separatrix goes to about 3/k for energy=0 in original; give margin
    const xmax=Math.max(4.6, 5.2/k);
    return {xmin:-1.6, xmax:xmax, ymin:-3.4, ymax:3.4};
  }
}

function drawPhase(ctx, sys, kNow, showVF, showNull, trajectories, bounds){
  const dpr=window.devicePixelRatio||1;
  const w=ctx.canvas.width/dpr, h=ctx.canvas.height/dpr;
  const view = makeView(w,h, bounds.xmin,bounds.xmax, bounds.ymin,bounds.ymax, 46);
  drawGridAxes(ctx, view, "Phase portrait (click to launch trajectory)", "x", "y");

  if(showVF) drawVectorField(ctx, view, sys, kNow);
  if(showNull) drawNullclines(ctx, view, sys, kNow);

  // equilibria
  const eqs = (sys===13)? eq13(kNow) : eq14(kNow);
  eqs.forEach((e)=>{
    drawPoint(ctx, view, e.x, e.y, 'rgba(253,230,138,.98)', 5);
  });

  // trajectories
  trajectories.forEach((tr, i)=>{
    drawTrajectory(ctx, view, tr.forward, 'rgba(134,239,172,.92)');
    drawTrajectory(ctx, view, tr.backward, 'rgba(134,239,172,.55)');
    // initial point marker
    if(tr.seed){
      drawPoint(ctx, view, tr.seed[0], tr.seed[1], 'rgba(233,238,255,.85)', 3.2);
    }
  });

  drawLegend(ctx, [
    {label:'trajectory (forward)', color:'rgba(134,239,172,.92)'},
    {label:'trajectory (backward)', color:'rgba(134,239,172,.55)'},
    {label:"x′=0 (blue), y′=0 (purple)", color:'rgba(233,238,255,.75)'}
  ]);
  return view;
}

/* ---------------------------
   Readout (classification at current k)
---------------------------- */
function formatComplex(z){
  const re = z.re, im=z.im;
  const r = (Math.abs(re)<1e-10)?0:re;
  const i = (Math.abs(im)<1e-10)?0:im;
  if(i===0) return `${r.toFixed(4)}`;
  const sign = i>=0 ? '+' : '−';
  return `${r.toFixed(4)} ${sign} i${Math.abs(i).toFixed(4)}`;
}
function updateReadout(sys, kNow){
  const eqs = (sys===13)? eq13(kNow) : eq14(kNow);
  const lines=[];
  lines.push(`System ${sys} with k=${kNow.toFixed(2)} (problem is k=1).`);
  eqs.forEach((e)=>{
    const A = (sys===13)? J13(e.x,kNow) : J14(e.x,kNow);
    const eigs = eig2(A);
    const cls = classifyFromEig(eigs);
    let extra = '';
    if(cls.type.includes('saddle') && eigs[0].im===0 && eigs[1].im===0){
      // compute eigenvectors
      const lpos = eigs[0].re>eigs[1].re ? eigs[0].re : eigs[1].re;
      const lneg = eigs[0].re<eigs[1].re ? eigs[0].re : eigs[1].re;
      const vpos = eigenvector(A, lpos);
      const vneg = eigenvector(A, lneg);
      extra = ` | eigenvectors approx: v(λ+)≈(${vpos[0].toFixed(2)},${vpos[1].toFixed(2)}), v(λ−)≈(${vneg[0].toFixed(2)},${vneg[1].toFixed(2)})`;
    }
    lines.push(
      `${e.name} at (${e.x.toFixed(3)}, ${e.y.toFixed(3)}): eigs = [${formatComplex(eigs[0])}, ${formatComplex(eigs[1])}] → ${cls.type}; structural: ${cls.structural}${extra}`
    );
  });
  document.getElementById('readoutText').textContent = lines.join('  ');
}

/* ---------------------------
   App state and wiring
---------------------------- */
const canvases = {
  diagram: document.getElementById('cDiagram'),
  main: document.getElementById('cMain'),
  secondary: document.getElementById('cSecondary'),
  phase: document.getElementById('cPhase')
};

const sysSel = document.getElementById('sysSel');
const kSlider = document.getElementById('kSlider');
const kVal = document.getElementById('kVal');
const vfToggle = document.getElementById('vfToggle');
const nullToggle = document.getElementById('nullToggle');
const clearBtn = document.getElementById('clearBtn');

let trajectories = [];
let lastPhaseView = null;
let lastBounds = null;

function currentState(){
  const sys = parseInt(sysSel.value,10);
  const k = parseFloat(kSlider.value);
  return {sys, k};
}

function renderAll(){
  const {sys, k} = currentState();
  kVal.textContent = k.toFixed(2);
  const bounds = defaultBounds(sys, k);
  lastBounds = bounds;

  // resize canvases (use their current CSS height)
  const r1 = resizeCanvas(canvases.diagram);
  const r2 = resizeCanvas(canvases.main);
  const r3 = resizeCanvas(canvases.secondary);
  const r4 = resizeCanvas(canvases.phase);

  clear(r1.ctx, r1.w, r1.h);
  clear(r2.ctx, r2.w, r2.h);
  clear(r3.ctx, r3.w, r3.h);
  clear(r4.ctx, r4.w, r4.h);

  drawDiagram(r1.ctx, sys, k, bounds);
  drawMainPlot(r2.ctx, sys, k);
  drawSecondary(r3.ctx, sys, k);

  lastPhaseView = drawPhase(
    r4.ctx, sys, k, vfToggle.checked, nullToggle.checked,
    trajectories, bounds
  );

  updateReadout(sys, k);
}

function addTrajectoryAt(x0, y0){
  const {sys, k} = currentState();
  const f = (sys===13)? f13 : f14;
  const bounds = lastBounds || defaultBounds(sys,k);

  const dt = 0.012;
  const steps = 2600;

  const forward = integrateTrajectory(f, x0, y0, k, dt, steps, bounds);
  const backward = integrateTrajectory(f, x0, y0, k, -dt, steps, bounds);
  trajectories.push({seed:[x0,y0], forward, backward});
  renderAll();
}

/* ---------------------------
   Event listeners
---------------------------- */
sysSel.addEventListener('change', ()=>{
  trajectories = [];
  renderAll();
});
kSlider.addEventListener('input', ()=>{
  // keep trajectories, but recompute them with new k for consistency
  const {sys,k} = currentState();
  const f = (sys===13)? f13 : f14;
  const bounds = defaultBounds(sys,k);

  const dt = 0.012;
  const steps = 2600;
  trajectories = trajectories.map(tr=>{
    const [x0,y0] = tr.seed;
    return {
      seed:[x0,y0],
      forward: integrateTrajectory(f, x0, y0, k, dt, steps, bounds),
      backward: integrateTrajectory(f, x0, y0, k, -dt, steps, bounds)
    };
  });
  renderAll();
});
vfToggle.addEventListener('change', renderAll);
nullToggle.addEventListener('change', renderAll);
clearBtn.addEventListener('click', ()=>{
  trajectories = [];
  renderAll();
});

canvases.phase.addEventListener('click', (ev)=>{
  if(!lastPhaseView) return;
  const rect = canvases.phase.getBoundingClientRect();
  const sx = ev.clientX - rect.left;
  const sy = ev.clientY - rect.top;
  const x0 = lastPhaseView.sToX(sx);
  const y0 = lastPhaseView.sToY(sy);
  addTrajectoryAt(x0, y0);
});

// responsive
window.addEventListener('resize', ()=>renderAll());

// initial
renderAll();
</script>
</body>
</html>
