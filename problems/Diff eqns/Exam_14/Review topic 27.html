<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Qualitative Behavior of 2×2 Linear Systems: Phase Portraits, Stability, and Structural Stability</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --panel2:#0f1730;
      --ink:#e9ecff;
      --muted:#b7c0ff;
      --soft:#8ea0ff;
      --accent:#7cf0c5;
      --accent2:#8db7ff;
      --warn:#ffcf5a;
      --bad:#ff6b86;
      --good:#63ffa6;
      --line:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --r:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      background: radial-gradient(1200px 800px at 20% 10%, rgba(141,183,255,.18), transparent 60%),
                  radial-gradient(900px 700px at 80% 30%, rgba(124,240,197,.12), transparent 55%),
                  radial-gradient(800px 600px at 50% 90%, rgba(255,207,90,.10), transparent 60%),
                  var(--bg);
      color: var(--ink);
      line-height:1.55;
    }

    header{
      padding: 28px 18px 10px;
      max-width: 1200px;
      margin: 0 auto;
    }
    header .top{
      display:flex;
      align-items:flex-start;
      gap:16px;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-size: clamp(1.35rem, 2.2vw, 2.1rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:8px 0 0;
      color: var(--muted);
      max-width: 72ch;
      font-size: 1.02rem;
    }

    .layout{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 18px 40px;
      display:grid;
      grid-template-columns: 310px 1fr;
      gap:18px;
    }

    nav{
      position: sticky;
      top: 14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(17,26,51,.92), rgba(15,23,48,.88));
      border: 1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
      backdrop-filter: blur(8px);
    }
    nav .navHead{
      padding: 14px 14px 10px;
      border-bottom: 1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    nav .navHead strong{
      font-size: .95rem;
      letter-spacing:.2px;
    }
    nav ul{
      list-style:none;
      padding: 8px 10px 12px;
      margin:0;
      display:grid;
      gap:6px;
    }
    nav a{
      display:block;
      padding: 9px 10px;
      border-radius: 12px;
      color: var(--ink);
      text-decoration:none;
      border: 1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      font-size:.95rem;
    }
    nav a:hover{
      background: rgba(141,183,255,.10);
      border-color: rgba(141,183,255,.18);
      transform: translateY(-1px);
    }

    main{
      display:grid;
      gap:16px;
      min-width: 0;
    }

    .card{
      background: linear-gradient(180deg, rgba(17,26,51,.92), rgba(15,23,48,.88));
      border: 1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      padding: 16px 16px 14px;
      overflow:hidden;
      backdrop-filter: blur(8px);
    }

    .quick{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:14px;
      align-items:stretch;
    }
    .quick ul{
      margin:10px 0 0;
      padding-left: 18px;
      color: var(--muted);
    }
    .badgeRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 10px;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      color: var(--ink);
      font-size:.9rem;
      white-space:nowrap;
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(124,240,197,.12);
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }

    .callout{
      border-left: 4px solid var(--accent2);
      padding: 10px 12px;
      background: rgba(141,183,255,.08);
      border-radius: 14px;
      color: var(--muted);
    }
    .warn{
      border-left-color: var(--warn);
      background: rgba(255,207,90,.08);
    }

    h2{
      margin:0 0 8px;
      font-size: 1.2rem;
    }
    h3{
      margin: 12px 0 8px;
      font-size: 1.05rem;
      color: var(--ink);
    }
    p{ margin: 10px 0; color: var(--muted); }

    .eq{
      position: relative;
      margin: 10px 0;
      padding: 12px 12px 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      overflow:auto;
      font-family: var(--mono);
      color: #f3f5ff;
      line-height:1.45;
    }
    .eq .copyBtn{
      position:absolute;
      top:10px;
      right:10px;
      font-family: var(--sans);
      font-size: .85rem;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.15);
      color: var(--ink);
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .eq .copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(124,240,197,.10);
      border-color: rgba(124,240,197,.30);
    }

    .vizWrap{
      display:grid;
      gap:14px;
    }
    .vizGrid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:14px;
      align-items:stretch;
    }
    .vizPanel{
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 10px;
      overflow:hidden;
    }
    .vizTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin: 4px 2px 10px;
      color: var(--ink);
      font-weight:600;
      letter-spacing:.2px;
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
      border-radius: 12px;
      background: rgba(10,14,30,.40);
    }
    .small canvas{ height: 260px; }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top: 8px;
    }
    .control{
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 10px 10px 8px;
    }
    label{
      display:flex;
      justify-content:space-between;
      gap:12px;
      font-size: .9rem;
      color: var(--ink);
      margin-bottom: 6px;
    }
    label span{
      color: var(--muted);
      font-feature-settings: "tnum" 1, "lnum" 1;
      font-variant-numeric: tabular-nums;
    }
    select, input[type="range"], button{
      width:100%;
      accent-color: var(--accent);
    }
    select{
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.18);
      color: var(--ink);
      outline:none;
    }
    button.action{
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(124,240,197,.12);
      color: var(--ink);
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    button.action:hover{
      transform: translateY(-1px);
      background: rgba(124,240,197,.18);
      border-color: rgba(124,240,197,.30);
    }

    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      margin-top: 10px;
      overflow:hidden;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
    }
    th, td{
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      vertical-align:top;
      font-size:.95rem;
    }
    th{
      text-align:left;
      color: var(--ink);
      background: rgba(255,255,255,.05);
      font-weight: 650;
    }
    td{ color: var(--muted); }
    tr:last-child td{ border-bottom:none; }
    .mono{ font-family: var(--mono); color:#f3f5ff; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      white-space:nowrap;
      font-size:.9rem;
      color: var(--ink);
    }
    .pill .miniDot{ width:9px;height:9px;border-radius:50%; }
    .good{ background: rgba(99,255,166,.14); border-color: rgba(99,255,166,.25); }
    .bad{ background: rgba(255,107,134,.14); border-color: rgba(255,107,134,.25); }
    .meh{ background: rgba(255,207,90,.12); border-color: rgba(255,207,90,.22); }

    .finalBox{
      border: 1px solid rgba(124,240,197,.28);
      background: rgba(124,240,197,.08);
      border-radius: 16px;
      padding: 12px 12px 10px;
      position: relative;
      overflow:hidden;
    }
    .finalBox h3{ margin-top:0; }
    .finalBox .copyBtn2{
      margin-top: 8px;
      display:inline-block;
      padding: 9px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.12);
      color: var(--ink);
      cursor:pointer;
    }
    .finalBox .copyBtn2:hover{
      background: rgba(124,240,197,.12);
      border-color: rgba(124,240,197,.28);
    }

    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 10px 18px 30px;
      color: rgba(233,236,255,.65);
      font-size:.92rem;
    }

    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
      nav{ position: relative; top: 0; }
      .quick{ grid-template-columns: 1fr; }
      .vizGrid{ grid-template-columns: 1fr; }
      canvas{ height: 300px; }
      .small canvas{ height: 260px; }
    }

    @media print{
      body{ background:#fff; color:#000; }
      nav{ display:none; }
      .card{ box-shadow:none; border:1px solid #ddd; background:#fff; }
      canvas{ border:1px solid #ddd; background:#fff; }
      .eq{ background:#fff; color:#000; }
      .eq .copyBtn, .finalBox .copyBtn2, button.action{ display:none; }
    }
  </style>
</head>

<body>
<header>
  <div class="top">
    <div>
      <h1>Phase Portraits of 2×2 Linear Systems (Trace–Determinant Method)</h1>
      <p class="subtitle">
        We classify each linear system <span class="mono">x' = A x</span> by computing trace, determinant, eigenvalues,
        and then sketch the qualitative phase portrait (node / saddle / spiral / center), including stability and structural stability.
      </p>
      <div class="badgeRow">
        <span class="badge"><span class="dot"></span>Interactive phase portrait + time signals</span>
        <span class="badge"><span class="dot" style="background:var(--accent2)"></span>Trace–det diagram classification</span>
        <span class="badge"><span class="dot" style="background:var(--warn)"></span>Structural stability check</span>
      </div>
    </div>
  </div>
</header>

<div class="layout">
  <nav aria-label="Table of contents">
    <div class="navHead">
      <strong>Table of Contents</strong>
      <span class="pill" title="Sticky TOC">⬇︎</span>
    </div>
    <ul>
      <li><a href="#quick">Quick Summary</a></li>
      <li><a href="#part1">PART 1 — Problem Analysis</a></li>
      <li><a href="#part2">PART 2 — Strategy & Tips</a></li>
      <li><a href="#part3">PART 3 — Full Solution</a></li>
      <li><a href="#viz">Interactive Visualizations</a></li>
      <li><a href="#final">Final Results (boxed)</a></li>
    </ul>
  </nav>

  <main>
    <!-- QUICK SUMMARY -->
    <section class="card" id="quick">
      <h2>Quick Summary</h2>
      <div class="quick">
        <div>
          <ul>
            <li>For <span class="mono">x' = A x</span>, the origin is a critical point. Its type is determined by <span class="mono">tr(A)=τ</span> and <span class="mono">det(A)=Δ</span>.</li>
            <li>Eigenvalues: <span class="mono">λ = (τ ± √(τ² − 4Δ))/2</span>. Signs of <span class="mono">Re(λ)</span> decide stability.</li>
            <li><span class="mono">Δ &lt; 0</span> → saddle (unstable). <span class="mono">Δ &gt; 0</span> with <span class="mono">τ &gt; 0</span> unstable, <span class="mono">τ &lt; 0</span> stable.</li>
            <li><span class="mono">τ² − 4Δ &lt; 0</span> → spiral/focus (if <span class="mono">τ ≠ 0</span>) or center (if <span class="mono">τ=0</span>).</li>
            <li>Structural stability (2D linear): typically fails on boundaries <span class="mono">Δ=0</span>, <span class="mono">τ=0</span> (centers), and <span class="mono">τ²−4Δ=0</span> (repeated eigenvalues).</li>
          </ul>
        </div>
        <div class="callout">
          <strong>What you will get here</strong>
          <p>
            For each system (a)–(f): trace, determinant, eigenvalues, phase portrait type, dynamical stability,
            and whether the system is structurally stable.
          </p>
        </div>
      </div>
    </section>

    <!-- PART 1 -->
    <section class="card" id="part1">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>Rewrite the problem (in my own words)</h3>
      <p>
        We are given six planar linear systems of the form <span class="mono">x' = A x</span> (with <span class="mono">x = (x, y)</span>).
        For each matrix <span class="mono">A</span>, we must (1) sketch the phase portrait near the origin, (2) identify the type of the equilibrium at the origin
        (node/saddle/spiral/center/degenerate), (3) determine whether the origin is dynamically stable (trajectories approach the origin),
        and (4) decide whether the system is structurally stable (qualitative behavior unchanged under small perturbations).
      </p>

      <h3>Given quantities</h3>
      <ul>
        <li>Six constant matrices <span class="mono">A</span>:
          <div class="eq" id="eqGiven">
            <button class="copyBtn" data-copy="eqGiven">Copy</button>
(a) A = [[ 5,  1],
         [-4, 10]]

(b) A = [[ -7,  -3],
         [  3, -17]]

(c) A = [[ 5,  3],
         [ 0, -2]]

(d) A = [[ 5,  5],
         [-5, -1]]

(e) A = [[ 3, -4],
         [ 4, -3]]

(f) A = [[-4, 4],
         [-1, 0]]
          </div>
        </li>
      </ul>

      <h3>Unknowns</h3>
      <ul>
        <li>Type of critical point at the origin for each system.</li>
        <li>Dynamical stability (stable / unstable / neutrally stable).</li>
        <li>Structural stability (yes/no) for each system.</li>
        <li>Phase portrait sketches (qualitative).</li>
      </ul>

      <h3>Relevant “physical principles” and why they apply</h3>
      <p>
        Even though this is a math topic, it’s exactly the same toolkit used in physics for small oscillations,
        linearized dynamics, circuits, and stability of equilibria:
      </p>
      <ul>
        <li><strong>Linearization & eigenmodes:</strong> solutions are combinations of eigenmodes <span class="mono">e^{λt}</span>. So eigenvalues control growth/decay/rotation.</li>
        <li><strong>Trace–determinant classification:</strong> in 2D, <span class="mono">τ</span> and <span class="mono">Δ</span> determine whether eigenvalues are real/complex and their signs.</li>
        <li><strong>Structural stability idea:</strong> in physics terms, “robust behavior”: small parameter changes should not change the qualitative motion (node ↔ spiral ↔ center boundaries matter).</li>
      </ul>

      <h3>Possible approaches (compare 2–3)</h3>
      <ul>
        <li><strong>Approach A: Compute eigenvalues/eigenvectors directly</strong> for each matrix, then infer phase portrait. Accurate, but repetitive.</li>
        <li><strong>Approach B: Use trace–determinant diagram</strong> to classify quickly, then compute eigenvalues only to confirm. Efficient and conceptually clean.</li>
        <li><strong>Approach C: Numerical phase portrait</strong> (vector field + integration) to “see” behavior. Great for intuition but must be backed by analysis.</li>
      </ul>
      <p class="callout">
        <strong>Best choice:</strong> Use <strong>Approach B</strong> as the main analytical method (fast classification + stability),
        and use <strong>Approach C</strong> as a visual verification (interactive plots below).
      </p>
    </section>

    <!-- PART 2 -->
    <section class="card" id="part2">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

      <h3>Minimal plan (no algebra yet)</h3>
      <ol>
        <li><strong>Compute invariants</strong>: find <span class="mono">τ = tr(A)</span> and <span class="mono">Δ = det(A)</span>.</li>
        <li><strong>Compute discriminant</strong>: <span class="mono">D = τ² − 4Δ</span> to decide real vs complex eigenvalues.</li>
        <li><strong>Classify type</strong>:
          <ul>
            <li><span class="mono">Δ &lt; 0</span> → saddle.</li>
            <li><span class="mono">Δ &gt; 0</span>, <span class="mono">D &gt; 0</span> → node (stable if <span class="mono">τ&lt;0</span>, unstable if <span class="mono">τ&gt;0</span>).</li>
            <li><span class="mono">Δ &gt; 0</span>, <span class="mono">D &lt; 0</span> → spiral/focus (stable if <span class="mono">τ&lt;0</span>, unstable if <span class="mono">τ&gt;0</span>); if <span class="mono">τ=0</span> → center.</li>
            <li><span class="mono">D = 0</span> → repeated eigenvalue; check diagonalizability for proper vs improper node.</li>
          </ul>
        </li>
        <li><strong>Compute eigenvalues</strong> with <span class="mono">λ = (τ ± √D)/2</span> to confirm.</li>
        <li><strong>Decide dynamical stability</strong>: stable if both eigenvalues have negative real part; unstable if any has positive real part; center is neutral.</li>
        <li><strong>Decide structural stability</strong>: generally stable if not on the “boundary curves” (<span class="mono">Δ=0</span>, <span class="mono">τ=0</span> with complex, or <span class="mono">D=0</span>).</li>
        <li><strong>Sketch phase portrait</strong> using eigenvectors (nodes/saddles) or rotation direction (spirals/centers).</li>
      </ol>

      <h3>Common mistakes & quick tips</h3>
      <div class="grid2">
        <div class="callout warn">
          <strong>Common mistakes</strong>
          <ul>
            <li>Mixing up <span class="mono">τ² − 4Δ</span> sign (real vs complex eigenvalues).</li>
            <li>Forgetting: <span class="mono">Δ&lt;0</span> always means a saddle (one positive, one negative eigenvalue).</li>
            <li>Calling a center “stable” in the asymptotic sense (it’s <em>neutrally</em> stable, not attracting).</li>
            <li>Ignoring the special case <span class="mono">D=0</span> (degenerate/repeated eigenvalue).</li>
          </ul>
        </div>
        <div class="callout">
          <strong>Quick tips</strong>
          <ul>
            <li><span class="mono">τ</span> is the sum of eigenvalues; <span class="mono">Δ</span> is the product.</li>
            <li>If <span class="mono">τ&gt;0</span> and <span class="mono">Δ&gt;0</span>, the origin repels (unstable).</li>
            <li>If <span class="mono">τ&lt;0</span> and <span class="mono">Δ&gt;0</span>, the origin attracts (stable).</li>
            <li>Spiral vs node: check whether <span class="mono">D</span> is negative (spiral) or positive (node).</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- PART 3 -->
    <section class="card" id="part3">
      <h2>PART 3 — Full Solution</h2>

      <h3>Physical intuition first</h3>
      <p>
        A 2D linear system <span class="mono">x' = A x</span> behaves like a “mix” of two exponential modes. If eigenvalues are real,
        trajectories move straight in/out along eigenvectors (nodes or saddles). If eigenvalues are complex, trajectories rotate while
        expanding/contracting (spirals). If the real part is zero, you get closed orbits (center).
      </p>

      <h3>The core math tools</h3>
      <p>
        The characteristic polynomial is:
      </p>
      <div class="eq" id="eqChar">
        <button class="copyBtn" data-copy="eqChar">Copy</button>
p(λ) = det(A − λI) = λ² − τ λ + Δ
where τ = tr(A), Δ = det(A)
      </div>

      <p>
        The eigenvalues are:
      </p>
      <div class="eq" id="eqEig">
        <button class="copyBtn" data-copy="eqEig">Copy</button>
λ₁,₂ = (τ ± √(τ² − 4Δ)) / 2
Discriminant D = τ² − 4Δ
      </div>

      <p>
        Classification (for the equilibrium at the origin):
      </p>
      <div class="eq" id="eqClass">
        <button class="copyBtn" data-copy="eqClass">Copy</button>
Let τ = tr(A), Δ = det(A), D = τ² − 4Δ.

1) Δ < 0  → saddle (unstable).
2) Δ > 0 and D > 0 → node:
      τ < 0 stable node, τ > 0 unstable node.
3) Δ > 0 and D < 0 → spiral/focus:
      τ < 0 stable spiral, τ > 0 unstable spiral.
   Special: if τ = 0 (hence Re(λ)=0) → center (neutral).
4) D = 0 → repeated eigenvalue λ = τ/2:
      if two eigenvectors → proper (star) node,
      if one eigenvector → improper (degenerate) node.
      (Still attracting if λ<0, repelling if λ>0.)
      </div>

      <h3>Now apply to each system (a)–(f)</h3>

      <p>
        We compute <span class="mono">τ</span>, <span class="mono">Δ</span>, <span class="mono">D</span>, and eigenvalues for each.
        (No units here—these are abstract phase-plane variables; the “unit check” becomes a consistency check that growth/decay rates match eigenvalues.)
      </p>

      <table aria-label="Summary table">
        <thead>
          <tr>
            <th>System</th>
            <th class="mono">τ = tr(A)</th>
            <th class="mono">Δ = det(A)</th>
            <th class="mono">D = τ² − 4Δ</th>
            <th>Eigenvalues</th>
            <th>Type at origin</th>
            <th>Dynamical stability</th>
            <th>Structural stability</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>(a)</strong></td>
            <td class="mono">15</td>
            <td class="mono">54</td>
            <td class="mono">9</td>
            <td class="mono">λ = 9, 6</td>
            <td>Unstable node (source)</td>
            <td><span class="pill bad"><span class="miniDot" style="background:var(--bad)"></span>Unstable</span></td>
            <td><span class="pill good"><span class="miniDot" style="background:var(--good)"></span>Yes</span></td>
          </tr>
          <tr>
            <td><strong>(b)</strong></td>
            <td class="mono">−24</td>
            <td class="mono">128</td>
            <td class="mono">64</td>
            <td class="mono">λ = −8, −16</td>
            <td>Stable node (sink)</td>
            <td><span class="pill good"><span class="miniDot" style="background:var(--good)"></span>Stable</span></td>
            <td><span class="pill good"><span class="miniDot" style="background:var(--good)"></span>Yes</span></td>
          </tr>
          <tr>
            <td><strong>(c)</strong></td>
            <td class="mono">3</td>
            <td class="mono">−10</td>
            <td class="mono">49</td>
            <td class="mono">λ = 5, −2</td>
            <td>Saddle</td>
            <td><span class="pill bad"><span class="miniDot" style="background:var(--bad)"></span>Unstable</span></td>
            <td><span class="pill good"><span class="miniDot" style="background:var(--good)"></span>Yes</span></td>
          </tr>
          <tr>
            <td><strong>(d)</strong></td>
            <td class="mono">4</td>
            <td class="mono">20</td>
            <td class="mono">−64</td>
            <td class="mono">λ = 2 ± 4i</td>
            <td>Unstable spiral (focus/source)</td>
            <td><span class="pill bad"><span class="miniDot" style="background:var(--bad)"></span>Unstable</span></td>
            <td><span class="pill good"><span class="miniDot" style="background:var(--good)"></span>Yes</span></td>
          </tr>
          <tr>
            <td><strong>(e)</strong></td>
            <td class="mono">0</td>
            <td class="mono">7</td>
            <td class="mono">−28</td>
            <td class="mono">λ = ± i√7</td>
            <td>Center</td>
            <td><span class="pill meh"><span class="miniDot" style="background:var(--warn)"></span>Neutral</span></td>
            <td><span class="pill bad"><span class="miniDot" style="background:var(--bad)"></span>No</span></td>
          </tr>
          <tr>
            <td><strong>(f)</strong></td>
            <td class="mono">−4</td>
            <td class="mono">4</td>
            <td class="mono">0</td>
            <td class="mono">λ = −2 (double)</td>
            <td>Stable improper (degenerate) node</td>
            <td><span class="pill good"><span class="miniDot" style="background:var(--good)"></span>Stable</span></td>
            <td><span class="pill bad"><span class="miniDot" style="background:var(--bad)"></span>No*</span></td>
          </tr>
        </tbody>
      </table>

      <h3>Step-by-step confirmations (brief but explicit)</h3>

      <div class="callout">
        <strong>(a)</strong>
        <p>
          <span class="mono">τ=5+10=15</span>, <span class="mono">Δ=5·10 − 1(−4)=50+4=54</span>,
          <span class="mono">D=15²−4·54=225−216=9&gt;0</span> → real eigenvalues.
          Since <span class="mono">τ&gt;0</span> and <span class="mono">Δ&gt;0</span>, both eigenvalues are positive → unstable node.
        </p>
      </div>

      <div class="callout">
        <strong>(b)</strong>
        <p>
          <span class="mono">τ=−7+(−17)=−24</span>, <span class="mono">Δ=(−7)(−17) − (−3)(3)=119 − (−9)=128</span>,
          <span class="mono">D= (−24)²−4·128=576−512=64&gt;0</span>.
          <span class="mono">τ&lt;0</span>, <span class="mono">Δ&gt;0</span> → both eigenvalues negative → stable node.
        </p>
      </div>

      <div class="callout">
        <strong>(c)</strong>
        <p>
          <span class="mono">τ=5+(−2)=3</span>, <span class="mono">Δ=5(−2) − 3·0 = −10</span>.
          Since <span class="mono">Δ&lt;0</span>, eigenvalues have opposite signs → saddle → unstable.
        </p>
      </div>

      <div class="callout">
        <strong>(d)</strong>
        <p>
          <span class="mono">τ=5+(−1)=4</span>, <span class="mono">Δ=5(−1) − 5(−5)=−5+25=20</span>,
          <span class="mono">D=4²−4·20=16−80=−64&lt;0</span> → complex eigenvalues.
          Real part is <span class="mono">τ/2=2&gt;0</span> → unstable spiral (spiral source).
        </p>
      </div>

      <div class="callout">
        <strong>(e)</strong>
        <p>
          <span class="mono">τ=3+(−3)=0</span>, <span class="mono">Δ=3(−3) − (−4)(4)=−9+16=7</span>,
          <span class="mono">D=0−4·7=−28&lt;0</span> → purely imaginary eigenvalues <span class="mono">± i√7</span>.
          This is a <strong>center</strong> (closed orbits). It is not asymptotically stable (no decay).
        </p>
      </div>

      <div class="callout">
        <strong>(f)</strong>
        <p>
          <span class="mono">τ=−4+0=−4</span>, <span class="mono">Δ=(−4)·0 − 4(−1)=4</span>,
          <span class="mono">D=(−4)²−4·4=16−16=0</span> → repeated eigenvalue <span class="mono">λ=τ/2=−2</span>.
          Check eigenvectors: <span class="mono">A+2I = [[−2,4],[−1,2]]</span> has rank 1 → only one eigenvector → <strong>improper/degenerate stable node</strong>.
        </p>
        <p class="warn">
          <strong>Structural stability note:</strong> because it sits on the boundary <span class="mono">D=0</span>, arbitrarily small perturbations can turn this into a stable node (<span class="mono">D&gt;0</span>) or stable spiral (<span class="mono">D&lt;0</span>),
          changing the qualitative portrait (rotation vs no rotation). So it is typically classified as <strong>not structurally stable</strong>.
        </p>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><strong>Growth/decay:</strong> If <span class="mono">Re(λ)&gt;0</span> trajectories blow up (unstable), if <span class="mono">Re(λ)&lt;0</span> they shrink (stable). This matches all cases above.</li>
        <li><strong>Limiting cases:</strong> The boundaries <span class="mono">Δ=0</span>, <span class="mono">τ=0</span>, <span class="mono">D=0</span> are exactly where the “type” can change—consistent with structural stability failures.</li>
        <li><strong>Physical interpretation:</strong> Spirals are “oscillation + growth/decay,” centers are “pure oscillation,” nodes are “pure exponential,” saddles are “one stable direction + one unstable direction.”</li>
      </ul>
    </section>

    <!-- VISUALIZATION -->
    <section class="card" id="viz">
      <h2>Interactive Visualizations</h2>
      <p>
        Use the controls to pick a system (a)–(f). All plots update live:
        (1) trace–determinant diagram (classification map), (2) phase portrait with vector field and trajectories,
        (3) time signals <span class="mono">x(t)</span> and <span class="mono">y(t)</span> for the highlighted initial condition.
      </p>

      <div class="vizWrap">
        <div class="controls" aria-label="Interactive controls">
          <div class="control">
            <label for="sysSel">System <span id="sysLabel" class="mono">(a)</span></label>
            <select id="sysSel">
              <option value="a">(a) A = [[5,1],[-4,10]]</option>
              <option value="b">(b) A = [[-7,-3],[3,-17]]</option>
              <option value="c">(c) A = [[5,3],[0,-2]]</option>
              <option value="d">(d) A = [[5,5],[-5,-1]]</option>
              <option value="e">(e) A = [[3,-4],[4,-3]]</option>
              <option value="f">(f) A = [[-4,4],[-1,0]]</option>
            </select>
          </div>

          <div class="control">
            <label for="tMax">Time span <span id="tMaxVal" class="mono">6.0</span></label>
            <input id="tMax" type="range" min="2" max="16" value="6" step="0.5"/>
          </div>

          <div class="control">
            <label for="r0">Initial radius r₀ <span id="r0Val" class="mono">1.00</span></label>
            <input id="r0" type="range" min="0.2" max="3.0" value="1.0" step="0.05"/>
          </div>

          <div class="control">
            <label for="theta">Initial angle θ (deg) <span id="thetaVal" class="mono">35</span></label>
            <input id="theta" type="range" min="0" max="360" value="35" step="1"/>
          </div>

          <div class="control">
            <label for="fieldScale">Vector-field scale <span id="fsVal" class="mono">1.0</span></label>
            <input id="fieldScale" type="range" min="0.4" max="2.0" value="1.0" step="0.05"/>
          </div>

          <div class="control">
            <label>&nbsp;<span class="mono">Actions</span></label>
            <button id="randBtn" class="action">Random initial condition</button>
          </div>
        </div>

        <div class="vizGrid">
          <div class="vizPanel">
            <div class="vizTitle">
              <span>Plot 1 (Diagram): Trace–Determinant Map</span>
              <span class="pill"><span class="miniDot" style="background:var(--accent2)"></span><span id="tdText">τ=?, Δ=?</span></span>
            </div>
            <canvas id="tdCanvas" aria-label="Trace determinant diagram"></canvas>
          </div>

          <div class="vizPanel small">
            <div class="vizTitle">
              <span>Plot 3: Time Signals for Highlighted Trajectory</span>
              <span class="pill"><span class="miniDot" style="background:var(--accent)"></span><span id="sigText" class="mono">x(t), y(t)</span></span>
            </div>
            <canvas id="timeCanvas" aria-label="Time series plot"></canvas>
          </div>
        </div>

        <div class="vizPanel">
          <div class="vizTitle">
            <span>Plot 2 (Main): Phase Portrait in the x–y Plane</span>
            <span class="pill"><span class="miniDot" style="background:var(--good)"></span><span id="typeText">Type…</span></span>
          </div>
          <canvas id="phaseCanvas" aria-label="Phase portrait"></canvas>
        </div>

        <p class="callout warn">
          <strong>Reading the plots:</strong> The highlighted trajectory starts at <span class="mono">(x(0), y(0))</span> from the sliders.
          Arrows show the velocity field <span class="mono">x' = A x</span>. Spirals rotate; saddles have one attracting and one repelling axis.
          Centers trace closed curves (no net decay).
        </p>
      </div>
    </section>

    <!-- FINAL RESULTS -->
    <section class="card" id="final">
      <h2>Final Results (boxed)</h2>
      <div class="finalBox" id="finalText">
        <h3>Classification, stability, and structural stability</h3>
        <div class="eq" id="eqFinal">
          <button class="copyBtn" data-copy="eqFinal">Copy</button>
(a) Unstable node (source). Eigenvalues: 9, 6. Dynamically unstable. Structurally stable: YES.

(b) Stable node (sink). Eigenvalues: −8, −16. Dynamically stable. Structurally stable: YES.

(c) Saddle. Eigenvalues: 5, −2. Dynamically unstable. Structurally stable: YES.

(d) Unstable spiral (focus/source). Eigenvalues: 2 ± 4i. Dynamically unstable. Structurally stable: YES.

(e) Center. Eigenvalues: ± i√7. Neutrally stable (not asymptotically). Structurally stable: NO.

(f) Stable improper (degenerate) node. Eigenvalue: −2 (double), one eigenvector. Dynamically stable.
    Structurally stable: NO (boundary case D=0).
        </div>
        <button class="copyBtn2" id="copyAll">Copy final answer (plain text)</button>
      </div>
    </section>
  </main>
</div>

<footer>
  Built with vanilla HTML/CSS/JS. Tip: If your course defines “structurally stable” strictly as “hyperbolic (no eigenvalues with zero real part),”
  then (f) may be considered stable under that definition; many phase-portrait classifications still treat <span class="mono">D=0</span> as non-robust because node ↔ spiral can change under tiny perturbations.
</footer>

<script>
/* ========= Utilities ========= */
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function fmt(x, n=3){
  if (Math.abs(x) < 1e-10) x = 0;
  return (Math.abs(x) >= 1000 || (Math.abs(x) > 0 && Math.abs(x) < 0.001))
    ? x.toExponential(2)
    : x.toFixed(n).replace(/\.?0+$/,'');
}
function copyFromElement(el){
  const txt = el.innerText.replace(/\u00A0/g,' ').trim();
  navigator.clipboard.writeText(txt).catch(()=>{});
}
function getDPR(){ return Math.max(1, Math.min(2.5, window.devicePixelRatio || 1)); }

function resizeCanvasToDisplaySize(canvas){
  const dpr = getDPR();
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(2, Math.floor(rect.width * dpr));
  const h = Math.max(2, Math.floor(rect.height * dpr));
  if (canvas.width !== w || canvas.height !== h){
    canvas.width = w;
    canvas.height = h;
    return true;
  }
  return false;
}

/* ========= Problem data ========= */
const systems = {
  a: { key:'a', name:'(a)', A:[[5,1],[-4,10]] },
  b: { key:'b', name:'(b)', A:[[-7,-3],[3,-17]] },
  c: { key:'c', name:'(c)', A:[[5,3],[0,-2]] },
  d: { key:'d', name:'(d)', A:[[5,5],[-5,-1]] },
  e: { key:'e', name:'(e)', A:[[3,-4],[4,-3]] },
  f: { key:'f', name:'(f)', A:[[-4,4],[-1,0]] },
};

function trace(A){ return A[0][0] + A[1][1]; }
function det(A){ return A[0][0]*A[1][1] - A[0][1]*A[1][0]; }

/* Eigenvalues for 2x2: returns {re1,im1,re2,im2, D} */
function eigen2x2(A){
  const tau = trace(A);
  const delta = det(A);
  const D = tau*tau - 4*delta;
  if (D >= 0){
    const s = Math.sqrt(D);
    return { re1:(tau+s)/2, im1:0, re2:(tau-s)/2, im2:0, D };
  } else {
    const s = Math.sqrt(-D);
    return { re1:tau/2, im1:s/2, re2:tau/2, im2:-s/2, D };
  }
}

/* Classify equilibrium (type, stability, structural stability) */
function classify(A){
  const tau = trace(A);
  const delta = det(A);
  const eig = eigen2x2(A);
  const D = eig.D;

  let type = '';
  let stability = '';
  let structural = 'Yes';
  let notes = '';

  if (delta < 0){
    type = 'Saddle';
    stability = 'Unstable';
    structural = 'Yes';
  } else if (delta > 0 && D > 1e-12){
    type = (tau < 0) ? 'Stable node (sink)' : 'Unstable node (source)';
    stability = (tau < 0) ? 'Stable' : 'Unstable';
    structural = 'Yes';
  } else if (delta > 0 && D < -1e-12){
    if (Math.abs(tau) < 1e-12){
      type = 'Center';
      stability = 'Neutral';
      structural = 'No';
    } else {
      type = (tau < 0) ? 'Stable spiral (focus)' : 'Unstable spiral (focus)';
      stability = (tau < 0) ? 'Stable' : 'Unstable';
      structural = 'Yes';
    }
  } else {
    // D ~ 0 boundary (repeated eigenvalue or close)
    const lam = tau/2;
    // check diagonalizability: rank(A - lam I) ? if nullity 2 -> A=lam I -> star node, else improper.
    const M = [[A[0][0]-lam, A[0][1]],[A[1][0], A[1][1]-lam]];
    const detM = M[0][0]*M[1][1] - M[0][1]*M[1][0];
    const isScalar = (Math.abs(M[0][0])<1e-10 && Math.abs(M[0][1])<1e-10 && Math.abs(M[1][0])<1e-10 && Math.abs(M[1][1])<1e-10);
    let diag = isScalar ? true : (Math.abs(detM) < 1e-10 ? false : true); // conservative; scalar is diagonalizable
    if (isScalar){
      type = (lam < 0) ? 'Stable star node' : 'Unstable star node';
    } else {
      type = (lam < 0) ? 'Stable improper (degenerate) node' : 'Unstable improper (degenerate) node';
    }
    stability = (lam < 0) ? 'Stable' : 'Unstable';
    structural = 'No';
    notes = 'Boundary case D=0 (repeated eigenvalue): small perturbations can change node ↔ spiral.';
  }

  const eigStr = eigenToString(eig);
  return { tau, delta, D, eig, eigStr, type, stability, structural, notes };
}

function eigenToString(e){
  const a1 = e.re1, b1 = e.im1;
  const a2 = e.re2, b2 = e.im2;
  function one(a,b){
    if (Math.abs(b) < 1e-10) return fmt(a,3);
    const sign = (b>=0) ? '+' : '−';
    return `${fmt(a,3)} ${sign} ${fmt(Math.abs(b),3)}i`;
  }
  if (Math.abs(b1) < 1e-10 && Math.abs(b2) < 1e-10){
    return `${one(a1,0)}, ${one(a2,0)}`;
  }
  // conjugate pair:
  return `${one(a1,b1)}, ${one(a2,b2)}`;
}

/* ========= ODE integration (RK4) ========= */
function mulA(A, v){
  return [
    A[0][0]*v[0] + A[0][1]*v[1],
    A[1][0]*v[0] + A[1][1]*v[1],
  ];
}
function rk4Step(A, x, dt){
  const k1 = mulA(A, x);
  const k2 = mulA(A, [x[0] + 0.5*dt*k1[0], x[1] + 0.5*dt*k1[1]]);
  const k3 = mulA(A, [x[0] + 0.5*dt*k2[0], x[1] + 0.5*dt*k2[1]]);
  const k4 = mulA(A, [x[0] + dt*k3[0], x[1] + dt*k3[1]]);
  return [
    x[0] + (dt/6)*(k1[0] + 2*k2[0] + 2*k3[0] + k4[0]),
    x[1] + (dt/6)*(k1[1] + 2*k2[1] + 2*k3[1] + k4[1]),
  ];
}
function integrate(A, x0, tMax, dt){
  const n = Math.max(2, Math.floor(tMax/dt)+1);
  const pts = new Array(n);
  let x = [x0[0], x0[1]];
  for (let i=0;i<n;i++){
    const t = i*dt;
    pts[i] = {t, x:x[0], y:x[1]};
    x = rk4Step(A, x, dt);
  }
  return pts;
}

/* ========= Drawing helpers ========= */
function clear(ctx, w, h){
  ctx.clearRect(0,0,w,h);
}
function setText(ctx, sizePx, bold=false){
  ctx.font = `${bold?'700':'500'} ${sizePx}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
}
function drawGridAxes(ctx, box, xTicks, yTicks, labels){
  const {x0,y0,w,h} = box;

  // grid
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,.08)';
  ctx.lineWidth = 1;
  for (const xt of xTicks){
    const X = x0 + xt*uScale;
    ctx.beginPath(); ctx.moveTo(X, y0); ctx.lineTo(X, y0+h); ctx.stroke();
  }
  for (const yt of yTicks){
    const Y = y0 + h - yt*vScale;
    ctx.beginPath(); ctx.moveTo(x0, Y); ctx.lineTo(x0+w, Y); ctx.stroke();
  }
  ctx.restore();

  // axes lines (x=0, y=0)
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,.22)';
  ctx.lineWidth = 1.5;
  // vertical axis at x=0
  const X0 = x0 + (0 - xMin)*uScale;
  ctx.beginPath(); ctx.moveTo(X0, y0); ctx.lineTo(X0, y0+h); ctx.stroke();
  // horizontal axis at y=0
  const Y0 = y0 + h - (0 - yMin)*vScale;
  ctx.beginPath(); ctx.moveTo(x0, Y0); ctx.lineTo(x0+w, Y0); ctx.stroke();
  ctx.restore();

  // ticks + labels
  ctx.save();
  setText(ctx, 12, false);
  ctx.fillStyle = 'rgba(233,236,255,.75)';
  ctx.strokeStyle = 'rgba(233,236,255,.45)';
  ctx.lineWidth = 1;

  // x ticks
  for (const xt of xTicks){
    const X = x0 + (xt - xMin)*uScale;
    const Y = y0 + h - (0 - yMin)*vScale;
    ctx.beginPath(); ctx.moveTo(X, Y-4); ctx.lineTo(X, Y+4); ctx.stroke();
    ctx.fillText(fmt(xt,1), X-10, Y+18);
  }
  // y ticks
  for (const yt of yTicks){
    const X = x0 + (0 - xMin)*uScale;
    const Y = y0 + h - (yt - yMin)*vScale;
    ctx.beginPath(); ctx.moveTo(X-4, Y); ctx.lineTo(X+4, Y); ctx.stroke();
    if (Math.abs(yt) > 1e-12){
      ctx.fillText(fmt(yt,1), X+8, Y+4);
    }
  }

  // axis labels
  setText(ctx, 13, true);
  ctx.fillStyle = 'rgba(233,236,255,.9)';
  if (labels && labels.x){
    ctx.fillText(labels.x, x0 + w - 34, y0 + h - 8);
  }
  if (labels && labels.y){
    ctx.fillText(labels.y, x0 + 8, y0 + 16);
  }
  ctx.restore();
}

/* ========= Trace-Determinant diagram (canvas 1) ========= */
const tdCanvas = document.getElementById('tdCanvas');
const phaseCanvas = document.getElementById('phaseCanvas');
const timeCanvas = document.getElementById('timeCanvas');

let xMin, xMax, yMin, yMax, uScale, vScale;

function drawTraceDet(sysKey){
  const ctx = tdCanvas.getContext('2d');
  const changed = resizeCanvasToDisplaySize(tdCanvas);
  const W = tdCanvas.width, H = tdCanvas.height;
  clear(ctx, W, H);

  const dpr = getDPR();
  const pad = 40*dpr;
  const box = { x0: pad, y0: pad, w: W-2*pad, h: H-2*pad };

  // Diagram ranges (τ on x, Δ on y) picked to include all systems comfortably
  const tauRange = [-30, 20];
  const delRange = [-20, 150];
  xMin = tauRange[0]; xMax = tauRange[1];
  yMin = delRange[0]; yMax = delRange[1];
  uScale = box.w/(xMax-xMin);
  vScale = box.h/(yMax-yMin);

  function X(tau){ return box.x0 + (tau - xMin)*uScale; }
  function Y(del){ return box.y0 + box.h - (del - yMin)*vScale; }

  // Background
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,.12)';
  ctx.fillRect(box.x0, box.y0, box.w, box.h);
  ctx.restore();

  // grid ticks
  const xTicks = [];
  for (let t=-30; t<=20; t+=10) xTicks.push(t);
  const yTicks = [];
  for (let d=-20; d<=150; d+=20) yTicks.push(d);

  // Draw grid/axes
  drawTDGridAxes(ctx, box, xTicks, yTicks);

  // Parabola Δ = τ²/4 (boundary D=0)
  ctx.save();
  ctx.strokeStyle = 'rgba(124,240,197,.85)';
  ctx.lineWidth = 2.2;
  ctx.beginPath();
  let first = true;
  for (let tau=xMin; tau<=xMax; tau+=0.2){
    const del = (tau*tau)/4;
    const px = X(tau), py = Y(del);
    if (first){ ctx.moveTo(px,py); first=false; }
    else ctx.lineTo(px,py);
  }
  ctx.stroke();
  ctx.restore();

  // Region labels (qualitative)
  ctx.save();
  setText(ctx, 12*dpr, true);
  ctx.fillStyle = 'rgba(233,236,255,.75)';
  ctx.fillText('Spirals/centers (D<0): Δ > τ²/4', X(-28), Y(140));
  ctx.fillText('Nodes (D>0): 0<Δ < τ²/4', X(-28), Y(35));
  ctx.fillText('Saddles: Δ<0', X(-28), Y(-10));
  ctx.restore();

  // Mark the current system point
  const A = systems[sysKey].A;
  const info = classify(A);
  const px = X(info.tau), py = Y(info.delta);

  ctx.save();
  // crosshair
  ctx.strokeStyle = 'rgba(141,183,255,.35)';
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(px, box.y0); ctx.lineTo(px, box.y0+box.h); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(box.x0, py); ctx.lineTo(box.x0+box.w, py); ctx.stroke();

  // point
  ctx.fillStyle = 'rgba(141,183,255,.95)';
  ctx.beginPath(); ctx.arc(px, py, 6*dpr, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = 'rgba(0,0,0,.35)';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.restore();

  // Legend note
  ctx.save();
  setText(ctx, 12*dpr, false);
  ctx.fillStyle = 'rgba(233,236,255,.85)';
  ctx.fillText(`Point: (τ,Δ)=(${fmt(info.tau,2)}, ${fmt(info.delta,2)})`, box.x0, box.y0 - 12*dpr);
  ctx.restore();
}

function drawTDGridAxes(ctx, box, xTicks, yTicks){
  const dpr = getDPR();
  const {x0,y0,w,h} = box;
  function X(tau){ return x0 + (tau - xMin)*uScale; }
  function Y(del){ return y0 + h - (del - yMin)*vScale; }

  // grid
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,.08)';
  ctx.lineWidth = 1;
  for (const tau of xTicks){
    const Xp = X(tau);
    ctx.beginPath(); ctx.moveTo(Xp, y0); ctx.lineTo(Xp, y0+h); ctx.stroke();
  }
  for (const del of yTicks){
    const Yp = Y(del);
    ctx.beginPath(); ctx.moveTo(x0, Yp); ctx.lineTo(x0+w, Yp); ctx.stroke();
  }
  ctx.restore();

  // axes (τ=0, Δ=0)
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,.22)';
  ctx.lineWidth = 1.6;
  const X0 = X(0);
  const Y0 = Y(0);
  ctx.beginPath(); ctx.moveTo(X0, y0); ctx.lineTo(X0, y0+h); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x0, Y0); ctx.lineTo(x0+w, Y0); ctx.stroke();
  ctx.restore();

  // tick labels
  ctx.save();
  setText(ctx, 12*dpr, false);
  ctx.fillStyle = 'rgba(233,236,255,.78)';
  for (const tau of xTicks){
    const Xp = X(tau);
    ctx.fillText(fmt(tau,0), Xp-10*dpr, Y0+18*dpr);
  }
  for (const del of yTicks){
    const Yp = Y(del);
    if (Math.abs(del) < 1e-12) continue;
    ctx.fillText(fmt(del,0), X0+8*dpr, Yp+4*dpr);
  }
  setText(ctx, 13*dpr, true);
  ctx.fillStyle = 'rgba(233,236,255,.92)';
  ctx.fillText('τ = tr(A)', x0 + w - 85*dpr, y0 + h - 8*dpr);
  ctx.fillText('Δ = det(A)', x0 + 8*dpr, y0 + 16*dpr);
  ctx.restore();
}

/* ========= Phase portrait (canvas 2) ========= */
function drawPhase(sysKey, x0Vec, tMax, fieldScale){
  const ctx = phaseCanvas.getContext('2d');
  resizeCanvasToDisplaySize(phaseCanvas);
  const W = phaseCanvas.width, H = phaseCanvas.height;
  clear(ctx, W, H);

  const dpr = getDPR();
  const pad = 42*dpr;
  const box = { x0: pad, y0: pad, w: W-2*pad, h: H-2*pad };

  // Choose view window adaptively using a "typical" scale
  const view = 3.2; // "units" in x,y (abstract)
  const xmin = -view, xmax = view, ymin2 = -view, ymax2 = view;
  const sx = box.w/(xmax-xmin);
  const sy = box.h/(ymax2-ymin2);

  function X(x){ return box.x0 + (x - xmin)*sx; }
  function Y(y){ return box.y0 + box.h - (y - ymin2)*sy; }

  // panel background
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,.12)';
  ctx.fillRect(box.x0, box.y0, box.w, box.h);
  ctx.restore();

  // grid
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,.08)';
  ctx.lineWidth = 1;
  for (let g=-3; g<=3; g+=1){
    const Xg = X(g);
    ctx.beginPath(); ctx.moveTo(Xg, box.y0); ctx.lineTo(Xg, box.y0+box.h); ctx.stroke();
    const Yg = Y(g);
    ctx.beginPath(); ctx.moveTo(box.x0, Yg); ctx.lineTo(box.x0+box.w, Yg); ctx.stroke();
  }
  ctx.restore();

  // axes
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,.22)';
  ctx.lineWidth = 1.6;
  ctx.beginPath(); ctx.moveTo(X(0), box.y0); ctx.lineTo(X(0), box.y0+box.h); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(box.x0, Y(0)); ctx.lineTo(box.x0+box.w, Y(0)); ctx.stroke();
  ctx.restore();

  // tick labels
  ctx.save();
  setText(ctx, 12*dpr, false);
  ctx.fillStyle = 'rgba(233,236,255,.78)';
  for (let g=-3; g<=3; g+=1){
    if (g===0) continue;
    ctx.fillText(String(g), X(g)-4*dpr, Y(0)+18*dpr);
    ctx.fillText(String(g), X(0)+10*dpr, Y(g)+4*dpr);
  }
  setText(ctx, 13*dpr, true);
  ctx.fillStyle = 'rgba(233,236,255,.92)';
  ctx.fillText('x (arb. units)', box.x0 + box.w - 92*dpr, box.y0 + box.h - 8*dpr);
  ctx.fillText('y (arb. units)', box.x0 + 8*dpr, box.y0 + 16*dpr);
  ctx.restore();

  const A = systems[sysKey].A;

  // vector field arrows
  const nx = 17, ny = 11;
  ctx.save();
  ctx.strokeStyle = 'rgba(141,183,255,.45)';
  ctx.lineWidth = 1.5;
  for (let i=0;i<nx;i++){
    for (let j=0;j<ny;j++){
      const x = xmin + (i/(nx-1))*(xmax-xmin);
      const y = ymin2 + (j/(ny-1))*(ymax2-ymin2);
      const v = mulA(A, [x,y]);
      const speed = Math.hypot(v[0], v[1]) + 1e-9;
      // scale arrow length with a saturating function
      const L = fieldScale * 0.35 * (1 - Math.exp(-0.6*speed));
      const ux = v[0]/speed, uy = v[1]/speed;
      const x2 = x + L*ux, y2 = y + L*uy;

      // draw arrow
      const px1 = X(x), py1 = Y(y), px2 = X(x2), py2 = Y(y2);
      ctx.beginPath(); ctx.moveTo(px1, py1); ctx.lineTo(px2, py2); ctx.stroke();

      // arrowhead
      const ang = Math.atan2(py2-py1, px2-px1);
      const ah = 6*dpr;
      ctx.beginPath();
      ctx.moveTo(px2, py2);
      ctx.lineTo(px2 - ah*Math.cos(ang-0.5), py2 - ah*Math.sin(ang-0.5));
      ctx.lineTo(px2 - ah*Math.cos(ang+0.5), py2 - ah*Math.sin(ang+0.5));
      ctx.closePath();
      ctx.fillStyle = 'rgba(141,183,255,.45)';
      ctx.fill();
    }
  }
  ctx.restore();

  // trajectories (several initial angles)
  const dt = Math.min(0.01, tMax/1800);
  const seeds = [];
  for (let k=0;k<10;k++){
    const ang = (k/10)*2*Math.PI;
    seeds.push([1.6*Math.cos(ang), 1.6*Math.sin(ang)]);
  }

  // draw faint trajectories
  ctx.save();
  ctx.lineWidth = 2.0;
  ctx.strokeStyle = 'rgba(255,255,255,.20)';
  for (const s of seeds){
    const pts = integrate(A, s, tMax, dt);
    ctx.beginPath();
    let started = false;
    for (const p of pts){
      if (Math.abs(p.x) > 10 || Math.abs(p.y) > 10) break; // escape
      const px = X(p.x), py = Y(p.y);
      if (!started){ ctx.moveTo(px,py); started=true; }
      else ctx.lineTo(px,py);
    }
    ctx.stroke();
  }
  ctx.restore();

  // highlighted trajectory
  const hi = integrate(A, x0Vec, tMax, dt);
  ctx.save();
  ctx.strokeStyle = 'rgba(124,240,197,.95)';
  ctx.lineWidth = 3.0;
  ctx.beginPath();
  let started = false;
  for (const p of hi){
    if (Math.abs(p.x) > 20 || Math.abs(p.y) > 20) break;
    const px = X(p.x), py = Y(p.y);
    if (!started){ ctx.moveTo(px,py); started=true; }
    else ctx.lineTo(px,py);
  }
  ctx.stroke();

  // start point marker
  ctx.fillStyle = 'rgba(124,240,197,.95)';
  ctx.beginPath(); ctx.arc(X(x0Vec[0]), Y(x0Vec[1]), 6*dpr, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = 'rgba(0,0,0,.35)';
  ctx.lineWidth = 2; ctx.stroke();

  // arrow showing direction at start
  const v0 = mulA(A, x0Vec);
  const sp = Math.hypot(v0[0], v0[1]) + 1e-9;
  const ux = v0[0]/sp, uy = v0[1]/sp;
  const Ld = 0.55;
  const p1x = x0Vec[0], p1y = x0Vec[1];
  const p2x = p1x + Ld*ux, p2y = p1y + Ld*uy;
  const px1 = X(p1x), py1 = Y(p1y), px2 = X(p2x), py2 = Y(p2y);
  ctx.strokeStyle = 'rgba(124,240,197,.95)';
  ctx.lineWidth = 2.5;
  ctx.beginPath(); ctx.moveTo(px1,py1); ctx.lineTo(px2,py2); ctx.stroke();
  const ang = Math.atan2(py2-py1, px2-px1);
  const ah = 8*dpr;
  ctx.beginPath();
  ctx.moveTo(px2, py2);
  ctx.lineTo(px2 - ah*Math.cos(ang-0.5), py2 - ah*Math.sin(ang-0.5));
  ctx.lineTo(px2 - ah*Math.cos(ang+0.5), py2 - ah*Math.sin(ang+0.5));
  ctx.closePath();
  ctx.fillStyle = 'rgba(124,240,197,.95)';
  ctx.fill();
  ctx.restore();

  // Legend (simple)
  ctx.save();
  setText(ctx, 12*dpr, false);
  ctx.fillStyle = 'rgba(233,236,255,.85)';
  ctx.fillText('Faint: sample trajectories   Green: selected trajectory', box.x0, box.y0 - 12*dpr);
  ctx.restore();

  return hi; // for time plot
}

/* ========= Time series (canvas 3) ========= */
function drawTimeSeries(traj, tMax){
  const ctx = timeCanvas.getContext('2d');
  resizeCanvasToDisplaySize(timeCanvas);
  const W = timeCanvas.width, H = timeCanvas.height;
  clear(ctx, W, H);

  const dpr = getDPR();
  const padL = 54*dpr, padR = 22*dpr, padT = 34*dpr, padB = 44*dpr;
  const box = { x0: padL, y0: padT, w: W-padL-padR, h: H-padT-padB };

  // find y-range from trajectory
  let ymin = Infinity, ymax = -Infinity;
  for (const p of traj){
    ymin = Math.min(ymin, p.x, p.y);
    ymax = Math.max(ymax, p.x, p.y);
  }
  // pad
  const span = Math.max(1e-9, ymax-ymin);
  ymin -= 0.12*span;
  ymax += 0.12*span;

  function X(t){ return box.x0 + (t/ tMax)*box.w; }
  function Y(v){ return box.y0 + box.h - ((v - ymin)/(ymax - ymin))*box.h; }

  // background
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,.12)';
  ctx.fillRect(box.x0, box.y0, box.w, box.h);
  ctx.restore();

  // grid
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,.08)';
  ctx.lineWidth = 1;
  // vertical time grid
  const tSteps = 6;
  for (let i=0;i<=tSteps;i++){
    const t = (i/tSteps)*tMax;
    const x = X(t);
    ctx.beginPath(); ctx.moveTo(x, box.y0); ctx.lineTo(x, box.y0+box.h); ctx.stroke();
  }
  // horizontal value grid
  const vSteps = 5;
  for (let j=0;j<=vSteps;j++){
    const v = ymin + (j/vSteps)*(ymax-ymin);
    const y = Y(v);
    ctx.beginPath(); ctx.moveTo(box.x0, y); ctx.lineTo(box.x0+box.w, y); ctx.stroke();
  }
  ctx.restore();

  // axes border
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,.16)';
  ctx.lineWidth = 1.5;
  ctx.strokeRect(box.x0, box.y0, box.w, box.h);
  ctx.restore();

  // plot x(t)
  ctx.save();
  ctx.strokeStyle = 'rgba(124,240,197,.92)';
  ctx.lineWidth = 2.6;
  ctx.beginPath();
  for (let i=0;i<traj.length;i++){
    const p = traj[i];
    const px = X(p.t), py = Y(p.x);
    if (i===0) ctx.moveTo(px,py);
    else ctx.lineTo(px,py);
  }
  ctx.stroke();
  ctx.restore();

  // plot y(t)
  ctx.save();
  ctx.strokeStyle = 'rgba(141,183,255,.92)';
  ctx.lineWidth = 2.6;
  ctx.beginPath();
  for (let i=0;i<traj.length;i++){
    const p = traj[i];
    const px = X(p.t), py = Y(p.y);
    if (i===0) ctx.moveTo(px,py);
    else ctx.lineTo(px,py);
  }
  ctx.stroke();
  ctx.restore();

  // ticks + labels
  ctx.save();
  setText(ctx, 12*dpr, false);
  ctx.fillStyle = 'rgba(233,236,255,.80)';
  // time ticks
  for (let i=0;i<=tSteps;i++){
    const t = (i/tSteps)*tMax;
    ctx.fillText(fmt(t,1), X(t)-10*dpr, box.y0+box.h+18*dpr);
  }
  // value ticks (left)
  for (let j=0;j<=vSteps;j++){
    const v = ymin + (j/vSteps)*(ymax-ymin);
    ctx.fillText(fmt(v,2), box.x0-50*dpr, Y(v)+4*dpr);
  }
  setText(ctx, 13*dpr, true);
  ctx.fillStyle = 'rgba(233,236,255,.92)';
  ctx.fillText('t (arb. time units)', box.x0 + box.w - 120*dpr, box.y0 + box.h + 36*dpr);
  ctx.fillText('value', 8*dpr, box.y0 + 16*dpr);

  // legend
  const lx = box.x0 + 8*dpr, ly = box.y0 - 14*dpr;
  setText(ctx, 12*dpr, true);
  ctx.fillStyle = 'rgba(233,236,255,.86)';
  ctx.fillText('Legend:', lx, ly);
  // x(t)
  ctx.strokeStyle = 'rgba(124,240,197,.92)'; ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(lx+62*dpr, ly-4*dpr); ctx.lineTo(lx+88*dpr, ly-4*dpr); ctx.stroke();
  ctx.fillStyle = 'rgba(233,236,255,.86)'; setText(ctx, 12*dpr, false);
  ctx.fillText('x(t)', lx+94*dpr, ly);
  // y(t)
  ctx.strokeStyle = 'rgba(141,183,255,.92)'; ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(lx+140*dpr, ly-4*dpr); ctx.lineTo(lx+166*dpr, ly-4*dpr); ctx.stroke();
  ctx.fillText('y(t)', lx+172*dpr, ly);
  ctx.restore();
}

/* ========= UI wiring ========= */
const sysSel = document.getElementById('sysSel');
const sysLabel = document.getElementById('sysLabel');
const tMaxEl = document.getElementById('tMax');
const tMaxVal = document.getElementById('tMaxVal');
const r0El = document.getElementById('r0');
const r0Val = document.getElementById('r0Val');
const thEl = document.getElementById('theta');
const thVal = document.getElementById('thetaVal');
const fsEl = document.getElementById('fieldScale');
const fsVal = document.getElementById('fsVal');
const randBtn = document.getElementById('randBtn');

const tdText = document.getElementById('tdText');
const typeText = document.getElementById('typeText');

function updateLabels(){
  tMaxVal.textContent = fmt(parseFloat(tMaxEl.value),1);
  r0Val.textContent = fmt(parseFloat(r0El.value),2);
  thVal.textContent = String(parseInt(thEl.value,10));
  fsVal.textContent = fmt(parseFloat(fsEl.value),2);
  sysLabel.textContent = `(${sysSel.value})`;
}

function updateAll(){
  updateLabels();
  const key = sysSel.value;
  const A = systems[key].A;
  const info = classify(A);

  tdText.textContent = `τ=${fmt(info.tau,2)}, Δ=${fmt(info.delta,2)}, D=${fmt(info.D,2)}`;
  typeText.textContent = `${info.type} • ${info.stability} • structural: ${info.structural}`;

  // initial condition from sliders
  const r0 = parseFloat(r0El.value);
  const th = (parseFloat(thEl.value) * Math.PI)/180;
  const x0Vec = [r0*Math.cos(th), r0*Math.sin(th)];

  const tMax = parseFloat(tMaxEl.value);
  const fScale = parseFloat(fsEl.value);

  drawTraceDet(key);
  const traj = drawPhase(key, x0Vec, tMax, fScale);
  drawTimeSeries(traj, tMax);
}

function randomizeIC(){
  thEl.value = String(Math.floor(Math.random()*361));
  r0El.value = fmt(0.3 + Math.random()*2.7, 2);
  updateAll();
}

/* Copy buttons */
document.querySelectorAll('.copyBtn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const id = btn.getAttribute('data-copy');
    const el = document.getElementById(id);
    if (el) copyFromElement(el);
    btn.textContent = 'Copied!';
    setTimeout(()=>btn.textContent='Copy', 900);
  });
});
document.getElementById('copyAll').addEventListener('click', ()=>{
  const el = document.getElementById('eqFinal');
  copyFromElement(el);
  const b = document.getElementById('copyAll');
  b.textContent = 'Copied!';
  setTimeout(()=>b.textContent='Copy final answer (plain text)', 900);
});

/* Events */
sysSel.addEventListener('change', updateAll);
[tMaxEl, r0El, thEl, fsEl].forEach(el=> el.addEventListener('input', updateAll));
randBtn.addEventListener('click', randomizeIC);
window.addEventListener('resize', updateAll);

/* Initial render */
updateAll();
</script>
</body>
</html>
