<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nonlinear Spring (Hard vs Soft): Phase Portraits & Trajectories</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#101a33;
      --card2:#0f1730;
      --text:#e9eefc;
      --muted:#b8c2e6;
      --accent:#7aa7ff;
      --accent2:#7dffcf;
      --warn:#ffd27a;
      --danger:#ff7a9a;
      --grid:rgba(255,255,255,.10);
      --grid2:rgba(255,255,255,.06);
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 600px at 15% 10%, rgba(122,167,255,.18), transparent 55%),
        radial-gradient(900px 500px at 85% 20%, rgba(125,255,207,.12), transparent 50%),
        radial-gradient(800px 500px at 50% 80%, rgba(255,122,154,.10), transparent 60%),
        var(--bg);
      color:var(--text);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:32px 18px 10px;
      max-width:1200px;
      margin:0 auto;
    }
    .title{
      display:flex; align-items:flex-start; gap:14px; flex-wrap:wrap;
    }
    .badge{
      background:linear-gradient(135deg, rgba(122,167,255,.25), rgba(125,255,207,.18));
      border:1px solid rgba(255,255,255,.16);
      color:var(--text);
      padding:8px 12px;
      border-radius:999px;
      font-weight:700;
      letter-spacing:.2px;
      box-shadow:var(--shadow);
      user-select:none;
    }
    h1{
      margin:0;
      font-size:clamp(1.55rem, 1.25rem + 1.2vw, 2.4rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:10px 0 0;
      color:var(--muted);
      max-width:72ch;
    }
    main{
      max-width:1200px;
      margin:0 auto;
      padding:14px 18px 60px;
      display:grid;
      grid-template-columns: 1fr;
      gap:18px;
    }
    .layout{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns: 1fr}
    }
    .card{
      background:linear-gradient(180deg, rgba(16,26,51,.92), rgba(15,23,48,.92));
      border:1px solid rgba(255,255,255,.14);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding:14px 16px;
      border-bottom:1px solid rgba(255,255,255,.10);
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      background:rgba(255,255,255,.03);
    }
    .card .hd h2, .card .hd h3{
      margin:0;
      font-size:1.02rem;
      letter-spacing:.2px;
    }
    .card .bd{padding:16px}
    .toc{
      position:sticky; top:14px;
      padding:14px 14px 10px;
    }
    .toc h3{margin:0 0 10px; font-size:.95rem; color:var(--muted); letter-spacing:.3px}
    .toc a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      color:var(--text);
      border:1px solid transparent;
      transition:transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:.96rem;
    }
    .toc a:hover{
      background:rgba(122,167,255,.10);
      border-color:rgba(122,167,255,.25);
      transform:translateX(2px);
      text-decoration:none;
    }
    .hr{
      height:1px; background:rgba(255,255,255,.10); margin:12px 0;
    }
    .callouts{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:14px;
    }
    .callout{
      grid-column: span 6;
      background:rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      padding:14px 14px 12px;
    }
    @media (max-width: 980px){
      .callout{grid-column: span 12;}
    }
    .callout strong{display:block; margin-bottom:6px}
    .pill{
      display:inline-block;
      padding:2px 10px;
      border-radius:999px;
      font-size:.85rem;
      border:1px solid rgba(255,255,255,.14);
      color:var(--muted);
      background:rgba(255,255,255,.02);
      margin-left:8px;
      vertical-align:middle;
    }
    .eq{
      font-family:var(--mono);
      background:rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.14);
      border-radius:14px;
      padding:12px 12px;
      overflow:auto;
      position:relative;
    }
    .eq code{font-family:var(--mono); color:var(--text)}
    .copyRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    button.copy{
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:8px 10px;
      border-radius:12px;
      cursor:pointer;
      transition:transform .12s ease, background .12s ease, border-color .12s ease;
      font-weight:650;
      letter-spacing:.15px;
    }
    button.copy:hover{
      background:rgba(122,167,255,.12);
      border-color:rgba(122,167,255,.30);
      transform:translateY(-1px);
    }
    button.copy:active{transform:translateY(0px)}
    .okToast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform:translateX(-50%);
      background:rgba(16,26,51,.92);
      border:1px solid rgba(255,255,255,.18);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      box-shadow:var(--shadow);
      opacity:0;
      pointer-events:none;
      transition:opacity .20s ease, transform .20s ease;
      z-index:99;
    }
    .okToast.show{
      opacity:1;
      transform:translateX(-50%) translateY(-2px);
    }
    .grid2{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:18px;
    }
    @media (max-width: 980px){
      .grid2{grid-template-columns:1fr}
    }
    figure{margin:0}
    canvas{
      width:100%;
      height:auto;
      display:block;
      background:rgba(0,0,0,.18);
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 700px){
      .controls{grid-template-columns: 1fr}
    }
    label{
      display:block;
      font-size:.92rem;
      color:var(--muted);
      margin-bottom:6px;
      letter-spacing:.15px;
    }
    input[type="range"], select{
      width:100%;
      accent-color: var(--accent);
    }
    select{
      background:rgba(0,0,0,.22);
      color:var(--text);
      border:1px solid rgba(255,255,255,.18);
      padding:10px 10px;
      border-radius:12px;
    }
    .readable p{margin:10px 0}
    .readable ul{margin:10px 0 10px 18px}
    .readable li{margin:6px 0}
    .tagRow{display:flex; flex-wrap:wrap; gap:8px; margin:8px 0 0}
    .tag{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.02);
      color:var(--muted);
      padding:6px 10px;
      border-radius:999px;
      font-size:.86rem;
    }
    .box{
      padding:14px;
      border-radius:16px;
      background:linear-gradient(180deg, rgba(122,167,255,.10), rgba(125,255,207,.06));
      border:1px solid rgba(122,167,255,.20);
    }
    .final{
      border-left:4px solid rgba(125,255,207,.75);
      padding-left:12px;
      background:rgba(125,255,207,.06);
      border-radius:12px;
      padding:12px 12px;
      margin-top:10px;
    }
    .muted{color:var(--muted)}
    .small{font-size:.92rem}
    footer{
      max-width:1200px;
      margin:0 auto;
      padding:18px 18px 50px;
      color:var(--muted);
    }
    @media print{
      body{background:white; color:black}
      .card{box-shadow:none; border-color:#ddd}
      canvas{border-color:#ddd; background:white}
      .toc{position:relative; top:auto}
      button.copy{display:none}
      .okToast{display:none}
    }
  </style>
</head>
<body>
  <header>
    <div class="title">
      <div class="badge">Topic: Physical Models</div>
      <div>
        <h1>Nonlinear Spring: Hard vs Soft (Phase Portraits & Trajectories)</h1>
        <p class="subtitle">
          We analyze the nonlinear oscillator
          <span class="pill">m ẍ = −k x + c x³</span>
          by converting to a first-order system, sketching phase portraits, and deriving trajectory equations via energy.
          Interactive canvases below let you vary parameters and see <em>all</em> plots update live.
        </p>
      </div>
    </div>
  </header>

  <main class="layout">
    <!-- Sticky TOC -->
    <aside class="card toc" aria-label="Table of contents">
      <h3>Table of Contents</h3>
      <a href="#quick" data-scroll>Quick Summary</a>
      <a href="#viz" data-scroll>Interactive Visualizations</a>
      <a href="#part1" data-scroll>PART 1 — Problem Analysis</a>
      <a href="#part2" data-scroll>PART 2 — Strategy & Tips</a>
      <a href="#part3" data-scroll>PART 3 — Full Solution</a>
      <a href="#final" data-scroll>Final Results (Copy)</a>
      <div class="hr"></div>
      <div class="small muted">
        <div><strong>Units (demo plots):</strong></div>
        <div>x in m, v in m/s, m in kg, k in N/m, c in N/m³, energy in J.</div>
      </div>
    </aside>

    <section class="readable" aria-label="Main content">
      <!-- Quick Summary -->
      <article id="quick" class="card">
        <div class="hd"><h2>Quick Summary</h2></div>
        <div class="bd">
          <ul>
            <li>Companion system: <span class="eq"><code>x' = v,  v' = (−k x + c x³)/m</code></span>.</li>
            <li>Conserved energy (phase curves are level sets): <span class="eq"><code>E = ½ m v² + ½ k x² − ¼ c x⁴</code></span>.</li>
            <li><strong>Hard spring</strong> (<code>c &lt; 0</code>): potential grows faster than quadratic ⇒ all trajectories are closed ovals (nonlinear center at origin).</li>
            <li><strong>Soft spring</strong> (<code>c &gt; 0</code>): potential has a barrier; equilibria at <code>x = ±√(k/c)</code> are saddles; a separatrix encloses periodic motion.</li>
            <li>Trajectory equation in phase plane: <span class="eq"><code>v(x) = ±√[(2/m)(E − ½ k x² + ¼ c x⁴)]</code></span>.</li>
          </ul>
          <div class="copyRow">
            <button class="copy" data-copy="x' = v; v' = (-k*x + c*x^3)/m">Copy companion system</button>
            <button class="copy" data-copy="E = (1/2)*m*v^2 + (1/2)*k*x^2 - (1/4)*c*x^4 (constant along trajectories)">Copy energy</button>
          </div>
        </div>
      </article>

      <!-- Interactive Visualizations -->
      <article id="viz" class="card">
        <div class="hd">
          <h2>Interactive Visualizations (All update live)</h2>
          <div class="tagRow" aria-label="Status tags">
            <span class="tag" id="tagType">Type: —</span>
            <span class="tag" id="tagEq">Equilibria: —</span>
            <span class="tag" id="tagEnergy">Barrier energy (soft): —</span>
          </div>
        </div>
        <div class="bd">
          <div class="controls" role="group" aria-label="Controls">
            <div>
              <label for="cSlider">Nonlinearity parameter c (N/m³)</label>
              <input id="cSlider" type="range" min="-2" max="2" step="0.01" value="-0.8" />
              <div class="small muted">Current: <span id="cVal"></span></div>
            </div>
            <div>
              <label for="ampSlider">Initial amplitude A for demo trajectory (m)</label>
              <input id="ampSlider" type="range" min="0.1" max="2.2" step="0.01" value="1.0" />
              <div class="small muted">Current: <span id="aVal"></span></div>
            </div>
            <div>
              <label for="kSlider">Linear stiffness k (N/m)</label>
              <input id="kSlider" type="range" min="0.2" max="5" step="0.01" value="1.2" />
              <div class="small muted">Current: <span id="kVal"></span></div>
            </div>
            <div>
              <label for="mSlider">Mass m (kg)</label>
              <input id="mSlider" type="range" min="0.2" max="5" step="0.01" value="1.0" />
              <div class="small muted">Current: <span id="mVal"></span></div>
            </div>
          </div>

          <div class="grid2" style="margin-top:14px">
            <div class="card" style="background:transparent; border:none; box-shadow:none">
              <div class="hd" style="border-radius:16px; margin-bottom:10px">
                <h3>Diagram: Nonlinear Spring-Mass</h3>
              </div>
              <figure>
                <canvas id="diagramCanvas" width="900" height="520" aria-label="spring mass diagram"></canvas>
                <figcaption class="small muted" style="margin-top:8px">
                  Force model: <span class="eq"><code>F(x) = −k x + c x³</code></span> (rest at x=0). Positive x is to the right.
                </figcaption>
              </figure>
            </div>

            <div class="card" style="background:transparent; border:none; box-shadow:none">
              <div class="hd" style="border-radius:16px; margin-bottom:10px">
                <h3>Main Plot: Potential Energy U(x)</h3>
              </div>
              <figure>
                <canvas id="potentialCanvas" width="900" height="520" aria-label="potential plot"></canvas>
                <figcaption class="small muted" style="margin-top:8px">
                  For this conservative system, motion follows constant total energy <code>E = ½ m v² + U(x)</code>.
                </figcaption>
              </figure>
            </div>
          </div>

          <div class="grid2" style="margin-top:14px">
            <div class="card" style="background:transparent; border:none; box-shadow:none">
              <div class="hd" style="border-radius:16px; margin-bottom:10px">
                <h3>Plot: Phase Portrait (x vs v)</h3>
              </div>
              <figure>
                <canvas id="phaseCanvas" width="900" height="560" aria-label="phase portrait"></canvas>
                <figcaption class="small muted" style="margin-top:8px">
                  Vector field plus several trajectories (numerical RK4). Closed loops indicate periodic motion.
                </figcaption>
              </figure>
            </div>

            <div class="card" style="background:transparent; border:none; box-shadow:none">
              <div class="hd" style="border-radius:16px; margin-bottom:10px">
                <h3>Secondary Plot: Period T vs Amplitude A</h3>
              </div>
              <figure>
                <canvas id="periodCanvas" width="900" height="560" aria-label="period vs amplitude plot"></canvas>
                <figcaption class="small muted" style="margin-top:8px">
                  Computed by simulation + zero-crossing detection (demo). Hard springs (c&lt;0) tend to shorten the period with amplitude; soft springs (c&gt;0) tend to lengthen it (within the bounded region).
                </figcaption>
              </figure>
            </div>
          </div>
        </div>
      </article>

      <!-- PART 1 -->
      <article id="part1" class="card">
        <div class="hd"><h2>PART 1 — Problem Analysis (no solving yet)</h2></div>
        <div class="bd">
          <section>
            <h3>1) Restate the problem</h3>
            <p>
              We are given the nonlinear spring-mass model
              <span class="eq"><code>m ẍ = −k x + c x³</code></span>,
              where the cubic term either <em>adds to</em> the restoring force (hard spring, <code>c&lt;0</code>) or <em>opposes</em> it (soft spring, <code>c&gt;0</code>).
              We must:
            </p>
            <ul>
              <li>(a) Convert it into a first-order (companion) system.</li>
              <li>(b) Sketch/describe the phase portrait for hard and soft cases.</li>
              <li>(c) Derive equations for trajectories (phase curves) in the <code>(x,v)</code> plane.</li>
            </ul>
          </section>

          <section class="callouts" aria-label="Given and unknowns">
            <div class="callout">
              <strong>Given quantities</strong>
              <ul>
                <li>Mass <code>m &gt; 0</code> (kg)</li>
                <li>Linear stiffness <code>k &gt; 0</code> (N/m)</li>
                <li>Cubic coefficient <code>c</code> (N/m³), sign determines hard/soft</li>
                <li>State variable <code>x(t)</code> (m), velocity <code>ẋ(t)</code> (m/s)</li>
              </ul>
            </div>
            <div class="callout">
              <strong>Unknowns</strong>
              <ul>
                <li>First-order system in <code>(x,v)</code></li>
                <li>Qualitative phase portrait (equilibria, centers/saddles, separatrices)</li>
                <li>Trajectory (phase curve) equations relating <code>v</code> and <code>x</code></li>
              </ul>
            </div>
          </section>

          <section>
            <h3>2) Physical principles (and why they apply)</h3>
            <ul>
              <li>
                <strong>Newton’s 2nd law:</strong> the ODE is exactly <code>m ẍ = F(x)</code>, so dynamics are determined by position-dependent force.
              </li>
              <li>
                <strong>Conservative force &amp; energy conservation:</strong>
                the force depends only on <code>x</code>, so we can write <code>F(x) = −dU/dx</code> for some potential <code>U(x)</code>.
                That implies total energy <code>E = ½ m v² + U(x)</code> is constant along trajectories, which is the key to phase portraits and trajectory equations.
              </li>
              <li>
                <strong>Linearization near equilibria:</strong>
                for conservative 1-DOF systems, a stable equilibrium of the potential corresponds to a center in phase space; an unstable equilibrium corresponds to a saddle (separatrix structure).
              </li>
            </ul>
          </section>

          <section>
            <h3>3) Possible approaches</h3>
            <ul>
              <li>
                <strong>Approach A: Direct phase-plane analysis</strong> (convert to first order, find equilibria, linearize).
                Good for classifying fixed points, but doesn’t automatically give the full trajectory family.
              </li>
              <li>
                <strong>Approach B: Energy method</strong> (find potential and conserved energy).
                Immediately produces phase curves <code>E=const</code> and explains hard/soft portraits cleanly.
              </li>
              <li>
                <strong>Approach C: Solve as a Duffing oscillator</strong> (advanced: elliptic integrals).
                Gives explicit time dependence for some cases, but is overkill for what’s asked.
              </li>
            </ul>
            <p class="box">
              <strong>Best choice:</strong> Use the energy method + basic equilibrium/linearization.
              It’s the most efficient way to get both the phase portrait and the trajectory equations (part c).
            </p>
          </section>
        </div>
      </article>

      <!-- PART 2 -->
      <article id="part2" class="card">
        <div class="hd"><h2>PART 2 — Strategy & Tips (roadmap only)</h2></div>
        <div class="bd">
          <ol>
            <li>
              <strong>Rewrite as first-order system</strong>:
              set <code>v = ẋ</code> to obtain <code>x' = v</code>, <code>v' = …</code>.
            </li>
            <li>
              <strong>Identify equilibria</strong>:
              solve <code>v=0</code> and <code>−k x + c x³ = 0</code>.
            </li>
            <li>
              <strong>Linearize at equilibria</strong>:
              compute Jacobian and classify (center vs saddle).
            </li>
            <li>
              <strong>Find potential U(x)</strong>:
              enforce <code>F(x)=−dU/dx</code> with <code>F(x)=−k x + c x³</code>.
            </li>
            <li>
              <strong>Write conserved energy</strong>:
              <code>E = ½ m v² + U(x)</code>.
            </li>
            <li>
              <strong>Phase portrait from energy level sets</strong>:
              interpret <code>E=const</code> curves; find separatrix (soft case) at the saddle energy.
            </li>
            <li>
              <strong>Trajectory equations</strong>:
              solve the energy equation for <code>v(x)</code> (± branch).
            </li>
          </ol>

          <div class="callouts">
            <div class="callout">
              <strong>Common mistakes</strong>
              <ul>
                <li>Forgetting the sign when converting force to potential: <code>F=−dU/dx</code>.</li>
                <li>Misclassifying “hard/soft”: here hard means <code>c&lt;0</code> (extra restoring); soft means <code>c&gt;0</code> (weakens restoring at large |x|).</li>
                <li>Assuming all soft-spring trajectories are periodic—only those inside the separatrix are.</li>
              </ul>
            </div>
            <div class="callout">
              <strong>Quick tips</strong>
              <ul>
                <li>In a 1D conservative system, stable equilibria ↔ minima of <code>U(x)</code> ↔ centers in phase space.</li>
                <li>Separatrix energy equals the potential at the saddle point (soft case).</li>
                <li>Trajectory in phase plane is easiest as <code>v(x)</code> from energy, not by solving for <code>x(t)</code>.</li>
              </ul>
            </div>
          </div>
        </div>
      </article>

      <!-- PART 3 -->
      <article id="part3" class="card">
        <div class="hd"><h2>PART 3 — Full Solution</h2></div>
        <div class="bd">
          <section>
            <h3>Physical intuition</h3>
            <p>
              The force is <code>F(x)=−k x + c x³</code>. Near <code>x=0</code>, the linear term dominates, so the system behaves like a simple harmonic oscillator.
              For larger |x|:
            </p>
            <ul>
              <li><strong>Hard spring (<code>c&lt;0</code>):</strong> the cubic term is <code>c x³</code> with opposite sign of <code>x</code>, adding extra restoring force. The potential rises steeply, keeping motion bounded and periodic for all energies.</li>
              <li><strong>Soft spring (<code>c&gt;0</code>):</strong> the cubic term reduces the restoring force and eventually overwhelms it, making the force push outward for |x| large. This creates a potential barrier: small oscillations are periodic, but beyond a threshold energy the mass can “escape” to large |x|.</li>
            </ul>
          </section>

          <section>
            <h3>(a) Convert to a companion first-order system</h3>
            <p>Let the velocity be <code>v = ẋ</code>. Then <code>ẍ = v̇</code> and the ODE becomes:</p>
            <div class="eq">
              <code>
                x' = v<br/>
                v' = (−k x + c x³)/m
              </code>
            </div>
            <div class="copyRow">
              <button class="copy" data-copy="Let v = ẋ. Then x' = v and v' = (−k x + c x^3)/m.">Copy part (a)</button>
            </div>
          </section>

          <section>
            <h3>(b) Phase portrait for hard vs soft springs</h3>

            <h4>Step 1: Equilibria</h4>
            <p>
              Equilibria satisfy <code>x' = 0</code> and <code>v' = 0</code>, i.e.
              <code>v=0</code> and
              <code>−k x + c x³ = 0</code>.
            </p>
            <p>
              Factor:
              <span class="eq"><code>x(−k + c x²)=0</code></span>,
              so
            </p>
            <ul>
              <li><strong>Always:</strong> <code>(x,v)=(0,0)</code>.</li>
              <li><strong>If <code>c&gt;0</code> (soft):</strong> also <code>x=±√(k/c)</code>, giving equilibria <code>(±√(k/c), 0)</code>.</li>
              <li><strong>If <code>c&lt;0</code> (hard):</strong> no additional real equilibria.</li>
            </ul>

            <h4>Step 2: Linear classification</h4>
            <p>
              The system is
              <code>f(x,v)=(v, (−k x + c x³)/m)</code>.
              The Jacobian is
            </p>
            <div class="eq">
              <code>
                J(x,v)=
                [ 0&nbsp;&nbsp; 1 ]<br/>
                [ (−k + 3c x²)/m&nbsp;&nbsp; 0 ]
              </code>
            </div>
            <p>
              At an equilibrium <code>(x*,0)</code>, the eigenvalues satisfy
              <span class="eq"><code>λ² = (−k + 3c x*²)/m</code></span>.
            </p>

            <ul>
              <li>
                <strong>At the origin (<code>x*=0</code>):</strong>
                <code>λ² = −k/m &lt; 0</code> ⇒ <code>λ = ± i √(k/m)</code>.
                So the origin is a <strong>center</strong> (closed orbits) in the linearized system, and in this conservative system it remains a nonlinear center.
              </li>
              <li>
                <strong>Soft equilibria (<code>x* = ±√(k/c)</code>, only if <code>c&gt;0</code>):</strong>
                then <code>3c x*² = 3c(k/c)=3k</code>, so
                <code>λ² = (−k + 3k)/m = 2k/m &gt; 0</code>.
                Thus <code>λ</code> is real ⇒ these points are <strong>saddles</strong>.
              </li>
            </ul>

            <h4>Step 3: Energy picture (the clean “sketch”)</h4>
            <p>
              Because the force depends only on <code>x</code>, define a potential <code>U(x)</code> with <code>F(x)=−dU/dx</code>.
              Here <code>F(x)=−k x + c x³</code>, so
            </p>
            <div class="eq">
              <code>
                dU/dx = kx − c x³
                &nbsp;&nbsp;⇒&nbsp;&nbsp;
                U(x)= ½ k x² − ¼ c x⁴ + (constant).
              </code>
            </div>
            <p>We choose the constant so that <code>U(0)=0</code>.</p>

            <div class="callouts">
              <div class="callout">
                <strong>Hard spring (c&lt;0)</strong>
                <ul>
                  <li><code>U(x)=½ k x² + ¼ |c| x⁴</code> grows to +∞ as |x|→∞.</li>
                  <li>All energy level sets <code>E=½ m v² + U(x)</code> are closed loops around (0,0).</li>
                  <li>Phase portrait: a family of nested closed ovals (nonlinear center).</li>
                </ul>
              </div>
              <div class="callout">
                <strong>Soft spring (c&gt;0)</strong>
                <ul>
                  <li><code>U(x)=½ k x² − ¼ c x⁴</code> rises then turns down (→−∞ for large |x|).</li>
                  <li>Saddles at <code>x=±√(k/c)</code> define a separatrix.</li>
                  <li>Inside separatrix: closed loops (periodic). Outside: unbounded “escape” trajectories.</li>
                </ul>
              </div>
            </div>

            <p class="box">
              <strong>Key sketch features to include (soft case):</strong> center at origin; two saddles at <code>(±√(k/c),0)</code>; a figure-eight-like separatrix passing through the saddles that encloses the periodic region.
              (The interactive phase portrait above shows this structure numerically.)
            </p>
          </section>

          <section>
            <h3>(c) Equations for the trajectories (phase curves)</h3>
            <p>
              Start from energy conservation. Total energy:
            </p>
            <div class="eq">
              <code>
                E = ½ m v² + U(x)
                = ½ m v² + ½ k x² − ¼ c x⁴
                &nbsp;&nbsp;(constant along a trajectory).
              </code>
            </div>

            <p>
              Solve for <code>v</code> as a function of <code>x</code>:
            </p>
            <div class="eq">
              <code>
                ½ m v² = E − ½ k x² + ¼ c x⁴
                &nbsp;&nbsp;⇒&nbsp;&nbsp;
                v(x)= ± √[(2/m)(E − ½ k x² + ¼ c x⁴)].
              </code>
            </div>

            <p>
              This is the phase-plane trajectory equation. Each choice of constant <code>E</code> gives one curve.
              Turning points occur where <code>v=0</code>, i.e. where <code>E=U(x)</code>.
            </p>

            <h4>Soft case: separatrix (critical energy)</h4>
            <p>
              When <code>c&gt;0</code>, the saddle points occur at <code>x_s=±√(k/c)</code>.
              The separatrix corresponds to the energy level equal to the potential at the saddle:
            </p>
            <div class="eq">
              <code>
                E_s = U(x_s)
                = ½ k (k/c) − ¼ c (k/c)²
                = (k²/(2c)) − (k²/(4c))
                = k²/(4c).
              </code>
            </div>
            <p>
              So:
            </p>
            <ul>
              <li><strong>Periodic (bounded) motion</strong> happens when <code>E &lt; E_s = k²/(4c)</code>.</li>
              <li><strong>Separatrix</strong> is <code>E = E_s</code>, passing through the saddles.</li>
              <li><strong>Unbounded motion</strong> happens for <code>E &gt; E_s</code>.</li>
            </ul>

            <div class="final" id="final">
              <strong>Final results (symbolic):</strong>
              <div class="eq" style="margin-top:10px">
                <code>
                  (a) Companion system: x' = v, &nbsp; v' = (−k x + c x³)/m.<br/><br/>
                  (b) Hard (c&lt;0): only equilibrium (0,0), a nonlinear center; all trajectories are closed loops.<br/>
                      Soft (c&gt;0): equilibria (0,0) center and (±√(k/c),0) saddles; separatrix encloses periodic region.<br/><br/>
                  (c) Trajectories (phase curves): E = ½ m v² + ½ k x² − ¼ c x⁴ = constant,<br/>
                      equivalently v(x)= ± √[(2/m)(E − ½ k x² + ¼ c x⁴)].<br/>
                      Soft case separatrix energy: E_s = k²/(4c).
                </code>
              </div>
              <div class="copyRow">
                <button class="copy" data-copy="(a) x' = v, v' = (-k*x + c*x^3)/m.
(b) Hard (c<0): (0,0) is a nonlinear center; all orbits are closed loops.
    Soft (c>0): (0,0) is a center; (±sqrt(k/c),0) are saddles; separatrix encloses periodic region.
(c) Energy: E = (1/2)*m*v^2 + (1/2)*k*x^2 - (1/4)*c*x^4 = const.
    Trajectories: v(x) = ± sqrt((2/m)*(E - (1/2)*k*x^2 + (1/4)*c*x^4)).
    For c>0: separatrix energy E_s = k^2/(4c).">Copy final answer</button>
              </div>
            </div>

            <h4>Sanity checks</h4>
            <ul>
              <li><strong>Units:</strong> <code>½ m v²</code> is Joules; <code>½ k x²</code> is Joules; <code>¼ c x⁴</code> has units (N/m³)·m⁴ = N·m = J. Consistent.</li>
              <li>
                <strong>Limiting case c → 0:</strong> energy reduces to <code>E = ½ m v² + ½ k x²</code>, so phase curves are ellipses and
                <code>v=±√[(2/m)(E − ½ k x²)]</code>, the familiar harmonic oscillator.
              </li>
              <li>
                <strong>Physical interpretation:</strong> phase curves are simply constant-energy contours.
                Hard springs trap energy more strongly (steeper potential); soft springs create a finite barrier energy where oscillations stop being confined.
              </li>
            </ul>
          </section>
        </div>
      </article>
    </section>
  </main>

  <footer>
    <div class="card">
      <div class="bd">
        <strong>Note on the demo plots:</strong>
        <span class="muted">The interactive canvases use “example values” (your chosen sliders) and numerical integration (RK4). The analytic results above remain symbolic and exact.</span>
      </div>
    </div>
  </footer>

  <div class="okToast" id="toast" role="status" aria-live="polite">Copied.</div>

  <script>
    // ---------------------------
    // Smooth scrolling for TOC
    // ---------------------------
    (function(){
      const links = document.querySelectorAll('[data-scroll]');
      links.forEach(a=>{
        a.addEventListener('click', (e)=>{
          e.preventDefault();
          const id = a.getAttribute('href');
          const el = document.querySelector(id);
          if(!el) return;
          el.scrollIntoView({behavior:'smooth', block:'start'});
        });
      });
    })();

    // ---------------------------
    // Copy buttons
    // ---------------------------
    (function(){
      const toast = document.getElementById('toast');
      let tId = null;
      function showToast(msg){
        toast.textContent = msg || 'Copied.';
        toast.classList.add('show');
        if(tId) clearTimeout(tId);
        tId = setTimeout(()=>toast.classList.remove('show'), 1100);
      }
      document.querySelectorAll('button.copy').forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          const text = btn.getAttribute('data-copy') || '';
          try{
            await navigator.clipboard.writeText(text);
            showToast('Copied to clipboard.');
          }catch(err){
            // Fallback
            const ta = document.createElement('textarea');
            ta.value = text;
            ta.style.position = 'fixed';
            ta.style.left = '-9999px';
            document.body.appendChild(ta);
            ta.select();
            try{ document.execCommand('copy'); showToast('Copied to clipboard.'); }
            catch(e){ showToast('Copy failed.'); }
            document.body.removeChild(ta);
          }
        });
      });
    })();

    // ---------------------------
    // Canvas helpers
    // ---------------------------
    function setupHiDPICanvas(canvas){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const aspect = canvas.height / canvas.width;
      const h = Math.max(1, Math.floor(w * aspect));
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {ctx, w, h, dpr};
    }

    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
      const {x, y, w, h, pad} = box;
      // background
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.18)';
      roundRect(ctx, x, y, w, h, 14);
      ctx.fill();

      // title
      ctx.fillStyle = 'rgba(233,238,252,0.92)';
      ctx.font = '600 14px ui-sans-serif, system-ui';
      ctx.fillText(title, x + pad, y + 18);

      // plot area
      const px = x + pad, py = y + 28, pw = w - 2*pad, ph = h - (28 + pad);
      ctx.strokeStyle = 'rgba(255,255,255,0.10)';
      ctx.lineWidth = 1;
      ctx.strokeRect(px, py, pw, ph);

      // grid + ticks
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.fillStyle = 'rgba(184,194,230,0.85)';
      ctx.strokeStyle = 'rgba(255,255,255,0.07)';
      ctx.lineWidth = 1;

      const nTicks = 5;
      for(let i=0;i<=nTicks;i++){
        const tx = px + (pw*i/nTicks);
        const ty = py + (ph*i/nTicks);

        // vertical grid
        ctx.beginPath();
        ctx.moveTo(tx, py);
        ctx.lineTo(tx, py+ph);
        ctx.stroke();

        // horizontal grid
        ctx.beginPath();
        ctx.moveTo(px, ty);
        ctx.lineTo(px+pw, ty);
        ctx.stroke();

        // x tick label
        const xv = xMin + (xMax-xMin)*i/nTicks;
        const xs = formatNum(xv);
        ctx.fillText(xs, tx - ctx.measureText(xs).width/2, py+ph+16);

        // y tick label (top to bottom)
        const yv = yMax - (yMax-yMin)*i/nTicks;
        const ys = formatNum(yv);
        ctx.fillText(ys, px - ctx.measureText(ys).width - 6, ty + 4);
      }

      // axis labels
      ctx.fillStyle = 'rgba(233,238,252,0.9)';
      ctx.font = '600 12px ui-sans-serif, system-ui';
      ctx.fillText(xLabel, px + pw/2 - ctx.measureText(xLabel).width/2, y + h - 8);

      // rotated y label
      ctx.save();
      ctx.translate(x + 12, py + ph/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
      ctx.restore();

      ctx.restore();
      return {px, py, pw, ph};
    }

    function worldToScreenX(x, xMin, xMax, px, pw){
      return px + (x - xMin) * pw / (xMax - xMin);
    }
    function worldToScreenY(y, yMin, yMax, py, ph){
      return py + (yMax - y) * ph / (yMax - yMin);
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function formatNum(v){
      if(!isFinite(v)) return '—';
      const av = Math.abs(v);
      if(av >= 1000 || (av > 0 && av < 0.001)) return v.toExponential(2);
      if(av >= 10) return v.toFixed(2);
      if(av >= 1) return v.toFixed(3);
      return v.toFixed(4);
    }

    // ---------------------------
    // Dynamics: x' = v, v' = (-k x + c x^3)/m
    // RK4 integrator
    // ---------------------------
    function deriv(state, p){
      const x = state[0], v = state[1];
      return [v, (-p.k*x + p.c*x*x*x)/p.m];
    }
    function rk4Step(state, dt, p){
      const k1 = deriv(state, p);
      const s2 = [state[0] + 0.5*dt*k1[0], state[1] + 0.5*dt*k1[1]];
      const k2 = deriv(s2, p);
      const s3 = [state[0] + 0.5*dt*k2[0], state[1] + 0.5*dt*k2[1]];
      const k3 = deriv(s3, p);
      const s4 = [state[0] + dt*k3[0], state[1] + dt*k3[1]];
      const k4 = deriv(s4, p);
      return [
        state[0] + (dt/6)*(k1[0] + 2*k2[0] + 2*k3[0] + k4[0]),
        state[1] + (dt/6)*(k1[1] + 2*k2[1] + 2*k3[1] + k4[1])
      ];
    }

    function potentialU(x, p){
      return 0.5*p.k*x*x - 0.25*p.c*Math.pow(x,4);
    }
    function energyE(state, p){
      const x = state[0], v = state[1];
      return 0.5*p.m*v*v + potentialU(x, p);
    }

    // Period estimation via simulation: start at (A,0), measure two same-direction zero-crossings of x
    function estimatePeriod(A, p){
      // For soft spring: if outside bounded region (A beyond saddle), period isn't meaningful
      if(p.c > 0){
        const xs = Math.sqrt(p.k / p.c);
        if(A >= xs) return NaN;
      }
      let state = [A, 0];
      const dt = 0.0025 * Math.sqrt(p.m / Math.max(1e-6, p.k)); // scaled
      const maxT = 200 * Math.sqrt(p.m / Math.max(1e-6, p.k));
      let t = 0;

      // We want crossings x=0 with v>0 (one direction), twice => one period.
      let crossings = [];
      let prev = state.slice();
      let prevX = prev[0];

      // kick slightly to avoid sitting at turning point symmetry issues in rare cases
      // (still conservative enough for demo)
      state = rk4Step(state, dt, p);
      t += dt;
      prevX = state[0];
      prev = state.slice();

      while(t < maxT && crossings.length < 2){
        const next = rk4Step(state, dt, p);
        t += dt;

        const x0 = state[0], x1 = next[0];
        const v1 = next[1];

        // detect sign change crossing around x=0
        if((x0 === 0) || (x0 < 0 && x1 > 0) || (x0 > 0 && x1 < 0)){
          // linear interpolation to estimate crossing time
          const alpha = (0 - x0) / (x1 - x0 + 1e-16);
          const tcross = t - dt + alpha*dt;
          const vcross = state[1] + alpha*(next[1] - state[1]);

          // take only v>0 direction to define a full period
          if(vcross > 0){
            crossings.push(tcross);
          }
        }

        state = next;

        // If it escapes too far, abort (soft case or numerical blow-up)
        if(Math.abs(state[0]) > 20 || Math.abs(state[1]) > 60) return NaN;
      }

      if(crossings.length < 2) return NaN;
      return crossings[1] - crossings[0];
    }

    // ---------------------------
    // Draw: Diagram
    // ---------------------------
    function drawDiagram(canvas, p){
      const {ctx, w, h} = setupHiDPICanvas(canvas);
      ctx.clearRect(0,0,w,h);

      const pad = 18;
      const box = {x:0, y:0, w:w, h:h, pad:18};
      // background panel
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.16)';
      roundRect(ctx, box.x+2, box.y+2, box.w-4, box.h-4, 16);
      ctx.fill();
      ctx.restore();

      // Coordinates
      const midY = h*0.55;
      const wallX = pad + 30;
      const massW = Math.min(170, w*0.22);
      const massH = Math.min(120, h*0.20);
      const restX = w*0.55;
      const x = p.A; // show as displacement scale
      const scale = Math.min(w*0.18, 140) / 2.2; // map meters to pixels
      const massX = restX + x*scale;

      // Wall
      ctx.save();
      ctx.fillStyle = 'rgba(233,238,252,0.9)';
      ctx.globalAlpha = 0.12;
      ctx.fillRect(wallX-18, midY-massH*0.9, 18, massH*1.8);
      ctx.globalAlpha = 1;
      ctx.strokeStyle = 'rgba(233,238,252,0.55)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(wallX, midY-massH*0.95);
      ctx.lineTo(wallX, midY+massH*0.95);
      ctx.stroke();
      // wall hatch
      ctx.strokeStyle = 'rgba(233,238,252,0.20)';
      for(let i=0;i<16;i++){
        const y0 = midY-massH*0.95 + i*(massH*1.9/16);
        ctx.beginPath();
        ctx.moveTo(wallX-16, y0);
        ctx.lineTo(wallX, y0+8);
        ctx.stroke();
      }
      ctx.restore();

      // Spring (zigzag)
      const springStartX = wallX;
      const springEndX = massX - massW/2 - 10;
      const coils = 10;
      const amp = 14;
      ctx.save();
      ctx.strokeStyle = 'rgba(122,167,255,0.9)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(springStartX, midY);
      const L = springEndX - springStartX;
      for(let i=1;i<=coils;i++){
        const t = i/coils;
        const xx = springStartX + t*L;
        const yy = midY + (i%2===0 ? -amp : amp);
        ctx.lineTo(xx, yy);
      }
      ctx.lineTo(springEndX, midY);
      ctx.stroke();
      ctx.restore();

      // Mass block
      ctx.save();
      ctx.fillStyle = 'rgba(125,255,207,0.14)';
      ctx.strokeStyle = 'rgba(125,255,207,0.65)';
      ctx.lineWidth = 2.5;
      roundRect(ctx, massX-massW/2, midY-massH/2, massW, massH, 18);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = 'rgba(233,238,252,0.92)';
      ctx.font = '700 14px ui-sans-serif, system-ui';
      ctx.fillText('m', massX-5, midY+5);
      ctx.restore();

      // Axis indicator and displacement
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.28)';
      ctx.lineWidth = 1.5;
      // baseline
      ctx.beginPath();
      ctx.moveTo(w*0.14, midY+massH*0.8);
      ctx.lineTo(w*0.88, midY+massH*0.8);
      ctx.stroke();

      // rest marker at x=0 (rest position)
      const restMarkerX = restX;
      ctx.strokeStyle = 'rgba(255,255,255,0.22)';
      ctx.beginPath();
      ctx.moveTo(restMarkerX, midY+massH*0.8-18);
      ctx.lineTo(restMarkerX, midY+massH*0.8+18);
      ctx.stroke();

      // arrow showing x displacement
      const arrowY = midY+massH*0.8-34;
      ctx.strokeStyle = 'rgba(255,210,122,0.85)';
      ctx.fillStyle = 'rgba(255,210,122,0.85)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(restMarkerX, arrowY);
      ctx.lineTo(massX, arrowY);
      ctx.stroke();
      drawArrowHead(ctx, massX, arrowY, Math.sign(massX-restMarkerX) || 1, 0);

      ctx.fillStyle = 'rgba(255,210,122,0.9)';
      ctx.font = '600 12px ui-sans-serif, system-ui';
      const lab = 'x (m)';
      ctx.fillText(lab, (restMarkerX+massX)/2 - ctx.measureText(lab).width/2, arrowY-8);

      // Force label
      ctx.fillStyle = 'rgba(233,238,252,0.92)';
      ctx.font = '600 13px ui-sans-serif, system-ui';
      const ftxt = `F(x) = −k x + c x³`;
      ctx.fillText(ftxt, pad+10, pad+20);

      // Parameter readout
      ctx.fillStyle = 'rgba(184,194,230,0.92)';
      ctx.font = '12px ui-sans-serif, system-ui';
      const line1 = `Example values: m = ${formatNum(p.m)} kg, k = ${formatNum(p.k)} N/m, c = ${formatNum(p.c)} N/m³`;
      const line2 = `Shown displacement: x = ${formatNum(p.A)} m`;
      ctx.fillText(line1, pad+10, pad+40);
      ctx.fillText(line2, pad+10, pad+58);

      ctx.restore();
    }

    function drawArrowHead(ctx, x, y, dx, dy){
      // dx,dy define direction unit-ish
      const ang = Math.atan2(dy, dx);
      const size = 7;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x - size*Math.cos(ang - 0.45), y - size*Math.sin(ang - 0.45));
      ctx.lineTo(x - size*Math.cos(ang + 0.45), y - size*Math.sin(ang + 0.45));
      ctx.closePath();
      ctx.fill();
    }

    // ---------------------------
    // Draw: Potential plot
    // ---------------------------
    function drawPotential(canvas, p){
      const {ctx, w, h} = setupHiDPICanvas(canvas);
      ctx.clearRect(0,0,w,h);

      // Choose x-range based on soft saddle if applicable
      let xMax = 2.3;
      if(p.c > 0){
        const xs = Math.sqrt(p.k / p.c);
        xMax = Math.max(1.2, Math.min(3.0, xs*1.6));
      }
      const xMin = -xMax;

      // y-range from sampling
      let yMin = Infinity, yMax = -Infinity;
      const N = 400;
      for(let i=0;i<=N;i++){
        const x = xMin + (xMax-xMin)*i/N;
        const u = potentialU(x, p);
        yMin = Math.min(yMin, u);
        yMax = Math.max(yMax, u);
      }
      // pad y-range
      const span = (yMax-yMin) || 1;
      yMin -= 0.12*span;
      yMax += 0.18*span;

      const pad = 44;
      const plot = drawAxes(ctx, {x:10,y:10,w:w-20,h:h-20,pad:pad},
        xMin, xMax, yMin, yMax,
        "x (m)", "U(x) (J)", "Potential Energy: U(x)=½kx²−¼cx⁴"
      );

      // Draw curve
      ctx.save();
      ctx.lineWidth = 2.5;
      ctx.strokeStyle = 'rgba(125,255,207,0.9)';
      ctx.beginPath();
      for(let i=0;i<=N;i++){
        const x = xMin + (xMax-xMin)*i/N;
        const u = potentialU(x, p);
        const sx = worldToScreenX(x, xMin, xMax, plot.px, plot.pw);
        const sy = worldToScreenY(u, yMin, yMax, plot.py, plot.ph);
        if(i===0) ctx.moveTo(sx, sy);
        else ctx.lineTo(sx, sy);
      }
      ctx.stroke();

      // Mark equilibrium points
      const eqPts = [];
      eqPts.push(0);
      if(p.c > 0){
        const xs = Math.sqrt(p.k/p.c);
        eqPts.push(xs, -xs);
      }
      ctx.fillStyle = 'rgba(255,210,122,0.92)';
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx.lineWidth = 1.5;
      eqPts.forEach(xe=>{
        const ue = potentialU(xe, p);
        if(xe < xMin || xe > xMax || ue < yMin || ue > yMax) return;
        const sx = worldToScreenX(xe, xMin, xMax, plot.px, plot.pw);
        const sy = worldToScreenY(ue, yMin, yMax, plot.py, plot.ph);
        ctx.beginPath();
        ctx.arc(sx, sy, 5, 0, Math.PI*2);
        ctx.fill();
      });

      // Draw energy level for demo trajectory E(A,0)
      const E0 = energyE([p.A, 0], p);
      if(isFinite(E0)){
        const syE = worldToScreenY(E0, yMin, yMax, plot.py, plot.ph);
        ctx.strokeStyle = 'rgba(122,167,255,0.75)';
        ctx.setLineDash([6,4]);
        ctx.beginPath();
        ctx.moveTo(plot.px, syE);
        ctx.lineTo(plot.px+plot.pw, syE);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.fillStyle = 'rgba(122,167,255,0.9)';
        ctx.font = '600 12px ui-sans-serif, system-ui';
        const lab = `E (demo) = ${formatNum(E0)} J`;
        ctx.fillText(lab, plot.px+10, Math.max(plot.py+14, syE-8));
      }

      // Legend
      ctx.fillStyle = 'rgba(233,238,252,0.92)';
      ctx.font = '600 12px ui-sans-serif, system-ui';
      const lgx = plot.px + 10, lgy = plot.py + 18;
      ctx.fillText("Legend:", lgx, lgy);
      ctx.strokeStyle = 'rgba(125,255,207,0.9)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(lgx+64, lgy-4);
      ctx.lineTo(lgx+94, lgy-4);
      ctx.stroke();
      ctx.fillStyle = 'rgba(233,238,252,0.86)';
      ctx.fillText("U(x)", lgx+102, lgy);

      ctx.strokeStyle = 'rgba(122,167,255,0.75)';
      ctx.setLineDash([6,4]);
      ctx.beginPath();
      ctx.moveTo(lgx+64, lgy+14);
      ctx.lineTo(lgx+94, lgy+14);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillText("E (demo)", lgx+102, lgy+18);

      ctx.restore();
    }

    // ---------------------------
    // Draw: Phase portrait
    // ---------------------------
    function drawPhase(canvas, p){
      const {ctx, w, h} = setupHiDPICanvas(canvas);
      ctx.clearRect(0,0,w,h);

      // Set ranges
      let xRange = 2.4;
      if(p.c > 0){
        const xs = Math.sqrt(p.k/p.c);
        xRange = Math.max(1.2, Math.min(3.2, xs*1.6));
      }
      xRange = Math.max(xRange, Math.abs(p.A)*1.2);

      const vRange = 3.0 * Math.sqrt(p.k/p.m) * xRange; // rough
      const xMin = -xRange, xMax = xRange;
      const yMin = -vRange, yMax = vRange;

      const pad = 44;
      const plot = drawAxes(ctx, {x:10,y:10,w:w-20,h:h-20,pad:pad},
        xMin, xMax, yMin, yMax,
        "x (m)", "v (m/s)", "Phase Portrait: x' = v,  v' = (−kx+cx³)/m"
      );

      // Draw vector field
      const nx = 15, ny = 13;
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 1.2;

      // Normalize arrow lengths by max magnitude at sample points
      let maxMag = 1e-9;
      for(let j=0;j<ny;j++){
        for(let i=0;i<nx;i++){
          const x = xMin + (xMax-xMin)*(i+0.5)/nx;
          const v = yMin + (yMax-yMin)*(j+0.5)/ny;
          const dx = v;
          const dv = (-p.k*x + p.c*x*x*x)/p.m;
          const mag = Math.hypot(dx, dv);
          if(mag > maxMag) maxMag = mag;
        }
      }
      const arrowLen = Math.min(plot.pw/nx, plot.ph/ny) * 0.45;

      for(let j=0;j<ny;j++){
        for(let i=0;i<nx;i++){
          const x = xMin + (xMax-xMin)*(i+0.5)/nx;
          const v = yMin + (yMax-yMin)*(j+0.5)/ny;
          const dx = v;
          const dv = (-p.k*x + p.c*x*x*x)/p.m;
          const mag = Math.hypot(dx, dv) / maxMag;
          const ux = dx / (Math.hypot(dx,dv)+1e-12);
          const uy = dv / (Math.hypot(dx,dv)+1e-12);

          const sx = worldToScreenX(x, xMin, xMax, plot.px, plot.pw);
          const sy = worldToScreenY(v, yMin, yMax, plot.py, plot.ph);
          const L = arrowLen * (0.22 + 0.78*mag);

          const ex = sx + ux*L;
          const ey = sy - uy*L; // screen y inverted

          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(ex, ey);
          ctx.stroke();

          // tiny head
          ctx.save();
          ctx.translate(ex, ey);
          const ang = Math.atan2(-(uy), ux);
          ctx.rotate(ang);
          ctx.beginPath();
          ctx.moveTo(0,0);
          ctx.lineTo(-5, -2.2);
          ctx.lineTo(-5,  2.2);
          ctx.closePath();
          ctx.fillStyle = 'rgba(255,255,255,0.18)';
          ctx.fill();
          ctx.restore();
        }
      }
      ctx.restore();

      // Equilibria markers
      const eqs = [{x:0, v:0, type:'center'}];
      if(p.c > 0){
        const xs = Math.sqrt(p.k/p.c);
        eqs.push({x:xs, v:0, type:'saddle'});
        eqs.push({x:-xs, v:0, type:'saddle'});
      }
      eqs.forEach(e=>{
        const sx = worldToScreenX(e.x, xMin, xMax, plot.px, plot.pw);
        const sy = worldToScreenY(e.v, yMin, yMax, plot.py, plot.ph);
        ctx.save();
        ctx.beginPath();
        ctx.arc(sx, sy, 6, 0, Math.PI*2);
        ctx.fillStyle = e.type==='center' ? 'rgba(125,255,207,0.95)' : 'rgba(255,122,154,0.92)';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.stroke();
        ctx.restore();
      });

      // Trajectories (numerical)
      const seeds = [];
      const A = p.A;
      seeds.push([A, 0]);
      seeds.push([0.6*A, 0]);
      seeds.push([1.2*A, 0]);
      seeds.push([0.0, 0.8*Math.sqrt(p.k/p.m)*A]); // some velocity-start

      // For soft case: keep seeds inside bounded region if possible
      if(p.c > 0){
        const xs = Math.sqrt(p.k/p.c);
        for(let s=0;s<seeds.length;s++){
          seeds[s][0] = Math.min(Math.abs(seeds[s][0]), xs*0.92) * Math.sign(seeds[s][0]||1);
        }
      }

      const colors = [
        'rgba(122,167,255,0.95)',
        'rgba(125,255,207,0.90)',
        'rgba(255,210,122,0.90)',
        'rgba(255,122,154,0.86)'
      ];

      for(let si=0;si<seeds.length;si++){
        const s0 = seeds[si].slice();
        const dt = 0.004 * Math.sqrt(p.m/Math.max(1e-6,p.k));
        const steps = 4500;
        let state = s0;

        ctx.save();
        ctx.strokeStyle = colors[si%colors.length];
        ctx.lineWidth = 2.2;
        ctx.beginPath();

        let started = false;
        for(let n=0;n<steps;n++){
          const x = state[0], v = state[1];
          // Stop if far away
          if(Math.abs(x) > 20 || Math.abs(v) > 60) break;

          const sx = worldToScreenX(x, xMin, xMax, plot.px, plot.pw);
          const sy = worldToScreenY(v, yMin, yMax, plot.py, plot.ph);
          if(!started){ ctx.moveTo(sx, sy); started = true; }
          else ctx.lineTo(sx, sy);

          state = rk4Step(state, dt, p);
        }
        ctx.stroke();
        ctx.restore();
      }

      // Legend
      ctx.save();
      ctx.font = '600 12px ui-sans-serif, system-ui';
      ctx.fillStyle = 'rgba(233,238,252,0.92)';
      const lx = plot.px + 10, ly = plot.py + 18;
      ctx.fillText('Legend:', lx, ly);

      // center/saddle swatches
      ctx.beginPath(); ctx.arc(lx+70, ly-4, 5, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(125,255,207,0.95)'; ctx.fill();
      ctx.fillStyle = 'rgba(233,238,252,0.86)';
      ctx.fillText('center', lx+82, ly);

      ctx.beginPath(); ctx.arc(lx+150, ly-4, 5, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,122,154,0.92)'; ctx.fill();
      ctx.fillStyle = 'rgba(233,238,252,0.86)';
      ctx.fillText('saddle', lx+162, ly);

      // trajectory swatches
      let y2 = ly+18;
      for(let i=0;i<Math.min(4,seeds.length);i++){
        ctx.strokeStyle = colors[i%colors.length];
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(lx+70, y2-4);
        ctx.lineTo(lx+100, y2-4);
        ctx.stroke();
        ctx.fillStyle = 'rgba(233,238,252,0.86)';
        ctx.fillText(`traj ${i+1}`, lx+108, y2);
        y2 += 16;
      }

      ctx.restore();
    }

    // ---------------------------
    // Draw: Period vs Amplitude
    // ---------------------------
    function drawPeriod(canvas, p){
      const {ctx, w, h} = setupHiDPICanvas(canvas);
      ctx.clearRect(0,0,w,h);

      // amplitude range
      let Amax = 2.2;
      if(p.c > 0){
        const xs = Math.sqrt(p.k/p.c);
        Amax = Math.min(Amax, xs*0.95);
        Amax = Math.max(0.25, Amax);
      }
      const Amin = 0.10;

      // compute periods
      const N = 18;
      const data = [];
      let tMin = Infinity, tMax = -Infinity;

      for(let i=0;i<=N;i++){
        const A = Amin + (Amax-Amin)*i/N;
        const T = estimatePeriod(A, p);
        data.push({A, T});
        if(isFinite(T)){
          tMin = Math.min(tMin, T);
          tMax = Math.max(tMax, T);
        }
      }

      // fallback y-range if all NaN
      if(!isFinite(tMin) || !isFinite(tMax)){
        tMin = 0; tMax = 10;
      }
      // pad
      const span = (tMax-tMin) || 1;
      tMin -= 0.12*span;
      tMax += 0.18*span;

      const pad = 44;
      const plot = drawAxes(ctx, {x:10,y:10,w:w-20,h:h-20,pad:pad},
        Amin, Amax, tMin, tMax,
        "Amplitude A (m)", "Period T (s)", "Period vs Amplitude (computed)"
      );

      // curve
      ctx.save();
      ctx.strokeStyle = 'rgba(122,167,255,0.95)';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      let started = false;
      for(const pt of data){
        if(!isFinite(pt.T)) { started = false; continue; }
        const sx = worldToScreenX(pt.A, Amin, Amax, plot.px, plot.pw);
        const sy = worldToScreenY(pt.T, tMin, tMax, plot.py, plot.ph);
        if(!started){ ctx.moveTo(sx, sy); started = true; }
        else ctx.lineTo(sx, sy);
      }
      ctx.stroke();

      // points
      ctx.fillStyle = 'rgba(125,255,207,0.92)';
      for(const pt of data){
        if(!isFinite(pt.T)) continue;
        const sx = worldToScreenX(pt.A, Amin, Amax, plot.px, plot.pw);
        const sy = worldToScreenY(pt.T, tMin, tMax, plot.py, plot.ph);
        ctx.beginPath();
        ctx.arc(sx, sy, 3.5, 0, Math.PI*2);
        ctx.fill();
      }

      // small-amplitude reference T0 = 2π sqrt(m/k)
      const T0 = 2*Math.PI*Math.sqrt(p.m/Math.max(1e-9,p.k));
      if(isFinite(T0)){
        const yRef = worldToScreenY(T0, tMin, tMax, plot.py, plot.ph);
        ctx.strokeStyle = 'rgba(255,210,122,0.75)';
        ctx.setLineDash([6,4]);
        ctx.beginPath();
        ctx.moveTo(plot.px, yRef);
        ctx.lineTo(plot.px+plot.pw, yRef);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.fillStyle = 'rgba(255,210,122,0.92)';
        ctx.font = '600 12px ui-sans-serif, system-ui';
        ctx.fillText(`T₀ = 2π√(m/k) = ${formatNum(T0)} s`, plot.px+10, Math.max(plot.py+14, yRef-8));
      }

      // highlight current A
      const Acur = Math.min(Math.max(p.A, Amin), Amax);
      const Tcur = estimatePeriod(Acur, p);
      if(isFinite(Tcur)){
        const sx = worldToScreenX(Acur, Amin, Amax, plot.px, plot.pw);
        const sy = worldToScreenY(Tcur, tMin, tMax, plot.py, plot.ph);
        ctx.strokeStyle = 'rgba(255,122,154,0.9)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(sx, sy, 7, 0, Math.PI*2);
        ctx.stroke();

        ctx.fillStyle = 'rgba(233,238,252,0.92)';
        ctx.font = '600 12px ui-sans-serif, system-ui';
        const lab = `At A=${formatNum(Acur)} m: T≈${formatNum(Tcur)} s`;
        ctx.fillText(lab, plot.px+10, plot.py+plot.ph-10);
      } else {
        ctx.fillStyle = 'rgba(233,238,252,0.86)';
        ctx.font = '600 12px ui-sans-serif, system-ui';
        ctx.fillText('Period undefined here (likely outside bounded region for soft spring).', plot.px+10, plot.py+plot.ph-10);
      }

      // legend
      ctx.fillStyle = 'rgba(233,238,252,0.92)';
      ctx.font = '600 12px ui-sans-serif, system-ui';
      const lx = plot.px + 10, ly = plot.py + 18;
      ctx.fillText('Legend:', lx, ly);
      ctx.strokeStyle = 'rgba(122,167,255,0.95)';
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(lx+64, ly-4); ctx.lineTo(lx+94, ly-4); ctx.stroke();
      ctx.fillStyle = 'rgba(233,238,252,0.86)'; ctx.fillText('T(A) (sim)', lx+102, ly);
      ctx.strokeStyle = 'rgba(255,210,122,0.75)';
      ctx.setLineDash([6,4]);
      ctx.beginPath(); ctx.moveTo(lx+64, ly+14); ctx.lineTo(lx+94, ly+14); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillText('T₀', lx+102, ly+18);

      ctx.restore();
    }

    // ---------------------------
    // UI state + updates
    // ---------------------------
    const els = {
      c: document.getElementById('cSlider'),
      A: document.getElementById('ampSlider'),
      k: document.getElementById('kSlider'),
      m: document.getElementById('mSlider'),
      cVal: document.getElementById('cVal'),
      aVal: document.getElementById('aVal'),
      kVal: document.getElementById('kVal'),
      mVal: document.getElementById('mVal'),
      tagType: document.getElementById('tagType'),
      tagEq: document.getElementById('tagEq'),
      tagEnergy: document.getElementById('tagEnergy'),
      diagram: document.getElementById('diagramCanvas'),
      pot: document.getElementById('potentialCanvas'),
      phase: document.getElementById('phaseCanvas'),
      period: document.getElementById('periodCanvas')
    };

    function currentParams(){
      return {
        m: parseFloat(els.m.value),
        k: parseFloat(els.k.value),
        c: parseFloat(els.c.value),
        A: parseFloat(els.A.value)
      };
    }

    function updateTags(p){
      let type = 'Linear (c=0)';
      if(p.c < 0) type = 'Hard spring (c < 0)';
      if(p.c > 0) type = 'Soft spring (c > 0)';
      els.tagType.textContent = `Type: ${type}`;

      if(p.c > 0){
        const xs = Math.sqrt(p.k/p.c);
        els.tagEq.textContent = `Equilibria: (0,0) + saddles at x=±${formatNum(xs)} m`;
        const Es = (p.k*p.k)/(4*p.c);
        els.tagEnergy.textContent = `Barrier energy: Eₛ = k²/(4c) = ${formatNum(Es)} J`;
      } else {
        els.tagEq.textContent = `Equilibria: only (0,0)`;
        els.tagEnergy.textContent = `Barrier energy (soft): —`;
      }
    }

    function clampAmplitudeForSoft(p){
      if(p.c > 0){
        const xs = Math.sqrt(p.k/p.c);
        const maxA = Math.max(0.12, Math.min(2.2, xs*0.95));
        const cur = parseFloat(els.A.value);
        if(cur > maxA){
          els.A.value = String(maxA);
        }
        // reflect in slider max visually
        els.A.max = String(Math.min(2.2, Math.max(0.2, xs*0.95)));
      } else {
        els.A.max = "2.2";
      }
    }

    function updateReadouts(p){
      els.cVal.textContent = `${formatNum(p.c)}`;
      els.aVal.textContent = `${formatNum(p.A)}`;
      els.kVal.textContent = `${formatNum(p.k)}`;
      els.mVal.textContent = `${formatNum(p.m)}`;
    }

    function updateAll(){
      const p0 = currentParams();
      clampAmplitudeForSoft(p0);
      const p = currentParams();
      updateReadouts(p);
      updateTags(p);

      drawDiagram(els.diagram, p);
      drawPotential(els.pot, p);
      drawPhase(els.phase, p);
      drawPeriod(els.period, p);
    }

    // attach listeners
    ['input','change'].forEach(evt=>{
      els.c.addEventListener(evt, updateAll);
      els.A.addEventListener(evt, updateAll);
      els.k.addEventListener(evt, updateAll);
      els.m.addEventListener(evt, updateAll);
    });

    // handle resize (debounced)
    let resizeId = null;
    window.addEventListener('resize', ()=>{
      if(resizeId) cancelAnimationFrame(resizeId);
      resizeId = requestAnimationFrame(updateAll);
    });

    // initial draw
    updateAll();
  </script>
</body>
</html>
