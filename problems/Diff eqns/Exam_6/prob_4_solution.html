<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Complex Numbers & Phasors (Parts a–f) — Full Structured Solution + Interactive Visualizations</title>
  <style>
    :root{
      --bg: #0b1020;
      --card: rgba(255,255,255,0.06);
      --card2: rgba(255,255,255,0.08);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --faint: rgba(255,255,255,0.45);
      --accent: #7cf7c5;
      --accent2:#7aa7ff;
      --warn:#ffcf6e;
      --danger:#ff6e9a;
      --border: rgba(255,255,255,0.14);
      --shadow: 0 12px 40px rgba(0,0,0,0.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg:#f6f8ff;
        --card: rgba(0,0,0,0.05);
        --card2: rgba(0,0,0,0.07);
        --text: rgba(0,0,0,0.90);
        --muted: rgba(0,0,0,0.68);
        --faint: rgba(0,0,0,0.45);
        --border: rgba(0,0,0,0.12);
        --shadow: 0 14px 40px rgba(15,20,40,0.12);
        --accent:#0aa36a;
        --accent2:#295bff;
        --warn:#b56a00;
        --danger:#b4003c;
      }
    }

    html,body{height:100%;}
    body{
      margin:0;
      font-family: var(--sans);
      background: radial-gradient(1200px 800px at 20% 10%, rgba(122,167,255,0.18), transparent 55%),
                  radial-gradient(900px 650px at 80% 25%, rgba(124,247,197,0.16), transparent 50%),
                  radial-gradient(900px 700px at 50% 110%, rgba(255,110,154,0.10), transparent 60%),
                  var(--bg);
      color: var(--text);
      line-height: 1.55;
    }

    header{
      padding: 28px 18px 16px;
      max-width: 1120px;
      margin: 0 auto;
    }
    .title{
      display:flex;
      gap:14px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .title h1{
      margin:0;
      font-size: clamp(1.35rem, 2.6vw, 2.15rem);
      letter-spacing: -0.02em;
    }
    .subtitle{
      margin: 10px 0 0;
      color: var(--muted);
      max-width: 78ch;
    }

    main{
      max-width: 1120px;
      margin: 0 auto;
      padding: 0 18px 34px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    /* Sticky mini TOC */
    .layout{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 16px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns: 1fr;}
    }
    nav.toc{
      position: sticky;
      top: 12px;
      background: linear-gradient(180deg, var(--card2), var(--card));
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 14px 14px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    nav.toc h2{
      font-size: 0.98rem;
      margin: 0 0 8px;
      letter-spacing: 0.02em;
    }
    .toc a{
      display:block;
      padding: 8px 10px;
      border-radius: 12px;
      color: var(--muted);
      text-decoration:none;
      border: 1px solid transparent;
      transition: transform 160ms ease, background 160ms ease, border-color 160ms ease, color 160ms ease;
      font-size: 0.95rem;
    }
    .toc a:hover{
      background: rgba(122,167,255,0.10);
      border-color: rgba(122,167,255,0.22);
      color: var(--text);
      transform: translateY(-1px);
    }
    .toc .hint{
      margin-top:10px;
      font-size: 0.86rem;
      color: var(--faint);
    }

    .card{
      background: linear-gradient(180deg, var(--card2), var(--card));
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .card h2{
      margin: 0 0 10px;
      font-size: 1.15rem;
      letter-spacing: -0.01em;
    }
    .card h3{
      margin: 14px 0 8px;
      font-size: 1.02rem;
      color: var(--text);
    }
    .muted{color: var(--muted);}
    .small{font-size: 0.95rem;}
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border:1px solid var(--border);
      border-radius: 999px;
      font-size: 0.9rem;
      color: var(--muted);
      background: rgba(0,0,0,0.02);
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 860px){
      .grid2{grid-template-columns: 1fr;}
    }

    .callout{
      border-left: 4px solid var(--accent2);
      background: rgba(122,167,255,0.10);
      border-radius: 14px;
      padding: 12px 12px 12px 14px;
      margin: 12px 0;
    }
    .callout.warn{
      border-left-color: var(--warn);
      background: rgba(255,207,110,0.12);
    }
    .callout.good{
      border-left-color: var(--accent);
      background: rgba(124,247,197,0.12);
    }

    .math{
      font-family: var(--mono);
      font-size: 0.98rem;
      color: var(--text);
      white-space: nowrap;
    }
    .eqblock{
      position: relative;
      margin: 10px 0;
      padding: 12px 12px 12px 12px;
      background: rgba(0,0,0,0.06);
      border: 1px solid var(--border);
      border-radius: 14px;
      overflow:hidden;
    }
    @media (prefers-color-scheme: light){
      .eqblock{background: rgba(255,255,255,0.55);}
    }
    .eqblock .eqtitle{
      font-size: 0.86rem;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .eqline{
      font-family: var(--mono);
      font-size: 0.98rem;
      color: var(--text);
      white-space: pre-wrap;
      word-break: break-word;
    }
    .copybtn{
      position:absolute;
      top:10px;
      right:10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 10px;
      padding: 6px 10px;
      cursor:pointer;
      font-size: 0.85rem;
      transition: transform 140ms ease, background 140ms ease, border-color 140ms ease;
      user-select:none;
    }
    .copybtn:hover{transform: translateY(-1px); background: rgba(122,167,255,0.12); border-color: rgba(122,167,255,0.30);}
    .copybtn:active{transform: translateY(0px) scale(0.98);}
    .copytoast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.75);
      color: white;
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 0.92rem;
      opacity: 0;
      pointer-events:none;
      transition: opacity 220ms ease, transform 220ms ease;
      z-index: 50;
      border: 1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(8px);
    }
    .copytoast.show{
      opacity: 1;
      transform: translateX(-50%) translateY(-2px);
    }

    /* Visualization area */
    .vizHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      flex-wrap:wrap;
      margin-bottom: 10px;
    }
    .controls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    label.control{
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size: 0.88rem;
      color: var(--muted);
      min-width: 220px;
    }
    select, input[type="range"]{
      width: 100%;
      accent-color: var(--accent2);
    }
    .readout{
      font-family: var(--mono);
      color: var(--text);
      font-size: 0.92rem;
      padding: 6px 10px;
      border:1px solid var(--border);
      border-radius: 12px;
      background: rgba(0,0,0,0.05);
      white-space: nowrap;
    }

    figure{
      margin: 0;
    }
    canvas{
      width: 100%;
      height: 320px;
      border-radius: 16px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.05);
      display:block;
    }
    .canvasRow{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }
    @media (min-width: 860px){
      .canvasRow{grid-template-columns: 1fr 1fr;}
    }
    .cap{
      margin-top: 8px;
      color: var(--muted);
      font-size: 0.92rem;
    }

    .finalBox{
      border: 2px solid rgba(124,247,197,0.45);
      background: rgba(124,247,197,0.10);
      border-radius: 16px;
      padding: 12px;
      margin-top: 12px;
    }
    .finalBox h3{margin: 0 0 8px;}
    .finalList{
      margin: 0;
      padding-left: 18px;
    }

    footer{
      max-width: 1120px;
      margin: 0 auto;
      padding: 0 18px 34px;
      color: var(--faint);
      font-size: 0.92rem;
    }

    /* Print friendly */
    @media print{
      nav.toc{position: relative; top: 0; box-shadow: none;}
      .copybtn, .copytoast, .controls{display:none !important;}
      body{background: #fff;}
      .card{box-shadow:none; backdrop-filter:none;}
      canvas{height: 260px;}
    }

    /* Subtle entrance animation */
    .fadeIn{
      animation: fadeInUp 420ms ease both;
    }
    @keyframes fadeInUp{
      from{opacity:0; transform: translateY(6px);}
      to{opacity:1; transform: translateY(0);}
    }
  </style>
</head>
<body>
  <header class="fadeIn">
    <div class="title">
      <h1>Complex Numbers & Phasors (Parts a–f)</h1>
      <span class="pill">Self-contained • No external libraries • Interactive plots</span>
    </div>
    <p class="subtitle">
      We compute several standard complex-number forms (rectangular, polar, powers/roots, exponentials) and rewrite a cosine–sine combination as a single shifted cosine (phasor form).
      Interactive canvases below let you sweep a parameter and see how complex numbers move on the Argand plane and how magnitude/phase change.
    </p>
  </header>

  <main class="fadeIn">
    <div class="layout">
      <nav class="toc" aria-label="Table of contents">
        <h2>Table of Contents</h2>
        <a href="#quick">Quick Summary</a>
        <a href="#viz">Interactive Visualizations</a>
        <a href="#part1">PART 1 — Problem Analysis</a>
        <a href="#part2">PART 2 — Strategy & Tips</a>
        <a href="#part3">PART 3 — Full Solution</a>
        <div class="hint">Tip: click any item; the page scrolls smoothly.</div>
      </nav>

      <div>
        <section id="quick" class="card">
          <h2>Quick Summary</h2>
          <ul>
            <li>(a) Rationalize: <span class="math">1/(3+2i) = (3/13) − (2/13)i</span>.</li>
            <li>(b) Polar form: <span class="math">1−i = √2 · e^{−iπ/4}</span> (principal angle).</li>
            <li>(c) De Moivre: <span class="math">(1−i)^8 = 16</span> (purely real).</li>
            <li>(d) Cube roots of <span class="math">−1</span>: the one with <span class="math">b&gt;0</span> is <span class="math">1/2 + (√3/2)i</span>.</li>
            <li>(e) <span class="math">e^{ln 2 + iπ} = −2</span>.</li>
            <li>(f) Phasor combine: <span class="math">2cos(4t) − 2sin(4t) = 2√2 cos(4t + π/4)</span> (i.e. <span class="math">A=2√2</span>, <span class="math">φ=−π/4</span> in <span class="math">Acos(ωt−φ)</span>).</li>
          </ul>
        </section>

        <section id="viz" class="card">
          <div class="vizHeader">
            <h2 style="margin:0;">Interactive Visualizations (Canvas)</h2>
            <div class="controls" role="group" aria-label="Visualization controls">
              <label class="control">
                <span>Explore part</span>
                <select id="mode">
                  <option value="a">(a) 1/(3 + p i)</option>
                  <option value="b">(b) 1 − p i in polar</option>
                  <option value="c">(c) (1 − p i)^8</option>
                  <option value="d">(d) cube roots of −1 (pick k)</option>
                  <option value="e">(e) e^{ln2 + i θ}</option>
                  <option value="f">(f) 2cos(4t) − 2sin(4t)</option>
                </select>
              </label>

              <label class="control">
                <span id="paramLabel">Parameter p</span>
                <input id="param" type="range" min="-4" max="4" step="0.01" value="2"/>
              </label>

              <div class="readout" id="readout">—</div>
            </div>
          </div>

          <div class="canvasRow">
            <figure>
              <canvas id="cDiagram" aria-label="Diagram: complex plane"></canvas>
              <figcaption class="cap">
                <strong>Diagram:</strong> Argand plane (Re/Im). Shows the relevant input complex number(s) and the computed result.
              </figcaption>
            </figure>

            <figure>
              <canvas id="cMain" aria-label="Main quantitative plot"></canvas>
              <figcaption class="cap">
                <strong>Main plot:</strong> Parameter sweep curve (or waveform for part f). The marker shows the current slider value.
              </figcaption>
            </figure>
          </div>

          <figure style="margin-top:14px;">
            <canvas id="cSecondary" aria-label="Secondary plot"></canvas>
            <figcaption class="cap">
              <strong>Secondary plot:</strong> Magnitude |z| and phase arg(z) vs parameter (or comparison plot for part f).
            </figcaption>
          </figure>

          <div class="callout good small">
            <strong>How to use:</strong> choose a part, then move the slider. All canvases update live.
            This does not change the exact answers below—it’s an intuition builder and parameter-sweep demo.
          </div>
        </section>

        <section id="part1" class="card">
          <h2>PART 1 — Problem Analysis (no solving yet)</h2>

          <h3>Problem restatement (in my words)</h3>
          <p>
            We are given several expressions involving complex numbers. For each part, we must rewrite the expression in a requested form:
            <span class="math">a+bi</span> (rectangular), <span class="math">re^{iθ}</span> (polar), compute a power, find a cube root with a sign condition, evaluate a complex exponential, and rewrite a trigonometric combination as a single cosine with amplitude and phase shift.
          </p>

          <h3>Given quantities</h3>
          <ul>
            <li>(a) Complex number <span class="math">3+2i</span>.</li>
            <li>(b) Complex number <span class="math">1−i</span>.</li>
            <li>(c) Complex number <span class="math">1−i</span> and exponent <span class="math">8</span>.</li>
            <li>(d) The complex number <span class="math">−1</span> and the constraint <span class="math">b &gt; 0</span>.</li>
            <li>(e) Exponent <span class="math">ln 2 + iπ</span>.</li>
            <li>(f) Trig expression <span class="math">f(t)=2cos(4t)−2sin(4t)</span>.</li>
          </ul>

          <h3>Unknowns</h3>
          <ul>
            <li>(a,c,d,e) Real numbers <span class="math">a</span>, <span class="math">b</span> such that the result is <span class="math">a+bi</span>.</li>
            <li>(b) Real <span class="math">r</span>, <span class="math">θ</span> such that <span class="math">1−i = r e^{iθ}</span>.</li>
            <li>(f) Amplitude <span class="math">A</span> and phase <span class="math">φ</span> in <span class="math">Acos(ωt−φ)</span> with <span class="math">ω=4</span>.</li>
          </ul>

          <h3>What must be found/proved</h3>
          <ul>
            <li>Convert between rectangular and polar forms, and compute powers/roots using polar representation.</li>
            <li>Use Euler’s formula to evaluate complex exponentials.</li>
            <li>Use phasor/identity matching to combine sinusoids into a single cosine.</li>
          </ul>

          <h3>Relevant principles/laws (and why they apply)</h3>
          <div class="grid2">
            <div class="callout">
              <strong>Complex algebra & conjugates</strong><br/>
              Rationalizing denominators uses the complex conjugate:
              <span class="math">(a+bi)^{-1}=(a-bi)/(a^2+b^2)</span>.
              This applies directly to part (a).
            </div>
            <div class="callout">
              <strong>Polar form & Euler/De Moivre</strong><br/>
              Any nonzero complex number can be written as <span class="math">re^{iθ}</span>, where
              <span class="math">r=|z|</span>, <span class="math">θ=arg(z)</span>.
              Powers/roots are easiest via De Moivre: <span class="math">(re^{iθ})^n=r^n e^{inθ}</span>.
              This applies to (b,c,d).
            </div>
          </div>
          <div class="callout">
            <strong>Phasors for sinusoids</strong><br/>
            Sinusoids of the same angular frequency can be combined by treating coefficients as a vector (phasor):
            <span class="math">Acos(ωt−φ)=A(cosωt cosφ + sinωt sinφ)</span>.
            This is exactly what part (f) requests.
          </div>

          <h3>Possible approaches (2–3) and comparison</h3>
          <ol>
            <li>
              <strong>Direct algebra in rectangular form</strong>:
              expand, collect real/imag parts. Works for (a,e) and can work for (c) but can be messy.
            </li>
            <li>
              <strong>Convert to polar form and use De Moivre/Euler</strong>:
              typically simplest for powers/roots and exponentials. Best for (b,c,d,e).
            </li>
            <li>
              <strong>Geometric/phasor viewpoint</strong>:
              interpret complex numbers as vectors; especially clean for (f) (amplitude/phase from a right triangle).
            </li>
          </ol>

          <h3>Best approach (and why)</h3>
          <p>
            Use <strong>conjugate rationalization</strong> for (a), <strong>polar form + De Moivre</strong> for (b,c,d),
            <strong>Euler’s formula</strong> for (e), and <strong>phasor coefficient matching</strong> for (f).
            This minimizes algebra, keeps steps systematic, and provides clear physical interpretation (phasors as rotating vectors).
          </p>
        </section>

        <section id="part2" class="card">
          <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

          <ol>
            <li>
              <strong>(a) Invert a complex number</strong><br/>
              Goal: express <span class="math">1/(3+2i)</span> as <span class="math">a+bi</span>.<br/>
              Tool: multiply numerator/denominator by conjugate <span class="math">(3−2i)</span>.
            </li>
            <li>
              <strong>(b) Convert to polar</strong><br/>
              Goal: find <span class="math">r</span>, <span class="math">θ</span> for <span class="math">1−i</span>.<br/>
              Tool: <span class="math">r=√(x^2+y^2)</span>, <span class="math">θ=atan2(y,x)</span>.
            </li>
            <li>
              <strong>(c) Compute a power</strong><br/>
              Goal: <span class="math">(1−i)^8</span>.<br/>
              Tool: write <span class="math">1−i = r e^{iθ}</span>, then apply De Moivre.
            </li>
            <li>
              <strong>(d) Find cube roots</strong><br/>
              Goal: solve <span class="math">z^3=-1</span> with <span class="math">Im(z)&gt;0</span>.<br/>
              Tool: represent <span class="math">-1 = e^{i(π+2πk)}</span>, then divide angle by 3.
            </li>
            <li>
              <strong>(e) Evaluate a complex exponential</strong><br/>
              Goal: compute <span class="math">e^{ln2+iπ}</span> as <span class="math">a+bi</span>.<br/>
              Tool: split: <span class="math">e^{x+iy}=e^x(\cos y + i\sin y)</span>.
            </li>
            <li>
              <strong>(f) Combine sinusoids</strong><br/>
              Goal: rewrite <span class="math">2cos(4t)−2sin(4t)</span> as <span class="math">Acos(4t−φ)</span>.<br/>
              Tool: expand <span class="math">Acos(4t−φ)=A(cos4t cosφ + sin4t sinφ)</span>, match coefficients.
            </li>
          </ol>

          <div class="callout warn">
            <strong>Common mistakes & quick tips</strong>
            <ul>
              <li>For polar angles: use the correct quadrant (here <span class="math">1−i</span> is in quadrant IV, so angle is negative).</li>
              <li>For roots: remember all branches <span class="math">θ+2πk</span>; missing them loses solutions.</li>
              <li>In phasors: keep track of the sign in front of <span class="math">sin</span>; it flips the phase direction.</li>
              <li>When reporting <span class="math">φ</span>, multiple equivalent phases exist (differ by <span class="math">2π</span>).</li>
            </ul>
          </div>
        </section>

        <section id="part3" class="card">
          <h2>PART 3 — Full Solution</h2>

          <div class="callout good">
            <strong>Physical intuition (phasor lens):</strong>
            treat <span class="math">x+iy</span> as a 2D vector.
            Multiplying by <span class="math">e^{iθ}</span> rotates by <span class="math">θ</span>,
            magnitude multiplies lengths, and roots/powers correspond to dividing/multiplying angles.
            In part (f), the cosine and sine terms are just perpendicular components of one rotating vector.
          </div>

          <!-- (a) -->
          <article>
            <h3>(a) Find real a, b such that <span class="math">1/(3+2i)=a+bi</span></h3>

            <div class="eqblock">
              <div class="eqtitle">Key tool: multiply by complex conjugate</div>
              <button class="copybtn" data-copy="1/(3+2i) = (3-2i)/(3^2+2^2) = (3/13) - (2/13)i">Copy</button>
              <div class="eqline">1/(3+2i) · (3−2i)/(3−2i) = (3−2i)/(3^2+2^2)</div>
            </div>

            <p>
              Multiply numerator and denominator by the conjugate <span class="math">3−2i</span> so the denominator becomes real:
              <span class="math">(3+2i)(3−2i)=3^2+(2)^2=13</span>.
            </p>

            <div class="eqblock">
              <div class="eqtitle">Compute the real and imaginary parts</div>
              <button class="copybtn" data-copy="a = 3/13,  b = -2/13">Copy</button>
              <div class="eqline">1/(3+2i) = (3−2i)/13 = 3/13 − (2/13)i</div>
            </div>

            <div class="finalBox">
              <h3>Final (a)</h3>
              <div class="eqline"><strong>1/(3+2i) = (3/13) − (2/13)i</strong></div>
              <div class="eqline">So: a = 3/13,  b = −2/13.</div>
            </div>

            <div class="callout small">
              <strong>Sanity check:</strong> magnitude:
              <span class="math">|3+2i|^2=13</span>, so <span class="math">|1/(3+2i)|=1/√13</span>, consistent with numerator magnitude <span class="math">|3−2i|=√13</span>.
            </div>
          </article>

          <!-- (b) -->
          <article>
            <h3>(b) Find real <span class="math">r,θ</span> such that <span class="math">1−i = r e^{iθ}</span></h3>

            <p>
              Write <span class="math">z = x+iy</span> with <span class="math">x=1</span>, <span class="math">y=−1</span>.
              Then <span class="math">r=|z|=√(x^2+y^2)</span> and <span class="math">θ=arg(z)=atan2(y,x)</span>.
            </p>

            <div class="eqblock">
              <div class="eqtitle">Magnitude and angle</div>
              <button class="copybtn" data-copy="r = sqrt(2),  θ = -π/4  (principal)">Copy</button>
              <div class="eqline">r = √(1^2 + (−1)^2) = √2</div>
              <div class="eqline">θ = arctan((−1)/1) = −π/4  (Quadrant IV)</div>
            </div>

            <div class="eqblock">
              <div class="eqtitle">Polar form</div>
              <button class="copybtn" data-copy="1 - i = √2 e^{-iπ/4}">Copy</button>
              <div class="eqline">1 − i = √2 · e^{−iπ/4}</div>
            </div>

            <div class="finalBox">
              <h3>Final (b)</h3>
              <div class="eqline"><strong>r = √2,  θ = −π/4</strong> (principal value; equivalently θ = 7π/4).</div>
            </div>

            <div class="callout small">
              <strong>Sanity check:</strong>
              <span class="math">√2( cos(−π/4) + i sin(−π/4) ) = √2( √2/2 − i √2/2 ) = 1 − i</span>.
            </div>
          </article>

          <!-- (c) -->
          <article>
            <h3>(c) Find real <span class="math">a,b</span> such that <span class="math">(1−i)^8 = a+bi</span></h3>

            <p>
              Use the polar form from part (b): <span class="math">1−i = √2 e^{−iπ/4}</span>.
              Then apply De Moivre’s theorem for powers.
            </p>

            <div class="eqblock">
              <div class="eqtitle">De Moivre for powers</div>
              <button class="copybtn" data-copy="(1-i)^8 = (√2)^8 e^{-i 8π/4} = 16 e^{-i2π} = 16">Copy</button>
              <div class="eqline">(re^{iθ})^n = r^n e^{inθ}</div>
            </div>

            <p>
              Compute:
              <span class="math">(√2)^8 = (2)^{4} = 16</span> and
              <span class="math">e^{−i(8)(π/4)} = e^{−i2π} = 1</span>.
            </p>

            <div class="finalBox">
              <h3>Final (c)</h3>
              <div class="eqline"><strong>(1−i)^8 = 16 + 0i</strong></div>
              <div class="eqline">So: a = 16, b = 0.</div>
            </div>

            <div class="callout small">
              <strong>Sanity check:</strong>
              since raising to the 8th power multiplies the argument by 8, and <span class="math">8(−π/4)=−2π</span>,
              the result must return to the positive real axis; hence purely real and positive.
            </div>
          </article>

          <!-- (d) -->
          <article>
            <h3>(d) Find real <span class="math">a,b</span> such that <span class="math">b &gt; 0</span> and <span class="math">a+bi</span> is a cube root of <span class="math">−1</span></h3>

            <p>
              Write <span class="math">−1</span> in exponential form. On the unit circle,
              <span class="math">−1</span> corresponds to angle <span class="math">π</span>, but we must include all coterminal angles:
              <span class="math">π + 2πk</span>.
            </p>

            <div class="eqblock">
              <div class="eqtitle">All cube roots</div>
              <button class="copybtn" data-copy="z_k = exp(i(π+2πk)/3),  k=0,1,2">Copy</button>
              <div class="eqline">−1 = e^{i(π + 2πk)}  ⇒  z^3 = e^{i(π+2πk)}</div>
              <div class="eqline">z_k = e^{i(π+2πk)/3},  k = 0,1,2</div>
            </div>

            <p>
              The three angles are:
              <span class="math">π/3</span>, <span class="math">π</span>, <span class="math">5π/3</span>.
              Only <span class="math">π/3</span> has positive imaginary part.
            </p>

            <div class="eqblock">
              <div class="eqtitle">Choose b &gt; 0 root</div>
              <button class="copybtn" data-copy="a = 1/2,  b = √3/2  (since cos(π/3)=1/2, sin(π/3)=√3/2)">Copy</button>
              <div class="eqline">z = e^{iπ/3} = cos(π/3) + i sin(π/3) = 1/2 + (√3/2)i</div>
            </div>

            <div class="finalBox">
              <h3>Final (d)</h3>
              <div class="eqline"><strong>a + bi = 1/2 + (√3/2)i</strong> with <strong>b = √3/2 &gt; 0</strong>.</div>
            </div>

            <div class="callout small">
              <strong>Sanity check:</strong>
              magnitude is 1, and cubing multiplies the angle by 3:
              <span class="math">3(π/3)=π</span> ⇒ result is <span class="math">e^{iπ}=−1</span>.
            </div>
          </article>

          <!-- (e) -->
          <article>
            <h3>(e) Find real <span class="math">a,b</span> such that <span class="math">e^{ln2 + iπ} = a+bi</span></h3>

            <p>
              Use <span class="math">e^{x+iy} = e^x(\cos y + i \sin y)</span> with <span class="math">x=ln2</span>, <span class="math">y=π</span>.
            </p>

            <div class="eqblock">
              <div class="eqtitle">Split real/imag in exponent</div>
              <button class="copybtn" data-copy="e^{ln2 + iπ} = e^{ln2}(cos π + i sin π) = 2(-1 + 0i) = -2">Copy</button>
              <div class="eqline">e^{ln2 + iπ} = e^{ln2} (cosπ + i sinπ) = 2(−1 + 0i) = −2</div>
            </div>

            <div class="finalBox">
              <h3>Final (e)</h3>
              <div class="eqline"><strong>e^{ln2 + iπ} = −2 + 0i</strong></div>
              <div class="eqline">So: a = −2, b = 0.</div>
            </div>

            <div class="callout small">
              <strong>Sanity check:</strong>
              <span class="math">e^{ln2}=2</span> scales magnitude by 2, and <span class="math">e^{iπ}</span> is a 180° rotation to the negative real axis.
            </div>
          </article>

          <!-- (f) -->
          <article>
            <h3>(f) Write <span class="math">f(t)=2cos(4t)−2sin(4t)</span> in the form <span class="math">Acos(ωt−φ)</span></h3>

            <p>
              Because both terms share the same angular frequency <span class="math">ω=4</span>, they can be combined into a single shifted cosine.
              Expand the target form:
            </p>

            <div class="eqblock">
              <div class="eqtitle">Expansion identity</div>
              <button class="copybtn" data-copy="A cos(4t-φ) = A(cos4t cosφ + sin4t sinφ)">Copy</button>
              <div class="eqline">Acos(4t−φ) = A( cos4t cosφ + sin4t sinφ )</div>
            </div>

            <p>
              Now match coefficients with <span class="math">2cos(4t)−2sin(4t)</span>:
            </p>

            <div class="eqblock">
              <div class="eqtitle">Coefficient matching</div>
              <button class="copybtn" data-copy="A cosφ = 2,  A sinφ = -2  ⇒  A = 2√2,  φ = -π/4 (mod 2π)">Copy</button>
              <div class="eqline">A cosφ = 2</div>
              <div class="eqline">A sinφ = −2</div>
            </div>

            <p>
              Square and add:
              <span class="math">A^2(cos^2φ + sin^2φ)=A^2 = 2^2 + (−2)^2 = 8</span>, so <span class="math">A=2√2</span>.
              Then <span class="math">cosφ = 2/A = 1/√2</span> and <span class="math">sinφ = −2/A = −1/√2</span>,
              which corresponds to <span class="math">φ = −π/4</span> (principal), up to adding <span class="math">2π</span>.
            </p>

            <div class="eqblock">
              <div class="eqtitle">Final combined sinusoid</div>
              <button class="copybtn" data-copy="2cos(4t) - 2sin(4t) = 2√2 cos(4t - (-π/4)) = 2√2 cos(4t + π/4)">Copy</button>
              <div class="eqline">2cos(4t) − 2sin(4t) = 2√2 cos(4t − (−π/4)) = 2√2 cos(4t + π/4)</div>
            </div>

            <div class="finalBox">
              <h3>Final (f)</h3>
              <ul class="finalList">
                <li><span class="math">ω = 4</span></li>
                <li><span class="math">A = 2√2</span></li>
                <li><span class="math">φ = −π/4</span> (equivalently <span class="math">φ = 7π/4</span>)</li>
                <li>So <strong><span class="math">f(t)=2√2 cos(4t + π/4)</span></strong> in a clean equivalent form.</li>
              </ul>
            </div>

            <div class="callout small">
              <strong>Sanity checks:</strong>
              <ul>
                <li><strong>Units:</strong> all coefficients are dimensionless amplitudes; angle is dimensionless; frequency is <span class="math">4</span> (rad per unit time).</li>
                <li><strong>Limiting/spot check:</strong> at <span class="math">t=0</span>, original gives <span class="math">2</span>. New form gives <span class="math">2√2 cos(π/4)=2√2·(√2/2)=2</span>.</li>
                <li><strong>Interpretation:</strong> phasor with components (2 along cosine axis, −2 along sine axis) has length <span class="math">2√2</span> and phase <span class="math">−π/4</span>.</li>
              </ul>
            </div>
          </article>

          <!-- One combined "copy all finals" -->
          <div class="eqblock" style="margin-top:16px;">
            <div class="eqtitle">All final answers (a–f) in one block</div>
            <button class="copybtn" data-copy="(a) 1/(3+2i) = 3/13 - (2/13)i
(b) 1 - i = √2 e^{-iπ/4}  (r=√2, θ=-π/4)
(c) (1-i)^8 = 16 + 0i
(d) cube root of -1 with b>0: 1/2 + (√3/2)i
(e) e^{ln2 + iπ} = -2 + 0i
(f) 2cos(4t) - 2sin(4t) = 2√2 cos(4t + π/4)  (A=2√2, ω=4, φ=-π/4)">Copy</button>
            <div class="eqline">(a) 1/(3+2i) = 3/13 − (2/13)i
(b) 1 − i = √2 e^{−iπ/4}
(c) (1−i)^8 = 16
(d) 1/2 + (√3/2)i  (b&gt;0 root)
(e) e^{ln2 + iπ} = −2
(f) 2cos(4t) − 2sin(4t) = 2√2 cos(4t + π/4)</div>
          </div>
        </section>
      </div>
    </div>
  </main>

  <footer>
    Built as a single self-contained HTML article with vanilla JS canvas visualizations (high-DPI aware) and copy-to-clipboard helpers.
  </footer>

  <div class="copytoast" id="toast" aria-live="polite">Copied!</div>

  <script>
    // Smooth scroll for TOC
    (function(){
      document.querySelectorAll('nav.toc a').forEach(a=>{
        a.addEventListener('click', (e)=>{
          const href = a.getAttribute('href');
          if(href && href.startsWith('#')){
            e.preventDefault();
            const el = document.querySelector(href);
            if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
          }
        });
      });
    })();

    // Copy buttons
    (function(){
      const toast = document.getElementById('toast');
      let tmr = null;

      function showToast(msg){
        toast.textContent = msg || 'Copied!';
        toast.classList.add('show');
        clearTimeout(tmr);
        tmr = setTimeout(()=>toast.classList.remove('show'), 1100);
      }

      async function copyText(txt){
        try{
          await navigator.clipboard.writeText(txt);
          showToast('Copied to clipboard');
        }catch(err){
          // fallback
          const ta = document.createElement('textarea');
          ta.value = txt;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
          showToast('Copied (fallback)');
        }
      }

      document.querySelectorAll('.copybtn').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const txt = btn.getAttribute('data-copy') || '';
          copyText(txt);
        });
      });
    })();

    // ---- Complex helpers ----
    function C(re, im){ return {re, im}; }
    function add(a,b){ return C(a.re+b.re, a.im+b.im); }
    function sub(a,b){ return C(a.re-b.re, a.im-b.im); }
    function mul(a,b){ return C(a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re); }
    function div(a,b){
      const den = b.re*b.re + b.im*b.im;
      return C((a.re*b.re + a.im*b.im)/den, (a.im*b.re - a.re*b.im)/den);
    }
    function abs(z){ return Math.hypot(z.re, z.im); }
    function arg(z){ return Math.atan2(z.im, z.re); }
    function expi(theta){ return C(Math.cos(theta), Math.sin(theta)); }
    function powInt(z,n){
      let r = C(1,0);
      for(let k=0;k<n;k++) r = mul(r,z);
      return r;
    }
    function fmt(x){
      const ax = Math.abs(x);
      if(ax < 1e-10) x = 0;
      if(ax >= 1000 || (ax>0 && ax<1e-3)) return x.toExponential(3);
      return (Math.round(x*10000)/10000).toString();
    }
    function fmtZ(z){
      const r = fmt(z.re), i = fmt(Math.abs(z.im));
      const s = (z.im>=0) ? '+' : '-';
      return `${r} ${s} ${i}i`;
    }
    function wrapPi(th){
      // wrap to (-pi, pi]
      let t = th;
      while(t <= -Math.PI) t += 2*Math.PI;
      while(t > Math.PI) t -= 2*Math.PI;
      return t;
    }

    // ---- Canvas plotting utilities (high-DPI) ----
    function setupCanvas(canvas){
      const ctx = canvas.getContext('2d');
      function resize(){
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        const w = Math.max(2, Math.floor(rect.width * dpr));
        const h = Math.max(2, Math.floor(rect.height * dpr));
        if(canvas.width !== w || canvas.height !== h){
          canvas.width = w; canvas.height = h;
        }
        ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      }
      const ro = new ResizeObserver(resize);
      ro.observe(canvas);
      resize();
      return {ctx, resize};
    }

    function clear(ctx, w, h){
      ctx.clearRect(0,0,w,h);
    }

    function drawPanelTitle(ctx, title, x, y){
      ctx.save();
      ctx.font = '600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text').trim();
      ctx.globalAlpha = 0.92;
      ctx.fillText(title, x, y);
      ctx.restore();
    }

    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, grid=true){
      const {x,y,w,h} = box;

      ctx.save();
      // background
      ctx.fillStyle = 'rgba(0,0,0,0)';
      ctx.fillRect(x,y,w,h);

      // grid
      const textColor = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim();
      const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border').trim();
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = 1;

      // frame
      ctx.beginPath();
      ctx.rect(x,y,w,h);
      ctx.stroke();

      function X(v){ return x + (v - xMin) * (w/(xMax-xMin)); }
      function Y(v){ return y + h - (v - yMin) * (h/(yMax-yMin)); }

      if(grid){
        ctx.save();
        ctx.strokeStyle = borderColor;
        ctx.globalAlpha = 0.55;
        ctx.lineWidth = 1;
        const n = 8;
        for(let i=1;i<n;i++){
          const xx = x + i*w/n;
          const yy = y + i*h/n;
          ctx.beginPath(); ctx.moveTo(xx,y); ctx.lineTo(xx,y+h); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(x,yy); ctx.lineTo(x+w,yy); ctx.stroke();
        }
        ctx.restore();
      }

      // ticks
      ctx.save();
      ctx.fillStyle = textColor;
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.globalAlpha = 0.9;

      const ticks = 5;
      for(let i=0;i<=ticks;i++){
        const xv = xMin + (xMax-xMin)*i/ticks;
        const yv = yMin + (yMax-yMin)*i/ticks;
        const xx = X(xv), yy = Y(yv);

        // x tick
        ctx.beginPath();
        ctx.moveTo(xx, y+h);
        ctx.lineTo(xx, y+h+4);
        ctx.stroke();
        ctx.fillText(fmt(xv), xx-10, y+h+16);

        // y tick
        ctx.beginPath();
        ctx.moveTo(x-4, yy);
        ctx.lineTo(x, yy);
        ctx.stroke();
        ctx.fillText(fmt(yv), x-44, yy+4);
      }

      // axis labels
      ctx.save();
      ctx.font = '600 12px ui-sans-serif, system-ui';
      ctx.fillStyle = textColor;
      ctx.globalAlpha = 0.9;
      ctx.fillText(xLabel, x+w-4-ctx.measureText(xLabel).width, y+h-6);

      ctx.translate(x+10, y+14);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();

      ctx.restore();
      ctx.restore();

      return {X, Y};
    }

    function drawLegend(ctx, items, x, y){
      // items: [{label, color}]
      ctx.save();
      ctx.font = '12px ui-sans-serif, system-ui';
      const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border').trim();
      ctx.fillStyle = 'rgba(0,0,0,0.0)';
      let w = 0;
      items.forEach(it=>{
        w = Math.max(w, 18 + ctx.measureText(it.label).width);
      });
      const h = items.length*18 + 10;
      ctx.strokeStyle = borderColor;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.roundRect(x, y, w+18, h, 10);
      ctx.stroke();

      ctx.globalAlpha = 1;
      items.forEach((it, i)=>{
        const yy = y + 18 + i*18;
        ctx.fillStyle = it.color;
        ctx.fillRect(x+10, yy-10, 10, 3);
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text').trim();
        ctx.fillText(it.label, x+26, yy-6);
      });
      ctx.restore();
    }

    // Polyfill for roundRect (older browsers)
    if(!CanvasRenderingContext2D.prototype.roundRect){
      CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
        const rr = Math.min(r, w/2, h/2);
        this.beginPath();
        this.moveTo(x+rr, y);
        this.arcTo(x+w, y, x+w, y+h, rr);
        this.arcTo(x+w, y+h, x, y+h, rr);
        this.arcTo(x, y+h, x, y, rr);
        this.arcTo(x, y, x+w, y, rr);
        this.closePath();
        return this;
      }
    }

    // ---- Visualization logic ----
    const modeEl = document.getElementById('mode');
    const paramEl = document.getElementById('param');
    const paramLabelEl = document.getElementById('paramLabel');
    const readoutEl = document.getElementById('readout');

    const canvDiagram = setupCanvas(document.getElementById('cDiagram'));
    const canvMain = setupCanvas(document.getElementById('cMain'));
    const canvSec = setupCanvas(document.getElementById('cSecondary'));

    function setSliderForMode(mode){
      if(mode === 'a'){
        paramLabelEl.textContent = 'Parameter p (imag part of denominator: 3 + p i)';
        paramEl.min = -6; paramEl.max = 6; paramEl.step = 0.01; paramEl.value = 2;
      }else if(mode === 'b'){
        paramLabelEl.textContent = 'Parameter p (z = 1 − p i)';
        paramEl.min = -6; paramEl.max = 6; paramEl.step = 0.01; paramEl.value = 1;
      }else if(mode === 'c'){
        paramLabelEl.textContent = 'Parameter p (z = (1 − p i)^8)';
        paramEl.min = -3; paramEl.max = 3; paramEl.step = 0.01; paramEl.value = 1;
      }else if(mode === 'd'){
        paramLabelEl.textContent = 'Parameter k (choose root index 0,1,2)';
        paramEl.min = 0; paramEl.max = 2; paramEl.step = 1; paramEl.value = 0;
      }else if(mode === 'e'){
        paramLabelEl.textContent = 'Parameter θ (radians) in e^{ln2 + iθ}';
        paramEl.min = -Math.PI; paramEl.max = Math.PI; paramEl.step = 0.001; paramEl.value = Math.PI;
      }else if(mode === 'f'){
        paramLabelEl.textContent = 'Parameter t (time) for f(t) over one period';
        const T = 2*Math.PI/4;
        paramEl.min = 0; paramEl.max = T; paramEl.step = 0.001; paramEl.value = 0;
      }
    }

    function computeForMode(mode, p){
      // returns {inputZs: [{z,label,color}], resultZs: [{z,label,color}], sweep: function(u)->C, uMin,uMax, mainPlotSpec}
      const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
      const accent2 = getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim();
      const danger = getComputedStyle(document.documentElement).getPropertyValue('--danger').trim();

      if(mode === 'a'){
        const denom = C(3, p);
        const res = div(C(1,0), denom);
        const sweep = (u)=> div(C(1,0), C(3,u));
        return {
          title: '(a) Reciprocal: z = 1/(3 + p i)',
          inputZs: [{z: denom, label:'denom = 3 + p i', color: accent2}],
          resultZs: [{z: res, label:'z = 1/denom', color: accent}],
          sweep, uMin: -6, uMax: 6,
          main: {kind:'paramCurve', xLabel:'Re(z) [unitless]', yLabel:'Im(z) [unitless]'},
          sec: {kind:'magPhase', uLabel:'p [unitless]'}
        };
      }

      if(mode === 'b'){
        const z = C(1, -p);
        const r = abs(z);
        const th = arg(z);
        const sweep = (u)=> C(1, -u);
        return {
          title: '(b) Polar: z = 1 − p i',
          inputZs: [{z, label:'z = 1 − p i', color: accent2}],
          resultZs: [{z: C(r, th), label:'(r, θ) shown in readout', color: accent}], // placeholder container
          sweep, uMin: -6, uMax: 6,
          main: {kind:'paramCurve', xLabel:'Re(z) [unitless]', yLabel:'Im(z) [unitless]'},
          sec: {kind:'magPhase', uLabel:'p [unitless]'}
        };
      }

      if(mode === 'c'){
        const base = C(1, -p);
        const res = powInt(base, 8);
        const sweep = (u)=> powInt(C(1, -u), 8);
        return {
          title: '(c) Power: z = (1 − p i)^8',
          inputZs: [{z: base, label:'base = 1 − p i', color: accent2}],
          resultZs: [{z: res, label:'z = base^8', color: accent}],
          sweep, uMin: -3, uMax: 3,
          main: {kind:'paramCurve', xLabel:'Re(z) [unitless]', yLabel:'Im(z) [unitless]'},
          sec: {kind:'magPhase', uLabel:'p [unitless]'}
        };
      }

      if(mode === 'd'){
        const k = Math.round(p);
        const roots = [0,1,2].map(kk=>{
          const th = (Math.PI + 2*Math.PI*kk)/3;
          return {z: expi(th), label:`z_${kk}`, color: (kk===k?accent:accent2), th};
        });
        return {
          title: '(d) Cube roots of −1',
          inputZs: [{z: C(-1,0), label:'−1', color: danger}],
          resultZs: roots.map(r=>({z:r.z, label:`root k=${r.label.split('_')[1]} (θ=${fmt(r.th)} rad)`, color:r.color})),
          sweep: null, uMin:0, uMax:2,
          main: {kind:'roots', xLabel:'Re(z) [unitless]', yLabel:'Im(z) [unitless]'},
          sec: {kind:'none'}
        };
      }

      if(mode === 'e'){
        const theta = p;
        const res = mul(C(Math.exp(Math.log(2)),0), expi(theta)); // 2 e^{iθ}
        const sweep = (u)=> mul(C(2,0), expi(u));
        return {
          title: '(e) Exponential: z = e^{ln2 + iθ} = 2e^{iθ}',
          inputZs: [{z: C(2,0), label:'magnitude = 2', color: accent2}],
          resultZs: [{z: res, label:'z = 2e^{iθ}', color: accent}],
          sweep, uMin: -Math.PI, uMax: Math.PI,
          main: {kind:'paramCurve', xLabel:'Re(z) [unitless]', yLabel:'Im(z) [unitless]'},
          sec: {kind:'magPhase', uLabel:'θ [rad]'}
        };
      }

      // mode f
      if(mode === 'f'){
        const t = p;
        const omega = 4;
        const f = 2*Math.cos(omega*t) - 2*Math.sin(omega*t);
        // phasor: 2cos(ωt) + (-2)sin(ωt) corresponds to A cos(ωt - φ) with A=2√2, φ=-π/4
        const A = 2*Math.SQRT2;
        const phi = -Math.PI/4;
        const f2 = A*Math.cos(omega*t - phi); // identical
        const T = 2*Math.PI/omega;
        return {
          title: '(f) Phasor sum: 2cos(4t) − 2sin(4t)',
          inputZs: [
            {z: C(2,0), label:'cos-component = 2', color: accent2},
            {z: C(0,-2), label:'sin-component = −2 (phasor axis)', color: danger}
          ],
          resultZs: [{z: C(A*Math.cos(phi), A*Math.sin(phi)), label:'result phasor (Acosφ, Asinφ)', color: accent}],
          sweep: null, uMin:0, uMax:T,
          main: {kind:'wave', xLabel:'t [time units]', yLabel:'f(t) [unitless]'},
          sec: {kind:'waveCompare', uLabel:'t [time units]'},
          extras: {omega, A, phi, f, f2, T}
        };
      }
    }

    function drawComplexPlane(ctx, box, points, title){
      const {x,y,w,h} = box;
      const pad = 40;
      const inner = {x:x+pad, y:y+pad, w:w-2*pad, h:h-2*pad};

      // Determine scale
      let maxAbs = 1;
      points.forEach(p=>{
        maxAbs = Math.max(maxAbs, Math.abs(p.z.re), Math.abs(p.z.im));
      });
      maxAbs = Math.max(1.2, maxAbs*1.2);
      const xMin = -maxAbs, xMax = maxAbs, yMin = -maxAbs, yMax = maxAbs;

      clear(ctx, w, h);

      drawPanelTitle(ctx, title, x+12, y+18);

      const map = drawAxes(ctx, inner, xMin, xMax, yMin, yMax, 'Re', 'Im', true);

      // Draw origin axes thicker
      ctx.save();
      const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border').trim();
      ctx.strokeStyle = borderColor;
      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 2;
      const x0 = map.X(0), y0 = map.Y(0);
      ctx.beginPath(); ctx.moveTo(inner.x, y0); ctx.lineTo(inner.x+inner.w, y0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x0, inner.y); ctx.lineTo(x0, inner.y+inner.h); ctx.stroke();
      ctx.restore();

      // Plot points + vectors from origin
      ctx.save();
      ctx.lineWidth = 2;
      points.forEach(p=>{
        const px = map.X(p.z.re), py = map.Y(p.z.im);

        // vector from origin
        ctx.strokeStyle = p.color;
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(px, py);
        ctx.stroke();

        // point
        ctx.fillStyle = p.color;
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.arc(px, py, 5, 0, Math.PI*2);
        ctx.fill();

        // label
        ctx.font = '12px ui-sans-serif, system-ui';
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text').trim();
        ctx.globalAlpha = 0.9;
        ctx.fillText(p.label, px+8, py-8);
      });
      ctx.restore();
    }

    function drawParamCurve(ctx, box, curveFn, uMin, uMax, uNow, title, xLabel, yLabel){
      const {x,y,w,h} = box;
      const pad = 40;
      const inner = {x:x+pad, y:y+pad, w:w-2*pad, h:h-2*pad};

      // sample points
      const N = 300;
      const pts = [];
      let xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity;
      for(let i=0;i<=N;i++){
        const u = uMin + (uMax-uMin)*i/N;
        const z = curveFn(u);
        pts.push({u, z});
        xMin = Math.min(xMin, z.re); xMax = Math.max(xMax, z.re);
        yMin = Math.min(yMin, z.im); yMax = Math.max(yMax, z.im);
      }
      // padding
      const dx = xMax-xMin || 1;
      const dy = yMax-yMin || 1;
      xMin -= 0.12*dx; xMax += 0.12*dx;
      yMin -= 0.12*dy; yMax += 0.12*dy;

      clear(ctx, w, h);
      drawPanelTitle(ctx, title, x+12, y+18);

      const map = drawAxes(ctx, inner, xMin, xMax, yMin, yMax, xLabel, yLabel, true);

      // draw curve
      const accent2 = getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim();
      ctx.save();
      ctx.strokeStyle = accent2;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      pts.forEach((p,i)=>{
        const xx = map.X(p.z.re), yy = map.Y(p.z.im);
        if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
      });
      ctx.stroke();
      ctx.restore();

      // highlight current point
      const zNow = curveFn(uNow);
      ctx.save();
      const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
      ctx.fillStyle = accent;
      ctx.strokeStyle = accent;
      ctx.lineWidth = 2;
      const xx = map.X(zNow.re), yy = map.Y(zNow.im);
      ctx.beginPath(); ctx.arc(xx, yy, 6, 0, Math.PI*2); ctx.fill();

      // tiny tangent marker
      ctx.globalAlpha = 0.9;
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text').trim();
      ctx.fillText(`u = ${fmt(uNow)}`, xx+10, yy+14);
      ctx.restore();

      // legend
      drawLegend(ctx, [
        {label:'sweep curve', color: accent2},
        {label:'current value', color: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()}
      ], inner.x + 10, inner.y + 10);
    }

    function drawMagPhase(ctx, box, curveFn, uMin, uMax, uNow, title, uLabel){
      const {x,y,w,h} = box;
      const pad = 46;
      const inner = {x:x+pad, y:y+pad, w:w-2*pad, h:h-2*pad};

      const N = 350;
      const mag = [];
      const phs = [];
      let mMin=Infinity, mMax=-Infinity, pMin=Infinity, pMax=-Infinity;

      for(let i=0;i<=N;i++){
        const u = uMin + (uMax-uMin)*i/N;
        const z = curveFn(u);
        const m = abs(z);
        const th = wrapPi(arg(z));
        mag.push({u, v:m});
        phs.push({u, v:th});
        mMin = Math.min(mMin, m); mMax = Math.max(mMax, m);
        pMin = Math.min(pMin, th); pMax = Math.max(pMax, th);
      }

      // We'll plot both on same axes using two y-axes concept but with scaling:
      // Normalize phase to same panel via separate mapping with labels in legend/readout.
      // Axis shows u on x, and "normalized value" on y with ticks for magnitude; phase shown with right-side label markers.
      // To keep it readable: we plot magnitude on left y-scale, phase on right y-scale and add right tick labels manually.
      const xMin=uMin, xMax=uMax;
      const yMin=mMin - 0.08*(mMax-mMin || 1);
      const yMax=mMax + 0.08*(mMax-mMin || 1);

      clear(ctx, w, h);
      drawPanelTitle(ctx, title, x+12, y+18);

      const map = drawAxes(ctx, inner, xMin, xMax, yMin, yMax, uLabel, '|z| [unitless]', true);

      // draw magnitude curve
      const accent2 = getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim();
      const danger = getComputedStyle(document.documentElement).getPropertyValue('--danger').trim();
      ctx.save();
      ctx.strokeStyle = accent2;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      mag.forEach((p,i)=>{
        const xx = map.X(p.u), yy = map.Y(p.v);
        if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
      });
      ctx.stroke();
      ctx.restore();

      // phase curve scaled into the same y-range visually:
      // Map phase range (-pi..pi) -> yMin..yMax
      function phaseToY(th){
        return yMin + ( (th - (-Math.PI)) / (2*Math.PI) ) * (yMax-yMin);
      }
      ctx.save();
      ctx.strokeStyle = danger;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      phs.forEach((p,i)=>{
        const xx = map.X(p.u), yy = map.Y(phaseToY(p.v));
        if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
      });
      ctx.stroke();
      ctx.restore();

      // right-side phase tick labels
      ctx.save();
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim();
      ctx.globalAlpha = 0.9;
      const ticks = 4;
      for(let i=0;i<=ticks;i++){
        const th = -Math.PI + (2*Math.PI)*i/ticks;
        const yy = map.Y(phaseToY(th));
        ctx.fillText(`${fmt(th)} rad`, inner.x+inner.w+6, yy+4);
        // small tick mark
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border').trim();
        ctx.beginPath();
        ctx.moveTo(inner.x+inner.w, yy);
        ctx.lineTo(inner.x+inner.w+5, yy);
        ctx.stroke();
      }
      // right axis label
      ctx.save();
      ctx.translate(inner.x+inner.w+36, inner.y+inner.h/2);
      ctx.rotate(-Math.PI/2);
      ctx.font = '600 12px ui-sans-serif, system-ui';
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim();
      ctx.fillText('arg(z) [rad]', 0, 0);
      ctx.restore();
      ctx.restore();

      // current markers
      const zNow = curveFn(uNow);
      const mNow = abs(zNow);
      const thNow = wrapPi(arg(zNow));
      ctx.save();
      const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
      // marker for magnitude
      ctx.fillStyle = accent;
      ctx.beginPath();
      ctx.arc(map.X(uNow), map.Y(mNow), 5.5, 0, Math.PI*2);
      ctx.fill();
      // marker for phase (in its scaled y)
      ctx.fillStyle = danger;
      ctx.beginPath();
      ctx.arc(map.X(uNow), map.Y(phaseToY(thNow)), 5.5, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      drawLegend(ctx, [
        {label:'|z|', color: accent2},
        {label:'arg(z) (scaled)', color: danger},
        {label:'current', color: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()}
      ], inner.x + 10, inner.y + 10);
    }

    function drawRootsPlot(ctx, box, roots, kSel, title){
      const {x,y,w,h} = box;
      const pad = 40;
      const inner = {x:x+pad, y:y+pad, w:w-2*pad, h:h-2*pad};

      clear(ctx, w, h);
      drawPanelTitle(ctx, title, x+12, y+18);

      const map = drawAxes(ctx, inner, -1.4, 1.4, -1.4, 1.4, 'Re(z) [unitless]', 'Im(z) [unitless]', true);

      // unit circle
      ctx.save();
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border').trim();
      ctx.globalAlpha = 0.9;
      ctx.lineWidth = 2;
      const x0 = map.X(0), y0 = map.Y(0);
      const r = (inner.w/2) * (1/1.4);
      ctx.beginPath();
      ctx.arc(x0, y0, r, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();

      // points
      roots.forEach((rt, idx)=>{
        const px = map.X(rt.z.re), py = map.Y(rt.z.im);
        ctx.save();
        ctx.strokeStyle = rt.color;
        ctx.fillStyle = rt.color;
        ctx.globalAlpha = 0.95;
        ctx.lineWidth = (idx===kSel) ? 3 : 2;

        // vector
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(px, py);
        ctx.stroke();

        // point
        ctx.beginPath();
        ctx.arc(px, py, (idx===kSel)?7:5, 0, Math.PI*2);
        ctx.fill();

        // label
        ctx.font = '12px ui-sans-serif, system-ui';
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text').trim();
        ctx.globalAlpha = 0.9;
        ctx.fillText(`k=${idx}`, px+8, py-8);

        ctx.restore();
      });

      drawLegend(ctx, [
        {label:'unit circle', color: getComputedStyle(document.documentElement).getPropertyValue('--border').trim()},
        {label:'selected root', color: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()}
      ], inner.x + 10, inner.y + 10);
    }

    function drawWave(ctx, box, omega, A, phi, tNow, title, compare=false){
      const {x,y,w,h} = box;
      const pad = 46;
      const inner = {x:x+pad, y:y+pad, w:w-2*pad, h:h-2*pad};

      const T = 2*Math.PI/omega;
      const xMin = 0, xMax = T;
      // range for y: amplitude of original is A
      const yMin = -1.2*A, yMax = 1.2*A;

      clear(ctx, w, h);
      drawPanelTitle(ctx, title, x+12, y+18);

      const map = drawAxes(ctx, inner, xMin, xMax, yMin, yMax, 't [time units]', 'f(t) [unitless]', true);

      // sample
      const N=420;
      const y1 = [];
      const y2 = [];
      for(let i=0;i<=N;i++){
        const t = xMin + (xMax-xMin)*i/N;
        const f1 = 2*Math.cos(omega*t) - 2*Math.sin(omega*t);
        const f2 = A*Math.cos(omega*t - phi);
        y1.push({t, v:f1});
        y2.push({t, v:f2});
      }

      const accent2 = getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim();
      const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
      const danger = getComputedStyle(document.documentElement).getPropertyValue('--danger').trim();

      // original
      ctx.save();
      ctx.strokeStyle = accent2;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      y1.forEach((p,i)=>{
        const xx=map.X(p.t), yy=map.Y(p.v);
        if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
      });
      ctx.stroke();
      ctx.restore();

      if(compare){
        // combined cosine form (should overlap)
        ctx.save();
        ctx.strokeStyle = danger;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.80;
        ctx.beginPath();
        y2.forEach((p,i)=>{
          const xx=map.X(p.t), yy=map.Y(p.v);
          if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
        });
        ctx.stroke();
        ctx.restore();
      }

      // marker line at tNow
      ctx.save();
      ctx.strokeStyle = accent;
      ctx.globalAlpha = 0.8;
      ctx.lineWidth = 2;
      const xx = map.X(tNow);
      ctx.beginPath();
      ctx.moveTo(xx, inner.y);
      ctx.lineTo(xx, inner.y+inner.h);
      ctx.stroke();

      const fNow = 2*Math.cos(omega*tNow) - 2*Math.sin(omega*tNow);
      ctx.fillStyle = accent;
      ctx.beginPath();
      ctx.arc(xx, map.Y(fNow), 6, 0, Math.PI*2);
      ctx.fill();

      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text').trim();
      ctx.globalAlpha = 0.95;
      ctx.fillText(`t=${fmt(tNow)}, f=${fmt(fNow)}`, Math.min(xx+8, inner.x+inner.w-160), inner.y+18);
      ctx.restore();

      if(compare){
        drawLegend(ctx, [
          {label:'original: 2cos(4t) − 2sin(4t)', color: accent2},
          {label:'single cosine: A cos(4t−φ)', color: danger},
          {label:'current t', color: accent}
        ], inner.x + 10, inner.y + 10);
      }else{
        drawLegend(ctx, [
          {label:'f(t)', color: accent2},
          {label:'current t', color: accent}
        ], inner.x + 10, inner.y + 10);
      }
    }

    function update(){
      const mode = modeEl.value;
      const p = parseFloat(paramEl.value);
      const spec = computeForMode(mode, p);

      // Readout text (ties to the actual problem parts)
      let readout = '';
      if(mode === 'a'){
        const z = div(C(1,0), C(3,p));
        readout = `p=${fmt(p)} → 1/(3+pi) = ${fmtZ(z)};  |z|=${fmt(abs(z))}, arg=${fmt(wrapPi(arg(z)))} rad`;
      }else if(mode === 'b'){
        const z = C(1,-p);
        readout = `p=${fmt(p)} → z=${fmtZ(z)};  r=${fmt(abs(z))}, θ=${fmt(wrapPi(arg(z)))} rad`;
      }else if(mode === 'c'){
        const base = C(1,-p);
        const z = powInt(base, 8);
        readout = `p=${fmt(p)} → (1−pi)^8 = ${fmtZ(z)};  |z|=${fmt(abs(z))}, arg=${fmt(wrapPi(arg(z)))} rad`;
      }else if(mode === 'd'){
        const k = Math.round(p);
        const th = (Math.PI + 2*Math.PI*k)/3;
        const z = expi(th);
        readout = `k=${k} → root = e^{i(π+2πk)/3} = ${fmtZ(z)};  θ=${fmt(th)} rad`;
      }else if(mode === 'e'){
        const theta = p;
        const z = mul(C(2,0), expi(theta));
        readout = `θ=${fmt(theta)} → e^{ln2+iθ} = ${fmtZ(z)};  |z|=${fmt(abs(z))} (should be 2)`;
      }else if(mode === 'f'){
        const t = p;
        const omega=4, A=2*Math.SQRT2, phi=-Math.PI/4;
        const fNow = 2*Math.cos(omega*t) - 2*Math.sin(omega*t);
        readout = `t=${fmt(t)} → f(t)=${fmt(fNow)};  A=${fmt(A)}, ω=4, φ=${fmt(phi)} rad`;
      }
      readoutEl.textContent = readout;

      // ---- Draw diagram (complex plane) ----
      {
        const ctx = canvDiagram.ctx;
        const rect = document.getElementById('cDiagram').getBoundingClientRect();
        const w = rect.width, h = rect.height;

        // choose which points to show
        let pts = [];
        // inputs
        spec.inputZs.forEach(o => pts.push({z:o.z, label:o.label, color:o.color}));
        // results (limit if too many)
        if(mode === 'd'){
          // show only selected root plus -1
          const k = Math.round(p);
          const th = (Math.PI + 2*Math.PI*k)/3;
          const z = expi(th);
          pts.push({z, label:`selected root (k=${k})`, color:getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()});
        }else if(mode === 'f'){
          // show component vectors and resultant phasor
          const omega=4, A=2*Math.SQRT2, phi=-Math.PI/4;
          pts.push({z:C(2,0), label:'2 (cos-axis)', color:getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim()});
          pts.push({z:C(0,-2), label:'−2i (sin-axis)', color:getComputedStyle(document.documentElement).getPropertyValue('--danger').trim()});
          pts.push({z:C(A*Math.cos(phi), A*Math.sin(phi)), label:'result (Acosφ + iAsinφ)', color:getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()});
        }else{
          spec.resultZs.forEach(o=>{
            if(o && o.z && isFinite(o.z.re) && isFinite(o.z.im)){
              pts.push({z:o.z, label:o.label, color:o.color});
            }
          });
        }

        drawComplexPlane(ctx, {x:0,y:0,w,h}, pts, 'Diagram: Argand plane');
      }

      // ---- Draw main plot ----
      {
        const ctx = canvMain.ctx;
        const rect = document.getElementById('cMain').getBoundingClientRect();
        const w = rect.width, h = rect.height;

        if(spec.main.kind === 'paramCurve'){
          drawParamCurve(ctx, {x:0,y:0,w,h}, spec.sweep, spec.uMin, spec.uMax, p,
            'Main: trajectory in (Re, Im) as parameter sweeps',
            spec.main.xLabel, spec.main.yLabel
          );
        }else if(spec.main.kind === 'roots'){
          const kSel = Math.round(p);
          const roots = [0,1,2].map(kk=>{
            const th = (Math.PI + 2*Math.PI*kk)/3;
            const z = expi(th);
            return {z, color: (kk===kSel)?getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()
                                        :getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim()};
          });
          drawRootsPlot(ctx, {x:0,y:0,w,h}, roots, kSel, 'Main: the three cube roots on the unit circle');
        }else if(spec.main.kind === 'wave'){
          const omega=spec.extras.omega, A=spec.extras.A, phi=spec.extras.phi;
          drawWave(ctx, {x:0,y:0,w,h}, omega, A, phi, p, 'Main: f(t) over one period', false);
        }
      }

      // ---- Draw secondary plot ----
      {
        const ctx = canvSec.ctx;
        const rect = document.getElementById('cSecondary').getBoundingClientRect();
        const w = rect.width, h = rect.height;

        if(spec.sec.kind === 'magPhase'){
          drawMagPhase(ctx, {x:0,y:0,w,h}, spec.sweep, spec.uMin, spec.uMax, p,
            'Secondary: magnitude |z| and phase arg(z) vs parameter', spec.sec.uLabel);
        }else if(spec.sec.kind === 'waveCompare'){
          const omega=spec.extras.omega, A=spec.extras.A, phi=spec.extras.phi;
          drawWave(ctx, {x:0,y:0,w,h}, omega, A, phi, p, 'Secondary: original vs single-cosine form (they overlap)', true);
        }else{
          // blank informative panel
          clear(ctx, w, h);
          drawPanelTitle(ctx, 'Secondary: (no additional curve needed for this mode)', 12, 18);
          ctx.save();
          ctx.font = '14px ui-sans-serif, system-ui';
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim();
          ctx.globalAlpha = 0.92;
          ctx.fillText('For cube roots, the main plot already shows the full discrete set.', 12, 48);
          ctx.fillText('Try switching to another mode to see magnitude/phase sweeps.', 12, 70);
          ctx.restore();
        }
      }
    }

    // events
    modeEl.addEventListener('change', ()=>{
      setSliderForMode(modeEl.value);
      update();
    });
    paramEl.addEventListener('input', update);

    // init
    setSliderForMode(modeEl.value);
    update();

    // redraw on DPR changes (zoom / moving across screens)
    window.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`).addEventListener?.('change', update);
    window.addEventListener('resize', ()=>{ update(); });
  </script>
</body>
</html>
