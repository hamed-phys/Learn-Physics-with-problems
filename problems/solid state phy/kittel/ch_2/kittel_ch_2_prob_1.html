<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="color-scheme" content="light dark" />
  <meta name="theme-color" content="#0b1220" />
  <title>Interplanar Separation (hkl): Reciprocal Lattice Geometry</title>
  <style>
    :root{
      --bg: #070b14;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.085);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --faint: rgba(255,255,255,0.52);
      --line: rgba(255,255,255,0.14);
      --accent: #7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;

      --shadow: 0 18px 45px rgba(0,0,0,0.35);
      --radius: 16px;
      --radius2: 22px;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    @media (prefers-color-scheme: light){
      :root{
        --bg: #f6f8ff;
        --panel: rgba(10,20,40,0.06);
        --panel2: rgba(10,20,40,0.085);
        --text: rgba(10,20,40,0.92);
        --muted: rgba(10,20,40,0.70);
        --faint: rgba(10,20,40,0.52);
        --line: rgba(10,20,40,0.14);
        --shadow: 0 16px 40px rgba(10,20,40,0.12);
      }
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background:
        radial-gradient(1200px 700px at 15% 10%, rgba(125,211,252,0.12), transparent 55%),
        radial-gradient(1100px 650px at 85% 15%, rgba(167,139,250,0.10), transparent 55%),
        radial-gradient(900px 650px at 50% 95%, rgba(52,211,153,0.08), transparent 55%),
        var(--bg);
      line-height:1.58;
    }

    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    code, pre{font-family:var(--mono)}
    .wrap{
      max-width: 1200px;
      margin: 0 auto;
      padding: 26px 18px 70px;
    }

    header{
      display:grid;
      gap:14px;
      padding: 18px 18px 14px;
      border: 1px solid var(--line);
      border-radius: var(--radius2);
      background: linear-gradient(180deg, var(--panel2), transparent);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    header::before{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(600px 300px at 10% 10%, rgba(125,211,252,0.12), transparent 60%),
        radial-gradient(520px 260px at 80% 20%, rgba(167,139,250,0.10), transparent 60%);
      pointer-events:none;
      filter: blur(0.2px);
    }
    header > *{position:relative}
    .kicker{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      color:var(--muted);
      font-size: 0.95rem;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border:1px solid var(--line);
      border-radius: 999px;
      background: rgba(255,255,255,0.04);
      backdrop-filter: blur(6px);
    }
    .dot{width:8px;height:8px;border-radius:50%}
    .dot.a{background:var(--accent)}
    .dot.b{background:var(--accent2)}
    .dot.c{background:var(--good)}
    h1{
      margin:0;
      font-size: clamp(1.55rem, 2.7vw, 2.35rem);
      letter-spacing: -0.02em;
      line-height:1.15;
    }
    .sub{
      margin:0;
      color:var(--muted);
      max-width: 78ch;
      font-size: 1.03rem;
    }

    .layout{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 18px;
      margin-top: 18px;
      align-items:start;
    }

    aside{
      position: sticky;
      top: 14px;
      align-self:start;
      border:1px solid var(--line);
      border-radius: var(--radius2);
      background: linear-gradient(180deg, var(--panel2), transparent);
      box-shadow: var(--shadow);
      padding: 14px 14px 12px;
      overflow:hidden;
    }

    .toc-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin: 2px 0 10px;
    }
    .toc-title strong{
      font-size:0.98rem;
      letter-spacing:0.01em;
    }
    .mini{
      font-size:0.88rem;
      color:var(--muted);
    }

    .toc{
      list-style:none;
      padding:0;
      margin:0;
      display:grid;
      gap:6px;
    }
    .toc a{
      display:block;
      padding: 8px 10px;
      border-radius: 12px;
      border:1px solid transparent;
      color: var(--text);
      background: rgba(255,255,255,0.03);
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .toc a:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,0.06);
      border-color: var(--line);
      text-decoration:none;
    }

    main{
      display:grid;
      gap: 16px;
      min-width: 0;
    }

    section{
      border:1px solid var(--line);
      border-radius: var(--radius2);
      background: linear-gradient(180deg, var(--panel2), transparent);
      box-shadow: var(--shadow);
      padding: 18px;
      overflow:hidden;
    }

    section h2{
      margin: 0 0 10px;
      font-size: clamp(1.25rem, 1.8vw, 1.55rem);
      letter-spacing:-0.01em;
    }
    section h3{
      margin: 14px 0 8px;
      font-size: 1.06rem;
      letter-spacing: -0.01em;
      color: var(--text);
    }
    p{margin: 8px 0}
    ul{margin: 8px 0 8px 18px}
    li{margin: 6px 0}

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns: 1fr}
      aside{position:relative; top:auto}
      .grid2{grid-template-columns: 1fr}
    }

    .card{
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding: 12px 12px 10px;
      background: rgba(255,255,255,0.03);
    }

    .callout{
      border-left: 4px solid var(--accent);
      padding: 12px 12px 10px;
      border-radius: 14px;
      background: rgba(125,211,252,0.08);
      border-top: 1px solid rgba(125,211,252,0.22);
      border-right: 1px solid rgba(125,211,252,0.18);
      border-bottom: 1px solid rgba(125,211,252,0.18);
      margin: 12px 0;
    }
    .callout strong{display:block; margin-bottom:4px}
    .callout.warn{
      border-left-color: var(--warn);
      background: rgba(251,191,36,0.10);
      border-top-color: rgba(251,191,36,0.22);
      border-right-color: rgba(251,191,36,0.18);
      border-bottom-color: rgba(251,191,36,0.18);
    }
    .callout.good{
      border-left-color: var(--good);
      background: rgba(52,211,153,0.10);
      border-top-color: rgba(52,211,153,0.22);
      border-right-color: rgba(52,211,153,0.18);
      border-bottom-color: rgba(52,211,153,0.18);
    }
    .callout.bad{
      border-left-color: var(--bad);
      background: rgba(251,113,133,0.10);
      border-top-color: rgba(251,113,133,0.22);
      border-right-color: rgba(251,113,133,0.18);
      border-bottom-color: rgba(251,113,133,0.18);
    }

    .eq{
      position:relative;
      border:1px dashed var(--line);
      border-radius: 16px;
      background: rgba(255,255,255,0.02);
      padding: 12px 12px 10px;
      margin: 10px 0;
      overflow:auto;
    }
    .eq pre{
      margin:0;
      white-space:pre-wrap;
      word-break:break-word;
      font-size: 0.95rem;
      color: var(--text);
    }
    .eq .row{
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
    }
    .btn{
      appearance:none;
      border:1px solid var(--line);
      background: rgba(255,255,255,0.05);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 0.86rem;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,0.08);
      border-color: rgba(255,255,255,0.22);
    }
    .btn:active{transform: translateY(0px) scale(0.99)}
    .btn.small{padding:6px 9px; font-size:0.82rem; border-radius: 11px}
    .btn.accent{border-color: rgba(125,211,252,0.35); background: rgba(125,211,252,0.10)}
    .btn.good{border-color: rgba(52,211,153,0.35); background: rgba(52,211,153,0.10)}
    .btn.warn{border-color: rgba(251,191,36,0.35); background: rgba(251,191,36,0.10)}
    .btn.bad{border-color: rgba(251,113,133,0.35); background: rgba(251,113,133,0.10)}
    .btn:focus{outline: 2px solid rgba(125,211,252,0.4); outline-offset:2px}

    details{
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.02);
      margin: 10px 0;
    }
    details summary{
      cursor:pointer;
      font-weight:600;
      color: var(--text);
      list-style:none;
    }
    details summary::-webkit-details-marker{display:none}
    details summary::after{
      content:"▾";
      float:right;
      color: var(--muted);
      transition: transform .15s ease;
    }
    details[open] summary::after{transform: rotate(180deg)}
    .backtop{
      display:inline-flex;
      align-items:center;
      gap:8px;
      margin-top: 10px;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .muted{color:var(--muted)}
    .faint{color:var(--faint)}

    .final{
      border: 1px solid rgba(52,211,153,0.35);
      background: rgba(52,211,153,0.10);
      border-radius: 18px;
      padding: 14px 14px 12px;
      margin: 12px 0 6px;
    }
    .final h3{margin-top:0}
    .final .eq{border-style:solid; border-color: rgba(52,211,153,0.28)}

    footer{
      margin-top: 16px;
      color: var(--muted);
      font-size: 0.95rem;
      border:1px solid var(--line);
      border-radius: var(--radius2);
      padding: 14px 18px;
      background: rgba(255,255,255,0.03);
    }

    /* Print-friendly */
    @media print{
      body{background:#fff; color:#000}
      header, section, aside, footer{
        box-shadow:none !important;
        background:#fff !important;
        border-color:#bbb !important;
      }
      a{color:#000; text-decoration:underline}
      .btn{display:none !important}
      aside{position:relative; top:auto}
      .layout{grid-template-columns: 1fr}
      section{break-inside:avoid}
      .pagebreak{break-before:page}
    }
  </style>
</head>
<body>
  <a id="top"></a>
  <div class="wrap">
    <header>
      <div class="kicker">
        <span class="pill"><span class="dot a"></span>Crystallography</span>
        <span class="pill"><span class="dot b"></span>Reciprocal Lattice</span>
        <span class="pill"><span class="dot c"></span>Math-Physics Rigour</span>
        <span class="mini">Interplanar spacing of (hkl) planes</span>
      </div>
      <h1>Interplanar Separation: Why <span class="muted">d(hkl) = 2π/|G|</span> and <span class="muted">G ⟂ (hkl)</span></h1>
      <p class="sub">
        We prove (a) the reciprocal lattice vector <code>G = h b1 + k b2 + l b3</code> is perpendicular to the lattice plane (hkl),
        (b) the spacing between adjacent parallel (hkl) planes is <code>d(hkl) = 2π/|G|</code>,
        and (c) for a simple cubic lattice <code>d = a / sqrt(h^2 + k^2 + l^2)</code>.
        Along the way we treat planes as level sets of a scalar field and use ∇-operator reasoning for a clean mathematical-physics view.
      </p>
    </header>

    <div class="layout">
      <aside aria-label="Table of contents">
        <div class="toc-title">
          <strong>Table of Contents</strong>
          <button class="btn small accent" id="copyFinalBtn" title="Copy final answers (plain text)">Copy final answer</button>
        </div>
        <div class="mini muted">Sticky navigation • click to jump</div>
        <ul class="toc">
          <li><a href="#qs">Quick Summary</a></li>
          <li><a href="#p0">PART 0 — Concept Primer</a></li>
          <li><a href="#p0b">PART 0B — Industry & Applied Physics</a></li>
          <li><a href="#p1">PART 1 — Problem Analysis</a></li>
          <li><a href="#p2">PART 2 — Strategy & Tips</a></li>
          <li><a href="#p3">PART 3 — Full Solution</a></li>
          <li><a href="#p4">PART 4 — Deeper Understanding</a></li>
          <li><a href="#p5">PART 5 — Optional Plot Guide</a></li>
        </ul>
        <div style="margin-top:10px" class="card">
          <div class="muted" style="font-size:0.92rem">
            <strong>Usability</strong>
            <ul style="margin:8px 0 0 18px">
              <li>Copy buttons on key equations</li>
              <li><code>&lt;details&gt;</code> blocks for deeper notes</li>
              <li>Print-friendly formatting</li>
            </ul>
          </div>
        </div>
      </aside>

      <main>
        <section id="qs">
          <h2>Quick Summary</h2>
          <ul>
            <li><strong>What this is about:</strong> spacing and orientation of crystallographic planes labeled by Miller indices (hkl).</li>
            <li><strong>Key physics idea:</strong> the reciprocal lattice encodes plane families and diffraction; (hkl) planes are orthogonal to a reciprocal vector <code>G</code>.</li>
            <li><strong>Governing geometric equation:</strong> (hkl) planes are <em>level sets</em> of <code>φ(r)=G·r</code>: <code>G·r = 2π n</code> for integer <code>n</code>.</li>
            <li><strong>Math-physics operator insight:</strong> <code>∇φ = G</code> is constant, so plane normals are <code>G</code>.</li>
            <li><strong>Main results (symbolic):</strong> <code>G ⟂ (hkl)</code> and <code>d(hkl)=2π/|G|</code>.</li>
            <li><strong>Simple cubic specialization:</strong> with lattice parameter <code>a</code>, <code>d = a / sqrt(h^2+k^2+l^2)</code>.</li>
            <li><strong>Physical meaning:</strong> larger |G| means tighter plane spacing; diffraction peaks occur when scattering vectors match reciprocal vectors.</li>
          </ul>
          <div class="callout good">
            <strong>Core takeaway</strong>
            In a crystal, the family of planes (hkl) can be described by a scalar “phase” field <code>φ(r)=G·r</code>.
            Its level sets are planes, and the gradient <code>∇φ</code> gives the normal direction.
          </div>
          <a class="backtop" href="#top">↑ Back to top</a>
        </section>

        <section id="p0">
          <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

          <div class="grid2">
            <div class="card">
              <h3>Core definitions (symbols + SI units)</h3>
              <ul>
                <li><strong>Direct lattice primitive vectors:</strong> <code>a1, a2, a3</code> (units: m).</li>
                <li><strong>Lattice points:</strong> <code>r = n1 a1 + n2 a2 + n3 a3</code> with <code>n_i ∈ ℤ</code> (units: m).</li>
                <li><strong>Reciprocal primitive vectors:</strong> <code>b1, b2, b3</code> (units: 1/m) defined by
                  <code>ai · bj = 2π δij</code>.</li>
                <li><strong>Reciprocal lattice vector:</strong> <code>G = h b1 + k b2 + l b3</code> with <code>h,k,l ∈ ℤ</code> (units: 1/m).</li>
                <li><strong>Miller indices:</strong> integers (hkl) labeling a family of equally spaced parallel planes.</li>
                <li><strong>Interplanar spacing:</strong> <code>d(hkl)</code> (units: m).</li>
              </ul>
            </div>

            <div class="card">
              <h3>Physical meaning / intuition</h3>
              <ul>
                <li><strong>Direct lattice</strong> describes atomic periodicity in real space.</li>
                <li><strong>Reciprocal lattice</strong> describes periodicity in Fourier space; diffraction conditions are naturally stated there.</li>
                <li>A plane family (hkl) corresponds to a set of density waves with wavevector <code>G</code>.</li>
                <li><strong>Bigger |G|</strong> means <strong>shorter real-space periodicity</strong> → smaller plane spacing.</li>
              </ul>
              <div class="callout">
                <strong>Why the factor 2π?</strong>
                The <code>2π</code> makes Fourier phases tidy: a plane-wave <code>exp(i G·r)</code> has the same phase at all lattice points.
              </div>
            </div>
          </div>

          <h3>Key principles and validity conditions</h3>
          <ul>
            <li><strong>Periodicity:</strong> crystal is modeled as an infinite (or large) periodic lattice; boundary effects ignored for plane-spacing geometry.</li>
            <li><strong>Linearity of dot product:</strong> used repeatedly to build plane equations from basis vectors.</li>
            <li><strong>Euclidean geometry in 3D:</strong> distances and perpendicularity use standard inner product <code>·</code>.</li>
          </ul>

          <h3>Common models/approximations in this topic (and why)</h3>
          <ul>
            <li><strong>Perfect lattice:</strong> no strain, defects, or thermal disorder → planes are exactly periodic.</li>
            <li><strong>Primitive-cell description:</strong> reduces geometry to three basis vectors; works for any Bravais lattice.</li>
            <li><strong>Fourier/reciprocal viewpoint:</strong> simplifies diffraction, filtering, and wave interactions with periodic media.</li>
          </ul>

          <h3>Mini intuition examples (conceptual, minimal algebra)</h3>
          <ul>
            <li><strong>1D analogy:</strong> equally spaced points at <code>x = n a</code> have Fourier wavevectors <code>G = 2π m / a</code>. Spacing in x is inversely proportional to |G|.</li>
            <li><strong>Orthogonality idea:</strong> level sets of <code>φ(r)=const</code> have normals <code>∇φ</code>. If <code>φ(r)=G·r</code>, normals are constant and equal to <code>G</code>.</li>
          </ul>

          <h3>What to watch for (pitfalls)</h3>
          <ul>
            <li><strong>Different conventions:</strong> some texts define reciprocal vectors without <code>2π</code>. Here it is included in <code>ai·bj=2πδij</code>.</li>
            <li><strong>Miller indices vs intercepts:</strong> (hkl) labels plane families; intercept-based definitions assume you understand the chosen axes.</li>
            <li><strong>Non-orthogonal lattices:</strong> in general, <code>a1,a2,a3</code> are not perpendicular; using cubic intuition can mislead.</li>
          </ul>

          <a class="backtop" href="#top">↑ Back to top</a>
        </section>

        <section id="p0b">
          <h2>PART 0B — Industry & Applied Physics Perspective</h2>

          <h3>Where this appears in industry (concrete application areas)</h3>
          <ul>
            <li><strong>X-ray diffraction (XRD) & quality control:</strong> extracting lattice parameters, texture, and phase identification relies on knowing <code>d(hkl)</code>.</li>
            <li><strong>Semiconductor manufacturing (epitaxy, wafers):</strong> wafer orientation (e.g., (100), (111)) controls growth rates, defect densities, and device mobility.</li>
            <li><strong>Metals & additive manufacturing:</strong> grain orientation and residual stress shift effective spacings and peak positions; essential for process tuning.</li>
            <li><strong>Thin films & coatings:</strong> multilayers depend on precise interplanar distances for reflectivity (Bragg mirrors) and mechanical properties.</li>
          </ul>

          <h3>Why engineers care</h3>
          <ul>
            <li><strong>Performance:</strong> orientation-dependent electron/phonon transport affects conductivity, thermal management, and reliability.</li>
            <li><strong>Manufacturability:</strong> choosing a crystal cut sets etch anisotropy, surface energy, and defect propagation pathways.</li>
            <li><strong>Cost & yield:</strong> fast non-destructive XRD checks identify off-spec lattice spacing (composition, strain) early.</li>
          </ul>

          <h3>Typical measurement / validation methods</h3>
          <ul>
            <li><strong>XRD / neutron diffraction:</strong> measure diffraction angles → infer <code>d</code> via Bragg’s law, which is reciprocal-lattice geometry in disguise.</li>
            <li><strong>TEM / SAED:</strong> electron diffraction patterns map directly to reciprocal lattice vectors and plane spacings.</li>
            <li><strong>EBSD (SEM-based):</strong> maps crystal orientations (hkl) over large areas for microstructure control.</li>
          </ul>

          <h3>Design trade-offs and constraints</h3>
          <ul>
            <li><strong>Non-idealities:</strong> strain, temperature, and defects distort <code>a_i</code> → modify <code>b_i</code> and shift spacings.</li>
            <li><strong>Tolerances:</strong> small changes in lattice parameter <code>a</code> cause measurable shifts in <code>d</code> and diffraction peaks.</li>
            <li><strong>Model adaptation:</strong> in products, the “perfect lattice” is replaced by a strained lattice field <code>a_i = a_i(x)</code>; locally, reciprocal vectors become position-dependent and XRD broadens.</li>
          </ul>

          <div class="callout">
            <strong>From lab to product</strong>
            The ideal formula <code>d = 2π/|G|</code> is used with corrections:
            strain tensors, thermal expansion, composition gradients, and finite-size broadening.
            Engineers still rely on the reciprocal-lattice geometry as the backbone of those corrections.
          </div>

          <a class="backtop" href="#top">↑ Back to top</a>
        </section>

        <section id="p1">
          <h2>PART 1 — Problem Analysis (no solving yet)</h2>

          <h3>Restate the problem in plain words</h3>
          <p>
            In a crystal lattice, consider the crystallographic plane family labeled by Miller indices (hkl).
            Define the reciprocal lattice vector <code>G = h b1 + k b2 + l b3</code>.
            Prove:
            (a) <code>G</code> is perpendicular (normal) to the plane (hkl);
            (b) the spacing between adjacent parallel planes is <code>d(hkl) = 2π/|G|</code>;
            (c) for simple cubic lattice, <code>d = a / sqrt(h^2 + k^2 + l^2)</code>.
          </p>

          <div class="grid2">
            <div class="card">
              <h3>Given quantities</h3>
              <ul>
                <li>Direct primitive vectors <code>a1,a2,a3</code></li>
                <li>Reciprocal primitive vectors <code>b1,b2,b3</code> with <code>ai·bj = 2π δij</code></li>
                <li>Integers <code>h,k,l</code> (Miller indices)</li>
              </ul>
            </div>
            <div class="card">
              <h3>Unknowns / targets</h3>
              <ul>
                <li>Direction of plane normal (show it is <code>G</code>)</li>
                <li>Distance <code>d(hkl)</code> between successive planes</li>
                <li>Cubic-lattice closed form in terms of <code>a</code></li>
              </ul>
            </div>
          </div>

          <h3>Relevant principles (and why they apply)</h3>
          <ul>
            <li><strong>Reciprocal lattice definition:</strong> <code>ai·bj = 2π δij</code> gives exact algebraic control over dot products and periodicity.</li>
            <li><strong>Planes as level sets:</strong> a plane family can be described by a scalar equation <code>φ(r)=const</code>; normal is <code>∇φ</code>.</li>
            <li><strong>Distance between parallel planes:</strong> for <code>n·r = c</code> with fixed normal <code>n</code>, spacing is <code>|Δc|/|n|</code>.</li>
          </ul>

          <div class="callout warn">
            <strong>Assumptions (explicit)</strong>
            <ul>
              <li>Perfect periodic lattice, Euclidean 3D geometry.</li>
              <li>We use the <code>2π</code>-inclusive reciprocal basis convention.</li>
              <li>Plane family (hkl) means all planes parallel to each other with the same indices.</li>
            </ul>
          </div>

          <h3>Mathematical model (variables, domains, coordinates, conditions)</h3>
          <div class="card">
            <p><strong>Domain:</strong> real space <code>r ∈ ℝ^3</code>. For lattice points, restrict to <code>r = n1 a1 + n2 a2 + n3 a3</code> with <code>n_i ∈ ℤ</code>.</p>
            <p><strong>Coordinate system:</strong> arbitrary Cartesian frame in ℝ³; the basis vectors <code>a_i</code> need not be orthogonal.</p>
            <p><strong>Field/function:</strong> define a scalar function <code>φ: ℝ^3 → ℝ</code> by <code>φ(r)=G·r</code>.</p>
            <p><strong>Boundary/initial conditions:</strong> none needed (static geometry). We use global definitions and integer labeling of planes via <code>φ(r)=2πn</code>.</p>
            <p><strong>Operators:</strong> gradient <code>∇φ</code> is used to identify normals of level sets.</p>
          </div>

          <h3>Propose 2–3 approaches (pros/cons)</h3>
          <ul>
            <li><strong>(A) Level-set / gradient method:</strong> define planes by <code>G·r=2πn</code>. Then <code>∇(G·r)=G</code> → immediate perpendicularity; spacing from plane formula. <em>Pros:</em> clean, operator-based, general. <em>Cons:</em> requires comfort with ∇ and level sets.</li>
            <li><strong>(B) Intercept/Miller definition method:</strong> show plane intercepts correspond to (hkl) and compute normal via cross products. <em>Pros:</em> matches classical crystallography. <em>Cons:</em> messier for non-orthogonal lattices.</li>
            <li><strong>(C) Fourier/periodicity method:</strong> use that <code>exp(iG·r)</code> is lattice-periodic; planes are constant-phase surfaces. <em>Pros:</em> directly connects to diffraction. <em>Cons:</em> abstract if you haven’t seen Fourier-space crystallography.</li>
          </ul>

          <p><strong>Chosen approach:</strong> (A), because it is the most mathematically transparent, works for any Bravais lattice, and naturally delivers both perpendicularity and spacing with minimal assumptions.</p>

          <a class="backtop" href="#top">↑ Back to top</a>
        </section>

        <section id="p2">
          <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

          <ol>
            <li><strong>Define the reciprocal vector</strong> <code>G = h b1 + k b2 + l b3</code> and recall <code>ai·bj=2πδij</code>. (Tool: linearity of dot product)</li>
            <li><strong>Build a scalar field</strong> <code>φ(r)=G·r</code>. (Tool: scalar product as linear functional)</li>
            <li><strong>Define (hkl) planes as level sets</strong> <code>φ(r)=2πn</code>. (Meaning: integer-indexed parallel planes)</li>
            <li><strong>Show the normal direction</strong> is <code>∇φ = G</code>, hence planes are perpendicular to <code>G</code>. (Tool: gradient of a linear function)</li>
            <li><strong>Compute spacing</strong> between <code>G·r=2πn</code> and <code>G·r=2π(n+1)</code> as <code>d = |Δc|/|G|</code> with <code>Δc=2π</code>. (Tool: distance between parallel planes)</li>
            <li><strong>Specialize to simple cubic</strong> where <code>b_i=(2π/a) e_i</code>. (Tool: explicit reciprocal basis)</li>
            <li><strong>Sanity-check</strong> units, limiting cases, and interpret physically (smaller spacing ↔ larger |G|).</li>
          </ol>

          <div class="callout bad">
            <strong>Common mistakes</strong>
            <ul>
              <li>Forgetting the <code>2π</code> convention and mixing definitions of <code>b_i</code>.</li>
              <li>Assuming orthogonality of <code>a_i</code> when the lattice is not cubic.</li>
              <li>Using a “plane through the origin” when the (hkl) family is actually a set of parallel planes labeled by an integer <code>n</code>.</li>
              <li>Computing <code>d</code> from intercepts without ensuring you are using adjacent planes (Δn = 1).</li>
            </ul>
          </div>

          <a class="backtop" href="#top">↑ Back to top</a>
        </section>

        <section id="p3">
          <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

          <h3>Physical intuition first (qualitative expectation)</h3>
          <p>
            A family of equally spaced parallel planes should have a single fixed normal direction.
            In diffraction and Fourier descriptions of periodic media, that normal direction is naturally a reciprocal vector.
            Also, “more rapidly varying phase” (larger |G|) should correspond to “tighter spacing” (smaller d), suggesting <code>d ∝ 1/|G|</code>.
          </p>

          <div class="callout">
            <strong>Math Insight (as a mathematical object)</strong>
            The equation <code>G·r = constant</code> defines a <em>hyperplane</em> in ℝ³: it is the level set of a linear functional.
            Its normal is the gradient of that functional: <code>∇(G·r) = G</code>.
            This is a clean example of geometry driven by a constant-coefficient first-order operator (the gradient).
          </div>

          <h3>Step 1 — Define the reciprocal lattice and the vector G</h3>
          <p>
            Let <code>a1,a2,a3</code> be primitive vectors of a Bravais lattice.
            The reciprocal primitive vectors <code>b1,b2,b3</code> are defined by:
          </p>
          <div class="eq" data-copy="a_i · b_j = 2π δ_ij">
            <div class="row">
              <pre>a_i · b_j = 2π δ_ij</pre>
              <button class="btn small" data-copy-btn>Copy equation</button>
            </div>
          </div>
          <p>
            Now define the reciprocal lattice vector:
          </p>
          <div class="eq" data-copy="G = h b1 + k b2 + l b3   with h,k,l ∈ ℤ">
            <div class="row">
              <pre>G = h b1 + k b2 + l b3   with h,k,l ∈ ℤ</pre>
              <button class="btn small" data-copy-btn>Copy equation</button>
            </div>
          </div>
          <p class="muted">
            Units check: <code>b_i</code> has units 1/m, so <code>G</code> has units 1/m. This matters for the distance formula later.
          </p>

          <h3>Step 2 — Mathematical-physics model: planes as level sets of a scalar field</h3>
          <p>
            Define a scalar function (a “phase” field) on real space:
          </p>
          <div class="eq" data-copy="φ(r) = G · r,   with r ∈ ℝ^3">
            <div class="row">
              <pre>φ(r) = G · r,   with r ∈ ℝ^3</pre>
              <button class="btn small" data-copy-btn>Copy equation</button>
            </div>
          </div>
          <p>
            Since <code>G</code> is constant (a fixed vector), <code>φ</code> is linear in <code>r</code>.
            The family of planes orthogonal to <code>G</code> can be represented as level sets:
          </p>
          <div class="eq" data-copy="Plane family:  G · r = 2π n,   n ∈ ℤ">
            <div class="row">
              <pre>Plane family:  G · r = 2π n,   n ∈ ℤ</pre>
              <button class="btn small" data-copy-btn>Copy equation</button>
            </div>
          </div>

          <details>
            <summary>Why is the constant chosen as 2πn?</summary>
            <p>
              Because with the convention <code>a_i·b_j = 2π δ_ij</code>, lattice translations preserve the phase of
              the plane wave <code>exp(i G·r)</code>:
            </p>
            <div class="eq" data-copy="For a lattice translation R = n1 a1 + n2 a2 + n3 a3:   exp(i G·(r+R)) = exp(i G·r) exp(i 2π (h n1 + k n2 + l n3)) = exp(i G·r).">
              <div class="row">
                <pre>For a lattice translation R = n1 a1 + n2 a2 + n3 a3:
exp(i G·(r+R)) = exp(i G·r) exp(i 2π (h n1 + k n2 + l n3)) = exp(i G·r).</pre>
                <button class="btn small" data-copy-btn>Copy equation</button>
              </div>
            </div>
            <p>
              Thus integer changes in <code>G·r</code> by multiples of <code>2π</code> label equivalent “phase planes.” This matches how (hkl) plane families repeat periodically.
            </p>
          </details>

          <h3>Step 3 — Prove (a): G is perpendicular to the (hkl) plane</h3>
          <p>
            Consider the plane defined by <code>G·r = 2π n</code>.
            A standard mathematical fact: for a surface defined implicitly by <code>F(r)=0</code>, the normal direction is <code>∇F</code>,
            provided <code>∇F ≠ 0</code>.
          </p>
          <p>
            Here we can take <code>F(r) = G·r - 2π n</code>. Then:
          </p>
          <div class="eq" data-copy="∇F(r) = ∇(G·r - 2π n) = ∇(G·r) - 0 = G">
            <div class="row">
              <pre>∇F(r) = ∇(G·r - 2π n) = ∇(G·r) - 0 = G</pre>
              <button class="btn small" data-copy-btn>Copy equation</button>
            </div>
          </div>
          <p>
            Why is <code>∇(G·r)=G</code> valid? Write <code>r=(x,y,z)</code> and <code>G=(Gx,Gy,Gz)</code>.
            Then <code>G·r = Gx x + Gy y + Gz z</code>, so:
          </p>
          <div class="eq" data-copy="∂(G·r)/∂x = Gx,   ∂(G·r)/∂y = Gy,   ∂(G·r)/∂z = Gz  ⇒  ∇(G·r) = (Gx,Gy,Gz)=G">
            <div class="row">
              <pre>∂(G·r)/∂x = Gx,   ∂(G·r)/∂y = Gy,   ∂(G·r)/∂z = Gz
⇒  ∇(G·r) = (Gx,Gy,Gz)=G</pre>
              <button class="btn small" data-copy-btn>Copy equation</button>
            </div>
          </div>
          <p>
            Therefore the normal to the plane is <code>G</code>. Hence <strong>G is perpendicular to every plane in the family</strong>:
            <strong>(a) proved.</strong>
          </p>

          <div class="callout good">
            <strong>Geometric interpretation</strong>
            Any tangent vector <code>t</code> lying in the plane satisfies no first-order change in <code>F</code>:
            <code>t·∇F = 0</code>. Since <code>∇F=G</code>, tangents satisfy <code>t·G=0</code>, i.e., the plane is orthogonal to <code>G</code>.
          </div>

          <h3>Step 4 — Prove (b): distance between adjacent planes is d = 2π/|G|</h3>
          <p>
            We now compute the spacing between two neighboring planes:
          </p>
          <div class="eq" data-copy="Plane n:   G·r = 2π n     and     Plane n+1:   G·r = 2π (n+1)">
            <div class="row">
              <pre>Plane n:   G·r = 2π n
Plane n+1: G·r = 2π (n+1)</pre>
              <button class="btn small" data-copy-btn>Copy equation</button>
            </div>
          </div>
          <p>
            Mathematical distance between two parallel planes in ℝ³:
            for <code>n̂·r = c1</code> and <code>n̂·r = c2</code> where <code>n̂</code> is any nonzero normal vector, the spacing is
            <code>|c2-c1| / |n̂|</code>. Here the normal is <code>G</code>, and the constants differ by <code>2π</code>.
          </p>
          <p>
            More explicitly (no “magic jump”): let <code>r_n</code> be a point on plane n. Move along the unit normal direction
            <code>u = G/|G|</code> by a distance <code>d</code> to reach plane n+1:
          </p>
          <div class="eq" data-copy="r_{n+1} = r_n + d (G/|G|)">
            <div class="row">
              <pre>r_{n+1} = r_n + d (G/|G|)</pre>
              <button class="btn small" data-copy-btn>Copy equation</button>
            </div>
          </div>
          <p>
            Enforce the plane equations:
          </p>
          <div class="eq" data-copy="G·r_n = 2π n,  and  G·r_{n+1} = 2π(n+1)">
            <div class="row">
              <pre>G·r_n = 2π n,  and  G·r_{n+1} = 2π(n+1)</pre>
              <button class="btn small" data-copy-btn>Copy equation</button>
            </div>
          </div>
          <p>
            Substitute <code>r_{n+1} = r_n + d (G/|G|)</code>:
          </p>
          <div class="eq" data-copy="G·r_{n+1} = G·r_n + d G·(G/|G|) = 2π n + d (|G|^2/|G|) = 2π n + d |G|">
            <div class="row">
              <pre>G·r_{n+1} = G·r_n + d G·(G/|G|)
          = 2π n + d (|G|^2/|G|)
          = 2π n + d |G|</pre>
              <button class="btn small" data-copy-btn>Copy equation</button>
            </div>
          </div>
          <p>
            But also <code>G·r_{n+1} = 2π(n+1) = 2πn + 2π</code>. Therefore:
          </p>
          <div class="eq" data-copy="2π n + d |G| = 2π n + 2π  ⇒  d |G| = 2π  ⇒  d(hkl) = 2π/|G|">
            <div class="row">
              <pre>2π n + d |G| = 2π n + 2π
⇒  d |G| = 2π
⇒  d(hkl) = 2π/|G|</pre>
              <button class="btn small" data-copy-btn>Copy equation</button>
            </div>
          </div>

          <div class="callout good">
            <strong>(b) proved</strong>
            The interplanar spacing is the “period” in the direction normal to the planes:
            <code>d = 2π / |G|</code>.
          </div>

          <h3>Sanity checks (units, limiting cases, interpretation)</h3>
          <ul>
            <li><strong>Units:</strong> |G| has units 1/m, so <code>2π/|G|</code> has units m. ✅</li>
            <li><strong>Limit |G|→∞:</strong> d→0 (very densely packed planes). Physically, high-index planes have small spacing. ✅</li>
            <li><strong>Limit |G|→0:</strong> d→∞ (planes extremely far apart). Only possible if (h,k,l)=(0,0,0), which is not a real plane family. ✅</li>
          </ul>

          <h3>Step 5 — Prove (c): simple cubic specialization</h3>
          <p>
            For a simple cubic lattice with lattice constant <code>a</code>, choose Cartesian unit vectors <code>e_x, e_y, e_z</code> and:
          </p>
          <div class="eq" data-copy="a1 = a e_x,   a2 = a e_y,   a3 = a e_z">
            <div class="row">
              <pre>a1 = a e_x,   a2 = a e_y,   a3 = a e_z</pre>
              <button class="btn small" data-copy-btn>Copy equation</button>
            </div>
          </div>
          <p>
            We need reciprocal vectors satisfying <code>ai·bj = 2π δij</code>. Because the basis is orthogonal:
          </p>
          <div class="eq" data-copy="b1 = (2π/a) e_x,   b2 = (2π/a) e_y,   b3 = (2π/a) e_z">
            <div class="row">
              <pre>b1 = (2π/a) e_x,   b2 = (2π/a) e_y,   b3 = (2π/a) e_z</pre>
              <button class="btn small" data-copy-btn>Copy equation</button>
            </div>
          </div>
          <p>
            Then:
          </p>
          <div class="eq" data-copy="G = h b1 + k b2 + l b3 = (2π/a)(h e_x + k e_y + l e_z)">
            <div class="row">
              <pre>G = h b1 + k b2 + l b3
  = (2π/a)(h e_x + k e_y + l e_z)</pre>
              <button class="btn small" data-copy-btn>Copy equation</button>
            </div>
          </div>
          <p>
            Its magnitude is:
          </p>
          <div class="eq" data-copy="|G| = (2π/a) sqrt(h^2 + k^2 + l^2)">
            <div class="row">
              <pre>|G| = (2π/a) sqrt(h^2 + k^2 + l^2)</pre>
              <button class="btn small" data-copy-btn>Copy equation</button>
            </div>
          </div>
          <p>
            Substitute into <code>d = 2π/|G|</code>:
          </p>
          <div class="eq" data-copy="d(hkl) = 2π / [(2π/a) sqrt(h^2+k^2+l^2)] = a / sqrt(h^2+k^2+l^2)">
            <div class="row">
              <pre>d(hkl) = 2π / [(2π/a) sqrt(h^2+k^2+l^2)]
      = a / sqrt(h^2+k^2+l^2)</pre>
              <button class="btn small" data-copy-btn>Copy equation</button>
            </div>
          </div>

          <div class="final" id="finalBox">
            <h3>Final Results (boxed)</h3>

            <div class="eq" data-copy="(a) The (hkl) planes are perpendicular to G = h b1 + k b2 + l b3.">
              <div class="row">
                <pre>(a) The (hkl) planes are perpendicular to
    G = h b1 + k b2 + l b3.</pre>
                <button class="btn small good" data-copy-btn>Copy</button>
              </div>
            </div>

            <div class="eq" data-copy="(b) The spacing between adjacent (hkl) planes is  d(hkl) = 2π / |G|.">
              <div class="row">
                <pre>(b) Spacing between adjacent (hkl) planes:
    d(hkl) = 2π / |G|.</pre>
                <button class="btn small good" data-copy-btn>Copy</button>
              </div>
            </div>

            <div class="eq" data-copy="(c) Simple cubic (lattice parameter a):  d(hkl) = a / sqrt(h^2 + k^2 + l^2).">
              <div class="row">
                <pre>(c) Simple cubic (lattice parameter a):
    d(hkl) = a / sqrt(h^2 + k^2 + l^2).</pre>
                <button class="btn small good" data-copy-btn>Copy</button>
              </div>
            </div>

            <button class="btn good" id="copyFinalInline" title="Copy all final results (plain text)">Copy all final results</button>
          </div>

          <a class="backtop" href="#top">↑ Back to top</a>
        </section>

        <section id="p4" class="pagebreak">
          <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

          <h3>Re-interpret the formula: what each term controls</h3>
          <ul>
            <li><code>G = h b1 + k b2 + l b3</code> selects a direction in reciprocal space; it is the normal to the plane family.</li>
            <li><code>|G|</code> sets the inverse length scale of the plane periodicity; <code>d = 2π/|G|</code> is exactly that period.</li>
            <li>In cubic crystals, the Euclidean norm becomes <code>sqrt(h^2+k^2+l^2)</code>, so higher indices mean smaller spacing.</li>
          </ul>

          <h3>Parameter dependence (qualitative)</h3>
          <ul>
            <li><strong>Increase h,k,l (in magnitude):</strong> |G| grows → <code>d</code> shrinks.</li>
            <li><strong>Increase lattice parameter a (cubic):</strong> reciprocal basis shrinks → spacing grows linearly with <code>a</code>.</li>
          </ul>

          <details>
            <summary>Nondimensionalization / scaling viewpoint</summary>
            <p>
              In cubic crystals, write a dimensionless spacing:
              <code>d/a = 1 / sqrt(h^2+k^2+l^2)</code>.
              This shows the entire geometry scales with <code>a</code>;
              the indices (hkl) only set a dimensionless direction/magnitude.
            </p>
          </details>

          <h3>Alternative derivation idea (brief but meaningful)</h3>
          <p>
            Using Fourier ideas: the crystal density can be expanded as
            <code>ρ(r) = Σ_G ρ_G exp(i G·r)</code>.
            Surfaces of constant phase for a given <code>G</code> satisfy <code>G·r = const</code>, which are planes orthogonal to <code>G</code>.
            The phase advances by <code>2π</code> when you move a distance <code>d = 2π/|G|</code> along the normal—same result, now tied directly to wave physics and diffraction.
          </p>

          <div class="callout">
            <strong>Why each math step is valid (quick checklist)</strong>
            <ul>
              <li><strong>Linearity:</strong> dot product distributes over sums → <code>G·r</code> is linear in <code>G</code> and <code>r</code>.</li>
              <li><strong>Gradient rule:</strong> <code>∇(c)=0</code> and <code>∇(G·r)=G</code> (component-wise partial derivatives).</li>
              <li><strong>Distance along the normal:</strong> the minimal distance between parallel planes is achieved along the common normal direction.</li>
            </ul>
          </div>

          <h3>Concept check (self-test with answers)</h3>
          <ul>
            <li><strong>Q:</strong> If we doubled all Miller indices (2h,2k,2l), what happens to spacing? <strong>A:</strong> |G| doubles → <code>d</code> halves.</li>
            <li><strong>Q:</strong> Why can’t (0,0,0) define a plane family? <strong>A:</strong> It gives <code>G=0</code>, so <code>G·r=0</code> doesn’t define a unique orientation or spacing.</li>
            <li><strong>Q:</strong> In non-cubic lattices, is <code>d = a / sqrt(h^2+k^2+l^2)</code> still true? <strong>A:</strong> No—only <code>d = 2π/|G|</code> remains universally true; |G| depends on the metric set by <code>a_i</code>.</li>
            <li><strong>Q:</strong> What is the “mathematical object” behind (hkl) planes? <strong>A:</strong> They are level sets of the linear functional <code>φ(r)=G·r</code>, i.e., affine hyperplanes in ℝ³.</li>
          </ul>

          <a class="backtop" href="#top">↑ Back to top</a>
        </section>

        <section id="p5">
          <h2>PART 5 — Optional Plot Guide</h2>
          <p>
            No plot is necessary here because the problem is purely symbolic and geometric:
            the key results follow exactly from linear algebra (dot products) and differential geometry of level sets (<code>∇</code>).
            A numeric curve would add little compared to the closed-form expressions.
          </p>
          <a class="backtop" href="#top">↑ Back to top</a>
        </section>

        <footer>
          <strong>Summary:</strong> Treat (hkl) planes as level sets <code>G·r = 2πn</code>. Then the normal is <code>∇(G·r)=G</code>,
          and the spacing is the phase step <code>2π</code> divided by the normal magnitude, giving <code>d = 2π/|G|</code>.
          For simple cubic, <code>|G|=(2π/a)√(h²+k²+l²)</code>, hence <code>d=a/√(h²+k²+l²)</code>.
        </footer>
      </main>
    </div>
  </div>

  <script>
    (function(){
      function copyText(text){
        if(!text) return;
        if(navigator.clipboard && navigator.clipboard.writeText){
          navigator.clipboard.writeText(text).catch(function(){
            fallbackCopy(text);
          });
        }else{
          fallbackCopy(text);
        }
      }

      function fallbackCopy(text){
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.setAttribute('readonly','');
        ta.style.position='fixed';
        ta.style.top='-1000px';
        ta.style.left='-1000px';
        document.body.appendChild(ta);
        ta.select();
        try{ document.execCommand('copy'); }catch(e){}
        document.body.removeChild(ta);
      }

      // Copy buttons for each equation block
      document.querySelectorAll('[data-copy-btn]').forEach(function(btn){
        btn.addEventListener('click', function(){
          const eq = btn.closest('.eq');
          const payload = eq ? eq.getAttribute('data-copy') : '';
          copyText(payload || '');
          btn.textContent = 'Copied!';
          setTimeout(()=>btn.textContent='Copy equation', 900);
        });
      });

      // Final answer copy (two buttons: sidebar and inline)
      function getFinalText(){
        return [
          "(a) The (hkl) planes are perpendicular to G = h b1 + k b2 + l b3.",
          "(b) The spacing between adjacent (hkl) planes is d(hkl) = 2π / |G|.",
          "(c) Simple cubic (lattice parameter a): d(hkl) = a / sqrt(h^2 + k^2 + l^2)."
        ].join("\n");
      }

      const copyFinalBtn = document.getElementById('copyFinalBtn');
      const copyFinalInline = document.getElementById('copyFinalInline');

      if(copyFinalBtn){
        copyFinalBtn.addEventListener('click', function(){
          copyText(getFinalText());
          copyFinalBtn.textContent = 'Copied final!';
          setTimeout(()=>copyFinalBtn.textContent='Copy final answer', 1100);
        });
      }
      if(copyFinalInline){
        copyFinalInline.addEventListener('click', function(){
          copyText(getFinalText());
          copyFinalInline.textContent = 'Copied!';
          setTimeout(()=>copyFinalInline.textContent='Copy all final results', 1100);
        });
      }

      // Smooth scroll for TOC (respect reduced motion)
      const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      document.querySelectorAll('.toc a').forEach(function(a){
        a.addEventListener('click', function(e){
          const href = a.getAttribute('href') || '';
          if(href.startsWith('#')){
            const target = document.querySelector(href);
            if(target){
              e.preventDefault();
              target.scrollIntoView({behavior: prefersReduced ? 'auto' : 'smooth', block: 'start'});
              history.replaceState(null, '', href);
            }
          }
        });
      });
    })();
  </script>
</body>
</html>
