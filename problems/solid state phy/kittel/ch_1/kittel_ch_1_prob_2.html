<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>FCC Plane Indices: Conventional Cubic → Primitive Rhombohedral Axes</title>
  <style>
    :root{
      --bg:#0b0f14;
      --card:#0f1620;
      --ink:#eaf0f7;
      --muted:#b8c4d6;
      --faint:#7e8aa0;
      --accent:#77b7ff;
      --accent2:#7dffcf;
      --warn:#ffcc66;
      --ok:#7dffcf;
      --line:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
      --radius2:22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 700px at 15% 5%, rgba(119,183,255,.16), transparent 55%),
                  radial-gradient(900px 600px at 85% 15%, rgba(125,255,207,.10), transparent 55%),
                  var(--bg);
      color:var(--ink);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:28px 18px 10px;
      border-bottom:1px solid var(--line);
      position:relative;
      overflow:hidden;
    }
    header .wrap{
      max-width:1200px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 1.4fr .6fr;
      gap:18px;
      align-items:start;
    }
    h1{
      font-size: clamp(1.55rem, 2.1vw, 2.25rem);
      letter-spacing:.2px;
      margin:.2rem 0 .35rem;
    }
    .subtitle{
      color:var(--muted);
      margin:0;
      max-width:68ch;
    }
    .badgeRow{
      display:flex; flex-wrap:wrap; gap:10px; justify-content:flex-end;
    }
    .badge{
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      padding:10px 12px;
      border-radius:999px;
      color:var(--muted);
      font-size:.92rem;
      box-shadow: 0 6px 18px rgba(0,0,0,.25);
      backdrop-filter: blur(6px);
      white-space:nowrap;
    }
    main{
      max-width:1200px;
      margin:0 auto;
      padding:18px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
    }

    /* Sticky ToC */
    nav.toc{
      position:sticky;
      top:14px;
      align-self:start;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .tocHeader{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .tocHeader strong{letter-spacing:.2px}
    .tocHeader .topLink{
      font-size:.9rem;
      color:var(--muted);
    }
    .tocList{
      margin:0; padding:10px 12px 14px;
      list-style:none;
      display:grid;
      gap:6px;
    }
    .tocList a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid transparent;
      color:var(--muted);
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
    }
    .tocList a:hover{
      background: rgba(119,183,255,.10);
      border-color: rgba(119,183,255,.25);
      transform: translateY(-1px);
      text-decoration:none;
      color:var(--ink);
    }

    section{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      padding:16px;
      overflow:hidden;
    }
    section + section{margin-top:14px}

    h2{
      margin:0 0 10px;
      font-size: clamp(1.15rem, 1.25vw, 1.35rem);
    }
    h3{
      margin:14px 0 8px;
      font-size:1.05rem;
      color:var(--ink);
    }
    p{margin:8px 0}
    ul{margin:8px 0 8px 18px}
    li{margin:6px 0}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 860px){
      .grid2{grid-template-columns: 1fr}
    }

    .callout{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(0,0,0,.18);
      padding:12px 12px 10px;
    }
    .callout strong{color:var(--ink)}
    .callout.assump{border-color: rgba(255,204,102,.35)}
    .callout.eq{border-color: rgba(119,183,255,.35)}
    .callout.mist{border-color: rgba(255,120,120,.35)}
    .callout.ans{border-color: rgba(125,255,207,.35)}
    .tagRow{display:flex; flex-wrap:wrap; gap:8px; margin-top:8px}
    .tag{
      font-size:.85rem;
      padding:5px 9px;
      border-radius:999px;
      border:1px solid var(--line);
      color:var(--muted);
      background: rgba(255,255,255,.03);
    }

    pre{
      margin:10px 0 0;
      padding:12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(8,12,18,.75);
      color: #e8f1ff;
      overflow:auto;
      font-family: var(--mono);
      font-size: .95rem;
      line-height:1.45;
    }
    .copyRow{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      margin-top:10px;
      flex-wrap:wrap;
    }
    button.copyBtn{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.04));
      color:var(--ink);
      border-radius: 12px;
      padding:9px 11px;
      cursor:pointer;
      font-size:.92rem;
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
    }
    button.copyBtn:hover{
      transform: translateY(-1px);
      border-color: rgba(119,183,255,.35);
      background: linear-gradient(180deg, rgba(119,183,255,.13), rgba(255,255,255,.04));
    }
    button.copyBtn:active{transform: translateY(0px) scale(.99)}
    .copyNote{
      font-size:.88rem;
      color:var(--faint);
      margin-top:6px;
    }

    details{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      border-radius: var(--radius);
      padding:10px 12px;
      margin-top:10px;
    }
    summary{
      cursor:pointer;
      color:var(--muted);
      font-weight:600;
      letter-spacing:.1px;
    }
    details[open] summary{color:var(--ink)}
    .backTop{
      display:inline-block;
      margin-top:12px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color:var(--muted);
    }
    .backTop:hover{
      color:var(--ink);
      border-color: rgba(119,183,255,.35);
      text-decoration:none;
    }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding:18px;
      color:var(--faint);
      font-size:.92rem;
    }

    /* Print friendly */
    @media print{
      body{background:#fff; color:#000}
      header, footer{border:none}
      nav.toc{display:none}
      main{display:block; max-width:none}
      section{box-shadow:none; background:#fff; border:1px solid #ccc}
      a{color:#000; text-decoration:underline}
      button.copyBtn{display:none}
      .backTop{display:none}
      details{break-inside:avoid}
      section{break-inside:avoid; page-break-inside:avoid}
      h2{page-break-after:avoid}
      pre{background:#f7f7f7; color:#000}
    }
  </style>
</head>

<body id="top">
<header>
  <div class="wrap">
    <div>
      <h1>Indices of Planes in FCC: Converting (100) and (001) to Primitive Rhombohedral Axes</h1>
      <p class="subtitle">
        We translate Miller indices given in the <em>conventional cubic</em> description of an FCC lattice into Miller indices
        referenced to the <em>primitive rhombohedral</em> axes <span style="white-space:nowrap;">a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub></span>
        shown in the figure.
      </p>
    </div>
    <div class="badgeRow" aria-label="context badges">
      <div class="badge">Applied physics lens</div>
      <div class="badge">Industrial engineering relevance</div>
      <div class="badge">Reciprocal-space method</div>
    </div>
  </div>
</header>

<main>
  <nav class="toc" aria-label="Table of contents">
    <div class="tocHeader">
      <strong>Table of Contents</strong>
      <a class="topLink" href="#top">Top ↑</a>
    </div>
    <ul class="tocList">
      <li><a href="#quick">Quick Summary</a></li>
      <li><a href="#part0">PART 0 — Concept Primer</a></li>
      <li><a href="#part0b">PART 0B — Industry & Applied Physics Perspective</a></li>
      <li><a href="#part1">PART 1 — Problem Analysis</a></li>
      <li><a href="#part2">PART 2 — Strategy & Tips</a></li>
      <li><a href="#part3">PART 3 — Full Solution</a></li>
      <li><a href="#part4">PART 4 — Deeper Understanding</a></li>
      <li><a href="#part5">PART 5 — Optional Plot Guide</a></li>
    </ul>
  </nav>

  <article>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><strong>What this is:</strong> Convert plane indices (100) and (001) from a conventional cubic FCC cell to indices referenced to primitive axes <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>3</sub>.</li>
        <li><strong>Key idea:</strong> Miller indices are best transformed through the <strong>reciprocal lattice</strong>: the plane normal is a reciprocal vector <strong>G</strong>.</li>
        <li><strong>Governing relation:</strong> <strong>G = h b</strong><sub>1</sub> + <strong>k b</strong><sub>2</sub> + <strong>l b</strong><sub>3</sub>, where b<sub>i</sub> · a<sub>j</sub> = 2π δ<sub>ij</sub>.</li>
        <li><strong>Primitive vectors (given):</strong> a<sub>1</sub> = (a/2)(ŷ+ẑ), a<sub>2</sub> = (a/2)(ẑ+ẋ), a<sub>3</sub> = (a/2)(ẋ+ŷ).</li>
        <li><strong>Result type:</strong> symbolic / exact integers (after clearing a factor of 2).</li>
        <li><strong>Final answers:</strong> (100)<sub>cubic</sub> → (0 1 1)<sub>primitive</sub>, and (001)<sub>cubic</sub> → (1 1 0)<sub>primitive</sub>.</li>
        <li><strong>Physical meaning:</strong> the same geometric planes are being described, but in a different basis; the normals are decomposed in a different reciprocal basis.</li>
      </ul>
      <a class="backTop" href="#top">Back to top ↑</a>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="grid2">
        <div class="callout">
          <h3>Core definitions</h3>
          <ul>
            <li><strong>Direct lattice vectors</strong> a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub> (units: m): define the primitive cell in real space.</li>
            <li><strong>Reciprocal lattice vectors</strong> b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub> (units: m<sup>−1</sup>): defined by
              b<sub>i</sub> · a<sub>j</sub> = 2π δ<sub>ij</sub>.</li>
            <li><strong>Miller indices</strong> (h k l): integers describing lattice planes; the plane normal is parallel to
              <strong>G</strong> = h b<sub>1</sub> + k b<sub>2</sub> + l b<sub>3</sub>.</li>
          </ul>
        </div>

        <div class="callout">
          <h3>Physical meaning (intuition)</h3>
          <ul>
            <li>The family of (h k l) planes is a set of equally spaced planes cutting the crystal.</li>
            <li>The reciprocal vector <strong>G</strong> points normal to the planes; its magnitude relates to plane spacing: |G| = 2π/d<sub>hkl</sub>.</li>
            <li>Changing the coordinate axes changes how you write the same <strong>G</strong> as a combination of basis vectors.</li>
          </ul>
        </div>
      </div>

      <div class="callout eq" style="margin-top:12px;">
        <strong>Key equations (reciprocal-space definition)</strong>
        <pre id="eq1" data-copy="Reciprocal basis:  b_i · a_j = 2π δ_ij
Plane normal:     G = h b1 + k b2 + l b3
Plane spacing:    |G| = 2π / d_hkl">Reciprocal basis:  b_i · a_j = 2π δ_ij
Plane normal:     G = h b1 + k b2 + l b3
Plane spacing:    |G| = 2π / d_hkl</pre>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="#eq1">Copy key equations</button>
        </div>
        <div class="copyNote">Copy buttons grab plain text (good for notes or reports).</div>
      </div>

      <h3>Validity conditions / assumptions</h3>
      <ul>
        <li>Perfect periodic lattice; plane families defined by lattice periodicity.</li>
        <li>We treat the FCC lattice using its conventional cubic cell for the <em>given</em> indices, but transform to the primitive basis for the <em>answer</em>.</li>
        <li>Miller indices are defined up to an overall common integer factor; we reduce to the smallest integers.</li>
      </ul>

      <h3>Common models/approximations (why we use them)</h3>
      <ul>
        <li><strong>Reciprocal lattice method:</strong> avoids messy intercept geometry in non-orthogonal primitive axes; transforms become linear algebra.</li>
        <li><strong>Integer scaling:</strong> if coefficients come out fractional, multiply by the least common multiple to get integer Miller indices.</li>
      </ul>

      <h3>Mini intuition examples (quick)</h3>
      <ul>
        <li>If you rotate your coordinate axes, the same physical vector has different components; plane indices behave similarly (but in reciprocal space).</li>
        <li>In cubic crystals, (100) and (001) are perpendicular. In a rhombohedral basis, those normals decompose into combinations of the new reciprocal basis vectors.</li>
      </ul>

      <div class="callout mist">
        <strong>What to watch for (pitfalls)</strong>
        <ul>
          <li><strong>Don’t transform plane indices using direct vectors.</strong> Planes transform naturally via <em>reciprocal</em> vectors (normals).</li>
          <li><strong>Fractions are OK temporarily.</strong> Clear them at the end to get integer indices.</li>
          <li><strong>“Conventional” vs “primitive” matters.</strong> FCC has a smaller primitive cell; bases are different even if the lattice is the same.</li>
        </ul>
      </div>

      <a class="backTop" href="#top">Back to top ↑</a>
    </section>

    <section id="part0b">
      <h2>PART 0B — Industry & Applied Physics Perspective</h2>

      <div class="grid2">
        <div class="callout">
          <h3>Where this shows up (3+ applications)</h3>
          <ul>
            <li><strong>X-ray/electron diffraction (XRD, EBSD, TEM):</strong> indexing diffraction peaks requires mapping between coordinate conventions and crystal bases.</li>
            <li><strong>Semiconductor wafer processing:</strong> orientation ((100), (111), etc.) determines etch rates, defect propagation, and device performance.</li>
            <li><strong>Metallurgy & additive manufacturing:</strong> texture/orientation impacts anisotropic strength, fatigue, and residual stress.</li>
            <li><strong>Thin-film epitaxy:</strong> lattice matching and growth directions are described by plane/direction indices in specific bases.</li>
          </ul>
        </div>

        <div class="callout">
          <h3>Why engineers care</h3>
          <ul>
            <li><strong>Performance:</strong> carrier mobility, slip systems, and cleavage planes depend on crystallographic orientation.</li>
            <li><strong>Reliability:</strong> crack growth and electromigration can be orientation-dependent.</li>
            <li><strong>Cost & manufacturability:</strong> choosing a wafer orientation affects yield and process windows.</li>
          </ul>
        </div>
      </div>

      <h3>Measurement / validation in practice</h3>
      <ul>
        <li>Diffraction peak positions → reciprocal vectors <strong>G</strong> → plane indices; orientation matrices convert between lab frame and crystal frame.</li>
        <li>EBSD maps grain orientation; indexing relies on consistent definitions of the crystal basis (conventional vs primitive).</li>
      </ul>

      <h3>Design trade-offs & non-idealities</h3>
      <ul>
        <li>Real crystals have strain, defects, and mosaic spread → peaks broaden and indexing becomes statistical.</li>
        <li>Tooling coordinates (machine axes) rarely align with crystal axes → transformations must be robust and traceable.</li>
      </ul>

      <details>
        <summary>From lab to product: how idealized indexing is adapted</summary>
        <p>
          In production, you rarely work with “pure” crystal axes. You build a pipeline:
          (1) calibrate instrument geometry, (2) determine an orientation matrix from reference peaks,
          (3) convert measured diffraction vectors into the chosen reciprocal basis, and (4) report indices in the convention used by the fab, standards, or customer.
          This problem is a small, clean version of that workflow.
        </p>
      </details>

      <a class="backTop" href="#top">Back to top ↑</a>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <p><strong>Restatement:</strong> We have an FCC lattice. Planes are labeled (100) and (001) using the <em>conventional cubic cell</em> axes x, y, z.
        The primitive FCC cell in the figure uses rhombohedral primitive translation vectors:</p>

      <pre id="given1" data-copy="a1 = (a/2)( yhat + zhat )
a2 = (a/2)( zhat + xhat )
a3 = (a/2)( xhat + yhat )">a1 = (a/2)( yhat + zhat )
a2 = (a/2)( zhat + xhat )
a3 = (a/2)( xhat + yhat )</pre>

      <div class="copyRow">
        <button class="copyBtn" data-copy-target="#given1">Copy given primitive vectors</button>
      </div>

      <h3>Given</h3>
      <ul>
        <li>FCC lattice with conventional cubic lattice constant <em>a</em>.</li>
        <li>Planes: (100)<sub>cubic</sub> and (001)<sub>cubic</sub>.</li>
        <li>Primitive direct basis a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub> as above.</li>
      </ul>

      <h3>Unknowns</h3>
      <ul>
        <li>Indices (h′ k′ l′) of the same planes when referenced to the primitive axes (a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>).</li>
      </ul>

      <h3>Relevant principles (and why)</h3>
      <ul>
        <li><strong>Reciprocal lattice definition:</strong> plane indices correspond to reciprocal lattice vectors normal to planes.</li>
        <li><strong>Basis change via linear algebra:</strong> express the same vector <strong>G</strong> in different reciprocal bases.</li>
      </ul>

      <div class="callout assump">
        <strong>Assumptions</strong>
        <ul>
          <li>Ideal FCC geometry; conventional cubic axes are orthonormal.</li>
          <li>Miller indices are reduced to smallest integers (overall scaling ignored).</li>
          <li>We use the same physical plane; only the coordinate description changes.</li>
        </ul>
      </div>

      <h3>Possible approaches (2–3) and comparison</h3>
      <ul>
        <li><strong>(A) Intercept method in primitive coordinates:</strong> find intercepts with a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub> axes.
          <br><span style="color:var(--faint)">Pros:</span> conceptually direct. <span style="color:var(--faint)">Cons:</span> primitive axes are not orthogonal; intercept geometry is easy to mishandle.</li>
        <li><strong>(B) Reciprocal-lattice (normal vector) method:</strong> compute primitive reciprocal vectors b<sub>i</sub>, then decompose the known cubic normal into them.
          <br><span style="color:var(--faint)">Pros:</span> systematic, robust, minimal geometric confusion. <span style="color:var(--faint)">Cons:</span> needs a small cross-product/volume computation.</li>
        <li><strong>(C) Matrix transformation of reciprocal bases:</strong> build direct-basis matrix A, then reciprocal basis is (2π)(A<sup>−1</sup>)<sup>T</sup>.
          <br><span style="color:var(--faint)">Pros:</span> clean linear algebra. <span style="color:var(--faint)">Cons:</span> feels abstract unless you’re comfortable with matrices.</li>
      </ul>

      <p><strong>Best choice:</strong> (B)/(C). We’ll compute b<sub>i</sub> and solve a 3×3 linear system; it is the least error-prone for non-orthogonal primitive axes.</p>

      <a class="backTop" href="#top">Back to top ↑</a>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

      <ol>
        <li><strong>Write the primitive direct vectors</strong> a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub> in cubic Cartesian components. <span style="color:var(--faint)">(Tool: vector components)</span></li>
        <li><strong>Compute primitive cell volume</strong> V = a<sub>1</sub> · (a<sub>2</sub> × a<sub>3</sub>). <span style="color:var(--faint)">(Tool: scalar triple product)</span></li>
        <li><strong>Compute primitive reciprocal vectors</strong> b<sub>1</sub> = 2π (a<sub>2</sub>×a<sub>3</sub>)/V, cyclic permutations. <span style="color:var(--faint)">(Principle: reciprocal basis definition)</span></li>
        <li><strong>Write the cubic reciprocal vector</strong> for the given plane:
          for (h k l)<sub>cubic</sub>, G = (2π/a)(h, k, l). <span style="color:var(--faint)">(Cubic orthonormal basis)</span></li>
        <li><strong>Decompose G</strong> as G = h′b<sub>1</sub> + k′b<sub>2</sub> + l′b<sub>3</sub>. <span style="color:var(--faint)">(Solve linear system)</span></li>
        <li><strong>Clear fractions</strong> and reduce to smallest integers → the primitive Miller indices.</li>
        <li><strong>Sanity check</strong>: confirm directions/normals make sense (e.g., symmetry between x and z cases).</li>
      </ol>

      <div class="callout mist">
        <strong>Common mistakes</strong>
        <ul>
          <li>Mixing up direct and reciprocal bases (planes live naturally in reciprocal space).</li>
          <li>Forgetting the 2π factors cancel consistently; you can often work “up to a common factor.”</li>
          <li>Not reducing indices to smallest integers (e.g., reporting (0 1/2 1/2) instead of (0 1 1)).</li>
        </ul>
      </div>

      <a class="backTop" href="#top">Back to top ↑</a>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Qualitative expectation (before calculating)</h3>
      <p>
        In the given primitive basis, each a<sub>i</sub> points along a face diagonal direction of the cube.
        So a plane that is “normal to x” (the cubic (100) plane) will generally not align with a single primitive reciprocal axis;
        instead it should be a combination of two of them—so getting something like (0 1 1) or similar is plausible.
      </p>

      <div class="callout assump">
        <strong>Setup</strong>
        <p>Use cubic Cartesian unit vectors (x̂, ŷ, ẑ). The primitive direct vectors are:</p>
        <pre id="eq2" data-copy="a1 = (a/2)(0,1,1)
a2 = (a/2)(1,0,1)
a3 = (a/2)(1,1,0)">a1 = (a/2)(0,1,1)
a2 = (a/2)(1,0,1)
a3 = (a/2)(1,1,0)</pre>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="#eq2">Copy component form</button>
        </div>
      </div>

      <h3>Step 1: Primitive cell volume</h3>
      <p>
        Compute the scalar triple product:
        V = a<sub>1</sub> · (a<sub>2</sub> × a<sub>3</sub>).
      </p>
      <p>
        Since each a<sub>i</sub> has a factor (a/2), the volume scales like (a/2)<sup>3</sup> times the determinant of the integer matrix.
        A direct evaluation gives:
      </p>
      <div class="callout eq">
        <pre id="eq3" data-copy="V = a^3 / 4">V = a^3 / 4</pre>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="#eq3">Copy</button>
        </div>
      </div>
      <p style="color:var(--faint)">
        Physical check: the FCC primitive cell has volume a<sup>3</sup>/4 (since FCC has 4 lattice points per conventional cubic cell).
      </p>

      <h3>Step 2: Primitive reciprocal vectors b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub></h3>
      <p>
        By definition:
        b<sub>1</sub> = 2π (a<sub>2</sub>×a<sub>3</sub>)/V, and cyclic permutations.
      </p>

      <div class="callout eq">
        <pre id="eq4" data-copy="b1 = (2π/a)(-1,  1,  1)
b2 = (2π/a)( 1, -1,  1)
b3 = (2π/a)( 1,  1, -1)">b1 = (2π/a)(-1,  1,  1)
b2 = (2π/a)( 1, -1,  1)
b3 = (2π/a)( 1,  1, -1)</pre>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="#eq4">Copy reciprocal basis</button>
        </div>
      </div>

      <details>
        <summary>Optional check: do these satisfy b<sub>i</sub>·a<sub>j</sub> = 2π δ<sub>ij</sub>?</summary>
        <p>
          Example: b<sub>1</sub>·a<sub>1</sub> = (2π/a)(-1,1,1) · (a/2)(0,1,1) = (2π)(1/2+1/2)=2π.
          Meanwhile b<sub>1</sub>·a<sub>2</sub> = (2π/a)(-1,1,1)·(a/2)(1,0,1) = (2π)(-1/2+0+1/2)=0, etc.
        </p>
      </details>

      <h3>Step 3: Write the cubic plane normals as reciprocal vectors</h3>
      <p>
        In a conventional cubic lattice (orthonormal x̂, ŷ, ẑ), the reciprocal basis vectors are (2π/a)x̂, (2π/a)ŷ, (2π/a)ẑ.
        Therefore, the reciprocal vector for (h k l)<sub>cubic</sub> is:
      </p>
      <div class="callout eq">
        <pre id="eq5" data-copy="For cubic indices (h k l):
G_cubic = (2π/a)(h, k, l)">For cubic indices (h k l):
G_cubic = (2π/a)(h, k, l)</pre>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="#eq5">Copy</button>
        </div>
      </div>

      <p>So for the two planes:</p>
      <ul>
        <li>(100)<sub>cubic</sub> → G<sub>100</sub> = (2π/a)(1,0,0)</li>
        <li>(001)<sub>cubic</sub> → G<sub>001</sub> = (2π/a)(0,0,1)</li>
      </ul>

      <h3>Step 4: Decompose each G into the primitive reciprocal basis</h3>
      <p>
        We want coefficients (h′, k′, l′) such that:
        G = h′ b<sub>1</sub> + k′ b<sub>2</sub> + l′ b<sub>3</sub>.
        Because each b<sub>i</sub> already has a factor (2π/a), we can cancel (2π/a) on both sides and solve using the integer vectors:
      </p>

      <div class="callout eq">
        <pre id="eq6" data-copy="Let  b1~ = (-1, 1, 1),  b2~ = (1, -1, 1),  b3~ = (1, 1, -1).
Solve  g = h' b1~ + k' b2~ + l' b3~  where g is (1,0,0) or (0,0,1).">Let  b1~ = (-1, 1, 1),  b2~ = (1, -1, 1),  b3~ = (1, 1, -1).
Solve  g = h' b1~ + k' b2~ + l' b3~  where g is (1,0,0) or (0,0,1).</pre>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="#eq6">Copy reduced system</button>
        </div>
      </div>

      <h3>Case A: (100)<sub>cubic</sub></h3>
      <p>
        Solve (1,0,0) = h′(-1,1,1) + k′(1,-1,1) + l′(1,1,-1).
        Component-wise:
      </p>
      <pre id="eq7" data-copy="x:  1 = -h' + k' + l'
y:  0 =  h' - k' + l'
z:  0 =  h' + k' - l'">x:  1 = -h' + k' + l'
y:  0 =  h' - k' + l'
z:  0 =  h' + k' - l'</pre>
      <div class="copyRow">
        <button class="copyBtn" data-copy-target="#eq7">Copy equations</button>
      </div>

      <p>
        Add the last two equations:
        (h′ - k′ + l′) + (h′ + k′ - l′) = 0 ⇒ 2h′ = 0 ⇒ h′ = 0.
        Then z-equation gives k′ = l′.
        Put into x-equation: 1 = 0 + k′ + k′ = 2k′ ⇒ k′ = 1/2 and l′ = 1/2.
      </p>

      <div class="callout ans">
        <strong>Thus, in the primitive reciprocal basis:</strong>
        <pre id="res1" data-copy="(100)_cubic corresponds to (h' k' l') = (0, 1/2, 1/2) in the primitive basis.
Clearing fractions → (0 1 1)_primitive.">(100)_cubic corresponds to (h' k' l') = (0, 1/2, 1/2) in the primitive basis.
Clearing fractions → (0 1 1)_primitive.</pre>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="#res1">Copy result</button>
        </div>
      </div>

      <h3>Case B: (001)<sub>cubic</sub></h3>
      <p>
        Now solve (0,0,1) = h′(-1,1,1) + k′(1,-1,1) + l′(1,1,-1).
        Component-wise:
      </p>
      <pre id="eq8" data-copy="x:  0 = -h' + k' + l'
y:  0 =  h' - k' + l'
z:  1 =  h' + k' - l'">x:  0 = -h' + k' + l'
y:  0 =  h' - k' + l'
z:  1 =  h' + k' - l'</pre>
      <div class="copyRow">
        <button class="copyBtn" data-copy-target="#eq8">Copy equations</button>
      </div>

      <p>
        Add x and y equations: (−h′ + k′ + l′) + (h′ − k′ + l′) = 0 ⇒ 2l′ = 0 ⇒ l′ = 0.
        Then x-equation gives k′ = h′.
        Plug into z: 1 = h′ + k′ − 0 = 2h′ ⇒ h′ = 1/2 and k′ = 1/2.
      </p>

      <div class="callout ans">
        <strong>Thus, in the primitive reciprocal basis:</strong>
        <pre id="res2" data-copy="(001)_cubic corresponds to (h' k' l') = (1/2, 1/2, 0) in the primitive basis.
Clearing fractions → (1 1 0)_primitive.">(001)_cubic corresponds to (h' k' l') = (1/2, 1/2, 0) in the primitive basis.
Clearing fractions → (1 1 0)_primitive.</pre>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="#res2">Copy result</button>
        </div>
      </div>

      <h3>Final boxed answer</h3>
      <div class="callout ans">
        <pre id="final" data-copy="Final (primitive-axis) plane indices:
(100)_cubic → (0 1 1)_primitive
(001)_cubic → (1 1 0)_primitive">Final (primitive-axis) plane indices:
(100)_cubic → (0 1 1)_primitive
(001)_cubic → (1 1 0)_primitive</pre>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="#final">Copy FINAL answer</button>
        </div>
        <div class="tagRow">
          <span class="tag">FCC</span>
          <span class="tag">Miller indices</span>
          <span class="tag">Reciprocal lattice</span>
          <span class="tag">Basis transform</span>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><strong>Dimensions:</strong> b<sub>i</sub> have units of 1/length, and G does too; consistent.</li>
        <li><strong>Symmetry check:</strong> swapping x ↔ z in the problem swaps the results (0 1 1) ↔ (1 1 0), matching the symmetry of the given a<sub>i</sub>.</li>
        <li><strong>Physical interpretation:</strong> fractions appear because one cubic reciprocal basis vector is halfway between two primitive reciprocal basis directions; clearing fractions restores integer plane labels.</li>
      </ul>

      <a class="backTop" href="#top">Back to top ↑</a>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the result</h3>
      <p>
        The statements
        (100)<sub>cubic</sub> → (0 1 1)<sub>primitive</sub> and
        (001)<sub>cubic</sub> → (1 1 0)<sub>primitive</sub>
        mean:
        the same physical plane normal vectors are being expressed as integer combinations of the primitive reciprocal vectors.
        The “mixing” of indices reflects that the primitive basis is tilted (rhombohedral) relative to the cubic axes.
      </p>

      <h3>Parameter dependence</h3>
      <ul>
        <li>The mapping of indices here is <strong>independent of a</strong> because both the direct and reciprocal vectors scale with a and cancel in the decomposition.</li>
        <li>What <em>does</em> depend on a is the plane spacing: d ∝ a, but the integer indices stay the same.</li>
      </ul>

      <h3>Alternative derivation idea (brief but meaningful)</h3>
      <p>
        You can do the transformation using matrices:
        put the direct primitive vectors as columns of a matrix A (in cubic components),
        then the reciprocal basis matrix is B = 2π (A<sup>−1</sup>)<sup>T</sup>.
        Finally solve B·(h′ k′ l′)<sup>T</sup> = G<sub>cubic</sub>.
        This is the same computation we effectively did by writing b<sub>i</sub> explicitly.
      </p>

      <div class="callout">
        <strong>Concept checks (self-test with answers)</strong>
        <ul>
          <li><strong>Q:</strong> Why do we transform via reciprocal vectors rather than direct vectors?
            <br><strong>A:</strong> Because plane indices encode the plane normal, which is a reciprocal-space object: G = h b<sub>1</sub> + k b<sub>2</sub> + l b<sub>3</sub>.</li>
          <li><strong>Q:</strong> If you got (0, 1/2, 1/2), is that “wrong”?
            <br><strong>A:</strong> No. Multiply by 2 to obtain the integer Miller indices (0 1 1). Indices are defined up to an overall integer factor.</li>
          <li><strong>Q:</strong> Would (200)<sub>cubic</sub> map to (0 2 2)<sub>primitive</sub>?
            <br><strong>A:</strong> Yes (same plane family as (100) but different scaling); reducing gives again (0 1 1) for the family.</li>
          <li><strong>Q:</strong> What does |G| tell you?
            <br><strong>A:</strong> The plane spacing: d = 2π/|G|.</li>
        </ul>
      </div>

      <a class="backTop" href="#top">Back to top ↑</a>
    </section>

    <section id="part5">
      <h2>PART 5 — Optional Plot Guide</h2>
      <p>
        A plot is not necessary here because the task is a <strong>pure basis-conversion</strong> problem in reciprocal space,
        yielding exact integer indices rather than a continuous relationship that benefits from visualization.
      </p>
      <a class="backTop" href="#top">Back to top ↑</a>
    </section>
  </article>
</main>

<footer>
  <p>
    Notes for practice: once you can compute reciprocal vectors, you can re-index planes/directions between any crystallographic conventions—critical for diffraction, texture analysis, and manufacturing orientation control.
  </p>
</footer>

<script>
  // Copy-to-clipboard buttons (plain text)
  (function(){
    function getTextFromTarget(sel){
      const el = document.querySelector(sel);
      if(!el) return '';
      const explicit = el.getAttribute('data-copy');
      return (explicit && explicit.trim().length) ? explicit : el.innerText;
    }

    async function copyText(text, btn){
      try{
        await navigator.clipboard.writeText(text);
        const old = btn.textContent;
        btn.textContent = 'Copied ✓';
        btn.style.borderColor = 'rgba(125,255,207,.45)';
        setTimeout(()=>{ btn.textContent = old; btn.style.borderColor = 'rgba(255,255,255,.14)'; }, 900);
      }catch(e){
        // Fallback
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position='fixed';
        ta.style.left='-9999px';
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        const old = btn.textContent;
        btn.textContent = 'Copied ✓';
        setTimeout(()=>{ btn.textContent = old; }, 900);
      }
    }

    document.querySelectorAll('button.copyBtn').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const sel = btn.getAttribute('data-copy-target');
        if(!sel) return;
        const text = getTextFromTarget(sel);
        copyText(text, btn);
      });
    });
  })();
</script>
</body>
</html>
