<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="color-scheme" content="dark light" />
  <meta name="theme-color" content="#0b1020" />
  <title>Fermat’s Principle with Maximum Time — Ellipse, Curvature, and Inflection</title>
  <style>
    :root{
      --bg:#070a14;
      --panel:#0d1530;
      --panel2:#0a1228;
      --text:#eaf0ff;
      --muted:#aab6dd;
      --faint:#7f8bb8;
      --line:rgba(255,255,255,.12);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 12% 8%, rgba(125,211,252,.18), transparent 55%),
        radial-gradient(900px 600px at 88% 22%, rgba(167,139,250,.16), transparent 55%),
        radial-gradient(700px 500px at 65% 95%, rgba(52,211,153,.10), transparent 60%),
        linear-gradient(180deg, #050714, #070a14 60%, #050714);
      line-height:1.55;
    }

    header{
      padding: clamp(18px, 3vw, 34px) clamp(16px, 5vw, 56px);
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.05), transparent);
      position:relative;
      overflow:hidden;
    }
    header::before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(800px 400px at 40% -10%, rgba(125,211,252,.12), transparent 60%),
        radial-gradient(900px 500px at 110% 30%, rgba(167,139,250,.10), transparent 60%);
      filter: blur(6px);
      pointer-events:none;
    }
    header > .wrap{position:relative; z-index:1; max-width:1100px; margin:0 auto;}
    h1{
      margin:0 0 10px 0;
      font-weight:800;
      letter-spacing:-.02em;
      font-size: clamp(1.35rem, 2.2vw + .8rem, 2.35rem);
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      max-width:78ch;
    }

    main{
      max-width:1100px;
      margin:0 auto;
      padding: clamp(14px, 3vw, 28px) clamp(12px, 4vw, 56px) 60px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 18px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.3fr .7fr;
      gap: 18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .pad{padding:16px 16px;}
    .card h2,.card h3{margin:0 0 8px 0}
    .card h2{font-size:1.1rem}
    .card h3{font-size:1.0rem; color:var(--text)}
    .muted{color:var(--muted)}
    .small{font-size:.94rem}
    .tiny{font-size:.86rem; color:var(--muted)}
    .mono{font-family:var(--mono)}
    .kicker{
      display:flex; gap:10px; align-items:center;
      font-weight:700; color: var(--text);
      padding: 12px 16px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(125,211,252,.10), transparent);
    }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      background: rgba(0,0,0,.18);
      color:var(--muted);
      font-size:.86rem;
      backdrop-filter: blur(8px);
    }

    /* Sticky mini ToC */
    .toc{
      position: sticky;
      top: 12px;
      z-index: 2;
    }
    .toc .pad{padding: 14px 14px 12px}
    .toc a{
      display:block;
      padding:8px 10px;
      color:var(--muted);
      text-decoration:none;
      border-radius:12px;
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .toc a:hover{
      color:var(--text);
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.10);
      transform: translateX(2px);
    }
    .toc .title{
      margin:0 0 8px 0;
      font-weight:800;
      letter-spacing:-.01em;
    }

    .callout{
      border-left: 4px solid rgba(125,211,252,.8);
      background: rgba(125,211,252,.07);
      padding: 12px 12px;
      border-radius: 12px;
    }
    .callout.warn{border-left-color: rgba(251,191,36,.9); background: rgba(251,191,36,.07);}
    .callout.good{border-left-color: rgba(52,211,153,.9); background: rgba(52,211,153,.07);}
    .callout.bad{border-left-color: rgba(251,113,133,.9); background: rgba(251,113,133,.07);}

    ul{margin: 8px 0 0 22px}
    li{margin: 6px 0}
    .hr{height:1px;background:var(--line); margin: 12px 0}

    .eq{
      margin:10px 0;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.16);
      border-radius: 12px;
      overflow:auto;
    }
    .eq pre{
      margin:0;
      font-family: var(--mono);
      font-size: .92rem;
      color: #eaf0ff;
      white-space: pre;
    }
    .eq-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 700;
      font-size: .88rem;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
    }
    .btn:hover{transform: translateY(-1px); background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.22);}
    .btn:active{transform: translateY(0px);}

    .controls{
      display:grid;
      gap: 10px;
    }
    .control{
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.16);
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size: .92rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .control input[type="range"]{width:100%;}
    .control select{
      width:100%;
      padding: 10px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      font-weight: 700;
      outline:none;
    }
    .readout{
      display:flex; flex-wrap:wrap; gap:10px;
      margin-top:10px;
    }
    .readout .pill{background: rgba(0,0,0,.20);}

    figure{margin:0;}
    canvas{display:block; width:100%; height:auto; background: rgba(0,0,0,.14); border-top:1px solid var(--line);}
    .canvas-wrap{
      border-top:1px solid var(--line);
      background: radial-gradient(700px 400px at 40% 10%, rgba(125,211,252,.08), transparent 60%);
    }
    .canvas-title{
      padding: 12px 16px 0;
      color: var(--muted);
      font-weight: 800;
      letter-spacing: -.01em;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .legend{
      padding: 8px 16px 14px;
      color: var(--muted);
      font-size:.9rem;
    }
    .badge{
      font-family: var(--mono);
      font-size:.82rem;
      padding: 4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: var(--muted);
      white-space:nowrap;
    }

    .final{
      border:1px solid rgba(52,211,153,.25);
      background: rgba(52,211,153,.08);
      border-radius: 16px;
      padding: 14px 14px;
    }
    .final h3{margin:0 0 8px 0}
    .final .box{
      border:1px dashed rgba(52,211,153,.55);
      background: rgba(0,0,0,.16);
      border-radius: 14px;
      padding: 12px;
      font-family: var(--mono);
      overflow:auto;
      white-space: pre-wrap;
    }

    footer{
      max-width:1100px;
      margin:0 auto;
      padding: 10px 16px 30px;
      color: var(--faint);
      text-align:center;
      border-top:1px solid var(--line);
    }

    @media print{
      body{background:#fff;color:#000}
      header, .card, .final{box-shadow:none}
      .toc{position:static}
      canvas{border:1px solid #ccc}
      .btn{display:none}
      .pill{border-color:#ccc}
      .card{background:#fff}
    }

    /* Subtle entrance */
    .fade-in{
      animation: fadeUp .35s ease both;
    }
    @keyframes fadeUp{
      from{opacity:0; transform: translateY(6px)}
      to{opacity:1; transform: translateY(0)}
    }
  </style>
</head>

<body>
  <header>
    <div class="wrap">
      <h1>Fermat’s Principle with <span style="color:var(--accent)">Maximum</span> Time: Elliptical Mirror, Curvature, and Inflection</h1>
      <p class="subtitle">
        We treat the optical travel time between foci <span class="mono">A</span> and <span class="mono">B</span> as a function of the reflection point on a mirror.
        Level sets of this time are ellipses. A mirror tangent to an ellipse can produce a <em>maximum</em>, <em>minimum</em>, or <em>inflection</em> of time depending on how its curvature compares to the ellipse at the tangency point.
      </p>
    </div>
  </header>

  <main>
    <section class="grid">
      <article class="card fade-in">
        <div class="kicker">
          <span>Quick Summary</span>
          <span class="pill">Fermat • Curvature • Stationary time</span>
        </div>
        <div class="pad">
          <ul>
            <li>The optical path length (OPL) via a point <span class="mono">Q</span> is <span class="mono">L(Q)=|AQ|+|QB|</span>; travel time is <span class="mono">T=L/c</span>.</li>
            <li><strong>Ellipses</strong> with foci <span class="mono">A,B</span> are exactly the level sets <span class="mono">L(Q)=const</span>; on the ellipse through <span class="mono">P</span>, <span class="mono">L=2a</span> is constant.</li>
            <li>If a mirror is <strong>tangent</strong> to that ellipse at <span class="mono">P</span>, then <span class="mono">P</span> is a <strong>stationary</strong> point of <span class="mono">T</span> along the mirror: <span class="mono">dT/ds=0</span>.</li>
            <li><strong>Part (a):</strong> If the mirror lies locally <em>inside</em> the ellipse (smaller radius of curvature, “more curved inward”), then nearby points have smaller <span class="mono">L</span>, so <span class="mono">P</span> gives a <strong>local maximum</strong> of time.</li>
            <li><strong>Part (b):</strong> If the mirror crosses the ellipse while staying tangent at <span class="mono">P</span>, then one side has larger <span class="mono">L</span> and the other smaller—so <span class="mono">P</span> is an <strong>inflection</strong> (neither max nor min).</li>
          </ul>
        </div>
      </article>

      <aside class="card toc fade-in" aria-label="Table of contents">
        <div class="pad">
          <div class="title">Table of Contents</div>
          <a href="#part1">PART 1 — Problem Analysis</a>
          <a href="#part2">PART 2 — Strategy & Tips</a>
          <a href="#part3">PART 3 — Full Solution</a>
          <a href="#viz">Interactive Visualizations</a>
        </div>
      </aside>
    </section>

    <section id="part1" class="card fade-in">
      <div class="kicker">
        <span>PART 1 — Problem Analysis (no solving yet)</span>
        <span class="pill">Understand • Define • Plan</span>
      </div>
      <div class="pad">
        <h2>1) Restate the problem in plain language</h2>
        <p class="muted">
          You have an ellipse with foci <span class="mono">A</span> and <span class="mono">B</span>. For a true elliptical mirror,
          any reflection point <span class="mono">P</span> on the ellipse gives the same total path length
          <span class="mono">|AP|+|PB|</span> as nearby points on the ellipse (because it is a level set).
        </p>
        <p class="muted">
          (a) Replace the ellipse by a different mirror curve that is <em>tangent</em> to the ellipse at <span class="mono">P</span>,
          but has <em>smaller radius of curvature</em> there (so it bends more strongly). Show the ray path
          <span class="mono">A→P→B</span> has <strong>maximum</strong> travel time compared with nearby reflection points
          <span class="mono">Q, Q′</span> on that new mirror.
        </p>
        <p class="muted">
          (b) Now use a mirror that <em>crosses</em> the ellipse but is still tangent at <span class="mono">P</span>.
          Show that the possible ray paths correspond to an <strong>inflection</strong> of travel time at <span class="mono">P</span>.
        </p>

        <div class="hr"></div>

        <h2>2) Given quantities</h2>
        <ul>
          <li>Two fixed points (foci) <span class="mono">A</span> and <span class="mono">B</span>.</li>
          <li>An ellipse defined by the property <span class="mono">|AQ|+|QB|=2a</span> (constant) for points <span class="mono">Q</span> on it.</li>
          <li>A tangency point <span class="mono">P</span> where an alternative mirror curve shares the same tangent direction as the ellipse.</li>
          <li>Local curvature condition: mirror has smaller radius of curvature than the ellipse at <span class="mono">P</span> (part a), or crosses the ellipse (part b).</li>
          <li>Speed of light <span class="mono">c</span> (constant, same medium).</li>
        </ul>

        <h2>3) Unknowns</h2>
        <ul>
          <li>The local nature of the extremum of travel time <span class="mono">T(Q)= (|AQ|+|QB|)/c</span> along the new mirror:
            maximum / minimum / inflection.</li>
          <li>A clear criterion in terms of geometry (inside/outside the ellipse; curvature relative to the ellipse).</li>
        </ul>

        <h2>4) What must be proved</h2>
        <ul>
          <li><strong>(a)</strong> For the “more curved” tangent mirror (inscribed as in the figure), show
            <span class="mono">T(P) &gt; T(Q)</span> and <span class="mono">T(P) &gt; T(Q′)</span> for nearby points on that mirror.</li>
          <li><strong>(b)</strong> For a tangent mirror that crosses the ellipse, show <span class="mono">T</span> has an inflection at <span class="mono">P</span> along that mirror (time increases on one side and decreases on the other; no local max/min).</li>
        </ul>

        <h2>5) Relevant principles and why they apply</h2>
        <ul>
          <li><strong>Fermat’s principle (stationary time):</strong> the physical ray makes the travel time stationary under small variations of the path. Here, varying the reflection point along the mirror varies <span class="mono">T</span>.</li>
          <li><strong>Geometry of ellipses:</strong> the set of points with fixed <span class="mono">|AQ|+|QB|</span> is an ellipse. Thus, the ellipse is a <em>level set</em> of the travel time function.</li>
          <li><strong>Differential geometry / curvature:</strong> whether a stationary point is a maximum/minimum/inflection depends on the second derivative of <span class="mono">T</span> along the mirror, which is controlled by how the mirror bends relative to the level set (ellipse).</li>
        </ul>

        <h2>6) Possible approaches</h2>
        <ol>
          <li><strong>Level-set (contour) argument (geometric):</strong> Since <span class="mono">L(Q)=|AQ|+|QB|</span> has ellipses as contours, a curve tangent to a contour is stationary; if it lies locally inside/outside, that implies max/min immediately.</li>
          <li><strong>Local Taylor expansion with curvature:</strong> Parametrize the mirror by arc length <span class="mono">s</span> near <span class="mono">P</span> and compute <span class="mono">dL/ds</span> and <span class="mono">d²L/ds²</span> using the Hessian of <span class="mono">L</span> and the mirror curvature.</li>
          <li><strong>Reflection-law route:</strong> Use the law of reflection to show stationarity, then use curvature to classify the stationary point.</li>
        </ol>
        <div class="callout good">
          <strong>Best approach:</strong> combine (1) and (2). The contour picture gives fast intuition (inside ⇒ smaller <span class="mono">L</span>, outside ⇒ larger <span class="mono">L</span>),
          and the curvature/Taylor method makes the “maximum vs inflection” statement rigorous.
        </div>
      </div>
    </section>

    <section id="part2" class="card fade-in">
      <div class="kicker">
        <span>PART 2 — Strategy & Tips (roadmap only)</span>
        <span class="pill">5–10 steps • No algebra yet</span>
      </div>
      <div class="pad">
        <h2>Roadmap (minimal steps)</h2>
        <ol>
          <li>
            <strong>Define the objective.</strong>
            <div class="tiny">Goal: express time as a scalar function of reflection point.</div>
            <div class="tiny">Tool: <span class="mono">T(Q)=L(Q)/c</span>, <span class="mono">L(Q)=|AQ|+|QB|</span>.</div>
          </li>
          <li>
            <strong>Identify level sets of <span class="mono">L</span>.</strong>
            <div class="tiny">Goal: connect “constant OPL” with ellipses.</div>
            <div class="tiny">Tool: ellipse definition: <span class="mono">|AQ|+|QB|=const</span>.</div>
          </li>
          <li>
            <strong>Use tangency ⇒ stationarity.</strong>
            <div class="tiny">Goal: show <span class="mono">dL/ds=0</span> at <span class="mono">P</span> for any curve tangent to the ellipse.</div>
            <div class="tiny">Tool: gradient is normal to level set; tangency makes directional derivative zero.</div>
          </li>
          <li>
            <strong>Classify the stationary point via curvature.</strong>
            <div class="tiny">Goal: determine sign/behavior of <span class="mono">d²L/ds²</span> or the “inside/outside” behavior.</div>
            <div class="tiny">Tool: compare mirror curvature with ellipse curvature at <span class="mono">P</span> (second-order contact).</div>
          </li>
          <li>
            <strong>Part (a): inscribed, more curved mirror.</strong>
            <div class="tiny">Goal: show neighbors on the mirror sit on ellipses with smaller <span class="mono">L</span> ⇒ <span class="mono">P</span> is a maximum.</div>
            <div class="tiny">Tool: local “inside the contour” argument + second derivative sign.</div>
          </li>
          <li>
            <strong>Part (b): crossing mirror.</strong>
            <div class="tiny">Goal: show <span class="mono">L</span> increases on one side and decreases on the other ⇒ inflection.</div>
            <div class="tiny">Tool: mirror switches sides relative to the contour while keeping tangency at <span class="mono">P</span>.</div>
          </li>
          <li>
            <strong>Sanity checks.</strong>
            <div class="tiny">Goal: ensure time ordering matches geometry; check units.</div>
            <div class="tiny">Tool: <span class="mono">T=L/c</span>, monotonic in <span class="mono">L</span>.</div>
          </li>
        </ol>

        <div class="hr"></div>

        <h2>Common mistakes & quick tips</h2>
        <ul>
          <li><strong>Mistake:</strong> confusing “ellipse is constant OPL” with “maximum/minimum.” On the ellipse itself, <span class="mono">L</span> is constant; classification happens when you restrict <span class="mono">L</span> to a different curve.</li>
          <li><strong>Tip:</strong> Always decide which side of the ellipse corresponds to <em>larger</em> <span class="mono">L</span>. Bigger ellipses mean larger <span class="mono">L</span>.</li>
          <li><strong>Mistake:</strong> thinking tangency alone implies a maximum. Tangency implies <em>stationary</em> time, not its type.</li>
          <li><strong>Tip:</strong> “Inside vs outside” is the quickest classifier: inside → smaller <span class="mono">L</span>, outside → larger <span class="mono">L</span>, crossing → mixed (inflection).</li>
        </ul>
      </div>
    </section>

    <section id="part3" class="card fade-in">
      <div class="kicker">
        <span>PART 3 — Full Solution</span>
        <span class="pill">Intuition → Math → Final</span>
      </div>
      <div class="pad">
        <h2>Physical intuition</h2>
        <p class="muted">
          Think of <span class="mono">L(Q)=|AQ|+|QB|</span> as a “height function” over the plane. Its contour lines are ellipses with foci <span class="mono">A,B</span>.
          At a point <span class="mono">P</span> on one contour, any curve tangent to that contour has <em>no first-order change</em> in <span class="mono">L</span> when you move along it:
          you are moving “sideways” along the contour direction.
        </p>
        <p class="muted">
          Whether <span class="mono">P</span> is a <strong>maximum</strong> or an <strong>inflection</strong> for a different mirror depends on the second-order behavior:
          does the mirror stay on the “lower <span class="mono">L</span> side” (inside the ellipse) near <span class="mono">P</span>,
          or does it cross to the “higher <span class="mono">L</span> side”?
        </p>

        <div class="hr"></div>

        <h2>Step 1 — Define optical path length and time</h2>
        <p>
          Let <span class="mono">Q</span> be a point on a mirror curve <span class="mono">C</span>. The travel time is
          <span class="mono">T(Q)=L(Q)/c</span> where
        </p>

        <div class="eq" role="group" aria-label="Equation with copy button">
          <div class="eq-row">
            <strong class="muted">Key equation</strong>
            <button class="btn copy" data-copy="L(Q)=|AQ|+|QB|,   T(Q)=L(Q)/c">Copy</button>
          </div>
          <pre>L(Q) = |A Q| + |Q B|         and         T(Q) = L(Q)/c</pre>
        </div>

        <p class="muted">
          Because <span class="mono">c</span> is constant, maximizing/minimizing travel time is equivalent to maximizing/minimizing <span class="mono">L</span>.
          So we analyze <span class="mono">L(Q)</span>.
        </p>

        <h2>Step 2 — Ellipses are level sets of <span class="mono">L(Q)</span></h2>
        <p>
          The set of points <span class="mono">Q</span> such that <span class="mono">|AQ|+|QB|</span> is a constant is, by definition, an ellipse with foci <span class="mono">A</span> and <span class="mono">B</span>.
          Therefore, the ellipse drawn in the problem is exactly the contour
        </p>

        <div class="eq">
          <div class="eq-row">
            <strong class="muted">Ellipse / level-set identity</strong>
            <button class="btn copy" data-copy="Ellipse with foci A,B: |AQ|+|QB|=2a (constant).">Copy</button>
          </div>
          <pre>|A Q| + |Q B| = 2a   (constant on the ellipse)</pre>
        </div>

        <p class="muted">
          In particular, at any point <span class="mono">P</span> on that ellipse, <span class="mono">L(P)=2a</span>.
          Nearby points <span class="mono">P±</span> on the same ellipse have the same <span class="mono">L</span>.
        </p>

        <h2>Step 3 — Tangency implies stationarity: <span class="mono">dL/ds = 0</span> at <span class="mono">P</span></h2>
        <p>
          Parametrize the mirror curve by arc length <span class="mono">s</span>, so <span class="mono">r(s)</span> lies on the mirror and <span class="mono">r(0)=P</span>.
          Consider <span class="mono">L(s)=L(r(s))</span>.
          Using the chain rule,
        </p>

        <div class="eq">
          <div class="eq-row">
            <strong class="muted">Directional derivative</strong>
            <button class="btn copy" data-copy="dL/ds = ∇L(P) · t(P), where t is unit tangent of the mirror.">Copy</button>
          </div>
          <pre>dL/ds = ∇L(r(s)) · r'(s)   ⇒   (dL/ds)|_{P} = ∇L(P) · t(P)</pre>
        </div>

        <p class="muted">
          The gradient <span class="mono">∇L(P)</span> is normal to the level set (ellipse) through <span class="mono">P</span>.
          If the mirror is tangent to the ellipse at <span class="mono">P</span>, then its tangent direction <span class="mono">t(P)</span> is along the ellipse tangent,
          hence perpendicular to <span class="mono">∇L(P)</span>. Therefore:
        </p>

        <div class="callout good">
          <strong>Stationarity at tangency:</strong>
          <span class="mono">(dL/ds)|_P = 0</span> (and thus <span class="mono">(dT/ds)|_P = 0</span>).
        </div>

        <h2>Step 4 — Second derivative and curvature: how to decide max/min/inflection</h2>
        <p>
          Stationary does not mean maximum. We need the next-order behavior of <span class="mono">L(s)</span> near <span class="mono">s=0</span>.
          With arc-length parametrization, the curve’s second derivative is
          <span class="mono">r''(s)=κ(s) n(s)</span>, where <span class="mono">κ</span> is curvature and <span class="mono">n</span> is the unit normal.
        </p>

        <p class="muted">
          A clean geometric fact: <strong>near a point <span class="mono">P</span>, the ellipse through <span class="mono">P</span> is the contour line <span class="mono">L=const</span></strong>.
          Moving to an ellipse with a <em>larger</em> constant (a “bigger” ellipse) increases <span class="mono">L</span>; moving to a smaller ellipse decreases <span class="mono">L</span>.
          So the sign of <span class="mono">L(s)-L(0)</span> is determined by which side of the ellipse the mirror lies on.
        </p>

        <div class="callout">
          <strong>Classifier (contour picture):</strong>
          <ul>
            <li>If the mirror lies locally on the <strong>inside</strong> of the ellipse near <span class="mono">P</span>, then nearby points satisfy <span class="mono">L&lt;L(P)</span> ⇒ <span class="mono">P</span> is a <strong>local maximum</strong> of <span class="mono">L</span> on the mirror.</li>
            <li>If the mirror lies locally on the <strong>outside</strong>, then nearby points satisfy <span class="mono">L&gt;L(P)</span> ⇒ <span class="mono">P</span> is a <strong>local minimum</strong>.</li>
            <li>If the mirror <strong>crosses</strong> the ellipse while remaining tangent at <span class="mono">P</span>, then one side has <span class="mono">L&gt;L(P)</span> and the other <span class="mono">L&lt;L(P)</span> ⇒ <span class="mono">P</span> is an <strong>inflection</strong> (no local extremum).</li>
          </ul>
        </div>

        <p>
          To make the “inside/outside” statement rigorous, compare <em>curvatures</em>.
          Let <span class="mono">κ_E</span> be the curvature of the ellipse (the contour <span class="mono">L=const</span>) at <span class="mono">P</span>,
          and <span class="mono">κ_M</span> the curvature of the mirror at <span class="mono">P</span>, measured with the same normal orientation.
          Then, to second order,
        </p>

        <div class="eq">
          <div class="eq-row">
            <strong class="muted">Curvature criterion (local classification)</strong>
            <button class="btn copy" data-copy="Near tangency: L(s)−L(0) ≈ (|∇L(P)|/2) (κ_M−κ_E) s^2 (with consistent normal).">Copy</button>
          </div>
          <pre>Near P (tangent contact):
L(s) − L(0)  ≈  (|∇L(P)|/2) · (κ_M − κ_E) · s^2    (choose a consistent normal)</pre>
        </div>

        <p class="muted">
          Interpretation: if the mirror bends more toward the <em>lower-L</em> side than the contour does,
          the mirror stays “inside” and <span class="mono">L(s)</span> curves downward (maximum at <span class="mono">s=0</span>);
          if it bends toward the <em>higher-L</em> side, it stays “outside” and <span class="mono">L(s)</span> curves upward (minimum).
          If the mirror crosses the contour, the leading even term can vanish/flip and the behavior becomes inflection-like (odd term dominates in the signed distance to the contour).
        </p>

        <h2>Part (a) — Tangential mirror with smaller radius of curvature ⇒ maximum time</h2>
        <p>
          In the figure’s case (b), the new mirror is tangent at <span class="mono">P</span> but has <strong>smaller radius of curvature</strong> than the ellipse.
          Smaller radius means <strong>larger curvature magnitude</strong> (<span class="mono">κ = 1/ρ</span>).
          The picture shows the mirror is <strong>inscribed</strong> relative to the ellipse at <span class="mono">P</span>, i.e. it lies locally on the <em>inside</em> of the ellipse near <span class="mono">P</span>.
        </p>
        <p class="muted">
          Since the ellipse through <span class="mono">P</span> is the contour <span class="mono">L=2a</span>, points inside that ellipse have
          <span class="mono">L &lt; 2a</span>, while points outside have <span class="mono">L &gt; 2a</span>.
          Because the mirror near <span class="mono">P</span> stays inside, its nearby points <span class="mono">Q, Q′</span> satisfy:
        </p>

        <div class="eq">
          <div class="eq-row">
            <strong class="muted">Key inequality (maximum time)</strong>
            <button class="btn copy" data-copy="If the mirror is tangent at P and lies inside the ellipse near P, then |AQ|+|QB| < |AP|+|PB| for nearby Q,Q′ on the mirror.">Copy</button>
          </div>
          <pre>For Q, Q′ near P on the inscribed tangent mirror:
|A Q| + |Q B|  <  |A P| + |P B|  = 2a</pre>
        </div>

        <p>
          Dividing by <span class="mono">c</span> gives the same ordering for times:
          <span class="mono">T(Q)&lt;T(P)</span> and <span class="mono">T(Q′)&lt;T(P)</span>.
          Thus the path <span class="mono">A→P→B</span> has <strong>maximum</strong> time among nearby reflection points on that mirror.
        </p>

        <div class="callout good">
          <strong>Conclusion (a):</strong> On the inscribed, more-curved tangent mirror, <span class="mono">P</span> is a <strong>local maximum</strong> of <span class="mono">T</span>.
        </div>

        <h2>Part (b) — Tangential mirror that crosses the ellipse ⇒ inflection</h2>
        <p>
          Now the mirror is still tangent at <span class="mono">P</span>, so <span class="mono">dL/ds=0</span> at <span class="mono">P</span>.
          But it <strong>crosses</strong> the ellipse: for small <span class="mono">s&gt;0</span> it lies on (say) the outside side, and for small <span class="mono">s&lt;0</span> it lies on the inside side (or vice versa).
        </p>
        <p class="muted">
          Therefore, immediately on opposite sides of <span class="mono">P</span> we have opposite inequalities:
        </p>

        <div class="eq">
          <div class="eq-row">
            <strong class="muted">Opposite-side behavior (inflection)</strong>
            <button class="btn copy" data-copy="Crossing tangent mirror: for s>0, L(s)>L(0); for s<0, L(s)<L(0) (or vice versa), so P is an inflection of L along the mirror.">Copy</button>
          </div>
          <pre>Crossing case:
for points on one side:   |A Q| + |Q B|  >  |A P| + |P B|
for the other side:       |A Q| + |Q B|  <  |A P| + |P B|</pre>
        </div>

        <p>
          That is exactly the signature of an <strong>inflection</strong>: the function is stationary at <span class="mono">P</span> (first derivative zero),
          but it is not a local max or min because it increases on one side and decreases on the other.
          Equivalently, the “curvature sign” of <span class="mono">L(s)</span> changes across <span class="mono">P</span>.
        </p>

        <div class="callout warn">
          <strong>Conclusion (b):</strong> With tangency plus crossing, <span class="mono">P</span> is an <strong>inflection point</strong> of the travel time <span class="mono">T(s)</span> along the mirror.
        </div>

        <div class="hr"></div>

        <div class="final">
          <h3>Final Result (boxed)</h3>
          <div class="final box" id="finalBox">Let L(Q)=|AQ|+|QB| and T(Q)=L(Q)/c.
The ellipse with foci A,B is the level set L(Q)=2a.

If a mirror curve C is tangent to that ellipse at P, then along C:
(dT/ds)|P = 0  (stationary time).

(a) If C lies locally inside the ellipse near P (as for an inscribed mirror with smaller radius of curvature),
then nearby points Q,Q′ on C satisfy L(Q),L(Q′) < L(P)=2a, hence T(Q),T(Q′) < T(P):
A→P→B is a local maximum-time path among nearby reflections.

(b) If C crosses the ellipse while remaining tangent at P, then one side of P has L>2a and the other has L<2a.
Thus T increases on one side and decreases on the other: P is an inflection point (not a local max/min).</div>
          <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
            <button class="btn copy" data-copy-target="#finalBox">Copy final answer</button>
            <span class="pill">Time ordering follows OPL since c is constant</span>
          </div>
        </div>

        <h2>Sanity checks</h2>
        <ul>
          <li><strong>Units:</strong> <span class="mono">L</span> has units of length; <span class="mono">T=L/c</span> has units of time. Inequalities are preserved by dividing by <span class="mono">c</span>.</li>
          <li><strong>Limiting case:</strong> If the mirror coincides with the ellipse, then <span class="mono">L</span> is constant along it (neither max nor min—flat direction).</li>
          <li><strong>Physical interpretation:</strong> The ray is always stationary at tangency. Whether it is fastest/slowest depends on whether the allowed nearby reflection points lie on smaller or larger OPL ellipses.</li>
        </ul>
      </div>
    </section>

    <section id="viz" class="card fade-in">
      <div class="kicker">
        <span>Interactive Visualizations</span>
        <span class="pill">Canvas • Live update</span>
      </div>

      <div class="pad">
        <div class="callout">
          <strong>How to use:</strong>
          Choose a mirror type (inscribed / circumscribed / crossing) and adjust the curvature slider.
          The diagram shows the geometry and nearby points; the plots show <span class="mono">L(s)=|A r(s)|+|r(s) B|</span> versus mirror coordinate <span class="mono">s</span>.
        </div>

        <div class="controls" style="margin-top:12px">
          <div class="control">
            <label>
              <span>Mirror type</span>
              <span class="badge" id="modeBadge">inscribed (max)</span>
            </label>
            <select id="mode">
              <option value="inscribed">Inscribed tangent mirror → maximum time</option>
              <option value="circumscribed">Circumscribed tangent mirror → minimum time</option>
              <option value="crossing">Crossing tangent mirror → inflection</option>
            </select>
          </div>

          <div class="control">
            <label>
              <span>Curvature control (radius ratio)</span>
              <span class="badge"><span class="mono">R / Rₑ(P)</span> = <span id="ratioOut">0.70</span></span>
            </label>
            <input id="ratio" type="range" min="0.35" max="2.20" step="0.01" value="0.70" />
            <div class="tiny">
              <span class="mono">Rₑ(P)</span> is the ellipse radius of curvature at the chosen tangency point <span class="mono">P</span>.
              Smaller ratio → “more curved” mirror.
            </div>
          </div>

          <div class="control" id="crossCtl">
            <label>
              <span>Crossing strength (cubic term)</span>
              <span class="badge"><span class="mono">m</span> = <span id="mOut">1.20</span></span>
            </label>
            <input id="m" type="range" min="0.20" max="3.00" step="0.01" value="1.20" />
            <div class="tiny">
              In crossing mode, a cubic normal displacement forces the mirror to switch sides of the ellipse while staying tangent at <span class="mono">P</span>.
            </div>
          </div>

          <div class="readout">
            <span class="pill">Example values: <span class="mono">a=5</span>, <span class="mono">c=3</span>, <span class="mono">b=4</span></span>
            <span class="pill">Foci: <span class="mono">A=(-c,0)</span>, <span class="mono">B=(+c,0)</span></span>
            <span class="pill">Tangency point: <span class="mono">P=(0,-b)</span></span>
            <span class="pill">Ellipse curvature radius at P: <span class="mono" id="ReOut">6.25</span></span>
          </div>
        </div>
      </div>

      <div class="canvas-wrap">
        <div class="canvas-title">
          <span>Diagram: Foci, ellipse (time contour), mirror, and rays</span>
          <span class="badge">Updates live</span>
        </div>
        <figure>
          <canvas id="c1" height="420" aria-label="Geometry diagram canvas"></canvas>
        </figure>
        <div class="legend">
          Solid curve: chosen mirror. Dotted curve: ellipse (constant <span class="mono">L</span>). Rays: <span class="mono">A→Q→B</span> near <span class="mono">P</span>.
        </div>
      </div>

      <div class="canvas-wrap">
        <div class="canvas-title">
          <span>Main plot: Optical path length <span class="mono">L(s)</span> along the mirror</span>
          <span class="badge">Units: length</span>
        </div>
        <figure>
          <canvas id="c2" height="360" aria-label="Main plot canvas"></canvas>
        </figure>
        <div class="legend">
          The extremum/inflection at <span class="mono">s=0</span> corresponds to the tangency point <span class="mono">P</span>.
        </div>
      </div>

      <div class="canvas-wrap">
        <div class="canvas-title">
          <span>Secondary plot: Relative change <span class="mono">ΔL(s)=L(s)−L(0)</span> and sign</span>
          <span class="badge">Highlights max/min/inflection</span>
        </div>
        <figure>
          <canvas id="c3" height="320" aria-label="Secondary plot canvas"></canvas>
        </figure>
        <div class="legend">
          Inscribed: <span class="mono">ΔL</span> negative near <span class="mono">0</span> (maximum). Circumscribed: positive (minimum). Crossing: changes sign (inflection).
        </div>
      </div>
    </section>
  </main>

  <footer>
    Built with vanilla HTML/CSS/JS • High-DPI canvas rendering • Copy buttons included
  </footer>

<script>
/* ===========================
   Utilities: crisp canvas + axes
=========================== */
function setupCanvas(canvas){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  const cssW = rect.width;
  const cssH = rect.height;
  canvas.width = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return {ctx, w: cssW, h: cssH, dpr};
}

function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function lerp(a,b,t){ return a + (b-a)*t; }

function niceTicks(min,max,nt=6){
  const span = (max-min) || 1;
  const raw = span/nt;
  const mag = Math.pow(10, Math.floor(Math.log10(raw)));
  const norm = raw/mag;
  let step;
  if(norm<1.5) step=1;
  else if(norm<3) step=2;
  else if(norm<7) step=5;
  else step=10;
  step *= mag;
  const t0 = Math.ceil(min/step)*step;
  const ticks=[];
  for(let v=t0; v<=max+1e-12; v+=step) ticks.push(v);
  return {step, ticks};
}

function drawAxes(ctx, box, xlim, ylim, opts){
  const {x0,y0,w,h} = box;
  const padL = opts.padL ?? 56;
  const padR = opts.padR ?? 16;
  const padT = opts.padT ?? 18;
  const padB = opts.padB ?? 44;
  const gx0 = x0 + padL;
  const gy0 = y0 + padT;
  const gw = w - padL - padR;
  const gh = h - padT - padB;

  function X(x){ return gx0 + (x - xlim[0])/(xlim[1]-xlim[0]) * gw; }
  function Y(y){ return gy0 + (1 - (y - ylim[0])/(ylim[1]-ylim[0])) * gh; }

  // panel background
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.12)";
  ctx.fillRect(x0,y0,w,h);
  ctx.restore();

  // grid + ticks
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth = 1;

  const xt = niceTicks(xlim[0], xlim[1], 7).ticks;
  const yt = niceTicks(ylim[0], ylim[1], 6).ticks;

  // grid lines
  xt.forEach(v=>{
    const x = X(v);
    ctx.beginPath();
    ctx.moveTo(x, gy0);
    ctx.lineTo(x, gy0+gh);
    ctx.stroke();
  });
  yt.forEach(v=>{
    const y = Y(v);
    ctx.beginPath();
    ctx.moveTo(gx0, y);
    ctx.lineTo(gx0+gw, y);
    ctx.stroke();
  });
  ctx.restore();

  // axes lines
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.28)";
  ctx.lineWidth = 1.25;
  ctx.beginPath();
  ctx.moveTo(gx0, gy0+gh);
  ctx.lineTo(gx0+gw, gy0+gh);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(gx0, gy0);
  ctx.lineTo(gx0, gy0+gh);
  ctx.stroke();
  ctx.restore();

  // tick labels
  ctx.save();
  ctx.fillStyle = "rgba(234,240,255,0.85)";
  ctx.font = "12px ui-monospace, Menlo, Consolas, monospace";

  xt.forEach(v=>{
    const x = X(v);
    ctx.beginPath();
    ctx.moveTo(x, gy0+gh);
    ctx.lineTo(x, gy0+gh+6);
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.stroke();
    const s = (Math.abs(v) < 1e-10) ? "0" : (Math.round(v*100)/100).toString();
    ctx.textAlign="center"; ctx.textBaseline="top";
    ctx.fillText(s, x, gy0+gh+8);
  });

  yt.forEach(v=>{
    const y = Y(v);
    ctx.beginPath();
    ctx.moveTo(gx0-6, y);
    ctx.lineTo(gx0, y);
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.stroke();
    const s = (Math.abs(v) < 1e-10) ? "0" : (Math.round(v*100)/100).toString();
    ctx.textAlign="right"; ctx.textBaseline="middle";
    ctx.fillText(s, gx0-8, y);
  });
  ctx.restore();

  // title + labels
  ctx.save();
  ctx.fillStyle = "rgba(234,240,255,0.92)";
  ctx.font = "700 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto";
  ctx.textAlign="left"; ctx.textBaseline="top";
  if(opts.title) ctx.fillText(opts.title, x0+12, y0+10);

  ctx.fillStyle = "rgba(170,182,221,0.95)";
  ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto";
  ctx.textAlign="center"; ctx.textBaseline="top";
  if(opts.xlabel) ctx.fillText(opts.xlabel, gx0 + gw/2, y0 + h - 18);

  // y label (rotated)
  if(opts.ylabel){
    ctx.save();
    ctx.translate(x0+16, gy0 + gh/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign="center"; ctx.textBaseline="top";
    ctx.fillText(opts.ylabel, 0, 0);
    ctx.restore();
  }
  ctx.restore();

  return {X,Y, gx0,gy0,gw,gh};
}

function dist(p,q){
  const dx=p.x-q.x, dy=p.y-q.y;
  return Math.hypot(dx,dy);
}

/* ===========================
   Model geometry (example values)
=========================== */
const params = {
  a: 5,         // semi-major
  c: 3,         // focal distance
  get b(){ return Math.sqrt(this.a*this.a - this.c*this.c); }, // semi-minor
  get A(){ return {x:-this.c, y:0}; },
  get B(){ return {x:+this.c, y:0}; },
  get P(){ return {x:0, y:-this.b}; }
};

// curvature radius of ellipse at P=(0,-b):
// ellipse: x=a cosθ, y=b sinθ. At θ=-π/2 => curvature k = b/a^2, so radius ρ = a^2/b.
function ellipseRadiusOfCurvatureAtP(a,b){ return (a*a)/b; }
function ellipseCurvatureAtP(a,b){ return b/(a*a); }

/* ===========================
   Mirror definitions
=========================== */
function mirrorPoints(mode, ratio, mCubic){
  const a=params.a, b=params.b;
  const P=params.P;

  const Re = ellipseRadiusOfCurvatureAtP(a,b);
  const R = ratio * Re;

  const t = {x:1, y:0};      // tangent at P (bottom of ellipse is horizontal tangent)
  const nIn = {x:0, y:1};    // inward normal (toward ellipse interior)
  const nOut = {x:0, y:-1};  // outward normal (toward larger-L ellipses here)

  const pts=[];
  const N=241;

  if(mode === "inscribed" || mode === "circumscribed"){
    // Circular arc tangent at P with radius R.
    // Inscribed: center above P (inside ellipse) => normal points inward.
    // Circumscribed: center below P (outside ellipse) => normal points outward.
    const center = (mode==="inscribed")
      ? {x:P.x + 0*nIn.x*R, y:P.y + 1*nIn.y*R}   // P + R*nIn
      : {x:P.x + 0*nOut.x*R, y:P.y + 1*nOut.y*R}; // P + R*nOut (since nOut y=-1)
    // But above line is not correct for circumscribed due to sign; compute explicitly:
    if(mode==="circumscribed"){
      center.x = P.x;
      center.y = P.y - R;
    }else{
      center.x = P.x;
      center.y = P.y + R;
    }

    const phiMax = 0.55; // radians for a local neighborhood
    for(let i=0;i<N;i++){
      const u = i/(N-1);
      const phi = lerp(-phiMax, phiMax, u);

      let x,y,s;
      if(mode==="inscribed"){
        // r = C + R*(sinφ, -cosφ) ensures r(0)=P, tangent along +x.
        x = center.x + R*Math.sin(phi);
        y = center.y - R*Math.cos(phi);
        s = R*phi;
      }else{
        // center below: r = C + R*(sinφ, +cosφ)
        x = center.x + R*Math.sin(phi);
        y = center.y + R*Math.cos(phi);
        s = R*phi;
      }
      pts.push({x,y,s});
    }
  }else{
    // Crossing mirror: polynomial curve tangent at P:
    // r(s) = P + s t + (k s^2/2) nIn + (m s^3/6) nIn
    // Choose k matched near tangency and use cubic to force crossing.
    const Re = ellipseRadiusOfCurvatureAtP(a,b);
    const kEllipse = 1/Re;     // curvature magnitude of ellipse at P (inward direction)
    const kBase = (1/(ratio*Re)); // adjustable quadratic curvature toward inward normal

    const sMax = 2.4; // arc-length-like parameter (not exact)
    for(let i=0;i<N;i++){
      const u = i/(N-1);
      const s = lerp(-sMax, sMax, u);
      const yN = (kBase*s*s)/2 + (mCubic*s*s*s)/6;
      const x = P.x + s*t.x;
      const y = P.y + yN*nIn.y;
      pts.push({x,y,s});
    }
  }

  return {pts, R, Re};
}

function ellipsePoints(){
  const a=params.a, b=params.b;
  const pts=[];
  const N=360;
  for(let i=0;i<=N;i++){
    const th = (i/N)*Math.PI*2;
    pts.push({x:a*Math.cos(th), y:b*Math.sin(th)});
  }
  return pts;
}

function LofPoint(Q){
  const A=params.A, B=params.B;
  return dist(A,Q) + dist(Q,B);
}

/* ===========================
   Drawing: Diagram
=========================== */
function drawDiagram(canvas, state){
  const {ctx,w,h} = setupCanvas(canvas);
  ctx.clearRect(0,0,w,h);

  const pad=18;

  // world bounds (in example units)
  const a=params.a, b=params.b;
  const xmin=-a-1.6, xmax=a+1.6;
  const ymin=-b-2.0, ymax=b+1.7;

  function X(x){ return pad + (x-xmin)/(xmax-xmin)*(w-2*pad); }
  function Y(y){ return pad + (1-(y-ymin)/(ymax-ymin))*(h-2*pad); }

  // background gradient
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0, "rgba(255,255,255,0.04)");
  g.addColorStop(1, "rgba(0,0,0,0.00)");
  ctx.fillStyle=g;
  ctx.fillRect(0,0,w,h);

  // grid
  ctx.save();
  ctx.strokeStyle="rgba(255,255,255,0.07)";
  ctx.lineWidth=1;
  for(let i=0;i<=10;i++){
    const x = lerp(pad, w-pad, i/10);
    ctx.beginPath(); ctx.moveTo(x,pad); ctx.lineTo(x,h-pad); ctx.stroke();
  }
  for(let j=0;j<=8;j++){
    const y = lerp(pad, h-pad, j/8);
    ctx.beginPath(); ctx.moveTo(pad,y); ctx.lineTo(w-pad,y); ctx.stroke();
  }
  ctx.restore();

  // axes (x-axis)
  ctx.save();
  ctx.strokeStyle="rgba(255,255,255,0.18)";
  ctx.lineWidth=1.25;
  ctx.beginPath();
  ctx.moveTo(X(xmin), Y(0));
  ctx.lineTo(X(xmax), Y(0));
  ctx.stroke();
  ctx.restore();

  // ellipse (dotted)
  const epts = ellipsePoints();
  ctx.save();
  ctx.setLineDash([5,5]);
  ctx.strokeStyle="rgba(125,211,252,0.70)";
  ctx.lineWidth=2;
  ctx.beginPath();
  epts.forEach((p,i)=>{
    const xx=X(p.x), yy=Y(p.y);
    if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
  });
  ctx.stroke();
  ctx.restore();

  // mirror curve (solid)
  const mpts = state.mirror.pts;
  ctx.save();
  ctx.setLineDash([]);
  ctx.strokeStyle="rgba(167,139,250,0.85)";
  ctx.lineWidth=3;
  ctx.beginPath();
  mpts.forEach((p,i)=>{
    const xx=X(p.x), yy=Y(p.y);
    if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
  });
  ctx.stroke();
  ctx.restore();

  // Key points: A, B, P, Q-, Q+
  const A=params.A, B=params.B, P=params.P;
  const i0 = Math.floor(mpts.length/2);
  const Qm = mpts[Math.max(0, i0-45)];
  const Qp = mpts[Math.min(mpts.length-1, i0+45)];

  function drawPoint(p, label, color){
    ctx.save();
    ctx.fillStyle=color;
    ctx.beginPath();
    ctx.arc(X(p.x), Y(p.y), 5.2, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle="rgba(0,0,0,0.45)";
    ctx.lineWidth=2;
    ctx.stroke();
    ctx.fillStyle="rgba(234,240,255,0.92)";
    ctx.font="700 13px ui-monospace, Menlo, Consolas, monospace";
    ctx.textAlign="left"; ctx.textBaseline="middle";
    ctx.fillText(label, X(p.x)+8, Y(p.y)-1);
    ctx.restore();
  }

  drawPoint(A,"A", "rgba(52,211,153,0.95)");
  drawPoint(B,"B", "rgba(52,211,153,0.95)");
  drawPoint(P,"P", "rgba(251,191,36,0.95)");
  drawPoint(Qm,"Q", "rgba(125,211,252,0.95)");
  drawPoint(Qp,"Q′","rgba(125,211,252,0.95)");

  // rays A->P->B (highlight) and A->Q->B, A->Q'->B (fainter)
  function drawPath(p1,p2,p3, color, lw, dash){
    ctx.save();
    if(dash) ctx.setLineDash(dash); else ctx.setLineDash([]);
    ctx.strokeStyle=color;
    ctx.lineWidth=lw;
    ctx.beginPath();
    ctx.moveTo(X(p1.x), Y(p1.y));
    ctx.lineTo(X(p2.x), Y(p2.y));
    ctx.lineTo(X(p3.x), Y(p3.y));
    ctx.stroke();
    ctx.restore();
  }

  drawPath(A,P,B, "rgba(251,191,36,0.95)", 2.8, null);
  drawPath(A,Qm,B, "rgba(125,211,252,0.55)", 2.0, [6,5]);
  drawPath(A,Qp,B, "rgba(125,211,252,0.55)", 2.0, [6,5]);

  // Caption in-canvas
  const Lp = LofPoint(P);
  const Lm = LofPoint(Qm);
  const Lq = LofPoint(Qp);
  let note;
  if(state.mode==="inscribed"){
    note = "Inscribed tangent mirror: neighbors have smaller L ⇒ P is a local maximum of time.";
  }else if(state.mode==="circumscribed"){
    note = "Circumscribed tangent mirror: neighbors have larger L ⇒ P is a local minimum of time.";
  }else{
    note = "Crossing tangent mirror: one side larger L, other smaller ⇒ inflection at P.";
  }

  ctx.save();
  ctx.fillStyle="rgba(0,0,0,0.35)";
  ctx.fillRect(pad, pad, w-2*pad, 56);
  ctx.fillStyle="rgba(234,240,255,0.92)";
  ctx.font="800 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto";
  ctx.textAlign="left"; ctx.textBaseline="top";
  ctx.fillText("OPL comparison (example):", pad+10, pad+8);
  ctx.fillStyle="rgba(170,182,221,0.98)";
  ctx.font="12px ui-monospace, Menlo, Consolas, monospace";
  ctx.fillText(`L(P)=${Lp.toFixed(3)}   L(Q)=${Lm.toFixed(3)}   L(Q′)=${Lq.toFixed(3)}`, pad+10, pad+30);
  ctx.fillStyle="rgba(170,182,221,0.95)";
  ctx.font="12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto";
  ctx.fillText(note, pad+10, pad+46);
  ctx.restore();
}

/* ===========================
   Drawing: Plots
=========================== */
function drawPlotL(canvas, state){
  const {ctx,w,h} = setupCanvas(canvas);
  ctx.clearRect(0,0,w,h);

  const pts = state.mirror.pts;
  const sArr = pts.map(p=>p.s);
  const LArr = pts.map(p=>LofPoint(p));

  const smin = Math.min(...sArr), smax=Math.max(...sArr);
  let Lmin = Math.min(...LArr), Lmax=Math.max(...LArr);

  // pad y range
  const padY = 0.08*(Lmax-Lmin || 1);
  Lmin -= padY; Lmax += padY;

  const ax = drawAxes(ctx, {x0:0,y0:0,w,h}, [smin,smax], [Lmin,Lmax], {
    title: "Optical path length along the mirror",
    xlabel: "mirror coordinate s (arbitrary length units)",
    ylabel: "L(s) = |A r(s)| + |r(s) B|  (length units)"
  });

  // curve
  ctx.save();
  ctx.strokeStyle="rgba(125,211,252,0.90)";
  ctx.lineWidth=2.6;
  ctx.beginPath();
  pts.forEach((p,i)=>{
    const x=ax.X(p.s), y=ax.Y(LofPoint(p));
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();
  ctx.restore();

  // mark s=0 (P) and neighbors
  const i0 = Math.floor(pts.length/2);
  const Pp = pts[i0];
  const L0 = LofPoint(Pp);

  ctx.save();
  // vertical line at s=0
  ctx.strokeStyle="rgba(255,255,255,0.25)";
  ctx.lineWidth=1.2;
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.moveTo(ax.X(0), ax.gy0);
  ctx.lineTo(ax.X(0), ax.gy0+ax.gh);
  ctx.stroke();
  ctx.setLineDash([]);

  // point at P
  ctx.fillStyle="rgba(251,191,36,0.95)";
  ctx.beginPath();
  ctx.arc(ax.X(Pp.s), ax.Y(L0), 4.8, 0, Math.PI*2);
  ctx.fill();

  // label
  ctx.fillStyle="rgba(234,240,255,0.92)";
  ctx.font="700 12px ui-monospace, Menlo, Consolas, monospace";
  ctx.textAlign="left"; ctx.textBaseline="bottom";
  ctx.fillText(`P: (s=0, L=${L0.toFixed(3)})`, ax.X(Pp.s)+8, ax.Y(L0)-6);
  ctx.restore();

  // legend-ish
  ctx.save();
  ctx.fillStyle="rgba(0,0,0,0.30)";
  ctx.fillRect(w-260, 10, 248, 52);
  ctx.fillStyle="rgba(234,240,255,0.92)";
  ctx.font="700 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto";
  ctx.fillText("Legend", w-248, 18);
  ctx.strokeStyle="rgba(125,211,252,0.90)";
  ctx.lineWidth=3;
  ctx.beginPath();
  ctx.moveTo(w-248, 38);
  ctx.lineTo(w-210, 38);
  ctx.stroke();
  ctx.fillStyle="rgba(170,182,221,0.95)";
  ctx.font="12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto";
  ctx.fillText("L(s) along mirror", w-202, 33);
  ctx.restore();
}

function drawPlotDelta(canvas, state){
  const {ctx,w,h} = setupCanvas(canvas);
  ctx.clearRect(0,0,w,h);

  const pts = state.mirror.pts;
  const i0 = Math.floor(pts.length/2);
  const L0 = LofPoint(pts[i0]);

  const sArr = pts.map(p=>p.s);
  const dArr = pts.map(p=>LofPoint(p)-L0);

  const smin = Math.min(...sArr), smax=Math.max(...sArr);
  let dmin = Math.min(...dArr), dmax=Math.max(...dArr);
  const padY = 0.12*(dmax-dmin || 1);
  dmin -= padY; dmax += padY;

  const ax = drawAxes(ctx, {x0:0,y0:0,w,h}, [smin,smax], [dmin,dmax], {
    title: "Relative change ΔL(s) = L(s) − L(0)",
    xlabel: "mirror coordinate s (arbitrary length units)",
    ylabel: "ΔL(s) (length units)"
  });

  // zero line
  ctx.save();
  ctx.strokeStyle="rgba(255,255,255,0.30)";
  ctx.lineWidth=1.2;
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.moveTo(ax.gx0, ax.Y(0));
  ctx.lineTo(ax.gx0+ax.gw, ax.Y(0));
  ctx.stroke();
  ctx.restore();

  // curve
  ctx.save();
  ctx.strokeStyle="rgba(167,139,250,0.90)";
  ctx.lineWidth=2.6;
  ctx.beginPath();
  pts.forEach((p,i)=>{
    const x=ax.X(p.s), y=ax.Y(LofPoint(p)-L0);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();
  ctx.restore();

  // shading sign regions (simple: sample and fill under curve)
  ctx.save();
  ctx.globalAlpha = 0.18;
  ctx.fillStyle = "rgba(52,211,153,0.9)"; // positive area
  ctx.beginPath();
  ctx.moveTo(ax.X(sArr[0]), ax.Y(0));
  for(let i=0;i<pts.length;i++){
    ctx.lineTo(ax.X(sArr[i]), ax.Y(dArr[i]));
  }
  ctx.lineTo(ax.X(sArr[sArr.length-1]), ax.Y(0));
  ctx.closePath();
  // This fills both; to keep it simple, we just fill overall lightly
  ctx.fill();
  ctx.restore();

  // mark s=0
  ctx.save();
  ctx.strokeStyle="rgba(255,255,255,0.25)";
  ctx.lineWidth=1.2;
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.moveTo(ax.X(0), ax.gy0);
  ctx.lineTo(ax.X(0), ax.gy0+ax.gh);
  ctx.stroke();
  ctx.setLineDash([]);

  ctx.fillStyle="rgba(251,191,36,0.95)";
  ctx.beginPath();
  ctx.arc(ax.X(0), ax.Y(0), 4.8, 0, Math.PI*2);
  ctx.fill();

  // classification label
  let cls;
  if(state.mode==="inscribed") cls="Maximum at P (ΔL<0 near 0)";
  else if(state.mode==="circumscribed") cls="Minimum at P (ΔL>0 near 0)";
  else cls="Inflection at P (ΔL changes sign)";
  ctx.fillStyle="rgba(234,240,255,0.92)";
  ctx.font="800 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto";
  ctx.textAlign="left"; ctx.textBaseline="top";
  ctx.fillText(cls, ax.gx0+10, ax.gy0+10);
  ctx.restore();
}

/* ===========================
   Copy buttons
=========================== */
function installCopy(){
  function copyText(t){
    navigator.clipboard.writeText(t).then(()=>{
      // tiny toast via button text swap
    }).catch(()=>{});
  }

  document.querySelectorAll(".copy").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const tgt = btn.getAttribute("data-copy-target");
      if(tgt){
        const el = document.querySelector(tgt);
        const t = el ? el.innerText.trim() : "";
        if(t) copyText(t);
        btn.textContent="Copied ✓";
        setTimeout(()=>btn.textContent="Copy final answer", 900);
      }else{
        const t = btn.getAttribute("data-copy") || "";
        if(t) copyText(t);
        const old = btn.textContent;
        btn.textContent="Copied ✓";
        setTimeout(()=>btn.textContent=old, 900);
      }
    });
  });
}

/* ===========================
   State + update loop
=========================== */
const state = {
  mode: "inscribed",
  ratio: 0.70,
  m: 1.20,
  mirror: null
};

function updateState(){
  const modeEl = document.getElementById("mode");
  const ratioEl = document.getElementById("ratio");
  const mEl = document.getElementById("m");

  state.mode = modeEl.value;
  state.ratio = parseFloat(ratioEl.value);
  state.m = parseFloat(mEl.value);

  const crossCtl = document.getElementById("crossCtl");
  crossCtl.style.display = (state.mode==="crossing") ? "block" : "none";

  const badge = document.getElementById("modeBadge");
  if(state.mode==="inscribed") badge.textContent="inscribed (max)";
  else if(state.mode==="circumscribed") badge.textContent="circumscribed (min)";
  else badge.textContent="crossing (inflection)";

  document.getElementById("ratioOut").textContent = state.ratio.toFixed(2);
  document.getElementById("mOut").textContent = state.m.toFixed(2);

  const Re = ellipseRadiusOfCurvatureAtP(params.a, params.b);
  document.getElementById("ReOut").textContent = Re.toFixed(2);

  state.mirror = mirrorPoints(state.mode, state.ratio, state.m);
}

function renderAll(){
  updateState();
  drawDiagram(document.getElementById("c1"), state);
  drawPlotL(document.getElementById("c2"), state);
  drawPlotDelta(document.getElementById("c3"), state);
}

function installUI(){
  ["mode","ratio","m"].forEach(id=>{
    document.getElementById(id).addEventListener("input", renderAll);
    document.getElementById(id).addEventListener("change", renderAll);
  });

  window.addEventListener("resize", ()=>{
    // responsive re-render
    renderAll();
  });
}

installCopy();
installUI();
renderAll();
</script>
</body>
</html>
