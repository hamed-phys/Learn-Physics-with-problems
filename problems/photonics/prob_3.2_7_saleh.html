<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gaussian Beam Spot Size Through a Lens — w0′(z) and Limiting Cases</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --panel2:#0c1328;
      --text:#eaf0ff;
      --muted:#b8c4ffcc;
      --faint:#b8c4ff66;
      --line:#2a3a72;
      --accent:#7cf0ff;
      --accent2:#a78bfa;
      --ok:#66f2a5;
      --warn:#ffd166;
      --danger:#ff5c7a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html{ scroll-behavior:smooth; }
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 800px at 10% -10%, rgba(124,240,255,.20), transparent 60%),
        radial-gradient(900px 700px at 90% 10%, rgba(167,139,250,.18), transparent 65%),
        radial-gradient(900px 900px at 40% 120%, rgba(102,242,165,.10), transparent 60%),
        linear-gradient(180deg, var(--bg), #070a14 70%);
      color:var(--text);
      line-height:1.55;
    }

    header{
      padding:28px 18px 8px;
      max-width:1200px;
      margin:0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:16px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .hero{ grid-template-columns:1fr; }
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid rgba(184,196,255,.12);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .pad{ padding:18px 18px; }
    .title{
      font-size: clamp(22px, 2.4vw, 34px);
      letter-spacing:.2px;
      margin:0 0 8px 0;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size:14px;
    }
    .pillrow{
      display:flex; flex-wrap:wrap; gap:8px;
      margin-top:12px;
    }
    .pill{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(184,196,255,.18);
      background: rgba(15,23,48,.55);
      color:var(--muted);
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding:12px 18px 42px;
      display:grid;
      grid-template-columns: 300px 1fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 1020px){
      main{ grid-template-columns: 1fr; }
    }

    nav.toc{
      position: sticky;
      top: 12px;
      align-self:start;
      padding:14px 14px;
      background: rgba(15,23,48,.72);
      border:1px solid rgba(184,196,255,.14);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    nav.toc h3{
      margin:0 0 10px;
      font-size:13px;
      color:var(--muted);
      letter-spacing:.6px;
      text-transform:uppercase;
    }
    nav.toc a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      text-decoration:none;
      color:var(--text);
      border:1px solid transparent;
      font-size:14px;
    }
    nav.toc a:hover{
      background: rgba(124,240,255,.08);
      border-color: rgba(124,240,255,.18);
    }

    section{
      padding:18px 18px;
      border-radius: var(--radius);
      border:1px solid rgba(184,196,255,.12);
      background: rgba(15,23,48,.48);
      box-shadow: var(--shadow);
    }
    section + section{ margin-top:16px; }

    h2{
      margin:0 0 10px;
      font-size:18px;
      letter-spacing:.2px;
    }
    h3{
      margin:16px 0 8px;
      font-size:15px;
      color: var(--muted);
    }
    ul{ margin:8px 0 0 18px; }
    li{ margin:6px 0; color: var(--text); }
    .muted{ color: var(--muted); }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 900px){ .grid2{ grid-template-columns:1fr; } }

    .eqbox{
      background: rgba(12,19,40,.75);
      border:1px solid rgba(184,196,255,.14);
      border-radius:14px;
      padding:12px 12px;
      margin:10px 0;
    }
    .eqrow{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .eq{
      font-family: var(--mono);
      font-size: 13px;
      white-space: pre-wrap;
      word-break: break-word;
      color:#eaf0ff;
    }
    .btn{
      cursor:pointer;
      border:1px solid rgba(184,196,255,.18);
      background: rgba(15,23,48,.55);
      color: var(--text);
      border-radius: 12px;
      padding:8px 10px;
      font-size:12px;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
      user-select:none;
    }
    .btn:hover{ background: rgba(124,240,255,.10); border-color: rgba(124,240,255,.22); }
    .btn:active{ transform: translateY(1px); }
    .badge{
      display:inline-block;
      font-size:12px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(184,196,255,.18);
      color:var(--muted);
      background: rgba(12,19,40,.55);
      margin-left:8px;
    }

    .callout{
      border-left: 3px solid var(--accent);
      padding: 12px 12px;
      border-radius: 14px;
      background: rgba(124,240,255,.06);
      border:1px solid rgba(124,240,255,.18);
      margin:12px 0;
    }
    .callout.warn{
      border-left-color: var(--warn);
      background: rgba(255,209,102,.06);
      border-color: rgba(255,209,102,.18);
    }
    .callout.ok{
      border-left-color: var(--ok);
      background: rgba(102,242,165,.06);
      border-color: rgba(102,242,165,.18);
    }

    figure{
      margin:0;
      padding:0;
    }
    .canvasWrap{
      padding:12px;
      background: rgba(12,19,40,.6);
      border-top:1px solid rgba(184,196,255,.12);
    }
    canvas{
      width:100%;
      height:320px;
      border-radius:14px;
      border:1px solid rgba(184,196,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      display:block;
    }
    .canvasTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin:0 0 10px 0;
    }
    .canvasTitle h3{ margin:0; }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    @media (max-width: 700px){
      .controls{ grid-template-columns:1fr; }
    }
    .control{
      background: rgba(15,23,48,.55);
      border:1px solid rgba(184,196,255,.14);
      border-radius:14px;
      padding:10px 10px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:12px;
      color:var(--muted);
      margin-bottom:6px;
    }
    input[type="range"]{ width:100%; }
    .tiny{
      font-size:12px;
      color:var(--muted);
    }

    .final{
      border:1px solid rgba(102,242,165,.22);
      background: rgba(102,242,165,.06);
      border-radius: var(--radius);
      padding:14px 14px;
      margin-top:10px;
    }
    .final h3{ margin:0 0 8px; color:#dfffee; }
    .box{
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(184,196,255,.14);
      background: rgba(12,19,40,.75);
      font-family: var(--mono);
      font-size:13px;
      white-space:pre-wrap;
      word-break: break-word;
    }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding:18px 18px 40px;
      color:var(--muted);
      font-size:12px;
    }

    @media print{
      body{ background:#fff; color:#000; }
      header, main, footer{ max-width: 100%; }
      nav.toc{ display:none; }
      .card, section{ box-shadow:none; background:#fff; border:1px solid #ccc; }
      canvas{ border:1px solid #aaa; }
      .btn{ display:none; }
    }

    /* subtle entrance */
    .fadeIn{
      animation: fade .5s ease-out both;
    }
    @keyframes fade{
      from{ opacity:0; transform: translateY(6px); }
      to{ opacity:1; transform: translateY(0); }
    }
  </style>
</head>

<body>
<header class="fadeIn">
  <div class="hero">
    <div class="card">
      <div class="pad">
        <h1 class="title">Spot Size of a Gaussian Beam After a Thin Lens: <span style="color:var(--accent)">w<sub>0</sub>′(z)</span></h1>
        <p class="subtitle">
          Using the complex <span style="font-family:var(--mono)">q</span>-parameter and ABCD matrices, we derive the exact transformed waist size
          and verify the two key limits (ray-optics imaging and “lens near the waist”).
        </p>
        <div class="pillrow" aria-label="key parameters">
          <span class="pill">Given: z<sub>0</sub> = 50 cm</span>
          <span class="pill">λ = 488 nm</span>
          <span class="pill">f = 5 cm (default)</span>
          <span class="pill">Plot: w<sub>0</sub>′ vs z</span>
        </div>

        <div class="callout ok" style="margin-top:14px">
          <strong>Quick Summary</strong>
          <ul>
            <li>At the lens plane (distance <span style="font-family:var(--mono)">z</span> from the original waist), the incident beam has <span style="font-family:var(--mono)">q = z + i z0</span>.</li>
            <li>A thin lens transforms <span style="font-family:var(--mono)">q</span> via <span style="font-family:var(--mono)">q′ = q / (1 − q/f)</span>.</li>
            <li>The new Rayleigh range: <span style="font-family:var(--mono)">z0′ = z0 / [ (1 − z/f)^2 + (z0/f)^2 ]</span>.</li>
            <li>The new waist radius: <span style="font-family:var(--mono)">w0′ = w0 / √[ (1 − z/f)^2 + (z0/f)^2 ]</span>, where <span style="font-family:var(--mono)">w0 = √(λ z0 / π)</span>.</li>
            <li>Ray-optics limit <span style="font-family:var(--mono)">|z − f| ≫ z0</span>: <span style="font-family:var(--mono)">w0′ ≈ (f/|z − f|) w0</span> and the lens formula holds.</li>
            <li>Near-waist limit <span style="font-family:var(--mono)">z ≪ z0</span>: <span style="font-family:var(--mono)">w0′ ≈ w0 / √(1 + (z0/f)^2)</span> (≈ Eq. 3.2-13).</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="pad">
        <h2 style="margin:0 0 8px">Interactive Controls</h2>
        <p class="muted" style="margin:0 0 10px">
          Change a parameter and watch the diagram and both plots update live.
        </p>

        <div class="controls" role="group" aria-label="interactive controls">
          <div class="control">
            <label for="zSlider">
              <span>Lens position from original waist, z</span>
              <span class="badge" id="zReadout">10.0 cm</span>
            </label>
            <input id="zSlider" type="range" min="0" max="250" value="10" step="0.1" />
            <div class="tiny">Range: 0 → 250 cm (adjusted to show both near-field and far-field behavior).</div>
          </div>

          <div class="control">
            <label for="fSlider">
              <span>Focal length, f</span>
              <span class="badge" id="fReadout">5.0 cm</span>
            </label>
            <input id="fSlider" type="range" min="2" max="20" value="5" step="0.1" />
            <div class="tiny">Try small f to focus harder; try large f to weaken the lens.</div>
          </div>

          <div class="control">
            <label for="z0Slider">
              <span>Rayleigh range, z<sub>0</sub></span>
              <span class="badge" id="z0Readout">50.0 cm</span>
            </label>
            <input id="z0Slider" type="range" min="5" max="150" value="50" step="0.5" />
            <div class="tiny">This sets the incident beam waist via w<sub>0</sub> = √(λ z<sub>0</sub>/π).</div>
          </div>

          <div class="control">
            <label for="lambdaSlider">
              <span>Wavelength, λ</span>
              <span class="badge" id="lamReadout">488 nm</span>
            </label>
            <input id="lambdaSlider" type="range" min="350" max="1550" value="488" step="1" />
            <div class="tiny">λ changes the absolute size scale, but not the dimensionless geometry factors.</div>
          </div>
        </div>

        <div class="callout warn" style="margin-top:12px">
          <strong>Note on units:</strong> Sliders use cm for distances and nm for wavelength; calculations are done in SI.
        </div>
      </div>
    </div>
  </div>
</header>

<main class="fadeIn">
  <nav class="toc" aria-label="Table of contents">
    <h3>Contents</h3>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#viz">Interactive Visualizations</a>
    <a href="#final">Final Results (boxed)</a>
  </nav>

  <article>
    <section id="part1">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>Restate the problem</h3>
      <p>
        A Gaussian beam with wavelength <span class="eq">λ = 488 nm</span> has Rayleigh range
        <span class="eq">z0 = 50 cm</span>. A thin lens of focal length <span class="eq">f = 5 cm</span>
        is placed a distance <span class="eq">z</span> from the beam’s waist (on the incident side),
        producing a new Gaussian beam with a new waist radius <span class="eq">w0′</span>.
        We must:
      </p>
      <ul>
        <li>Plot <span class="eq">w0′</span> as a function of <span class="eq">z</span>.</li>
        <li>Verify the ray-optics (imaging) limit <span class="eq">|z − f| ≫ z0</span>: Eqs. (3.2-10)–(3.2-12) hold.</li>
        <li>Verify the near-waist limit <span class="eq">z ≪ z0</span>: Eq. (3.2-13) holds.</li>
      </ul>

      <div class="grid2">
        <div>
          <h3>Given quantities</h3>
          <ul>
            <li>Rayleigh range: <span class="eq">z0 = 50 cm</span></li>
            <li>Wavelength: <span class="eq">λ = 488 nm</span></li>
            <li>Lens focal length: <span class="eq">f = 5 cm</span></li>
            <li>Lens position relative to original waist: <span class="eq">z</span> (variable)</li>
          </ul>
        </div>
        <div>
          <h3>Unknowns</h3>
          <ul>
            <li>New Rayleigh range: <span class="eq">z0′</span></li>
            <li>New waist radius: <span class="eq">w0′</span></li>
            <li>New waist location from the lens: <span class="eq">z′</span></li>
          </ul>
        </div>
      </div>

      <h3>What must be found/proved</h3>
      <ul>
        <li>An explicit expression <span class="eq">w0′(z)</span> (exact Gaussian-beam result).</li>
        <li>In the limit <span class="eq">|z − f| ≫ z0</span>, show <span class="eq">w0′ ≈ M w0</span> with <span class="eq">M ≈ f/|z − f|</span> (ray-optics magnification), and the lens formula for <span class="eq">z′</span>.</li>
        <li>In the limit <span class="eq">z ≪ z0</span>, show <span class="eq">w0′ ≈ w0 / √(1 + (z0/f)^2)</span> (≈ Eq. 3.2-13).</li>
      </ul>

      <h3>Relevant physical principles (and why)</h3>
      <ul>
        <li>
          <strong>Gaussian beam propagation via complex <span class="eq">q</span>-parameter:</strong>
          A Gaussian beam is fully described (paraxially) by <span class="eq">q(z)</span>, whose real part encodes wavefront curvature and whose imaginary part encodes spot size / Rayleigh range.
        </li>
        <li>
          <strong>ABCD matrix optics for first-order systems:</strong>
          A thin lens is a linear paraxial element. Gaussian beams transform through it by the same ABCD law:
          <span class="eq">q_out = (A q_in + B)/(C q_in + D)</span>.
        </li>
        <li>
          <strong>Ray-optics imaging as a limit:</strong>
          When diffraction is negligible across the lens aperture/geometry (effectively when <span class="eq">|z − f|</span> is large compared to the diffraction length <span class="eq">z0</span>), the Gaussian-beam result should reduce to geometric imaging with magnification.
        </li>
      </ul>

      <h3>Possible approaches (compare)</h3>
      <ol>
        <li>
          <strong>ABCD + q-parameter (best):</strong> short, exact, directly yields <span class="eq">z′</span>, <span class="eq">z0′</span>, <span class="eq">w0′</span>, and limits are easy.
        </li>
        <li>
          <strong>Wave optics / Fresnel integral:</strong> possible but heavy; you’d re-derive what q-parameter already packages.
        </li>
        <li>
          <strong>Heuristic scaling with numerical propagation:</strong> good for intuition but not ideal for symbolic limit verification.
        </li>
      </ol>
      <div class="callout">
        <strong>Chosen approach:</strong> Use the <span class="eq">q</span>-parameter with the thin-lens ABCD law to obtain an exact closed form, then take limits.
      </div>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

      <h3>Plan (5–10 steps)</h3>
      <ol>
        <li><strong>Goal:</strong> Express the incident beam at the lens. <br><span class="muted">Tool:</span> <span class="eq">q_in = z + i z0</span> (with the original waist at z=0).</li>
        <li><strong>Goal:</strong> Apply the thin-lens transformation. <br><span class="muted">Tool:</span> ABCD for a thin lens: <span class="eq">A=1, B=0, C=-1/f, D=1</span>.</li>
        <li><strong>Goal:</strong> Write <span class="eq">q_out</span> at the plane just after the lens. <br><span class="muted">Tool:</span> <span class="eq">q_out = q_in/(1 - q_in/f)</span>.</li>
        <li><strong>Goal:</strong> Identify the new waist location and new Rayleigh range. <br><span class="muted">Tool:</span> At any plane, <span class="eq">q = (z_plane - z_waist) + i z0′</span>; at the lens plane this implies <span class="eq">q_out = -z′ + i z0′</span>.</li>
        <li><strong>Goal:</strong> Convert <span class="eq">z0′</span> to <span class="eq">w0′</span>. <br><span class="muted">Tool:</span> <span class="eq">w0′ = √(λ z0′/π)</span>.</li>
        <li><strong>Goal:</strong> Take the limit <span class="eq">|z − f| ≫ z0</span>. <br><span class="muted">Tool:</span> Drop small term <span class="eq">(z0/f)^2</span> compared with <span class="eq">(1 − z/f)^2</span>.</li>
        <li><strong>Goal:</strong> Take the limit <span class="eq">z ≪ z0</span>. <br><span class="muted">Tool:</span> Approximate <span class="eq">1 − z/f ≈ 1</span> in the denominator.</li>
      </ol>

      <h3>Common mistakes & quick tips</h3>
      <ul>
        <li><strong>Sign convention trap:</strong> At the lens plane, if the new waist is to the right by distance <span class="eq">z′</span>, then <span class="eq">q_out = -z′ + i z0′</span>. (Real part is negative.)</li>
        <li><strong>Units mismatch:</strong> Convert cm → m and nm → m before computing <span class="eq">w0</span>.</li>
        <li><strong>“Ray-optics limit” meaning:</strong> It is not “large z” alone; it is specifically <span class="eq">|z − f|</span> large compared to <span class="eq">z0</span>.</li>
      </ul>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution</h2>

      <h3>Physical intuition</h3>
      <p>
        A Gaussian beam can be thought of as a bundle of paraxial rays with an additional diffraction “softening”
        controlled by <span class="eq">z0</span>. A thin lens adds curvature to the wavefront, attempting to form an image.
        If diffraction is weak over the relevant geometry (ray limit), the output waist behaves like an imaged spot:
        smaller when the magnification is small. If the lens is very near the original waist (<span class="eq">z ≪ z0</span>),
        the beam at the lens is still nearly “waist-like”, and the transformation becomes almost independent of z.
      </p>

      <h3>Step 1: Incident beam at the lens</h3>
      <p>
        Place the original waist at coordinate origin. For a Gaussian beam,
      </p>
      <div class="eqbox">
        <div class="eqrow">
          <div class="eq" id="eq1">q_in = z + i z0</div>
          <button class="btn" data-copy="#eq1">Copy</button>
        </div>
      </div>

      <h3>Step 2: Thin lens ABCD transform</h3>
      <p>
        A thin lens has ABCD matrix:
        <span class="eq">A=1, B=0, C=-1/f, D=1</span>.
        Gaussian beams transform by
        <span class="eq">q_out = (A q_in + B)/(C q_in + D)</span>,
        so
      </p>
      <div class="eqbox">
        <div class="eqrow">
          <div class="eq" id="eq2">q_out = q_in / (1 − q_in/f)</div>
          <button class="btn" data-copy="#eq2">Copy</button>
        </div>
      </div>

      <h3>Step 3: Compute real/imag parts and identify z′ and z0′</h3>
      <p>
        Write the denominator:
        <span class="eq">1 − q_in/f = (1 − z/f) − i (z0/f)</span>.
        Let
        <span class="eq">a = 1 − z/f</span>, <span class="eq">b = z0/f</span>, and
        <span class="eq">D = a^2 + b^2</span>.
        Then (complex division):
      </p>

      <div class="eqbox">
        <div class="eqrow">
          <div class="eq" id="eq3">q_out = [(z + i z0)(a + i b)] / (a^2 + b^2)</div>
          <button class="btn" data-copy="#eq3">Copy</button>
        </div>
      </div>

      <p>
        Multiply out:
        <span class="eq">(z + i z0)(a + i b) = (z a − z0 b) + i (z b + z0 a)</span>.
        Therefore,
      </p>

      <div class="eqbox">
        <div class="eqrow">
          <div class="eq" id="eq4">Re(q_out) = (z a − z0 b) / D
Im(q_out) = (z b + z0 a) / D</div>
          <button class="btn" data-copy="#eq4">Copy</button>
        </div>
      </div>

      <p>
        Now relate <span class="eq">q_out</span> at the lens plane to the new waist parameters. If the new waist is a distance
        <span class="eq">z′</span> to the right of the lens, then at the lens plane the coordinate relative to the new waist is
        <span class="eq">(-z′)</span>, so
      </p>
      <div class="eqbox">
        <div class="eqrow">
          <div class="eq" id="eq5">q_out = -z′ + i z0′</div>
          <button class="btn" data-copy="#eq5">Copy</button>
        </div>
      </div>

      <p>
        Thus <span class="eq">z′ = -Re(q_out)</span> and <span class="eq">z0′ = Im(q_out)</span>.
        Using <span class="eq">b=z0/f</span> and <span class="eq">a=1-z/f</span>:
      </p>

      <div class="eqbox">
        <div class="eqrow">
          <div class="eq" id="eq6">D = (1 − z/f)^2 + (z0/f)^2
z0′ = z0 / D
z′  = [ (z^2 + z0^2)/f − z ] / D</div>
          <button class="btn" data-copy="#eq6">Copy</button>
        </div>
      </div>

      <h3>Step 4: Convert z0′ to the new waist radius w0′</h3>
      <p>
        For any Gaussian beam, <span class="eq">z0 = π w0^2 / λ</span>, equivalently
        <span class="eq">w0 = √(λ z0 / π)</span>. Hence
      </p>

      <div class="eqbox">
        <div class="eqrow">
          <div class="eq" id="eq7">w0 = √(λ z0 / π)
w0′ = √(λ z0′ / π) = w0 / √D
D = (1 − z/f)^2 + (z0/f)^2</div>
          <button class="btn" data-copy="#eq7">Copy</button>
        </div>
      </div>

      <div class="callout ok">
        <strong>Key exact result:</strong>
        <span class="eq">w0′(z) = w0 / √[(1 − z/f)^2 + (z0/f)^2]</span>.
        This is what we plot.
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><strong>Units:</strong> <span class="eq">D</span> is dimensionless, so <span class="eq">w0′</span> has units of length like <span class="eq">w0</span>.</li>
        <li><strong>Behavior near z = f:</strong> <span class="eq">(1 − z/f) → 0</span>, so <span class="eq">w0′</span> approaches a finite minimum set by diffraction term <span class="eq">(z0/f)^2</span>.</li>
        <li><strong>Physical meaning:</strong> the lens can “image” the waist, but diffraction prevents the spot from shrinking arbitrarily.</li>
      </ul>

      <h3>Limit 1: Ray-optics imaging (|z − f| ≫ z0)</h3>
      <p>
        If <span class="eq">|z − f| ≫ z0</span>, then <span class="eq">(z0/f)^2</span> is negligible compared with <span class="eq">(1 − z/f)^2</span>.
        So
        <span class="eq">D ≈ (1 − z/f)^2</span>, and therefore
      </p>

      <div class="eqbox">
        <div class="eqrow">
          <div class="eq" id="eq8">w0′ ≈ w0 / |1 − z/f| = (f/|z − f|) w0</div>
          <button class="btn" data-copy="#eq8">Copy</button>
        </div>
      </div>

      <p>
        This matches the ray-optics magnification factor
        <span class="eq">M ≈ f/|z − f|</span> (Eq. 3.2-12) and <span class="eq">w0′ ≈ M w0</span> (Eq. 3.2-10).
      </p>

      <p>
        For the image distance <span class="eq">z′</span>, neglect <span class="eq">z0^2</span> in the numerator and set
        <span class="eq">D ≈ (1 − z/f)^2</span>:
      </p>
      <div class="eqbox">
        <div class="eqrow">
          <div class="eq" id="eq9">z′ ≈ (z^2/f − z) / (1 − z/f)^2 = (f z)/(z − f)</div>
          <button class="btn" data-copy="#eq9">Copy</button>
        </div>
      </div>

      <p>
        Rearranging gives the thin-lens imaging equation:
      </p>
      <div class="eqbox">
        <div class="eqrow">
          <div class="eq" id="eq10">1/z + 1/z′ ≈ 1/f</div>
          <button class="btn" data-copy="#eq10">Copy</button>
        </div>
      </div>

      <h3>Limit 2: Lens near the waist (z ≪ z0)</h3>
      <p>
        If the lens is placed very close to the original waist relative to the Rayleigh range,
        then <span class="eq">z</span> is small and <span class="eq">1 − z/f ≈ 1</span>. Thus
        <span class="eq">D ≈ 1 + (z0/f)^2</span> and
      </p>
      <div class="eqbox">
        <div class="eqrow">
          <div class="eq" id="eq11">w0′ ≈ w0 / √(1 + (z0/f)^2)</div>
          <button class="btn" data-copy="#eq11">Copy</button>
        </div>
      </div>
      <p>
        This reproduces Eq. (3.2-13) (to excellent accuracy for <span class="eq">z ≪ z0</span>), i.e. the spot size becomes nearly independent of <span class="eq">z</span>.
        Likewise,
      </p>
      <div class="eqbox">
        <div class="eqrow">
          <div class="eq" id="eq12">z′ ≈ (z0^2/f) / (1 + (z0/f)^2) = f / (1 + (f/z0)^2)</div>
          <button class="btn" data-copy="#eq12">Copy</button>
        </div>
      </div>
    </section>

    <section id="viz">
      <h2>Interactive Visualizations</h2>
      <p class="muted">
        The plots use the <em>exact</em> formulas above and also overlay limiting-case behavior through an error sweep.
        Move sliders to see how geometry and diffraction compete.
      </p>

      <div class="card" style="margin-top:12px">
        <div class="pad">
          <div class="canvasTitle">
            <h3 style="margin:0">1) Labeled Setup Diagram (beam + lens + new waist)</h3>
            <span class="tiny">Shows z, f, and computed z′, w0, w0′.</span>
          </div>
        </div>
        <div class="canvasWrap">
          <canvas id="cDiagram" aria-label="diagram canvas"></canvas>
        </div>
      </div>

      <div class="card" style="margin-top:14px">
        <div class="pad">
          <div class="canvasTitle">
            <h3 style="margin:0">2) Main Plot — New waist radius w0′ versus lens position z</h3>
            <span class="tiny">Units: z in cm, w0′ in mm.</span>
          </div>
        </div>
        <div class="canvasWrap">
          <canvas id="cMain" aria-label="main plot canvas"></canvas>
        </div>
      </div>

      <div class="card" style="margin-top:14px">
        <div class="pad">
          <div class="canvasTitle">
            <h3 style="margin:0">3) Secondary Plot — Approximation Errors vs z</h3>
            <span class="tiny">Relative error of two limits: ray-optics and near-waist.</span>
          </div>
        </div>
        <div class="canvasWrap">
          <canvas id="cErr" aria-label="error plot canvas"></canvas>
        </div>
      </div>

      <div class="callout" style="margin-top:14px">
        <strong>How to read the error plot:</strong>
        <ul>
          <li><span class="eq">ε_ray(z) = |w0′_ray − w0′_exact| / w0′_exact</span>, where <span class="eq">w0′_ray = (f/|z − f|) w0</span>.</li>
          <li><span class="eq">ε_near(z) = |w0′_near − w0′_exact| / w0′_exact</span>, where <span class="eq">w0′_near = w0 / √(1 + (z0/f)^2)</span>.</li>
        </ul>
      </div>
    </section>

    <section id="final">
      <h2>Final Results (boxed)</h2>

      <div class="final">
        <h3>Exact Gaussian-beam transformation (thin lens at distance z from the original waist)</h3>
        <div class="box" id="finalText">Let q_in = z + i z0, and a = 1 − z/f, b = z0/f, D = a^2 + b^2.

Thin lens:  q_out = q_in / (1 − q_in/f) = -z′ + i z0′

z0′ = z0 / D
z′  = [ (z^2 + z0^2)/f − z ] / D

w0 = √(λ z0 / π)
w0′(z) = √(λ z0′ / π) = w0 / √D = w0 / √[(1 − z/f)^2 + (z0/f)^2]</div>
        <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px">
          <button class="btn" data-copy="#finalText">Copy Final Answer</button>
        </div>
      </div>

      <div class="final" style="margin-top:14px">
        <h3>Verified limits</h3>
        <div class="box" id="limitsText">1) Ray-optics imaging limit |z − f| ≫ z0:
   D ≈ (1 − z/f)^2  ⇒  w0′ ≈ w0/|1 − z/f| = (f/|z − f|) w0  (matches M ≈ f/|z − f|).
   Also z′ ≈ f z/(z − f), which implies 1/z + 1/z′ ≈ 1/f.

2) Near-waist limit z ≪ z0:
   1 − z/f ≈ 1  ⇒  D ≈ 1 + (z0/f)^2  ⇒  w0′ ≈ w0 / √(1 + (z0/f)^2)  (Eq. 3.2-13).</div>
        <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px">
          <button class="btn" data-copy="#limitsText">Copy Limits</button>
        </div>
      </div>
    </section>
  </article>
</main>

<footer class="fadeIn">
  <div class="card">
    <div class="pad">
      <strong>Numerical note (with the given defaults):</strong>
      <div class="muted" id="numNote" style="margin-top:6px"></div>
      <div style="margin-top:10px" class="muted">
        Built with vanilla HTML/CSS/JS. Canvases are high-DPI aware and responsive.
      </div>
    </div>
  </div>
</footer>

<script>
(function(){
  // ---------- Utilities ----------
  const $ = (sel) => document.querySelector(sel);
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

  function fmt(x, digits=3){
    if (!isFinite(x)) return "—";
    const ax = Math.abs(x);
    if (ax !== 0 && (ax < 1e-3 || ax >= 1e4)) return x.toExponential(digits);
    return x.toFixed(digits);
  }

  function copyTextFromSelector(sel){
    const el = document.querySelector(sel);
    if(!el) return;
    const text = el.innerText.trim();
    navigator.clipboard?.writeText(text).then(()=>{
      toast("Copied!");
    }).catch(()=>{
      // fallback
      const ta = document.createElement("textarea");
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      document.body.removeChild(ta);
      toast("Copied!");
    });
  }

  let toastTimer = null;
  function toast(msg){
    let t = document.getElementById("toast");
    if(!t){
      t = document.createElement("div");
      t.id = "toast";
      t.style.position = "fixed";
      t.style.left = "50%";
      t.style.bottom = "18px";
      t.style.transform = "translateX(-50%)";
      t.style.padding = "10px 12px";
      t.style.borderRadius = "999px";
      t.style.border = "1px solid rgba(184,196,255,.22)";
      t.style.background = "rgba(15,23,48,.85)";
      t.style.color = "var(--text)";
      t.style.fontSize = "12px";
      t.style.boxShadow = "0 10px 25px rgba(0,0,0,.35)";
      t.style.backdropFilter = "blur(10px)";
      t.style.zIndex = "9999";
      t.style.opacity = "0";
      t.style.transition = "opacity .18s ease";
      document.body.appendChild(t);
    }
    t.textContent = msg;
    t.style.opacity = "1";
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>{ t.style.opacity="0"; }, 900);
  }

  document.addEventListener("click", (e)=>{
    const b = e.target.closest("[data-copy]");
    if(!b) return;
    copyTextFromSelector(b.getAttribute("data-copy"));
  });

  // ---------- Physics (SI units internally) ----------
  function computeAll(params){
    const z = params.z_m;    // lens position from original waist (m)
    const f = params.f_m;    // focal length (m)
    const z0 = params.z0_m;  // Rayleigh range (m)
    const lam = params.lam_m;

    const a = 1 - z/f;
    const b = z0/f;
    const D = a*a + b*b;

    const z0p = z0 / D;
    const zp = (((z*z + z0*z0)/f) - z) / D; // distance from lens to new waist (m), assuming waist to right if positive

    const w0 = Math.sqrt(lam * z0 / Math.PI);
    const w0p = w0 / Math.sqrt(D);

    // approximations
    const w0p_ray = w0 * (f / Math.abs(z - f)); // ray-optics magnification
    const w0p_near = w0 / Math.sqrt(1 + (z0/f)*(z0/f)); // near-waist (z<<z0) approx

    // relative errors (handle z ~ f separately)
    const err_ray = (isFinite(w0p_ray) && isFinite(w0p) && w0p>0) ? Math.abs(w0p_ray - w0p)/w0p : NaN;
    const err_near = (isFinite(w0p_near) && isFinite(w0p) && w0p>0) ? Math.abs(w0p_near - w0p)/w0p : NaN;

    return {a,b,D,z0p,zp,w0,w0p,w0p_ray,w0p_near,err_ray,err_near};
  }

  // ---------- Canvas helpers ----------
  function setupCanvas(canvas){
    const ctx = canvas.getContext("2d");
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(320, rect.width);
      const h = rect.height || 320;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {w, h};
    }
    return {ctx, resize};
  }

  function clear(ctx, w, h){
    ctx.clearRect(0,0,w,h);
  }

  function drawPanelFrame(ctx, w, h, title){
    // subtle header text
    ctx.save();
    ctx.fillStyle = "rgba(234,240,255,.92)";
    ctx.font = "600 13px " + getComputedStyle(document.body).fontFamily;
    ctx.fillText(title, 14, 22);
    ctx.restore();
  }

  function drawAxes(ctx, box, xLabel, yLabel, xTicks, yTicks){
    const {x,y,w,h} = box;

    // gridlines
    ctx.save();
    ctx.strokeStyle = "rgba(184,196,255,.12)";
    ctx.lineWidth = 1;
    for(const t of xTicks){
      const xx = x + t.pos*w;
      ctx.beginPath(); ctx.moveTo(xx, y); ctx.lineTo(xx, y+h); ctx.stroke();
    }
    for(const t of yTicks){
      const yy = y + (1 - t.pos)*h;
      ctx.beginPath(); ctx.moveTo(x, yy); ctx.lineTo(x+w, yy); ctx.stroke();
    }

    // axes
    ctx.strokeStyle = "rgba(184,196,255,.35)";
    ctx.lineWidth = 1.25;
    ctx.beginPath(); ctx.moveTo(x, y+h); ctx.lineTo(x+w, y+h); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y+h); ctx.stroke();

    // ticks + labels
    ctx.fillStyle = "rgba(234,240,255,.80)";
    ctx.font = "12px " + getComputedStyle(document.body).fontFamily;

    for(const t of xTicks){
      const xx = x + t.pos*w;
      ctx.strokeStyle = "rgba(234,240,255,.25)";
      ctx.beginPath(); ctx.moveTo(xx, y+h); ctx.lineTo(xx, y+h+6); ctx.stroke();
      ctx.fillText(t.label, xx-10, y+h+20);
    }
    for(const t of yTicks){
      const yy = y + (1 - t.pos)*h;
      ctx.strokeStyle = "rgba(234,240,255,.25)";
      ctx.beginPath(); ctx.moveTo(x-6, yy); ctx.lineTo(x, yy); ctx.stroke();
      ctx.fillText(t.label, x-52, yy+4);
    }

    // axis labels
    ctx.fillStyle = "rgba(184,196,255,.92)";
    ctx.font = "600 12px " + getComputedStyle(document.body).fontFamily;
    ctx.fillText(xLabel, x + w - 120, y + h + 38);

    ctx.save();
    ctx.translate(x - 46, y + 20);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    ctx.restore();
  }

  function mapLin(v, vmin, vmax, pmin, pmax){
    const t = (v - vmin) / (vmax - vmin);
    return pmin + t*(pmax - pmin);
  }

  function niceTicks(vmin, vmax, n=5){
    const span = vmax - vmin;
    if(span <= 0) return [vmin];
    const raw = span / n;
    const pow10 = Math.pow(10, Math.floor(Math.log10(raw)));
    const m = raw / pow10;
    let step;
    if(m < 1.5) step = 1*pow10;
    else if(m < 3.5) step = 2*pow10;
    else if(m < 7.5) step = 5*pow10;
    else step = 10*pow10;

    const start = Math.ceil(vmin/step)*step;
    const end = Math.floor(vmax/step)*step;
    const ticks = [];
    for(let x = start; x <= end + 1e-12; x += step) ticks.push(x);
    return ticks;
  }

  function plotLine(ctx, box, xs, ys, xMin, xMax, yMin, yMax, strokeStyle){
    const {x,y,w,h} = box;
    ctx.save();
    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = 2;
    ctx.beginPath();
    let started = false;
    for(let i=0;i<xs.length;i++){
      const xv = xs[i], yv = ys[i];
      if(!isFinite(yv)) { started=false; continue; }
      const px = mapLin(xv, xMin, xMax, x, x+w);
      const py = mapLin(yv, yMin, yMax, y+h, y);
      if(!started){ ctx.moveTo(px, py); started=true; }
      else ctx.lineTo(px, py);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawLegend(ctx, items, x, y){
    ctx.save();
    ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
    ctx.textBaseline = "middle";
    let yy = y;
    for(const it of items){
      ctx.strokeStyle = it.color;
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(x, yy); ctx.lineTo(x+18, yy); ctx.stroke();
      ctx.fillStyle = "rgba(234,240,255,.85)";
      ctx.fillText(it.label, x+26, yy);
      yy += 18;
    }
    ctx.restore();
  }

  function drawMarker(ctx, box, xVal, yVal, xMin, xMax, yMin, yMax, color){
    const {x,y,w,h} = box;
    if(!isFinite(yVal)) return;
    const px = mapLin(xVal, xMin, xMax, x, x+w);
    const py = mapLin(yVal, yMin, yMax, y+h, y);
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.arc(px, py, 4.5, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,.35)";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
  }

  // ---------- Rendering ----------
  const diagram = setupCanvas($("#cDiagram"));
  const mainPlot = setupCanvas($("#cMain"));
  const errPlot = setupCanvas($("#cErr"));

  const state = {
    z_cm: 10,
    f_cm: 5,
    z0_cm: 50,
    lam_nm: 488
  };

  function updateReadouts(){
    $("#zReadout").textContent = `${fmt(state.z_cm,1)} cm`;
    $("#fReadout").textContent = `${fmt(state.f_cm,1)} cm`;
    $("#z0Readout").textContent = `${fmt(state.z0_cm,1)} cm`;
    $("#lamReadout").textContent = `${fmt(state.lam_nm,0)} nm`;
  }

  function buildParams(){
    return {
      z_m: state.z_cm/100,
      f_m: state.f_cm/100,
      z0_m: state.z0_cm/100,
      lam_m: state.lam_nm*1e-9
    };
  }

  function renderDiagram(w, h, params, out){
    const ctx = diagram.ctx;
    clear(ctx, w, h);
    drawPanelFrame(ctx, w, h, "Beam + Lens Geometry (not to scale in diffraction thickness)");

    const margin = {l:22, r:22, t:36, b:22};
    const X0 = margin.l;
    const X1 = w - margin.r;
    const Yc = Math.round((margin.t + (h - margin.b)) / 2);

    // Map "positions" along a schematic axis: waist at x=0, lens at x=z, new waist at x=z+z'
    const z = params.z_m, f = params.f_m;
    const zp = out.zp;

    // Keep diagram stable: choose a view window that includes [0, z] and [z, z+z'] nicely.
    // Use max distance to right; clamp to avoid crazy when z ~ f.
    const zRight = z + clamp(zp, -0.2, 2.5); // allow modest negative to show virtual waist; cap huge
    const viewMin = -0.05;
    const viewMax = Math.max(0.35, Math.max(z+0.05, zRight+0.05));

    function xMap(val){
      return mapLin(val, viewMin, viewMax, X0, X1);
    }

    // Draw axis
    ctx.save();
    ctx.strokeStyle = "rgba(184,196,255,.35)";
    ctx.lineWidth = 1.25;
    ctx.beginPath(); ctx.moveTo(X0, Yc); ctx.lineTo(X1, Yc); ctx.stroke();

    // ticks
    const ticks = 6;
    ctx.fillStyle = "rgba(184,196,255,.85)";
    ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
    for(let i=0;i<=ticks;i++){
      const tv = viewMin + (viewMax - viewMin)*i/ticks;
      const xx = xMap(tv);
      ctx.strokeStyle = "rgba(184,196,255,.22)";
      ctx.beginPath(); ctx.moveTo(xx, Yc-6); ctx.lineTo(xx, Yc+6); ctx.stroke();
      ctx.fillText(`${fmt(tv*100,0)} cm`, xx-16, Yc+22);
    }

    // draw original waist
    const xW0 = xMap(0);
    ctx.strokeStyle = "rgba(124,240,255,.85)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(xW0, Yc-50); ctx.lineTo(xW0, Yc+50); ctx.stroke();
    ctx.fillStyle = "rgba(124,240,255,.92)";
    ctx.fillText("original waist", xW0-36, Yc-58);

    // lens at z
    const xL = xMap(z);
    // lens shape
    ctx.fillStyle = "rgba(167,139,250,.22)";
    ctx.strokeStyle = "rgba(167,139,250,.70)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(xL-8, Yc-60);
    ctx.quadraticCurveTo(xL, Yc-65, xL+8, Yc-60);
    ctx.lineTo(xL+8, Yc+60);
    ctx.quadraticCurveTo(xL, Yc+65, xL-8, Yc+60);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = "rgba(167,139,250,.92)";
    ctx.fillText("lens", xL-12, Yc-72);

    // new waist location
    const xWp = xMap(z + zp);
    ctx.strokeStyle = "rgba(102,242,165,.85)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(xWp, Yc-50); ctx.lineTo(xWp, Yc+50); ctx.stroke();
    ctx.fillStyle = "rgba(102,242,165,.92)";
    ctx.fillText("new waist", xWp-26, Yc-58);

    // beam envelope (schematic): draw cones around lens based on w0 and w0'
    const w0_mm = out.w0 * 1e3;
    const w0p_mm = out.w0p * 1e3;

    // Convert waist sizes to pixels (schematic, not physical scaling)
    const scalePix = 40; // px per mm, chosen for visibility
    const r0 = clamp(w0_mm*scalePix, 6, 34);
    const r1 = clamp(w0p_mm*scalePix, 4, 34);

    // left side: from original waist to lens, beam expands with z; we exaggerate linearly
    const leftR_atLens = clamp(r0 + (Math.abs(z)*100)*0.06, r0, 70); // heuristic

    // right side: from lens to new waist
    const rightR_atLens = clamp(r1 + Math.abs(zp)*100*0.08, r1, 70);

    ctx.strokeStyle = "rgba(255,92,122,.85)";
    ctx.lineWidth = 2;

    // upper envelope
    ctx.beginPath();
    ctx.moveTo(xW0, Yc - r0);
    ctx.lineTo(xL, Yc - leftR_atLens);
    ctx.lineTo(xWp, Yc - r1);
    ctx.stroke();

    // lower envelope
    ctx.beginPath();
    ctx.moveTo(xW0, Yc + r0);
    ctx.lineTo(xL, Yc + leftR_atLens);
    ctx.lineTo(xWp, Yc + r1);
    ctx.stroke();

    // dashed center rays
    ctx.setLineDash([6,6]);
    ctx.strokeStyle = "rgba(234,240,255,.25)";
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(xW0, Yc); ctx.lineTo(xWp, Yc); ctx.stroke();
    ctx.setLineDash([]);

    // labels for z and z'
    function drawDoubleArrow(xA, xB, y, label, color){
      ctx.save();
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(xA, y); ctx.lineTo(xB, y); ctx.stroke();
      // arrowheads
      const ah = 7;
      ctx.beginPath();
      ctx.moveTo(xA, y);
      ctx.lineTo(xA+ah, y-ah/2);
      ctx.lineTo(xA+ah, y+ah/2);
      ctx.closePath(); ctx.fill();
      ctx.beginPath();
      ctx.moveTo(xB, y);
      ctx.lineTo(xB-ah, y-ah/2);
      ctx.lineTo(xB-ah, y+ah/2);
      ctx.closePath(); ctx.fill();
      ctx.font = "600 12px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText(label, (xA+xB)/2 - 18, y-8);
      ctx.restore();
    }

    drawDoubleArrow(xW0, xL, Yc-95, `z = ${fmt(state.z_cm,1)} cm`, "rgba(124,240,255,.85)");
    drawDoubleArrow(xL, xWp, Yc-115, `z′ = ${fmt(out.zp*100,1)} cm`, "rgba(102,242,165,.85)");

    // a quick numeric inset
    ctx.fillStyle = "rgba(234,240,255,.85)";
    ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
    const info = [
      `w0 = ${fmt(out.w0*1e3,3)} mm`,
      `w0′ = ${fmt(out.w0p*1e3,3)} mm`,
      `D = ${(isFinite(out.D)?fmt(out.D,3):"—")}`
    ];
    let yy = margin.t + 18;
    for(const line of info){
      ctx.fillText(line, X0, yy);
      yy += 16;
    }

    ctx.restore();
  }

  function renderMainPlot(w, h, params){
    const ctx = mainPlot.ctx;
    clear(ctx, w, h);
    drawPanelFrame(ctx, w, h, "Main Plot: w0′(z)");

    const pad = {l:76, r:18, t:40, b:56};
    const box = {x:pad.l, y:pad.t, w:w-pad.l-pad.r, h:h-pad.t-pad.b};

    // Build sweep data
    const zMin_cm = 0;
    const zMax_cm = 250;
    const N = 600;
    const xs = new Array(N);
    const ys = new Array(N);

    // update param note
    const lam = params.lam_m;
    const z0 = params.z0_m;

    for(let i=0;i<N;i++){
      const z_cm = zMin_cm + (zMax_cm - zMin_cm)*i/(N-1);
      const p = { ...params, z_m: z_cm/100 };
      const out = computeAll(p);
      xs[i] = z_cm;
      ys[i] = out.w0p * 1e3; // mm
    }

    // y-limits (avoid infinite at z=f for ray approx; exact stays finite)
    let yMin = Infinity, yMax = -Infinity;
    for(const v of ys){
      if(!isFinite(v)) continue;
      yMin = Math.min(yMin, v);
      yMax = Math.max(yMax, v);
    }
    if(!isFinite(yMin) || !isFinite(yMax)){ yMin = 0; yMax = 1; }
    // pad
    const span = yMax - yMin;
    yMin = Math.max(0, yMin - 0.08*span);
    yMax = yMax + 0.12*span;

    // ticks
    const xTicksV = niceTicks(zMin_cm, zMax_cm, 5);
    const yTicksV = niceTicks(yMin, yMax, 5);
    const xTicks = xTicksV.map(v=>({pos:(v-zMin_cm)/(zMax_cm-zMin_cm), label: `${fmt(v,0)}`}));
    const yTicks = yTicksV.map(v=>({pos:(v-yMin)/(yMax-yMin), label: `${fmt(v,3)}`}));

    drawAxes(ctx, box, "z (cm)", "w0′ (mm)", xTicks, yTicks);

    // line
    plotLine(ctx, box, xs, ys, zMin_cm, zMax_cm, yMin, yMax, "rgba(124,240,255,.85)");

    // current marker
    const outNow = computeAll(params);
    drawMarker(ctx, box, state.z_cm, outNow.w0p*1e3, zMin_cm, zMax_cm, yMin, yMax, "rgba(102,242,165,.95)");

    // legend
    drawLegend(ctx, [
      {label:"exact w0′(z)", color:"rgba(124,240,255,.85)"},
      {label:"current z marker", color:"rgba(102,242,165,.95)"}
    ], pad.l + 12, pad.t + 18);

    // annotate minimum near z=f
    const xF = params.f_m * 100;
    if(xF >= zMin_cm && xF <= zMax_cm){
      ctx.save();
      ctx.strokeStyle = "rgba(167,139,250,.55)";
      ctx.lineWidth = 1.5;
      const px = mapLin(xF, zMin_cm, zMax_cm, box.x, box.x+box.w);
      ctx.beginPath(); ctx.moveTo(px, box.y); ctx.lineTo(px, box.y+box.h); ctx.stroke();
      ctx.fillStyle = "rgba(167,139,250,.85)";
      ctx.font = "600 12px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText("z = f", px+6, box.y+14);
      ctx.restore();
    }
  }

  function renderErrPlot(w, h, params){
    const ctx = errPlot.ctx;
    clear(ctx, w, h);
    drawPanelFrame(ctx, w, h, "Secondary Plot: Relative Errors of Limiting Approximations");

    const pad = {l:76, r:18, t:40, b:56};
    const box = {x:pad.l, y:pad.t, w:w-pad.l-pad.r, h:h-pad.t-pad.b};

    const zMin_cm = 0;
    const zMax_cm = 250;
    const N = 600;
    const xs = new Array(N);
    const eRay = new Array(N);
    const eNear = new Array(N);

    for(let i=0;i<N;i++){
      const z_cm = zMin_cm + (zMax_cm - zMin_cm)*i/(N-1);
      const p = { ...params, z_m: z_cm/100 };
      const out = computeAll(p);
      xs[i] = z_cm;
      eRay[i] = out.err_ray;
      eNear[i] = out.err_near;
    }

    // y-range: errors can blow up near z=f for ray approx; cap for readability
    let yMin = 0;
    let yMax = 0.0;
    for(const arr of [eRay, eNear]){
      for(const v of arr){
        if(!isFinite(v)) continue;
        yMax = Math.max(yMax, v);
      }
    }
    yMax = Math.min(Math.max(0.25, yMax*1.05), 2.0); // cap at 200% for plot clarity

    // ticks
    const xTicksV = niceTicks(zMin_cm, zMax_cm, 5);
    const yTicksV = niceTicks(yMin, yMax, 5);
    const xTicks = xTicksV.map(v=>({pos:(v-zMin_cm)/(zMax_cm-zMin_cm), label: `${fmt(v,0)}`}));
    const yTicks = yTicksV.map(v=>({pos:(v-yMin)/(yMax-yMin || 1), label: `${fmt(v,2)}`}));

    drawAxes(ctx, box, "z (cm)", "relative error", xTicks, yTicks);

    plotLine(ctx, box, xs, eRay.map(v=>isFinite(v)?Math.min(v,yMax):NaN), zMin_cm, zMax_cm, yMin, yMax, "rgba(255,209,102,.90)");
    plotLine(ctx, box, xs, eNear.map(v=>isFinite(v)?Math.min(v,yMax):NaN), zMin_cm, zMax_cm, yMin, yMax, "rgba(167,139,250,.88)");

    // marker at current z
    const outNow = computeAll(params);
    drawMarker(ctx, box, state.z_cm, Math.min(outNow.err_ray, yMax), zMin_cm, zMax_cm, yMin, yMax, "rgba(255,209,102,.95)");
    drawMarker(ctx, box, state.z_cm, Math.min(outNow.err_near, yMax), zMin_cm, zMax_cm, yMin, yMax, "rgba(167,139,250,.95)");

    drawLegend(ctx, [
      {label:"ε_ray (ray-optics)", color:"rgba(255,209,102,.90)"},
      {label:"ε_near (z ≪ z0)", color:"rgba(167,139,250,.88)"}
    ], pad.l + 12, pad.t + 18);

    // show recommended regimes visually
    // |z-f| >> z0 region (approx) as a hint: shade where |z-f| >= 3 z0 (heuristic)
    const z0_cm = params.z0_m * 100;
    const f_cm = params.f_m * 100;
    const leftEnd = f_cm - 3*z0_cm;
    const rightStart = f_cm + 3*z0_cm;

    ctx.save();
    ctx.fillStyle = "rgba(102,242,165,.06)";
    if(leftEnd > zMin_cm){
      const xA = mapLin(zMin_cm, zMin_cm, zMax_cm, box.x, box.x+box.w);
      const xB = mapLin(clamp(leftEnd, zMin_cm, zMax_cm), zMin_cm, zMax_cm, box.x, box.x+box.w);
      ctx.fillRect(xA, box.y, xB-xA, box.h);
    }
    if(rightStart < zMax_cm){
      const xA = mapLin(clamp(rightStart, zMin_cm, zMax_cm), zMin_cm, zMax_cm, box.x, box.x+box.w);
      const xB = mapLin(zMax_cm, zMin_cm, zMax_cm, box.x, box.x+box.w);
      ctx.fillRect(xA, box.y, xB-xA, box.h);
    }
    ctx.fillStyle = "rgba(102,242,165,.75)";
    ctx.font = "600 12px " + getComputedStyle(document.body).fontFamily;
    ctx.fillText("heuristic ray-optics zone: |z−f| ≥ 3 z0", box.x+12, box.y+box.h-12);
    ctx.restore();

    // vertical line at z=f
    if(f_cm >= zMin_cm && f_cm <= zMax_cm){
      ctx.save();
      ctx.strokeStyle = "rgba(184,196,255,.25)";
      ctx.lineWidth = 1.5;
      const px = mapLin(f_cm, zMin_cm, zMax_cm, box.x, box.x+box.w);
      ctx.beginPath(); ctx.moveTo(px, box.y); ctx.lineTo(px, box.y+box.h); ctx.stroke();
      ctx.restore();
    }
  }

  function renderAll(){
    updateReadouts();
    const params = buildParams();
    const outNow = computeAll(params);

    // footer numeric note
    const w0mm = outNow.w0*1e3;
    const w0pmm = outNow.w0p*1e3;
    const zpcm = outNow.zp*100;
    const z0pcm = outNow.z0p*100;
    $("#numNote").innerText =
      `With current settings: w0 = ${fmt(w0mm,3)} mm, w0′ = ${fmt(w0pmm,3)} mm, z′ = ${fmt(zpcm,2)} cm, z0′ = ${fmt(z0pcm,2)} cm.`;

    // resize and draw
    const d = diagram.resize();
    renderDiagram(d.w, d.h, params, outNow);

    const m = mainPlot.resize();
    renderMainPlot(m.w, m.h, params);

    const e = errPlot.resize();
    renderErrPlot(e.w, e.h, params);
  }

  // ---------- Wire controls ----------
  $("#zSlider").addEventListener("input", (e)=>{ state.z_cm = parseFloat(e.target.value); renderAll(); });
  $("#fSlider").addEventListener("input", (e)=>{ state.f_cm = parseFloat(e.target.value); renderAll(); });
  $("#z0Slider").addEventListener("input", (e)=>{ state.z0_cm = parseFloat(e.target.value); renderAll(); });
  $("#lambdaSlider").addEventListener("input", (e)=>{ state.lam_nm = parseFloat(e.target.value); renderAll(); });

  window.addEventListener("resize", ()=>renderAll());

  // initialize
  updateReadouts();
  renderAll();
})();
</script>
</body>
</html>
