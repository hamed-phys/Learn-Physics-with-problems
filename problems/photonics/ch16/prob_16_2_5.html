<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Modal Powers in a Multimode He–Ne Laser (Longitudinal Modes + Power in Strongest Mode)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --panel2:#0f1730;
      --text:#eaf0ff;
      --muted:#b7c3e6;
      --faint:#7f8ab3;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --ink:#0b1020;
      --card:#0f1833;
      --border:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background: radial-gradient(1200px 800px at 20% 10%, rgba(125,211,252,.12), transparent 60%),
                  radial-gradient(1000px 700px at 80% 20%, rgba(167,139,250,.10), transparent 55%),
                  radial-gradient(900px 600px at 50% 90%, rgba(52,211,153,.06), transparent 55%),
                  var(--bg);
      color:var(--text);
      font-family:var(--sans);
      line-height:1.55;
    }
    a{color:var(--accent)}
    header{
      padding:32px 20px 18px;
      max-width:1200px;
      margin:0 auto;
    }
    .kicker{
      color:var(--muted);
      font-size:14px;
      letter-spacing:.08em;
      text-transform:uppercase;
      opacity:.9;
    }
    h1{
      margin:8px 0 10px;
      font-size:clamp(26px, 2.7vw, 40px);
      line-height:1.15;
    }
    .subtitle{
      max-width:80ch;
      color:var(--muted);
      font-size:16px;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding:0 20px 56px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:20px;
      align-items:start;
    }

    nav.toc{
      position:sticky;
      top:14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(17,26,51,.92), rgba(15,23,48,.92));
      border:1px solid var(--border);
      border-radius:16px;
      box-shadow:var(--shadow);
      padding:14px 14px 10px;
      backdrop-filter: blur(8px);
    }
    .toc h2{
      margin:4px 0 10px;
      font-size:14px;
      letter-spacing:.05em;
      text-transform:uppercase;
      color:var(--muted);
    }
    .toc a{
      display:block;
      padding:8px 10px;
      margin:3px 0;
      border-radius:12px;
      text-decoration:none;
      color:var(--text);
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:14px;
    }
    .toc a:hover{
      background:rgba(125,211,252,.08);
      border-color:rgba(125,211,252,.22);
      transform: translateY(-1px);
    }
    .toc .mini{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.12);
      color:var(--muted);
      font-size:13px;
    }

    article{
      display:flex;
      flex-direction:column;
      gap:18px;
      min-width:0;
    }

    section{
      background: linear-gradient(180deg, rgba(17,26,51,.72), rgba(15,23,48,.72));
      border:1px solid var(--border);
      border-radius:18px;
      box-shadow: var(--shadow);
      padding:18px 18px 16px;
      backdrop-filter: blur(8px);
      overflow:hidden;
    }

    section h2{
      margin:0 0 10px;
      font-size:18px;
      letter-spacing:.02em;
    }
    section h3{
      margin:16px 0 8px;
      font-size:15px;
      color:var(--muted);
      letter-spacing:.02em;
    }
    p{margin:8px 0; color: var(--text)}
    ul{margin:8px 0 8px 18px; color:var(--text)}
    li{margin:6px 0}
    .grid2{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
      align-items:start;
    }
    .grid3{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:12px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr; }
      nav.toc{position:relative; top:0}
      .grid2{grid-template-columns: 1fr}
      .grid3{grid-template-columns: 1fr}
    }

    .callout{
      border:1px solid var(--border);
      background: rgba(0,0,0,.14);
      border-radius:16px;
      padding:12px 12px 10px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
    }
    .callout .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size:12px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color:var(--muted);
      margin-bottom:6px;
    }
    .pill{
      width:10px; height:10px; border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(125,211,252,.15);
      flex:0 0 auto;
    }
    .pill.good{background: var(--good); box-shadow: 0 0 0 3px rgba(52,211,153,.14)}
    .pill.warn{background: var(--warn); box-shadow: 0 0 0 3px rgba(251,191,36,.14)}
    .pill.bad{background: var(--bad); box-shadow: 0 0 0 3px rgba(251,113,133,.14)}
    .eq{
      font-family:var(--mono);
      background: rgba(125,211,252,.08);
      border:1px solid rgba(125,211,252,.18);
      border-radius:14px;
      padding:10px 12px;
      overflow:auto;
      position:relative;
    }
    .eq small{color:var(--muted); display:block; margin-top:6px; font-family:var(--sans)}
    .copyRow{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .copyBtn{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:8px 10px;
      border-radius:12px;
      cursor:pointer;
      font-size:13px;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
    }
    .copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.28);
    }
    .copyBtn:active{transform: translateY(0px) scale(.99)}
    .mono{font-family:var(--mono)}
    .muted{color:var(--muted)}
    .faint{color:var(--faint)}
    .hr{
      height:1px;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,.18), transparent);
      margin:12px 0;
    }
    .result{
      border:1px solid rgba(52,211,153,.22);
      background: rgba(52,211,153,.08);
    }
    .warnbox{
      border:1px solid rgba(251,191,36,.22);
      background: rgba(251,191,36,.08);
    }
    .badbox{
      border:1px solid rgba(251,113,133,.22);
      background: rgba(251,113,133,.08);
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    @media (max-width: 620px){
      .controls{grid-template-columns:1fr}
    }
    label{
      display:block;
      font-size:13px;
      color:var(--muted);
      margin-bottom:6px;
    }
    input[type="range"]{
      width:100%;
    }
    .ctrlCard{
      padding:12px;
      border-radius:16px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.12);
    }
    .readout{
      margin-top:6px;
      font-family:var(--mono);
      font-size:13px;
      color:var(--text);
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }

    .canvasWrap{
      border:1px solid var(--border);
      border-radius:16px;
      background: rgba(0,0,0,.20);
      overflow:hidden;
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
    }
    .canvasTitle{
      padding:10px 12px 0;
      font-size:13px;
      color:var(--muted);
      letter-spacing:.02em;
    }
    .foot{
      margin-top:10px;
      font-size:12px;
      color:var(--faint);
    }

    /* Print-friendly */
    @media print{
      body{background:#fff; color:#000}
      header, main{max-width:100%; padding:0}
      nav.toc{display:none}
      section{box-shadow:none; border:1px solid #ddd; background:#fff}
      .eq{background:#f6f8ff; border-color:#cdd7ff}
      .copyBtn{display:none}
      .canvasWrap{display:none}
    }

    /* subtle animation */
    @keyframes floatIn {
      from{transform: translateY(8px); opacity:0}
      to{transform: translateY(0); opacity:1}
    }
    section{animation: floatIn .35s ease both}
  </style>
</head>
<body>
<header>
  <div class="kicker">Photonics • Laser Physics • Longitudinal modes</div>
  <h1>Modal Powers in a Multimode He–Ne Laser</h1>
  <div class="subtitle">
    We determine how many <b>longitudinal cavity modes</b> can oscillate under an <b>inhomogeneously broadened (Doppler)</b> gain profile,
    and then estimate the <b>power in the strongest mode</b> when the cavity is tuned to favor it.
  </div>
</header>

<main>
  <nav class="toc" aria-label="Table of contents">
    <h2>Contents</h2>
    <a href="#quick" data-jump>Quick Summary</a>
    <a href="#part0" data-jump>PART 0 — Concept Primer</a>
    <a href="#part1" data-jump>PART 1 — Problem Analysis</a>
    <a href="#part2" data-jump>PART 2 — Strategy &amp; Tips</a>
    <a href="#part3" data-jump>PART 3 — Full Solution</a>
    <a href="#part4" data-jump>PART 4 — Deeper Understanding</a>
    <a href="#part5" data-jump>PART 5 — Visualization Guide</a>
    <div class="mini">
      <div class="muted"><b>Interactive:</b> change cavity length <span class="mono">L</span> and gain margin <span class="mono">r=gmax/α</span>.</div>
      <div class="faint">All plots update live (gain curve + modes + predicted per-mode powers).</div>
    </div>
  </nav>

  <article>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>Topic:</b> multimode lasing in a Fabry–Pérot resonator under a <b>Doppler (Gaussian) gain profile</b>.</li>
        <li><b>Key idea:</b> a longitudinal mode oscillates if its <span class="mono">small-signal gain g0(ν)</span> exceeds the <span class="mono">loss coefficient α</span>.</li>
        <li><b>Cavity mode spacing:</b> <span class="mono">Δνc = c / (2 n L)</span> (free spectral range).</li>
        <li><b>Inhomogeneous broadening:</b> different longitudinal modes saturate different velocity classes → per-mode saturation can be approximated independently.</li>
        <li><b>Threshold region:</b> if <span class="mono">gmax = 2α</span>, then modes lase wherever <span class="mono">g0(ν) ≥ α = (1/2) gmax</span> → inside the <b>half-maximum</b> gain bandwidth.</li>
        <li><b>Numerical result (given values):</b> <span class="mono">L=0.30 m</span>, <span class="mono">n=1</span> ⇒ <span class="mono">Δνc = 0.50 GHz</span>; Doppler FWHM <span class="mono">ΔνD = 1.5 GHz</span> ⇒ <b>≈ 3 longitudinal modes</b>.</li>
        <li><b>Strongest mode power estimate:</b> tuning a cavity mode to line center gives a strongest-mode fraction ≈ <b>0.515</b> of total → <b>~26 mW</b> if total output remains ~50 mW.</li>
      </ul>

      <div class="grid2">
        <div class="callout">
          <div class="tag"><span class="pill"></span>Governing equations (copy-ready)</div>
          <div class="eq" id="eq1">
            Δνc = c / (2 n L)
            <small>Longitudinal mode spacing (free spectral range).</small>
          </div>
          <div class="copyRow">
            <button class="copyBtn" data-copy="#eq1">Copy equation</button>
          </div>

          <div class="eq" id="eq2" style="margin-top:10px">
            g0(ν) = gmax · exp[ -4 ln(2) · ((ν-ν0)/ΔνD)^2 ]
            <small>Gaussian Doppler-broadened small-signal gain (ΔνD = FWHM).</small>
          </div>
          <div class="copyRow">
            <button class="copyBtn" data-copy="#eq2">Copy equation</button>
          </div>

          <div class="eq" id="eq3" style="margin-top:10px">
            Threshold condition: g0(νm) ≥ α
            <small>A cavity mode at frequency νm can lase if its small-signal gain exceeds losses.</small>
          </div>
          <div class="copyRow">
            <button class="copyBtn" data-copy="#eq3">Copy equation</button>
          </div>
        </div>

        <div class="callout result">
          <div class="tag"><span class="pill good"></span>Final numeric answers (given data)</div>
          <div class="eq" id="ansText">
            (a) Δνc = 0.50 GHz, threshold region width ≈ ΔνD = 1.5 GHz  ⇒  N ≈ 1.5/0.5 = 3 modes.
            (b) With one mode tuned to ν0: predicted strongest-mode fraction ≈ 1 / (1 + 2·0.47) ≈ 0.515
                ⇒  Pstrong ≈ 0.515 × 50 mW ≈ 26 mW.
          </div>
          <div class="copyRow">
            <button class="copyBtn" data-copy="#ansText">Copy final answer</button>
          </div>
          <div class="foot">Note: Part (b) uses a standard inhomogeneous-saturation model; see PART 3 for the assumptions.</div>
        </div>
      </div>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <h3>Core definitions (symbols + units)</h3>
      <ul>
        <li><span class="mono">L</span> — cavity (resonator) length (m).</li>
        <li><span class="mono">n</span> — refractive index inside the cavity (dimensionless).</li>
        <li><span class="mono">c</span> — speed of light in vacuum (m/s).</li>
        <li><span class="mono">ν</span> — optical frequency (Hz), with line center <span class="mono">ν0</span>.</li>
        <li><span class="mono">Δνc</span> — longitudinal mode spacing / free spectral range (Hz).</li>
        <li><span class="mono">g0(ν)</span> — <b>small-signal gain coefficient</b> at frequency ν (1/m or 1/length; the problem treats it as a coefficient compared to loss).</li>
        <li><span class="mono">gmax</span> — maximum (on-line-center) small-signal gain coefficient (same units as <span class="mono">g0</span>).</li>
        <li><span class="mono">α</span> — loss coefficient (distributed loss per pass length; same units as gain).</li>
        <li><span class="mono">ΔνD</span> — Doppler linewidth (FWHM) of the inhomogeneously broadened gain profile (Hz).</li>
        <li><span class="mono">Pout</span> — total output power (W), and <span class="mono">Pm</span> — power in mode m (W).</li>
      </ul>

      <h3>Physical meaning</h3>
      <div class="grid2">
        <div class="callout">
          <div class="tag"><span class="pill"></span>Longitudinal modes</div>
          <p>
            A Fabry–Pérot cavity only supports standing waves whose round-trip phase is an integer multiple of <span class="mono">2π</span>.
            That quantizes the allowed frequencies. Adjacent allowed frequencies are separated by
            <span class="mono">Δνc = c/(2nL)</span>.
          </p>
          <p class="muted">
            Think of <span class="mono">Δνc</span> as the “frequency grid spacing” set by the cavity length.
          </p>
        </div>
        <div class="callout">
          <div class="tag"><span class="pill"></span>Gain vs loss → threshold</div>
          <p>
            For a mode to grow, amplification must beat loss. In a simple distributed model:
            <span class="mono">g0(νm) ≥ α</span>.
            The region of frequencies where the gain curve lies above the loss line determines how many cavity modes can lase.
          </p>
          <p class="muted">
            The maximum gain may be higher than threshold only near the line center; far away, the gain falls below threshold.
          </p>
        </div>
      </div>

      <h3>Key laws/principles and validity</h3>
      <ul>
        <li><b>Cavity resonance condition</b> (standing wave): valid for stable Fabry–Pérot cavities with well-defined length <span class="mono">L</span>.</li>
        <li><b>Threshold condition</b> gain ≥ loss: valid in steady state near threshold; ignores fast transients.</li>
        <li><b>Gaussian Doppler gain profile</b>: valid for inhomogeneous broadening dominated by Doppler motion (gas lasers like He–Ne).</li>
        <li><b>Inhomogeneous saturation approximation</b>: different modes saturate different parts of the velocity distribution → weaker cross-saturation than in homogeneously broadened media (often a good first model for Doppler-broadened gas lasers).</li>
      </ul>

      <h3>Common models/approximations (and why)</h3>
      <div class="grid3">
        <div class="callout">
          <div class="tag"><span class="pill warn"></span>Model A: “Above-threshold bandwidth” counting</div>
          <p>
            Count how many cavity resonances lie where <span class="mono">g0(ν) ≥ α</span>. Fast, gives <b>mode count</b>.
          </p>
          <p class="muted">Best for part (a).</p>
        </div>
        <div class="callout">
          <div class="tag"><span class="pill warn"></span>Model B: Per-mode saturation (inhomogeneous)</div>
          <p>
            Approximate each mode’s saturated gain as
            <span class="mono">g(νm) = g0(νm)/(1 + Im/Is)</span> and set it equal to <span class="mono">α</span> to find <span class="mono">Im</span>.
          </p>
          <p class="muted">Best for power distribution in part (b).</p>
        </div>
        <div class="callout">
          <div class="tag"><span class="pill warn"></span>Model C: Detailed rate-equations</div>
          <p>
            Full multimode laser equations including cross-saturation and spatial hole burning. Accurate but heavy.
          </p>
          <p class="muted">Overkill for this problem.</p>
        </div>
      </div>

      <h3>Mini intuition examples</h3>
      <ul>
        <li><b>Long cavity → more modes:</b> increasing <span class="mono">L</span> makes <span class="mono">Δνc</span> smaller, packing more modes under the gain curve.</li>
        <li><b>More gain margin → more modes:</b> if <span class="mono">gmax</span> rises relative to <span class="mono">α</span>, the gain curve crosses threshold farther out in frequency → wider “lasing band” → more modes.</li>
      </ul>

      <div class="callout badbox">
        <div class="tag"><span class="pill bad"></span>What to watch for (pitfalls)</div>
        <ul>
          <li>Mixing up <b>Doppler linewidth</b> with cavity mode spacing: one is the gain bandwidth, the other is cavity geometry.</li>
          <li>Using a Lorentzian width formula for Doppler gain (Doppler is Gaussian).</li>
          <li>For part (b), assuming “equal power per mode” without checking gain at each mode frequency.</li>
          <li>For threshold, forgetting that <span class="mono">gmax = 2α</span> implies threshold occurs at <b>half maximum</b> of the gain profile.</li>
        </ul>
      </div>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Problem restatement (clear + precise)</h3>
      <p>
        A multimode He–Ne laser at wavelength <span class="mono">λ0 = 632.8 nm</span> outputs total power <span class="mono">Pout = 50 mW</span>.
        The gain is <b>inhomogeneously broadened</b> with Doppler FWHM linewidth <span class="mono">ΔνD = 1.5 GHz</span>.
        The cavity has refractive index <span class="mono">n = 1</span> and length <span class="mono">L = 30 cm</span>.
      </p>
      <p>
        (a) If the maximum small-signal gain coefficient is <span class="mono">gmax = 2α</span>, find how many longitudinal modes lase.
        (b) If the cavity (mirrors) is adjusted to maximize the intensity of the strongest mode, estimate that mode’s power.
      </p>

      <div class="grid2">
        <div class="callout">
          <div class="tag"><span class="pill"></span>Given</div>
          <ul>
            <li><span class="mono">λ0 = 632.8 nm</span></li>
            <li><span class="mono">Pout = 50 mW</span> (multimode total)</li>
            <li><span class="mono">ΔνD = 1.5 GHz</span> (Doppler FWHM)</li>
            <li><span class="mono">n = 1</span></li>
            <li><span class="mono">L = 0.30 m</span></li>
            <li><span class="mono">gmax = 2α</span></li>
          </ul>
        </div>
        <div class="callout">
          <div class="tag"><span class="pill"></span>Unknowns / targets</div>
          <ul>
            <li>(a) <span class="mono">N</span> = number of longitudinal modes that satisfy threshold.</li>
            <li>(b) <span class="mono">Pstrong</span> = output power in the strongest single longitudinal mode under “best tuning”.</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li><b>Cavity mode spacing</b> (Fabry–Pérot): the problem provides <span class="mono">L</span> and <span class="mono">n</span>, pointing directly to <span class="mono">Δνc</span>.</li>
        <li><b>Threshold inequality</b> <span class="mono">g0(νm) ≥ α</span>: because we’re asked which modes lase and gain/loss are given comparatively.</li>
        <li><b>Doppler (Gaussian) gain curve</b>: because the medium is inhomogeneously broadened with Doppler linewidth.</li>
      </ul>
      <p class="muted">
        We do <b>not</b> need transverse mode theory, detailed rate equations, or exact mirror reflectivities; the question is about longitudinal-mode counting
        and a rough strongest-mode power estimate.
      </p>

      <div class="callout warnbox">
        <div class="tag"><span class="pill warn"></span>Assumptions (explicit)</div>
        <ul>
          <li>The Doppler linewidth <span class="mono">ΔνD</span> is the <b>FWHM</b> of a Gaussian <span class="mono">g0(ν)</span>.</li>
          <li>Longitudinal mode frequencies form a uniform comb with spacing <span class="mono">Δνc</span>.</li>
          <li>Modes lase if <span class="mono">g0(νm) ≥ α</span> (simple threshold model).</li>
          <li>For part (b), use an inhomogeneous saturation model where each mode saturates mainly its own velocity class, giving
              <span class="mono">Im ∝ (g0(νm)/α − 1)</span> for lasing modes.</li>
          <li>Total output power is assumed approximately fixed at 50 mW when redistributing among modes by tuning (common coarse estimate).</li>
        </ul>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ul>
        <li><b>Approach 1 (best):</b> Compute <span class="mono">Δνc</span>, find the frequency interval where <span class="mono">g0 ≥ α</span>, then count how many cavity lines fit. Fast + directly matches part (a).</li>
        <li><b>Approach 2:</b> Use a “mode number ≈ bandwidth/FSR” estimate without modeling the gain shape. Quick but can be wrong when the threshold level is not near half-maximum.</li>
        <li><b>Approach 3:</b> Full multimode laser rate equations. Accurate but far beyond the information given.</li>
      </ul>
      <p><b>Choice:</b> Approach 1 for (a), and a lightweight version of Approach 3’s ideas (per-mode saturation) for (b).</p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>

      <ol>
        <li>
          <b>Compute cavity mode spacing</b><br/>
          <span class="muted">Tool:</span> <span class="mono">Δνc = c/(2nL)</span><br/>
          <span class="muted">Meaning:</span> sets how tightly modes are packed in frequency.
        </li>
        <li>
          <b>Write the Doppler gain profile</b><br/>
          <span class="muted">Tool:</span> Gaussian with FWHM <span class="mono">ΔνD</span><br/>
          <span class="muted">Meaning:</span> tells how gain decreases away from line center.
        </li>
        <li>
          <b>Find the “lasing band” where threshold is met</b><br/>
          <span class="muted">Tool:</span> solve <span class="mono">g0(ν) ≥ α</span> given <span class="mono">gmax = 2α</span><br/>
          <span class="muted">Meaning:</span> region of frequency where modes can oscillate.
        </li>
        <li>
          <b>Count modes</b><br/>
          <span class="muted">Tool:</span> <span class="mono">N ≈ (bandwidth above threshold)/Δνc</span><br/>
          <span class="muted">Meaning:</span> integer number of longitudinal modes.
        </li>
        <li>
          <b>For strongest-mode tuning, place a cavity mode at ν0</b><br/>
          <span class="muted">Tool:</span> shift the comb so one mode hits peak gain<br/>
          <span class="muted">Meaning:</span> that mode gets the maximum gain margin.
        </li>
        <li>
          <b>Estimate per-mode intensities under inhomogeneous saturation</b><br/>
          <span class="muted">Tool:</span> set saturated gain to loss: <span class="mono">g0/(1+I/Is) = α</span><br/>
          <span class="muted">Meaning:</span> yields <span class="mono">I ∝ (g0/α − 1)</span>.
        </li>
        <li>
          <b>Convert intensity ratios to power ratios and scale to 50 mW total</b><br/>
          <span class="muted">Tool:</span> <span class="mono">Pm ∝ Im</span>, then <span class="mono">Pstrong = (Istrong/ΣI)·Pout</span><br/>
          <span class="muted">Meaning:</span> strongest mode power estimate.
        </li>
      </ol>

      <div class="callout badbox">
        <div class="tag"><span class="pill bad"></span>Common mistakes (quick fixes)</div>
        <ul>
          <li><b>Off-by-one mode counting:</b> remember you usually get a central mode plus symmetric side modes → odd numbers like 1, 3, 5…</li>
          <li><b>Wrong Gaussian form:</b> for FWHM <span class="mono">ΔνD</span>, use <span class="mono">exp[-4 ln2 (Δ/ΔνD)^2]</span>.</li>
          <li><b>Assuming “only one mode” can lase:</b> even if one mode is centered, neighbors may still exceed threshold if <span class="mono">Δνc</span> is small compared to linewidth.</li>
        </ul>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Qualitative intuition before calculating</h3>
      <p>
        The cavity supports a comb of resonant frequencies spaced by <span class="mono">Δνc</span>.
        The Doppler gain curve is ~1.5 GHz wide (FWHM). If the comb spacing is around a few tenths of a GHz, we should expect
        only a handful of longitudinal modes to lie under the portion of the gain curve above threshold.
      </p>

      <div class="hr"></div>

      <h3>Step 1: Longitudinal mode spacing (free spectral range)</h3>
      <p>
        For a Fabry–Pérot cavity of length <span class="mono">L</span> filled with index <span class="mono">n</span>, the longitudinal modes are separated by:
      </p>
      <div class="eq" id="eqFSR">
        Δνc = c / (2 n L)
      </div>
      <div class="copyRow">
        <button class="copyBtn" data-copy="#eqFSR">Copy</button>
      </div>

      <p><b>Insert numbers:</b> <span class="mono">c = 3.00×10^8 m/s</span>, <span class="mono">n = 1</span>, <span class="mono">L = 0.30 m</span>.</p>
      <div class="eq" id="eqFSRnum">
        Δνc = (3.00×10^8) / (2×1×0.30) = (3.00×10^8) / 0.60 = 5.00×10^8 Hz = 0.50 GHz
      </div>
      <div class="copyRow">
        <button class="copyBtn" data-copy="#eqFSRnum">Copy</button>
      </div>

      <p class="muted">
        Interpretation: cavity resonances are spaced by half a GHz — fairly coarse compared to a 1.5 GHz Doppler gain width, so only a few will fit.
      </p>

      <div class="hr"></div>

      <h3>Step 2: Gain profile and threshold region</h3>
      <p>
        A Doppler-broadened line is well approximated by a Gaussian. Using the FWHM form:
      </p>
      <div class="eq" id="eqGain">
        g0(ν) = gmax · exp[ -4 ln(2) · ((ν-ν0)/ΔνD)^2 ]
      </div>
      <div class="copyRow">
        <button class="copyBtn" data-copy="#eqGain">Copy</button>
      </div>

      <p>
        The threshold condition (in this simplified distributed-gain picture) is:
      </p>
      <div class="eq" id="eqTh">
        g0(νm) ≥ α
      </div>
      <div class="copyRow">
        <button class="copyBtn" data-copy="#eqTh">Copy</button>
      </div>

      <p>
        We are told <span class="mono">gmax = 2α</span>. Therefore threshold occurs when
        <span class="mono">g0(ν) = α = (1/2) gmax</span>.
      </p>

      <p><b>Find the detuning where the Gaussian drops to half maximum:</b></p>
      <p class="mono">
        g0/gmax = 1/2 = exp[-4 ln2 · (Δ/ΔνD)^2]
      </p>
      <p class="mono">
        Take ln: ln(1/2) = -ln2 = -4 ln2 · (Δ/ΔνD)^2
      </p>
      <p class="mono">
        ⇒ (Δ/ΔνD)^2 = 1/4  ⇒  |Δ| = ΔνD / 2
      </p>

      <div class="callout">
        <div class="tag"><span class="pill"></span>Key result: “above-threshold bandwidth”</div>
        <p>
          The gain is above threshold for <span class="mono">|ν-ν0| ≤ ΔνD/2</span>, i.e. over a total span
          <span class="mono">Δν_lase = ΔνD</span>.
        </p>
      </div>

      <div class="hr"></div>

      <h3>Part (a): Number of longitudinal modes</h3>
      <p>
        Mode count is roughly the number of cavity resonances that fit within the above-threshold frequency span:
      </p>
      <div class="eq" id="eqN">
        N ≈ Δν_lase / Δνc = ΔνD / Δνc
      </div>
      <div class="copyRow">
        <button class="copyBtn" data-copy="#eqN">Copy</button>
      </div>

      <p><b>Insert numbers:</b> <span class="mono">ΔνD = 1.5 GHz</span>, <span class="mono">Δνc = 0.50 GHz</span>.</p>
      <div class="eq" id="eqNnum">
        N ≈ 1.5 / 0.50 = 3
      </div>
      <div class="copyRow">
        <button class="copyBtn" data-copy="#eqNnum">Copy</button>
      </div>

      <div class="callout result">
        <div class="tag"><span class="pill good"></span>Answer (a)</div>
        <p class="mono"><b>N ≈ 3 longitudinal modes</b> (typically the central mode plus one on each side).</p>
      </div>

      <p><b>Sanity checks:</b></p>
      <ul>
        <li><b>Units:</b> GHz/GHz → dimensionless count ✅</li>
        <li><b>Limiting case:</b> if <span class="mono">L</span> doubled, <span class="mono">Δνc</span> halves → <span class="mono">N</span> doubles ✅</li>
        <li><b>Reasonableness:</b> 1.5 GHz wide gain, 0.5 GHz spacing → a few modes ✅</li>
      </ul>

      <div class="hr"></div>

      <h3>Part (b): Power in the strongest mode when tuned for maximum</h3>

      <p>
        “Mirrors adjusted” is commonly interpreted as <b>tuning the cavity length</b> so that one longitudinal resonance lands as close as possible
        to the gain peak at <span class="mono">ν0</span>. That maximizes the gain margin of that particular mode.
      </p>

      <h3>Step 3: Determine which modes lase when one is centered at ν0</h3>
      <p>
        Place mode <span class="mono">m=0</span> at <span class="mono">ν0</span>. Then neighboring modes are at detunings
        <span class="mono">±Δνc</span>, <span class="mono">±2Δνc</span>, ...
      </p>
      <p>
        A mode at detuning <span class="mono">Δ</span> has small-signal gain:
        <span class="mono">g0(Δ) = gmax · exp[-4 ln2 (Δ/ΔνD)^2]</span>.
        With <span class="mono">gmax = 2α</span>, it lases if <span class="mono">g0(Δ)/α ≥ 1</span>.
      </p>

      <p><b>Compute the gain ratios for neighboring modes:</b></p>

      <div class="callout">
        <div class="tag"><span class="pill"></span>Mode m = 0 (centered)</div>
        <p class="mono">Δ = 0 ⇒ g0/α = gmax/α = 2</p>
      </div>

      <div class="callout" style="margin-top:10px">
        <div class="tag"><span class="pill"></span>Modes m = ±1 (detuning Δ = ±Δνc)</div>
        <p class="mono">g0(±Δνc)/gmax = exp[-4 ln2 (Δνc/ΔνD)^2]</p>
        <p class="mono">
          Δνc/ΔνD = 0.50/1.50 = 1/3 ⇒
          g0/gmax = exp[-4 ln2 · (1/3)^2] = exp[-4 ln2/9]
        </p>
        <p class="mono">
          exp[-4 ln2/9] = 2^(-4/9) ≈ 0.735
        </p>
        <p class="mono">
          ⇒ g0/α = (gmax/α)·(g0/gmax) = 2·0.735 ≈ 1.47  (above threshold)
        </p>
      </div>

      <div class="callout" style="margin-top:10px">
        <div class="tag"><span class="pill"></span>Modes m = ±2 (detuning Δ = ±2Δνc)</div>
        <p class="mono">
          Δ/ΔνD = (2·0.50)/1.50 = 2/3 ⇒ g0/gmax = exp[-4 ln2 · (2/3)^2] = exp[-16 ln2/9] = 2^(-16/9) ≈ 0.29
        </p>
        <p class="mono">
          ⇒ g0/α = 2·0.29 ≈ 0.58  (below threshold → does not lase)
        </p>
      </div>

      <p class="muted">
        So with best tuning, the same three modes (m = 0, ±1) lase, but the central mode has the largest gain margin.
      </p>

      <h3>Step 4: Estimate how power splits among lasing modes (inhomogeneous saturation model)</h3>
      <p>
        For inhomogeneous broadening, a standard first estimate is that each mode saturates the gain at its own frequency mostly independently.
        A simple saturation form is:
      </p>
      <div class="eq" id="eqSat">
        g(νm) = g0(νm) / (1 + Im/Is)
        and in steady-state lasing:  g(νm) = α
      </div>
      <div class="copyRow">
        <button class="copyBtn" data-copy="#eqSat">Copy</button>
      </div>

      <p>
        Solve for the intensity <span class="mono">Im</span>:
      </p>
      <p class="mono">
        α = g0 / (1 + Im/Is)  ⇒  1 + Im/Is = g0/α  ⇒  Im = Is (g0/α − 1)
      </p>

      <div class="callout">
        <div class="tag"><span class="pill"></span>Interpretation</div>
        <p>
          In this model, a mode’s intensity scales with its <b>gain margin</b> above threshold:
          <span class="mono">Im ∝ (g0/α − 1)</span>.
          Higher small-signal gain at that mode frequency means more steady-state intensity.
        </p>
      </div>

      <h3>Step 5: Compute intensity ratios for m = 0 and m = ±1</h3>
      <ul>
        <li>
          Center mode: <span class="mono">g0/α = 2</span> ⇒ <span class="mono">I0 = Is (2 − 1) = 1.00 Is</span>
        </li>
        <li>
          Side modes: <span class="mono">g0/α ≈ 1.47</span> ⇒ <span class="mono">I±1 = Is (1.47 − 1) = 0.47 Is</span>
        </li>
      </ul>

      <p>
        Total (relative) multimode intensity:
      </p>
      <div class="eq" id="eqSum">
        Itot ∝ I0 + I+1 + I-1 = Is [1.00 + 2·0.47] = 1.94 Is
      </div>
      <div class="copyRow">
        <button class="copyBtn" data-copy="#eqSum">Copy</button>
      </div>

      <p>
        Therefore the strongest-mode fraction is:
      </p>
      <div class="eq" id="eqFrac">
        fstrong = I0 / (I0 + I+1 + I-1) = 1.00 / 1.94 ≈ 0.515
      </div>
      <div class="copyRow">
        <button class="copyBtn" data-copy="#eqFrac">Copy</button>
      </div>

      <h3>Step 6: Scale by the given total output power</h3>
      <p>
        Using the problem’s total multimode output power <span class="mono">Pout = 50 mW</span> as the scale,
        and assuming output power is approximately conserved under tuning (coarse estimate):
      </p>
      <div class="eq" id="eqPstrong">
        Pstrong ≈ fstrong · Pout ≈ 0.515 · 50 mW ≈ 25.8 mW  ≈ 26 mW
      </div>
      <div class="copyRow">
        <button class="copyBtn" data-copy="#eqPstrong">Copy</button>
      </div>

      <div class="callout result">
        <div class="tag"><span class="pill good"></span>Answer (b)</div>
        <p class="mono"><b>Pstrong ≈ 26 mW</b> (strongest longitudinal mode, with one mode tuned to line center).</p>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><b>Bounds:</b> strongest-mode power must be &lt; total 50 mW ✅ (we get ~26 mW).</li>
        <li><b>Consistency:</b> if side modes were suppressed, strongest-mode power would approach 50 mW; here side modes still above threshold, so strongest mode is only ~half the total ✅</li>
        <li><b>Parameter intuition:</b> narrower linewidth or larger spacing would reduce side-mode gain and increase strongest-mode fraction ✅</li>
      </ul>

      <p class="muted">
        Connection to the visuals: the diagram shows the gain curve and cavity mode comb; the plots show which modes exceed threshold and how power splits.
      </p>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-reading the final formulas: what controls what?</h3>
      <ul>
        <li>
          <b>Mode spacing</b> <span class="mono">Δνc = c/(2nL)</span>:
          increasing <span class="mono">L</span> packs modes closer → more modes under the gain curve.
        </li>
        <li>
          <b>How many modes lase</b> depends on how wide the gain stays above threshold:
          with <span class="mono">gmax/α = r</span>, the threshold crossing occurs at a detuning where
          <span class="mono">g0/gmax = 1/r</span>, which sets an effective lasing bandwidth.
        </li>
        <li>
          <b>Strongest-mode dominance</b> grows when neighboring modes fall below threshold, which happens if:
          <span class="mono">Δνc</span> increases (shorter cavity) or <span class="mono">ΔνD</span> decreases (narrower gain), or if gain margin <span class="mono">r</span> is smaller.</li>
      </ul>

      <h3>How changing parameters affects outcomes (connect to the interactive plots)</h3>
      <ul>
        <li>Increase <span class="mono">L</span> → <span class="mono">Δνc</span> decreases → more mode lines sit above threshold → strongest-mode fraction usually decreases.</li>
        <li>Increase <span class="mono">r = gmax/α</span> → threshold line effectively lower relative to peak → lasing band widens → more modes → strongest-mode fraction decreases.</li>
        <li>Decrease <span class="mono">ΔνD</span> → fewer modes fit → strongest-mode fraction increases, possibly approaching single-mode operation.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        Instead of using the simple saturation law, one can use multimode rate equations with cross-saturation terms.
        In the <b>inhomogeneous</b> limit, cross-saturation is weak and the simple result
        <span class="mono">Im ∝ (g0/α − 1)</span> is recovered as a first approximation. In the <b>homogeneous</b> limit, strong mode competition
        typically collapses the laser toward fewer modes (often one dominant mode).
      </p>

      <h3>Concept checks (quick self-test)</h3>
      <ul>
        <li><b>Q:</b> If the cavity length doubles, what happens to the number of longitudinal modes? <b>A:</b> <span class="mono">Δνc</span> halves, so roughly twice as many modes fit under the same gain band.</li>
        <li><b>Q:</b> Why does <span class="mono">gmax = 2α</span> make the threshold region correspond to the half-maximum points of the gain curve? <b>A:</b> Because threshold requires <span class="mono">g0 = α = (1/2)gmax</span>.</li>
        <li><b>Q:</b> Why can multiple modes oscillate more easily in inhomogeneous broadening than in homogeneous broadening? <b>A:</b> Because different modes draw gain from different sub-ensembles (velocity classes), reducing direct competition.</li>
        <li><b>Q:</b> What parameter most directly sets the mode spacing? <b>A:</b> Cavity length <span class="mono">L</span> (and index <span class="mono">n</span>) through <span class="mono">Δνc = c/(2nL)</span>.</li>
      </ul>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="callout">
        <div class="tag"><span class="pill"></span>What each canvas shows</div>
        <ul>
          <li><b>Diagram:</b> a Fabry–Pérot cavity (two mirrors separated by <span class="mono">L</span>) and the idea of standing-wave longitudinal modes.</li>
          <li><b>Main plot:</b> Gaussian gain curve <span class="mono">g0(ν)/α</span> vs detuning, a horizontal threshold line at 1, and vertical lines for cavity modes. Modes above threshold are highlighted.</li>
          <li><b>Secondary plot:</b> predicted per-mode <b>relative power</b> (from inhomogeneous saturation) vs mode index <span class="mono">m</span>.</li>
        </ul>
      </div>

      <div class="callout" style="margin-top:12px">
        <div class="tag"><span class="pill"></span>Interactive controls (what changes + why)</div>
        <ul>
          <li><span class="mono">L</span> (cavity length): changes <span class="mono">Δνc</span>, moving the mode spacing in the gain plot and changing mode count and power split.</li>
          <li><span class="mono">r = gmax/α</span> (gain margin): changes how far out in frequency the gain stays above threshold, affecting the number of lasing modes and the strongest-mode fraction.</li>
          <li>All numerical readouts and both plots update live to match the symbols used in the text.</li>
        </ul>
      </div>

      <div class="grid2" style="margin-top:14px">
        <div class="canvasWrap">
          <div class="canvasTitle">Diagram — Fabry–Pérot cavity + longitudinal standing waves</div>
          <canvas id="cDiagram" aria-label="Cavity diagram"></canvas>
        </div>
        <div class="canvasWrap">
          <div class="canvasTitle">Main plot — Gain profile and cavity modes (with threshold)</div>
          <canvas id="cGain" aria-label="Gain curve and cavity modes"></canvas>
        </div>
      </div>

      <div class="canvasWrap" style="margin-top:14px">
        <div class="canvasTitle">Secondary plot — Predicted relative modal powers (inhomogeneous saturation)</div>
        <canvas id="cPowers" aria-label="Modal power bar chart"></canvas>
      </div>

      <div class="controls">
        <div class="ctrlCard">
          <label for="Lrng">Cavity length L (m)</label>
          <input id="Lrng" type="range" min="0.10" max="1.00" step="0.01" value="0.30"/>
          <div class="readout">
            <span>Current: <span class="mono" id="Lval">0.30</span> m</span>
            <span>Δνc: <span class="mono" id="FSRval">0.50</span> GHz</span>
          </div>
        </div>
        <div class="ctrlCard">
          <label for="rrng">Gain margin r = g<sub>max</sub>/α</label>
          <input id="rrng" type="range" min="1.05" max="4.00" step="0.01" value="2.00"/>
          <div class="readout">
            <span>Current: <span class="mono" id="rval">2.00</span></span>
            <span>Mode count: <span class="mono" id="Nval">3</span></span>
            <span>Strongest fraction: <span class="mono" id="fval">0.515</span></span>
          </div>
        </div>
      </div>

      <div class="callout" style="margin-top:12px">
        <div class="tag"><span class="pill"></span>Note on “example values”</div>
        <p>
          The interactive plots use the problem’s values by default (<span class="mono">ΔνD = 1.5 GHz</span>, <span class="mono">n=1</span>, <span class="mono">L=0.30 m</span>, <span class="mono">r=2</span>).
          Adjusting sliders explores “what-if” scenarios while keeping the same model.
        </p>
      </div>

      <footer class="foot">
        Built with vanilla HTML/CSS/JS. High-DPI rendering handled via devicePixelRatio scaling.
      </footer>
    </section>
  </article>
</main>

<script>
(function(){
  // ---------------------------
  // Utilities
  // ---------------------------
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const ln2 = Math.log(2);

  function $(id){ return document.getElementById(id); }

  function copyTextFromEl(sel){
    const el = document.querySelector(sel);
    if(!el) return;
    const text = el.innerText.replace(/\n\s+/g,"\n").trim();
    navigator.clipboard?.writeText(text).then(()=>{
      // tiny UI feedback
      const btn = document.querySelector(`button[data-copy="${sel}"]`);
      if(btn){
        const old = btn.textContent;
        btn.textContent = "Copied ✓";
        setTimeout(()=>btn.textContent=old, 900);
      }
    }).catch(()=>{
      // fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      try{ document.execCommand('copy'); }catch(e){}
      document.body.removeChild(ta);
    });
  }

  document.addEventListener('click', (e)=>{
    const b = e.target.closest('button[data-copy]');
    if(b){
      copyTextFromEl(b.getAttribute('data-copy'));
    }
  });

  // Smooth TOC scrolling
  document.querySelectorAll('a[data-jump]').forEach(a=>{
    a.addEventListener('click', (e)=>{
      e.preventDefault();
      const href = a.getAttribute('href');
      const target = document.querySelector(href);
      if(target){
        target.scrollIntoView({behavior:'smooth', block:'start'});
      }
    });
  });

  // ---------------------------
  // Physical model (matches text)
  // ---------------------------
  const c = 3e8;       // m/s
  const n = 1.0;
  const DeltaNuD_GHz = 1.5; // given (FWHM), GHz

  function FSR_GHz(L){
    return (c/(2*n*L))/1e9;
  }

  // Gaussian gain normalized to alpha: g0(Δ)/α = r * exp[-4 ln2 (Δ/ΔνD)^2]
  function gainOverAlpha(detGHz, r){
    const x = detGHz / DeltaNuD_GHz;
    return r * Math.exp(-4*ln2*x*x);
  }

  // Determine lasing modes when a cavity mode is centered at ν0.
  // Modes at detuning m*FSR. Lase if gainOverAlpha >= 1.
  function computeModes(L, r){
    const fsr = FSR_GHz(L);
    // Find max |m| needed: stop when even m=0 gain <1 (but r>=1.05 so center always lases).
    // We'll step until gain falls well below 1.
    const modes = [];
    const maxM = 80; // safe cap
    for(let m=-maxM; m<=maxM; m++){
      const det = m*fsr;
      const g = gainOverAlpha(det, r);
      if(g >= 1){
        // Inhomogeneous saturation: I ~ (g - 1)
        const Irel = (g - 1);
        modes.push({m, det, g, Irel});
      }
    }
    // Keep in order
    modes.sort((a,b)=>a.m-b.m);
    // Strongest is the one with max g (typically m=0 if centered)
    let sumI = 0;
    let maxI = -1;
    let iStrong = 0;
    modes.forEach((mm, idx)=>{
      sumI += mm.Irel;
      if(mm.Irel > maxI){
        maxI = mm.Irel;
        iStrong = idx;
      }
    });
    const fStrong = (sumI>0)? (modes[iStrong].Irel / sumI) : 0;
    return {fsr, modes, fStrong, sumI, iStrong};
  }

  // ---------------------------
  // Canvas rendering helpers (HiDPI)
  // ---------------------------
  function setupCanvas(canvas, hCss){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width));
    const h = hCss || Math.max(1, Math.floor(rect.height));
    canvas.style.height = h + "px";
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return {ctx, w, h, dpr};
  }

  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
    const {x,y,w,h} = box;
    // Background
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.20)";
    ctx.fillRect(x,y,w,h);

    // Title
    ctx.fillStyle = "rgba(234,240,255,0.92)";
    ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(title, x+10, y+18);

    // Plot area
    const padL=54, padR=16, padT=28, padB=42;
    const px = x+padL, py=y+padT, pw=w-padL-padR, ph=h-padT-padB;

    // Gridlines
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.lineWidth = 1;
    const nGrid = 5;
    for(let i=0;i<=nGrid;i++){
      const gx = px + (pw*i/nGrid);
      const gy = py + (ph*i/nGrid);
      ctx.beginPath(); ctx.moveTo(gx,py); ctx.lineTo(gx,py+ph); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(px,gy); ctx.lineTo(px+pw,gy); ctx.stroke();
    }

    // Axes
    ctx.strokeStyle = "rgba(255,255,255,0.22)";
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(px, py+ph);
    ctx.lineTo(px+pw, py+ph);
    ctx.stroke();

    // Ticks + labels
    ctx.fillStyle = "rgba(183,195,230,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";

    function xMap(v){ return px + (v-xMin)*pw/(xMax-xMin); }
    function yMap(v){ return py+ph - (v-yMin)*ph/(yMax-yMin); }

    const nTicks = 6;
    for(let i=0;i<=nTicks;i++){
      const xv = xMin + (xMax-xMin)*i/nTicks;
      const xx = xMap(xv);
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.beginPath(); ctx.moveTo(xx, py+ph); ctx.lineTo(xx, py+ph+6); ctx.stroke();
      const s = (Math.abs(xv) < 1e-9) ? "0" : xv.toFixed(2).replace(/-0\.00/,"0");
      ctx.fillText(s, xx-10, py+ph+20);
    }
    for(let i=0;i<=nTicks;i++){
      const yv = yMin + (yMax-yMin)*i/nTicks;
      const yy = yMap(yv);
      ctx.beginPath(); ctx.moveTo(px-6, yy); ctx.lineTo(px, yy); ctx.stroke();
      const s = yv.toFixed(2);
      ctx.fillText(s, px-48, yy+4);
    }

    // Axis labels
    ctx.fillStyle = "rgba(234,240,255,0.86)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(xLabel, px + pw/2 - ctx.measureText(xLabel).width/2, y + h - 12);

    // y label rotated
    ctx.save();
    ctx.translate(x+14, py + ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
    ctx.restore();

    ctx.restore();
    return {plot:{x:px,y:py,w:pw,h:ph}, xMap, yMap};
  }

  function drawLegend(ctx, items, x, y){
    ctx.save();
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    let yy = y;
    items.forEach(it=>{
      ctx.fillStyle = it.color;
      ctx.fillRect(x, yy-9, 12, 12);
      ctx.fillStyle = "rgba(234,240,255,0.9)";
      ctx.fillText(it.label, x+18, yy+1);
      yy += 16;
    });
    ctx.restore();
  }

  // ---------------------------
  // Draw: Diagram
  // ---------------------------
  function drawDiagram(){
    const canvas = $("cDiagram");
    const {ctx,w,h} = setupCanvas(canvas, 320);

    ctx.clearRect(0,0,w,h);

    // Background
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.fillRect(0,0,w,h);

    // Title strip
    ctx.fillStyle = "rgba(234,240,255,0.10)";
    ctx.fillRect(0,0,w,36);
    ctx.fillStyle = "rgba(234,240,255,0.92)";
    ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText("Fabry–Pérot resonator and longitudinal standing waves", 12, 22);

    // Draw mirrors
    const left = 70, right = w-70;
    const midY = h/2 + 10;

    ctx.strokeStyle = "rgba(125,211,252,0.85)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(left, midY-70); ctx.lineTo(left, midY+70);
    ctx.moveTo(right, midY-70); ctx.lineTo(right, midY+70);
    ctx.stroke();

    // Mirror shading
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1;
    for(let i=0;i<8;i++){
      const x = left + i*2.2;
      ctx.beginPath(); ctx.moveTo(x, midY-70); ctx.lineTo(x, midY+70); ctx.stroke();
    }
    for(let i=0;i<8;i++){
      const x = right - i*2.2;
      ctx.beginPath(); ctx.moveTo(x, midY-70); ctx.lineTo(x, midY+70); ctx.stroke();
    }

    // Standing wave between mirrors
    ctx.strokeStyle = "rgba(167,139,250,0.90)";
    ctx.lineWidth = 2;
    const amp = 22;
    const cycles = 5;
    ctx.beginPath();
    for(let i=0;i<=240;i++){
      const t = i/240;
      const x = left + 10 + t*(right-left-20);
      const y = midY + amp*Math.sin(2*Math.PI*cycles*t);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // Labels
    ctx.fillStyle = "rgba(234,240,255,0.92)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ctx.fillText("Mirror", left-18, midY-80);
    ctx.fillText("Mirror", right-18, midY-80);

    // Length arrow
    ctx.strokeStyle = "rgba(52,211,153,0.9)";
    ctx.lineWidth = 2;
    const yA = midY+92;
    ctx.beginPath();
    ctx.moveTo(left, yA); ctx.lineTo(right, yA);
    ctx.stroke();
    // arrowheads
    ctx.beginPath();
    ctx.moveTo(left, yA); ctx.lineTo(left+10, yA-6); ctx.lineTo(left+10, yA+6); ctx.closePath();
    ctx.fillStyle = "rgba(52,211,153,0.9)"; ctx.fill();
    ctx.beginPath();
    ctx.moveTo(right, yA); ctx.lineTo(right-10, yA-6); ctx.lineTo(right-10, yA+6); ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "rgba(234,240,255,0.92)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText("Cavity length L", (left+right)/2 - 45, yA+18);

    // Resonance condition box
    const bx=12, by=48, bw=Math.min(320, w-24), bh=78;
    ctx.fillStyle = "rgba(0,0,0,0.22)";
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(bx,by,bw,bh,14);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = "rgba(183,195,230,0.95)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText("Longitudinal resonance:", bx+12, by+24);
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ctx.fillText("νm = m · c / (2 n L)", bx+12, by+46);
    ctx.fillText("Δνc = c / (2 n L)", bx+12, by+66);
  }

  // ---------------------------
  // Draw: Gain plot
  // ---------------------------
  function drawGainPlot(L, r, model){
    const canvas = $("cGain");
    const {ctx,w,h} = setupCanvas(canvas, 320);
    ctx.clearRect(0,0,w,h);

    const fsr = model.fsr;
    // x-range: show +/- 2*ΔνD for context
    const xMin = -2.2*DeltaNuD_GHz;
    const xMax =  2.2*DeltaNuD_GHz;

    // y-range: show up to slightly above r
    const yMin = 0;
    const yMax = Math.max(1.2, r*1.08);

    const ax = drawAxes(
      ctx,
      {x:0,y:0,w:w,h:h},
      xMin, xMax, yMin, yMax,
      "Detuning Δν = ν − ν0 (GHz)",
      "Small-signal gain g0/α (dimensionless)",
      "Gaussian gain curve with threshold and cavity modes"
    );

    const {plot, xMap, yMap} = ax;

    // Gain curve
    ctx.save();
    ctx.strokeStyle = "rgba(125,211,252,0.95)";
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    const N = 500;
    for(let i=0;i<=N;i++){
      const x = xMin + (xMax-xMin)*i/N;
      const y = gainOverAlpha(x, r);
      const xx = xMap(x);
      const yy = yMap(y);
      if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
    }
    ctx.stroke();

    // Threshold line at 1
    ctx.strokeStyle = "rgba(251,191,36,0.90)";
    ctx.lineWidth = 2;
    const yTh = yMap(1);
    ctx.beginPath();
    ctx.moveTo(plot.x, yTh); ctx.lineTo(plot.x+plot.w, yTh);
    ctx.stroke();

    // Cavity modes as vertical lines
    // We'll draw around center
    const maxDet = Math.max(Math.abs(xMin), Math.abs(xMax));
    const maxM = Math.floor(maxDet/fsr)+1;

    // Helper: whether lasing
    function isLasing(det){
      return gainOverAlpha(det, r) >= 1;
    }

    for(let m=-maxM; m<=maxM; m++){
      const det = m*fsr;
      if(det < xMin || det > xMax) continue;
      const xx = xMap(det);
      const lase = isLasing(det);
      ctx.strokeStyle = lase ? "rgba(52,211,153,0.90)" : "rgba(255,255,255,0.16)";
      ctx.lineWidth = lase ? 2.0 : 1.0;
      ctx.beginPath();
      ctx.moveTo(xx, plot.y);
      ctx.lineTo(xx, plot.y+plot.h);
      ctx.stroke();
    }

    // Highlight strongest mode (max Irel among lasing)
    const strong = model.modes[model.iStrong];
    if(strong){
      const xx = xMap(strong.det);
      ctx.strokeStyle = "rgba(167,139,250,0.95)";
      ctx.lineWidth = 3.0;
      ctx.beginPath();
      ctx.moveTo(xx, plot.y);
      ctx.lineTo(xx, plot.y+plot.h);
      ctx.stroke();
    }

    // Annotation text
    ctx.fillStyle = "rgba(183,195,230,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ctx.fillText(`ΔνD = ${DeltaNuD_GHz.toFixed(2)} GHz (FWHM)`, plot.x+10, plot.y+18);
    ctx.fillText(`Δνc = ${fsr.toFixed(2)} GHz`, plot.x+10, plot.y+36);
    ctx.fillText(`r = gmax/α = ${r.toFixed(2)}`, plot.x+10, plot.y+54);

    drawLegend(ctx, [
      {color:"rgba(125,211,252,0.95)", label:"Gain g0/α"},
      {color:"rgba(251,191,36,0.90)", label:"Threshold (1)"},
      {color:"rgba(52,211,153,0.90)", label:"Lasing modes"},
      {color:"rgba(167,139,250,0.95)", label:"Strongest mode"}
    ], plot.x+10, plot.y+plot.h-50);

    ctx.restore();
  }

  // ---------------------------
  // Draw: Modal power plot
  // ---------------------------
  function drawPowerPlot(model){
    const canvas = $("cPowers");
    const {ctx,w,h} = setupCanvas(canvas, 320);
    ctx.clearRect(0,0,w,h);

    const modes = model.modes;
    // If none (should not happen), bail gracefully
    if(!modes || modes.length===0){
      ctx.fillStyle="rgba(234,240,255,0.9)";
      ctx.font="14px system-ui";
      ctx.fillText("No lasing modes for these parameters.", 16, 40);
      return;
    }

    // x axis: mode index, from min m to max m
    const mMin = modes[0].m;
    const mMax = modes[modes.length-1].m;

    // y axis: relative power proportional to Irel = g-1
    const yMax = Math.max(...modes.map(d=>d.Irel))*1.15;
    const yMin = 0;

    const ax = drawAxes(
      ctx,
      {x:0,y:0,w:w,h:h},
      mMin-0.8, mMax+0.8, yMin, yMax,
      "Mode index m (integer)",
      "Relative power ∝ (g0/α − 1)",
      "Relative modal powers (inhomogeneous saturation model)"
    );

    const {plot, xMap, yMap} = ax;

    // Bars
    const barW = plot.w / (mMax - mMin + 2);
    modes.forEach((d, idx)=>{
      const xCenter = xMap(d.m);
      const x0 = xCenter - barW*0.35;
      const x1 = xCenter + barW*0.35;
      const y0 = yMap(0);
      const y1 = yMap(d.Irel);

      const isStrong = (idx === model.iStrong);
      ctx.fillStyle = isStrong ? "rgba(167,139,250,0.90)" : "rgba(52,211,153,0.80)";
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 1;

      ctx.beginPath();
      ctx.roundRect(x0, y1, x1-x0, y0-y1, 8);
      ctx.fill();
      ctx.stroke();

      // label (small)
      ctx.fillStyle = "rgba(234,240,255,0.85)";
      ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      const frac = (model.sumI>0) ? (d.Irel/model.sumI) : 0;
      const s = (frac*100).toFixed(0) + "%";
      ctx.fillText(s, x0+2, y1-6);
    });

    // Legend + readout
    drawLegend(ctx, [
      {color:"rgba(52,211,153,0.80)", label:"Lasing mode"},
      {color:"rgba(167,139,250,0.90)", label:"Strongest mode"}
    ], plot.x+10, plot.y+plot.h-50);

    ctx.fillStyle = "rgba(183,195,230,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ctx.fillText(`N = ${modes.length} modes`, plot.x+10, plot.y+18);
    ctx.fillText(`Strongest fraction f ≈ ${model.fStrong.toFixed(3)}`, plot.x+10, plot.y+36);
  }

  // ---------------------------
  // UI wiring + recompute
  // ---------------------------
  const Lrng = $("Lrng");
  const rrng = $("rrng");
  const Lval = $("Lval");
  const rval = $("rval");
  const FSRval = $("FSRval");
  const Nval = $("Nval");
  const fval = $("fval");

  function update(){
    const L = parseFloat(Lrng.value);
    const r = parseFloat(rrng.value);

    const model = computeModes(L, r);

    Lval.textContent = L.toFixed(2);
    rval.textContent = r.toFixed(2);
    FSRval.textContent = model.fsr.toFixed(2);
    Nval.textContent = String(model.modes.length);
    fval.textContent = model.fStrong.toFixed(3);

    drawDiagram();
    drawGainPlot(L, r, model);
    drawPowerPlot(model);
  }

  Lrng.addEventListener('input', update);
  rrng.addEventListener('input', update);
  window.addEventListener('resize', update);

  // Initial draw
  update();
})();
</script>
</body>
</html>
