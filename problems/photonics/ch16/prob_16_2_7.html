<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Transmittance of a Laser Resonator — Length, Photon Lifetime, Threshold Gain</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f1620;
      --panel2:#111b27;
      --text:#e9eef6;
      --muted:#a9b6c7;
      --faint:#7f8da1;
      --accent:#6ae4ff;
      --accent2:#a78bfa;
      --ok:#49f2a0;
      --warn:#ffd166;
      --bad:#ff5c7a;
      --line:rgba(255,255,255,.10);
      --shadow: 0 18px 60px rgba(0,0,0,.35);
      --radius:18px;
      --radius2:26px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(900px 600px at 15% 10%, rgba(106,228,255,.14), transparent 55%),
        radial-gradient(900px 600px at 85% 15%, rgba(167,139,250,.14), transparent 60%),
        radial-gradient(700px 500px at 60% 90%, rgba(73,242,160,.10), transparent 55%),
        linear-gradient(180deg, #070a0f, var(--bg));
      overflow-x:hidden;
    }

    a{color:var(--accent)}
    header{
      padding:28px 18px 14px;
      max-width:1200px;
      margin:0 auto;
    }
    .title{
      display:flex;
      gap:14px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-size: clamp(22px, 3.1vw, 38px);
      letter-spacing:.2px;
      line-height:1.15;
    }
    .subtitle{
      margin:10px 0 0;
      color:var(--muted);
      max-width:78ch;
      font-size: clamp(14px, 1.25vw, 16px);
      line-height:1.55;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding: 14px 18px 60px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }

    /* Sticky TOC */
    nav.toc{
      position:sticky;
      top:14px;
      background: linear-gradient(180deg, rgba(17,27,39,.92), rgba(15,22,32,.92));
      backdrop-filter: blur(10px);
      border:1px solid var(--line);
      border-radius: var(--radius2);
      padding:16px 14px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .toc h2{
      margin:0 0 10px;
      font-size:14px;
      color:var(--muted);
      letter-spacing:.12em;
      text-transform:uppercase;
    }
    .toc a{
      display:block;
      padding:8px 10px;
      margin:4px 0;
      color:var(--text);
      text-decoration:none;
      border-radius: 12px;
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:14px;
    }
    .toc a:hover{
      background: rgba(106,228,255,.08);
      border-color: rgba(106,228,255,.18);
      transform: translateX(2px);
    }
    .toc small{color:var(--faint); display:block; margin-top:10px; line-height:1.4}

    /* Content cards */
    article{
      display:flex;
      flex-direction:column;
      gap:18px;
      min-width:0;
    }
    section{
      background: linear-gradient(180deg, rgba(17,27,39,.86), rgba(15,22,32,.86));
      border:1px solid var(--line);
      border-radius: var(--radius2);
      padding:18px 18px 16px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    section::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(400px 120px at 12% 0%, rgba(106,228,255,.10), transparent 60%),
                  radial-gradient(420px 130px at 88% 0%, rgba(167,139,250,.10), transparent 62%);
      pointer-events:none;
      opacity:.9;
    }
    section > *{position:relative}
    h2{
      margin:0 0 10px;
      font-size: 20px;
      letter-spacing:.2px;
    }
    h3{
      margin:14px 0 8px;
      font-size:16px;
      color: var(--text);
    }
    p{margin:8px 0; line-height:1.65; color:var(--text)}
    ul{margin:10px 0 0 20px; color:var(--text); line-height:1.6}
    li{margin:6px 0}
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
      nav.toc{position:relative; top:auto}
      .grid2{grid-template-columns: 1fr}
    }

    .callouts{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:12px;
      margin-top:10px;
    }
    .card{
      grid-column: span 12;
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:12px 12px 10px;
      background: rgba(255,255,255,.03);
    }
    .card strong{display:block; margin-bottom:6px}
    .assump{border-color: rgba(255,209,102,.35); background: rgba(255,209,102,.06)}
    .keyeq{border-color: rgba(106,228,255,.35); background: rgba(106,228,255,.06)}
    .mist{border-color: rgba(255,92,122,.35); background: rgba(255,92,122,.06)}
    .final{border-color: rgba(73,242,160,.35); background: rgba(73,242,160,.06)}
    .mini{
      color:var(--muted);
      font-size:13px;
      line-height:1.55;
    }

    .eqwrap{
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
      margin:10px 0 6px;
    }
    .eq{
      font-family:var(--mono);
      font-size: 13.5px;
      background: rgba(0,0,0,.30);
      border:1px solid var(--line);
      border-radius: 14px;
      padding:10px 10px;
      white-space:pre-wrap;
      line-height:1.45;
      flex:1 1 520px;
      min-width:min(100%, 520px);
    }
    button.copy{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:var(--text);
      border-radius: 14px;
      padding:10px 12px;
      font-weight:600;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      flex:0 0 auto;
    }
    button.copy:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.10);
      border-color: rgba(106,228,255,.28);
    }
    button.copy:active{transform: translateY(0px) scale(.99)}
    .copyNote{font-size:12px; color:var(--faint); margin-top:6px}

    /* Visualization area */
    .vizgrid{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:12px;
      align-items:stretch;
      margin-top:10px;
    }
    .viz{
      border:1px solid var(--line);
      border-radius: var(--radius2);
      background: rgba(0,0,0,.22);
      overflow:hidden;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
    }
    .viz header{
      padding:12px 12px 10px;
      border-bottom:1px solid rgba(255,255,255,.08);
      margin:0;
      max-width:none;
    }
    .viz header h3{margin:0; font-size:14px; color:var(--muted); letter-spacing:.08em; text-transform:uppercase}
    canvas{
      display:block;
      width:100%;
      height: 290px;
    }
    .small canvas{height: 250px}
    .diagram canvas{height: 240px}

    @media (max-width:980px){
      .vizgrid{grid-template-columns:1fr}
      canvas{height: 280px}
      .diagram canvas{height:240px}
    }

    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      margin-top:10px;
      padding:10px 12px;
      border-radius: var(--radius);
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
    }
    .controls label{
      font-size:13px;
      color:var(--muted);
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    input[type="range"]{
      width: 260px;
      accent-color: var(--accent);
    }
    .pill{
      font-family:var(--mono);
      font-size:12.5px;
      padding:6px 8px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: var(--text);
    }
    .btnrow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-left:auto;
    }
    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:var(--text);
      border-radius: 14px;
      padding:9px 11px;
      font-weight:700;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .btn:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.10);
      border-color: rgba(167,139,250,.28);
    }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding: 14px 18px 30px;
      color: var(--faint);
      font-size: 12.5px;
      line-height:1.55;
    }

    /* Print-friendly */
    @media print{
      body{background:#fff; color:#000}
      nav.toc{display:none}
      section{box-shadow:none; background:#fff; border-color:#ccc}
      .eq{background:#f6f6f6}
      .viz{display:none}
      a{color:#000; text-decoration:underline}
    }

    /* Subtle entrance animation */
    @media (prefers-reduced-motion: no-preference){
      section{animation: rise .35s ease both}
      section:nth-child(2){animation-delay:.03s}
      section:nth-child(3){animation-delay:.06s}
      section:nth-child(4){animation-delay:.09s}
      section:nth-child(5){animation-delay:.12s}
      section:nth-child(6){animation-delay:.15s}
      @keyframes rise{
        from{transform: translateY(6px); opacity:.0}
        to{transform: translateY(0); opacity:1}
      }
    }
  </style>
</head>

<body>
<header>
  <div class="title">
    <div>
      <h1>Transmittance of a Laser Resonator: Finding <span style="color:var(--accent)">L</span>, <span style="color:var(--accent2)">photon lifetime</span>, and <span style="color:var(--ok)">threshold gain</span></h1>
      <p class="subtitle">
        A tunable monochromatic source probes an <b>unpumped gas-laser resonator</b>. From the measured transmission peaks we extract the
        <b>free spectral range</b> (mode spacing) and the <b>linewidth</b>, then convert those directly into the resonator length, the photon lifetime,
        and the threshold gain coefficient.
      </p>
    </div>
  </div>
</header>

<main>
  <nav class="toc" aria-label="Table of contents">
    <h2>Contents</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy &amp; Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
    <small>
      Interactive controls below let you “turn on” sub-threshold gain and watch
      linewidth and transmission peaks change.
    </small>
  </nav>

  <article>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>What this is about:</b> reading a cavity transmission spectrum to infer resonator parameters.</li>
        <li><b>Key idea:</b> adjacent resonances are separated by the <b>free spectral range</b> (FSR) and each resonance has a <b>linewidth</b> set by losses.</li>
        <li><b>Given from the figure:</b> mode spacing (FSR) ≈ <b>200&nbsp;MHz</b>, resonance linewidth ≈ <b>2&nbsp;MHz</b>, central optical frequency ≈ <b>5×10<sup>14</sup>&nbsp;Hz</b>, refractive index <b>n=1</b>.</li>
        <li><b>Governing equations:</b> FSR <span class="muted">Δν<sub>FSR</sub>=c/(2nL)</span>, linewidth–lifetime <span class="muted">Δν=1/(2π τ<sub>ph</sub>)</span>, threshold gain <span class="muted">g<sub>th</sub>=1/(v<sub>g</sub> τ<sub>ph</sub>)</span>.</li>
        <li><b>Results (numeric):</b> <b>L ≈ 0.75 m</b>, <b>τ<sub>ph</sub> ≈ 80 ns</b>, <b>g<sub>th</sub> ≈ 0.042 m⁻¹</b> (≈4.2×10⁻³ cm⁻¹).</li>
        <li><b>Part (b) sketch outcome:</b> adding <b>sub-threshold gain</b> reduces effective losses → resonances become <b>taller and narrower</b> near line center, with the same 200&nbsp;MHz spacing.</li>
      </ul>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <h3>Core definitions (symbols + units)</h3>
      <ul>
        <li><b>Cavity length</b> <span class="muted">L</span> (m): mirror-to-mirror distance in a linear (Fabry–Pérot) resonator.</li>
        <li><b>Refractive index</b> <span class="muted">n</span> (dimensionless): sets phase velocity in the cavity; here <span class="muted">n=1</span>.</li>
        <li><b>Free spectral range</b> <span class="muted">Δν<sub>FSR</sub></span> (Hz): frequency spacing between adjacent longitudinal resonances.</li>
        <li><b>Resonance linewidth</b> <span class="muted">Δν</span> (Hz): full width at half maximum (FWHM) of a transmission peak.</li>
        <li><b>Photon lifetime</b> <span class="muted">τ<sub>ph</sub></span> (s): average time energy stays stored in the cavity before being lost.</li>
        <li><b>Gain coefficient</b> <span class="muted">g</span> (m⁻¹): exponential amplification per unit length for intensity: <span class="muted">I(z) ∝ e^{g z}</span>.</li>
        <li><b>Threshold gain</b> <span class="muted">g<sub>th</sub></span> (m⁻¹): gain that exactly balances cavity losses (net growth rate = 0).</li>
      </ul>

      <h3>Physical meaning (what these quantities represent)</h3>
      <p>
        In a linear resonator, only frequencies that satisfy the standing-wave condition “fit” in the cavity.
        Those frequencies appear as sharp transmission peaks when you scan a tunable laser through them.
        The <b>spacing</b> between peaks tells you the round-trip time (hence length), while the <b>width</b> of each peak tells you how quickly
        stored energy decays (hence photon lifetime and losses).
      </p>

      <h3>Key principles and validity conditions</h3>
      <ul>
        <li><b>Longitudinal resonance condition:</b> round-trip phase must be an integer multiple of 2π (plane-wave, near-normal incidence).</li>
        <li><b>FSR formula:</b> assumes a simple two-mirror cavity with length L and index n, and that dispersion across one FSR is negligible.</li>
        <li><b>Linewidth–lifetime relation:</b> assumes an exponential decay of stored energy with a single decay constant τ<sub>ph</sub> (linear, time-invariant losses).</li>
        <li><b>Threshold gain:</b> assumes a uniform small-signal gain and that gain competes with the same loss channel that sets τ<sub>ph</sub>.</li>
      </ul>

      <div class="callouts">
        <div class="card keyeq">
          <strong>Key equations (copyable)</strong>
          <div class="eqwrap">
            <div class="eq" id="eq_key">
Δν_FSR = c / (2 n L)
Δν = 1 / (2π τ_ph)
g_th = 1 / (v_g τ_ph)  (with v_g ≈ c/n)</div>
            <button class="copy" data-copy="#eq_key">Copy</button>
          </div>
          <div class="mini">These three relationships are enough to solve part (a) directly from the spectrum.</div>
        </div>
      </div>

      <h3>Common models / approximations (and why we use them)</h3>
      <ul>
        <li><b>Fabry–Pérot / Airy model:</b> transmission is periodic in frequency with sharp resonances; great for interpreting scanned spectra.</li>
        <li><b>Single-pole cavity response:</b> energy in the cavity decays as <span class="muted">U(t)=U(0)e^{-t/τ<sub>ph</sub>}</span>, giving a Lorentzian resonance in frequency.</li>
        <li><b>Group velocity approximation:</b> <span class="muted">v<sub>g</sub>≈c/n</span> (good here since n=1 and we’re not near strong dispersion features).</li>
      </ul>

      <h3>Mini intuition examples</h3>
      <ul>
        <li>If peaks are <b>far apart</b> (large FSR), the cavity must be <b>short</b> (light completes a round trip quickly).</li>
        <li>If peaks are <b>very narrow</b> (small linewidth), photons live <b>longer</b> in the cavity (low loss, high finesse).</li>
      </ul>

      <h3>What to watch for (pitfalls)</h3>
      <ul>
        <li>Using the wrong FSR formula (linear cavity uses <span class="muted">2L</span> round trip).</li>
        <li>Confusing Hz vs rad/s (the 2π matters in <span class="muted">Δν = 1/(2π τ)</span>).</li>
        <li>Mixing “field lifetime” and “energy (photon) lifetime” definitions—here we use the standard energy-decay photon lifetime tied to the intensity linewidth.</li>
      </ul>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Problem restatement (in plain words)</h3>
      <p>
        A tunable monochromatic source is sent through an <b>unpumped</b> gas-laser optical resonator. The transmitted intensity versus frequency shows
        a comb of resonant peaks. From that plot:
      </p>
      <ul>
        <li><b>(a)</b> Find the resonator length <span class="muted">L</span>, photon lifetime <span class="muted">τ<sub>ph</sub></span>, and threshold gain coefficient <span class="muted">g<sub>th</sub></span> (given <span class="muted">n=1</span>).</li>
        <li><b>(b)</b> If the cavity is pumped but still <b>below threshold</b>, sketch how transmission versus frequency changes.</li>
      </ul>

      <h3>Given quantities (read from the figure)</h3>
      <ul>
        <li>FSR (peak spacing): <span class="muted">Δν<sub>FSR</sub> ≈ 200&nbsp;MHz = 2.00×10<sup>8</sup>&nbsp;Hz</span></li>
        <li>Resonance linewidth: <span class="muted">Δν ≈ 2&nbsp;MHz = 2.00×10<sup>6</sup>&nbsp;Hz</span></li>
        <li>Transition (center) frequency: <span class="muted">ν<sub>0</sub> ≈ 5×10<sup>14</sup>&nbsp;Hz</span></li>
        <li>Refractive index: <span class="muted">n = 1</span></li>
        <li>Speed of light: <span class="muted">c = 3.00×10<sup>8</sup>&nbsp;m/s</span></li>
      </ul>

      <h3>Unknowns</h3>
      <ul>
        <li><span class="muted">L</span> (m)</li>
        <li><span class="muted">τ<sub>ph</sub></span> (s)</li>
        <li><span class="muted">g<sub>th</sub></span> (m⁻¹ or cm⁻¹)</li>
      </ul>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li><b>FSR → length:</b> The spacing between adjacent longitudinal modes depends only on round-trip time, hence on <span class="muted">L</span> and <span class="muted">n</span>.</li>
        <li><b>Linewidth → lifetime:</b> A lossy cavity stores energy that decays exponentially; the Fourier transform gives a Lorentzian resonance with width set by the decay time.</li>
        <li><b>Lifetime → threshold gain:</b> At threshold, gain exactly cancels loss. The loss rate is the inverse photon lifetime.</li>
      </ul>
      <p class="muted">
        We do <b>not</b> need mirror reflectivities explicitly because the measured linewidth already contains the total round-trip loss information.
      </p>

      <div class="callouts">
        <div class="card assump">
          <strong>Assumptions</strong>
          <div class="mini">
            (1) Linear Fabry–Pérot cavity (two-mirror resonator). (2) n=1 and v<sub>g</sub>≈c. (3) Measured 2&nbsp;MHz is the intensity FWHM linewidth.
            (4) Losses are frequency-independent across one FSR for part (a). (5) In part (b), pumping introduces a small-signal gain profile centered at ν<sub>0</sub>.
          </div>
        </div>
      </div>

      <h3>Possible approaches (compare briefly)</h3>
      <ul>
        <li><b>Direct spectral-parameter method (best here):</b> Use FSR and linewidth formulas → quickest, uses given plot directly.</li>
        <li><b>Round-trip loss method:</b> Infer finesse <span class="muted">F=Δν<sub>FSR</sub>/Δν</span>, then compute mirror reflectivity and loss. Needs extra model assumptions about coupling; unnecessary.</li>
        <li><b>Time-domain ringdown method:</b> Would measure decay after switching off input to get τ<sub>ph</sub>. Not available here, but equivalent in principle.</li>
      </ul>
      <p><b>Chosen approach:</b> Use <span class="muted">Δν<sub>FSR</sub></span> for <span class="muted">L</span>, use linewidth for <span class="muted">τ<sub>ph</sub></span>, then use the loss rate for <span class="muted">g<sub>th</sub></span>.</p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>

      <ol style="margin:10px 0 0 20px; line-height:1.7;">
        <li><b>Extract FSR</b> from adjacent peak spacing (goal: get Δν<sub>FSR</sub>). <span class="muted">Tool: read spectrum.</span> Meaning: inverse of round-trip time.</li>
        <li><b>Compute length</b> using <span class="muted">Δν<sub>FSR</sub>=c/(2nL)</span>. Meaning: longer cavity → smaller spacing.</li>
        <li><b>Extract linewidth</b> Δν (FWHM) from a peak. Meaning: set by total loss (mirror + scattering + absorption).</li>
        <li><b>Convert linewidth to photon lifetime</b> via <span class="muted">Δν=1/(2π τ<sub>ph</sub>)</span>. Meaning: narrower peak → longer storage time.</li>
        <li><b>Relate lifetime to threshold gain</b> using rate balance: <span class="muted">c g<sub>th</sub>=1/τ<sub>ph</sub></span> (since n=1). Meaning: gain must replace lost photons.</li>
        <li><b>Part (b):</b> Introduce sub-threshold gain and predict how effective linewidth and peak heights change versus frequency (gain profile centered at ν<sub>0</sub>).</li>
      </ol>

      <div class="callouts">
        <div class="card mist">
          <strong>Common mistakes (quick tips)</strong>
          <div class="mini">
            • Don’t forget the factor <b>2</b> in <span class="muted">c/(2nL)</span> (linear cavity round trip).<br/>
            • Don’t drop the <b>2π</b> in <span class="muted">Δν=1/(2π τ)</span>.<br/>
            • Keep units consistent: MHz → Hz; cm⁻¹ vs m⁻¹ conversion (1 m⁻¹ = 10⁻² cm⁻¹).
          </div>
        </div>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Qualitative expectation before calculating</h3>
      <p>
        A Fabry–Pérot cavity transmits strongly only when the input frequency matches a cavity resonance. The spacing between resonances should be constant
        (for a fixed L and n), and the resonances should be narrow if the cavity has low loss. Since the plot indicates a relatively small linewidth (2 MHz)
        compared to the spacing (200 MHz), we expect a fairly high-finesse cavity and a photon lifetime on the order of <span class="muted">1/(2π·MHz) ~ 10⁻⁷ s</span>.
      </p>

      <h3>Step 1: Resonator length from the free spectral range</h3>
      <p>
        For a linear cavity of length <span class="muted">L</span> filled with index <span class="muted">n</span>, the longitudinal modes satisfy:
        the round-trip phase <span class="muted">2k n L</span> changes by <span class="muted">2π</span> between adjacent modes.
        This gives the well-known free spectral range:
      </p>

      <div class="eqwrap">
        <div class="eq" id="eq_fsr">Δν_FSR = c / (2 n L)</div>
        <button class="copy" data-copy="#eq_fsr">Copy</button>
      </div>

      <p>
        Solve for <span class="muted">L</span>:
      </p>
      <div class="eqwrap">
        <div class="eq" id="eq_L">L = c / (2 n Δν_FSR)</div>
        <button class="copy" data-copy="#eq_L">Copy</button>
      </div>

      <p>
        Insert values (<span class="muted">c=3.00×10^8 m/s</span>, <span class="muted">n=1</span>, <span class="muted">Δν_FSR=200 MHz=2.00×10^8 Hz</span>):
      </p>
      <div class="eqwrap">
        <div class="eq" id="eq_Lnum">
L = (3.00×10^8 m/s) / (2 × 1 × 2.00×10^8 s^-1)
  = 3.00×10^8 / 4.00×10^8  m
  = 0.75 m</div>
        <button class="copy" data-copy="#eq_Lnum">Copy</button>
      </div>
      <p class="muted">
        What we did: used mode spacing to infer round-trip time → length. Why it works: peaks occur whenever an integer number of half-wavelengths fits in L.
      </p>

      <h3>Step 2: Photon lifetime from the resonance linewidth</h3>
      <p>
        A lossy cavity stores electromagnetic energy <span class="muted">U(t)</span> that decays approximately exponentially:
        <span class="muted">U(t)=U(0)e^{-t/τ_ph}</span>. The corresponding frequency response is Lorentzian with an intensity full-width at half-maximum:
      </p>

      <div class="eqwrap">
        <div class="eq" id="eq_tau">Δν = 1 / (2π τ_ph)</div>
        <button class="copy" data-copy="#eq_tau">Copy</button>
      </div>

      <p>
        Solve for <span class="muted">τ<sub>ph</sub></span>:
      </p>
      <div class="eqwrap">
        <div class="eq" id="eq_tau2">τ_ph = 1 / (2π Δν)</div>
        <button class="copy" data-copy="#eq_tau2">Copy</button>
      </div>

      <p>
        Insert <span class="muted">Δν=2 MHz=2.00×10^6 Hz</span>:
      </p>
      <div class="eqwrap">
        <div class="eq" id="eq_taunum">
τ_ph = 1 / (2π × 2.00×10^6 s^-1)
     ≈ 1 / (12.566×10^6 s^-1)
     ≈ 7.96×10^-8 s
     ≈ 79.6 ns</div>
        <button class="copy" data-copy="#eq_taunum">Copy</button>
      </div>

      <p class="muted">
        What we did: converted frequency-domain width into time-domain storage time. Why 2π appears: Hz is cycles/s, while decay rates naturally connect to rad/s.
      </p>

      <h3>Step 3: Threshold gain coefficient from the loss rate</h3>
      <p>
        In a laser cavity, the intracavity photon number (or energy) grows with gain and decays with losses. A simple rate equation for energy is:
      </p>

      <div class="eqwrap">
        <div class="eq" id="eq_rate">dU/dt = (v_g g - 1/τ_ph) U</div>
        <button class="copy" data-copy="#eq_rate">Copy</button>
      </div>

      <p>
        At <b>threshold</b>, the net growth rate is zero:
        <span class="muted">v_g g_th = 1/τ_ph</span>. With <span class="muted">n=1</span>, we take <span class="muted">v_g ≈ c</span>, so:
      </p>

      <div class="eqwrap">
        <div class="eq" id="eq_gth">g_th = 1 / (v_g τ_ph) ≈ 1 / (c τ_ph)</div>
        <button class="copy" data-copy="#eq_gth">Copy</button>
      </div>

      <p>
        Insert <span class="muted">c=3.00×10^8 m/s</span> and <span class="muted">τ_ph = 7.96×10^-8 s</span>:
      </p>

      <div class="eqwrap">
        <div class="eq" id="eq_gnum">
g_th ≈ 1 / (3.00×10^8 m/s × 7.96×10^-8 s)
     = 1 / (23.88 m)
     ≈ 0.0419 m^-1
     ≈ 4.19×10^-3 cm^-1</div>
        <button class="copy" data-copy="#eq_gnum">Copy</button>
      </div>

      <div class="callouts">
        <div class="card final">
          <strong>Final Answer (Part a)</strong>
          <div class="eqwrap">
            <div class="eq" id="eq_final">
Given Δν_FSR = 200 MHz, Δν = 2 MHz, n = 1:

L = c/(2 n Δν_FSR) = 0.75 m
τ_ph = 1/(2π Δν) ≈ 7.96×10^-8 s ≈ 80 ns
g_th = 1/(c τ_ph) ≈ 4.19×10^-2 m^-1 ≈ 4.19×10^-3 cm^-1</div>
            <button class="copy" data-copy="#eq_final">Copy</button>
          </div>
          <div class="mini">
            These values come straight from the two measured spectral features: spacing (FSR) and linewidth.
          </div>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><b>Units:</b> <span class="muted">L</span> in meters; <span class="muted">τ</span> in seconds; <span class="muted">g</span> in m⁻¹ (since <span class="muted">cτ</span> is a length).</li>
        <li><b>Limiting behavior:</b> if linewidth ↓, then τ<sub>ph</sub> ↑ and g<sub>th</sub> ↓ — a better cavity needs less gain to lase (makes sense).</li>
        <li><b>Scale check:</b> a 0.75 m cavity gives FSR ~ c/(2L) ≈ 3e8/(1.5) ≈ 2e8 Hz = 200 MHz — consistent.</li>
      </ul>

      <h3>Part (b): sketch when pumped but still below threshold</h3>
      <p>
        Pumping introduces a <b>small-signal gain</b> <span class="muted">g(ν)</span> centered at the laser transition frequency <span class="muted">ν<sub>0</sub></span>.
        If pumping is <b>not sufficient</b> for oscillation, then <span class="muted">g(ν) &lt; g_th</span> for all frequencies, so the cavity remains stable (no self-sustained lasing).
        However, the gain <b>partially cancels losses</b>, so the effective decay rate decreases:
      </p>

      <div class="eqwrap">
        <div class="eq" id="eq_eff">
1/τ_eff(ν) = 1/τ_ph − v_g g(ν)
Δν_eff(ν) = 1/(2π τ_eff(ν))</div>
        <button class="copy" data-copy="#eq_eff">Copy</button>
      </div>

      <p>
        Therefore, near line center where <span class="muted">g(ν)</span> is largest, transmission resonances become <b>narrower</b> (smaller Δν) and typically <b>taller</b>
        (more build-up, less net loss). The peak spacing remains the same 200 MHz because it is set by geometry (L and n), not by gain.
      </p>

      <p class="muted">
        The interactive plots below implement exactly this idea: a gain fraction slider increases <span class="muted">g/g_th</span> (but keeps it &lt; 1),
        and you’ll see peaks sharpen and τ_eff rise toward infinity as you approach threshold.
      </p>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the final formulas</h3>
      <ul>
        <li><b>Δν<sub>FSR</sub> = c/(2nL):</b> geometry sets the “comb spacing.” Doubling L halves the spacing.</li>
        <li><b>Δν = 1/(2π τ<sub>ph</sub>):</b> linewidth is the frequency-domain fingerprint of time-domain energy loss.</li>
        <li><b>g<sub>th</sub> = 1/(v<sub>g</sub> τ<sub>ph</sub>):</b> threshold gain is basically “loss per meter” written as a gain.</li>
      </ul>

      <h3>How parameter changes affect outcomes (connect to plots)</h3>
      <ul>
        <li>Increase <b>gain fraction</b> (<span class="muted">g/g_th</span> ↑) → <span class="muted">τ_eff</span> ↑ and <span class="muted">Δν_eff</span> ↓; peaks sharpen dramatically near center where gain is strongest.</li>
        <li>Increase <b>cavity length</b> (not changed in the slider, but conceptually) → FSR decreases; peaks crowd closer together.</li>
        <li>Increase <b>loss</b> (larger Δν at zero gain) → τ<sub>ph</sub> decreases and threshold gain increases.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        Instead of using <span class="muted">Δν=1/(2π τ)</span> directly, you can compute the <b>finesse</b>
        <span class="muted">F=Δν_FSR/Δν</span> and relate it to round-trip power loss.
        That approach can yield mirror reflectivity estimates if coupling assumptions are supplied.
      </p>

      <h3>Concept checks (self-test)</h3>
      <ul>
        <li><b>Q:</b> If the observed FSR were 400 MHz instead of 200 MHz, what happens to L? <b>A:</b> It halves (L ∝ 1/FSR).</li>
        <li><b>Q:</b> If Δν shrinks by 10×, what happens to τ<sub>ph</sub>? <b>A:</b> It grows by 10× (τ ∝ 1/Δν).</li>
        <li><b>Q:</b> Why doesn’t ν<sub>0</sub> matter for part (a)? <b>A:</b> FSR and linewidth depend on time scales (round-trip and decay), not the absolute optical carrier.</li>
        <li><b>Q:</b> Below threshold, can the cavity still show narrow peaks? <b>A:</b> Yes—gain can reduce effective loss and narrow peaks without self-oscillation as long as g&lt;g<sub>th</sub>.</li>
      </ul>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="controls" role="group" aria-label="Interactive controls">
        <label>
          Gain fraction (sub-threshold):
          <input id="gainSlider" type="range" min="0" max="0.98" step="0.01" value="0.00" />
          <span class="pill" id="gainLabel">g/g_th = 0.00</span>
        </label>

        <label>
          Gain bandwidth (example):
          <input id="bwSlider" type="range" min="0.2" max="5.0" step="0.1" value="1.2" />
          <span class="pill" id="bwLabel">σ = 1.2 GHz</span>
        </label>

        <div class="btnrow">
          <button class="btn" id="resetBtn" type="button">Reset</button>
          <span class="pill" id="readouts">τ_ph = 79.6 ns • Δν = 2.0 MHz • FSR = 200 MHz</span>
        </div>
      </div>

      <p class="muted">
        <b>What each canvas shows:</b>
      </p>
      <ul>
        <li><b>Diagram:</b> a linear Fabry–Pérot cavity of length L, with input and transmitted beams and a note about FSR and linewidth.</li>
        <li><b>Main plot:</b> transmission vs frequency offset around ν<sub>0</sub>, showing multiple cavity modes spaced by Δν<sub>FSR</sub>. When gain is added (but below threshold), peaks near ν<sub>0</sub> sharpen and rise.</li>
        <li><b>Secondary plot:</b> τ<sub>eff</sub>(ν) and Δν<sub>eff</sub>(ν) at line center as the gain fraction changes (parameter sweep). This shows how close you are to threshold.</li>
      </ul>

      <p class="muted">
        <b>Interactive controls:</b> The <span class="muted">g/g<sub>th</sub></span> slider increases the peak gain at line center (kept below 1).
        The bandwidth slider sets an <i>example</i> Gaussian gain profile width σ (in GHz) used only for visualization in part (b).
        Both sliders update <b>all</b> plots live.
      </p>

      <div class="vizgrid">
        <div class="viz diagram">
          <header><h3>Diagram — Linear Resonator Geometry</h3></header>
          <canvas id="cDiagram"></canvas>
        </div>

        <div class="viz small">
          <header><h3>Secondary — Gain Sweep: Lifetime &amp; Linewidth at Line Center</h3></header>
          <canvas id="cSweep"></canvas>
        </div>

        <div class="viz" style="grid-column: 1 / -1;">
          <header><h3>Main — Transmission Spectrum Around ν₀ (Mode Comb + Gain Narrowing)</h3></header>
          <canvas id="cMain"></canvas>
        </div>
      </div>
    </section>
  </article>
</main>

<footer>
  <div>
    Notes: The spectrum-derived values assume the plotted linewidth corresponds to the cavity intensity FWHM.
    The “pumped-below-threshold” behavior is visualized with an example Gaussian gain profile; the key qualitative features (same mode spacing, narrower/taller peaks near line center)
    are robust for any smooth gain line shape.
  </div>
</footer>

<script>
(function(){
  // -----------------------------
  // Problem constants (from figure)
  // -----------------------------
  const c = 3.0e8;           // m/s
  const n = 1.0;             // given
  const FSR = 200e6;         // Hz (from figure)
  const dnu0 = 2e6;          // Hz (linewidth FWHM, from figure)
  const nu0 = 5e14;          // Hz (center optical freq, given)
  const L = c/(2*n*FSR);     // m
  const tau_ph = 1/(2*Math.PI*dnu0); // s
  const vg = c/n;            // m/s
  const g_th = 1/(vg*tau_ph);// 1/m

  // UI elements
  const gainSlider = document.getElementById('gainSlider');
  const gainLabel  = document.getElementById('gainLabel');
  const bwSlider   = document.getElementById('bwSlider');
  const bwLabel    = document.getElementById('bwLabel');
  const resetBtn   = document.getElementById('resetBtn');
  const readouts   = document.getElementById('readouts');

  // Canvases
  const cDiagram = document.getElementById('cDiagram');
  const cMain    = document.getElementById('cMain');
  const cSweep   = document.getElementById('cSweep');

  // High-DPI setup helper
  function setupCanvas(canvas){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(10, Math.floor(rect.width  * dpr));
    const h = Math.max(10, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
    }
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return {ctx, w: rect.width, h: rect.height, dpr};
  }

  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

  // Simple "nice" ticks
  function niceTicks(min, max, count){
    const span = max - min;
    if(span <= 0) return [min];
    const raw = span / Math.max(1,count);
    const pow = Math.pow(10, Math.floor(Math.log10(raw)));
    const candidates = [1,2,5,10].map(m => m*pow);
    let step = candidates[0];
    for(const s of candidates){
      if(raw <= s){ step = s; break; }
      step = s;
    }
    const start = Math.ceil(min/step)*step;
    const ticks = [];
    for(let v=start; v<=max+1e-12; v+=step) ticks.push(v);
    return ticks;
  }

  function drawGridAxes(ctx, x0,y0,w,h, xMin,xMax,yMin,yMax, xLabel,yLabel, title){
    // background
    ctx.save();
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = 'rgba(0,0,0,0)';
    ctx.fillRect(0,0,w,h);

    // title
    ctx.fillStyle = 'rgba(233,238,246,.92)';
    ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(title, x0, y0-10);

    // grid
    const xTicks = niceTicks(xMin, xMax, 6);
    const yTicks = niceTicks(yMin, yMax, 5);

    ctx.strokeStyle = 'rgba(255,255,255,.10)';
    ctx.lineWidth = 1;

    function X(x){ return x0 + (x-xMin)/(xMax-xMin)*w; }
    function Y(y){ return y0 + h - (y-yMin)/(yMax-yMin)*h; }

    // grid lines and tick labels
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillStyle = 'rgba(169,182,199,.85)';

    for(const xt of xTicks){
      const xx = X(xt);
      ctx.beginPath(); ctx.moveTo(xx,y0); ctx.lineTo(xx,y0+h); ctx.stroke();
      const txt = formatTick(xt);
      ctx.fillText(txt, xx-ctx.measureText(txt).width/2, y0+h+16);
    }
    for(const yt of yTicks){
      const yy = Y(yt);
      ctx.beginPath(); ctx.moveTo(x0,yy); ctx.lineTo(x0+w,yy); ctx.stroke();
      const txt = formatTick(yt);
      ctx.fillText(txt, x0-10-ctx.measureText(txt).width, yy+4);
    }

    // axes box
    ctx.strokeStyle = 'rgba(255,255,255,.18)';
    ctx.strokeRect(x0,y0,w,h);

    // labels
    ctx.fillStyle = 'rgba(169,182,199,.92)';
    ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(xLabel, x0 + w/2 - ctx.measureText(xLabel).width/2, y0+h+36);

    // y label (rotated)
    ctx.save();
    ctx.translate(x0-52, y0 + h/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
    ctx.restore();

    ctx.restore();

    return {X,Y};
  }

  function formatTick(v){
    // Display compact numbers with suffixes where helpful for our ranges.
    const av = Math.abs(v);
    if(av >= 1e9) return (v/1e9).toFixed((av/1e9<10)?1:0)+'G';
    if(av >= 1e6) return (v/1e6).toFixed((av/1e6<10)?1:0)+'M';
    if(av >= 1e3) return (v/1e3).toFixed((av/1e3<10)?1:0)+'k';
    if(av >= 1)   return (Math.abs(v)<10 ? v.toFixed(1) : v.toFixed(0));
    return v.toExponential(1);
  }

  // Lorentzian peak (normalized to 1 at center)
  function lorentzian(dnu, fwhm){
    const gamma = fwhm/2; // HWHM
    return 1/(1 + (dnu/gamma)*(dnu/gamma));
  }

  // Gain profile (example) Gaussian centered at 0 offset
  function gainProfile(dnu, sigmaHz){
    return Math.exp(-0.5*(dnu/sigmaHz)*(dnu/sigmaHz));
  }

  // Effective linewidth with gain fraction r0 at center:
  // 1/τ_eff(ν) = 1/τ_ph - v_g g(ν), with g(ν)=r0*g_th*G(ν)
  // => 1/τ_eff = 1/τ_ph * (1 - r0*G(ν))
  // => Δν_eff = Δν0 * (1 - r0*G(ν))  (since Δν ∝ 1/τ)
  // We clamp to avoid negative widths (below-threshold keeps it positive).
  function effectiveLinewidth(dnu, r0, sigmaHz){
    const G = gainProfile(dnu, sigmaHz);
    const factor = clamp(1 - r0*G, 0.02, 1.0); // keep finite for visualization
    return dnu0 * factor;
  }

  function effectiveTauAtOffset(dnu, r0, sigmaHz){
    const G = gainProfile(dnu, sigmaHz);
    const denom = clamp(1 - r0*G, 0.02, 1.0);
    return tau_ph / denom;
  }

  // Transmission spectrum model for visualization:
  // Sum of Lorentzian resonances spaced by FSR, with linewidth Δν_eff(ν)
  // and a modest peak-height boost when loss is reduced.
  function transmissionAtOffset(dnu, r0, sigmaHz){
    // choose modes around center
    const mMax = 8; // total peaks roughly 2*mMax+1 shown
    let T = 0;
    for(let m=-mMax; m<=mMax; m++){
      const center = m*FSR;
      const d = dnu - center;
      const fwhm = effectiveLinewidth(center, r0, sigmaHz); // linewidth depends on frequency via gain
      const peakBoost = 1 / (fwhm/dnu0); // smaller linewidth -> more buildup (visual cue)
      T += lorentzian(d, fwhm) * clamp(0.35*peakBoost, 0.6, 8.0);
    }
    // scale into [0,1] visually (not a strict physical normalization)
    return 1 - Math.exp(-0.22*T);
  }

  // -----------------------------
  // Draw diagram
  // -----------------------------
  function drawDiagram(){
    const {ctx, w, h} = setupCanvas(cDiagram);
    const pad = 14;
    ctx.clearRect(0,0,w,h);

    // Soft background
    const g = ctx.createLinearGradient(0,0,w,h);
    g.addColorStop(0,'rgba(106,228,255,.06)');
    g.addColorStop(1,'rgba(167,139,250,.06)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // Draw cavity line
    const y = h*0.58;
    const xL = pad + 40;
    const xR = w - pad - 40;

    // Mirrors
    function mirror(x, tilt){
      ctx.save();
      ctx.translate(x,y);
      ctx.rotate(tilt);
      ctx.strokeStyle = 'rgba(233,238,246,.85)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0,-34); ctx.lineTo(0,34);
      ctx.stroke();
      // hatch
      ctx.strokeStyle = 'rgba(233,238,246,.30)';
      ctx.lineWidth = 1;
      for(let i=-30;i<=30;i+=6){
        ctx.beginPath();
        ctx.moveTo(0,i); ctx.lineTo(10,i+10);
        ctx.stroke();
      }
      ctx.restore();
    }
    mirror(xL, 0);
    mirror(xR, 0);

    // Cavity axis
    ctx.strokeStyle = 'rgba(255,255,255,.25)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(xL, y);
    ctx.lineTo(xR, y);
    ctx.stroke();

    // Input beam arrow
    ctx.strokeStyle = 'rgba(106,228,255,.9)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(pad, y);
    ctx.lineTo(xL-6, y);
    ctx.stroke();
    arrowHead(ctx, xL-6, y, 0, 10, 'rgba(106,228,255,.9)');

    // Transmitted beam arrow
    ctx.strokeStyle = 'rgba(73,242,160,.9)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(xR+6, y);
    ctx.lineTo(w-pad, y);
    ctx.stroke();
    arrowHead(ctx, w-pad, y, 0, 10, 'rgba(73,242,160,.9)');

    // Labels
    ctx.fillStyle = 'rgba(233,238,246,.92)';
    ctx.font = '600 12.5px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText('Input (tunable) ν', pad+2, y-14);
    const tx = w-pad-110;
    ctx.fillText('Transmitted', tx, y-14);

    // Length bracket
    ctx.strokeStyle = 'rgba(255,255,255,.45)';
    ctx.lineWidth = 1.8;
    const by = y+44;
    ctx.beginPath();
    ctx.moveTo(xL, by); ctx.lineTo(xR, by);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(xL, by-8); ctx.lineTo(xL, by+8);
    ctx.moveTo(xR, by-8); ctx.lineTo(xR, by+8);
    ctx.stroke();
    ctx.fillStyle = 'rgba(169,182,199,.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    const Ltxt = `L = ${L.toFixed(2)} m`;
    ctx.fillText(Ltxt, (xL+xR)/2 - ctx.measureText(Ltxt).width/2, by+22);

    // Spectrum annotations
    ctx.fillStyle = 'rgba(169,182,199,.92)';
    ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText('FSR = 200 MHz', pad+6, pad+22);
    ctx.fillText('Linewidth Δν = 2 MHz', pad+6, pad+42);

    // draw small comb sketch in diagram corner
    const sx0 = w*0.62, sy0 = pad+16;
    ctx.strokeStyle = 'rgba(255,255,255,.18)';
    ctx.strokeRect(sx0, sy0, w*0.34, 62);
    ctx.strokeStyle = 'rgba(106,228,255,.7)';
    ctx.lineWidth = 2;
    for(let i=0;i<5;i++){
      const x = sx0 + 14 + i*(w*0.34-28)/4;
      ctx.beginPath();
      ctx.moveTo(x, sy0+55);
      ctx.lineTo(x, sy0+18 + (i===2?0:8));
      ctx.stroke();
    }
    ctx.fillStyle = 'rgba(233,238,246,.75)';
    ctx.font = '11px var(--mono)';
    ctx.fillText('T(ν): resonant peaks', sx0+10, sy0+14);
  }

  function arrowHead(ctx, x, y, ang, size, color){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(ang);
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(-size, -size*0.55);
    ctx.lineTo(-size,  size*0.55);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // -----------------------------
  // Draw main spectrum plot
  // -----------------------------
  function drawMain(){
    const {ctx, w, h} = setupCanvas(cMain);

    const left = 72, right = 16, top = 40, bottom = 58;
    const pw = w - left - right;
    const ph = h - top - bottom;

    const r0 = parseFloat(gainSlider.value);  // peak gain fraction at center
    const sigmaGHz = parseFloat(bwSlider.value);
    const sigmaHz = sigmaGHz * 1e9;

    // x range: show ± 1.4 GHz (about ±7 modes, since FSR=0.2 GHz)
    const xMin = -1.4e9;
    const xMax =  1.4e9;
    const yMin = 0;
    const yMax = 1.05;

    const axes = drawGridAxes(ctx, left, top, pw, ph, xMin, xMax, yMin, yMax,
      'Frequency offset Δν = ν − ν₀ (Hz; tick labels use k/M/G)', 'Transmittance T (arb. 0–1)',
      'Transmission vs Frequency (mode spacing = 200 MHz; gain narrows peaks near ν₀)'
    );

    // plot gain envelope (scaled for display)
    ctx.save();
    ctx.strokeStyle = 'rgba(167,139,250,.65)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6,4]);
    ctx.beginPath();
    const N = 700;
    for(let i=0;i<=N;i++){
      const x = xMin + (xMax-xMin)*i/N;
      const G = gainProfile(x, sigmaHz);
      const y = 0.08 + 0.20*G; // display band
      const X = axes.X(x), Y = axes.Y(y);
      if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
    }
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();

    // plot transmission
    ctx.save();
    ctx.strokeStyle = 'rgba(106,228,255,.95)';
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    for(let i=0;i<=N;i++){
      const x = xMin + (xMax-xMin)*i/N;
      const T = transmissionAtOffset(x, r0, sigmaHz);
      const X = axes.X(x), Y = axes.Y(T);
      if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
    }
    ctx.stroke();
    ctx.restore();

    // annotate FSR marker
    ctx.save();
    const markerY = axes.Y(0.92);
    const xA = axes.X(-FSR/2), xB = axes.X(FSR/2);
    ctx.strokeStyle = 'rgba(255,255,255,.55)';
    ctx.lineWidth = 1.8;
    ctx.beginPath();
    ctx.moveTo(xA, markerY);
    ctx.lineTo(xB, markerY);
    ctx.stroke();
    arrowHead(ctx, xA, markerY, Math.PI, 8, 'rgba(255,255,255,.55)');
    arrowHead(ctx, xB, markerY, 0, 8, 'rgba(255,255,255,.55)');
    ctx.fillStyle = 'rgba(233,238,246,.85)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    const fsrtxt = 'FSR = 200 MHz';
    ctx.fillText(fsrtxt, (xA+xB)/2 - ctx.measureText(fsrtxt).width/2, markerY-10);
    ctx.restore();

    // legend
    ctx.save();
    const lx = left + 10, ly = top + 10;
    ctx.fillStyle = 'rgba(0,0,0,.30)';
    ctx.strokeStyle = 'rgba(255,255,255,.16)';
    roundRect(ctx, lx, ly, 310, 52, 12);
    ctx.fill();
    ctx.stroke();

    // line samples
    ctx.strokeStyle = 'rgba(106,228,255,.95)';
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(lx+12, ly+18); ctx.lineTo(lx+56, ly+18); ctx.stroke();
    ctx.fillStyle = 'rgba(233,238,246,.90)';
    ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText('T(ν): cavity transmission (with sub-threshold gain)', lx+66, ly+22);

    ctx.strokeStyle = 'rgba(167,139,250,.65)';
    ctx.lineWidth = 3;
    ctx.setLineDash([7,4]);
    ctx.beginPath(); ctx.moveTo(lx+12, ly+38); ctx.lineTo(lx+56, ly+38); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(233,238,246,.80)';
    ctx.fillText('Example gain envelope (not to scale)', lx+66, ly+42);
    ctx.restore();
  }

  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // -----------------------------
  // Draw sweep plot: center lifetime/linewidth vs gain fraction
  // -----------------------------
  function drawSweep(){
    const {ctx, w, h} = setupCanvas(cSweep);

    const left = 76, right = 16, top = 40, bottom = 58;
    const pw = w - left - right;
    const ph = h - top - bottom;

    const sigmaGHz = parseFloat(bwSlider.value);
    const sigmaHz = sigmaGHz * 1e9;

    // We'll sweep r0 from 0 to 0.98 and plot:
    // τ_eff(0) = τ_ph/(1-r0)
    // Δν_eff(0) = Δν0*(1-r0)
    // Use two y axes? We'll instead plot normalized quantities to fit one axis cleanly:
    // y1 = τ_eff/τ_ph ; y2 = Δν_eff/Δν0
    const xMin = 0, xMax = 0.98;
    const yMin = 0, yMax = 6.0; // τ ratio can get big; clamp display

    const axes = drawGridAxes(ctx, left, top, pw, ph, xMin, xMax, yMin, yMax,
      'Gain fraction r₀ = g(ν₀)/g_th (dimensionless)', 'Normalized value (τ_eff/τ_ph and Δν_eff/Δν0)',
      'Parameter Sweep at Line Center (ν=ν₀): lifetime rises, linewidth shrinks'
    );

    // plot τ ratio
    ctx.save();
    ctx.strokeStyle = 'rgba(73,242,160,.92)';
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    const N = 420;
    for(let i=0;i<=N;i++){
      const r = xMin + (xMax-xMin)*i/N;
      const tauRatio = clamp(1/(1 - r), 0, 6.0);
      const X = axes.X(r);
      const Y = axes.Y(tauRatio);
      if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
    }
    ctx.stroke();
    ctx.restore();

    // plot linewidth ratio (scaled into same axis by mapping [0,1] into [0,1] region)
    // We'll actually plot it directly but on same axis: Δν_ratio ranges 0.02..1, so visible near bottom.
    ctx.save();
    ctx.strokeStyle = 'rgba(106,228,255,.92)';
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    for(let i=0;i<=N;i++){
      const r = xMin + (xMax-xMin)*i/N;
      const dnuRatio = clamp(1 - r, 0.02, 1.0);
      const X = axes.X(r);
      const Y = axes.Y(dnuRatio); // sits near bottom
      if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
    }
    ctx.stroke();
    ctx.restore();

    // mark current r0
    const r0 = parseFloat(gainSlider.value);
    ctx.save();
    const xMark = axes.X(r0);
    ctx.strokeStyle = 'rgba(255,255,255,.55)';
    ctx.lineWidth = 1.6;
    ctx.setLineDash([5,5]);
    ctx.beginPath();
    ctx.moveTo(xMark, top);
    ctx.lineTo(xMark, top+ph);
    ctx.stroke();
    ctx.setLineDash([]);

    // legend
    const lx = left + 10, ly = top + 10;
    ctx.fillStyle = 'rgba(0,0,0,.30)';
    ctx.strokeStyle = 'rgba(255,255,255,.16)';
    roundRect(ctx, lx, ly, 250, 54, 12);
    ctx.fill(); ctx.stroke();

    ctx.strokeStyle = 'rgba(73,242,160,.92)';
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(lx+12, ly+18); ctx.lineTo(lx+56, ly+18); ctx.stroke();
    ctx.fillStyle = 'rgba(233,238,246,.90)';
    ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText('τ_eff / τ_ph', lx+66, ly+22);

    ctx.strokeStyle = 'rgba(106,228,255,.92)';
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(lx+12, ly+38); ctx.lineTo(lx+56, ly+38); ctx.stroke();
    ctx.fillStyle = 'rgba(233,238,246,.80)';
    ctx.fillText('Δν_eff / Δν0', lx+66, ly+42);
    ctx.restore();
  }

  // -----------------------------
  // UI updates
  // -----------------------------
  function updateLabels(){
    const r0 = parseFloat(gainSlider.value);
    const sigmaGHz = parseFloat(bwSlider.value);

    gainLabel.textContent = `g/g_th = ${r0.toFixed(2)}`;
    bwLabel.textContent = `σ = ${sigmaGHz.toFixed(1)} GHz`;

    // center effective quantities
    const tauEff0 = tau_ph / clamp(1 - r0, 0.02, 1.0);
    const dnuEff0 = dnu0 * clamp(1 - r0, 0.02, 1.0);

    const ns = (tau_ph*1e9).toFixed(1);
    const nsEff = (tauEff0*1e9).toFixed(1);
    const MHz = (dnu0/1e6).toFixed(1);
    const MHzEff = (dnuEff0/1e6).toFixed(2);

    readouts.textContent =
      `τ_ph = ${ns} ns • Δν = ${MHz} MHz • FSR = ${(FSR/1e6).toFixed(0)} MHz • τ_eff(ν₀) ≈ ${nsEff} ns • Δν_eff(ν₀) ≈ ${MHzEff} MHz`;
  }

  function redrawAll(){
    updateLabels();
    drawDiagram();
    drawSweep();
    drawMain();
  }

  gainSlider.addEventListener('input', redrawAll);
  bwSlider.addEventListener('input', redrawAll);
  resetBtn.addEventListener('click', ()=>{
    gainSlider.value = "0.00";
    bwSlider.value = "1.2";
    redrawAll();
  });
  window.addEventListener('resize', ()=>{ redrawAll(); });

  // -----------------------------
  // Copy buttons
  // -----------------------------
  async function copyFromSelector(sel){
    const el = document.querySelector(sel);
    if(!el) return;
    const text = el.innerText.replace(/\u00a0/g,' ').trim();
    try{
      await navigator.clipboard.writeText(text);
      flashToast('Copied.');
    }catch(e){
      // Fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.style.position='fixed';
      ta.style.left='-9999px';
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      flashToast('Copied.');
    }
  }

  document.querySelectorAll('button.copy').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      copyFromSelector(btn.getAttribute('data-copy'));
    });
  });

  let toastTimer = null;
  function flashToast(msg){
    let toast = document.getElementById('toast');
    if(!toast){
      toast = document.createElement('div');
      toast.id='toast';
      toast.style.position='fixed';
      toast.style.right='14px';
      toast.style.bottom='14px';
      toast.style.padding='10px 12px';
      toast.style.borderRadius='14px';
      toast.style.border='1px solid rgba(255,255,255,.16)';
      toast.style.background='rgba(15,22,32,.88)';
      toast.style.backdropFilter='blur(10px)';
      toast.style.color='rgba(233,238,246,.95)';
      toast.style.font='600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      toast.style.boxShadow='0 18px 50px rgba(0,0,0,.35)';
      toast.style.zIndex='9999';
      toast.style.transform='translateY(6px)';
      toast.style.opacity='0';
      toast.style.transition='opacity .15s ease, transform .15s ease';
      document.body.appendChild(toast);
    }
    toast.textContent = msg;
    requestAnimationFrame(()=>{
      toast.style.opacity='1';
      toast.style.transform='translateY(0)';
    });
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>{
      toast.style.opacity='0';
      toast.style.transform='translateY(6px)';
    }, 900);
  }

  // Initial draw
  redrawAll();

  // Expose a few constants for debugging (optional)
  window.__laserRes = {c,n,FSR,dnu0,nu0,L,tau_ph,g_th};

})();
</script>

</body>
</html>
