<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Operation of a Cavity-Dumped Laser — Threshold, Inversion, Photon Density, Output Flux</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#0f1623;
      --card:#121c2d;
      --text:#e9eef7;
      --muted:#a9b6cc;
      --faint:#6f7f9a;
      --line:#22314d;
      --accent:#7bdcff;
      --accent2:#a7ff83;
      --warn:#ffcf6f;
      --bad:#ff6b8a;
      --good:#78ffb5;
      --shadow: 0 16px 40px rgba(0,0,0,.35);
      --radius:18px;
      --radius2:24px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(123,220,255,.12), transparent 60%),
        radial-gradient(900px 600px at 70% 30%, rgba(167,255,131,.10), transparent 60%),
        radial-gradient(900px 600px at 40% 85%, rgba(255,107,138,.08), transparent 55%),
        linear-gradient(180deg, #070a10 0%, #0b0f17 35%, #070a10 100%);
      overflow-x:hidden;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      position:relative;
      padding:36px 18px 18px;
      border-bottom:1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, rgba(18,28,45,.85), rgba(15,22,35,.35));
      overflow:hidden;
    }
    .wrap{max-width:1200px; margin:0 auto; padding:0 10px}
    .hero{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns:1fr}
    }
    h1{
      margin:0 0 10px;
      letter-spacing:.2px;
      line-height:1.15;
      font-size: clamp(26px, 3.2vw, 42px);
    }
    .sub{
      color:var(--muted);
      font-size: 15.5px;
      line-height:1.55;
      margin:0;
      max-width: 75ch;
    }
    .pillrow{display:flex; gap:10px; flex-wrap:wrap; margin-top:14px}
    .pill{
      font-size:12.5px;
      color:rgba(233,238,247,.9);
      background:rgba(123,220,255,.08);
      border:1px solid rgba(123,220,255,.20);
      padding:6px 10px;
      border-radius:999px;
      backdrop-filter: blur(8px);
    }
    .pill.alt{
      background:rgba(167,255,131,.08);
      border-color:rgba(167,255,131,.20);
    }
    .pill.warn{
      background:rgba(255,207,111,.08);
      border-color:rgba(255,207,111,.20);
    }

    main{padding:22px 18px 46px}
    .grid{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }

    /* Sticky TOC */
    nav.toc{
      position:sticky;
      top:12px;
      align-self:start;
      background: linear-gradient(180deg, rgba(18,28,45,.85), rgba(18,28,45,.55));
      border:1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      padding:14px 14px 10px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    nav.toc .toc-title{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .toc-title b{font-size:13px; letter-spacing:.2px}
    .toc small{color:var(--faint)}
    .toc a{
      display:block;
      padding:9px 10px;
      border-radius:12px;
      color:var(--muted);
      font-size:13.5px;
      border:1px solid transparent;
    }
    .toc a:hover{
      background:rgba(123,220,255,.08);
      border-color:rgba(123,220,255,.16);
      color:var(--text);
      text-decoration:none;
    }

    section{
      background: linear-gradient(180deg, rgba(18,28,45,.75), rgba(15,22,35,.55));
      border:1px solid rgba(255,255,255,.08);
      border-radius: var(--radius2);
      padding:18px 18px 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      margin-bottom:18px;
    }
    section h2{
      margin:2px 0 10px;
      font-size: 19.5px;
      letter-spacing:.2px;
    }
    section h3{
      margin:14px 0 8px;
      font-size: 16.5px;
      color: rgba(233,238,247,.95);
    }
    p{margin:10px 0; color:var(--muted); line-height:1.65}
    ul{margin:10px 0 10px 20px; color:var(--muted); line-height:1.6}
    li{margin:6px 0}
    .callouts{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:12px;
      margin-top:10px;
    }
    .callout{
      grid-column: span 6;
      background:rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      padding:12px 12px;
    }
    @media (max-width: 880px){ .callout{grid-column: span 12;} }
    .callout .tag{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:4px 9px;
      border-radius:999px;
      font-size:12px;
      letter-spacing:.15px;
      margin-bottom:8px;
      border:1px solid rgba(255,255,255,.10);
      color: rgba(233,238,247,.92);
      background: rgba(123,220,255,.08);
    }
    .callout .tag.warn{background: rgba(255,207,111,.08); border-color: rgba(255,207,111,.18)}
    .callout .tag.bad{background: rgba(255,107,138,.08); border-color: rgba(255,107,138,.18)}
    .callout .tag.good{background: rgba(120,255,181,.08); border-color: rgba(120,255,181,.18)}
    .callout p{margin:6px 0 0}

    .eq{
      position:relative;
      margin:10px 0;
      padding:12px 12px 12px 12px;
      border-radius:16px;
      background: rgba(123,220,255,.06);
      border:1px solid rgba(123,220,255,.16);
      overflow:hidden;
    }
    .eq pre{
      margin:0;
      font-family: var(--mono);
      font-size: 13px;
      line-height:1.45;
      color: rgba(233,238,247,.95);
      white-space: pre-wrap;
      word-break: break-word;
    }
    .copyBtn{
      position:absolute;
      top:10px;
      right:10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      color: rgba(233,238,247,.92);
      font-size:12px;
      padding:6px 9px;
      border-radius:12px;
      cursor:pointer;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
      user-select:none;
    }
    .copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(123,220,255,.10);
      border-color: rgba(123,220,255,.22);
    }
    .copyNote{
      font-size:12px;
      color: var(--faint);
      margin-top:6px;
    }

    figure{margin:0}
    .vizGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
      margin-top:10px;
    }
    .vizCard{
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 18px;
      padding:12px;
    }
    .vizHead{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      margin-bottom:8px;
    }
    .vizHead .title{
      font-size:13.5px;
      color: rgba(233,238,247,.95);
      letter-spacing:.15px;
      margin:0;
    }
    .vizHead .hint{
      font-size:12px;
      color: var(--faint);
      margin:0;
      text-align:right;
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(18,28,45,.35), rgba(10,14,22,.20));
      border: 1px solid rgba(255,255,255,.06);
    }
    .twoCol{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 980px){ .twoCol{grid-template-columns:1fr;} }

    .controls{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:12px;
      margin-top:10px;
    }
    .ctrl{
      grid-column: span 6;
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 16px;
      padding:12px 12px;
    }
    @media (max-width: 880px){ .ctrl{grid-column: span 12;} }
    label{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      font-size:13px;
      color: rgba(233,238,247,.92);
      margin-bottom:8px;
    }
    input[type="range"]{width:100%}
    select{
      width:100%;
      padding:10px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      color: rgba(233,238,247,.92);
      outline:none;
    }
    .mini{
      font-size:12px;
      color: var(--faint);
      margin-top:6px;
      line-height:1.45;
    }
    .btnRow{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
    .btn{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      color: rgba(233,238,247,.92);
      padding:9px 11px;
      border-radius: 14px;
      cursor:pointer;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
    }
    .btn:hover{
      transform: translateY(-1px);
      background: rgba(167,255,131,.10);
      border-color: rgba(167,255,131,.22);
    }

    .final{
      border:1px solid rgba(120,255,181,.22);
      background: rgba(120,255,181,.08);
    }
    .final h3{margin-top:0}
    .kicker{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(233,238,247,.85);
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.08);
      padding:8px 10px;
      border-radius: 14px;
      display:inline-block;
    }

    footer{
      padding:18px 18px 30px;
      color: var(--faint);
      text-align:center;
      border-top:1px solid rgba(255,255,255,.06);
    }

    /* Print */
    @media print{
      body{background:#fff; color:#000}
      nav.toc{display:none}
      section{box-shadow:none; backdrop-filter:none}
      canvas{border:1px solid #bbb}
      .copyBtn,.btn{display:none}
      a{color:#000; text-decoration:underline}
    }

    /* Subtle motion */
    @keyframes floatIn{
      from{transform: translateY(6px); opacity:.0}
      to{transform: translateY(0); opacity:1}
    }
    section{animation: floatIn .35s ease both}
  </style>
</head>
<body>
<header>
  <div class="wrap hero">
    <div>
      <h1>Operation of a Cavity-Dumped Laser: How <span style="color:var(--accent)">Loss</span>, <span style="color:var(--accent2)">Inversion</span>, and <span style="color:var(--warn)">Photons</span> Evolve Over Each Pulse</h1>
      <p class="sub">
        We will model and <b>sketch (and simulate)</b> how the <b>threshold population difference</b> <span class="kicker">N<sub>t</sub>(t)</span> (set by cavity loss),
        the actual <b>population difference</b> <span class="kicker">N(t)</span>,
        the <b>internal photon number density</b> <span class="kicker">n(t)</span>,
        and the <b>external photon flux density</b> <span class="kicker">&phi;<sub>o</sub>(t)</span>
        vary during <b>two cycles</b> of a pulsed cavity-dumped laser.
      </p>
      <div class="pillrow">
        <span class="pill">Pulsed lasers</span>
        <span class="pill alt">Rate-equation intuition</span>
        <span class="pill warn">Cavity dumping (Q-switch-like)</span>
      </div>
    </div>

    <div>
      <section style="margin:0; padding:14px 14px 12px;">
        <h2 style="margin:2px 0 8px;">Quick Summary</h2>
        <ul>
          <li><b>What this is about:</b> a cavity-dumped laser stores photons in a low-loss cavity, then <b>rapidly increases out-coupling</b> to eject a short, intense pulse.</li>
          <li><b>Key physics idea:</b> the <b>threshold inversion</b> tracks the cavity loss: <span class="kicker">N<sub>t</sub> ∝ loss</span>. When loss jumps up, threshold jumps up instantly.</li>
          <li><b>Governing model:</b> coupled rate equations for inversion and photon density with a <b>time-dependent cavity lifetime</b> (loss switching).</li>
          <li><b>Qualitative result:</b> during “store” time: <span class="kicker">n</span> builds and <span class="kicker">N</span> clamps near <span class="kicker">N<sub>t</sub></span>; during “dump”: <span class="kicker">N<sub>t</sub></span> spikes up, <span class="kicker">n</span> collapses fast, and <span class="kicker">&phi;<sub>o</sub></span> spikes outward.</li>
          <li><b>What you must sketch:</b> over two periods: step-like <span class="kicker">N<sub>t</sub>(t)</span>, sawtooth-like <span class="kicker">N(t)</span>, bursty <span class="kicker">n(t)</span>, and sharp pulses in <span class="kicker">&phi;<sub>o</sub>(t)</span>.</li>
          <li><b>Final result type:</b> symbolic relationships + a physically faithful <b>example simulation</b> for plotting/sketch guidance.</li>
        </ul>
      </section>
    </div>
  </div>
</header>

<main>
  <div class="wrap grid">
    <nav class="toc" aria-label="Table of Contents">
      <div class="toc-title">
        <b>Table of Contents</b>
        <small>sticky</small>
      </div>
      <a href="#p0">PART 0 — Concept Primer</a>
      <a href="#p1">PART 1 — Problem Analysis</a>
      <a href="#p2">PART 2 — Strategy & Tips</a>
      <a href="#p3">PART 3 — Full Solution</a>
      <a href="#p4">PART 4 — Deeper Understanding</a>
      <a href="#p5">PART 5 — Visualization Guide</a>
      <a href="#viz">Interactive Visualizations</a>
    </nav>

    <div>
      <section id="p0">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <h3>Core definitions (symbols + typical units)</h3>
        <ul>
          <li><b>Population difference (inversion):</b> <span class="kicker">N(t)</span> — difference between upper and lower laser-level populations per unit volume (m<sup>−3</sup>), or a normalized inversion in simplified models.</li>
          <li><b>Internal photon number density:</b> <span class="kicker">n(t)</span> — photons per unit volume inside the cavity mode (m<sup>−3</sup>) (often modeled in normalized units).</li>
          <li><b>External photon flux density:</b> <span class="kicker">&phi;<sub>o</sub>(t)</span> — photons per unit area per unit time leaving the cavity (m<sup>−2</sup> s<sup>−1</sup>), proportional to out-coupled photons.</li>
          <li><b>Cavity photon lifetime:</b> <span class="kicker">&tau;<sub>c</sub>(t)</span> (s) — average time a photon stays in the cavity before being lost (absorption + scattering + output coupling). Lower loss ⇢ larger lifetime.</li>
          <li><b>Threshold inversion:</b> <span class="kicker">N<sub>t</sub>(t)</span> — inversion required for net gain to balance cavity loss.</li>
        </ul>

        <h3>Physical meaning of the key quantities</h3>
        <p>
          A cavity-dumped laser is designed to separate <b>photon storage</b> from <b>photon extraction</b>.
          During storage, the cavity is “closed” (low output coupling, low loss), so <span class="kicker">n(t)</span> can build.
          During dumping, an electro-optic switch (e.g., Pockels cell + polarizer) makes the cavity “open” (high output coupling),
          so stored photons exit in a short pulse: <span class="kicker">&phi;<sub>o</sub>(t)</span> spikes.
        </p>

        <h3>Key laws/principles and validity</h3>
        <ul>
          <li><b>Laser rate equations</b> (class-B style): energy exchange between inversion and photons via stimulated emission.</li>
          <li><b>Threshold condition:</b> net gain equals loss. If gain < loss, photons decay; if gain > loss, photons grow.</li>
          <li><b>Time-dependent loss switching:</b> cavity dumping changes loss (or output coupling) much faster than the population lifetime, so loss can be treated as an abrupt step.</li>
        </ul>

        <div class="callouts">
          <div class="callout">
            <div class="tag">Assumption box</div>
            <p>
              We treat the cavity-dump switch as <b>instantaneously changing</b> the cavity photon lifetime
              from a “store” value <span class="kicker">&tau<sub>store</sub></span> to a “dump” value <span class="kicker">&tau<sub>dump</sub></span>.
              This is valid when the electro-optic switch time ≪ pulse build/dump times.
            </p>
          </div>
          <div class="callout">
            <div class="tag warn">Model choice</div>
            <p>
              For sketching, the essential feature is that <span class="kicker">N<sub>t</sub>(t)</span> follows the <b>loss</b>.
              A simple rate-equation model reproduces the correct qualitative waveforms without needing full Maxwell–Bloch theory.
            </p>
          </div>
        </div>

        <h3>Common models/approximations (and why we use them)</h3>
        <ul>
          <li><b>Single-mode approximation:</b> one dominant cavity mode; photon density described by one number <span class="kicker">n</span>.</li>
          <li><b>Uniform gain medium:</b> spatial hole burning ignored for a clean conceptual sketch.</li>
          <li><b>Phenomenological gain coefficient:</b> stimulated emission term proportional to <span class="kicker">N n</span>.</li>
          <li><b>Small spontaneous “seed” term:</b> prevents the model from staying exactly at <span class="kicker">n=0</span> numerically.</li>
        </ul>

        <h3>Mini intuition examples (no long algebra)</h3>
        <ul>
          <li><b>If you increase loss suddenly:</b> threshold inversion rises suddenly. If the actual inversion cannot jump instantly (populations change slowly), the laser goes below threshold and photons dump/decay rapidly.</li>
          <li><b>If you decrease loss suddenly:</b> threshold inversion drops. If inversion is already high, photon density grows explosively until inversion is pulled down (“clamped”) near threshold.</li>
        </ul>

        <h3>What to watch for (pitfalls)</h3>
        <ul>
          <li>Confusing <b>cavity dumping</b> with <b>Q-switching</b>: both involve loss control, but cavity dumping is specifically about <b>extracting stored intracavity photons</b> by increasing output coupling.</li>
          <li>Thinking inversion <span class="kicker">N</span> jumps instantly: it usually changes on the population lifetime/pump timescale, much slower than photon lifetime changes.</li>
          <li>Forgetting that <span class="kicker">&phi_o</span> is tied to <b>outcoupling</b>: during storage it can be tiny even if <span class="kicker">n</span> is large.</li>
        </ul>
      </section>

      <section id="p1">
        <h2>PART 1 — Problem Analysis (No solving yet)</h2>

        <h3>Problem restatement (in plain words)</h3>
        <p>
          You are asked to <b>sketch</b> how four time-dependent quantities behave during a <b>pulsed cavity-dumped laser</b>
          over <b>two full operating cycles</b>:
          the <b>threshold population difference</b> <span class="kicker">N<sub>t</sub>(t)</span> (proportional to cavity loss),
          the actual population difference <span class="kicker">N(t)</span>,
          the internal photon density <span class="kicker">n(t)</span>,
          and the external photon flux density <span class="kicker">&phi;<sub>o</sub>(t)</span>.
        </p>

        <h3>Given quantities</h3>
        <ul>
          <li>The laser is <b>cavity dumped</b> and <b>pulsed</b>: there is a repeating cycle with a “store” interval and a “dump” interval.</li>
          <li><span class="kicker">N<sub>t</sub></span> is proportional to <b>loss</b> (so it changes when the cavity outcoupling changes).</li>
        </ul>

        <h3>Unknowns / what must be found</h3>
        <ul>
          <li>Qualitative time traces (sketches) for <span class="kicker">N<sub>t</sub>(t)</span>, <span class="kicker">N(t)</span>, <span class="kicker">n(t)</span>, and <span class="kicker">&phi_o(t)</span> over <b>two periods</b>.</li>
          <li>Key features: step changes, clamping, pulse spikes, and recovery.</li>
        </ul>

        <h3>Relevant principles (and why they apply)</h3>
        <ul>
          <li><b>Threshold condition:</b> lasing requires gain to match loss, so threshold inversion must scale with loss.</li>
          <li><b>Timescale separation:</b> photons respond quickly (photon lifetime), inversion responds slowly (upper-state lifetime/pump).</li>
          <li><b>Cavity dumping mechanism:</b> outcoupling is deliberately increased briefly, causing stored photons to exit in a short burst.</li>
        </ul>

        <h3>Assumptions (explicit)</h3>
        <div class="callouts">
          <div class="callout">
            <div class="tag">Assumptions</div>
            <ul>
              <li>Single dominant cavity mode; photon density described by one number <span class="kicker">n</span>.</li>
              <li>Loss switching is fast: <span class="kicker">&tau_c(t)</span> changes as a step between two values.</li>
              <li>Inversion cannot change discontinuously; it changes smoothly under pump and stimulated emission.</li>
              <li>During storage, output coupling is low, so external flux is small even if intracavity power is high.</li>
            </ul>
          </div>
          <div class="callout">
            <div class="tag warn">What we are NOT doing</div>
            <p>
              We are not fitting a specific experimental device. The goal is the <b>correct qualitative waveform shapes</b>.
              Any numerical values used later are <b>example values</b> to generate consistent plots.
            </p>
          </div>
        </div>

        <h3>Possible approaches (2–3) and comparison</h3>
        <ul>
          <li><b>(A) Pure qualitative timescale argument</b>: fastest (best for sketch exams), emphasizes step-like <span class="kicker">N_t</span>, fast photon dump, slow inversion recovery. <i>Pros:</i> minimal math. <i>Cons:</i> less precise shapes.</li>
          <li><b>(B) Piecewise rate-equation reasoning</b>: write rate equations, analyze “store” vs “dump” intervals. <i>Pros:</i> physically grounded, still manageable. <i>Cons:</i> some algebra.</li>
          <li><b>(C) Numerical simulation of rate equations</b>: generate plots that guide the sketch. <i>Pros:</i> clear waveforms and parameter effects. <i>Cons:</i> needs computation.</li>
        </ul>

        <p>
          <b>Best approach here:</b> combine (B) and (C): we will derive the key relationships symbolically,
          then use a minimal numerical model to visualize the shapes over two cycles (exactly what a “sketch” should look like).
        </p>
      </section>

      <section id="p2">
        <h2>PART 2 — Strategy & Tips (Roadmap only)</h2>

        <ol style="color:var(--muted); line-height:1.65; margin:10px 0 10px 20px;">
          <li>
            <b>Identify the two phases of each cycle</b> (store vs dump).<br/>
            <span class="mini">Tool: physical description of cavity dumping.</span><br/>
            <span class="mini">Meaning: loss is low most of the time, then high briefly.</span>
          </li>
          <li>
            <b>Relate threshold inversion to loss</b> via photon lifetime <span class="kicker">&tau_c</span>.<br/>
            <span class="mini">Tool: threshold condition (gain = loss).</span><br/>
            <span class="mini">Meaning: <span class="kicker">N_t</span> steps when loss steps.</span>
          </li>
          <li>
            <b>Write minimal rate equations</b> for <span class="kicker">N</span> and <span class="kicker">n</span> with time-dependent loss.<br/>
            <span class="mini">Tool: coupled differential equations.</span><br/>
            <span class="mini">Meaning: photons respond quickly, inversion slowly.</span>
          </li>
          <li>
            <b>Analyze the store interval</b>: if pump drives <span class="kicker">N</span> above <span class="kicker">N_t</span>, photons grow and <span class="kicker">N</span> clamps near threshold.<br/>
            <span class="mini">Meaning: intracavity photon density builds.</span>
          </li>
          <li>
            <b>Analyze the dump interval</b>: loss ↑ ⇒ <span class="kicker">N_t</span> ↑ instantly; typically <span class="kicker">N</span> cannot follow, so gain < loss and photons decay quickly; outcoupling converts that decay into external flux pulse.<br/>
            <span class="mini">Meaning: big spike in <span class="kicker">&phi_o</span>.</span>
          </li>
          <li>
            <b>Repeat over two cycles</b> to show periodic behavior (build, dump, recover).<br/>
            <span class="mini">Meaning: sketches must show repeating pattern.</span>
          </li>
          <li>
            <b>Sanity-check shapes</b>: <span class="kicker">N_t</span> step-like; <span class="kicker">n</span> rises then drops sharply; <span class="kicker">&phi_o</span> pulsed; <span class="kicker">N</span> sawtooth/clamped then recovers.<br/>
            <span class="mini">Common mistake: drawing <span class="kicker">N</span> jumping at switch time.</span>
          </li>
        </ol>

        <div class="callouts">
          <div class="callout">
            <div class="tag bad">Common mistakes</div>
            <ul>
              <li>Drawing <span class="kicker">&phi_o</span> large during storage (it should be small if cavity is “closed”).</li>
              <li>Not showing <span class="kicker">N_t</span> as a step (loss switching is abrupt).</li>
              <li>Making <span class="kicker">n(t)</span> decay slowly during dump (dump is fast: photon lifetime is short).</li>
            </ul>
          </div>
          <div class="callout">
            <div class="tag good">Quick tips</div>
            <ul>
              <li>Use two timescales on your sketch: slow pump recovery for <span class="kicker">N</span>, fast cavity decay for <span class="kicker">n</span>.</li>
              <li>During store: <span class="kicker">N</span> is pulled toward <span class="kicker">N_t(store)</span> once lasing starts (gain clamping).</li>
              <li>During dump: <span class="kicker">N_t</span> jumps up; <span class="kicker">n</span> collapses; <span class="kicker">&phi_o</span> spikes.</li>
            </ul>
          </div>
        </div>
      </section>

      <section id="p3">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Physical intuition first (qualitative expectations)</h3>
        <p>
          A cavity-dumped laser runs like this each cycle:
        </p>
        <ul>
          <li><b>Store phase (low loss):</b> the cavity keeps photons inside. Pumping builds inversion <span class="kicker">N</span>. Once gain exceeds loss, photons grow and stimulated emission pulls <span class="kicker">N</span> down so it stays near the (low) threshold <span class="kicker">N_t</span>. Intracavity photon density <span class="kicker">n</span> builds to a large value.</li>
          <li><b>Dump phase (high outcoupling / high loss):</b> the cavity is briefly “opened.” Loss increases suddenly, so the threshold inversion <span class="kicker">N_t</span> jumps up. The actual inversion <span class="kicker">N</span> cannot jump; therefore the laser becomes below threshold and photons are depleted rapidly. Those photons leave the cavity, producing a sharp pulse in <span class="kicker">&phi_o</span>.</li>
        </ul>

        <h3>Step 1 — Threshold inversion tracks loss</h3>
        <p>
          In a simple single-mode description, photon density grows if (gain − loss) is positive and decays if it is negative.
          Let the stimulated emission contribution to photon growth be proportional to <span class="kicker">g N</span>, where <span class="kicker">g</span> is an effective coupling coefficient.
          Let cavity loss be represented by the photon decay rate <span class="kicker">1/&tau_c(t)</span>.
        </p>

        <div class="eq" id="eq1">
          <button class="copyBtn" data-copy-target="eq1">Copy</button>
          <pre>
Photon (field energy) balance, minimal form:
dn/dt = ( g N(t) - 1/τc(t) ) n(t) + (seed term)

Threshold condition (marginal dn/dt ≈ 0 for small n):
g Nt(t) = 1/τc(t)

⇒ Nt(t) = 1 / ( g τc(t) )
          </pre>
          <div class="copyNote">This is the key reason <b>N<sub>t</sub>(t)</b> steps when the cavity loss/outcoupling is switched.</div>
        </div>

        <p>
          So if cavity dumping changes the cavity lifetime between two values:
          <span class="kicker">&tau_c(t)=&tau_{store}</span> (low loss) and <span class="kicker">&tau_c(t)=&tau_{dump}</span> (high loss),
          then <span class="kicker">N_t(t)</span> is piecewise constant with step changes:
        </p>

        <div class="eq" id="eq2">
          <button class="copyBtn" data-copy-target="eq2">Copy</button>
          <pre>
Nt(store) = 1 / ( g τstore )   (low threshold)
Nt(dump)  = 1 / ( g τdump  )   (high threshold; because τdump << τstore)
          </pre>
        </div>

        <h3>Step 2 — Minimal coupled rate equations for N(t) and n(t)</h3>
        <p>
          A standard (phenomenological) pair of equations capturing pumping, relaxation, and stimulated emission is:
        </p>

        <div class="eq" id="eq3">
          <button class="copyBtn" data-copy-target="eq3">Copy</button>
          <pre>
Inversion (population difference) dynamics:
dN/dt = (R - N)/T1  -  g N n

Photon density dynamics (with time-dependent cavity lifetime):
dn/dt = ( g N - 1/τc(t) ) n  +  β N/T1
          </pre>
          <div class="copyNote">
            Symbols: R = pump-set inversion level (same units as N), T1 = upper-state lifetime, β = spontaneous-seed fraction (small),
            τc(t) = cavity photon lifetime controlled by the dump switch.
          </div>
        </div>

        <p>
          <b>What we did and why:</b>
          <span class="kicker">(R - N)/T1</span> makes <span class="kicker">N</span> relax toward a pump-determined level <span class="kicker">R</span>;
          <span class="kicker">- g N n</span> removes inversion via stimulated emission;
          <span class="kicker">(gN - 1/τc) n</span> controls photon growth/decay; the small <span class="kicker">βN/T1</span> term provides a seed.
        </p>

        <h3>Step 3 — Qualitative waveform during the store phase</h3>
        <p>
          During store, <span class="kicker">τc = τstore</span> is relatively large ⇒ loss is low ⇒ <span class="kicker">N_t</span> is small.
          Pumping drives <span class="kicker">N</span> upward; once <span class="kicker">N > N_t(store)</span>, the photon equation has positive net gain and <span class="kicker">n</span> rises quickly.
          As <span class="kicker">n</span> rises, the stimulated term <span class="kicker">g N n</span> pulls <span class="kicker">N</span> back down.
          The result is <b>gain clamping</b>: <span class="kicker">N(t)</span> hovers near <span class="kicker">N_t(store)</span> while <span class="kicker">n(t)</span> builds.
        </p>

        <h3>Step 4 — Qualitative waveform during the dump phase</h3>
        <p>
          During dump, the switch makes <span class="kicker">τc = τdump</span> much smaller (loss/outcoupling much larger).
          By the threshold relation <span class="kicker">N_t = 1/(gτc)</span>, <span class="kicker">N_t</span> jumps upward instantly.
          The inversion <span class="kicker">N</span> cannot jump on that short timescale, so typically <span class="kicker">N &lt; N_t(dump)</span> right after switching.
          Therefore the net gain becomes negative and <span class="kicker">n(t)</span> decays rapidly (timescale ~ <span class="kicker">τdump</span>).
        </p>
        <p>
          The external output flux density is proportional to outcoupling times intracavity photon density. A simple proportionality is:
        </p>

        <div class="eq" id="eq4">
          <button class="copyBtn" data-copy-target="eq4">Copy</button>
          <pre>
External photon flux density (conceptual):
φo(t) ∝ κout(t) · n(t)

where κout(t) is small during store and large during dump.
          </pre>
        </div>

        <p>
          So during dump, even though <span class="kicker">n(t)</span> is dropping, <span class="kicker">κout</span> is large, producing a <b>sharp pulse</b> in <span class="kicker">φo(t)</span>.
        </p>

        <h3>Step 5 — What the sketch must look like over <i>two cycles</i></h3>
        <div class="callouts">
          <div class="callout">
            <div class="tag">N<sub>t</sub>(t)</div>
            <p>
              Piecewise constant with <b>step up</b> during dump and <b>step down</b> back to store.
              Since it is proportional to loss, it mirrors the loss waveform.
            </p>
          </div>
          <div class="callout">
            <div class="tag">N(t)</div>
            <p>
              Slow evolution: rises under pumping when below threshold, then gets <b>clamped near N<sub>t</sub>(store)</b> while photons build.
              During dump, stimulated emission is short-lived (photons vanish), so <b>N tends to recover upward</b> afterward (pump dominates).
            </p>
          </div>
          <div class="callout">
            <div class="tag">n(t)</div>
            <p>
              Builds during store (fast rise once threshold is crossed), then shows a <b>rapid collapse</b> during dump
              (photon lifetime becomes short). Repeats in the second cycle.
            </p>
          </div>
          <div class="callout">
            <div class="tag warn">&phi;<sub>o</sub>(t)</div>
            <p>
              Small during store (low outcoupling), then a <b>sharp output pulse</b> during dump
              (high outcoupling × remaining intracavity photons). Repeats each cycle.
            </p>
          </div>
        </div>

        <section class="final" style="margin-top:14px;">
          <h3>Final Answer (what you should sketch)</h3>
          <div class="eq" id="eqFinal">
            <button class="copyBtn" data-copy-target="eqFinal">Copy</button>
            <pre>
Over each period T (repeat twice):

1) Threshold inversion Nt(t) ∝ loss:
   Nt(t) = 1/(g τc(t))  ⇒ Nt is LOW during store (τc=τstore),
                          Nt is HIGH during dump  (τc=τdump << τstore).
   So Nt(t) is a rectangular step waveform (low → high → low).

2) Inversion N(t):
   - rises slowly under pumping when photons are absent/small,
   - then clamps near Nt(store) once lasing builds photons,
   - during dump, photons disappear quickly, so N cannot follow the Nt jump and then recovers upward afterward.
   Result: a slow, smooth “sawtooth/clamped” curve repeating each cycle.

3) Intracavity photon density n(t):
   - grows during store once N exceeds Nt(store),
   - then is rapidly depleted during dump (fast decay with τdump).
   Result: large build-up followed by a sharp drop, repeating each cycle.

4) Output photon flux φo(t):
   φo(t) ∝ κout(t) n(t), with κout small in store and large in dump.
   Result: near-zero baseline during store and a sharp pulse during dump, repeating each cycle.
            </pre>
          </div>

          <p style="margin:8px 0 0; color:var(--muted)">
            <b>Sanity checks:</b> (i) <span class="kicker">N_t</span> steps instantly (loss can switch fast), (ii) <span class="kicker">N</span> stays smooth (populations change slowly),
            (iii) <span class="kicker">n</span> changes fast (photons respond quickly), (iv) <span class="kicker">&phi_o</span> pulses only when outcoupling is high.
          </p>
        </section>

        <h3>Connecting the result to the diagram & plots</h3>
        <p>
          In the diagram below, the electro-optic switch toggles the cavity between a <b>high-Q storage state</b> and a <b>dump (high outcoupling) state</b>.
          In the plots, this appears as a step in <span class="kicker">N_t(t)</span>, a fast depletion of <span class="kicker">n(t)</span>, and an output pulse in <span class="kicker">&phi_o(t)</span>.
          The inversion <span class="kicker">N(t)</span> responds more slowly and typically recovers between dumps.
        </p>
      </section>

      <section id="p4">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpreting the key formulas</h3>
        <p>
          The most important relationship is:
          <span class="kicker">N_t(t)=1/(gτ_c(t))</span>.
          It tells you that <b>threshold is not an intrinsic constant</b>—it is set by cavity loss (photon lifetime).
          Cavity dumping works because you can <b>change the threshold instantly</b> by changing the loss.
        </p>
        <ul>
          <li><b>Larger store lifetime</b> <span class="kicker">τstore</span> ⇒ smaller threshold ⇒ easier to build intracavity photons.</li>
          <li><b>Smaller dump lifetime</b> <span class="kicker">τdump</span> ⇒ larger threshold ⇒ photons are forced to disappear quickly (and exit as a pulse if outcoupled).</li>
          <li><b>Dump fraction</b> (how long you keep the cavity “open”) controls pulse extraction completeness and repetition behavior.</li>
        </ul>

        <h3>How changing parameters affects the outcome (matches the interactive plots)</h3>
        <ul>
          <li><b>Increase dump duration fraction</b> ⇒ more time to extract photons ⇒ larger extracted pulse energy up to saturation (after photons are depleted, extra dump time adds little).</li>
          <li><b>Increase dump coupling strength</b> (more loss/outcoupling) ⇒ sharper, taller output pulse but potentially less time for inversion to be depleted by stimulated emission (depends on regime).</li>
          <li><b>Increase pump level</b> ⇒ inversion recovers faster and can support larger intracavity build-up before each dump.</li>
        </ul>

        <h3>Alternative derivation idea (brief)</h3>
        <p>
          Instead of rate equations, you can start from a round-trip gain/loss condition:
          per cavity round trip, intensity multiplies by <span class="kicker">exp(2gL)</span> and is reduced by total loss <span class="kicker">exp(-2αL)</span>.
          Threshold is when these balance, yielding a threshold gain coefficient proportional to loss.
          Converting that to inversion (via gain–inversion proportionality) reproduces <span class="kicker">N_t ∝ loss</span>.
        </p>

        <h3>Concept check (self-test)</h3>
        <ul>
          <li><b>Q:</b> Why does <span class="kicker">N_t</span> jump but <span class="kicker">N</span> does not? <b>A:</b> Loss (optics) can switch fast; populations change on slower relaxation/pump timescales.</li>
          <li><b>Q:</b> Why is <span class="kicker">&phi_o</span> small during storage? <b>A:</b> Outcoupling is intentionally low; photons remain inside the cavity.</li>
          <li><b>Q:</b> What causes <span class="kicker">n</span> to drop rapidly during dump? <b>A:</b> Photon lifetime becomes short (loss high), making net gain negative.</li>
          <li><b>Q:</b> What sets repetition behavior? <b>A:</b> The balance of pump recovery of <span class="kicker">N</span> versus how completely each dump depletes <span class="kicker">n</span>.</li>
        </ul>
      </section>

      <section id="p5">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>
        <h3>What each canvas shows</h3>
        <ul>
          <li><b>Diagram canvas:</b> a simplified cavity-dumped laser: gain medium, mirrors, Pockels cell, polarizer/output coupler, and the “store vs dump” switch logic.</li>
          <li><b>Main plot:</b> time traces over <b>two cycles</b> of <span class="kicker">N_t(t)</span>, <span class="kicker">N(t)</span>, <span class="kicker">n(t)</span>, and <span class="kicker">&phi_o(t)</span> using consistent example parameters.</li>
          <li><b>Secondary plot (parameter sweep):</b> extracted pulse energy per cycle vs <b>dump duration fraction</b>. The current slider setting is highlighted.</li>
        </ul>

        <h3>Interactive controls</h3>
        <ul>
          <li><b>Dump fraction slider</b> changes how long the cavity is in the dump (high-loss) state each period.
            You should see: wider output pulses, lower leftover intracavity photons, and a change in extracted energy on the sweep plot.</li>
          <li><b>Dump coupling selector</b> changes how strongly the cavity is opened during dump (effectively reducing <span class="kicker">τdump</span> and increasing outcoupling).
            You should see: sharper/faster photon depletion and taller output spikes.</li>
          <li><b>“Reset to example”</b> returns to a clean illustrative regime.</li>
        </ul>

        <p class="mini">
          Note: The plotted values are <b>normalized example units</b> designed to match the qualitative physics of a cavity-dumped laser.
          Your exam sketch should match the <b>shapes and relative timing</b>, not these specific numbers.
        </p>
      </section>

      <section id="viz">
        <h2>Interactive Visualizations</h2>

        <div class="controls" aria-label="Interactive controls">
          <div class="ctrl">
            <label for="dumpFrac">
              <span>Dump duration fraction <span class="kicker">f = T<sub>dump</sub>/T</span></span>
              <span class="kicker" id="dumpFracVal">0.12</span>
            </label>
            <input id="dumpFrac" type="range" min="0.03" max="0.35" step="0.01" value="0.12" />
            <div class="mini">
              Larger <span class="kicker">f</span> means the cavity stays “open” longer each cycle. Expect longer extraction, up to saturation once intracavity photons are depleted.
            </div>
          </div>

          <div class="ctrl">
            <label for="dumpStrength">
              <span>Dump coupling strength</span>
              <span class="kicker" id="dumpStrengthVal">Strong</span>
            </label>
            <select id="dumpStrength">
              <option value="mild">Mild (less opening)</option>
              <option value="strong" selected>Strong</option>
              <option value="extreme">Extreme (very open)</option>
            </select>
            <div class="mini">
              Stronger dumping reduces photon lifetime during dump (<span class="kicker">τdump</span>) and increases outcoupling (<span class="kicker">κout</span>), sharpening the output pulse.
            </div>
          </div>

          <div class="ctrl" style="grid-column: span 12;">
            <div class="btnRow">
              <button class="btn" id="resetBtn">Reset to example</button>
              <button class="btn" id="toggleLegendBtn">Toggle legend</button>
            </div>
            <div class="mini">
              All plots update live and remain consistent with the symbols used in the text:
              <span class="kicker">N(t)</span>, <span class="kicker">N<sub>t</sub>(t)</span>, <span class="kicker">n(t)</span>, <span class="kicker">&phi;<sub>o</sub>(t)</span>.
            </div>
          </div>
        </div>

        <div class="vizGrid">
          <div class="vizCard">
            <div class="vizHead">
              <p class="title">Diagram — Cavity-Dumped Laser Setup (Conceptual)</p>
              <p class="hint">Labeled components • store vs dump</p>
            </div>
            <canvas id="cDiagram" aria-label="Cavity-dumped laser diagram"></canvas>
          </div>

          <div class="vizCard">
            <div class="vizHead">
              <p class="title">Main Plot — Two Cycles: N<sub>t</sub>(t), N(t), n(t), and &phi;<sub>o</sub>(t)</p>
              <p class="hint">Normalized example units • time in ms</p>
            </div>
            <canvas id="cMain" aria-label="Time traces plot"></canvas>
          </div>

          <div class="vizCard">
            <div class="vizHead">
              <p class="title">Secondary Plot — Pulse Energy per Cycle vs Dump Fraction f</p>
              <p class="hint">Parameter sweep • marker shows current f</p>
            </div>
            <canvas id="cSweep" aria-label="Parameter sweep plot"></canvas>
          </div>
        </div>
      </section>

    </div>
  </div>
</main>

<footer>
  Built as a self-contained learning article (vanilla HTML/CSS/JS). Copy equations with the buttons above and use the plots to guide your sketch.
</footer>

<script>
/* =========================
   Utilities: copy buttons
   ========================= */
(function(){
  function copyText(text){
    navigator.clipboard.writeText(text).then(()=>{},()=>{});
  }
  document.querySelectorAll(".copyBtn").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const id = btn.getAttribute("data-copy-target");
      const el = document.getElementById(id);
      if(!el) return;
      const pre = el.querySelector("pre");
      const txt = pre ? pre.innerText.trim() : el.innerText.trim();
      copyText(txt);
      const old = btn.textContent;
      btn.textContent = "Copied!";
      setTimeout(()=>btn.textContent = old, 900);
    });
  });
})();

/* =========================
   Canvas helpers (HiDPI)
   ========================= */
function fitCanvas(canvas, targetCSSHeight){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const cssW = rect.width;
  const cssH = targetCSSHeight || rect.height;
  canvas.style.height = cssH + "px";
  canvas.width = Math.max(2, Math.floor(cssW * dpr));
  canvas.height = Math.max(2, Math.floor(cssH * dpr));
  const ctx = canvas.getContext("2d");
  ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  return {ctx, w: cssW, h: cssH, dpr};
}

function lerp(a,b,t){ return a + (b-a)*t; }
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

/* =========================
   Minimal rate-equation model
   (normalized example units)
   =========================
   Time unit: ms
   N, n: normalized
*/
const model = {
  // base example parameters (chosen ONLY for plotting)
  T: 1.0,           // period [ms]
  T1: 1.0,          // inversion lifetime [ms]
  g: 80.0,          // coupling [1/(ms * n_unit)]
  R: 1.5,           // pump-set inversion level (normalized)
  beta: 2e-4,       // spontaneous seed fraction
  tauStore: 0.05,   // cavity photon lifetime during store [ms]
  tauDump_mild: 0.012,
  tauDump_strong: 0.006,
  tauDump_extreme: 0.003,
  koutStore: 0.03,  // outcoupling factor during store (small)
  koutDump_mild: 0.45,
  koutDump_strong: 0.75,
  koutDump_extreme: 0.95
};

function getDumpParams(strength){
  if(strength==="mild"){
    return {tauDump: model.tauDump_mild, koutDump: model.koutDump_mild};
  } else if(strength==="extreme"){
    return {tauDump: model.tauDump_extreme, koutDump: model.koutDump_extreme};
  }
  return {tauDump: model.tauDump_strong, koutDump: model.koutDump_strong};
}

function simulateTwoCycles(fDump, strength){
  const T = model.T;
  const total = 2*T;
  const dt = 0.0004; // ms (0.4 µs if 1 ms unit) good resolution for sharp dumps
  const steps = Math.floor(total/dt)+1;

  const {tauDump, koutDump} = getDumpParams(strength);
  const tauStore = model.tauStore;

  // Pre-allocate arrays
  const tArr = new Float32Array(steps);
  const NtArr = new Float32Array(steps);
  const NArr = new Float32Array(steps);
  const nArr = new Float32Array(steps);
  const phiArr = new Float32Array(steps);

  // initial conditions
  let N = 0.2;
  let n = 1e-6;

  function inDump(t){
    // dump is the LAST fraction fDump of each period
    const phase = t % T;
    return phase >= (1.0 - fDump)*T;
  }

  for(let i=0;i<steps;i++){
    const t = i*dt;
    const dump = inDump(t);
    const tauC = dump ? tauDump : tauStore;
    const kout = dump ? koutDump : model.koutStore;

    const Nt = 1.0/(model.g * tauC);

    // Rate equations (Euler)
    const dN = (model.R - N)/model.T1 - model.g * N * n;
    const dn = (model.g * N - 1.0/tauC) * n + model.beta * N / model.T1;

    // Update
    N = N + dN*dt;
    n = n + dn*dt;

    // Keep non-negative
    N = Math.max(0, N);
    n = Math.max(0, n);

    // External photon flux density (normalized)
    const phi = kout * (1.0/tauC) * n; // proportional to outcoupling * decay rate * stored photons

    tArr[i]=t;
    NtArr[i]=Nt;
    NArr[i]=N;
    nArr[i]=n;
    phiArr[i]=phi;
  }

  return {tArr, NtArr, NArr, nArr, phiArr, dt};
}

function pulseEnergyPerCycle(fDump, strength){
  // integrate phi over ONE cycle after transient: simulate 2 cycles and integrate second cycle
  const sim = simulateTwoCycles(fDump, strength);
  const T = model.T;
  let E = 0;
  const {tArr, phiArr, dt} = sim;
  for(let i=0;i<tArr.length;i++){
    const t = tArr[i];
    if(t >= T && t < 2*T){
      E += phiArr[i]*dt; // normalized energy per area (since phi is flux density)
    }
  }
  return E;
}

/* =========================
   Plotting primitives
   ========================= */
function drawAxes(ctx, x0,y0,w,h, xLabel, yLabel, title){
  // Panel background inside axes already via canvas
  // Frame
  ctx.save();
  ctx.lineWidth = 1;
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.strokeRect(x0,y0,w,h);

  // Title
  ctx.fillStyle = "rgba(233,238,247,0.95)";
  ctx.font = "12.5px " + getComputedStyle(document.body).fontFamily;
  ctx.fillText(title, x0, y0-10);

  // Labels
  ctx.fillStyle = "rgba(169,182,204,0.95)";
  ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
  ctx.fillText(xLabel, x0 + w - ctx.measureText(xLabel).width, y0 + h + 28);

  // y label rotated
  ctx.translate(x0-32, y0 + h/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
  ctx.restore();
}

function drawGrid(ctx, x0,y0,w,h, nx, ny){
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  ctx.lineWidth = 1;
  for(let i=1;i<nx;i++){
    const x = x0 + (i/nx)*w;
    ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+h); ctx.stroke();
  }
  for(let j=1;j<ny;j++){
    const y = y0 + (j/ny)*h;
    ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+w,y); ctx.stroke();
  }
  ctx.restore();
}

function drawTicks(ctx, x0,y0,w,h, xMin,xMax,yMin,yMax, nx, ny){
  ctx.save();
  ctx.fillStyle = "rgba(169,182,204,0.9)";
  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.lineWidth = 1;
  ctx.font = "11px " + getComputedStyle(document.body).fontFamily;

  // x ticks
  for(let i=0;i<=nx;i++){
    const t = i/nx;
    const x = x0 + t*w;
    ctx.beginPath(); ctx.moveTo(x,y0+h); ctx.lineTo(x,y0+h+5); ctx.stroke();
    const val = lerp(xMin,xMax,t);
    const label = (Math.round(val*100)/100).toString();
    ctx.fillText(label, x-ctx.measureText(label).width/2, y0+h+18);
  }
  // y ticks
  for(let j=0;j<=ny;j++){
    const t = j/ny;
    const y = y0 + (1-t)*h;
    ctx.beginPath(); ctx.moveTo(x0-5,y); ctx.lineTo(x0,y); ctx.stroke();
    const val = lerp(yMin,yMax,t);
    const label = (Math.round(val*100)/100).toString();
    ctx.fillText(label, x0-10-ctx.measureText(label).width, y+4);
  }
  ctx.restore();
}

function plotLine(ctx, x0,y0,w,h, xArr, yArr, xMin,xMax,yMin,yMax, strokeStyle, lineWidth){
  ctx.save();
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = lineWidth || 2;
  ctx.beginPath();
  let started = false;
  for(let i=0;i<xArr.length;i++){
    const xVal = xArr[i], yVal = yArr[i];
    if(xVal < xMin || xVal > xMax) continue;
    const X = x0 + ( (xVal - xMin)/(xMax-xMin) ) * w;
    const Y = y0 + ( 1 - ( (yVal - yMin)/(yMax-yMin) ) ) * h;
    if(!started){ ctx.moveTo(X,Y); started=true; }
    else ctx.lineTo(X,Y);
  }
  ctx.stroke();
  ctx.restore();
}

function legend(ctx, items, x, y){
  ctx.save();
  ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
  ctx.fillStyle = "rgba(233,238,247,0.95)";
  const pad = 10;
  const rowH = 18;
  const w = 8;
  let maxW = 0;
  items.forEach(it=>{
    maxW = Math.max(maxW, ctx.measureText(it.label).width);
  });
  const boxW = pad*2 + 18 + maxW;
  const boxH = pad*2 + rowH*items.length;
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  roundRect(ctx, x, y, boxW, boxH, 12);
  ctx.fill(); ctx.stroke();

  items.forEach((it, i)=>{
    const yy = y + pad + i*rowH + 12;
    ctx.strokeStyle = it.color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x+pad, yy-4);
    ctx.lineTo(x+pad+18, yy-4);
    ctx.stroke();

    ctx.fillStyle = "rgba(233,238,247,0.92)";
    ctx.lineWidth = 1;
    ctx.fillText(it.label, x+pad+24, yy);
  });
  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

/* =========================
   Diagram canvas
   ========================= */
function drawDiagram(){
  const canvas = document.getElementById("cDiagram");
  const {ctx, w, h} = fitCanvas(canvas, 300);

  ctx.clearRect(0,0,w,h);

  // Layout
  const margin = 16;
  const x0 = margin, y0 = margin;
  const W = w - 2*margin, H = h - 2*margin;

  // Title
  ctx.fillStyle = "rgba(233,238,247,0.95)";
  ctx.font = "12.5px " + getComputedStyle(document.body).fontFamily;
  ctx.fillText("Cavity-dumped laser: store (low outcoupling) → dump (high outcoupling)", x0, y0+2);

  // Draw cavity rectangle
  const cavX = x0+24, cavY = y0+34, cavW = W-48, cavH = H-70;
  ctx.strokeStyle = "rgba(255,255,255,0.14)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  roundRect(ctx, cavX, cavY, cavW, cavH, 18);
  ctx.stroke();

  // Mirrors
  function drawMirror(x, y, angle){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(angle);
    ctx.strokeStyle = "rgba(123,220,255,0.85)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(-10, -20);
    ctx.lineTo(-10, 20);
    ctx.stroke();
    ctx.restore();
  }
  drawMirror(cavX+20, cavY+cavH/2, 0);
  drawMirror(cavX+cavW-20, cavY+cavH/2, 0);

  // Gain medium block
  const gmX = cavX + cavW*0.20, gmY = cavY + cavH*0.35, gmW = cavW*0.18, gmH = cavH*0.30;
  ctx.fillStyle = "rgba(167,255,131,0.12)";
  ctx.strokeStyle = "rgba(167,255,131,0.35)";
  ctx.lineWidth = 1.5;
  ctx.beginPath(); roundRect(ctx, gmX, gmY, gmW, gmH, 12); ctx.fill(); ctx.stroke();

  // Pockels cell
  const pcX = cavX + cavW*0.50, pcY = cavY + cavH*0.34, pcW = cavW*0.12, pcH = cavH*0.32;
  ctx.fillStyle = "rgba(123,220,255,0.10)";
  ctx.strokeStyle = "rgba(123,220,255,0.30)";
  ctx.beginPath(); roundRect(ctx, pcX, pcY, pcW, pcH, 12); ctx.fill(); ctx.stroke();

  // Polarizer/output coupler element near output mirror
  const polX = cavX + cavW*0.72, polY = cavY + cavH*0.34, polW = cavW*0.10, polH = cavH*0.32;
  ctx.fillStyle = "rgba(255,207,111,0.10)";
  ctx.strokeStyle = "rgba(255,207,111,0.34)";
  ctx.beginPath(); roundRect(ctx, polX, polY, polW, polH, 12); ctx.fill(); ctx.stroke();

  // Beam line
  ctx.strokeStyle = "rgba(233,238,247,0.60)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(cavX+30, cavY+cavH/2);
  ctx.lineTo(cavX+cavW-30, cavY+cavH/2);
  ctx.stroke();

  // Output arrow
  ctx.strokeStyle = "rgba(255,207,111,0.85)";
  ctx.lineWidth = 2.5;
  const outY = cavY+cavH/2;
  ctx.beginPath();
  ctx.moveTo(cavX+cavW-10, outY);
  ctx.lineTo(cavX+cavW+50, outY);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(cavX+cavW+50, outY);
  ctx.lineTo(cavX+cavW+40, outY-6);
  ctx.lineTo(cavX+cavW+40, outY+6);
  ctx.closePath();
  ctx.fillStyle = "rgba(255,207,111,0.85)";
  ctx.fill();

  // Labels
  ctx.fillStyle = "rgba(169,182,204,0.95)";
  ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
  ctx.fillText("Mirror", cavX+6, cavY+cavH/2-28);
  ctx.fillText("Mirror / OC", cavX+cavW-70, cavY+cavH/2-28);

  ctx.fillStyle = "rgba(233,238,247,0.92)";
  ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
  ctx.fillText("Gain medium", gmX, gmY-8);
  ctx.fillText("Pockels cell", pcX-4, pcY-8);
  ctx.fillText("Polarizer / switch", polX-16, polY-8);
  ctx.fillStyle = "rgba(255,207,111,0.95)";
  ctx.fillText("Output pulse φo(t)", cavX+cavW+8, outY-10);

  // Store vs dump callout
  const bx = cavX+18, by = cavY+cavH+10, bw = cavW-36, bh = 34;
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth = 1;
  ctx.beginPath(); roundRect(ctx, bx, by, bw, bh, 14); ctx.fill(); ctx.stroke();

  ctx.fillStyle = "rgba(233,238,247,0.92)";
  ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
  ctx.fillText("Store: low loss (τc=τstore) → Nt low", bx+12, by+14);
  ctx.fillStyle = "rgba(233,238,247,0.82)";
  ctx.fillText("Dump: high outcoupling (τc=τdump) → Nt high, n dumps out", bx+12, by+30);
}

/* =========================
   Main plot: two-cycle traces
   ========================= */
let showLegend = true;

function drawMain(sim){
  const canvas = document.getElementById("cMain");
  const {ctx, w, h} = fitCanvas(canvas, 340);
  ctx.clearRect(0,0,w,h);

  const padL = 58, padR = 18, padT = 34, padB = 46;
  const x0 = padL, y0 = padT, W = w - padL - padR, H = h - padT - padB;

  // Determine ranges (robust)
  const tMin = 0, tMax = 2*model.T;

  // Normalize & choose y-range to show all curves meaningfully.
  // We'll compress dynamic ranges with gentle scaling:
  //   plot N and Nt directly,
  //   plot n scaled by nScale,
  //   plot phi scaled by phiScale
  const {tArr, NtArr, NArr, nArr, phiArr} = sim;

  let nMax = 0, phiMax = 0, Nmax = 0, NtMax = 0;
  for(let i=0;i<tArr.length;i++){
    nMax = Math.max(nMax, nArr[i]);
    phiMax = Math.max(phiMax, phiArr[i]);
    Nmax = Math.max(Nmax, NArr[i]);
    NtMax = Math.max(NtMax, NtArr[i]);
  }
  const nScale = nMax > 0 ? (0.9 * Math.max(Nmax,NtMax)) / nMax : 1;
  const phiScale = phiMax > 0 ? (0.9 * Math.max(Nmax,NtMax)) / phiMax : 1;

  // build y arrays for plotting
  const nScaled = new Float32Array(nArr.length);
  const phiScaled = new Float32Array(phiArr.length);
  for(let i=0;i<nArr.length;i++){
    nScaled[i] = nArr[i]*nScale;
    phiScaled[i] = phiArr[i]*phiScale;
  }

  const yMin = 0;
  const yMax = Math.max(Nmax, NtMax, 1e-3) * 1.15;

  // Grid, axes, labels
  drawGrid(ctx, x0,y0,W,H, 10, 6);
  drawAxes(ctx, x0,y0,W,H, "time t (ms)", "normalized amplitude (scaled)", "Two-cycle evolution (scaled for visibility)");
  drawTicks(ctx, x0,y0,W,H, tMin,tMax, yMin,yMax, 10, 6);

  // Plot lines (colors are not specified by the user; use internal palette)
  plotLine(ctx, x0,y0,W,H, tArr, NtArr, tMin,tMax,yMin,yMax, "rgba(255,207,111,0.95)", 2.4);  // Nt
  plotLine(ctx, x0,y0,W,H, tArr, NArr,  tMin,tMax,yMin,yMax, "rgba(167,255,131,0.95)", 2.2);  // N
  plotLine(ctx, x0,y0,W,H, tArr, nScaled,tMin,tMax,yMin,yMax, "rgba(123,220,255,0.92)", 2.0);  // n scaled
  plotLine(ctx, x0,y0,W,H, tArr, phiScaled,tMin,tMax,yMin,yMax,"rgba(255,107,138,0.90)", 2.0);  // phi scaled

  // Dump windows shading
  const fDump = current.fDump;
  for(let cyc=0; cyc<2; cyc++){
    const T = model.T;
    const xStart = (cyc + (1-fDump))*T;
    const xEnd = (cyc+1)*T;
    const Xs = x0 + (xStart - tMin)/(tMax-tMin) * W;
    const Xe = x0 + (xEnd - tMin)/(tMax-tMin) * W;
    ctx.save();
    ctx.fillStyle = "rgba(255,207,111,0.06)";
    ctx.strokeStyle = "rgba(255,207,111,0.12)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.rect(Xs, y0, Xe-Xs, H);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = "rgba(255,207,111,0.80)";
    ctx.font = "11px " + getComputedStyle(document.body).fontFamily;
    ctx.fillText("dump", Xs+6, y0+14);
    ctx.restore();
  }

  // Annotation: scales used
  ctx.save();
  ctx.fillStyle = "rgba(169,182,204,0.9)";
  ctx.font = "11.5px " + getComputedStyle(document.body).fontFamily;
  const note = `Note: plotted n(t) is scaled by ×${(nScale).toFixed(2)}, and φo(t) by ×${(phiScale).toFixed(2)} for visibility.`;
  ctx.fillText(note, x0, y0+H+40);
  ctx.restore();

  if(showLegend){
    legend(ctx, [
      {label:"Nt(t) (threshold, ∝ loss)", color:"rgba(255,207,111,0.95)"},
      {label:"N(t) (inversion)", color:"rgba(167,255,131,0.95)"},
      {label:"n(t) (intracavity photons, scaled)", color:"rgba(123,220,255,0.92)"},
      {label:"φo(t) (output flux, scaled)", color:"rgba(255,107,138,0.90)"}
    ], x0 + 12, y0 + 12);
  }
}

/* =========================
   Sweep plot: energy vs f
   ========================= */
function drawSweep(){
  const canvas = document.getElementById("cSweep");
  const {ctx, w, h} = fitCanvas(canvas, 300);
  ctx.clearRect(0,0,w,h);

  const padL = 60, padR = 18, padT = 34, padB = 46;
  const x0 = padL, y0 = padT, W = w - padL - padR, H = h - padT - padB;

  const strength = current.strength;

  // Build sweep data
  const fMin = 0.03, fMax = 0.35;
  const Npts = 50;
  const fArr = new Float32Array(Npts);
  const EArr = new Float32Array(Npts);
  let Emax = 0;
  for(let i=0;i<Npts;i++){
    const f = lerp(fMin,fMax, i/(Npts-1));
    const E = pulseEnergyPerCycle(f, strength);
    fArr[i]=f;
    EArr[i]=E;
    Emax = Math.max(Emax, E);
  }
  const yMin = 0;
  const yMax = Emax*1.15 || 1;

  drawGrid(ctx, x0,y0,W,H, 10, 6);
  drawAxes(ctx, x0,y0,W,H, "dump fraction f = Tdump/T (—)", "pulse energy per cycle (arb.)", "Parameter sweep (example model)");
  drawTicks(ctx, x0,y0,W,H, fMin,fMax, yMin,yMax, 10, 6);

  plotLine(ctx, x0,y0,W,H, fArr, EArr, fMin,fMax,yMin,yMax, "rgba(167,255,131,0.92)", 2.4);

  // Current marker
  const f = current.fDump;
  const Ecur = pulseEnergyPerCycle(f, strength);
  const X = x0 + (f - fMin)/(fMax-fMin) * W;
  const Y = y0 + (1 - (Ecur - yMin)/(yMax-yMin)) * H;

  ctx.save();
  ctx.fillStyle = "rgba(255,207,111,0.95)";
  ctx.strokeStyle = "rgba(255,207,111,0.95)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(X,Y,5,0,Math.PI*2);
  ctx.fill();

  ctx.fillStyle = "rgba(233,238,247,0.92)";
  ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
  const label = `current: f=${f.toFixed(2)}, E=${Ecur.toFixed(3)}`;
  ctx.fillText(label, clamp(X+10, x0+6, x0+W-ctx.measureText(label).width-6), clamp(Y-10, y0+14, y0+H-6));
  ctx.restore();

  // Explanatory note
  ctx.save();
  ctx.fillStyle = "rgba(169,182,204,0.9)";
  ctx.font = "11.5px " + getComputedStyle(document.body).fontFamily;
  ctx.fillText("Typical behavior: energy rises with dump time then saturates when intracavity photons are fully extracted.", x0, y0+H+40);
  ctx.restore();
}

/* =========================
   UI & orchestration
   ========================= */
const current = {
  fDump: 0.12,
  strength: "strong"
};

function updateLabels(){
  document.getElementById("dumpFracVal").textContent = current.fDump.toFixed(2);
  const map = {mild:"Mild", strong:"Strong", extreme:"Extreme"};
  document.getElementById("dumpStrengthVal").textContent = map[current.strength] || "Strong";
}

function redrawAll(){
  updateLabels();
  drawDiagram();
  const sim = simulateTwoCycles(current.fDump, current.strength);
  drawMain(sim);
  drawSweep();
}

function attach(){
  const dumpFrac = document.getElementById("dumpFrac");
  const dumpStrength = document.getElementById("dumpStrength");
  const resetBtn = document.getElementById("resetBtn");
  const toggleLegendBtn = document.getElementById("toggleLegendBtn");

  dumpFrac.addEventListener("input", ()=>{
    current.fDump = parseFloat(dumpFrac.value);
    redrawAll();
  });
  dumpStrength.addEventListener("change", ()=>{
    current.strength = dumpStrength.value;
    redrawAll();
  });
  resetBtn.addEventListener("click", ()=>{
    current.fDump = 0.12;
    current.strength = "strong";
    dumpFrac.value = current.fDump;
    dumpStrength.value = current.strength;
    redrawAll();
  });
  toggleLegendBtn.addEventListener("click", ()=>{
    showLegend = !showLegend;
    redrawAll();
  });

  window.addEventListener("resize", ()=>{
    redrawAll();
  }, {passive:true});
}

attach();
redrawAll();

/* Accessibility: smooth scrolling for TOC */
document.querySelectorAll('nav.toc a[href^="#"]').forEach(a=>{
  a.addEventListener("click", (e)=>{
    const id = a.getAttribute("href").slice(1);
    const el = document.getElementById(id);
    if(!el) return;
    e.preventDefault();
    el.scrollIntoView({behavior:"smooth", block:"start"});
    history.replaceState(null, "", "#"+id);
  });
});
</script>
</body>
</html>
