<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Second-Harmonic Generation in a Laser Resonator — Rate Equations & Steady State</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#0f172a;
      --panel2:#0b1224;
      --text:#e7eefc;
      --muted:#a9b6d3;
      --faint:#6f7fa6;
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.16);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#86efac;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
      --radius2:22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 15% 10%, rgba(125,211,252,.12), transparent 55%),
        radial-gradient(1100px 700px at 85% 15%, rgba(167,139,250,.10), transparent 58%),
        radial-gradient(900px 600px at 50% 85%, rgba(134,239,172,.08), transparent 60%),
        linear-gradient(180deg, #070a10, var(--bg) 30%, #070a10 120%);
      line-height:1.55;
    }

    header{
      position:relative;
      padding: clamp(18px, 4vw, 40px) 18px 14px;
      max-width: 1180px;
      margin: 0 auto;
    }

    .hero{
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap: 16px;
      align-items:stretch;
    }
    @media (max-width: 920px){
      .hero{grid-template-columns: 1fr}
    }

    .hero-card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      padding: 18px 18px 16px;
      overflow:hidden;
      position:relative;
    }

    .hero-card:before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(500px 240px at 20% 0%, rgba(125,211,252,.18), transparent 60%),
                  radial-gradient(520px 260px at 80% 10%, rgba(167,139,250,.14), transparent 60%);
      opacity:.8;
      pointer-events:none;
      filter: blur(0px);
    }
    .hero-card > *{position:relative}

    h1{
      margin: 0 0 8px;
      font-size: clamp(22px, 2.2vw + 12px, 38px);
      letter-spacing: .2px;
    }
    .subtitle{
      color: var(--muted);
      font-size: 15px;
      margin: 0 0 12px;
      max-width: 70ch;
    }

    .meta{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top: 10px;
      color: var(--faint);
      font-size: 12.5px;
    }
    .pill{
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      padding:6px 10px;
      border-radius: 999px;
      display:inline-flex;
      gap:8px;
      align-items:center;
      white-space:nowrap;
    }
    .dot{
      width:8px;height:8px;border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(125,211,252,.10);
    }

    .toc{
      position: sticky;
      top: 12px;
      align-self:start;
      padding: 14px 14px 12px;
      border-radius: var(--radius2);
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(15,23,42,.85), rgba(11,18,36,.75));
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }
    .toc h2{
      margin:0 0 10px;
      font-size: 14px;
      color: var(--text);
      letter-spacing:.2px;
    }
    .toc a{
      display:block;
      color: var(--muted);
      text-decoration:none;
      padding: 6px 8px;
      border-radius: 10px;
      border:1px solid transparent;
      font-size: 13px;
      line-height: 1.2;
    }
    .toc a:hover{
      background: rgba(255,255,255,.04);
      border-color: var(--line);
      color: var(--text);
    }

    main{
      max-width: 1180px;
      margin: 0 auto;
      padding: 0 18px 46px;
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap: 16px;
    }
    @media (max-width: 920px){
      main{grid-template-columns: 1fr}
      .toc{position:relative; top:0}
    }

    section{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      padding: 16px 16px 14px;
      margin-bottom: 16px;
      overflow:hidden;
      position:relative;
    }
    section:after{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(620px 240px at 10% 0%, rgba(125,211,252,.08), transparent 60%),
        radial-gradient(620px 260px at 90% 10%, rgba(167,139,250,.07), transparent 60%);
      opacity:.65;
    }
    section > *{position:relative}

    h2{
      margin:0 0 10px;
      font-size: 18px;
      letter-spacing:.15px;
    }
    h3{
      margin: 14px 0 8px;
      font-size: 15px;
      color: var(--text);
    }
    p{margin: 8px 0}
    ul{margin: 8px 0 8px 18px}
    li{margin: 6px 0; color: var(--muted)}
    .tight li{margin: 4px 0}
    .note{
      color: var(--muted);
      font-size: 13.5px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 720px){
      .grid2{grid-template-columns: 1fr}
    }

    .callout{
      border-radius: 16px;
      border: 1px solid var(--line2);
      background: rgba(0,0,0,.18);
      padding: 12px 12px 10px;
      margin: 10px 0;
    }
    .callout strong{color: var(--text)}
    .callout .label{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size: 12px;
      letter-spacing:.25px;
      color: var(--faint);
      text-transform: uppercase;
      margin-bottom: 6px;
    }
    .badge{
      width:10px;height:10px;border-radius:3px;background: var(--accent);
      box-shadow: 0 0 0 4px rgba(125,211,252,.10);
    }
    .badge.good{background: var(--good); box-shadow:0 0 0 4px rgba(134,239,172,.10)}
    .badge.warn{background: var(--warn); box-shadow:0 0 0 4px rgba(251,191,36,.10)}
    .badge.bad{background: var(--bad); box-shadow:0 0 0 4px rgba(251,113,133,.10)}

    .eq{
      font-family: var(--mono);
      font-size: 13.2px;
      color: #dbeafe;
      background: rgba(0,0,0,.22);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 10px 10px;
      margin: 10px 0;
      overflow:auto;
      position:relative;
    }
    .eq .copybtn{
      position:absolute;
      top:8px; right:8px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 12px;
      font-size: 12px;
      cursor:pointer;
    }
    .eq .copybtn:hover{background: rgba(255,255,255,.08)}
    code.inline{
      font-family: var(--mono);
      color:#dbeafe;
      font-size: .95em;
      background: rgba(0,0,0,.20);
      border:1px solid var(--line);
      padding: 1px 6px;
      border-radius: 8px;
      white-space:nowrap;
    }

    figure{
      margin: 10px 0 8px;
      padding: 10px;
      border-radius: 18px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
    }
    figcaption{
      margin-top: 8px;
      color: var(--muted);
      font-size: 12.5px;
    }

    canvas{
      width:100%;
      height: 280px;
      display:block;
      border-radius: 14px;
      border:1px solid var(--line);
      background: rgba(8,12,20,.75);
    }
    .canvas-tall{height: 320px;}
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin: 10px 0 6px;
    }
    @media (max-width: 720px){ .controls{grid-template-columns:1fr} }

    .ctrl{
      border:1px solid var(--line);
      border-radius: 16px;
      background: rgba(255,255,255,.03);
      padding: 10px 10px 8px;
    }
    .ctrl label{
      display:flex;
      justify-content:space-between;
      gap: 10px;
      font-size: 12.8px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .ctrl .val{
      color: var(--text);
      font-family: var(--mono);
      font-size: 12.5px;
      white-space:nowrap;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    select{
      width:100%;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.22);
      color: var(--text);
      outline:none;
    }

    .side{
      display:flex;
      flex-direction:column;
      gap: 16px;
    }

    footer{
      max-width:1180px;
      margin: 0 auto;
      padding: 0 18px 28px;
      color: var(--faint);
      font-size: 12.5px;
    }

    /* subtle animation */
    @media (prefers-reduced-motion: no-preference){
      section, .hero-card, .toc{
        animation: floatIn .6s ease both;
      }
      @keyframes floatIn{
        from{transform: translateY(8px); opacity:0}
        to{transform: translateY(0); opacity:1}
      }
    }

    /* print-friendly */
    @media print{
      body{background:white;color:black}
      header, main, footer{max-width:none}
      .toc{display:none}
      section, .hero-card{box-shadow:none}
      canvas{border:1px solid #ddd; background:white}
      .eq{background:#f6f6f6;color:black}
      .eq .copybtn{display:none}
      .callout{background:#f7f7f7}
      a{color:black;text-decoration:none}
    }
  </style>
</head>

<body>
<header>
  <div class="hero">
    <div class="hero-card">
      <h1>Second-Harmonic Generation in a Laser Resonator</h1>
      <p class="subtitle">
        Build the coupled <span class="inline" style="font-family:var(--mono);">rate equations</span> for photon-number densities at
        <b>ν</b> and <b>2ν</b>, then solve for the <b>steady-state</b> densities when the cavity has finite photon lifetimes.
      </p>
      <div class="meta">
        <span class="pill"><span class="dot"></span>Nonlinear optics → frequency doubling</span>
        <span class="pill"><span class="dot" style="background:var(--accent2); box-shadow:0 0 0 4px rgba(167,139,250,.10)"></span>Laser gain + cavity loss</span>
        <span class="pill"><span class="dot" style="background:var(--good); box-shadow:0 0 0 4px rgba(134,239,172,.10)"></span>Steady state from algebra</span>
      </div>
    </div>

    <nav class="toc" aria-label="Table of contents">
      <h2>Table of Contents</h2>
      <a href="#quick-summary">Quick Summary</a>
      <a href="#part0">PART 0 — Concept Primer</a>
      <a href="#part1">PART 1 — Problem Analysis</a>
      <a href="#part2">PART 2 — Strategy & Tips</a>
      <a href="#part3">PART 3 — Full Solution</a>
      <a href="#part4">PART 4 — Deeper Understanding</a>
      <a href="#part5">PART 5 — Visualization Guide</a>
      <a href="#viz">Interactive Visualizations</a>
    </nav>
  </div>
</header>

<main>
  <div>
    <section id="quick-summary">
      <h2>Quick Summary</h2>
      <ul class="tight">
        <li>This problem models <b>second-harmonic generation (SHG)</b> inside a resonator that also has <b>laser gain</b> at frequency <b>ν</b>.</li>
        <li>Key physics idea: SHG converts <b>two ν-photons into one 2ν-photon</b>, so it is a <b>loss term</b> for the fundamental and a <b>source term</b> for the harmonic.</li>
        <li>We write <b>coupled rate equations</b> for photon-number densities <span class="inline">n</span> (at ν) and <span class="inline">n₂</span> (at 2ν), including cavity decay via lifetimes <span class="inline">τp</span> and <span class="inline">τp2</span>.</li>
        <li>Using the usual SHG event rate per volume <span class="inline">R = ζ n²</span>, the equations are:
          <span class="inline">dn/dt = ξ n − 2ζ n² − n/τp</span> and <span class="inline">dn₂/dt = ζ n² − n₂/τp2</span>.</li>
        <li>Steady state is found by setting <span class="inline">dn/dt = dn₂/dt = 0</span>, giving a <b>threshold</b> condition <span class="inline">ξ &gt; 1/τp</span> for nonzero fields.</li>
        <li>Final result type: <b>symbolic formulas</b> for <span class="inline">n*</span> and <span class="inline">n₂*</span> (plus the trivial zero solution).</li>
      </ul>

      <div class="callout">
        <div class="label"><span class="badge warn"></span>Note about the SHG rate form</div>
        <p class="note">
          Many textbooks model SHG as an event rate <span class="inline">R ∝ n²</span> because two fundamental photons are required per conversion event.
          If your course/problem statement instead uses <span class="inline">R = ζ n</span>, the same bookkeeping applies; you would replace every <span class="inline">n²</span> below by <span class="inline">n</span>.
          The visualization here uses the physically common <span class="inline">R = ζ n²</span>.
        </p>
      </div>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="grid2">
        <div>
          <h3>Core definitions (symbols & units)</h3>
          <ul>
            <li><span class="inline">n</span> — photon-number density at frequency <b>ν</b> (units: m<sup>−3</sup>).</li>
            <li><span class="inline">n₂</span> — photon-number density at frequency <b>2ν</b> (units: m<sup>−3</sup>).</li>
            <li><span class="inline">τp</span>, <span class="inline">τp2</span> — photon lifetimes (energy decay times) at ν and 2ν (units: s).</li>
            <li><span class="inline">ξ</span> — net laser gain rate coefficient for the ν-mode (units: s<sup>−1</sup>).</li>
            <li><span class="inline">ζ</span> — SHG conversion coefficient (units depend on model; for <span class="inline">R=ζ n²</span>, units: m<sup>3</sup>/s).</li>
            <li><span class="inline">R</span> — SHG <b>event</b> rate per volume: number of ν+ν→2ν conversions per (m<sup>3</sup>·s).</li>
          </ul>
        </div>

        <div>
          <h3>Physical meaning of key quantities</h3>
          <ul>
            <li><span class="inline">τp</span> encodes cavity losses (mirror transmission, absorption, scattering). A term <span class="inline">−n/τp</span> is “photon leakage.”</li>
            <li><span class="inline">ξ n</span> is a <b>stimulated</b> growth term: more photons → more stimulated emission → faster growth.</li>
            <li>SHG couples the modes: increasing <span class="inline">n</span> “feeds” <span class="inline">n₂</span>, while simultaneously draining <span class="inline">n</span>.</li>
          </ul>

          <div class="callout">
            <div class="label"><span class="badge"></span>Key bookkeeping rule (stoichiometry)</div>
            <p class="note">
              One SHG event consumes <b>2</b> photons at ν and produces <b>1</b> photon at 2ν.
              So the ν-equation gets <span class="inline">−2R</span> and the 2ν-equation gets <span class="inline">+R</span>.
            </p>
          </div>
        </div>
      </div>

      <h3>Key laws/principles & validity</h3>
      <ul>
        <li><b>Rate equation modeling:</b> valid when you can treat photon numbers as continuous densities and average over fast optical oscillations (intensity-level dynamics).</li>
        <li><b>Single-mode approximation:</b> ν and 2ν each correspond to one resonator mode (no multimode competition).</li>
        <li><b>Constant coefficients:</b> <span class="inline">ξ</span> and <span class="inline">ζ</span> are treated as constants (no pump depletion beyond what is captured by the rate terms; no gain saturation unless explicitly included).</li>
      </ul>

      <h3>Common models/approximations (why we use them)</h3>
      <ul>
        <li><b>Linear cavity loss:</b> <span class="inline">−n/τp</span> is the simplest correct way to encode a finite lifetime.</li>
        <li><b>Quadratic SHG source:</b> <span class="inline">R=ζ n²</span> is the simplest way to express “needs two photons,” matching classical intensity dependence of SHG.</li>
        <li><b>No back-conversion:</b> we neglect 2ν→ν+ν (often small if phase matching and cavity design favor SHG extraction).</li>
      </ul>

      <h3>Mini intuition examples</h3>
      <ul>
        <li><b>If ζ = 0 (no nonlinear crystal):</b> ν-mode behaves like a simple laser-with-loss: <span class="inline">dn/dt = (ξ − 1/τp) n</span>.</li>
        <li><b>If ξ is barely above 1/τp:</b> ν builds up slightly; SHG is weak because it depends on <span class="inline">n²</span>.</li>
      </ul>

      <div class="callout">
        <div class="label"><span class="badge bad"></span>What to watch for (pitfalls)</div>
        <ul class="tight">
          <li>Forgetting the factor <b>2</b> in the ν-loss term from SHG (two photons consumed).</li>
          <li>Mixing “event rate” <span class="inline">R</span> with “photon production rate” at 2ν (they’re equal only because one 2ν photon is created per event).</li>
          <li>Missing the <b>threshold-like condition</b> <span class="inline">ξ &gt; 1/τp</span> needed to overcome cavity loss.</li>
          <li>Units: if you use <span class="inline">R=ζ n²</span>, then <span class="inline">ζ</span> must carry units <span class="inline">m³/s</span> so that <span class="inline">R</span> has units <span class="inline">m⁻³ s⁻¹</span>.</li>
        </ul>
      </div>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Rewrite the problem in plain language</h3>
      <p class="note">
        A nonlinear crystal inside a laser cavity converts light at frequency ν into its second harmonic at 2ν.
        The cavity supports two modes (ν and 2ν). The ν-mode also experiences laser gain from an active medium.
        You are given phenomenological rates for SHG and for laser photon production, and you must:
        (i) write coupled rate equations for <span class="inline">n</span> and <span class="inline">n₂</span> including finite photon lifetimes, and
        (ii) solve for the steady-state photon-number densities.
      </p>

      <div class="grid2">
        <div>
          <h3>Given quantities</h3>
          <ul>
            <li>SHG conversion event rate per volume: <span class="inline">R = ζ n²</span> (units: m<sup>−3</sup>·s<sup>−1</sup>).</li>
            <li>Laser photon production rate per volume at ν: <span class="inline">G = ξ n</span> (units: m<sup>−3</sup>·s<sup>−1</sup>).</li>
            <li>Photon lifetimes: <span class="inline">τp</span> at ν, <span class="inline">τp2</span> at 2ν.</li>
          </ul>
        </div>

        <div>
          <h3>Unknowns</h3>
          <ul>
            <li>Time-dependent photon densities <span class="inline">n(t)</span> and <span class="inline">n₂(t)</span>.</li>
            <li>Steady-state values <span class="inline">n*</span> and <span class="inline">n₂*</span>.</li>
          </ul>

          <h3>What must be found</h3>
          <ul class="tight">
            <li>Two coupled ODEs for <span class="inline">n</span> and <span class="inline">n₂</span>.</li>
            <li>Steady-state solutions (including conditions for nonzero operation).</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li><b>Photon balance in each mode:</b> time rate of change equals sources minus sinks.</li>
        <li><b>Cavity loss via lifetime:</b> a mode with lifetime τ loses photons at rate proportional to its population: <span class="inline">−n/τ</span>.</li>
        <li><b>Nonlinear coupling via SHG stoichiometry:</b> ν loses 2 per event, 2ν gains 1 per event.</li>
      </ul>

      <div class="callout">
        <div class="label"><span class="badge good"></span>Assumptions (explicit)</div>
        <ul class="tight">
          <li>Single resonator mode at ν and a single mode at 2ν (no spatial/mode competition).</li>
          <li>Coefficients <span class="inline">ξ</span>, <span class="inline">ζ</span> are constants (no gain saturation, no temperature drift, no phase-mismatch dynamics).</li>
          <li>No back-conversion (2ν→ν+ν) and no additional nonlinear losses.</li>
          <li>Mean-field (rate-equation) description: fluctuations are ignored.</li>
        </ul>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ul>
        <li><b>Rate-equation method (best here):</b> directly write ODEs and set derivatives to zero. Fast, transparent, matches given data.</li>
        <li><b>Field-amplitude coupled-mode equations:</b> more fundamental (includes phases, phase matching), but overkill since problem provides rates.</li>
        <li><b>Energy-flow method:</b> relate power at ν and 2ν. Useful experimentally, but still needs a dynamical model to incorporate lifetimes cleanly.</li>
      </ul>
      <p class="note"><b>Choice:</b> Use the <b>rate-equation method</b> because the problem gives rates in exactly that language, and steady state reduces to algebra.</p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>
      <ol style="margin:8px 0 8px 20px; color: var(--muted);">
        <li><b>Define the SHG event rate</b> <span class="inline">R</span> from the given model (<span class="inline">R=ζ n²</span>).<br/>
          <span class="note">Tool: interpret “conversion rate per volume.” Meaning: how many ν+ν→2ν events occur per second per m³.</span>
        </li>
        <li><b>Write ν-mode balance</b>: add gain <span class="inline">+ξ n</span>, subtract cavity loss <span class="inline">−n/τp</span>, subtract SHG loss <span class="inline">−2R</span>.<br/>
          <span class="note">Meaning: ν photons grow via stimulated emission, leak out, and are consumed by SHG.</span>
        </li>
        <li><b>Write 2ν-mode balance</b>: add SHG source <span class="inline">+R</span>, subtract cavity loss <span class="inline">−n₂/τp2</span>.<br/>
          <span class="note">Meaning: harmonic photons are produced only by SHG and leak out with their own lifetime.</span>
        </li>
        <li><b>Set derivatives to zero</b> to impose steady state.<br/>
          <span class="note">Meaning: average photon densities stop changing in time.</span>
        </li>
        <li><b>Solve the algebra</b>: first solve for <span class="inline">n₂</span> in terms of <span class="inline">n</span>, then solve ν-equation for <span class="inline">n</span>.<br/>
          <span class="note">Meaning: harmonic follows the fundamental; then fundamental is set by gain-loss-nonlinear balance.</span>
        </li>
        <li><b>Check sanity</b>: units, thresholds, limiting cases (ζ→0, τp2→∞, etc.).</li>
      </ol>

      <div class="callout">
        <div class="label"><span class="badge warn"></span>Common mistakes & quick tips</div>
        <ul class="tight">
          <li>Tip: Treat SHG as an <b>event rate</b> <span class="inline">R</span>; then multiply by 2 only in the ν-equation.</li>
          <li>Mistake: dropping the cavity loss terms — lifetimes are essential to avoid unphysical runaway.</li>
          <li>Tip: In steady state, it’s easiest to solve the 2ν equation first because it’s linear in <span class="inline">n₂</span>.</li>
        </ul>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Qualitative expectation (before math)</h3>
      <p class="note">
        If laser gain is too small, photons at ν leak out faster than they are produced, so <span class="inline">n → 0</span> and then SHG also vanishes (<span class="inline">n₂ → 0</span>).
        If gain exceeds losses, ν builds up until SHG becomes strong enough (because it grows like <span class="inline">n²</span>) to clamp the ν population.
        The harmonic population then scales like <span class="inline">n²</span> times its lifetime.
      </p>

      <h3>Step 1 — Define the SHG event rate and bookkeeping</h3>
      <p class="note">
        Let <span class="inline">R</span> be the number of SHG conversion events per unit volume per unit time:
      </p>

      <div class="eq" data-copy="R = ζ n^2">
        <button class="copybtn" type="button">Copy</button>
        R = ζ n²
      </div>

      <p class="note">
        Each event consumes <b>2</b> photons from the ν-mode and creates <b>1</b> photon in the 2ν-mode.
        Therefore:
      </p>
      <ul class="tight">
        <li>ν-mode SHG contribution: <span class="inline">−2R</span></li>
        <li>2ν-mode SHG contribution: <span class="inline">+R</span></li>
      </ul>

      <h3>Step 2 — Write the ν-mode rate equation</h3>
      <p class="note">
        Sources and sinks for <span class="inline">n</span> (photon density at ν):
      </p>
      <ul class="tight">
        <li>Laser (net stimulated emission minus absorption): <span class="inline">+ ξ n</span></li>
        <li>Cavity loss (finite lifetime <span class="inline">τp</span>): <span class="inline">− n/τp</span></li>
        <li>SHG consumption: <span class="inline">− 2R = − 2 ζ n²</span></li>
      </ul>

      <div class="eq" data-copy="dn/dt = ξ n − (n/τp) − 2 ζ n^2">
        <button class="copybtn" type="button">Copy</button>
        dn/dt = ξ n − n/τp − 2 ζ n²
      </div>

      <p class="note">
        <b>What we did:</b> photon balance for the ν-mode. Gain increases n, cavity leakage decreases n, and nonlinear conversion decreases n by two photons per event.
      </p>

      <h3>Step 3 — Write the 2ν-mode rate equation</h3>
      <p class="note">
        The harmonic photon density <span class="inline">n₂</span> has:
      </p>
      <ul class="tight">
        <li>Source from SHG: <span class="inline">+ R = + ζ n²</span></li>
        <li>Loss from cavity lifetime <span class="inline">τp2</span>: <span class="inline">− n₂/τp2</span></li>
      </ul>

      <div class="eq" data-copy="dn2/dt = ζ n^2 − (n2/τp2)">
        <button class="copybtn" type="button">Copy</button>
        dn₂/dt = ζ n² − n₂/τp2
      </div>

      <p class="note">
        <b>What we did:</b> harmonic photons are created by SHG and decay by cavity loss. (No direct gain at 2ν is assumed.)
      </p>

      <h3>Step 4 — Impose steady state</h3>
      <p class="note">Steady state means <span class="inline">dn/dt = 0</span> and <span class="inline">dn₂/dt = 0</span>.</p>

      <h4 style="margin:10px 0 6px; color:var(--text); font-size:14px;">4a) Solve the 2ν equation first</h4>
      <p class="note">
        From <span class="inline">0 = ζ n² − n₂/τp2</span>, rearrange:
      </p>

      <div class="eq" data-copy="n2* = τp2 ζ (n*)^2">
        <button class="copybtn" type="button">Copy</button>
        n₂* = τp2 ζ (n*)²
      </div>

      <p class="note">
        <b>Meaning:</b> the harmonic population equals “production rate × lifetime.” Longer <span class="inline">τp2</span> stores more 2ν photons.
      </p>

      <h4 style="margin:10px 0 6px; color:var(--text); font-size:14px;">4b) Solve the ν equation</h4>
      <p class="note">
        Start from the ν steady-state condition:
      </p>

      <div class="eq" data-copy="0 = ξ n* − (n*/τp) − 2 ζ (n*)^2">
        <button class="copybtn" type="button">Copy</button>
        0 = ξ n* − n*/τp − 2 ζ (n*)²
      </div>

      <p class="note">
        Factor out <span class="inline">n*</span>:
      </p>

      <div class="eq" data-copy="0 = n* [ (ξ − 1/τp) − 2 ζ n* ]">
        <button class="copybtn" type="button">Copy</button>
        0 = n* [ (ξ − 1/τp) − 2 ζ n* ]
      </div>

      <p class="note">
        This gives two branches:
      </p>
      <ul class="tight">
        <li><b>Trivial (off) solution:</b> <span class="inline">n* = 0</span></li>
        <li><b>Nontrivial (on) solution:</b> solve <span class="inline">(ξ − 1/τp) − 2 ζ n* = 0</span></li>
      </ul>

      <p class="note">Rearrange for the nonzero solution:</p>

      <div class="eq" data-copy="n* = (ξ − 1/τp) / (2 ζ)  (valid only if ξ > 1/τp)">
        <button class="copybtn" type="button">Copy</button>
        n* = (ξ − 1/τp) / (2 ζ) &nbsp;&nbsp; (requires ξ &gt; 1/τp)
      </div>

      <p class="note">
        <b>Meaning:</b> ν photons grow until nonlinear conversion (∝n²) balances the “excess gain” above cavity loss.
      </p>

      <h3>Step 5 — Final steady-state pair</h3>
      <p class="note">Substitute <span class="inline">n*</span> into the harmonic expression:</p>

      <div class="eq" data-copy="n2* = τp2 ζ (n*)^2 = τp2 (ξ − 1/τp)^2 / (4 ζ)  (for ξ > 1/τp)">
        <button class="copybtn" type="button">Copy</button>
        n₂* = τp2 ζ (n*)² = τp2 (ξ − 1/τp)² / (4 ζ) &nbsp;&nbsp; (for ξ &gt; 1/τp)
      </div>

      <div class="callout">
        <div class="label"><span class="badge good"></span>Final answer (boxed)</div>
        <div class="eq" style="margin:10px 0 0" data-copy="Rate equations:
dn/dt = ξ n − n/τp − 2 ζ n^2
dn2/dt = ζ n^2 − n2/τp2

Steady state:
If ξ ≤ 1/τp:  n* = 0,  n2* = 0
If ξ > 1/τp:  n* = (ξ − 1/τp)/(2 ζ),  n2* = τp2 (ξ − 1/τp)^2/(4 ζ)">
          <button class="copybtn" type="button">Copy</button>
Rate equations:
dn/dt = ξ n − n/τp − 2 ζ n²
dn₂/dt = ζ n² − n₂/τp2

Steady state:
If ξ ≤ 1/τp:  n* = 0,  n₂* = 0
If ξ &gt; 1/τp:  n* = (ξ − 1/τp)/(2 ζ),  n₂* = τp2 (ξ − 1/τp)²/(4 ζ)
        </div>
      </div>

      <h3>Sanity checks</h3>
      <div class="grid2">
        <div class="callout">
          <div class="label"><span class="badge"></span>Units / dimensions</div>
          <ul class="tight">
            <li><span class="inline">ξ</span> and <span class="inline">1/τp</span> both have units s<sup>−1</sup>, so <span class="inline">(ξ − 1/τp)</span> is s<sup>−1</sup>.</li>
            <li>If <span class="inline">R = ζ n²</span>, then <span class="inline">[ζ] = m³/s</span>, so <span class="inline">n* = (s⁻¹)/(m³/s) = m⁻³</span>. ✅</li>
            <li><span class="inline">n₂* = τp2 (ξ − 1/τp)²/(4ζ)</span> has units <span class="inline">s·(s⁻2)/(m³/s)=m⁻3</span>. ✅</li>
          </ul>
        </div>

        <div class="callout">
          <div class="label"><span class="badge warn"></span>Limiting cases</div>
          <ul class="tight">
            <li><b>ζ → 0</b>: the nonzero solution diverges (because without SHG or saturation, a pure linear-gain model would run away). This flags that real lasers need gain saturation—here SHG plays the role of a nonlinear clamp.</li>
            <li><b>τp2 → 0</b>: harmonic leaks instantly, so <span class="inline">n₂*</span>→0 even if SHG happens.</li>
            <li><b>ξ → 1/τp</b><sup>+</sup>: <span class="inline">n*</span>→0 and <span class="inline">n₂*</span>→0 smoothly (threshold-like behavior).</li>
          </ul>
        </div>
      </div>

      <p class="note">
        <b>Connection to the diagram & plots:</b>
        the cavity stores photons for times <span class="inline">τp</span> and <span class="inline">τp2</span>. Increasing gain <span class="inline">ξ</span> raises the steady ν density linearly above threshold,
        while the 2ν density rises quadratically with the “excess gain” <span class="inline">(ξ − 1/τp)</span>.
      </p>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpret the final formulas</h3>
      <ul>
        <li><span class="inline">n*</span> is set by a balance:
          <b>excess linear gain</b> <span class="inline">(ξ − 1/τp)</span> versus <b>nonlinear depletion</b> <span class="inline">2ζ n</span>.
          Larger <span class="inline">ζ</span> means stronger conversion, so the fundamental clamps at a smaller value.</li>
        <li><span class="inline">n₂*</span> scales like <span class="inline">τp2</span> (storage time) and like <span class="inline">(ξ − 1/τp)²</span> (because it is proportional to <span class="inline">n²</span>).</li>
      </ul>

      <div class="callout">
        <div class="label"><span class="badge"></span>How parameters reshape the outcome (connect to plots)</div>
        <ul class="tight">
          <li>Increase <span class="inline">ξ</span>: threshold at <span class="inline">1/τp</span>; above it, <span class="inline">n*</span> rises linearly and <span class="inline">n₂*</span> rises faster (quadratic in excess gain).</li>
          <li>Increase <span class="inline">ζ</span>: stronger conversion → lower <span class="inline">n*</span>, and (for fixed ξ) also lowers <span class="inline">n₂*</span> because the same excess gain is “spent” more efficiently at smaller n, reducing stored 2ν density in this simple lifetime model.</li>
          <li>Increase <span class="inline">τp2</span>: harmonic stores longer → larger <span class="inline">n₂*</span> at fixed <span class="inline">n*</span>.</li>
          <li>Decrease <span class="inline">τp</span>: more loss → higher threshold, smaller steady-state densities.</li>
        </ul>
      </div>

      <h3>Alternative derivation idea (brief)</h3>
      <p class="note">
        You can start from <b>coupled-mode equations for field amplitudes</b> (including a nonlinear polarization term for SHG),
        then derive photon-number rate equations by differentiating intensities and averaging over optical cycles.
        That approach exposes phase matching and relative phases, but collapses to the same population equations when phases are fixed and only intensities matter.
      </p>

      <h3>Concept checks (self-test)</h3>
      <ul>
        <li><b>Q:</b> Why does the ν-equation have <span class="inline">−2R</span> but the 2ν-equation has <span class="inline">+R</span>?<br/>
            <b>A:</b> Two ν photons are consumed per conversion event, but only one 2ν photon is produced per event.</li>
        <li><b>Q:</b> What sets the “threshold” condition here?<br/>
            <b>A:</b> Nonzero steady state requires net growth at small n: <span class="inline">ξ − 1/τp &gt; 0</span>.</li>
        <li><b>Q:</b> If <span class="inline">τp2</span> doubles while everything else is fixed, what happens to <span class="inline">n₂*</span>?<br/>
            <b>A:</b> It doubles, because <span class="inline">n₂* = τp2 ζ (n*)²</span>.</li>
        <li><b>Q:</b> Why does <span class="inline">n₂*</span> grow faster than <span class="inline">n*</span> when you increase <span class="inline">ξ</span>?<br/>
            <b>A:</b> Because <span class="inline">n₂*</span> depends on <span class="inline">n²</span> (quadratic relationship).</li>
      </ul>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>
      <ul>
        <li><b>Diagram canvas:</b> shows a resonator with a nonlinear crystal. The ν-mode experiences gain and loss; the crystal converts ν photons into 2ν photons.</li>
        <li><b>Main plot:</b> steady-state <span class="inline">n*</span> and <span class="inline">n₂*</span versus gain coefficient <span class="inline">ξ</span>. A vertical marker shows the current slider value and a dashed line shows the threshold <span class="inline">ξ = 1/τp</span>.</li>
        <li><b>Secondary plot:</b> parameter sweep of <span class="inline">n*</span> and <span class="inline">n₂*</span versus the SHG coefficient <span class="inline">ζ</span> (log-x). This highlights how conversion strength clamps the fundamental and affects harmonic storage.</li>
        <li><b>Interactive controls:</b> change <span class="inline">ξ</span>, <span class="inline">ζ</span>, and lifetimes. All canvases update live so you can see how the algebraic steady-state responds.</li>
      </ul>
      <div class="callout">
        <div class="label"><span class="badge warn"></span>Reminder</div>
        <p class="note">
          The plotted numbers use <b>example values</b> (clearly labeled in the control panel) because the problem is symbolic.
          The formulas in the solution remain fully general.
        </p>
      </div>
    </section>
  </div>

  <aside class="side" id="viz">
    <section>
      <h2>Interactive Visualizations</h2>
      <p class="note">All plots use the same symbols as the derivation. Values shown are example numbers for visualization.</p>

      <div class="controls" aria-label="Interactive controls">
        <div class="ctrl">
          <label for="xi">
            Gain coefficient <span class="inline">ξ</span> (s<sup>−1</sup>)
            <span class="val" id="xiVal"></span>
          </label>
          <input id="xi" type="range" min="0" max="6e8" step="1e6" value="3.2e8" />
        </div>

        <div class="ctrl">
          <label for="zeta">
            SHG coefficient <span class="inline">ζ</span> (m<sup>3</sup>/s)
            <span class="val" id="zetaVal"></span>
          </label>
          <input id="zeta" type="range" min="1e-11" max="5e-10" step="1e-11" value="1e-10" />
        </div>

        <div class="ctrl">
          <label for="taup">
            Photon lifetime <span class="inline">τp</span> at ν (s)
            <span class="val" id="taupVal"></span>
          </label>
          <input id="taup" type="range" min="1e-9" max="2e-8" step="1e-10" value="5e-9" />
        </div>

        <div class="ctrl">
          <label for="taup2">
            Photon lifetime <span class="inline">τp2</span> at 2ν (s)
            <span class="val" id="taup2Val"></span>
          </label>
          <input id="taup2" type="range" min="5e-10" max="2e-8" step="1e-10" value="3e-9" />
        </div>

        <div class="ctrl" style="grid-column: 1 / -1;">
          <label for="sweepMode">
            Secondary plot sweep mode
            <span class="val" id="modeVal"></span>
          </label>
          <select id="sweepMode">
            <option value="zeta">Sweep ζ (log-x) at fixed ξ</option>
            <option value="taup2">Sweep τp2 (linear-x) at fixed ξ, ζ</option>
          </select>
        </div>
      </div>

      <figure>
        <canvas id="diagram" class="canvas-tall" aria-label="Cavity diagram"></canvas>
        <figcaption>Diagram: laser resonator with an active medium (gain at ν) and a nonlinear crystal (SHG ν+ν→2ν).</figcaption>
      </figure>

      <figure>
        <canvas id="plotMain" class="canvas-tall" aria-label="Main quantitative plot"></canvas>
        <figcaption>Main plot: steady-state photon densities vs gain coefficient ξ (example parameter values).</figcaption>
      </figure>

      <figure>
        <canvas id="plotSweep" class="canvas-tall" aria-label="Secondary parameter sweep"></canvas>
        <figcaption>Secondary plot: parameter sweep showing how conversion strength or harmonic lifetime affects steady state.</figcaption>
      </figure>
    </section>
  </aside>
</main>

<footer>
  <p>
    Built as a self-contained learning article (vanilla HTML/CSS/JS). Copy buttons copy plain-text equations/results.
    For different problem conventions (e.g., SHG rate ∝ n instead of n²), substitute accordingly in the rate equations and repeat the same steady-state steps.
  </p>
</footer>

<script>
(function(){
  "use strict";

  // ---------- Copy buttons ----------
  function wireCopyButtons(){
    document.querySelectorAll(".eq").forEach(eqBox=>{
      const btn = eqBox.querySelector(".copybtn");
      if(!btn) return;
      btn.addEventListener("click", async ()=>{
        const txt = eqBox.getAttribute("data-copy") || eqBox.innerText.replace("Copy","").trim();
        try{
          await navigator.clipboard.writeText(txt);
          const old = btn.textContent;
          btn.textContent = "Copied!";
          setTimeout(()=>btn.textContent = old, 900);
        }catch(e){
          const old = btn.textContent;
          btn.textContent = "Copy failed";
          setTimeout(()=>btn.textContent = old, 900);
        }
      });
    });
  }

  // ---------- Numerics (steady state) ----------
  // Model used in the article:
  // dn/dt = ξ n − n/τp − 2 ζ n^2
  // dn2/dt = ζ n^2 − n2/τp2
  function steadyState(xi, zeta, taup, taup2){
    const thr = 1.0/taup;
    if(xi <= thr || zeta <= 0){
      return { n:0, n2:0, thr:thr, on:false };
    }
    const n = (xi - thr)/(2*zeta);
    const n2 = taup2 * zeta * n*n;
    return { n:n, n2:n2, thr:thr, on:true };
  }

  // ---------- Canvas helpers ----------
  function setupHiDPI(canvas){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width * dpr));
    const h = Math.max(1, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w;
      canvas.height = h;
    }
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return ctx;
  }

  function clear(ctx, w, h){
    ctx.clearRect(0,0,w,h);
    // subtle backdrop
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,"rgba(255,255,255,0.03)");
    g.addColorStop(1,"rgba(0,0,0,0.06)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
  }

  function drawGrid(ctx, x0, y0, x1, y1, nx, ny){
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.lineWidth = 1;
    for(let i=0;i<=nx;i++){
      const x = x0 + (x1-x0)*i/nx;
      ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y1); ctx.stroke();
    }
    for(let j=0;j<=ny;j++){
      const y = y0 + (y1-y0)*j/ny;
      ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke();
    }
    ctx.restore();
  }

  function formatSI(v, sig=3){
    if(!isFinite(v)) return "—";
    if(v === 0) return "0";
    const abs = Math.abs(v);
    const exp = Math.floor(Math.log10(abs));
    // Use scientific for very small/large
    if(exp >= 4 || exp <= -3){
      const m = v / Math.pow(10, exp);
      return m.toFixed(Math.max(0, sig-1)) + "e" + exp;
    }
    // Otherwise fixed-ish
    const decimals = Math.max(0, sig - 1 - exp);
    return v.toFixed(decimals);
  }

  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  // Plot engine (supports linear x, linear y; optional log-x)
  function plotLines(ctx, box, series, opts){
    const {x, y, w, h} = box;
    const padL = 54, padR = 16, padT = 34, padB = 44;
    const gx0 = x + padL, gx1 = x + w - padR;
    const gy0 = y + padT, gy1 = y + h - padB;

    // background + grid
    drawGrid(ctx, gx0, gy0, gx1, gy1, 8, 6);

    // titles
    ctx.save();
    ctx.fillStyle = "rgba(231,238,252,0.95)";
    ctx.font = "600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(opts.title || "Plot", x + 10, y + 18);
    ctx.fillStyle = "rgba(169,182,211,0.90)";
    ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(opts.subtitle || "", x + 10, y + 34);
    ctx.restore();

    // axis mapping
    const xMin = opts.xMin, xMax = opts.xMax;
    const yMin = opts.yMin, yMax = opts.yMax;
    const xLog = !!opts.xLog;

    function X(u){
      if(xLog){
        const a = Math.log10(xMin), b = Math.log10(xMax);
        const uu = (Math.log10(u) - a) / (b - a);
        return gx0 + (gx1 - gx0) * uu;
      }
      return gx0 + (gx1 - gx0) * ((u - xMin) / (xMax - xMin));
    }
    function Y(v){
      return gy1 - (gy1 - gy0) * ((v - yMin) / (yMax - yMin));
    }

    // axes
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.20)";
    ctx.lineWidth = 1.2;
    ctx.beginPath(); ctx.moveTo(gx0, gy0); ctx.lineTo(gx0, gy1); ctx.lineTo(gx1, gy1); ctx.stroke();
    ctx.restore();

    // ticks & labels
    ctx.save();
    ctx.fillStyle = "rgba(169,182,211,0.92)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";

    // y ticks
    const yTicks = 6;
    for(let i=0;i<=yTicks;i++){
      const t = yMin + (yMax-yMin)*i/yTicks;
      const yy = Y(t);
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.beginPath(); ctx.moveTo(gx0-4, yy); ctx.lineTo(gx0, yy); ctx.stroke();
      const label = formatSI(t, 3);
      ctx.fillText(label, x + 8, yy + 4);
    }

    // x ticks
    const xTicks = 8;
    if(xLog){
      // decade ticks between xMin and xMax
      const a = Math.ceil(Math.log10(xMin));
      const b = Math.floor(Math.log10(xMax));
      for(let e=a; e<=b; e++){
        const u = Math.pow(10,e);
        const xx = X(u);
        ctx.strokeStyle = "rgba(255,255,255,0.14)";
        ctx.beginPath(); ctx.moveTo(xx, gy1); ctx.lineTo(xx, gy1+4); ctx.stroke();
        ctx.fillText("1e"+e, xx-12, y + h - 16);
      }
    }else{
      for(let i=0;i<=xTicks;i++){
        const u = xMin + (xMax-xMin)*i/xTicks;
        const xx = X(u);
        ctx.strokeStyle = "rgba(255,255,255,0.14)";
        ctx.beginPath(); ctx.moveTo(xx, gy1); ctx.lineTo(xx, gy1+4); ctx.stroke();
        const label = formatSI(u, 3);
        const tw = ctx.measureText(label).width;
        ctx.fillText(label, xx - tw/2, y + h - 16);
      }
    }
    ctx.restore();

    // axis labels
    ctx.save();
    ctx.fillStyle = "rgba(231,238,252,0.90)";
    ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
    // x label
    const xl = opts.xLabel || "x";
    const xw = ctx.measureText(xl).width;
    ctx.fillText(xl, gx0 + (gx1-gx0)/2 - xw/2, y + h - 2);
    // y label (rotated)
    ctx.translate(x + 14, gy0 + (gy1-gy0)/2);
    ctx.rotate(-Math.PI/2);
    const yl = opts.yLabel || "y";
    const yw = ctx.measureText(yl).width;
    ctx.fillText(yl, -yw/2, 0);
    ctx.restore();

    // series draw
    ctx.save();
    ctx.lineWidth = 2;
    series.forEach(s=>{
      ctx.strokeStyle = s.color || "rgba(125,211,252,0.95)";
      ctx.beginPath();
      let started=false;
      for(let i=0;i<s.data.length;i++){
        const p = s.data[i];
        if(!isFinite(p.x) || !isFinite(p.y)) continue;
        if(xLog && p.x<=0) continue;
        const xx = X(p.x);
        const yy = Y(p.y);
        if(!started){ ctx.moveTo(xx,yy); started=true; }
        else ctx.lineTo(xx,yy);
      }
      ctx.stroke();

      // point marker (optional)
      if(s.marker){
        const pm = s.marker;
        if(isFinite(pm.x) && isFinite(pm.y) && (!xLog || pm.x>0)){
          const xx = X(pm.x), yy = Y(pm.y);
          ctx.fillStyle = s.color || "rgba(125,211,252,0.95)";
          ctx.beginPath(); ctx.arc(xx,yy,4,0,Math.PI*2); ctx.fill();
          ctx.strokeStyle = "rgba(0,0,0,0.35)";
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.lineWidth = 2;
        }
      }
    });
    ctx.restore();

    // legend
    ctx.save();
    const lx = gx0 + 10, ly = gy0 + 10;
    let yy = ly;
    ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
    series.forEach(s=>{
      ctx.fillStyle = s.color || "rgba(125,211,252,0.95)";
      ctx.fillRect(lx, yy-9, 10, 10);
      ctx.fillStyle = "rgba(231,238,252,0.92)";
      ctx.fillText(s.name || "series", lx+14, yy);
      yy += 16;
    });
    ctx.restore();

    // optional vertical marker and threshold
    if(opts.vLine !== undefined){
      const xx = X(opts.vLine);
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(xx, gy0); ctx.lineTo(xx, gy1); ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }
    if(opts.thrLine !== undefined){
      const xx = X(opts.thrLine);
      ctx.save();
      ctx.strokeStyle = "rgba(251,191,36,0.65)";
      ctx.setLineDash([4,6]);
      ctx.beginPath(); ctx.moveTo(xx, gy0); ctx.lineTo(xx, gy1); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(251,191,36,0.9)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillText("threshold ξ=1/τp", clamp(xx+6, gx0+6, gx1-120), gy0+14);
      ctx.restore();
    }
  }

  // ---------- Diagram ----------
  function drawDiagram(ctx, w, h, params, ss){
    clear(ctx, w, h);

    const cx = 14, cy = 14, cw = w-28, ch = h-28;
    // frame
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1.2;
    roundRect(ctx, cx, cy, cw, ch, 18);
    ctx.stroke();
    ctx.restore();

    // cavity outline
    const ymid = cy + ch*0.52;
    const xL = cx + 36;
    const xR = cx + cw - 36;
    const mirrorW = 10, mirrorH = 80;

    // mirrors
    ctx.save();
    ctx.fillStyle = "rgba(231,238,252,0.10)";
    ctx.strokeStyle = "rgba(231,238,252,0.35)";
    ctx.lineWidth = 1.2;
    // left mirror
    roundRect(ctx, xL-mirrorW/2, ymid-mirrorH/2, mirrorW, mirrorH, 6);
    ctx.fill(); ctx.stroke();
    // right mirror
    roundRect(ctx, xR-mirrorW/2, ymid-mirrorH/2, mirrorW, mirrorH, 6);
    ctx.fill(); ctx.stroke();
    ctx.restore();

    // cavity mode line
    ctx.save();
    ctx.strokeStyle = "rgba(125,211,252,0.60)";
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(xL+8, ymid); ctx.lineTo(xR-8, ymid); ctx.stroke();
    ctx.restore();

    // nonlinear crystal block
    const crystW = 70, crystH = 54;
    const crystX = cx + cw*0.55 - crystW/2;
    const crystY = ymid - crystH/2;
    ctx.save();
    ctx.fillStyle = "rgba(167,139,250,0.14)";
    ctx.strokeStyle = "rgba(167,139,250,0.55)";
    ctx.lineWidth = 1.2;
    roundRect(ctx, crystX, crystY, crystW, crystH, 10);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = "rgba(231,238,252,0.92)";
    ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Nonlinear", crystX+8, crystY+20);
    ctx.fillText("crystal", crystX+8, crystY+36);
    ctx.restore();

    // gain medium block (left side)
    const gainW = 86, gainH = 54;
    const gainX = cx + cw*0.30 - gainW/2;
    const gainY = ymid - gainH/2;
    ctx.save();
    ctx.fillStyle = "rgba(134,239,172,0.12)";
    ctx.strokeStyle = "rgba(134,239,172,0.55)";
    ctx.lineWidth = 1.2;
    roundRect(ctx, gainX, gainY, gainW, gainH, 10);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = "rgba(231,238,252,0.92)";
    ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Active medium", gainX+8, gainY+20);
    ctx.fillText("(gain at ν)", gainX+8, gainY+36);
    ctx.restore();

    // arrows for SHG: ν+ν -> 2ν
    const ax = crystX + crystW/2;
    const ay = crystY - 8;
    ctx.save();
    ctx.strokeStyle = "rgba(167,139,250,0.65)";
    ctx.lineWidth = 2;
    arrow(ctx, ax-70, ay, ax-12, ay, 10); // incoming ν
    arrow(ctx, ax-70, ay+18, ax-12, ay+18, 10); // incoming ν
    ctx.strokeStyle = "rgba(125,211,252,0.65)";
    arrow(ctx, ax+12, ay+9, ax+92, ay+9, 10); // outgoing 2ν
    ctx.restore();

    // labels
    ctx.save();
    ctx.fillStyle = "rgba(169,182,211,0.92)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ctx.fillText("ν photons (density n)", ax-160, ay-6);
    ctx.fillText("ν photons (density n)", ax-160, ay+12);
    ctx.fillText("2ν photons (density n₂)", ax+18, ay-6);

    // parameter mini readout
    const ssTxt = ss.on ? "ON" : "OFF";
    const thr = ss.thr;
    ctx.fillStyle = "rgba(231,238,252,0.95)";
    ctx.font = "600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Model: dn/dt = ξn − n/τp − 2ζn²,   dn₂/dt = ζn² − n₂/τp2", cx+12, cy+22);

    ctx.fillStyle = "rgba(169,182,211,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ctx.fillText("ξ = "+formatSI(params.xi,3)+" s⁻¹   ζ = "+formatSI(params.zeta,3)+" m³/s", cx+12, cy+44);
    ctx.fillText("τp = "+formatSI(params.taup,3)+" s   τp2 = "+formatSI(params.taup2,3)+" s   threshold 1/τp = "+formatSI(thr,3)+" s⁻¹", cx+12, cy+62);
    ctx.fillText("steady state: n* = "+formatSI(ss.n,3)+" m⁻³   n₂* = "+formatSI(ss.n2,3)+" m⁻³   ("+ssTxt+")", cx+12, cy+80);

    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function arrow(ctx, x1,y1,x2,y2, head=10){
    const dx = x2-x1, dy = y2-y1;
    const L = Math.hypot(dx,dy) || 1;
    const ux = dx/L, uy = dy/L;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
    // head
    const hx = x2 - ux*head;
    const hy = y2 - uy*head;
    const px = -uy, py = ux;
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(hx + px*head*0.55, hy + py*head*0.55);
    ctx.lineTo(hx - px*head*0.55, hy - py*head*0.55);
    ctx.closePath();
    ctx.fillStyle = ctx.strokeStyle;
    ctx.fill();
  }

  // ---------- UI wiring ----------
  const el = {
    xi: document.getElementById("xi"),
    zeta: document.getElementById("zeta"),
    taup: document.getElementById("taup"),
    taup2: document.getElementById("taup2"),
    sweepMode: document.getElementById("sweepMode"),
    xiVal: document.getElementById("xiVal"),
    zetaVal: document.getElementById("zetaVal"),
    taupVal: document.getElementById("taupVal"),
    taup2Val: document.getElementById("taup2Val"),
    modeVal: document.getElementById("modeVal"),
    diagram: document.getElementById("diagram"),
    plotMain: document.getElementById("plotMain"),
    plotSweep: document.getElementById("plotSweep"),
  };

  function readParams(){
    return {
      xi: parseFloat(el.xi.value),
      zeta: parseFloat(el.zeta.value),
      taup: parseFloat(el.taup.value),
      taup2: parseFloat(el.taup2.value),
      mode: el.sweepMode.value
    };
  }

  function updateLabels(p){
    el.xiVal.textContent = formatSI(p.xi,3);
    el.zetaVal.textContent = formatSI(p.zeta,3);
    el.taupVal.textContent = formatSI(p.taup,3);
    el.taup2Val.textContent = formatSI(p.taup2,3);
    el.modeVal.textContent = (p.mode === "zeta") ? "ζ sweep" : "τp2 sweep";
  }

  // ---------- Plot data generation ----------
  function buildMainPlotData(p){
    const taup = p.taup, taup2 = p.taup2, zeta = p.zeta;
    const thr = 1/taup;

    // Sweep xi from 0 to max (use slider max)
    const xiMax = parseFloat(el.xi.max);
    const nPts = 200;
    const sN = [];
    const sN2 = [];

    for(let i=0;i<=nPts;i++){
      const xi = xiMax * i/nPts;
      const ss = steadyState(xi, zeta, taup, taup2);
      sN.push({x: xi, y: ss.n});
      sN2.push({x: xi, y: ss.n2});
    }

    // y scaling: compute max among series for nice headroom
    let yMax = 0;
    for(const pnt of sN) yMax = Math.max(yMax, pnt.y);
    for(const pnt of sN2) yMax = Math.max(yMax, pnt.y);
    yMax = (yMax<=0) ? 1 : yMax * 1.08;

    return { sN, sN2, yMax, thr, xiMax };
  }

  function buildSweepData(p){
    const taup = p.taup, taup2 = p.taup2, zeta = p.zeta, xi = p.xi;

    if(p.mode === "zeta"){
      const zMin = 1e-11, zMax = 5e-10;
      const nPts = 180;
      const sN = [];
      const sN2 = [];
      for(let i=0;i<=nPts;i++){
        const t = i/nPts;
        const zz = zMin * Math.pow(zMax/zMin, t); // log spacing
        const ss = steadyState(xi, zz, taup, taup2);
        sN.push({x: zz, y: ss.n});
        sN2.push({x: zz, y: ss.n2});
      }
      let yMax = 0;
      for(const q of sN) yMax = Math.max(yMax, q.y);
      for(const q of sN2) yMax = Math.max(yMax, q.y);
      yMax = (yMax<=0) ? 1 : yMax*1.08;
      return { mode:"zeta", sN, sN2, xMin:zMin, xMax:zMax, yMax };
    }else{
      // sweep taup2 linear
      const tMin = 5e-10, tMax = 2e-8;
      const nPts = 200;
      const sN = [];
      const sN2 = [];
      for(let i=0;i<=nPts;i++){
        const tt = tMin + (tMax-tMin)*i/nPts;
        const ss = steadyState(xi, zeta, taup, tt);
        sN.push({x: tt, y: ss.n});
        sN2.push({x: tt, y: ss.n2});
      }
      let yMax = 0;
      for(const q of sN) yMax = Math.max(yMax, q.y);
      for(const q of sN2) yMax = Math.max(yMax, q.y);
      yMax = (yMax<=0) ? 1 : yMax*1.08;
      return { mode:"taup2", sN, sN2, xMin:tMin, xMax:tMax, yMax };
    }
  }

  // ---------- Render ----------
  function renderAll(){
    const p = readParams();
    updateLabels(p);

    const ss = steadyState(p.xi, p.zeta, p.taup, p.taup2);

    // Diagram
    {
      const ctx = setupHiDPI(el.diagram);
      const w = el.diagram.getBoundingClientRect().width;
      const h = el.diagram.getBoundingClientRect().height;
      drawDiagram(ctx, w, h, p, ss);
    }

    // Main plot (n*, n2* vs xi)
    {
      const ctx = setupHiDPI(el.plotMain);
      const w = el.plotMain.getBoundingClientRect().width;
      const h = el.plotMain.getBoundingClientRect().height;
      clear(ctx, w, h);

      const dat = buildMainPlotData(p);
      const marker = steadyState(p.xi, p.zeta, p.taup, p.taup2);

      plotLines(ctx,
        {x:0,y:0,w:w,h:h},
        [
          {name:"n* (ν mode)", data: dat.sN, color:"rgba(125,211,252,0.95)", marker:{x:p.xi, y:marker.n}},
          {name:"n₂* (2ν mode)", data: dat.sN2, color:"rgba(167,139,250,0.92)", marker:{x:p.xi, y:marker.n2}}
        ],
        {
          title:"Steady-state photon densities vs gain ξ (example values)",
          subtitle:"Model: n* = (ξ − 1/τp)/(2ζ) (above threshold),   n₂* = τp2 ζ (n*)²",
          xLabel:"ξ  (s⁻¹)",
          yLabel:"photon density  (m⁻³)",
          xMin: 0,
          xMax: dat.xiMax,
          yMin: 0,
          yMax: dat.yMax,
          vLine: p.xi,
          thrLine: dat.thr
        }
      );
    }

    // Sweep plot
    {
      const ctx = setupHiDPI(el.plotSweep);
      const w = el.plotSweep.getBoundingClientRect().width;
      const h = el.plotSweep.getBoundingClientRect().height;
      clear(ctx, w, h);

      const sw = buildSweepData(p);

      if(sw.mode === "zeta"){
        const marker = steadyState(p.xi, p.zeta, p.taup, p.taup2);
        plotLines(ctx,
          {x:0,y:0,w:w,h:h},
          [
            {name:"n* (ν mode)", data: sw.sN, color:"rgba(125,211,252,0.95)", marker:{x:p.zeta, y:marker.n}},
            {name:"n₂* (2ν mode)", data: sw.sN2, color:"rgba(167,139,250,0.92)", marker:{x:p.zeta, y:marker.n2}}
          ],
          {
            title:"Parameter sweep: effect of SHG strength ζ (fixed ξ)",
            subtitle:"x-axis is logarithmic; stronger ζ clamps n* lower in this simple model",
            xLabel:"ζ  (m³/s)   [log scale]",
            yLabel:"photon density  (m⁻³)",
            xMin: sw.xMin,
            xMax: sw.xMax,
            yMin: 0,
            yMax: sw.yMax,
            xLog: true
          }
        );
      }else{
        const marker = steadyState(p.xi, p.zeta, p.taup, p.taup2);
        plotLines(ctx,
          {x:0,y:0,w:w,h:h},
          [
            {name:"n* (ν mode)", data: sw.sN, color:"rgba(125,211,252,0.95)", marker:{x:p.taup2, y:marker.n}},
            {name:"n₂* (2ν mode)", data: sw.sN2, color:"rgba(167,139,250,0.92)", marker:{x:p.taup2, y:marker.n2}}
          ],
          {
            title:"Parameter sweep: effect of harmonic lifetime τp2 (fixed ξ, ζ)",
            subtitle:"n* is independent of τp2 here, while n₂* grows ~ linearly with τp2",
            xLabel:"τp2  (s)",
            yLabel:"photon density  (m⁻³)",
            xMin: sw.xMin,
            xMax: sw.xMax,
            yMin: 0,
            yMax: sw.yMax
          }
        );
      }
    }
  }

  function addListeners(){
    [el.xi, el.zeta, el.taup, el.taup2, el.sweepMode].forEach(k=>{
      k.addEventListener("input", renderAll);
      k.addEventListener("change", renderAll);
    });
    window.addEventListener("resize", renderAll);
  }

  // init
  wireCopyButtons();
  addListeners();
  renderAll();

})();
</script>
</body>
</html>
