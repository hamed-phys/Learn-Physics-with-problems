<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rate Equations for a Four-Level Laser (with Interactive Plots)</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#101827;
      --panel2:#0f1624;
      --text:#e7ecf5;
      --muted:#a9b4c7;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --ok:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 800px at 10% 0%, rgba(125,211,252,.10), transparent 50%),
        radial-gradient(1000px 700px at 95% 15%, rgba(167,139,250,.10), transparent 55%),
        radial-gradient(900px 700px at 50% 110%, rgba(52,211,153,.08), transparent 55%),
        var(--bg);
      color:var(--text);
      line-height:1.55;
    }

    header{
      padding:34px 18px 18px;
      max-width:1200px;
      margin:0 auto;
    }
    .title{
      display:grid;
      gap:10px;
    }
    h1{
      margin:0;
      font-size:clamp(1.5rem, 2.3vw, 2.4rem);
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      max-width:75ch;
      font-size:1.02rem;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding:0 18px 60px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }

    nav{
      position:sticky;
      top:14px;
      align-self:start;
      background:linear-gradient(180deg, rgba(16,24,39,.88), rgba(16,24,39,.68));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:14px 14px 10px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    nav .toc-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    nav .toc-title b{font-size:.95rem}
    nav a{
      display:block;
      padding:7px 10px;
      border-radius:12px;
      color:var(--muted);
      text-decoration:none;
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, color .12s ease, border-color .12s ease;
      font-size:.92rem;
    }
    nav a:hover{
      background:rgba(125,211,252,.08);
      border-color:rgba(125,211,252,.18);
      color:var(--text);
      transform: translateX(2px);
    }

    article{
      background:linear-gradient(180deg, rgba(16,24,39,.78), rgba(16,24,39,.52));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:18px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }

    section{
      padding:10px 0 6px;
      border-top:1px solid rgba(255,255,255,.08);
      scroll-margin-top:16px;
    }
    section:first-of-type{border-top:none}
    h2{
      margin:0 0 10px;
      font-size:1.25rem;
      letter-spacing:.2px;
    }
    h3{
      margin:16px 0 8px;
      font-size:1.05rem;
      color:rgba(231,236,245,.95);
    }
    p{margin:10px 0; color:rgba(231,236,245,.92)}
    ul{margin:10px 0 10px 20px; color:rgba(231,236,245,.92)}
    li{margin:6px 0}
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
      nav{position:relative; top:0}
      .grid2{grid-template-columns:1fr}
    }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin:12px 0;
    }
    @media (max-width: 980px){
      .callouts{grid-template-columns:1fr}
    }

    .card{
      background:linear-gradient(180deg, rgba(15,22,36,.85), rgba(15,22,36,.55));
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:12px 12px 10px;
    }
    .card .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size:.82rem;
      color:rgba(231,236,245,.88);
      margin-bottom:8px;
      letter-spacing:.2px;
    }
    .dot{
      width:9px;height:9px;border-radius:99px;display:inline-block;
      background:var(--accent);
      box-shadow: 0 0 0 3px rgba(125,211,252,.12);
    }
    .dot.ok{background:var(--ok); box-shadow: 0 0 0 3px rgba(52,211,153,.12);}
    .dot.warn{background:var(--warn); box-shadow: 0 0 0 3px rgba(251,191,36,.12);}
    .dot.bad{background:var(--bad); box-shadow: 0 0 0 3px rgba(251,113,133,.12);}

    .eqbox{
      position:relative;
      margin:12px 0;
      padding:12px 12px 12px;
      border-radius:16px;
      border:1px solid rgba(125,211,252,.18);
      background:rgba(125,211,252,.06);
      overflow:hidden;
    }
    .eqbox pre{
      margin:0;
      white-space:pre-wrap;
      font-family:var(--mono);
      font-size:.92rem;
      line-height:1.45;
      color:rgba(231,236,245,.95);
    }
    .copybtn{
      position:absolute;
      top:10px;
      right:10px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(16,24,39,.65);
      color:var(--text);
      border-radius:12px;
      padding:7px 10px;
      font-size:.82rem;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .copybtn:hover{
      transform: translateY(-1px);
      background:rgba(16,24,39,.85);
      border-color:rgba(125,211,252,.25);
    }
    .copyhint{
      font-size:.84rem;
      color:var(--muted);
      margin-top:8px;
    }

    .vizWrap{
      margin:14px 0 4px;
      display:grid;
      gap:12px;
    }
    figure{
      margin:0;
      background:linear-gradient(180deg, rgba(15,22,36,.85), rgba(15,22,36,.55));
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:12px;
      overflow:hidden;
    }
    figcaption{
      color:var(--muted);
      font-size:.9rem;
      margin-top:8px;
    }
    canvas{
      width:100%;
      height:340px;
      display:block;
      border-radius:14px;
      background:rgba(10,14,22,.55);
      border:1px solid rgba(255,255,255,.08);
    }
    .small canvas{height:300px}

    .controls{
      display:grid;
      grid-template-columns: 1.2fr 1fr 1fr;
      gap:12px;
      margin:10px 0 2px;
      align-items:end;
    }
    @media (max-width: 980px){
      .controls{grid-template-columns:1fr}
    }
    label{
      display:block;
      font-size:.88rem;
      color:rgba(231,236,245,.90);
      margin-bottom:6px;
    }
    .controlCard{
      background:linear-gradient(180deg, rgba(15,22,36,.85), rgba(15,22,36,.55));
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:12px;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    select, input[type="number"]{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(10,14,22,.55);
      color:var(--text);
      outline:none;
    }
    .readout{
      margin-top:8px;
      font-family:var(--mono);
      font-size:.88rem;
      color:rgba(231,236,245,.92);
      display:flex;
      flex-wrap:wrap;
      gap:10px;
    }
    .pill{
      border:1px solid rgba(255,255,255,.12);
      background:rgba(16,24,39,.55);
      padding:6px 8px;
      border-radius:999px;
    }

    .final{
      border:1px solid rgba(52,211,153,.22);
      background:rgba(52,211,153,.08);
    }

    .printNote{display:none}
    @media print{
      body{background:#fff;color:#000}
      nav{display:none}
      header, main{max-width:900px}
      article, figure, .controlCard, .card, .eqbox{box-shadow:none; backdrop-filter:none}
      canvas{border:1px solid #999}
      .printNote{display:block;color:#333;font-size:.9rem;margin-top:10px}
    }

    .shake{
      animation: pop .22s ease;
    }
    @keyframes pop{
      0%{transform:scale(.98)}
      100%{transform:scale(1)}
    }
  </style>
</head>

<body>
<header>
  <div class="title">
    <h1>Rate Equations for a Four-Level Laser (Upper/Lower Laser Levels 2 and 1)</h1>
    <div class="subtitle">
      We derive the coupled population–photon rate equations for a four-level laser and obtain the steady-state inversion
      and photon density. The interactive canvases below visualize inversion clamping and the photon buildup versus pump.
    </div>
  </div>
</header>

<main>
  <nav aria-label="Table of contents">
    <div class="toc-title">
      <b>Table of Contents</b>
      <span class="muted" style="font-size:.82rem">sticky</span>
    </div>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
  </nav>

  <article>
    <!-- QUICK SUMMARY -->
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>Goal:</b> Write rate equations for population densities <b>N₂</b>, <b>N₁</b>, inversion <b>N = N₂ − N₁</b>, and photon number density <b>n</b> in a four-level laser.</li>
        <li><b>Key physics idea:</b> Stimulated emission/absorption couples matter and field through the term <b>g n N</b>, where <b>g = σ(ν) v<sub>g</sub></b> and <b>v<sub>g</sub></b> is the light (group) velocity in the gain medium.</li>
        <li><b>Upper/lower lifetimes:</b> Level 2 decays by spontaneous 2→1 with time <b>τ₂₁</b> and by other loss channels summarized by <b>τ₂</b>; level 1 empties to the ground with <b>τ₁</b>.</li>
        <li><b>Pump constraint:</b> Pump is adjusted so that if stimulated processes are “turned off,” the steady inversion is <b>N₀</b>.</li>
        <li><b>Steady-state result type:</b> Symbolic piecewise steady state (below/above threshold) for <b>N</b> and <b>n</b>.</li>
        <li><b>Laser threshold:</b> When we neglect spontaneous seeding in the cavity mode, lasing occurs once <b>N₀</b> exceeds a threshold inversion <b>N<sub>th</sub> = 1/(σ(ν) v<sub>g</sub> τ<sub>p</sub>)</b>.</li>
      </ul>
    </section>

    <!-- PART 0 -->
    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="callouts">
        <div class="card">
          <div class="tag"><span class="dot"></span><b>Core definitions (symbols & units)</b></div>
          <ul>
            <li><b>N₂</b>, <b>N₁</b> — population densities in upper/lower laser levels (m⁻³ or cm⁻³).</li>
            <li><b>N = N₂ − N₁</b> — population inversion density (same units as N₂).</li>
            <li><b>n</b> — photon number density in the lasing mode (m⁻³ or cm⁻³).</li>
            <li><b>σ(ν)</b> — stimulated transition cross section at optical frequency ν (m²).</li>
            <li><b>v<sub>g</sub></b> — light speed in the medium (m/s). Often ≈ c/n<sub>r</sub>.</li>
            <li><b>τ₂₁</b> — spontaneous lifetime for the lasing transition 2 → 1 (s).</li>
            <li><b>τ₂</b> — effective lifetime for other depopulation paths out of level 2 (s).</li>
            <li><b>τ₁</b> — lower-level lifetime to the ground (s).</li>
            <li><b>τ<sub>sp</sub></b> — fast relaxation from pump level to upper laser level (s) (four-level structure detail).</li>
            <li><b>τ<sub>p</sub></b> — photon lifetime in the cavity (s) (loss time constant).</li>
          </ul>
        </div>

        <div class="card">
          <div class="tag"><span class="dot ok"></span><b>Physical meaning</b></div>
          <ul>
            <li><b>N₂</b> stores energy (excited atoms/ions). Increasing N₂ increases gain.</li>
            <li><b>N₁</b> is the “bottleneck” that would cause reabsorption if it gets large; a four-level laser makes τ₁ short so N₁ stays small.</li>
            <li><b>n</b> measures how many photons are in the lasing mode per volume; it grows when gain exceeds loss.</li>
            <li><b>σ(ν) v<sub>g</sub> n</b> is proportional to photon flux times cross section → a <i>stimulated transition rate</i> per particle (s⁻¹).</li>
            <li><b>τ<sub>p</sub></b> converts cavity loss into a simple decay term: photons leak out/are absorbed at rate n/τ<sub>p</sub>.</li>
          </ul>
        </div>
      </div>

      <h3>Key laws/principles (and validity)</h3>
      <ul>
        <li><b>Rate-equation (population) model:</b> Treats transitions as incoherent with well-defined lifetimes; valid when phase coherence is not tracked (class B/C lasers), and when populations vary slowly compared to optical period.</li>
        <li><b>Stimulated emission/absorption:</b> Net stimulated rate ∝ photon density × inversion: <b>g n N</b>, where <b>g = σ(ν) v<sub>g</sub></b>.</li>
        <li><b>Cavity losses as a lifetime:</b> If losses are linear, photon number decays exponentially with time constant τ<sub>p</sub>.</li>
      </ul>

      <h3>Common models/approximations (why we use them)</h3>
      <ul>
        <li><b>Four-level reduction:</b> The pump level relaxes quickly (τ<sub>sp</sub> small), so the pump effectively injects population into level 2.</li>
        <li><b>Single-mode photon density:</b> Use one <b>n</b> for the lasing mode; multimode effects are ignored.</li>
        <li><b>Neglect spontaneous seeding (optional):</b> For clean threshold physics, we may omit spontaneous emission into the lasing mode in dn/dt. (You can add it later via a β factor.)</li>
      </ul>

      <h3>Mini intuition examples</h3>
      <ul>
        <li><b>If n = 0:</b> No stimulated processes occur; inversion tends to the pump-set value N₀ (by problem statement).</li>
        <li><b>If n is large:</b> Stimulated emission drains N₂ and fills n until gain “self-adjusts” so that net gain equals cavity loss — this is inversion clamping.</li>
      </ul>

      <div class="card">
        <div class="tag"><span class="dot warn"></span><b>What to watch for (pitfalls)</b></div>
        <ul>
          <li>Confusing optical frequency <b>ν</b> (in σ(ν)) with velocity; keep <b>v<sub>g</sub></b> (speed) separate.</li>
          <li>Forgetting that <b>stimulated absorption</b> is included automatically via the <b>N₂ − N₁</b> difference.</li>
          <li>Mixing units (cm⁻³ vs m⁻³). Use one system consistently.</li>
          <li>Including spontaneous photons in dn/dt changes “threshold” behavior (it removes the strictly zero-photon solution).</li>
        </ul>
      </div>
    </section>

    <!-- PART 1 -->
    <section id="part1">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Restate the problem (in plain words)</h3>
      <p>
        We have a four-level laser medium (active volume given but we work with densities). The upper laser level is <b>2</b>
        with population density <b>N₂</b>, the lower laser level is <b>1</b> with population density <b>N₁</b>.
        The inversion is <b>N = N₂ − N₁</b>. The cavity has photon number density <b>n</b> and photon lifetime <b>τ<sub>p</sub></b>.
        The pump is adjusted such that, if we ignore stimulated emission and absorption, the steady inversion would be <b>N₀</b>.
        We must write the coupled rate equations in terms of <b>N₀</b>, <b>σ(ν)</b>, and the times <b>τ<sub>sp</sub></b>, <b>τ₁</b>, <b>τ₂</b>, <b>τ₂₁</b>, <b>τ<sub>p</sub></b>, and then find steady-state <b>N</b> and <b>n</b>.
      </p>

      <div class="grid2">
        <div class="card">
          <div class="tag"><span class="dot"></span><b>Given</b></div>
          <ul>
            <li>Active volume (not essential for density equations).</li>
            <li>Laser levels: upper <b>2</b>, lower <b>1</b>, inversion <b>N = N₂ − N₁</b>.</li>
            <li>Photon density <b>n</b>, photon lifetime <b>τ<sub>p</sub></b>.</li>
            <li>Cross section <b>σ(ν)</b>, times <b>τ<sub>sp</sub></b>, <b>τ₁</b>, <b>τ₂</b>, <b>τ₂₁</b>.</li>
            <li>Pump is set so that (with stimulated terms removed) <b>N → N₀</b> at steady state.</li>
          </ul>
        </div>

        <div class="card">
          <div class="tag"><span class="dot ok"></span><b>Unknowns to solve for</b></div>
          <ul>
            <li>Time-dependent rate equations for <b>N₂(t)</b>, <b>N₁(t)</b>, <b>N(t)</b>, <b>n(t)</b>.</li>
            <li>Steady-state values <b>N̄</b> and <b>n̄</b>.</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles and why they apply</h3>
      <ul>
        <li><b>Population rate equations</b> apply because we track incoherent transitions among discrete levels using lifetimes.</li>
        <li><b>Stimulated interaction term</b> must involve σ(ν) and photon flux; photon flux in the mode is <b>Φ = v<sub>g</sub> n</b> (photons·m⁻²·s⁻¹), so stimulated rate per particle is <b>σ(ν) Φ = σ(ν) v<sub>g</sub> n</b>.</li>
        <li><b>Photon lifetime model</b> applies because cavity losses are treated as a linear decay: <b>dn/dt = (gain) − n/τ<sub>p</sub></b>.</li>
      </ul>

      <div class="card">
        <div class="tag"><span class="dot warn"></span><b>Assumptions (explicit)</b></div>
        <ul>
          <li>Single effective lasing mode described by <b>n</b> (spatial uniformity in the active volume).</li>
          <li>Homogeneous gain medium; σ(ν) is treated constant at the laser frequency.</li>
          <li>Stimulated emission/absorption rate coefficient <b>g = σ(ν) v<sub>g</sub></b>.</li>
          <li>We derive a clean threshold result by <b>neglecting spontaneous emission into the lasing mode</b> in dn/dt (can be added later with a β factor).</li>
          <li>τ<sub>sp</sub> describes rapid pump-level relaxation; it affects pump dynamics but can be adiabatically eliminated if fast.</li>
        </ul>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ul>
        <li><b>Approach A: Full four-level system (include pump level explicitly)</b> — most detailed; shows where τ<sub>sp</sub> enters; algebra heavier.</li>
        <li><b>Approach B: Reduced model (effective pump into level 2)</b> — simplest; uses the problem’s condition “N → N₀ when stimulated terms are off” to eliminate the pump rate; best for steady-state analysis.</li>
        <li><b>Approach C: Work directly with inversion N and photon density n</b> — fastest to get the steady-state and threshold; then reconstruct N₂ and N₁ if needed.</li>
      </ul>
      <p><b>Choice:</b> We use <b>Approach B + C</b>: write N₂ and N₁ equations with an effective pump term, then eliminate the pump rate using the given condition to express everything in terms of <b>N₀</b>.</p>
    </section>

    <!-- PART 2 -->
    <section id="part2">
      <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

      <ol>
        <li><b>Define the stimulated rate coefficient</b> <span class="muted">(goal: connect σ(ν) and n)</span>:
          use photon flux Φ = v<sub>g</sub> n, so g = σ(ν) v<sub>g</sub>.</li>
        <li><b>Write dN₂/dt</b> <span class="muted">(goal: balance pump, spontaneous losses, stimulated loss/gain)</span>:
          pump into level 2 minus depopulation by τ₂, τ₂₁, and stimulated term g n (N₂ − N₁).</li>
        <li><b>Write dN₁/dt</b> <span class="muted">(goal: track lower-level filling/emptying)</span>:
          gains from 2→1 spontaneous plus stimulated term, and loss by τ₁.</li>
        <li><b>Form dN/dt</b> from d(N₂ − N₁)/dt <span class="muted">(goal: compact inversion equation)</span>.</li>
        <li><b>Write dn/dt</b> <span class="muted">(goal: gain minus cavity loss)</span>:
          dn/dt = g n N − n/τ<sub>p</sub> (optionally +βN₂/τ₂₁ if you include spontaneous seeding).</li>
        <li><b>Use the pump constraint</b> <span class="muted">(goal: eliminate unknown pump rate)</span>:
          set n=0, stimulated terms off → steady inversion equals N₀ to solve for the pump term.</li>
        <li><b>Solve steady state</b> <span class="muted">(goal: get N̄ and n̄)</span>:
          either n̄=0 with N̄=N₀ (below threshold), or N̄ = 1/(g τ<sub>p</sub>) with n̄ from the inversion equation (above threshold).</li>
        <li><b>Sanity checks</b> <span class="muted">(goal: trust the result)</span>:
          verify units, verify inversion clamping, check limits τ₁ → 0 (ideal four-level).</li>
      </ol>

      <div class="card">
        <div class="tag"><span class="dot bad"></span><b>Common mistakes & quick tips</b></div>
        <ul>
          <li><b>Mistake:</b> using σ(ν) n instead of σ(ν) v<sub>g</sub> n. <b>Tip:</b> σ × (photon flux) must have units s⁻¹.</li>
          <li><b>Mistake:</b> forgetting absorption. <b>Tip:</b> the net stimulated term always depends on <b>N = N₂ − N₁</b>.</li>
          <li><b>Mistake:</b> declaring “threshold” while including a spontaneous source in dn/dt. <b>Tip:</b> spontaneous seeding makes n never exactly zero.</li>
        </ul>
      </div>
    </section>

    <!-- PART 3 -->
    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Qualitative expectation (before math)</h3>
      <p>
        With weak pumping, the cavity has essentially no photons (n ≈ 0), so the inversion simply rises to the pump-set value N₀.
        Once pumping is strong enough, stimulated emission quickly converts stored inversion into photons.
        Above threshold, the laser “self-regulates”: <b>inversion clamps</b> near a threshold value determined by cavity loss (τ<sub>p</sub>) and gain strength (σ(ν)).
      </p>

      <h3>Step 1: Define the stimulated rate coefficient</h3>
      <p>
        Photon number density in the lasing mode is <b>n</b> (photons·m⁻³). The photon flux (photons·m⁻²·s⁻¹) is
        <b>Φ = v<sub>g</sub> n</b>, where v<sub>g</sub> is the light speed in the medium.
        A stimulated transition rate per particle is cross section × flux:
      </p>

      <div class="eqbox" id="eq_g">
        <button class="copybtn" data-copy="#eq_g pre">Copy</button>
        <pre>g ≡ σ(ν) v_g       [units: (m²)(m/s) = m³/s]</pre>
      </div>

      <p>
        Then <b>g n</b> has units s⁻¹, and <b>g n (N₂ − N₁)</b> has units (m⁻³·s⁻¹), consistent with population-rate terms.
      </p>

      <h3>Step 2: Population rate equations for N₂ and N₁</h3>
      <p>
        We use a reduced four-level picture: pumping ultimately injects population into level 2 (after the fast pump relaxation characterized by τ<sub>sp</sub>).
        We represent that injection by an effective pump rate density <b>R</b> (m⁻³·s⁻¹).
        Level 2 depopulates by:
        (i) non-lasing loss channels with time τ₂, (ii) spontaneous lasing-transition decay with τ₂₁, and (iii) stimulated net transitions with rate g n (N₂ − N₁).
      </p>

      <div class="eqbox" id="eq_N2N1">
        <button class="copybtn" data-copy="#eq_N2N1 pre">Copy</button>
        <pre>dN2/dt = R  - N2/τ2 - N2/τ21 - g n (N2 - N1)
dN1/dt =      + N2/τ21 + g n (N2 - N1) - N1/τ1</pre>
      </div>

      <p>
        <b>What did we do and why?</b> We wrote a gain–loss balance for each level.
        The stimulated term appears with opposite signs: it removes population from level 2 and adds it to level 1.
        Absorption is included automatically: if N is negative, the net stimulated term reverses.
      </p>

      <div class="card">
        <div class="tag"><span class="dot warn"></span><b>Where τ<sub>sp</sub> fits</b></div>
        <p class="muted">
          In a fully explicit four-level model you would include a pump level (say level 3) with
          dN3/dt = R_pump − N3/τ_sp and an additional +N3/τ_sp term in dN2/dt.
          If τ_sp is fast, the pump level follows adiabatically and simply produces an effective injection R into level 2.
          In this reduced model, τ_sp is “hidden” inside how R depends on the pump hardware.
          The problem’s given condition (steady inversion = N0 when stimulated is off) lets us eliminate R without needing pump-level details.
        </p>
      </div>

      <h3>Step 3: Inversion rate equation dN/dt</h3>
      <p>
        Define <b>N ≡ N₂ − N₁</b>. Subtract the second equation from the first:
      </p>

      <div class="eqbox" id="eq_inv">
        <button class="copybtn" data-copy="#eq_inv pre">Copy</button>
        <pre>Let N = N2 - N1.

dN/dt = dN2/dt - dN1/dt
     = R - N2/τ2 - N2/τ21 - g n (N2 - N1)  - [ N2/τ21 + g n (N2 - N1) - N1/τ1 ]

     = R - N2/τ2 - 2 N2/τ21 + N1/τ1 - 2 g n N</pre>
      </div>

      <p>
        <b>Interpretation:</b> Pump increases inversion; spontaneous/other decays and stimulated emission reduce it.
        The factor <b>2 g n N</b> appears because stimulated transitions remove one from N₂ and add one to N₁, changing N by −2 per stimulated event.
      </p>

      <h3>Step 4: Photon density rate equation dn/dt</h3>
      <p>
        In the simplest “threshold” model, photons grow by stimulated emission at rate g n N and decay by cavity losses with lifetime τ<sub>p</sub>.
        (You can optionally add a spontaneous seeding term +β N₂/τ₂₁, but we omit it to keep a clean n=0 below-threshold solution.)
      </p>

      <div class="eqbox" id="eq_ph">
        <button class="copybtn" data-copy="#eq_ph pre">Copy</button>
        <pre>dn/dt = g n N - n/τp</pre>
      </div>

      <h3>Step 5: Eliminate the pump rate R using the problem’s condition (defines N₀)</h3>
      <p>
        The statement “the pumping rate is such that the steady-state inversion in the absence of stimulated emission and absorption is N₀”
        means: set stimulated coupling to zero (n=0 so g n terms vanish), then the steady solution should satisfy N = N₀.
        In practice, that determines R in terms of N₀ and the level lifetimes.
      </p>

      <p class="muted">
        To do this cleanly, we use the steady-state of the population equations with n=0:
      </p>

      <div class="eqbox" id="eq_RfromN0">
        <button class="copybtn" data-copy="#eq_RfromN0 pre">Copy</button>
        <pre>Set n = 0 (no stimulated terms).

0 = dN2/dt = R - N2/τ2 - N2/τ21
0 = dN1/dt =      + N2/τ21 - N1/τ1

From the second:  N1 = (τ1/τ21) N2
So inversion:      N = N2 - N1 = N2(1 - τ1/τ21)

Thus N2 = N / (1 - τ1/τ21)

Insert into first:
R = N2(1/τ2 + 1/τ21) = [N/(1 - τ1/τ21)](1/τ2 + 1/τ21)

Pump condition (steady N = N0 when n=0) gives:
R = [N0/(1 - τ1/τ21)](1/τ2 + 1/τ21)</pre>
      </div>

      <p>
        <b>What did we do and why?</b> We used the fact that, without stimulated processes, the populations are governed only by the pump and lifetimes.
        The pump rate density R is then fixed by demanding the inversion equal N₀ in steady state.
      </p>

      <h3>Step 6: Steady-state solutions for N̄ and n̄ (piecewise)</h3>
      <p>
        In steady state, dn/dt = 0 implies:
      </p>

      <div class="eqbox" id="eq_dn0">
        <button class="copybtn" data-copy="#eq_dn0 pre">Copy</button>
        <pre>0 = dn/dt = g n N - n/τp
⇒ n (g N - 1/τp) = 0

So either:
(1) n = 0   (nonlasing / below-threshold solution), or
(2) N = 1/(g τp) ≡ N_th   (lasing solution with inversion clamping)</pre>
      </div>

      <p>
        Now we find n̄ for the lasing solution by using the steady-state inversion relation from the populations.
        Using the N₂/N₁ steady relations with finite n gives (derivation kept transparent in the next box):
      </p>

      <div class="eqbox" id="eq_N_vs_n">
        <button class="copybtn" data-copy="#eq_N_vs_n pre">Copy</button>
        <pre>Steady-state population relations with finite n:

From dN1/dt = 0:
0 = N2/τ21 + g n (N2 - N1) - N1/τ1
⇒ N1 = τ1 [N2/τ21 + g n (N2 - N1)]

Solve for N in terms of N2:
N = N2 - N1 = N2(1 - τ1/τ21) / (1 + τ1 g n)

So N2 = N (1 + τ1 g n)/(1 - τ1/τ21)

Then from dN2/dt = 0:
0 = R - N2/τ2 - N2/τ21 - g n N
⇒ R = N2(1/τ2 + 1/τ21) + g n N

Using R fixed by the pump condition (R corresponds to N0),
define:
A ≡ (1/τ2 + 1/τ21) / (1 - τ1/τ21)

Then algebra gives:
N = (A N0) / [A + g n (1 + A τ1)]</pre>
      </div>

      <p>
        <b>Below threshold:</b> choose the n=0 branch → immediately N̄ = N₀ and n̄ = 0.
        <b>Above threshold:</b> choose the clamped inversion branch N̄ = N<sub>th</sub> = 1/(g τ<sub>p</sub>) and solve for n̄:
      </p>

      <div class="eqbox final" id="final_answer">
        <button class="copybtn" data-copy="#final_answer pre">Copy</button>
        <pre>Define g = σ(ν) v_g
Define A = (1/τ2 + 1/τ21) / (1 - τ1/τ21)
Threshold inversion: N_th = 1/(g τp)

Steady state (neglect spontaneous seeding in dn/dt):

• If N0 ≤ N_th  (below threshold):
  N̄ = N0
  n̄ = 0

• If N0 > N_th  (lasing / above threshold):
  N̄ = N_th
  n̄ = [A / (g (1 + A τ1))] (g τp N0 - 1)</pre>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><b>Units:</b> g has units m³/s, so g n has s⁻¹, and N<sub>th</sub> = 1/(g τ<sub>p</sub>) has units m⁻³. Good.</li>
        <li><b>Limiting case τ₁ → 0 (ideal four-level):</b> A → (1/τ₂ + 1/τ₂₁), and n̄ → (A/g)(g τ<sub>p</sub> N₀ − 1). Lower level empties instantly, so absorption is minimized.</li>
        <li><b>Inversion clamping:</b> For N₀ > N<sub>th</sub>, N̄ is fixed at N<sub>th</sub> while n̄ grows linearly with pump parameter N₀. This matches standard laser physics.</li>
        <li><b>Physical interpretation:</b> Above threshold, extra pump power no longer raises inversion; it is converted into photons.</li>
      </ul>

      <p class="printNote">
        Print tip: the interactive canvases won’t animate on paper; use the “Copy” buttons to save equations and final results.
      </p>

      <!-- VISUALIZATION BLOCK -->
      <div class="vizWrap">
        <div class="controls" aria-label="Interactive controls">
          <div class="controlCard">
            <label for="pumpSlider">Pump-set inversion parameter N₀ (example units: m⁻³)</label>
            <input id="pumpSlider" type="range" min="0" max="6e19" step="1e17" value="2.5e19" />
            <div class="readout" id="pumpReadout"></div>
          </div>
          <div class="controlCard">
            <label for="tauP">Photon lifetime τ<sub>p</sub> (s) — changes threshold</label>
            <input id="tauP" type="range" min="1e-9" max="3e-8" step="1e-9" value="5e-9" />
            <div class="readout" id="tauPReadout"></div>
          </div>
          <div class="controlCard">
            <label for="sigmaSel">Stimulated cross section σ(ν) (example)</label>
            <select id="sigmaSel">
              <option value="1e-20">1×10⁻²⁰ m²</option>
              <option value="3e-20" selected>3×10⁻²⁰ m²</option>
              <option value="1e-19">1×10⁻¹⁹ m²</option>
              <option value="3e-19">3×10⁻¹⁹ m²</option>
            </select>
            <div class="readout" id="sigmaReadout"></div>
          </div>
        </div>

        <figure class="small">
          <canvas id="diagramCanvas" aria-label="Four-level laser diagram"></canvas>
          <figcaption>
            Labeled four-level structure: pump to level 3, fast relaxation (τ<sub>sp</sub>) to upper laser level 2, lasing transition 2→1 with σ(ν),
            lower-level decay (τ₁) to ground. (Diagram is conceptual, not to scale.)
          </figcaption>
        </figure>

        <figure>
          <canvas id="mainPlot" aria-label="Main plot: photon density vs pump parameter"></canvas>
          <figcaption>
            Main plot: steady-state photon density <b>n̄</b> versus pump-set inversion <b>N₀</b>. Below threshold n̄ = 0; above threshold it grows linearly.
          </figcaption>
        </figure>

        <figure>
          <canvas id="secondaryPlot" aria-label="Secondary plot: inversion vs pump parameter"></canvas>
          <figcaption>
            Secondary plot: steady-state inversion <b>N̄</b> versus <b>N₀</b>. Note inversion clamping at <b>N<sub>th</sub></b> above threshold.
          </figcaption>
        </figure>
      </div>
    </section>

    <!-- PART 4 -->
    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpret the final formulas</h3>
      <ul>
        <li><b>N<sub>th</sub> = 1/(σ(ν) v<sub>g</sub> τ<sub>p</sub>)</b>:
          threshold inversion decreases if you increase σ(ν) (stronger coupling) or increase τ<sub>p</sub> (lower cavity loss).</li>
        <li><b>A = (1/τ₂ + 1/τ₂₁)/(1 − τ₁/τ₂₁)</b>:
          this “effective inversion relaxation rate” grows if the upper level is short-lived (small τ₂ or τ₂₁),
          and it grows if the lower level is not emptied quickly (τ₁ not ≪ τ₂₁), because that increases reabsorption.</li>
        <li><b>n̄ ∝ (g τ<sub>p</sub> N₀ − 1)</b> above threshold:
          n̄ increases linearly with the “excess pump” above threshold.</li>
      </ul>

      <h3>How parameters affect the outcome (connect to the plots)</h3>
      <ul>
        <li>Increase <b>τ<sub>p</sub></b> (better cavity): threshold shifts left (smaller N<sub>th</sub>), so lasing occurs at lower N₀.</li>
        <li>Increase <b>σ(ν)</b>: same effect—lower threshold and stronger slope of n̄ vs N₀.</li>
        <li>Increase <b>τ₁</b> (worse four-level behavior): denominator (1 + A τ₁) increases, reducing photon buildup slope (more energy stuck in lower level → more absorption).</li>
      </ul>

      <h3>Alternative derivation idea</h3>
      <p>
        You can derive the same steady state using the <b>gain equals loss</b> condition: in steady state above threshold,
        the net modal gain coefficient is <b>gN</b> and must match the cavity loss rate <b>1/τ<sub>p</sub></b>.
        That immediately gives N = N<sub>th</sub>. Then you back-substitute into the inversion equation to find n̄.
      </p>

      <h3>Concept checks (with answers)</h3>
      <ul>
        <li><b>Q:</b> Why does inversion clamp above threshold? <b>A:</b> Because once gN exceeds 1/τ<sub>p</sub>, photons grow rapidly and stimulated emission drains N₂ until gN = 1/τ<sub>p</sub> again.</li>
        <li><b>Q:</b> Where is absorption in the equations? <b>A:</b> It is included in g n (N₂ − N₁): if N₁ becomes comparable to N₂, the net stimulated term shrinks or becomes negative.</li>
        <li><b>Q:</b> Why do four-level lasers have low threshold? <b>A:</b> τ₁ is very short, so N₁ ≈ 0 and the medium behaves like a near-ideal inverted system (minimal reabsorption).</li>
        <li><b>Q:</b> What changes if we include spontaneous emission into the mode? <b>A:</b> dn/dt gains a small +βN₂/τ₂₁ term, so n̄ is never exactly zero and “threshold” becomes a smooth turn-on.</li>
      </ul>
    </section>

    <!-- PART 5 -->
    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <h3>What each canvas shows</h3>
      <ul>
        <li><b>Diagram canvas:</b> A conceptual four-level energy diagram with labeled lifetimes τ<sub>sp</sub>, τ₂₁, τ₁ and the stimulated coupling σ(ν) via the laser transition 2→1.</li>
        <li><b>Main plot (n̄ vs N₀):</b> Steady photon density as a function of the pump-set inversion parameter N₀. The vertical dashed line marks N<sub>th</sub>.</li>
        <li><b>Secondary plot (N̄ vs N₀):</b> Inversion increases as N̄=N₀ below threshold, then clamps to N<sub>th</sub> above threshold.</li>
      </ul>

      <h3>Interactive controls</h3>
      <ul>
        <li><b>N₀ slider:</b> Changes the pump-set inversion parameter. You should see (i) the operating point move along both plots, and (ii) n̄ switch from zero to linear growth once N₀ exceeds N<sub>th</sub>.</li>
        <li><b>τ<sub>p</sub> slider:</b> Changes cavity photon lifetime. Increasing τ<sub>p</sub> reduces loss, decreasing N<sub>th</sub>, shifting the threshold left in both plots.</li>
        <li><b>σ(ν) selector:</b> Changes the gain strength. Larger σ(ν) lowers N<sub>th</sub> and increases the slope of n̄ above threshold.</li>
      </ul>
    </section>

    <footer class="muted" style="border-top:1px solid rgba(255,255,255,.08); padding-top:12px; margin-top:10px;">
      Built with vanilla HTML/CSS/JS — equations are plain text (copyable) and plots are drawn on &lt;canvas&gt;.
    </footer>
  </article>
</main>

<script>
(function(){
  // ---------- Utilities ----------
  const $ = (sel)=>document.querySelector(sel);

  function fmtSci(x, sig=3){
    if (!isFinite(x)) return "—";
    if (x === 0) return "0";
    const exp = Math.floor(Math.log10(Math.abs(x)));
    const mant = x / Math.pow(10, exp);
    const m = mant.toFixed(Math.max(0, sig-1));
    return `${m}×10^${exp}`;
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function setHiDPICanvas(canvas){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(2, Math.round(rect.width * dpr));
    const h = Math.max(2, Math.round(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
    }
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return ctx;
  }

  function niceTicks(min, max, n=6){
    const span = max - min;
    if (span <= 0) return [min];
    const raw = span / (n-1);
    const pow = Math.pow(10, Math.floor(Math.log10(raw)));
    const steps = [1,2,5,10].map(k=>k*pow);
    let step = steps[0];
    for (const s of steps){
      if (Math.abs(raw - s) < Math.abs(raw - step)) step = s;
    }
    const start = Math.ceil(min/step)*step;
    const ticks = [];
    for (let v=start; v<=max+1e-12; v+=step) ticks.push(v);
    return ticks;
  }

  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
    const {x,y,w,h} = box;

    // background
    ctx.save();
    ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
    ctx.fillStyle = "rgba(10,14,22,.25)";
    ctx.fillRect(0,0, ctx.canvas.width, ctx.canvas.height);

    // panel
    ctx.fillStyle = "rgba(10,14,22,.35)";
    ctx.fillRect(x,y,w,h);

    // title
    ctx.fillStyle = "rgba(231,236,245,.95)";
    ctx.font = "600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(title, x, y-12);

    // ticks
    const xTicks = niceTicks(xMin, xMax, 6);
    const yTicks = niceTicks(yMin, yMax, 6);

    // gridlines
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(255,255,255,.08)";
    ctx.beginPath();
    for (const xv of xTicks){
      const px = x + (xv - xMin)/(xMax - xMin) * w;
      ctx.moveTo(px, y);
      ctx.lineTo(px, y+h);
    }
    for (const yv of yTicks){
      const py = y + h - (yv - yMin)/(yMax - yMin) * h;
      ctx.moveTo(x, py);
      ctx.lineTo(x+w, py);
    }
    ctx.stroke();

    // axes border
    ctx.strokeStyle = "rgba(255,255,255,.18)";
    ctx.strokeRect(x,y,w,h);

    // tick labels
    ctx.fillStyle = "rgba(231,236,245,.82)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";

    // x labels
    for (const xv of xTicks){
      const px = x + (xv - xMin)/(xMax - xMin) * w;
      ctx.fillText(fmtSci(xv,3), px-18, y+h+18);
      // tick mark
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.beginPath(); ctx.moveTo(px, y+h); ctx.lineTo(px, y+h+6); ctx.stroke();
    }
    // y labels
    for (const yv of yTicks){
      const py = y + h - (yv - yMin)/(yMax - yMin) * h;
      ctx.fillText(fmtSci(yv,3), x-70, py+4);
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.beginPath(); ctx.moveTo(x-6, py); ctx.lineTo(x, py); ctx.stroke();
    }

    // axis labels
    ctx.fillStyle = "rgba(231,236,245,.92)";
    ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(xLabel, x + w/2 - ctx.measureText(xLabel).width/2, y+h+42);

    ctx.save();
    ctx.translate(x-92, y + h/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
    ctx.restore();

    ctx.restore();

    return {xTicks, yTicks};
  }

  function plotLine(ctx, box, xMin, xMax, yMin, yMax, xs, ys){
    const {x,y,w,h} = box;
    ctx.save();
    ctx.strokeStyle = "rgba(125,211,252,.95)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i=0;i<xs.length;i++){
      const px = x + (xs[i]-xMin)/(xMax-xMin)*w;
      const py = y + h - (ys[i]-yMin)/(yMax-yMin)*h;
      if (i===0) ctx.moveTo(px,py);
      else ctx.lineTo(px,py);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawVLine(ctx, box, xMin, xMax, xv, label){
    const {x,y,w,h} = box;
    const px = x + (xv-xMin)/(xMax-xMin)*w;
    ctx.save();
    ctx.strokeStyle = "rgba(251,191,36,.85)";
    ctx.setLineDash([6,6]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(px,y);
    ctx.lineTo(px,y+h);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = "rgba(251,191,36,.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ctx.fillText(label, px+6, y+14);
    ctx.restore();
  }

  function drawMarker(ctx, box, xMin, xMax, yMin, yMax, xVal, yVal){
    const {x,y,w,h} = box;
    const px = x + (xVal-xMin)/(xMax-xMin)*w;
    const py = y + h - (yVal-yMin)/(yMax-yMin)*h;
    ctx.save();
    ctx.fillStyle = "rgba(52,211,153,.95)";
    ctx.strokeStyle = "rgba(52,211,153,.35)";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.arc(px, py, 5.5, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // ---------- Physics model (example values for plotting) ----------
  // Example constants (editable via UI):
  let vg = 2.0e8;         // m/s (example group velocity)
  let tau1 = 1.0e-9;      // s (example lower-level lifetime)
  let tau2 = 5.0e-6;      // s (example nonlasing loss lifetime out of level 2)
  let tau21 = 1.0e-6;     // s (example spontaneous 2->1 lifetime)
  let tauSp = 1.0e-9;     // s (pump relaxation) used in diagram and discussion
  // tauP and sigma updated from UI

  function computeA(){
    // A = (1/τ2 + 1/τ21) / (1 - τ1/τ21)
    const denom = (1 - tau1/tau21);
    return (1/tau2 + 1/tau21) / denom;
  }

  function steadyState(N0, sigma, tauP){
    // g = sigma * vg
    const g = sigma * vg;
    const A = computeA();
    const Nth = 1/(g * tauP);

    let Nbar, nbar;
    if (N0 <= Nth){
      Nbar = N0;
      nbar = 0;
    } else {
      Nbar = Nth;
      nbar = (A / (g * (1 + A * tau1))) * (g * tauP * N0 - 1);
      nbar = Math.max(0, nbar);
    }
    return {g, A, Nth, Nbar, nbar};
  }

  // ---------- Canvases ----------
  const cDiag = $("#diagramCanvas");
  const cMain = $("#mainPlot");
  const cSec  = $("#secondaryPlot");

  // ---------- UI ----------
  const pumpSlider = $("#pumpSlider");
  const tauPSlider = $("#tauP");
  const sigmaSel   = $("#sigmaSel");

  const pumpReadout = $("#pumpReadout");
  const tauPReadout = $("#tauPReadout");
  const sigmaReadout = $("#sigmaReadout");

  function updateReadouts(state, N0, sigma, tauP){
    pumpReadout.innerHTML = `
      <span class="pill">N0 = ${fmtSci(N0,3)} m⁻³</span>
      <span class="pill">N̄ = ${fmtSci(state.Nbar,3)} m⁻³</span>
      <span class="pill">n̄ = ${fmtSci(state.nbar,3)} m⁻³</span>
      <span class="pill">N_th = ${fmtSci(state.Nth,3)} m⁻³</span>
    `;
    tauPReadout.innerHTML = `
      <span class="pill">τp = ${fmtSci(tauP,3)} s</span>
      <span class="pill">1/τp = ${fmtSci(1/tauP,3)} s⁻¹</span>
    `;
    sigmaReadout.innerHTML = `
      <span class="pill">σ(ν) = ${fmtSci(sigma,3)} m²</span>
      <span class="pill">v_g = ${fmtSci(vg,3)} m/s</span>
      <span class="pill">g = σ v_g = ${fmtSci(state.g,3)} m³/s</span>
    `;
  }

  // ---------- Draw diagram ----------
  function drawDiagram(){
    const ctx = setHiDPICanvas(cDiag);
    const W = cDiag.getBoundingClientRect().width;
    const H = cDiag.getBoundingClientRect().height;

    // canvas is in CSS px coordinates because of ctx.setTransform in setHiDPICanvas
    ctx.clearRect(0,0,W,H);

    // background
    ctx.fillStyle = "rgba(10,14,22,.35)";
    ctx.fillRect(0,0,W,H);

    const pad = 18;
    const left = pad + 34;
    const right = W - pad - 30;
    const top = pad + 26;
    const bottom = H - pad - 18;

    // energy axis
    ctx.strokeStyle = "rgba(255,255,255,.18)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(left, bottom);
    ctx.lineTo(left, top);
    ctx.stroke();

    // levels y positions
    const y0 = bottom;
    const y1 = bottom - 0.22*(bottom-top);
    const y2 = bottom - 0.55*(bottom-top);
    const y3 = bottom - 0.82*(bottom-top);

    function level(y, label, color){
      ctx.strokeStyle = color;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(left+10, y);
      ctx.lineTo(right-20, y);
      ctx.stroke();

      ctx.fillStyle = "rgba(231,236,245,.95)";
      ctx.font = "600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(label, left-24, y+5);
    }

    level(y3, "3", "rgba(167,139,250,.90)");
    level(y2, "2", "rgba(125,211,252,.95)");
    level(y1, "1", "rgba(125,211,252,.65)");
    level(y0, "0", "rgba(231,236,245,.45)");

    // pump arrow 0->3
    drawArrow(ctx, left+90, y0, left+90, y3, "Pump", "rgba(251,191,36,.95)");

    // relaxation 3->2 with tauSp
    drawArrow(ctx, left+150, y3, left+150, y2, "τsp (fast)", "rgba(52,211,153,.95)");

    // laser transition 2->1
    drawArrow(ctx, left+250, y2, left+250, y1, "stim: g n (N2−N1)\nspont: τ21", "rgba(125,211,252,.95)");

    // lower decay 1->0
    drawArrow(ctx, left+330, y1, left+330, y0, "τ1 (fast)", "rgba(231,236,245,.80)");

    // extra nonlasing loss from 2
    drawCurvedArrow(ctx, left+400, y2, left+420, y2+52, "τ2 (loss)", "rgba(251,113,133,.90)");

    // title
    ctx.fillStyle = "rgba(231,236,245,.95)";
    ctx.font = "700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText("Four-level laser: pump → 3 →(τsp)→ 2 → 1 → 0", pad, pad+10);

    // axis label
    ctx.save();
    ctx.translate(pad+10, H/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillStyle = "rgba(231,236,245,.80)";
    ctx.font = "600 12px ui-sans-serif, system-ui";
    ctx.fillText("Energy", 0, 0);
    ctx.restore();
  }

  function drawArrow(ctx, x1,y1,x2,y2, label, color){
    const head = 10;
    const angle = Math.atan2(y2-y1, x2-x1);

    ctx.strokeStyle = color;
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();

    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2 - head*Math.cos(angle - Math.PI/6), y2 - head*Math.sin(angle - Math.PI/6));
    ctx.lineTo(x2 - head*Math.cos(angle + Math.PI/6), y2 - head*Math.sin(angle + Math.PI/6));
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "rgba(231,236,245,.90)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    const lines = label.split("\n");
    let tx = (x1+x2)/2 + 8;
    let ty = (y1+y2)/2 - 10;
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], tx, ty + i*14);
    }
  }

  function drawCurvedArrow(ctx, x1,y1,x2,y2, label, color){
    ctx.strokeStyle = color;
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    const cx = (x1+x2)/2 + 20;
    const cy = (y1+y2)/2 + 10;
    ctx.quadraticCurveTo(cx, cy, x2, y2);
    ctx.stroke();

    // arrowhead
    const angle = Math.atan2(y2-cy, x2-cx);
    const head = 10;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2 - head*Math.cos(angle - Math.PI/6), y2 - head*Math.sin(angle - Math.PI/6));
    ctx.lineTo(x2 - head*Math.cos(angle + Math.PI/6), y2 - head*Math.sin(angle + Math.PI/6));
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "rgba(231,236,245,.90)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ctx.fillText(label, x1+12, y1+18);
  }

  // ---------- Draw plots ----------
  function drawPlots(){
    const N0 = parseFloat(pumpSlider.value);
    const tauP = parseFloat(tauPSlider.value);
    const sigma = parseFloat(sigmaSel.value);

    const state = steadyState(N0, sigma, tauP);
    updateReadouts(state, N0, sigma, tauP);

    // Domain for N0 sweep
    const N0max = parseFloat(pumpSlider.max);
    const N0min = parseFloat(pumpSlider.min);

    // Compute curves
    const xs = [];
    const nCurve = [];
    const NCurve = [];
    const steps = 220;
    for (let i=0;i<=steps;i++){
      const x = N0min + (N0max-N0min)*i/steps;
      const s = steadyState(x, sigma, tauP);
      xs.push(x);
      nCurve.push(s.nbar);
      NCurve.push(s.Nbar);
    }

    // Determine y ranges (with padding)
    const nMax = Math.max(...nCurve);
    const NMax = Math.max(...NCurve, state.Nth, N0max*0.9);

    const nYMax = (nMax<=0) ? 1 : nMax*1.15;
    const nYMin = 0;

    const NYMax = Math.max(state.Nth*1.3, N0max*1.05);
    const NYMin = 0;

    // --- Main plot: n vs N0
    {
      const ctx = setHiDPICanvas(cMain);
      const W = cMain.getBoundingClientRect().width;
      const H = cMain.getBoundingClientRect().height;

      const box = {x:88, y:44, w:W-110, h:H-110};
      drawAxes(
        ctx, box,
        N0min, N0max,
        nYMin, nYMax,
        "N0  (m⁻³)", "n̄  (m⁻³)",
        "Steady photon density n̄ vs pump-set inversion N0 (example parameters)"
      );

      plotLine(ctx, box, N0min, N0max, nYMin, nYMax, xs, nCurve);

      drawVLine(ctx, box, N0min, N0max, state.Nth, "N_th");
      drawMarker(ctx, box, N0min, N0max, nYMin, nYMax, N0, state.nbar);

      // legend
      ctx.save();
      ctx.fillStyle = "rgba(231,236,245,.90)";
      ctx.font = "12px ui-sans-serif, system-ui";
      ctx.fillText("Curve: n̄(N0)", box.x+8, box.y+16);
      ctx.fillStyle = "rgba(125,211,252,.95)";
      ctx.fillRect(box.x+90, box.y+7, 18, 3);
      ctx.fillStyle = "rgba(52,211,153,.95)";
      ctx.beginPath();
      ctx.arc(box.x+160, box.y+12, 5, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "rgba(231,236,245,.85)";
      ctx.fillText("Operating point", box.x+172, box.y+16);
      ctx.restore();
    }

    // --- Secondary plot: N vs N0
    {
      const ctx = setHiDPICanvas(cSec);
      const W = cSec.getBoundingClientRect().width;
      const H = cSec.getBoundingClientRect().height;

      const box = {x:88, y:44, w:W-110, h:H-110};
      drawAxes(
        ctx, box,
        N0min, N0max,
        NYMin, NYMax,
        "N0  (m⁻³)", "N̄  (m⁻³)",
        "Steady inversion N̄ vs N0 (shows inversion clamping at N_th)"
      );

      // Use a different line color via alpha only (no explicit colors restriction? The instruction forbids matplotlib colors; this is canvas.)
      ctx.save();
      ctx.strokeStyle = "rgba(167,139,250,.90)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i=0;i<xs.length;i++){
        const px = box.x + (xs[i]-N0min)/(N0max-N0min)*box.w;
        const py = box.y + box.h - (NCurve[i]-NYMin)/(NYMax-NYMin)*box.h;
        if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.restore();

      drawVLine(ctx, box, N0min, N0max, state.Nth, "N_th");
      drawMarker(ctx, box, N0min, N0max, NYMin, NYMax, N0, state.Nbar);

      // draw clamp line at Nth
      ctx.save();
      ctx.strokeStyle = "rgba(251,191,36,.65)";
      ctx.lineWidth = 2;
      const yClamp = box.y + box.h - (state.Nth-NYMin)/(NYMax-NYMin)*box.h;
      ctx.beginPath();
      ctx.moveTo(box.x, yClamp);
      ctx.lineTo(box.x+box.w, yClamp);
      ctx.stroke();
      ctx.fillStyle = "rgba(251,191,36,.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillText("Clamp: N̄ = N_th", box.x+8, yClamp-8);
      ctx.restore();
    }

    // diagram
    drawDiagram();
  }

  // ---------- Copy buttons ----------
  function installCopy(){
    document.querySelectorAll(".copybtn").forEach(btn=>{
      btn.addEventListener("click", async ()=>{
        const sel = btn.getAttribute("data-copy");
        const el = document.querySelector(sel);
        const txt = el ? el.innerText.trim() : "";
        try{
          await navigator.clipboard.writeText(txt);
          btn.textContent = "Copied!";
          btn.classList.add("shake");
          setTimeout(()=>{ btn.textContent="Copy"; btn.classList.remove("shake"); }, 900);
        }catch(e){
          btn.textContent = "Copy failed";
          setTimeout(()=>{ btn.textContent="Copy"; }, 900);
        }
      });
    });
  }

  // ---------- Events ----------
  function bind(){
    const rerender = ()=>drawPlots();
    pumpSlider.addEventListener("input", rerender);
    tauPSlider.addEventListener("input", rerender);
    sigmaSel.addEventListener("change", rerender);

    // Resize observer for crisp responsiveness
    const ro = new ResizeObserver(()=>drawPlots());
    ro.observe(cDiag);
    ro.observe(cMain);
    ro.observe(cSec);
  }

  installCopy();
  bind();
  drawPlots();
})();
</script>
</body>
</html>
