<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Output of a Single-Mode Gas Laser — Losses, Photon Lifetime, Output Flux & Power</title>
  <style>
    :root{
      --bg:#0b0f16;
      --card:#0f1724;
      --muted:#a9b3c7;
      --text:#e9eefc;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 700px at 15% 10%, rgba(125, 211, 252, .12), transparent 55%),
        radial-gradient(900px 600px at 80% 20%, rgba(167, 139, 250, .12), transparent 55%),
        radial-gradient(900px 700px at 55% 90%, rgba(52, 211, 153, .10), transparent 55%),
        var(--bg);
      color:var(--text);
      line-height:1.55;
    }

    header{
      padding:28px 18px 10px;
      max-width:1200px;
      margin:0 auto;
    }
    header .kicker{
      color:var(--muted);
      letter-spacing:.08em;
      text-transform:uppercase;
      font-size:.82rem;
    }
    header h1{
      margin:.4rem 0 .65rem;
      font-size: clamp(1.6rem, 2.5vw, 2.35rem);
      line-height:1.15;
    }
    header p{
      margin:.35rem 0 0;
      color:var(--muted);
      max-width: 78ch;
    }

    .layout{
      max-width:1200px;
      margin:0 auto;
      padding:18px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }

    nav.toc{
      position:sticky;
      top:14px;
      background: linear-gradient(180deg, rgba(15,23,36,.86), rgba(15,23,36,.72));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:14px 14px 10px;
      backdrop-filter: blur(10px);
    }
    nav.toc .title{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; margin-bottom:8px;
    }
    nav.toc .title strong{ font-size: .98rem; }
    nav.toc .title span{
      font-family:var(--mono);
      font-size:.78rem;
      color:var(--muted);
      border:1px solid var(--line);
      padding:2px 8px;
      border-radius:999px;
    }
    nav.toc a{
      display:block;
      padding:7px 10px;
      margin:2px 0;
      color:var(--text);
      text-decoration:none;
      border-radius:12px;
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border .12s ease;
      font-size:.95rem;
    }
    nav.toc a:hover{
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.10);
      transform: translateX(2px);
    }
    nav.toc small{
      display:block;
      color:var(--muted);
      margin-top:10px;
      font-size:.84rem;
    }

    main{
      display:flex;
      flex-direction:column;
      gap:16px;
      min-width:0;
    }

    section, article{
      background: linear-gradient(180deg, rgba(15,23,36,.86), rgba(15,23,36,.70));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:16px 16px 14px;
      backdrop-filter: blur(10px);
      overflow:hidden;
    }

    h2{
      margin:0 0 10px;
      font-size: 1.25rem;
      letter-spacing:.01em;
    }
    h3{
      margin:14px 0 8px;
      font-size: 1.08rem;
      color:#f3f6ff;
    }
    p{ margin: 8px 0; color: rgba(233,238,252,.92); }
    ul, ol{ margin: 8px 0 8px 18px; color: rgba(233,238,252,.92); }
    li{ margin: 5px 0; }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      align-items:start;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:14px;
      align-items:start;
    }

    .callout{
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      border-radius: 16px;
      padding:12px 12px 10px;
    }
    .callout .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size:.80rem;
      letter-spacing:.06em;
      text-transform:uppercase;
      color: rgba(233,238,252,.85);
      border: 1px solid rgba(255,255,255,.14);
      padding:3px 10px;
      border-radius: 999px;
      margin-bottom: 8px;
    }
    .tag.good{ border-color: rgba(52,211,153,.35); color: rgba(167,243,208,.95); }
    .tag.warn{ border-color: rgba(251,191,36,.35); color: rgba(254,243,199,.95); }
    .tag.key{ border-color: rgba(125,211,252,.35); color: rgba(186,230,253,.95); }
    .tag.final{ border-color: rgba(167,139,250,.40); color: rgba(233,213,255,.95); }

    code, pre{
      font-family:var(--mono);
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 2px 7px;
    }
    pre{
      padding: 10px 12px;
      overflow:auto;
      margin: 10px 0;
    }

    .eqRow{
      display:flex;
      gap:10px;
      align-items:flex-start;
      margin:10px 0;
    }
    .eq{
      flex:1;
      padding:10px 12px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      overflow:auto;
    }
    .eq .label{
      font-size:.82rem;
      color: var(--muted);
      margin-bottom:6px;
    }
    .copyBtn{
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-size:.88rem;
      transition: transform .12s ease, background .12s ease;
      user-select:none;
      white-space:nowrap;
    }
    .copyBtn:hover{ background: rgba(255,255,255,.10); transform: translateY(-1px); }
    .copyBtn:active{ transform: translateY(0px); }

    .vizWrap{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:14px;
      align-items:stretch;
    }
    .vizCard{
      border:1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      background: rgba(0,0,0,.18);
      padding:12px;
      overflow:hidden;
      min-width:0;
    }
    .vizTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .vizTitle strong{ font-size: .98rem; }
    .vizTitle span{
      font-family:var(--mono);
      color: var(--muted);
      font-size:.80rem;
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(10,14,22,.65);
    }
    .smallCanvas canvas{ height:260px; }

    .controls{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
      margin-top:10px;
    }
    .control{
      border:1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      background: rgba(255,255,255,.04);
      padding:10px 10px 8px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      color: rgba(233,238,252,.92);
      font-size:.92rem;
      margin-bottom:6px;
    }
    .control label span{
      font-family:var(--mono);
      color: var(--muted);
      font-size:.85rem;
    }
    input[type="range"]{ width:100%; }
    .mini{
      font-size:.88rem;
      color: var(--muted);
      margin-top:6px;
    }

    .results{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    .pill{
      border:1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      padding:10px 10px 8px;
      background: rgba(0,0,0,.16);
    }
    .pill .k{ color: var(--muted); font-size:.85rem; }
    .pill .v{ font-family:var(--mono); font-size: 1.02rem; margin-top:4px; }
    .pill .v b{ color: #ffffff; }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding:14px 18px 28px;
      color: var(--muted);
      font-size:.92rem;
    }

    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
      nav.toc{ position:relative; top:auto; }
      .vizWrap{ grid-template-columns: 1fr; }
      .grid2, .grid3{ grid-template-columns: 1fr; }
      .results{ grid-template-columns: 1fr; }
    }

    @media print{
      body{ background:#fff; color:#000; }
      header, section, article, nav.toc{ box-shadow:none; background:#fff; border-color:#ddd; }
      nav.toc{ position:relative; }
      .copyBtn, .controls{ display:none !important; }
      canvas{ border:1px solid #bbb; background:#fff; }
      code, pre{ background:#f6f6f6; border-color:#ddd; }
    }

    /* subtle entrance */
    section, article, nav.toc{
      animation: fadeUp .35s ease both;
    }
    @keyframes fadeUp{
      from{ opacity:0; transform: translateY(6px); }
      to{ opacity:1; transform: translateY(0); }
    }
  </style>
</head>

<body>
<header>
  <div class="kicker">Photonics • single-mode gas laser cavity</div>
  <h1>Output of a Single-Mode Gas Laser: Mirror Losses, Photon Lifetime, Output Flux Density, and Power</h1>
  <p>
    We model a 10&nbsp;cm gas laser resonator at 600&nbsp;nm with one partially reflecting output coupler
    (<span style="font-family:var(--mono)">R1 = 99%</span>) and one perfect reflector (<span style="font-family:var(--mono)">R2 = 100%</span>).
    Using distributed-loss equivalents and a standard saturation model, we compute the cavity loss coefficient,
    photon lifetime, and output.
  </p>
</header>

<div class="layout">
  <nav class="toc" aria-label="Table of contents">
    <div class="title">
      <strong>Table of Contents</strong>
      <span>sticky</span>
    </div>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
    <small>
      Interactive controls update all plots and the numeric results.
      Use them to build intuition about how output coupling affects loss, lifetime, and power.
    </small>
  </nav>

  <main>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li>We convert mirror reflectances into <b>equivalent distributed loss coefficients</b> (units: cm<sup>−1</sup>) so they can be compared directly with gain.</li>
        <li>Laser steady state uses <b>gain clamping with saturation</b>: <code>g(φ) = g0 / (1 + φ/φs)</code> and at steady state <code>g(φ) = a_r</code>.</li>
        <li>Mirror loss (for mirror <i>i</i>) as an equivalent distributed loss: <code>a_mi = (1/(2L)) ln(1/Ri)</code>.</li>
        <li>Total resonator loss (no internal loss here): <code>a_r = a_m1 + a_m2</code>.</li>
        <li>Photon lifetime from intensity decay: <code>τp = n / (c a_r)</code>.</li>
        <li>Intracavity flux density: <code>φ_cav = φs (g0/a_r − 1)</code> (in photons·cm<sup>−2</sup>·s<sup>−1</sup>).</li>
        <li>Output flux density through the output coupler (standing-wave model): <code>φ_out = (1−R1) φ_cav / 2</code>, and <code>P_out = (hν) A φ_out</code>.</li>
      </ul>
    </section>

    <article id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="grid2">
        <div class="callout">
          <div class="tag key">Core definitions</div>
          <ul>
            <li><b>Mirror reflectance</b> <code>R</code> (dimensionless): fraction of intensity reflected at a mirror.</li>
            <li><b>Distributed loss coefficient</b> <code>a</code> (cm<sup>−1</sup>): defined so intensity decays as <code>I(z)=I(0) e^(−a z)</code>.</li>
            <li><b>Gain coefficient</b> <code>g</code> (cm<sup>−1</sup>): defined so intensity grows as <code>I(z)=I(0) e^(+g z)</code> inside the gain medium.</li>
            <li><b>Photon flux density</b> <code>φ</code> (photons·cm<sup>−2</sup>·s<sup>−1</sup>): photons crossing a unit area per unit time (proportional to intensity via <code>I = (hν) φ</code>).</li>
            <li><b>Saturation flux</b> <code>φs</code>: scale at which stimulated emission significantly reduces the gain.</li>
            <li><b>Photon lifetime</b> <code>τp</code> (s): time constant for intracavity intensity to decay when gain is removed.</li>
          </ul>
        </div>

        <div class="callout">
          <div class="tag key">Physical meaning</div>
          <p>
            In a laser cavity, photons bounce back and forth. Mirrors are not perfectly reflecting (except here for one),
            so each round trip loses a fraction of the intracavity power. It is convenient to treat those discrete mirror losses
            as if they were a continuous (distributed) loss per unit length—then we can compare directly to the gain per unit length.
          </p>
          <p>
            Above threshold, the gain medium <b>saturates</b>:
            as intracavity intensity rises, population inversion is depleted faster, reducing gain until
            the saturated gain equals total loss. This is the “gain clamps to loss” idea.
          </p>
        </div>
      </div>

      <h3>Key laws/principles and validity</h3>
      <ul>
        <li><b>Round-trip condition</b> (steady state): net round-trip amplification equals unity (no growth, no decay).</li>
        <li><b>Small-signal gain</b> <code>g0</code> is the gain when intensity is low (unsaturated).</li>
        <li><b>Homogeneous saturation model</b>: <code>g(φ) = g0/(1+φ/φs)</code>. Valid when the gain medium behaves like a homogeneously broadened saturable amplifier (common in many gas-laser models).</li>
        <li><b>Intensity decay and photon lifetime</b>: if intensity loss per length is <code>a_r</code>, then in time it decays with rate <code>(c/n) a_r</code>, so <code>τp = n/(c a_r)</code>.</li>
      </ul>

      <div class="grid2">
        <div class="callout">
          <div class="tag good">Mini intuition example 1</div>
          <p>
            If mirror reflectance drops (say from 99% to 95%), the cavity loses much more power per round trip.
            That increases the equivalent distributed loss <code>a_r</code>, which reduces photon lifetime <code>τp</code>
            and increases the threshold gain.
          </p>
        </div>
        <div class="callout">
          <div class="tag good">Mini intuition example 2</div>
          <p>
            If the small-signal gain <code>g0</code> is only barely above the loss, the laser runs weakly:
            the saturation term hardly turns on and the intracavity flux stays modest.
            If <code>g0</code> is far above loss, the intracavity field must become strong enough to saturate gain down to the loss value.
          </p>
        </div>
      </div>

      <div class="callout">
        <div class="tag warn">What to watch for (pitfalls)</div>
        <ul>
          <li><b>Factor-of-2 confusion:</b> in linear cavities a “round trip” is <code>2L</code>. Many formulas contain <code>1/(2L)</code>.</li>
          <li><b>What does φ mean?</b> Is it one traveling wave or total standing-wave intensity? Be explicit. (We will use a consistent model and state it.)</li>
          <li><b>Units:</b> keep <code>L</code> in cm if gain/loss are in cm<sup>−1</sup>, and <code>c</code> in cm/s when computing <code>τp</code>.</li>
          <li><b>Output power:</b> don’t forget to multiply by area <code>A</code> and photon energy <code>hν</code>.</li>
        </ul>
      </div>
    </article>

    <article id="part1">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Restate the problem</h3>
      <p>
        A 10&nbsp;cm long single-mode gas laser operates at 600&nbsp;nm.
        The cavity has two mirrors with reflectances <code>R1 = 0.99</code> (output coupler) and <code>R2 = 1.00</code>.
        The refractive index is <code>n = 1</code>.
        The effective output area is <code>A = 1 mm²</code>.
        The small-signal gain is <code>g0 = 0.1 cm⁻¹</code> and the saturation photon-flux density is
        <code>φs = 1.43×10¹⁹ photons/(cm²·s)</code>.
      </p>
      <p>
        (a) Convert each mirror loss into an equivalent distributed loss coefficient <code>a_m1</code>, <code>a_m2</code>, and with no internal loss (<code>a_s = 0</code>) find total resonator loss <code>a_r</code>.
        (b) Find the photon lifetime <code>τp</code>.
        (c) Find the output photon-flux density <code>φ0</code> and output power <code>P0</code>.
      </p>

      <div class="grid2">
        <div class="callout">
          <div class="tag key">Given</div>
          <ul>
            <li><code>L = 10 cm</code></li>
            <li><code>λ = 600 nm</code></li>
            <li><code>R1 = 0.99</code>, <code>R2 = 1.00</code></li>
            <li><code>n = 1</code></li>
            <li><code>A = 1 mm² = 0.01 cm²</code></li>
            <li><code>g0 = 0.1 cm⁻¹</code></li>
            <li><code>φs = 1.43×10¹⁹ photons/(cm²·s)</code></li>
            <li><code>a_s = 0</code></li>
          </ul>
        </div>
        <div class="callout">
          <div class="tag key">Unknowns</div>
          <ul>
            <li><code>a_m1</code>, <code>a_m2</code> (cm<sup>−1</sup>)</li>
            <li><code>a_r</code> (cm<sup>−1</sup>)</li>
            <li><code>τp</code> (s)</li>
            <li><code>φ0</code> (photons·cm<sup>−2</sup>·s<sup>−1</sup>)</li>
            <li><code>P0</code> (W)</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles and why they apply</h3>
      <ul>
        <li><b>Mirror losses as distributed loss:</b> mirrors cause discrete intensity drops; replacing them by an equivalent exponential loss over one round trip gives a convenient cm<sup>−1</sup> loss coefficient.</li>
        <li><b>Steady-state laser condition:</b> for continuous-wave operation in a single mode, the intracavity field settles so that saturated gain equals total loss.</li>
        <li><b>Photon lifetime relation:</b> with distributed loss <code>a_r</code>, intensity decays in time with rate <code>(c/n) a_r</code>.</li>
        <li><b>Output coupling:</b> a fraction <code>T1 ≈ 1−R1</code> of the wave incident on the output mirror exits; multiply by photon energy and area to get power.</li>
      </ul>

      <div class="callout">
        <div class="tag warn">Assumptions</div>
        <ul>
          <li>Single longitudinal and transverse mode; uniform mode area <code>A</code> at the output.</li>
          <li>Negligible internal distributed loss: <code>a_s = 0</code> (given).</li>
          <li>Homogeneous saturation model: <code>g(φ) = g0/(1 + φ/φs)</code>.</li>
          <li>Standing-wave cavity approximated as two equal counter-propagating traveling waves; total intracavity flux is split equally in the two directions.</li>
          <li>Mirror transmissions are small so <code>T1 ≈ 1−R1</code> is adequate (here 1%).</li>
        </ul>
      </div>

      <h3>Possible approaches (and choice)</h3>
      <ol>
        <li><b>Round-trip intensity method:</b> write a round-trip gain/loss product and convert to an equivalent distributed coefficient. <i>Pros:</i> fast and standard. <i>Cons:</i> must be careful with factors of 2.</li>
        <li><b>Rate-equation method:</b> write <code>dφ/dt = (c/n)(g−a_r)φ</code> and enforce steady state. <i>Pros:</i> directly yields lifetime and clamping. <i>Cons:</i> still needs mirror → loss conversion.</li>
        <li><b>Energy storage method:</b> compute cavity energy and divide by output loss rate. <i>Pros:</i> physically transparent. <i>Cons:</i> more bookkeeping than needed here.</li>
      </ol>
      <p>
        <b>We choose:</b> round-trip intensity method + saturation clamping, because it cleanly produces <code>a_r</code>, then <code>τp</code>, then output.
      </p>
    </article>

    <article id="part2">
      <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

      <ol>
        <li>
          <b>Convert mirror losses to distributed form</b><br/>
          <span style="color:var(--muted)">Tool:</span> equate round-trip mirror multiplication <code>R</code> to <code>exp(−2 a_m L)</code>.<br/>
          <span style="color:var(--muted)">Meaning:</span> an “average” loss per cm that produces the same net round-trip loss.
        </li>
        <li>
          <b>Sum losses to get total resonator loss</b><br/>
          <span style="color:var(--muted)">Tool:</span> <code>a_r = a_s + a_m1 + a_m2</code> with <code>a_s=0</code>.<br/>
          <span style="color:var(--muted)">Meaning:</span> total cm<sup>−1</sup> intensity loss that must be balanced by gain.
        </li>
        <li>
          <b>Compute photon lifetime</b><br/>
          <span style="color:var(--muted)">Tool:</span> time-decay rate <code>(c/n) a_r</code> ⇒ <code>τp=n/(c a_r)</code>.<br/>
          <span style="color:var(--muted)">Meaning:</span> how quickly intracavity photons leak away.
        </li>
        <li>
          <b>Use gain saturation + steady state to find intracavity flux</b><br/>
          <span style="color:var(--muted)">Tool:</span> solve <code>g0/(1+φ/φs) = a_r</code> for <code>φ</code>.<br/>
          <span style="color:var(--muted)">Meaning:</span> the field grows until it saturates gain down to the loss.
        </li>
        <li>
          <b>Convert intracavity flux to output flux and power</b><br/>
          <span style="color:var(--muted)">Tool:</span> output fraction <code>T1≈1−R1</code> of the wave incident on mirror 1; multiply by <code>hν</code> and area <code>A</code>.<br/>
          <span style="color:var(--muted)">Meaning:</span> photons escaping per second times energy per photon.
        </li>
      </ol>

      <div class="callout">
        <div class="tag warn">Common mistakes (quick tips)</div>
        <ul>
          <li>Using <code>1/L</code> instead of <code>1/(2L)</code> when converting mirrors to distributed loss.</li>
          <li>Mixing SI and cgs: if you keep gain in cm<sup>−1</sup>, use <code>c = 3×10¹⁰ cm/s</code> for <code>τp</code>.</li>
          <li>Forgetting to convert <code>1 mm²</code> to <code>0.01 cm²</code> when computing power.</li>
          <li>Not stating whether output flux is based on one traveling wave or total standing-wave intensity (we will state it explicitly).</li>
        </ul>
      </div>
    </article>

    <article id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Physical intuition before calculating</h3>
      <p>
        With <code>R2 = 100%</code>, the only mirror loss comes from the output coupler <code>R1 = 99%</code>.
        That is a relatively small loss (1% per reflection), so the equivalent distributed loss <code>a_r</code> should be much smaller than the given small-signal gain <code>g0 = 0.1 cm⁻¹</code>.
        Therefore the laser will run well above threshold and the intracavity field must become strong enough to <b>saturate</b> the gain down until
        <code>g(φ) = a_r</code>.
      </p>

      <h3>(a) Mirror losses as distributed coefficients; resonator loss</h3>

      <p>
        Let <code>a_mi</code> be the equivalent distributed loss coefficient (cm<sup>−1</sup>) associated with mirror <i>i</i>.
        Over one <b>round trip</b> the light traverses length <code>2L</code> and experiences each mirror once, so the round-trip intensity multiplication
        due to mirror <i>i</i> alone is <code>Ri</code>.
      </p>

      <div class="eqRow">
        <div class="eq" id="eq_mirror">
          <div class="label">Mirror i → equivalent distributed loss (intensity)</div>
          <div><code>Ri = exp(−2 a_mi L)</code></div>
          <div style="margin-top:6px;"><code>⇒ a_mi = (1/(2L)) ln(1/Ri)</code></div>
        </div>
        <button class="copyBtn" data-copy="a_mi = (1/(2L)) ln(1/Ri)">Copy</button>
      </div>

      <p>
        Now insert numbers. Use <code>L = 10 cm</code>, <code>R1 = 0.99</code>, <code>R2 = 1.00</code>.
      </p>

      <pre id="calc_a">
Given L = 10 cm.

a_m1 = (1/(2L)) ln(1/R1) = (1/20 cm) ln(1/0.99)
     = (1/20) ln(1.010101...)
     ≈ (1/20) (0.0100503)
     ≈ 5.03×10^−4 cm^−1

a_m2 = (1/(2L)) ln(1/R2) = (1/20) ln(1/1) = 0
</pre>

      <div class="callout">
        <div class="tag final">Answer (a)</div>
        <p style="margin:6px 0 0;">
          <b>Distributed mirror losses:</b><br/>
          <code>a_m1 ≈ 5.03×10^−4 cm^−1</code>, &nbsp;
          <code>a_m2 = 0</code>.
        </p>
        <p style="margin:8px 0 0;">
          With <code>a_s = 0</code>, the <b>total resonator loss coefficient</b> is
          <code>a_r = a_m1 + a_m2 = 5.03×10^−4 cm^−1</code>.
        </p>
      </div>

      <h3>(b) Photon lifetime τ<sub>p</sub></h3>
      <p>
        If intensity decays along propagation as <code>dI/dz = −a_r I</code>, then in time the rate is
        <code>dI/dt = (dI/dz)(dz/dt) = −a_r I (c/n)</code>.
        This is exponential decay: <code>dI/dt = −I/τp</code>, so:
      </p>

      <div class="eqRow">
        <div class="eq" id="eq_tau">
          <div class="label">Photon lifetime from distributed loss</div>
          <div><code>τp = n / (c a_r)</code></div>
        </div>
        <button class="copyBtn" data-copy="τp = n/(c a_r)">Copy</button>
      </div>

      <p>
        Use <code>n = 1</code>, <code>c = 3.00×10^10 cm/s</code>, and <code>a_r = 5.03×10^−4 cm^−1</code>.
      </p>

      <pre id="calc_tau">
τp = 1 / ( (3.00×10^10 cm/s)(5.03×10^−4 cm^−1) )
   = 1 / (1.51×10^7 s^−1)
   ≈ 6.63×10^−8 s
   ≈ 66 ns
</pre>

      <div class="callout">
        <div class="tag final">Answer (b)</div>
        <p style="margin:6px 0 0;">
          <b>Photon lifetime:</b> <code>τp ≈ 6.63×10^−8 s ≈ 66 ns</code>.
        </p>
      </div>

      <h3>(c) Output photon-flux density φ<sub>0</sub> and output power P<sub>0</sub></h3>

      <p>
        Use the saturation model (homogeneous saturation):
      </p>

      <div class="eqRow">
        <div class="eq" id="eq_sat">
          <div class="label">Gain saturation model</div>
          <div><code>g(φ) = g0 / (1 + φ/φs)</code></div>
        </div>
        <button class="copyBtn" data-copy="g(φ) = g0/(1 + φ/φs)">Copy</button>
      </div>

      <p>
        In steady state (continuous-wave), the net growth rate is zero, so saturated gain equals total loss:
        <code>g(φ_cav) = a_r</code>.
        Solve for the <b>intracavity</b> photon flux density <code>φ_cav</code>:
      </p>

      <div class="eqRow">
        <div class="eq" id="eq_phi_cav">
          <div class="label">Steady-state flux from gain clamping</div>
          <div><code>a_r = g0 / (1 + φ_cav/φs)</code></div>
          <div style="margin-top:6px;"><code>⇒ 1 + φ_cav/φs = g0/a_r</code></div>
          <div style="margin-top:6px;"><code>⇒ φ_cav = φs (g0/a_r − 1)</code></div>
        </div>
        <button class="copyBtn" data-copy="φ_cav = φs (g0/a_r − 1)">Copy</button>
      </div>

      <p>
        Insert values: <code>g0 = 0.1 cm⁻1</code>, <code>a_r = 5.03×10^−4 cm⁻1</code>, <code>φs = 1.43×10^19</code>.
      </p>

      <pre id="calc_phi">
g0/a_r ≈ 0.1 / (5.03×10^−4) ≈ 199
φ_cav = φs (199 − 1) = (1.43×10^19)(198)
      ≈ 2.83×10^21 photons/(cm^2·s)
</pre>

      <p>
        Now relate intracavity flux to the output through mirror 1.
        We use a linear standing-wave cavity approximated as two equal counter-propagating traveling waves.
        Let the <b>total</b> intracavity flux density be <code>φ_cav</code>, so each traveling wave carries approximately <code>φ_cav/2</code>.
        The output coupler transmits a fraction <code>T1 ≈ 1 − R1</code> of the incident traveling wave.
        Therefore the <b>output photon-flux density</b> is:
      </p>

      <div class="eqRow">
        <div class="eq" id="eq_phi_out">
          <div class="label">Output flux density (through mirror 1)</div>
          <div><code>φ0 = φ_out = (1 − R1) (φ_cav/2)</code></div>
        </div>
        <button class="copyBtn" data-copy="φ0 = (1 − R1) φ_cav / 2">Copy</button>
      </div>

      <p>
        With <code>1−R1 = 0.01</code>:
      </p>

      <pre id="calc_phi_out">
φ0 = 0.01 × (2.83×10^21 / 2)
   ≈ 1.42×10^19 photons/(cm^2·s)
</pre>

      <p>
        Convert flux density to output power. Photon energy is <code>hν = hc/λ</code>.
        Output power equals (photons per second) × (energy per photon):
        <code>P0 = (hν) × (A φ0)</code>.
      </p>

      <div class="eqRow">
        <div class="eq" id="eq_power">
          <div class="label">Output power from photon flux density</div>
          <div><code>P0 = (h c / λ) · A · φ0</code></div>
        </div>
        <button class="copyBtn" data-copy="P0 = (h c/λ) A φ0">Copy</button>
      </div>

      <p>
        Use <code>A = 1 mm² = 0.01 cm²</code>, <code>λ = 600 nm</code>, and <code>h c/λ ≈ 3.31×10^−19 J</code> per photon at 600 nm.
      </p>

      <pre id="calc_P">
Photon energy: h c/λ ≈ 3.31×10^−19 J (at 600 nm)

Photon rate out = A φ0 = (0.01 cm^2)(1.42×10^19) ≈ 1.42×10^17 photons/s

P0 = (3.31×10^−19 J)(1.42×10^17 s^−1)
   ≈ 4.69×10^−2 W
   ≈ 47 mW
</pre>

      <div class="callout">
        <div class="tag final">Answer (c)</div>
        <p style="margin:6px 0 0;">
          <b>Intracavity photon-flux density:</b> <code>φ_cav ≈ 2.83×10^21 photons/(cm^2·s)</code>
        </p>
        <p style="margin:8px 0 0;">
          <b>Output photon-flux density:</b> <code>φ0 ≈ 1.42×10^19 photons/(cm^2·s)</code>
        </p>
        <p style="margin:8px 0 0;">
          <b>Output power:</b> <code>P0 ≈ 4.7×10^−2 W ≈ 47 mW</code>
        </p>
        <button class="copyBtn" style="margin-top:10px;" data-copy="a_m1 ≈ 5.03×10^−4 cm^−1; a_m2 = 0; a_r ≈ 5.03×10^−4 cm^−1; τp ≈ 6.63×10^−8 s (66 ns); φ_cav ≈ 2.83×10^21 photons/(cm^2·s); φ0 ≈ 1.42×10^19 photons/(cm^2·s); P0 ≈ 4.7×10^−2 W (47 mW).">Copy final results</button>
      </div>

      <h3>Sanity checks</h3>
      <div class="grid3">
        <div class="callout">
          <div class="tag good">Units</div>
          <ul>
            <li><code>a_r</code> in cm<sup>−1</sup> ⇒ <code>c a_r</code> in s<sup>−1</sup> ⇒ <code>τp</code> in s.</li>
            <li><code>φ0</code> in photons/(cm²·s); multiply by <code>A</code> (cm²) ⇒ photons/s.</li>
            <li>Multiply photons/s by J/photon ⇒ W.</li>
          </ul>
        </div>
        <div class="callout">
          <div class="tag good">Limiting cases</div>
          <ul>
            <li>If <code>R1 → 1</code>, then <code>a_r → 0</code>, <code>τp → ∞</code>, and <code>φ_cav</code> grows large (until other physics limits it).</li>
            <li>If <code>R1</code> decreases, loss rises, so <code>τp</code> drops and threshold approaches <code>g0</code>.</li>
          </ul>
        </div>
        <div class="callout">
          <div class="tag good">Physical interpretation</div>
          <p>
            The computed <code>a_r</code> is tiny compared to <code>g0</code>, so the laser must saturate strongly
            (large <code>φ_cav</code>) until gain clamps down to the small loss value. The output is then set mainly by the output coupling (<code>1−R1</code>) and the saturated intracavity flux.
          </p>
        </div>
      </div>

      <p>
        Connection to visuals: the gain curve <code>g(φ)</code> intersects the horizontal loss line at <code>φ=φ_cav</code>.
        The cavity diagram shows where the output is extracted (mirror 1) and what quantities map to the computations.
      </p>
    </article>

    <article id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the final formulas</h3>
      <ul>
        <li><code>a_r = (1/(2L)) ln(1/(R1 R2)) + a_s</code>: losses add; longer cavities reduce the equivalent loss per cm for fixed mirror reflectance.</li>
        <li><code>τp = n/(c a_r)</code>: photon lifetime is longer when loss is smaller; it is essentially the cavity energy storage time constant.</li>
        <li><code>φ_cav = φs (g0/a_r − 1)</code>: how far above threshold you are (<code>g0/a_r</code>) determines how much saturation is needed.</li>
        <li><code>φ0 ∝ (1−R1)</code>: stronger output coupling extracts more, but also increases loss—so power vs <code>R1</code> can have an optimum when other constraints are present.</li>
      </ul>

      <h3>How changing parameters affects outcomes (connect to interactive plots)</h3>
      <ul>
        <li><b>Decrease R1</b> ⇒ increases <code>a_r</code> ⇒ decreases <code>τp</code> and reduces <code>φ_cav</code> (because the gain needs less saturation to match a larger loss), but increases transmission. Output power can increase or decrease depending on which effect dominates.</li>
        <li><b>Increase g0</b> ⇒ increases <code>φ_cav</code> approximately linearly for <code>g0 ≫ a_r</code>, so output rises.</li>
        <li><b>Increase L</b> (keeping mirrors fixed) ⇒ reduces <code>a_r</code> ⇒ increases <code>τp</code> and increases <code>φ_cav</code>.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        Instead of converting mirrors to distributed loss first, you can write the round-trip steady-state condition directly:
        <code>exp(2 g(φ) L) · R1 R2 · exp(−2 a_s L) = 1</code>.
        Taking the natural log and dividing by <code>2L</code> immediately yields
        <code>g(φ) = a_s + (1/(2L)) ln(1/(R1 R2))</code>.
        That is the same <code>a_r</code> we used, derived in one line.
      </p>

      <h3>Concept check (quick self-test)</h3>
      <ul>
        <li><b>Q:</b> Why does the steady-state gain equal the loss, not the small-signal gain? <b>A:</b> The field grows until saturation reduces gain; steady state requires zero net growth.</li>
        <li><b>Q:</b> Why does mirror loss become <code>(1/(2L)) ln(1/R)</code>? <b>A:</b> Because a round-trip intensity factor <code>R</code> equals an exponential loss over distance <code>2L</code>.</li>
        <li><b>Q:</b> If <code>R2</code> were 0.98, would <code>a_r</code> roughly double? <b>A:</b> It would increase by <code>(1/(2L)) ln(1/0.98)</code>, which is comparable to (but not exactly equal to) the increase from the first mirror—so yes, it would increase noticeably.</li>
        <li><b>Q:</b> What sets the scale of <code>φ_cav</code>? <b>A:</b> The saturation flux <code>φs</code>; it’s the “unit” of flux needed to reduce gain significantly.</li>
      </ul>
    </article>

    <article id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="vizWrap">
        <div class="vizCard">
          <div class="vizTitle">
            <strong>Diagram: Linear Laser Resonator</strong>
            <span>geometry & symbols</span>
          </div>
          <canvas id="cDiagram" aria-label="Laser cavity diagram"></canvas>
          <div class="mini">
            Shows mirror 1 (output coupler), mirror 2 (high reflector), cavity length <code>L</code>, mode area <code>A</code>,
            and an output beam through mirror 1 with transmission <code>T1 ≈ 1−R1</code>.
          </div>
        </div>

        <div class="vizCard">
          <div class="vizTitle">
            <strong>Main Plot: Saturated Gain vs Photon Flux</strong>
            <span>intersection gives φ<sub>cav</sub></span>
          </div>
          <canvas id="cMain" aria-label="Gain vs flux plot"></canvas>

          <div class="controls" aria-label="Interactive controls">
            <div class="control">
              <label>
                Output-coupler reflectance R1
                <span id="labR1">0.990</span>
              </label>
              <input id="slR1" type="range" min="0.90" max="0.999" step="0.001" value="0.99" />
              <div class="mini">Move R1 to see how mirror loss, photon lifetime, and output change.</div>
            </div>

            <div class="control">
              <label>
                Small-signal gain g0 (cm⁻¹)
                <span id="labG0">0.100</span>
              </label>
              <input id="slG0" type="range" min="0.01" max="0.20" step="0.005" value="0.10" />
              <div class="mini">Higher g0 drives stronger saturation and generally increases output.</div>
            </div>

            <div class="control">
              <label>
                Cavity length L (cm)
                <span id="labL">10.0</span>
              </label>
              <input id="slL" type="range" min="5" max="50" step="1" value="10" />
              <div class="mini">Longer cavities spread mirror loss over more length → smaller a<sub>r</sub> and longer τ<sub>p</sub>.</div>
            </div>

            <div class="results" aria-label="Live computed results">
              <div class="pill"><div class="k">a_m1 (cm⁻¹)</div><div class="v" id="out_am1">—</div></div>
              <div class="pill"><div class="k">a_r (cm⁻¹)</div><div class="v" id="out_ar">—</div></div>
              <div class="pill"><div class="k">τp (ns)</div><div class="v" id="out_tau">—</div></div>
              <div class="pill"><div class="k">φ_cav (photons/(cm²·s))</div><div class="v" id="out_phic">—</div></div>
              <div class="pill"><div class="k">φ0 (photons/(cm²·s))</div><div class="v" id="out_phio">—</div></div>
              <div class="pill"><div class="k">P0 (mW)</div><div class="v" id="out_P">—</div></div>
            </div>
          </div>
        </div>
      </div>

      <div class="vizWrap" style="margin-top:14px;">
        <div class="vizCard smallCanvas">
          <div class="vizTitle">
            <strong>Secondary Plot: Output Power vs R1 (Sweep)</strong>
            <span>marker = current R1</span>
          </div>
          <canvas id="cSweep" aria-label="Power vs R1 sweep"></canvas>
          <div class="mini">
            This plot sweeps <code>R1</code> while holding <code>R2=1</code>, <code>φs</code>, and the selected <code>g0</code>, <code>L</code> fixed.
            The marker shows the current slider value of <code>R1</code>.
          </div>
        </div>
        <div class="vizCard smallCanvas">
          <div class="vizTitle">
            <strong>Secondary Plot: Photon Lifetime vs R1 (Sweep)</strong>
            <span>how leakage changes storage</span>
          </div>
          <canvas id="cSweep2" aria-label="Lifetime vs R1 sweep"></canvas>
          <div class="mini">
            As <code>R1</code> decreases, the equivalent loss <code>a_r</code> rises, so <code>τp</code> falls.
          </div>
        </div>
      </div>

      <div class="callout" style="margin-top:14px;">
        <div class="tag key">What the controls do</div>
        <ul>
          <li><b>R1 slider:</b> changes mirror loss <code>a_m1</code>, thus <code>a_r</code>, which shifts the horizontal loss line in the main plot and moves the intersection (changes <code>φ_cav</code>).</li>
          <li><b>g0 slider:</b> rescales the gain curve upward/downward, changing the intersection and output.</li>
          <li><b>L slider:</b> changes the conversion from mirror reflectance to distributed loss (because of the <code>1/(2L)</code> factor), affecting both <code>a_r</code> and <code>τp</code>.</li>
        </ul>
      </div>
    </article>
  </main>
</div>

<footer>
  Built as a self-contained learning article (vanilla HTML/CSS/JS). The numerical defaults match the problem statement:
  <span style="font-family:var(--mono)">L=10 cm, R1=0.99, R2=1, g0=0.1 cm⁻¹, φs=1.43×10¹⁹ photons/(cm²·s), A=1 mm², λ=600 nm</span>.
</footer>

<script>
(function(){
  // ---------- Constants ----------
  const phiS = 1.43e19;            // photons/(cm^2 s)
  const R2 = 1.0;
  const n = 1.0;
  const c_cm = 3.0e10;             // cm/s
  const A_cm2 = 0.01;              // 1 mm^2 = 0.01 cm^2
  const lambda_m = 600e-9;         // m
  const h = 6.62607015e-34;        // J s
  const c_m = 299792458;           // m/s
  const hv = h * (c_m / lambda_m); // J/photon

  // ---------- Helpers ----------
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function fmtSci(x, sig=3){
    if(!isFinite(x)) return "—";
    if(x===0) return "0";
    const e = Math.floor(Math.log10(Math.abs(x)));
    const m = x / Math.pow(10,e);
    const mm = (Math.round(m*Math.pow(10, sig-1))/Math.pow(10, sig-1)).toFixed(Math.max(0, sig-1));
    return `${mm}×10^${e}`;
  }
  function fmt(x, digits=3){
    if(!isFinite(x)) return "—";
    return x.toFixed(digits);
  }

  // Convert reflectance to distributed loss coefficient (cm^-1) for a linear cavity of length L (cm)
  function a_m(R, Lcm){
    if(R<=0) return Infinity;
    if(R>=1) return 0;
    return (1/(2*Lcm)) * Math.log(1/R);
  }

  // Saturated gain model
  function g_of_phi(phi, g0){
    return g0 / (1 + phi/phiS);
  }

  // Solve for intracavity flux density from g(phi)=a_r
  function phi_cav_from_ar(g0, ar){
    if(ar<=0) return Infinity;
    if(g0<=ar) return 0; // below or at threshold in this simple model
    return phiS * (g0/ar - 1);
  }

  // Output flux density (standing-wave split): phi_out = (1-R1) * (phi_cav/2)
  function phi_out_from(phi_cav, R1){
    return (1 - R1) * phi_cav / 2;
  }

  function power_out(phi_out){
    const photons_per_s = A_cm2 * phi_out;
    return photons_per_s * hv; // W
  }

  function tau_p(ar){
    if(ar<=0) return Infinity;
    return n / (c_cm * ar); // s
  }

  // ---------- Canvas utilities ----------
  function setupCanvas(canvas){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(10, Math.floor(rect.width * dpr));
    const h = Math.max(10, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
    }
    const ctx = canvas.getContext('2d');
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
    return {ctx, w: rect.width, h: rect.height, dpr};
  }

  function clear(ctx, w, h){
    ctx.clearRect(0,0,w,h);
  }

  function drawPanelBackground(ctx, w, h){
    // subtle grid-like background gradient
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, "rgba(255,255,255,0.04)");
    g.addColorStop(1, "rgba(255,255,255,0.01)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
  }

  function drawAxes(ctx, w, h, plot, xLabel, yLabel){
    const {x0,y0,x1,y1} = plot;
    // axes
    ctx.strokeStyle = "rgba(255,255,255,0.55)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x0,y1); ctx.lineTo(x1,y1);
    ctx.moveTo(x0,y0); ctx.lineTo(x0,y1);
    ctx.stroke();

    // labels
    ctx.fillStyle = "rgba(233,238,252,0.92)";
    ctx.font = "12px ui-sans-serif, system-ui";
    ctx.textAlign = "center";
    ctx.fillText(xLabel, (x0+x1)/2, h - 8);

    ctx.save();
    ctx.translate(12, (y0+y1)/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = "center";
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();
  }

  function drawGridAndTicks(ctx, w, h, plot, xTicks, yTicks, xFmt, yFmt){
    const {x0,y0,x1,y1} = plot;
    ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ctx.fillStyle = "rgba(233,238,252,0.75)";
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 1;

    // vertical grid + ticks
    xTicks.forEach(t=>{
      const x = t.x;
      ctx.beginPath();
      ctx.moveTo(x,y0); ctx.lineTo(x,y1);
      ctx.stroke();
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.beginPath();
      ctx.moveTo(x,y1); ctx.lineTo(x,y1+5);
      ctx.stroke();
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.textAlign = "center";
      ctx.fillText(xFmt(t.v), x, y1+16);
    });

    // horizontal grid + ticks
    yTicks.forEach(t=>{
      const y = t.y;
      ctx.beginPath();
      ctx.moveTo(x0,y); ctx.lineTo(x1,y);
      ctx.stroke();
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.beginPath();
      ctx.moveTo(x0-5,y); ctx.lineTo(x0,y);
      ctx.stroke();
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.textAlign = "right";
      ctx.fillText(yFmt(t.v), x0-8, y+4);
    });
  }

  function legend(ctx, x, y, items){
    ctx.font = "12px ui-sans-serif, system-ui";
    ctx.textAlign = "left";
    let yy = y;
    items.forEach(it=>{
      ctx.fillStyle = it.color;
      ctx.fillRect(x, yy-9, 12, 12);
      ctx.fillStyle = "rgba(233,238,252,0.92)";
      ctx.fillText(it.label, x+18, yy+1);
      yy += 18;
    });
  }

  // ---------- Plots ----------
  function plotGainVsPhi(canvas, params){
    const {R1, g0, Lcm} = params;
    const {ctx, w, h} = setupCanvas(canvas);
    clear(ctx,w,h);
    drawPanelBackground(ctx,w,h);

    const padL=56, padR=16, padT=18, padB=36;
    const plot = {x0:padL, y0:padT, x1:w-padR, y1:h-padB};

    // compute losses
    const am1 = a_m(R1, Lcm);
    const ar = am1 + a_m(R2, Lcm); // + a_s (0)

    // x axis: log10(phi)
    const xMin = 14; // 1e14
    const xMax = 23; // 1e23

    // y axis: gain/loss in cm^-1
    // choose dynamic y range to show both g0 and ar comfortably
    const yMax = Math.max(g0*1.05, ar*3 + 1e-4);
    const yMin = 0;

    const X = (phi)=> {
      const lx = Math.log10(phi);
      const t = (lx - xMin)/(xMax-xMin);
      return plot.x0 + t*(plot.x1-plot.x0);
    };
    const Y = (val)=> {
      const t = (val - yMin)/(yMax-yMin);
      return plot.y1 - t*(plot.y1-plot.y0);
    };

    // ticks
    const xTicks = [];
    for(let e=xMin; e<=xMax; e+=1){
      const phi = Math.pow(10,e);
      xTicks.push({v:e, x:X(phi)});
    }
    const yTicks = [];
    const yStep = (yMax<=0.02)? 0.002 : (yMax<=0.1 ? 0.01 : 0.02);
    for(let yy=0; yy<=yMax+1e-12; yy+=yStep){
      yTicks.push({v:yy, y:Y(yy)});
    }

    drawGridAndTicks(
      ctx,w,h,plot,
      xTicks,
      yTicks,
      (e)=>`1e${e}`,
      (v)=> (v===0? "0" : v.toFixed(3))
    );
    drawAxes(ctx,w,h,plot, "Photon flux density φ (photons·cm⁻²·s⁻¹) [log scale]", "Gain / Loss (cm⁻¹)");

    // gain curve
    ctx.strokeStyle = "rgba(125,211,252,0.95)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    let started=false;
    const N=600;
    for(let i=0;i<=N;i++){
      const lx = xMin + (xMax-xMin)*i/N;
      const phi = Math.pow(10,lx);
      const g = g_of_phi(phi, g0);
      const x = X(phi), y = Y(g);
      if(!started){ ctx.moveTo(x,y); started=true; }
      else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // loss line
    ctx.strokeStyle = "rgba(167,139,250,0.95)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(plot.x0, Y(ar));
    ctx.lineTo(plot.x1, Y(ar));
    ctx.stroke();

    // intersection (phi_cav)
    const phiC = phi_cav_from_ar(g0, ar);
    if(isFinite(phiC) && phiC>0){
      const xI = X(phiC);
      const yI = Y(ar);
      // marker
      ctx.fillStyle = "rgba(52,211,153,0.95)";
      ctx.beginPath();
      ctx.arc(xI,yI,5,0,Math.PI*2);
      ctx.fill();

      // vertical line
      ctx.strokeStyle = "rgba(52,211,153,0.35)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(xI, plot.y0);
      ctx.lineTo(xI, plot.y1);
      ctx.stroke();

      // annotation
      ctx.fillStyle = "rgba(233,238,252,0.92)";
      ctx.font = "12px ui-sans-serif, system-ui";
      ctx.textAlign="left";
      const txt = `φ_cav ≈ ${fmtSci(phiC,3)}`;
      ctx.fillText(txt, clamp(xI+10, plot.x0+6, plot.x1-170), clamp(yI-10, plot.y0+14, plot.y1-8));
    }

    // title
    ctx.fillStyle="rgba(233,238,252,0.95)";
    ctx.font="13px ui-sans-serif, system-ui";
    ctx.textAlign="left";
    ctx.fillText("Saturated gain g(φ) and cavity loss a_r", plot.x0, 14);

    legend(ctx, plot.x0+8, plot.y0+18, [
      {color:"rgba(125,211,252,0.95)", label:"g(φ) = g0/(1+φ/φs)"},
      {color:"rgba(167,139,250,0.95)", label:"a_r (loss)"},
      {color:"rgba(52,211,153,0.95)", label:"intersection → φ_cav"}
    ]);
  }

  function plotSweepPower(canvas, params){
    const {R1, g0, Lcm} = params;
    const {ctx, w, h} = setupCanvas(canvas);
    clear(ctx,w,h);
    drawPanelBackground(ctx,w,h);

    const padL=56, padR=16, padT=18, padB=36;
    const plot = {x0:padL, y0:padT, x1:w-padR, y1:h-padB};

    const xMin=0.90, xMax=0.999;

    // sweep
    const xs=[], ys=[];
    let yMax=0;
    const N=220;
    for(let i=0;i<=N;i++){
      const r = xMin + (xMax-xMin)*i/N;
      const ar = a_m(r, Lcm) + a_m(R2, Lcm);
      const phiC = phi_cav_from_ar(g0, ar);
      const phiOut = phi_out_from(phiC, r);
      const P = power_out(phiOut); // W
      xs.push(r); ys.push(P);
      if(isFinite(P)) yMax = Math.max(yMax, P);
    }
    yMax *= 1.10;
    const yMin = 0;

    const X = (r)=>{
      const t=(r-xMin)/(xMax-xMin);
      return plot.x0 + t*(plot.x1-plot.x0);
    };
    const Y = (p)=>{
      const t=(p-yMin)/(yMax-yMin || 1);
      return plot.y1 - t*(plot.y1-plot.y0);
    };

    // ticks
    const xTicks = [];
    for(let r=0.90; r<=1.0001; r+=0.02){
      xTicks.push({v:r, x:X(r)});
    }
    const yTicks=[];
    const yStep = (yMax<=0.02)? 0.002 : (yMax<=0.1 ? 0.01 : 0.02);
    for(let yy=0; yy<=yMax+1e-12; yy+=yStep){
      yTicks.push({v:yy, y:Y(yy)});
    }

    drawGridAndTicks(
      ctx,w,h,plot,
      xTicks,
      yTicks,
      (v)=>v.toFixed(2),
      (v)=> (v===0? "0" : (v*1000).toFixed(0)+" mW")
    );
    drawAxes(ctx,w,h,plot, "R1 (output-coupler reflectance)", "Output power P0 (W)");

    // curve
    ctx.strokeStyle="rgba(125,211,252,0.95)";
    ctx.lineWidth=2;
    ctx.beginPath();
    xs.forEach((r,i)=>{
      const x=X(r), y=Y(ys[i]);
      if(i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    });
    ctx.stroke();

    // marker at current R1
    const arNow = a_m(R1, Lcm) + a_m(R2, Lcm);
    const phiCNow = phi_cav_from_ar(g0, arNow);
    const phiOutNow = phi_out_from(phiCNow, R1);
    const PNow = power_out(phiOutNow);
    if(isFinite(PNow)){
      ctx.fillStyle="rgba(52,211,153,0.95)";
      ctx.beginPath();
      ctx.arc(X(R1), Y(PNow), 5, 0, Math.PI*2);
      ctx.fill();

      ctx.strokeStyle="rgba(52,211,153,0.35)";
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(X(R1), plot.y0);
      ctx.lineTo(X(R1), plot.y1);
      ctx.stroke();

      ctx.fillStyle="rgba(233,238,252,0.92)";
      ctx.font="12px ui-sans-serif, system-ui";
      ctx.textAlign="left";
      ctx.fillText(`P0 ≈ ${(PNow*1000).toFixed(1)} mW`, clamp(X(R1)+10, plot.x0+6, plot.x1-140), clamp(Y(PNow)-10, plot.y0+14, plot.y1-8));
    }

    ctx.fillStyle="rgba(233,238,252,0.95)";
    ctx.font="13px ui-sans-serif, system-ui";
    ctx.textAlign="left";
    ctx.fillText("Output power vs output-coupler reflectance (sweep)", plot.x0, 14);

    legend(ctx, plot.x0+8, plot.y0+18, [
      {color:"rgba(125,211,252,0.95)", label:"P0(R1) with gain saturation"},
      {color:"rgba(52,211,153,0.95)", label:"current R1 marker"}
    ]);
  }

  function plotSweepLifetime(canvas, params){
    const {R1, Lcm} = params;
    const {ctx, w, h} = setupCanvas(canvas);
    clear(ctx,w,h);
    drawPanelBackground(ctx,w,h);

    const padL=56, padR=16, padT=18, padB=36;
    const plot = {x0:padL, y0:padT, x1:w-padR, y1:h-padB};

    const xMin=0.90, xMax=0.999;

    const xs=[], ys=[];
    let yMax=0;
    const N=220;
    for(let i=0;i<=N;i++){
      const r = xMin + (xMax-xMin)*i/N;
      const ar = a_m(r, Lcm) + a_m(R2, Lcm);
      const tau = tau_p(ar); // s
      xs.push(r); ys.push(tau);
      if(isFinite(tau)) yMax = Math.max(yMax, tau);
    }
    yMax *= 1.12;
    const yMin = 0;

    const X=(r)=> plot.x0 + ((r-xMin)/(xMax-xMin))*(plot.x1-plot.x0);
    const Y=(t)=> plot.y1 - ((t-yMin)/(yMax-yMin || 1))*(plot.y1-plot.y0);

    const xTicks=[];
    for(let r=0.90; r<=1.0001; r+=0.02){
      xTicks.push({v:r, x:X(r)});
    }
    const yTicks=[];
    // ticks in ns for readability
    const yMaxNs = yMax*1e9;
    const stepNs = (yMaxNs<=100)? 10 : (yMaxNs<=400? 50 : 100);
    for(let nsVal=0; nsVal<=yMaxNs+1e-9; nsVal+=stepNs){
      yTicks.push({v:nsVal*1e-9, y:Y(nsVal*1e-9)});
    }

    drawGridAndTicks(
      ctx,w,h,plot,
      xTicks,
      yTicks,
      (v)=>v.toFixed(2),
      (v)=> (v===0? "0" : (v*1e9).toFixed(0)+" ns")
    );
    drawAxes(ctx,w,h,plot, "R1 (output-coupler reflectance)", "Photon lifetime τp (s)");

    ctx.strokeStyle="rgba(167,139,250,0.95)";
    ctx.lineWidth=2;
    ctx.beginPath();
    xs.forEach((r,i)=>{
      const x=X(r), y=Y(ys[i]);
      if(i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    });
    ctx.stroke();

    // marker at current R1
    const arNow = a_m(R1, Lcm) + a_m(R2, Lcm);
    const tauNow = tau_p(arNow);
    if(isFinite(tauNow)){
      ctx.fillStyle="rgba(52,211,153,0.95)";
      ctx.beginPath();
      ctx.arc(X(R1), Y(tauNow), 5, 0, Math.PI*2);
      ctx.fill();

      ctx.strokeStyle="rgba(52,211,153,0.35)";
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(X(R1), plot.y0);
      ctx.lineTo(X(R1), plot.y1);
      ctx.stroke();

      ctx.fillStyle="rgba(233,238,252,0.92)";
      ctx.font="12px ui-sans-serif, system-ui";
      ctx.textAlign="left";
      ctx.fillText(`τp ≈ ${(tauNow*1e9).toFixed(1)} ns`, clamp(X(R1)+10, plot.x0+6, plot.x1-140), clamp(Y(tauNow)-10, plot.y0+14, plot.y1-8));
    }

    ctx.fillStyle="rgba(233,238,252,0.95)";
    ctx.font="13px ui-sans-serif, system-ui";
    ctx.textAlign="left";
    ctx.fillText("Photon lifetime vs R1 (sweep)", plot.x0, 14);

    legend(ctx, plot.x0+8, plot.y0+18, [
      {color:"rgba(167,139,250,0.95)", label:"τp(R1) = n/(c a_r)"},
      {color:"rgba(52,211,153,0.95)", label:"current R1 marker"}
    ]);
  }

  function drawDiagram(canvas, params){
    const {R1, g0, Lcm} = params;
    const {ctx, w, h} = setupCanvas(canvas);
    clear(ctx,w,h);
    drawPanelBackground(ctx,w,h);

    // geometry box
    const pad=18;
    const x0=pad, y0=pad+10, x1=w-pad, y1=h-pad;
    const midY=(y0+y1)/2;

    // cavity line
    ctx.strokeStyle="rgba(233,238,252,0.75)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(x0+40, midY);
    ctx.lineTo(x1-40, midY);
    ctx.stroke();

    // mirrors
    function mirror(x, label, reflect){
      ctx.save();
      ctx.translate(x, midY);
      ctx.strokeStyle="rgba(125,211,252,0.95)";
      ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(0,-42);
      ctx.lineTo(0,42);
      ctx.stroke();

      // hatch
      ctx.strokeStyle="rgba(125,211,252,0.35)";
      ctx.lineWidth=1.5;
      for(let i=-38;i<=38;i+=10){
        ctx.beginPath();
        ctx.moveTo(0,i);
        ctx.lineTo(14,i+8);
        ctx.stroke();
      }

      ctx.fillStyle="rgba(233,238,252,0.92)";
      ctx.font="12px ui-sans-serif, system-ui";
      ctx.textAlign="center";
      ctx.fillText(label, 0, -52);
      ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillStyle="rgba(233,238,252,0.80)";
      ctx.fillText(`R=${reflect.toFixed(3)}`, 0, 60);

      ctx.restore();
    }

    mirror(x0+40, "Mirror 1 (Output)", R1);
    mirror(x1-40, "Mirror 2 (HR)", 1.000);

    // gain medium region
    const gmX = x0+70;
    const gmW = (x1-x0)-140;
    ctx.fillStyle="rgba(52,211,153,0.12)";
    ctx.strokeStyle="rgba(52,211,153,0.45)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.roundRect(gmX, midY-28, gmW, 56, 14);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle="rgba(233,238,252,0.92)";
    ctx.font="12px ui-sans-serif, system-ui";
    ctx.textAlign="center";
    ctx.fillText("Gain medium (single-mode)", gmX + gmW/2, midY-36);

    // length arrow
    ctx.strokeStyle="rgba(167,139,250,0.9)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(x0+55, midY+80);
    ctx.lineTo(x1-55, midY+80);
    ctx.stroke();

    // arrowheads
    function arrowHead(x,y,dir){
      ctx.save();
      ctx.translate(x,y);
      ctx.rotate(dir);
      ctx.fillStyle="rgba(167,139,250,0.9)";
      ctx.beginPath();
      ctx.moveTo(0,0); ctx.lineTo(10,4); ctx.lineTo(10,-4);
      ctx.closePath(); ctx.fill();
      ctx.restore();
    }
    arrowHead(x0+55, midY+80, Math.PI);
    arrowHead(x1-55, midY+80, 0);

    ctx.fillStyle="rgba(233,238,252,0.90)";
    ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ctx.textAlign="center";
    ctx.fillText(`L = ${Lcm.toFixed(1)} cm`, (x0+x1)/2, midY+100);

    // output beam
    ctx.strokeStyle="rgba(251,191,36,0.9)";
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(x0+40, midY);
    ctx.lineTo(x0+5, midY);
    ctx.stroke();
    arrowHead(x0+5, midY, Math.PI);

    ctx.fillStyle="rgba(254,243,199,0.95)";
    ctx.font="12px ui-sans-serif, system-ui";
    ctx.textAlign="left";
    ctx.fillText(`Output through mirror 1`, x0+6, midY-14);

    ctx.fillStyle="rgba(233,238,252,0.78)";
    ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ctx.fillText(`T1 ≈ 1−R1 = ${(1-R1).toFixed(3)}`, x0+6, midY+18);

    // text box with key parameters
    const boxX = x1-260;
    const boxY = y0+10;
    const boxW = 240;
    const boxH = 112;
    ctx.fillStyle="rgba(0,0,0,0.22)";
    ctx.strokeStyle="rgba(255,255,255,0.14)";
    ctx.lineWidth=1.5;
    ctx.beginPath();
    ctx.roundRect(boxX, boxY, boxW, boxH, 14);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle="rgba(233,238,252,0.92)";
    ctx.font="12px ui-sans-serif, system-ui";
    ctx.textAlign="left";
    ctx.fillText("Model inputs", boxX+12, boxY+20);

    ctx.fillStyle="rgba(233,238,252,0.78)";
    ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ctx.fillText(`g0 = ${g0.toFixed(3)} cm^-1`, boxX+12, boxY+42);
    ctx.fillText(`φs = 1.43e19`, boxX+12, boxY+60);
    ctx.fillText(`A = 0.01 cm^2`, boxX+12, boxY+78);
    ctx.fillText(`λ = 600 nm`, boxX+12, boxY+96);

    // title
    ctx.fillStyle="rgba(233,238,252,0.95)";
    ctx.font="13px ui-sans-serif, system-ui";
    ctx.textAlign="left";
    ctx.fillText("Linear cavity setup used in the calculations", x0, 14);
  }

  // ---------- Live results rendering ----------
  const els = {
    slR1: document.getElementById('slR1'),
    slG0: document.getElementById('slG0'),
    slL: document.getElementById('slL'),
    labR1: document.getElementById('labR1'),
    labG0: document.getElementById('labG0'),
    labL: document.getElementById('labL'),
    out_am1: document.getElementById('out_am1'),
    out_ar: document.getElementById('out_ar'),
    out_tau: document.getElementById('out_tau'),
    out_phic: document.getElementById('out_phic'),
    out_phio: document.getElementById('out_phio'),
    out_P: document.getElementById('out_P'),
    cDiagram: document.getElementById('cDiagram'),
    cMain: document.getElementById('cMain'),
    cSweep: document.getElementById('cSweep'),
    cSweep2: document.getElementById('cSweep2')
  };

  function getParams(){
    const R1 = parseFloat(els.slR1.value);
    const g0 = parseFloat(els.slG0.value);
    const Lcm = parseFloat(els.slL.value);
    return {R1, g0, Lcm};
  }

  function updateLabels(p){
    els.labR1.textContent = p.R1.toFixed(3);
    els.labG0.textContent = p.g0.toFixed(3);
    els.labL.textContent = p.Lcm.toFixed(1);
  }

  function updateNumbers(p){
    const am1 = a_m(p.R1, p.Lcm);
    const am2 = a_m(R2, p.Lcm);
    const ar = am1 + am2;
    const tau = tau_p(ar);
    const phiC = phi_cav_from_ar(p.g0, ar);
    const phiO = phi_out_from(phiC, p.R1);
    const P = power_out(phiO);

    els.out_am1.innerHTML = `<b>${fmtSci(am1,3)}</b>`;
    els.out_ar.innerHTML  = `<b>${fmtSci(ar,3)}</b>`;
    els.out_tau.innerHTML = `<b>${isFinite(tau)? (tau*1e9).toFixed(1) : "∞"}</b>`;
    els.out_phic.innerHTML= `<b>${isFinite(phiC)? fmtSci(phiC,3) : "∞"}</b>`;
    els.out_phio.innerHTML= `<b>${isFinite(phiO)? fmtSci(phiO,3) : "∞"}</b>`;
    els.out_P.innerHTML   = `<b>${isFinite(P)? (P*1000).toFixed(1) : "—"}</b>`;
  }

  function renderAll(){
    const p = getParams();
    updateLabels(p);
    updateNumbers(p);
    drawDiagram(els.cDiagram, p);
    plotGainVsPhi(els.cMain, p);
    plotSweepPower(els.cSweep, p);
    plotSweepLifetime(els.cSweep2, p);
  }

  // ---------- Copy buttons ----------
  function copyText(text){
    if(navigator.clipboard && navigator.clipboard.writeText){
      navigator.clipboard.writeText(text).catch(()=>{});
    }else{
      const ta=document.createElement('textarea');
      ta.value=text;
      document.body.appendChild(ta);
      ta.select();
      try{ document.execCommand('copy'); }catch(e){}
      document.body.removeChild(ta);
    }
  }
  document.querySelectorAll('.copyBtn[data-copy]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      copyText(btn.getAttribute('data-copy'));
      const old = btn.textContent;
      btn.textContent = "Copied ✓";
      setTimeout(()=>btn.textContent=old, 900);
    });
  });

  // ---------- Interactivity ----------
  ['input','change'].forEach(ev=>{
    els.slR1.addEventListener(ev, renderAll);
    els.slG0.addEventListener(ev, renderAll);
    els.slL.addEventListener(ev, renderAll);
  });

  // Resize handling
  let resizeTimer=null;
  window.addEventListener('resize', ()=>{
    clearTimeout(resizeTimer);
    resizeTimer=setTimeout(renderAll, 120);
  });

  // Initial render
  renderAll();
})();
</script>
</body>
</html>
