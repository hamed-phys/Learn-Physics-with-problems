<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Prism Coupler for Exciting an Ag–Air Surface Plasmon Polariton (SPP)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:rgba(255,255,255,0.06);
      --card2:rgba(255,255,255,0.085);
      --text:rgba(255,255,255,0.92);
      --muted:rgba(255,255,255,0.72);
      --faint:rgba(255,255,255,0.55);
      --line:rgba(255,255,255,0.12);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 14px 40px rgba(0,0,0,0.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background: radial-gradient(1200px 800px at 20% 5%, rgba(125,211,252,0.18), transparent 55%),
                  radial-gradient(900px 700px at 90% 20%, rgba(167,139,250,0.15), transparent 60%),
                  radial-gradient(1000px 700px at 50% 95%, rgba(52,211,153,0.10), transparent 60%),
                  var(--bg);
      line-height:1.55;
    }

    header{
      padding: 2.2rem 1.2rem 1.0rem;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), transparent);
    }
    header .wrap{
      max-width:1100px;
      margin:0 auto;
      display:grid;
      gap:0.8rem;
    }
    h1{
      margin:0;
      letter-spacing:-0.02em;
      font-size: clamp(1.55rem, 2.5vw, 2.4rem);
      line-height:1.15;
    }
    .subtitle{
      color:var(--muted);
      max-width: 76ch;
      font-size: 1.02rem;
    }

    main{
      max-width:1100px;
      margin:0 auto;
      padding: 1.2rem 1.2rem 2.4rem;
      display:grid;
      grid-template-columns: 280px 1fr;
      gap: 1.1rem;
      align-items:start;
    }

    nav.toc{
      position: sticky;
      top: 0.9rem;
      align-self:start;
      border:1px solid var(--line);
      background: rgba(255,255,255,0.04);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 0.9rem 0.85rem;
      backdrop-filter: blur(10px);
    }
    .toc h2{
      margin:0 0 0.55rem;
      font-size:0.95rem;
      color:var(--muted);
      letter-spacing:0.02em;
      text-transform:uppercase;
    }
    .toc a{
      display:block;
      padding:0.42rem 0.45rem;
      margin:0.10rem 0;
      border-radius: 10px;
      text-decoration:none;
      color:var(--text);
      font-size:0.95rem;
      border:1px solid transparent;
    }
    .toc a:hover{
      background: rgba(255,255,255,0.06);
      border-color: rgba(125,211,252,0.22);
    }

    article{
      display:grid;
      gap: 1.0rem;
      min-width:0;
    }

    section{
      border:1px solid var(--line);
      background: rgba(255,255,255,0.04);
      border-radius: 18px;
      padding: 1.05rem 1.05rem;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }

    section h2{
      margin:0 0 0.6rem;
      font-size: 1.25rem;
      letter-spacing:-0.01em;
    }
    section h3{
      margin: 0.9rem 0 0.35rem;
      font-size: 1.06rem;
      color: rgba(255,255,255,0.90);
    }
    p{margin:0.4rem 0; color: var(--text)}
    ul{margin:0.45rem 0 0.2rem 1.1rem; color: var(--text)}
    li{margin:0.25rem 0}
    .muted{color:var(--muted)}
    .faint{color:var(--faint)}
    .small{font-size:0.95rem}
    .kicker{
      color: var(--muted);
      font-size: 0.92rem;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }

    .grid{
      display:grid;
      gap:0.85rem;
    }
    .grid.two{grid-template-columns: 1fr 1fr;}
    .grid.three{grid-template-columns: 1fr 1fr 1fr;}
    @media (max-width: 980px){
      main{grid-template-columns: 1fr;}
      nav.toc{position:relative; top:auto;}
      .grid.two, .grid.three{grid-template-columns:1fr;}
    }

    .callout{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.035));
      border-radius: 16px;
      padding: 0.85rem 0.85rem;
      position:relative;
      overflow:hidden;
    }
    .callout:before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(600px 140px at 20% 0%, rgba(125,211,252,0.22), transparent 60%),
                  radial-gradient(500px 140px at 80% 0%, rgba(167,139,250,0.18), transparent 60%);
      opacity:0.6;
      pointer-events:none;
    }
    .callout > *{position:relative}
    .pill{
      display:inline-flex;
      align-items:center;
      gap:0.45rem;
      padding:0.22rem 0.55rem;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.18);
      color: var(--muted);
      font-size:0.86rem;
      margin-bottom:0.45rem;
    }
    .pill b{color:var(--text); font-weight:600}

    .eqbox{
      border:1px dashed rgba(125,211,252,0.35);
      background: rgba(125,211,252,0.06);
      border-radius: 14px;
      padding: 0.7rem 0.75rem;
      margin: 0.55rem 0;
    }
    .eq{
      font-family: var(--mono);
      font-size: 0.96rem;
      white-space: pre-wrap;
      word-break: break-word;
      color: rgba(255,255,255,0.92);
    }

    .btnrow{
      display:flex;
      flex-wrap:wrap;
      gap:0.5rem;
      margin-top:0.55rem;
    }
    button.copy{
      appearance:none;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 0.5rem 0.65rem;
      border-radius: 12px;
      cursor:pointer;
      font-size:0.92rem;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
    }
    button.copy:hover{background: rgba(255,255,255,0.10); border-color: rgba(125,211,252,0.35);}
    button.copy:active{transform: translateY(1px) scale(0.99);}

    .canvasCard{
      border:1px solid var(--line);
      background: rgba(255,255,255,0.03);
      border-radius: 16px;
      padding: 0.75rem;
      overflow:hidden;
    }
    .canvasTitle{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:0.8rem;
      margin: 0 0 0.5rem;
    }
    .canvasTitle h3{margin:0; font-size:1.02rem;}
    .canvasTitle .meta{font-size:0.9rem; color:var(--muted);}
    canvas{
      width:100%;
      height: 280px;
      display:block;
      border-radius: 12px;
      background: rgba(0,0,0,0.18);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .controls{
      display:grid;
      gap:0.75rem;
      grid-template-columns: 1fr 1fr 1fr;
      margin-top: 0.7rem;
    }
    @media (max-width: 980px){
      canvas{height: 260px;}
      .controls{grid-template-columns: 1fr;}
    }
    label{
      display:grid;
      gap:0.25rem;
      color:var(--muted);
      font-size:0.92rem;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      padding: 0.6rem 0.65rem;
    }
    input[type="range"]{width:100%}
    .val{
      font-family: var(--mono);
      color: var(--text);
      font-size: 0.92rem;
    }

    .answer{
      border:1px solid rgba(52,211,153,0.35);
      background: rgba(52,211,153,0.07);
      border-radius: 16px;
      padding: 0.85rem 0.85rem;
    }
    .answer .big{
      font-size: 1.05rem;
      font-family: var(--mono);
      margin-top:0.35rem;
      white-space: pre-wrap;
    }

    .assumptions{
      border:1px solid rgba(251,191,36,0.30);
      background: rgba(251,191,36,0.06);
      border-radius: 16px;
      padding: 0.85rem 0.85rem;
    }
    .mistakes{
      border:1px solid rgba(251,113,133,0.30);
      background: rgba(251,113,133,0.06);
      border-radius: 16px;
      padding: 0.85rem 0.85rem;
    }

    .fadeIn{
      animation: fadeIn 420ms ease both;
    }
    @keyframes fadeIn{
      from{opacity:0; transform: translateY(6px)}
      to{opacity:1; transform: translateY(0)}
    }

    footer{
      max-width:1100px;
      margin: 0 auto;
      padding: 1.0rem 1.2rem 2.4rem;
      color: var(--muted);
    }

    /* print-friendly */
    @media print{
      body{background:#fff; color:#000;}
      header, nav.toc, .canvasCard, .controls, button.copy{display:none !important;}
      main{max-width:100%; padding:0; grid-template-columns: 1fr;}
      section{box-shadow:none; border:1px solid #ddd; background:#fff;}
      .eq{color:#000;}
    }
  </style>
</head>
<body>
<header class="fadeIn">
  <div class="wrap">
    <div class="kicker">Photonics • Surface Plasmons • Prism Coupling (Kretschmann-style)</div>
    <h1>8.2-2 — Prism Coupler for Exciting an Ag–Air SPP Wave</h1>
    <p class="subtitle">
      We compute the <b>incidence angle inside a SiN prism</b> (n = 2.0) needed to <b>phase-match</b> a light wave to the
      <b>Ag–air surface plasmon polariton (SPP)</b> at λ<sub>0</sub> = 700 nm, given the silver permittivity
      ε<sub>Ag</sub> = −20 + j1.3. Along the way, you’ll learn the SPP dispersion relation and why prism coupling works.
    </p>
  </div>
</header>

<main>
  <nav class="toc fadeIn" aria-label="Table of contents">
    <h2>Contents</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
  </nav>

  <article>
    <section id="quick" class="fadeIn">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>What this is about:</b> Using a high-index prism to excite an <b>SPP</b> on the <b>Ag–air interface</b> by <b>phase matching</b>.</li>
        <li><b>Key physics idea:</b> Match the in-plane wavevector of light in the prism to the SPP propagation constant: <span class="muted">k<sub>x</sub> = Re{β}</span>.</li>
        <li><b>Governing dispersion (SPP):</b> <span class="muted">β = k<sub>0</sub> √( ε<sub>m</sub> ε<sub>d</sub> / (ε<sub>m</sub>+ε<sub>d</sub>) )</span> (metal–dielectric interface).</li>
        <li><b>Prism in-plane component:</b> <span class="muted">k<sub>x</sub> = n<sub>p</sub> k<sub>0</sub> sinθ<sub>p</sub></span> (θ<sub>p</sub> measured inside the prism from the normal).</li>
        <li><b>Result type:</b> Numeric resonance angle θ<sub>p</sub> (with a clear symbolic formula you can reuse).</li>
        <li><b>Given values:</b> λ<sub>0</sub>=700 nm, ε<sub>Ag</sub>=−20+j1.3, ε<sub>air</sub>=1, n<sub>p</sub>=2.0.</li>
        <li><b>Final answer:</b> θ<sub>p</sub> ≈ <b>30.9°</b> inside the prism (slightly above the prism–air critical angle 30°).</li>
      </ul>
    </section>

    <section id="part0" class="fadeIn">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="grid two">
        <div>
          <h3>Core definitions (symbols & units)</h3>
          <ul>
            <li><b>Free-space wavenumber:</b> k<sub>0</sub> = 2π/λ<sub>0</sub> <span class="muted">[rad·m⁻¹]</span></li>
            <li><b>Relative permittivity:</b> ε = ε′ + jε″ (dimensionless). Metals typically have ε′ &lt; 0 at optical frequencies.</li>
            <li><b>SPP propagation constant:</b> β (complex) along the interface <span class="muted">[rad·m⁻¹]</span>. Re{β} sets the phase velocity; Im{β} sets loss/attenuation.</li>
            <li><b>Effective index of the SPP:</b> n<sub>eff</sub> ≡ β/k<sub>0</sub> (complex, dimensionless).</li>
            <li><b>Prism index:</b> n<sub>p</sub> (dimensionless); incident angle inside prism: θ<sub>p</sub> <span class="muted">[deg or rad]</span>.</li>
          </ul>
        </div>

        <div>
          <h3>Physical meaning (what these quantities represent)</h3>
          <ul>
            <li><b>SPP:</b> A surface-bound electromagnetic wave coupled to collective electron motion in the metal, confined near the interface.</li>
            <li><b>Why β matters:</b> The SPP has a larger in-plane momentum than a free-space photon in the adjacent dielectric; this mismatch prevents direct excitation from air.</li>
            <li><b>Prism coupling:</b> A high-index prism increases the in-plane component k<sub>x</sub> so light can “reach” the SPP momentum.</li>
            <li><b>Evanescent field:</b> At sufficiently large θ<sub>p</sub>, the field beyond the prism boundary becomes evanescent, enabling strong near-field coupling through the metal film.</li>
          </ul>
        </div>
      </div>

      <h3>Key laws/principles & validity</h3>
      <div class="callout">
        <div class="pill"><b>Principle</b> Phase matching (momentum conservation parallel to the interface)</div>
        <p>
          In a stratified planar system, the <b>tangential wavevector</b> (parallel to interfaces) is conserved.
          To excite the SPP, we require:
        </p>
        <div class="eqbox">
          <div class="eq" data-copy="k_x = n_p k_0 sin(theta_p)  ≈  Re{β_SPP}">
k_x = n_p k_0 sin(θ_p)  ≈  Re{β_SPP}</div>
        </div>
        <p class="muted small">
          We typically match to <b>Re{β}</b> because Im{β} describes damping, not phase advance.
          This is valid when losses are modest (common at visible/near-IR for noble metals).
        </p>
      </div>

      <h3>Common models/approximations (and why)</h3>
      <ul>
        <li><b>Single-interface SPP dispersion:</b> We use the standard metal–dielectric interface formula for β.
            The problem explicitly says the prism does not disturb the Ag–air SPP dispersion.</li>
        <li><b>ε<sub>d</sub> = 1 for air:</b> Good approximation at optical frequencies.</li>
        <li><b>Use Re{n<sub>eff</sub>} for matching:</b> Captures resonance angle; Im part mainly affects dip depth/width in reflectance.</li>
      </ul>

      <h3>Mini intuition examples (quick)</h3>
      <ul>
        <li>If ε′<sub>m</sub> becomes <i>more negative</i> (e.g., −40 instead of −20), the SPP becomes <b>less photon-like</b>, n<sub>eff</sub> moves closer to 1, and the required θ<sub>p</sub> typically <b>decreases</b>.</li>
        <li>If n<sub>p</sub> increases, the same in-plane momentum can be reached at a <b>smaller angle</b> because k<sub>x</sub> = n<sub>p</sub>k<sub>0</sub>sinθ grows with n<sub>p</sub>.</li>
      </ul>

      <div class="mistakes">
        <div class="pill"><b>What to watch for</b></div>
        <ul>
          <li>Mixing up <b>θ in the prism</b> vs external angle in air (Snell’s law!). Here we want θ<sub>p</sub> <i>inside the prism</i>.</li>
          <li>Forgetting that β is complex: match the <b>real part</b> for phase matching.</li>
          <li>Using refractive index instead of permittivity: the SPP formula uses <b>ε</b>, not n directly.</li>
          <li>Not checking feasibility: you need Re{n<sub>eff</sub>} ≤ n<sub>p</sub> (otherwise sinθ &gt; 1 → impossible).</li>
        </ul>
      </div>
    </section>

    <section id="part1" class="fadeIn">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Problem restatement (in plain words)</h3>
      <p>
        We have a <b>60 nm Ag film</b> with <b>air</b> on one side and a <b>SiN prism</b> (n<sub>p</sub>=2.0) touching the other side.
        At λ<sub>0</sub>=700 nm, silver has ε<sub>Ag</sub>=−20 + j1.3. Find the <b>incident angle inside the prism</b>,
        θ<sub>p</sub>, such that the light couples to the <b>Ag–air SPP</b>. We are told to assume the Ag–air SPP dispersion is
        the same as if the prism were not there.
      </p>

      <div class="grid two">
        <div class="callout">
          <div class="pill"><b>Given</b></div>
          <ul>
            <li>λ<sub>0</sub> = 700 nm</li>
            <li>n<sub>p</sub> = 2.0 (SiN prism)</li>
            <li>ε<sub>m</sub> (Ag) = −20 + j1.3</li>
            <li>ε<sub>d</sub> (air) ≈ 1</li>
            <li>Ag film thickness = 60 nm (but dispersion assumed undisturbed)</li>
          </ul>
        </div>

        <div class="callout">
          <div class="pill"><b>Unknown</b></div>
          <ul>
            <li>θ<sub>p</sub> = incidence angle <i>inside the prism</i> that satisfies phase matching.</li>
          </ul>
          <div class="pill" style="margin-top:0.5rem;"><b>Must find</b></div>
          <ul>
            <li>A numeric value (degrees) and the reusable formula for θ<sub>p</sub>.</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li><b>SPP dispersion at a flat metal–dielectric interface:</b> determines β for the Ag–air mode.</li>
        <li><b>Conservation of tangential wavevector:</b> the in-plane momentum of the incident wave in the prism must equal that of the SPP (phase matching).</li>
        <li><b>Why not full multilayer Fresnel math here?</b> The question asks only for the required angle and explicitly states the SPP dispersion is undisturbed—so we can bypass full transfer-matrix reflectance modeling.</li>
      </ul>

      <div class="assumptions">
        <div class="pill"><b>Assumptions</b></div>
        <ul>
          <li>Planar interfaces, monochromatic steady-state waves.</li>
          <li>Air ε<sub>d</sub>=1; prism is lossless with index n<sub>p</sub>=2.0.</li>
          <li>SPP dispersion is that of the <b>Ag–air single interface</b>, unaffected by prism/film thickness (as stated).</li>
          <li>Phase matching uses <b>Re{β}</b> (losses small enough that resonance angle is set by phase, not damping).</li>
        </ul>
      </div>

      <h3>Possible approaches (compare & choose)</h3>
      <ul>
        <li><b>(A) Direct phase-matching + SPP dispersion (best here):</b> Compute β from the Ag–air formula, then solve n<sub>p</sub>k<sub>0</sub>sinθ = Re{β}. Fast and matches the problem’s assumptions.</li>
        <li><b>(B) Full multilayer (transfer-matrix) reflectance dip:</b> More realistic for finite film thickness; gives dip width and depth. Overkill for the asked quantity.</li>
        <li><b>(C) Numerical mode solver:</b> Would handle disturbances and exact geometry. Not needed given the instruction “undisturbed dispersion.”</li>
      </ul>
      <p><b>Chosen:</b> Approach (A), because the problem statement explicitly permits it and asks only for the coupling angle.</p>
    </section>

    <section id="part2" class="fadeIn">
      <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

      <ol>
        <li>
          <b>Compute k<sub>0</sub></b> from λ<sub>0</sub>.
          <div class="muted small">Tool: k<sub>0</sub>=2π/λ<sub>0</sub>. Physical meaning: sets the basic spatial scale of phase change in free space.</div>
        </li>
        <li>
          <b>Write the SPP dispersion</b> for a metal–dielectric interface.
          <div class="muted small">Tool: β = k<sub>0</sub>√(ε<sub>m</sub>ε<sub>d</sub>/(ε<sub>m</sub>+ε<sub>d</sub>)). Physical meaning: SPP carries larger in-plane momentum than light in the dielectric.</div>
        </li>
        <li>
          <b>Convert to effective index</b> n<sub>eff</sub>=β/k<sub>0</sub>.
          <div class="muted small">This simplifies matching because k<sub>0</sub> cancels in the angle equation.</div>
        </li>
        <li>
          <b>Apply phase matching</b>: n<sub>p</sub>k<sub>0</sub>sinθ<sub>p</sub> = Re{β} ⇒ sinθ<sub>p</sub>=Re{n<sub>eff</sub>}/n<sub>p</sub>.
          <div class="muted small">Physical meaning: prism supplies extra tangential momentum.</div>
        </li>
        <li>
          <b>Check feasibility</b>: Re{n<sub>eff</sub>} ≤ n<sub>p</sub and sinθ<sub>p</sub> ≤ 1.
          <div class="muted small">If not, no coupling by this prism index.</div>
        </li>
        <li>
          <b>Compute θ<sub>p</sub></b> and do quick sanity checks (critical angle, magnitude).
          <div class="muted small">Tip: compare to θ<sub>c</sub>=arcsin(1/n<sub>p</sub>) to see if it’s in the evanescent regime.</div>
        </li>
      </ol>

      <div class="mistakes">
        <div class="pill"><b>Common mistakes & quick tips</b></div>
        <ul>
          <li><b>Tip:</b> Keep ε complex through the square-root, then take <b>Re</b> at the end for phase matching.</li>
          <li><b>Tip:</b> Ensure θ is the angle <b>inside the prism</b> relative to the normal.</li>
          <li><b>Tip:</b> If your θ ends up &lt; θ<sub>c</sub>, you might not get strong evanescent coupling in the classic picture.</li>
        </ul>
      </div>
    </section>

    <section id="part3" class="fadeIn">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Physical intuition (before calculating)</h3>
      <p>
        An SPP at the Ag–air interface typically has an effective index slightly larger than 1 (because it is bound and carries
        extra momentum). Since the prism has n<sub>p</sub>=2, it can supply k<sub>x</sub> up to 2k<sub>0</sub> (at grazing incidence),
        so matching should be possible at a moderate angle. Because Re{n<sub>eff</sub>} is only slightly above 1, we expect
        sinθ<sub>p</sub> ≈ (a bit above 1)/2 ≈ 0.5 → θ<sub>p</sub> near 30°.
      </p>

      <h3>Step 1 — SPP dispersion at a metal–dielectric interface</h3>
      <p>
        For a flat interface between a metal (permittivity ε<sub>m</sub>) and dielectric (ε<sub>d</sub>), the TM SPP dispersion is:
      </p>
      <div class="eqbox">
        <div class="eq" data-copy="beta_SPP = k0 * sqrt( (eps_m * eps_d) / (eps_m + eps_d) )">
β_SPP = k0 * √( (ε_m ε_d) / (ε_m + ε_d) )</div>
      </div>
      <p class="muted small">
        Here k<sub>0</sub>=2π/λ<sub>0</sub>. β is generally complex because metals have loss (ε″ &gt; 0).
      </p>

      <h3>Step 2 — Define the SPP effective index</h3>
      <p>
        Divide by k<sub>0</sub> to get a dimensionless effective index:
      </p>
      <div class="eqbox">
        <div class="eq" data-copy="n_eff = beta_SPP / k0 = sqrt( (eps_m * eps_d) / (eps_m + eps_d) )">
n_eff = β_SPP / k0 = √( (ε_m ε_d) / (ε_m + ε_d) )</div>
      </div>
      <p>
        For air, ε<sub>d</sub>≈1, so:
      </p>
      <div class="eqbox">
        <div class="eq" data-copy="n_eff = sqrt( eps_m / (eps_m + 1) )   (air: eps_d=1)">
n_eff = √( ε_m / (ε_m + 1) )   (air: ε_d = 1)</div>
      </div>

      <h3>Step 3 — Plug in the given silver permittivity</h3>
      <p>
        Given ε<sub>m</sub>=−20 + j1.3, compute the ratio:
      </p>
      <div class="eqbox">
        <div class="eq" data-copy="R = eps_m / (eps_m + 1)  where eps_m = -20 + j*1.3">
R = ε_m / (ε_m + 1)  with  ε_m = −20 + j1.3</div>
      </div>
      <p>
        Numerically:
      </p>
      <div class="eqbox">
        <div class="eq" id="calcRText">
R ≈ 1.052386 + j0.003584</div>
      </div>
      <p class="muted small">
        Notice R is slightly above 1 with a tiny imaginary part, so √R will be slightly above 1 — consistent with “SPP momentum &gt; photon momentum in air.”
      </p>

      <h3>Step 4 — Take the square root to get n<sub>eff</sub></h3>
      <div class="eqbox">
        <div class="eq" id="calcNeffText">
n_eff = √R ≈ 1.025860 + j0.001747</div>
      </div>
      <p>
        So the phase (momentum) part is Re{n<sub>eff</sub>} ≈ 1.02586.
      </p>

      <h3>Step 5 — Phase matching with the prism</h3>
      <p>
        The incident plane wave inside the prism has in-plane wavevector component:
      </p>
      <div class="eqbox">
        <div class="eq" data-copy="k_x = n_p * k0 * sin(theta_p)">
k_x = n_p k0 sin(θ_p)</div>
      </div>
      <p>
        Phase matching requires k<sub>x</sub> = Re{β<sub>SPP</sub>} = k<sub>0</sub>Re{n<sub>eff</sub>}. Cancel k<sub>0</sub>:
      </p>
      <div class="eqbox">
        <div class="eq" data-copy="sin(theta_p) = Re{n_eff} / n_p">
sin(θ_p) = Re{n_eff} / n_p</div>
      </div>

      <h3>Step 6 — Compute θ<sub>p</sub></h3>
      <p>
        With n<sub>p</sub>=2.0:
      </p>
      <div class="eqbox">
        <div class="eq" id="calcAngleText">
sin(θ_p) = 1.025860 / 2.0 = 0.512930  ⇒  θ_p ≈ 30.86°</div>
      </div>

      <div class="answer">
        <div class="pill"><b>Final Answer</b> (angle inside the prism)</div>
        <div class="big" id="finalAnswerText">θ_p ≈ 30.9°  (inside the SiN prism, measured from the normal)</div>
        <div class="btnrow">
          <button class="copy" data-copy-target="#finalAnswerText">Copy final answer</button>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <div class="grid two">
        <div class="callout">
          <div class="pill"><b>Units / dimensions</b></div>
          <p class="small">
            n<sub>eff</sub> and n<sub>p</sub> are dimensionless, so Re{n<sub>eff</sub>}/n<sub>p</sub> is dimensionless as required for sin(θ).
            β has units of rad·m⁻¹ because it is k<sub>0</sub> times a dimensionless factor.
          </p>
        </div>
        <div class="callout">
          <div class="pill"><b>Limiting cases</b></div>
          <ul class="small">
            <li>If n<sub>p</sub> → ∞, then θ<sub>p</sub> → 0 for a fixed SPP momentum: a huge index supplies momentum even at small angles.</li>
            <li>If ε<sub>m</sub> → −∞ (lossless, very negative), n<sub>eff</sub> → 1, so θ<sub>p</sub> → arcsin(1/n<sub>p</sub>) (approaches critical angle).</li>
          </ul>
        </div>
      </div>
      <p class="muted small">
        Extra check: the prism–air critical angle is θ<sub>c</sub>=arcsin(1/n<sub>p</sub>)=arcsin(0.5)=30°.
        Our result 30.86° is slightly above that, consistent with evanescent coupling conditions in prism setups.
      </p>

      <h3>Connect result to the geometry (diagram + plots)</h3>
      <p>
        The prism sets the tangential momentum through k<sub>x</sub>=n<sub>p</sub>k<sub>0</sub>sinθ<sub>p</sub>.
        The SPP demands k<sub>x</sub>/k<sub>0</sub>=Re{n<sub>eff</sub>}≈1.026. The intersection occurs near θ<sub>p</sub>≈30.9°,
        which is exactly what you’ll see in the main plot: the rising curve n<sub>p</sub>sinθ crosses the horizontal SPP line at the resonance angle.
      </p>

      <div class="btnrow">
        <button class="copy" data-copy="beta_SPP = k0 * sqrt( (eps_m * eps_d) / (eps_m + eps_d) )
n_eff = sqrt( (eps_m * eps_d) / (eps_m + eps_d) )
phase match: n_p * sin(theta_p) = Re{n_eff}
=> theta_p = asin(Re{n_eff}/n_p)">Copy key equations</button>
      </div>
    </section>

    <section id="part4" class="fadeIn">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the final formula</h3>
      <div class="eqbox">
        <div class="eq" data-copy="theta_p = asin( Re{ sqrt( eps_m eps_d / (eps_m + eps_d) ) } / n_p )">
θ_p = asin( Re{ √( ε_m ε_d / (ε_m + ε_d) ) } / n_p )</div>
      </div>
      <ul>
        <li><b>ε<sub>m</sub> controls the SPP momentum:</b> More negative ε′ generally pushes the mode closer to a photon in the dielectric (n<sub>eff</sub>→1).</li>
        <li><b>ε″ controls losses:</b> It mainly affects Im{n<sub>eff</sub>} → propagation length and the width/depth of the reflectance dip, not the resonance angle strongly (unless losses are very large).</li>
        <li><b>n<sub>p</sub> controls how “easy” it is to match:</b> Larger n<sub>p</sub> lowers θ<sub>p</sub> for the same required in-plane momentum.</li>
      </ul>

      <h3>Parameter dependence (connect to interactive plots)</h3>
      <ul>
        <li>Increasing <b>n<sub>p</sub></b> shifts the intersection to <b>smaller θ</b> (because the curve n<sub>p</sub>sinθ rises faster).</li>
        <li>Making ε′<sub>m</sub> <b>less negative</b> (e.g., −10 instead of −20) tends to increase Re{n<sub>eff</sub>} and therefore requires <b>larger θ</b>.</li>
        <li>Increasing ε″<sub>m</sub> increases Im{n<sub>eff</sub>} → broader, shallower “resonance dip” in a reflectance-style plot (modeled qualitatively here).</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        Instead of using the closed-form SPP dispersion directly, you could:
        (i) apply Maxwell boundary conditions for TM fields at z=0, (ii) enforce evanescent decay into both media,
        and (iii) solve the resulting characteristic equation for β. This yields the same β = k<sub>0</sub>√(ε<sub>m</sub>ε<sub>d</sub>/(ε<sub>m</sub>+ε<sub>d</sub>)).
      </p>

      <h3>Concept checks (self-test)</h3>
      <ul>
        <li><b>Q:</b> Why can’t a plane wave from air directly excite the Ag–air SPP?<br><b>A:</b> Its maximum in-plane momentum is k<sub>0</sub> (since k<sub>x</sub>=k<sub>0</sub>sinθ ≤ k<sub>0</sub>), but the SPP requires k<sub>x</sub>=Re{β}&gt;k<sub>0</sub>.</li>
        <li><b>Q:</b> Why do we match to Re{β} and not |β|?<br><b>A:</b> Re{β} sets the phase-matching (spatial oscillation along the surface). Im{β} sets attenuation, affecting coupling strength/linewidth.</li>
        <li><b>Q:</b> What does it mean if Re{n<sub>eff</sub>}/n<sub>p</sub> &gt; 1?<br><b>A:</b> No real angle exists; the prism index is too small to provide enough in-plane momentum.</li>
        <li><b>Q:</b> Why is the solution near the critical angle here?<br><b>A:</b> Because Re{n<sub>eff</sub>}≈1 and n<sub>p</sub>=2, so sinθ≈0.5 → θ≈30°, i.e., close to θ<sub>c</sub>=arcsin(1/n<sub>p</sub>).</li>
      </ul>
    </section>

    <section id="part5" class="fadeIn">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="canvasCard">
        <div class="canvasTitle">
          <h3>Diagram — Prism → Ag film → Air SPP (geometry + wavevectors)</h3>
          <div class="meta">Shows θ<sub>p</sub>, k<sub>x</sub>, and the SPP direction along the interface</div>
        </div>
        <canvas id="cDiagram" aria-label="Prism coupling diagram"></canvas>
        <div class="controls" aria-label="Interactive controls">
          <label>
            Prism index n<sub>p</sub>
            <input id="sNp" type="range" min="1.30" max="2.50" step="0.01" value="2.00"/>
            <div class="val" id="vNp"></div>
          </label>
          <label>
            Silver ε′<sub>m</sub> (real part)
            <input id="sEpsRe" type="range" min="-40" max="-5" step="0.1" value="-20"/>
            <div class="val" id="vEpsRe"></div>
          </label>
          <label>
            Silver ε″<sub>m</sub> (imag part)
            <input id="sEpsIm" type="range" min="0.0" max="5.0" step="0.05" value="1.30"/>
            <div class="val" id="vEpsIm"></div>
          </label>
        </div>
        <p class="muted small" style="margin-top:0.6rem">
          Move the sliders to see how the SPP effective index and resonance angle shift.
          The calculations in the article correspond to n<sub>p</sub>=2.0, ε<sub>m</sub>=−20+j1.3.
        </p>
      </div>

      <div class="grid two">
        <div class="canvasCard">
          <div class="canvasTitle">
            <h3>Main plot — Phase matching: k<sub>x</sub>/k<sub>0</sub> vs θ<sub>p</sub></h3>
            <div class="meta">Intersection gives θ<sub>p</sub></div>
          </div>
          <canvas id="cMain" aria-label="Main phase matching plot"></canvas>
        </div>

        <div class="canvasCard">
          <div class="canvasTitle">
            <h3>Secondary plot — Toy reflectance dip vs θ<sub>p</sub></h3>
            <div class="meta">Qualitative resonance behavior</div>
          </div>
          <canvas id="cSecond" aria-label="Secondary reflectance plot"></canvas>
        </div>
      </div>

      <div class="callout" style="margin-top:0.9rem">
        <div class="pill"><b>How to read</b></div>
        <ul class="small">
          <li><b>Diagram:</b> The incident prism wave hits the prism–metal boundary at angle θ<sub>p</sub>. Its tangential component is k<sub>x</sub>.</li>
          <li><b>Main plot:</b> The curve <span style="color:var(--accent)"><b>n<sub>p</sub>sinθ</b></span> rises with θ. The horizontal line <span style="color:var(--accent2)"><b>Re{n<sub>eff</sub>}</b></span> is the SPP requirement. Their intersection is the coupling angle.</li>
          <li><b>Secondary plot:</b> A simplified “reflectance” shows a dip centered at θ<sub>res</sub>. Increasing ε″ broadens the dip (more loss → lower Q).</li>
          <li><b>Interactive controls:</b> Changing n<sub>p</sub>, ε′, ε″ updates: (i) the diagram labels, (ii) the intersection angle marker, and (iii) both plots live.</li>
        </ul>
      </div>
    </section>
  </article>
</main>

<footer class="fadeIn">
  <p>
    Built as a self-contained learning page (no external libraries). Copy buttons use the Clipboard API where available.
  </p>
</footer>

<script>
/* ---------- Utilities ---------- */
function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function fmt(x, d=4){ return Number(x).toFixed(d); }
function rad(deg){ return deg*Math.PI/180; }
function deg(rad){ return rad*180/Math.PI; }

/* Complex helpers (minimal) */
function c(re, im){ return {re, im}; }
function cAdd(a,b){ return c(a.re+b.re, a.im+b.im); }
function cSub(a,b){ return c(a.re-b.re, a.im-b.im); }
function cMul(a,b){ return c(a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re); }
function cDiv(a,b){
  const den = b.re*b.re + b.im*b.im;
  return c((a.re*b.re + a.im*b.im)/den, (a.im*b.re - a.re*b.im)/den);
}
function cAbs(a){ return Math.hypot(a.re, a.im); }
function cSqrt(z){
  // principal square root
  const r = cAbs(z);
  const t = Math.atan2(z.im, z.re);
  const sr = Math.sqrt(r);
  return c(sr*Math.cos(t/2), sr*Math.sin(t/2));
}

/* ---------- Model (physics) ---------- */
function computeModel(params){
  // params: np, epsRe, epsIm
  const epsm = c(params.epsRe, params.epsIm);
  const epsd = c(1, 0); // air
  // n_eff = sqrt( epsm*epsd / (epsm + epsd) ) = sqrt( epsm / (epsm+1) )
  const denom = cAdd(epsm, epsd);
  const ratio = cDiv(cMul(epsm, epsd), denom);
  const neff = cSqrt(ratio);

  const sinTheta = neff.re / params.np;
  const feasible = (sinTheta <= 1 && sinTheta >= 0);
  const theta = feasible ? Math.asin(clamp(sinTheta,0,1)) : NaN;

  // A toy "reflectance dip" model (qualitative): 1 - A/(1 + ((θ-θres)/γ)^2)
  // Dip width increases with loss (epsIm). Keep it stable for display.
  const gammaDeg = clamp(0.35 + 0.25*params.epsIm, 0.25, 2.5); // degrees
  const depth = clamp(0.55 - 0.06*params.epsIm, 0.15, 0.60);

  return {
    epsm, ratio, neff,
    sinTheta, feasible,
    thetaRad: theta,
    thetaDeg: feasible ? deg(theta) : NaN,
    gammaDeg, depth
  };
}

/* ---------- Canvas plotting primitives ---------- */
function setupCanvas(canvas){
  const ctx = canvas.getContext('2d');
  function resize(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(2, Math.floor(rect.width * dpr));
    canvas.height = Math.max(2, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return {w: rect.width, h: rect.height, dpr};
  }
  return {ctx, resize};
}

function drawAxes(ctx, box, opts){
  const {x0,y0,w,h} = box;
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1;

  // border
  ctx.strokeRect(x0,y0,w,h);

  // grid & ticks
  const xTicks = opts.xTicks || 6;
  const yTicks = opts.yTicks || 6;

  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillStyle = 'rgba(255,255,255,0.75)';

  // gridlines
  ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  for(let i=1;i<xTicks;i++){
    const x = x0 + (i/xTicks)*w;
    ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+h); ctx.stroke();
  }
  for(let j=1;j<yTicks;j++){
    const y = y0 + (j/yTicks)*h;
    ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+w,y); ctx.stroke();
  }

  // axis labels
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  ctx.fillText(opts.title || '', x0, y0-10);
  ctx.fillStyle = 'rgba(255,255,255,0.72)';
  ctx.fillText(opts.xLabel || '', x0 + w - ctx.measureText(opts.xLabel||'').width, y0 + h + 28);

  // y-label (rotated)
  ctx.save();
  ctx.translate(x0 - 34, y0 + h/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(opts.yLabel || '', -ctx.measureText(opts.yLabel||'').width/2, 0);
  ctx.restore();

  // numeric ticks (simple)
  ctx.fillStyle = 'rgba(255,255,255,0.62)';
  const xmin = opts.xMin, xmax = opts.xMax, ymin = opts.yMin, ymax = opts.yMax;

  for(let i=0;i<=xTicks;i++){
    const t=i/xTicks;
    const x = x0 + t*w;
    const val = lerp(xmin,xmax,t);
    const s = (opts.xFmt ? opts.xFmt(val) : val.toFixed(0));
    ctx.fillText(s, x - ctx.measureText(s).width/2, y0+h+16);
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.beginPath(); ctx.moveTo(x,y0+h); ctx.lineTo(x,y0+h+5); ctx.stroke();
  }
  for(let j=0;j<=yTicks;j++){
    const t=j/yTicks;
    const y = y0 + (1-t)*h;
    const val = lerp(ymin,ymax,t);
    const s = (opts.yFmt ? opts.yFmt(val) : val.toFixed(2));
    ctx.fillText(s, x0 - 6 - ctx.measureText(s).width, y+4);
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.beginPath(); ctx.moveTo(x0-5,y); ctx.lineTo(x0,y); ctx.stroke();
  }

  ctx.restore();
}

function mapToBox(x,y, opts, box){
  const {xMin,xMax,yMin,yMax} = opts;
  const {x0,y0,w,h} = box;
  const X = x0 + (x - xMin)/(xMax-xMin)*w;
  const Y = y0 + (1 - (y - yMin)/(yMax-yMin))*h;
  return {X,Y};
}

/* ---------- Draw: Diagram ---------- */
function drawDiagram(ctx, W, H, model, params){
  ctx.clearRect(0,0,W,H);

  // background subtle vignette
  const grad = ctx.createRadialGradient(W*0.2,H*0.2,10, W*0.2,H*0.2, Math.max(W,H)*0.9);
  grad.addColorStop(0,'rgba(125,211,252,0.10)');
  grad.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,W,H);

  // geometry
  const pad = 18;
  const prismTop = pad+18;
  const metalTop = H*0.52;
  const metalTh = 18;
  const airTop = metalTop + metalTh;

  // prism wedge (simple trapezoid)
  ctx.save();
  ctx.fillStyle = 'rgba(125,211,252,0.12)';
  ctx.strokeStyle = 'rgba(125,211,252,0.35)';
  ctx.lineWidth = 1.2;

  const px0 = pad, py0 = prismTop;
  const px1 = W-pad, py1 = prismTop+18;
  const px2 = W-pad-70, py2 = metalTop;
  const px3 = pad+70, py3 = metalTop;

  ctx.beginPath();
  ctx.moveTo(px0,py0);
  ctx.lineTo(px1,py1);
  ctx.lineTo(px2,py2);
  ctx.lineTo(px3,py3);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // metal layer
  ctx.fillStyle = 'rgba(167,139,250,0.14)';
  ctx.strokeStyle = 'rgba(167,139,250,0.35)';
  ctx.beginPath();
  ctx.rect(pad+40, metalTop, W-2*(pad+40), metalTh);
  ctx.fill();
  ctx.stroke();

  // air region
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  ctx.beginPath();
  ctx.rect(pad+40, airTop, W-2*(pad+40), H-airTop-pad);
  ctx.fill();
  ctx.stroke();
  ctx.restore();

  // labels
  ctx.save();
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillStyle = 'rgba(255,255,255,0.80)';
  ctx.fillText(`Prism (SiN): n_p = ${params.np.toFixed(2)}`, pad+12, prismTop+22);
  ctx.fillText(`Ag film (60 nm)`, pad+52, metalTop+13);
  ctx.fillText(`Air: ε_d ≈ 1`, pad+52, airTop+20);

  // incident ray
  const originX = W*0.65;
  const originY = prismTop + 32;
  const theta = isFinite(model.thetaRad) ? model.thetaRad : rad(35); // fallback
  const normalX = W*0.50, normalY = metalTop; // point on interface
  const L = 150;

  // We draw ray hitting near center
  const hitX = W*0.52;
  const hitY = metalTop;
  const dirX = -Math.sin(theta);
  const dirY = Math.cos(theta);
  const rayX0 = hitX - dirX*L;
  const rayY0 = hitY - dirY*L;

  ctx.strokeStyle = 'rgba(125,211,252,0.85)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(rayX0, rayY0);
  ctx.lineTo(hitX, hitY);
  ctx.stroke();

  // reflected ray (for context)
  ctx.strokeStyle = 'rgba(125,211,252,0.45)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(hitX, hitY);
  ctx.lineTo(hitX + dirX*L*0.65, hitY - dirY*L*0.65);
  ctx.stroke();

  // normal
  ctx.strokeStyle = 'rgba(255,255,255,0.45)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(hitX, hitY);
  ctx.lineTo(hitX, hitY-90);
  ctx.stroke();

  // angle arc
  ctx.strokeStyle = 'rgba(255,255,255,0.65)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  const r = 38;
  // angle between ray and normal is theta (inside prism)
  const a0 = -Math.PI/2;         // along normal upwards
  const a1 = a0 + theta;         // rotate clockwise by theta
  ctx.arc(hitX, hitY, r, a0, a1);
  ctx.stroke();

  ctx.fillStyle = 'rgba(255,255,255,0.86)';
  ctx.fillText(`θ_p`, hitX + 8, hitY - 30);

  // SPP arrow along interface (air side)
  ctx.strokeStyle = 'rgba(167,139,250,0.9)';
  ctx.lineWidth = 2.2;
  const sppY = airTop + 24;
  ctx.beginPath();
  ctx.moveTo(pad+90, sppY);
  ctx.lineTo(W-pad-90, sppY);
  ctx.stroke();
  // arrow head
  ctx.beginPath();
  ctx.moveTo(W-pad-90, sppY);
  ctx.lineTo(W-pad-102, sppY-6);
  ctx.lineTo(W-pad-102, sppY+6);
  ctx.closePath();
  ctx.fillStyle = 'rgba(167,139,250,0.9)';
  ctx.fill();

  ctx.fillStyle = 'rgba(255,255,255,0.82)';
  ctx.fillText(`SPP at Ag–air: β (along x)`, pad+92, sppY-10);

  // kx label
  ctx.fillStyle = 'rgba(125,211,252,0.92)';
  ctx.fillText(`k_x = n_p k0 sin(θ_p)`, pad+12, H-pad-10);

  // neff summary
  ctx.fillStyle = 'rgba(255,255,255,0.78)';
  const ne = model.neff;
  ctx.fillText(`n_eff ≈ ${ne.re.toFixed(6)} + j${ne.im.toFixed(6)}`, pad+12, H-pad-28);

  // feasibility
  if(!model.feasible){
    ctx.fillStyle = 'rgba(251,113,133,0.95)';
    ctx.fillText(`No real θ_p: Re{n_eff}/n_p > 1 (insufficient prism momentum)`, pad+12, H-pad-46);
  }else{
    ctx.fillStyle = 'rgba(52,211,153,0.90)';
    ctx.fillText(`Phase match at θ_p ≈ ${model.thetaDeg.toFixed(2)}°`, pad+12, H-pad-46);
  }

  ctx.restore();
}

/* ---------- Draw: Main plot (phase matching) ---------- */
function drawMainPlot(ctx, W, H, model, params){
  ctx.clearRect(0,0,W,H);

  const margin = {l:58, r:18, t:34, b:44};
  const box = {x0: margin.l, y0: margin.t, w: W-margin.l-margin.r, h: H-margin.t-margin.b};

  const xMin=0, xMax=80;               // θ range (deg)
  const yMin=0, yMax=Math.max(2.6, params.np*1.05); // kx/k0 range

  drawAxes(ctx, box, {
    title: 'Phase matching (dimensionless): kx/k0 vs θp',
    xLabel: 'θp (degrees, inside prism)',
    yLabel: 'kx / k0',
    xMin, xMax, yMin, yMax,
    xTicks: 8,
    yTicks: 6,
    xFmt: v => v.toFixed(0),
    yFmt: v => v.toFixed(2)
  });

  function plotCurve(fn, color){
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    const N=300;
    for(let i=0;i<=N;i++){
      const th = lerp(xMin,xMax,i/N);
      const y = fn(th);
      const p = mapToBox(th,y,{xMin,xMax,yMin,yMax}, box);
      if(i===0) ctx.moveTo(p.X,p.Y); else ctx.lineTo(p.X,p.Y);
    }
    ctx.stroke();
    ctx.restore();
  }

  // Curve: n_p sinθ
  plotCurve(th => params.np * Math.sin(rad(th)), 'rgba(125,211,252,0.92)');

  // Horizontal line: Re{n_eff}
  const yLine = model.neff.re;
  ctx.save();
  ctx.strokeStyle = 'rgba(167,139,250,0.92)';
  ctx.lineWidth = 2;
  ctx.setLineDash([6,6]);
  let p1 = mapToBox(xMin,yLine,{xMin,xMax,yMin,yMax}, box);
  let p2 = mapToBox(xMax,yLine,{xMin,xMax,yMin,yMax}, box);
  ctx.beginPath(); ctx.moveTo(p1.X,p1.Y); ctx.lineTo(p2.X,p2.Y); ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();

  // Marker at intersection
  if(model.feasible){
    const th = model.thetaDeg;
    const y = params.np * Math.sin(rad(th));
    const p = mapToBox(th,y,{xMin,xMax,yMin,yMax}, box);

    ctx.save();
    ctx.fillStyle = 'rgba(52,211,153,0.95)';
    ctx.beginPath();
    ctx.arc(p.X,p.Y,5,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.stroke();
    ctx.restore();

    // annotation
    ctx.save();
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillStyle = 'rgba(255,255,255,0.86)';
    const label = `θres ≈ ${th.toFixed(2)}°`;
    ctx.fillText(label, p.X+8, p.Y-8);
    ctx.restore();
  }

  // Legend
  ctx.save();
  ctx.font = '12px ui-sans-serif, system-ui';
  const lx = box.x0 + 10, ly = box.y0 + 10;
  ctx.fillStyle = 'rgba(255,255,255,0.82)';
  ctx.fillText('Legend:', lx, ly);
  ctx.fillStyle = 'rgba(125,211,252,0.92)';
  ctx.fillText('—  n_p sin(θp)  (available prism kx/k0)', lx, ly+16);
  ctx.fillStyle = 'rgba(167,139,250,0.92)';
  ctx.fillText('—  Re{n_eff}  (SPP requirement)', lx, ly+32);
  ctx.restore();
}

/* ---------- Draw: Secondary plot (toy reflectance dip) ---------- */
function drawSecondaryPlot(ctx, W, H, model, params){
  ctx.clearRect(0,0,W,H);

  const margin = {l:58, r:18, t:34, b:44};
  const box = {x0: margin.l, y0: margin.t, w: W-margin.l-margin.r, h: H-margin.t-margin.b};

  const xMin=0, xMax=80;
  const yMin=0, yMax=1.05;

  drawAxes(ctx, box, {
    title: 'Qualitative reflectance vs θp (resonance dip at phase match)',
    xLabel: 'θp (degrees, inside prism)',
    yLabel: 'Reflectance (a.u.)',
    xMin, xMax, yMin, yMax,
    xTicks: 8,
    yTicks: 5,
    xFmt: v => v.toFixed(0),
    yFmt: v => v.toFixed(2)
  });

  // toy reflectance function
  const th0 = model.feasible ? model.thetaDeg : 45;
  const gamma = model.gammaDeg;
  const A = model.depth;

  function R(th){
    const u = (th - th0)/gamma;
    const dip = A/(1 + u*u);
    return clamp(1 - dip, 0, 1);
  }

  // plot reflectance
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.88)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  const N=400;
  for(let i=0;i<=N;i++){
    const th = lerp(xMin,xMax,i/N);
    const y = R(th);
    const p = mapToBox(th,y,{xMin,xMax,yMin,yMax}, box);
    if(i===0) ctx.moveTo(p.X,p.Y); else ctx.lineTo(p.X,p.Y);
  }
  ctx.stroke();
  ctx.restore();

  // vertical line at resonance
  if(model.feasible){
    ctx.save();
    ctx.strokeStyle = 'rgba(52,211,153,0.85)';
    ctx.lineWidth = 1.8;
    ctx.setLineDash([5,6]);
    const p1 = mapToBox(th0,yMin,{xMin,xMax,yMin,yMax}, box);
    const p2 = mapToBox(th0,yMax,{xMin,xMax,yMin,yMax}, box);
    ctx.beginPath(); ctx.moveTo(p1.X,p1.Y); ctx.lineTo(p2.X,p2.Y); ctx.stroke();
    ctx.setLineDash([]);

    // annotate
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillStyle = 'rgba(255,255,255,0.86)';
    ctx.fillText(`θres ≈ ${th0.toFixed(2)}°`, p2.X+8, p2.Y+14);
    ctx.fillStyle = 'rgba(255,255,255,0.72)';
    ctx.fillText(`(dip width ~ ${gamma.toFixed(2)}°; qualitative)`, box.x0+10, box.y0+box.h-10);
    ctx.restore();
  }else{
    ctx.save();
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillStyle = 'rgba(251,113,133,0.92)';
    ctx.fillText('No real phase-match angle for current parameters.', box.x0+10, box.y0+box.h-10);
    ctx.restore();
  }
}

/* ---------- Copy buttons ---------- */
function installCopy(){
  function copyText(txt){
    if(navigator.clipboard && window.isSecureContext){
      return navigator.clipboard.writeText(txt);
    }
    // fallback
    const ta = document.createElement('textarea');
    ta.value = txt;
    ta.style.position = 'fixed';
    ta.style.left = '-9999px';
    document.body.appendChild(ta);
    ta.select();
    try{ document.execCommand('copy'); }catch(e){}
    document.body.removeChild(ta);
    return Promise.resolve();
  }

  document.querySelectorAll('button.copy').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const explicit = btn.getAttribute('data-copy');
      const targetSel = btn.getAttribute('data-copy-target');
      let txt = '';
      if(explicit){
        txt = explicit;
      }else if(targetSel){
        const el = document.querySelector(targetSel);
        txt = el ? el.textContent.trim() : '';
      }else{
        // attempt: sibling eq element
        const near = btn.closest('section')?.querySelector('.eq[data-copy]');
        txt = near ? near.getAttribute('data-copy') : '';
      }
      if(!txt) return;
      await copyText(txt);
      const old = btn.textContent;
      btn.textContent = 'Copied ✓';
      setTimeout(()=>btn.textContent = old, 900);
    });
  });

  // make equation blocks clickable via attribute
  document.querySelectorAll('.eq[data-copy]').forEach(eq=>{
    eq.style.cursor = 'copy';
    eq.title = 'Click to copy';
    eq.addEventListener('click', async ()=>{
      const txt = eq.getAttribute('data-copy') || eq.textContent.trim();
      if(!txt) return;
      await copyText(txt);
      eq.style.outline = '2px solid rgba(52,211,153,0.45)';
      setTimeout(()=>eq.style.outline = 'none', 650);
    });
  });
}

/* ---------- Wire everything ---------- */
const cD = setupCanvas(document.getElementById('cDiagram'));
const cM = setupCanvas(document.getElementById('cMain'));
const cS = setupCanvas(document.getElementById('cSecond'));

const sNp = document.getElementById('sNp');
const sEpsRe = document.getElementById('sEpsRe');
const sEpsIm = document.getElementById('sEpsIm');
const vNp = document.getElementById('vNp');
const vEpsRe = document.getElementById('vEpsRe');
const vEpsIm = document.getElementById('vEpsIm');

const calcRText = document.getElementById('calcRText');
const calcNeffText = document.getElementById('calcNeffText');
const calcAngleText = document.getElementById('calcAngleText');
const finalAnswerText = document.getElementById('finalAnswerText');

function update(){
  const params = {
    np: parseFloat(sNp.value),
    epsRe: parseFloat(sEpsRe.value),
    epsIm: parseFloat(sEpsIm.value)
  };
  const model = computeModel(params);

  // UI values
  vNp.textContent = `n_p = ${params.np.toFixed(2)}`;
  vEpsRe.textContent = `ε′_m = ${params.epsRe.toFixed(1)}`;
  vEpsIm.textContent = `ε″_m = ${params.epsIm.toFixed(2)}`;

  // Update numeric text in solution boxes (reflects current sliders)
  const R = model.ratio;
  calcRText.textContent = `R = ε_m/(ε_m+1) ≈ ${R.re.toFixed(6)} + j${R.im.toFixed(6)}`;
  const ne = model.neff;
  calcNeffText.textContent = `n_eff = √R ≈ ${ne.re.toFixed(6)} + j${ne.im.toFixed(6)}`;

  if(model.feasible){
    const s = model.sinTheta;
    calcAngleText.textContent = `sin(θ_p) = Re{n_eff}/n_p = ${ne.re.toFixed(6)} / ${params.np.toFixed(2)} = ${s.toFixed(6)}  ⇒  θ_p ≈ ${model.thetaDeg.toFixed(2)}°`;
    finalAnswerText.textContent = `θ_p ≈ ${model.thetaDeg.toFixed(1)}°  (inside the prism, measured from the normal)`;
  }else{
    calcAngleText.textContent = `No real θ_p: Re{n_eff}/n_p = ${model.sinTheta.toFixed(4)} > 1  ⇒  phase matching impossible for this prism index.`;
    finalAnswerText.textContent = `No real coupling angle for current parameters (increase n_p or reduce Re{n_eff}).`;
  }

  // Draw canvases
  const rd = cD.resize(); drawDiagram(cD.ctx, rd.w, rd.h, model, params);
  const rm = cM.resize(); drawMainPlot(cM.ctx, rm.w, rm.h, model, params);
  const rs = cS.resize(); drawSecondaryPlot(cS.ctx, rs.w, rs.h, model, params);
}

[sNp, sEpsRe, sEpsIm].forEach(el => el.addEventListener('input', update));
window.addEventListener('resize', update);

installCopy();
update();
</script>
</body>
</html>
