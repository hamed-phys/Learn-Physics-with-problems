<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>8.1-2 — NIM Slab as a Near-Field Imaging System (n = −2)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --card2:#0f1730;
      --text:#eaf0ff;
      --muted:#b9c4e6;
      --line:rgba(255,255,255,.12);
      --accent:#7aa2ff;
      --accent2:#7dffcc;
      --warn:#ffd479;
      --bad:#ff7a9e;
      --good:#7dffcc;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1000px 700px at 15% 10%, rgba(122,162,255,.22), transparent 55%),
        radial-gradient(900px 600px at 90% 20%, rgba(125,255,204,.14), transparent 60%),
        linear-gradient(180deg, #070a14 0%, var(--bg) 55%, #070a14 100%);
      line-height:1.6;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding: 42px 18px 18px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .title{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
      padding: 24px;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .title:before{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(600px 250px at 20% 0%, rgba(122,162,255,.18), transparent 55%),
        radial-gradient(600px 250px at 80% 0%, rgba(125,255,204,.12), transparent 55%);
      filter: blur(0px);
      pointer-events:none;
    }
    h1{
      margin:0;
      font-size: clamp(1.35rem, 2.4vw, 2.05rem);
      letter-spacing:.2px;
      position:relative;
    }
    .subtitle{
      margin:0;
      color: var(--muted);
      font-size: 0.98rem;
      position:relative;
      max-width: 75ch;
    }

    main{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 18px 60px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 18px;
    }

    .layout{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 18px;
      align-items:start;
    }

    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border-radius: var(--radius);
      padding: 14px 14px 10px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .toc h2{
      margin: 0 0 10px;
      font-size: 1rem;
      letter-spacing:.3px;
    }
    .toc a{
      display:block;
      padding: 8px 10px;
      margin: 6px 0;
      border-radius: 12px;
      color: var(--text);
      border:1px solid transparent;
      background: rgba(255,255,255,.02);
    }
    .toc a:hover{
      border-color: rgba(122,162,255,.35);
      background: rgba(122,162,255,.10);
      text-decoration:none;
    }
    .content{
      display:grid;
      gap: 18px;
    }

    section, article{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow);
    }
    section h2{
      margin: 0 0 10px;
      font-size: 1.25rem;
    }
    section h3{
      margin: 14px 0 8px;
      font-size: 1.05rem;
      color: #f2f6ff;
    }
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns: 1fr}
      nav.toc{position:relative; top:auto}
    }
    @media (max-width: 820px){
      .grid2,.grid3{grid-template-columns:1fr}
    }

    .callout{
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(15,23,48,.9), rgba(15,23,48,.55));
      padding: 14px;
      border-radius: 16px;
      position:relative;
      overflow:hidden;
    }
    .callout:before{
      content:"";
      position:absolute;
      inset:-1px;
      background: radial-gradient(500px 200px at 10% 0%, rgba(122,162,255,.18), transparent 55%);
      pointer-events:none;
    }
    .callout > *{position:relative}
    .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 4px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.04);
      font-size: .84rem;
      color: var(--muted);
      margin-bottom: 10px;
    }
    .tag .dot{
      width:9px; height:9px; border-radius: 99px; background: var(--accent);
      box-shadow: 0 0 0 3px rgba(122,162,255,.18);
    }
    .warn .dot{background:var(--warn); box-shadow:0 0 0 3px rgba(255,212,121,.18)}
    .good .dot{background:var(--good); box-shadow:0 0 0 3px rgba(125,255,204,.16)}
    .bad .dot{background:var(--bad); box-shadow:0 0 0 3px rgba(255,122,158,.16)}
    ul{margin: 8px 0 0 18px}
    li{margin: 6px 0}
    .eq{
      border:1px solid rgba(122,162,255,.28);
      background: rgba(122,162,255,.08);
      border-radius: 14px;
      padding: 12px;
      margin: 10px 0;
      overflow:auto;
      position:relative;
    }
    .eq pre{
      margin:0;
      white-space: pre-wrap;
      font-family: var(--mono);
      font-size: .95rem;
      line-height: 1.45;
      color:#f4f7ff;
    }
    .copyRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      margin-top:10px;
    }
    button.copyBtn{
      cursor:pointer;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 12px;
      padding: 9px 11px;
      font-size: .9rem;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
    }
    button.copyBtn:hover{
      background: rgba(122,162,255,.14);
      border-color: rgba(122,162,255,.35);
    }
    button.copyBtn:active{transform: translateY(1px)}
    .small{font-size:.92rem}
    .hr{
      height:1px;
      background: var(--line);
      margin: 14px 0;
    }

    figure{
      margin:0;
      display:grid;
      gap: 10px;
    }
    .canvasCard{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      border-radius: 16px;
      padding: 12px;
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
      border-radius: 12px;
      background: rgba(5,8,15,.55);
      border:1px solid rgba(255,255,255,.10);
    }
    .canvasGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }
    @media (min-width: 900px){
      .canvasGrid{grid-template-columns: 1.1fr .9fr}
      canvas.big{height: 360px}
      canvas.small{height: 360px}
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    @media (max-width: 900px){
      .controls{grid-template-columns:1fr}
    }
    .control{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      border-radius: 14px;
      padding: 10px 12px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size: .92rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    input[type="range"]{width:100%}
    select{
      width:100%;
      border-radius: 12px;
      padding: 10px 10px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(10,14,28,.65);
      color: var(--text);
      outline:none;
    }
    .pill{
      font-family: var(--mono);
      font-size: .9rem;
      color:#f7f9ff;
      padding: 2px 8px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      white-space:nowrap;
    }

    footer{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 18px 36px;
      color: var(--muted);
      font-size: .92rem;
    }

    /* subtle animation */
    .fadeIn{
      animation: fade .45s ease both;
    }
    @keyframes fade{
      from{opacity:.0; transform: translateY(6px)}
      to{opacity:1; transform: translateY(0)}
    }

    /* print */
    @media print{
      body{background:#fff; color:#000}
      header, main, footer{max-width: 100%; margin:0; padding: 0}
      nav.toc{display:none}
      section, article, .title{box-shadow:none; background:#fff; border-color:#ddd}
      a{color:#000; text-decoration:underline}
      canvas{border:1px solid #999; background:#fff}
      .eq{background:#f6f7ff; border-color:#bcc7ff}
      button.copyBtn{display:none}
    }
  </style>
</head>
<body>
<header class="fadeIn">
  <div class="title">
    <h1>8.1-2 — NIM Slab as a Near-Field Imaging System (n = −2 in air)</h1>
    <p class="subtitle">
      A guided, mini-lecture style solution: ray imaging (graph like Fig. 8.1-6(b)), the imaging equation, normal-incidence reflection/transmission,
      and an evanescent-wave amplitude profile (like Fig. 8.1-6(d)).
    </p>
  </div>
</header>

<main class="layout">
  <nav class="toc fadeIn" aria-label="Table of contents">
    <h2>Table of Contents</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
  </nav>

  <div class="content">
    <section id="quick" class="fadeIn">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>What this is about:</b> A <b>negative-index metamaterial (NIM)</b> slab (here <span class="pill">n = −2</span>) can form images by <b>negative refraction</b> at each interface.</li>
        <li><b>Key idea:</b> For paraxial rays, a plane interface obeys <span class="pill">n₁ θ₁ = n₂ θ₂</span>, so a negative <span class="pill">n₂</span> flips the ray angle sign and enables focusing.</li>
        <li><b>Imaging equation (paraxial, slab thickness d):</b> for air–NIM–air with <span class="pill">n₁=1</span>, <span class="pill">n₂=n</span>, the external image distance is
          <span class="pill">s′ = −s − d/n</span>. For <span class="pill">n = −2</span>: <span class="pill">s′ = d/2 − s</span> (unit magnification, upright).</li>
        <li><b>Normal-incidence Fresnel coefficients:</b> depend on wave impedance <span class="pill">η = √(μ/ε)</span>, not only on <span class="pill">n</span>. For an impedance-matched DNG design (common idealization) <span class="pill">η₂=η₁</span>, so <span class="pill">r = 0</span>, <span class="pill">t = 1</span> at each boundary (no reflection).</li>
        <li><b>Evanescent components:</b> have <span class="pill">kₓ &gt; k₀</span> and decay in free space as <span class="pill">e^{−α z}</span>, with <span class="pill">α = √(kₓ² − k₀²)</span>. In a DNG slab they can be <b>amplified</b> (growing exponential) so the near-field content is partially restored at the image plane.</li>
        <li><b>Plots included:</b> (1) labeled ray diagram, (2) main plot: <span class="pill">s′(s)</span> line, (3) secondary plot: semilog amplitude profile of an evanescent spatial-frequency component.</li>
      </ul>
    </section>

    <section id="part0" class="fadeIn">
      <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

      <div class="grid2">
        <div class="callout">
          <div class="tag good"><span class="dot"></span><span>Core definitions</span></div>
          <ul>
            <li><b>Refractive index</b> <span class="pill">n</span> (dimensionless): relates phase velocity and wave number:
              <span class="pill">k = n k₀</span>, <span class="pill">k₀ = 2π/λ₀</span>.</li>
            <li><b>Negative-index medium (NIM)</b>: engineered so the refractive index is negative (typically <b>double-negative</b>, DNG:
              <span class="pill">ε &lt; 0</span>, <span class="pill">μ &lt; 0</span> over a band).</li>
            <li><b>Wave impedance</b> <span class="pill">η</span> (ohms): <span class="pill">η = √(μ/ε)</span>.
              This controls reflection at boundaries.</li>
            <li><b>Spatial frequency / transverse wavenumber</b> <span class="pill">kₓ</span> (rad/m): decomposes a field into plane-wave components.
              For a component, <span class="pill">kₓ² + k_z² = (n k₀)²</span>.</li>
          </ul>
        </div>

        <div class="callout">
          <div class="tag"><span class="dot"></span><span>Physical meaning</span></div>
          <ul>
            <li><b>Negative refraction:</b> Snell’s law still holds, but if <span class="pill">n₂&lt;0</span> then the refracted angle has the opposite sign,
              bending to the “same side” of the normal as the incident ray.</li>
            <li><b>Why a slab can image:</b> the first interface can create a focus inside the slab; the second can create an image outside.
              With negative index, both interfaces have focusing power.</li>
            <li><b>Near-field imaging:</b> subwavelength detail resides in <b>evanescent</b> components (<span class="pill">kₓ&gt;k₀</span>) that normally decay.
              A DNG slab can enhance them, improving resolution beyond ordinary diffraction limits (in the idealized “perfect lens” limit).</li>
          </ul>
        </div>
      </div>

      <h3>Key laws / principles and validity</h3>
      <div class="grid2">
        <div class="callout">
          <div class="tag"><span class="dot"></span><span>Snell’s law (paraxial)</span></div>
          <p class="muted small">For a plane boundary, tangential wavevector is conserved. For small angles, <span class="pill">sinθ≈θ</span>.</p>
          <div class="eq" data-copy>
            <pre>n1 sinθ1 = n2 sinθ2  →  (paraxial)  n1 θ1 = n2 θ2</pre>
          </div>
          <p class="small muted">Valid when the medium is homogeneous, isotropic (or effectively so), and linear, and angles are small for the paraxial form.</p>
        </div>

        <div class="callout">
          <div class="tag"><span class="dot"></span><span>Fresnel coefficients (normal incidence)</span></div>
          <p class="muted small">At normal incidence, reflection depends on <b>impedance</b>, not directly on <span class="pill">n</span>.</p>
          <div class="eq" data-copy>
            <pre>r = (η2 − η1)/(η2 + η1)
t = 2η2/(η2 + η1)      (E-field amplitude, wave from 1 → 2)</pre>
          </div>
          <p class="small muted">For matched impedances (<span class="pill">η2=η1</span>): <span class="pill">r=0</span>, <span class="pill">t=1</span>.</p>
        </div>
      </div>

      <h3>Common models / approximations (and why we use them)</h3>
      <ul>
        <li><b>Geometric optics / paraxial rays:</b> to get a clean imaging equation and a Fig. 8.1-6(b)-type ray graph. Assumes features ≫ wavelength and small angles.</li>
        <li><b>Plane-wave (spatial-frequency) decomposition:</b> to discuss propagating vs evanescent content and near-field restoration.</li>
        <li><b>Ideal DNG (“lossless, matched”):</b> a standard pedagogical model where reflections vanish, isolating the imaging physics. Real metamaterials have dispersion and loss; those reduce perfect restoration.</li>
      </ul>

      <h3>Mini intuition examples (quick)</h3>
      <ul>
        <li>If <span class="pill">n₂ = −n₁</span>, then <span class="pill">θ₂ = −θ₁</span>. Rays “mirror” about the normal and can meet inside the negative-index region.</li>
        <li>Evanescent component in air: <span class="pill">E(z) ∝ e^{−α z}</span>. If a slab provides <span class="pill">e^{+α z}</span> growth over thickness <span class="pill">d</span>, it can undo the decay.</li>
      </ul>

      <div class="callout">
        <div class="tag warn"><span class="dot"></span><span>What to watch for (pitfalls)</span></div>
        <ul>
          <li><b>Index vs impedance:</b> knowing <span class="pill">n</span> alone does <i>not</i> determine reflection; you need <span class="pill">η</span> (i.e., ε and μ).</li>
          <li><b>Sign conventions:</b> negative refraction flips angle sign; keep geometry consistent with your coordinate axes.</li>
          <li><b>Evanescent inside the slab:</b> whether the field decays or grows depends on which exponential satisfies boundary conditions and physical power flow; in DNG media the “growing” solution can be the relevant one.</li>
        </ul>
      </div>
    </section>

    <section id="part1" class="fadeIn">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>Problem rewritten clearly</h3>
      <p>
        We have a slab of thickness <span class="pill">d</span> in air. The slab is a negative-index metamaterial with refractive index <span class="pill">n = −2</span>.
        (Air has <span class="pill">n₁ = 1</span>.) We must:
      </p>
      <ul>
        <li>Show its <b>near-field imaging capability</b> by constructing a <b>ray graph</b> like Fig. 8.1-6(b) and derive the <b>imaging equation</b>.</li>
        <li>Find <b>reflection and transmission coefficients</b> for a <b>normally incident</b> wave at the slab boundaries.</li>
        <li>Sketch the <b>amplitude profile</b> of an <b>evanescent</b> spatial-frequency component transmitted through the slab (like Fig. 8.1-6(d)).</li>
      </ul>

      <div class="grid2">
        <div class="callout">
          <div class="tag"><span class="dot"></span><span>Given</span></div>
          <ul>
            <li>Air index: <span class="pill">n₁ = 1</span></li>
            <li>Slab index: <span class="pill">n₂ = n = −2</span></li>
            <li>Slab thickness: <span class="pill">d</span> (symbolic; choose example values for plots)</li>
            <li>Normal incidence for Fresnel part: <span class="pill">θ = 0</span></li>
          </ul>
        </div>
        <div class="callout">
          <div class="tag"><span class="dot"></span><span>Unknowns / outputs</span></div>
          <ul>
            <li>Imaging equation relating object distance <span class="pill">s</span> and image distance <span class="pill">s′</span></li>
            <li>Normal-incidence coefficients <span class="pill">r</span>, <span class="pill">t</span> (and interpretation)</li>
            <li>Evanescent amplitude profile <span class="pill">|E(z)|</span> across: air → slab → air</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why)</h3>
      <ul>
        <li><b>Geometric optics / Snell’s law:</b> needed for the ray graph and imaging equation (Fig. 8.1-6(b) is a ray picture).</li>
        <li><b>Boundary conditions → Fresnel coefficients:</b> needed for reflection/transmission at normal incidence.</li>
        <li><b>Spatial-frequency decomposition:</b> evanescent waves correspond to <span class="pill">kₓ&gt;k₀</span>; their behavior is essential for near-field imaging.</li>
      </ul>
      <p class="muted">
        We do <i>not</i> need full vector Maxwell algebra for the imaging equation (paraxial rays suffice), but we do need Maxwell-based impedance ideas for the reflection part.
      </p>

      <div class="callout">
        <div class="tag warn"><span class="dot"></span><span>Assumptions (explicit)</span></div>
        <ul>
          <li>Slab is planar, homogeneous, isotropic; interfaces are flat and parallel.</li>
          <li>For ray imaging: <b>paraxial</b> (small angles), monochromatic, geometric optics applies.</li>
          <li>For Fresnel coefficients: linear media, time-harmonic fields, normal incidence.</li>
          <li>For the evanescent sketch: we use an <b>idealized DNG model</b> to illustrate amplification (typical in the “NIM lens” discussion); real loss/dispersion would reduce the effect.</li>
        </ul>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ul>
        <li><b>(A) Pure ray geometry (recommended):</b> trace a generic paraxial ray through both interfaces and impose “all rays meet.” Fast and transparent for imaging equation.</li>
        <li><b>(B) ABCD matrices / ray-transfer:</b> elegant and general; slightly more abstract but yields the same linear relation between <span class="pill">s</span> and <span class="pill">s′</span>.</li>
        <li><b>(C) Full wave transfer function:</b> best for exact evanescent behavior and phase, but heavier. Overkill for the ray-graph part.</li>
      </ul>
      <p><b>Choice:</b> We use <b>(A)</b> for the imaging equation, plus Fresnel formulas for normal incidence, and a transfer-function style exponential model to sketch evanescent amplitude.</p>
    </section>

    <section id="part2" class="fadeIn">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>
      <ol>
        <li><b>Set geometry:</b> Put first interface at <span class="pill">z=0</span>, slab ends at <span class="pill">z=d</span>. Define object distance <span class="pill">s</span> (object at <span class="pill">z=-s</span>) and image distance <span class="pill">s′</span> (image at <span class="pill">z=d+s′</span>).</li>
        <li><b>Trace a generic ray:</b> Let it hit the first interface at transverse position <span class="pill">x₁</span>. Express the incident slope (paraxial angle) in terms of <span class="pill">x₁</span>, <span class="pill">s</span>.</li>
        <li><b>Apply Snell (paraxial):</b> use <span class="pill">n₁ θ₁ = n₂ θ₂</span> to get the slope inside the slab.</li>
        <li><b>Propagate to second interface:</b> compute <span class="pill">x₂</span> at <span class="pill">z=d</span>.</li>
        <li><b>Refract out:</b> apply Snell again to get the exiting slope in air.</li>
        <li><b>Imaging condition:</b> impose that the final intersection point <span class="pill">(z=d+s′, x=x_img)</span> is independent of <span class="pill">x₁</span>. Solve for <span class="pill">s′</span> and magnification.</li>
        <li><b>Normal incidence coefficients:</b> write <span class="pill">r,t</span> in terms of impedances; then specialize to the common matched DNG idealization.</li>
        <li><b>Evanescent profile:</b> choose a spatial frequency <span class="pill">kₓ</span> and write piecewise exponentials in air (decay) and in slab (growth) to sketch a semilog amplitude vs <span class="pill">z</span>.</li>
      </ol>

      <div class="callout">
        <div class="tag bad"><span class="dot"></span><span>Common mistakes & quick tips</span></div>
        <ul>
          <li><b>Mixing up distances:</b> keep <span class="pill">s</span> measured from the first interface, and <span class="pill">s′</span> from the second.</li>
          <li><b>Forgetting angle sign:</b> if <span class="pill">n₂</span> is negative, then <span class="pill">θ₂</span> flips sign relative to <span class="pill">θ₁</span>.</li>
          <li><b>Assuming r from n:</b> at normal incidence, <span class="pill">r</span> comes from <span class="pill">η</span>. If the problem only states <span class="pill">n</span>, report the general <span class="pill">η</span>-based result and then the standard matched special case.</li>
        </ul>
      </div>
    </section>

    <section id="part3" class="fadeIn">
      <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

      <h3>Physical intuition first (qualitative expectation)</h3>
      <p>
        A negative-index slab “bends rays the wrong way.” The first interface (air → NIM) can make rays from a point source
        converge <b>inside</b> the slab; then the second interface (NIM → air) can create another convergence point <b>outside</b>.
        If the exiting rays re-create the original transverse coordinate, the image is <b>upright</b> (positive magnification).
        Meanwhile, near-field detail corresponds to evanescent components that usually decay in air—so an imaging-capable NIM slab must
        (at least partially) <b>compensate</b> that decay.
      </p>

      <div class="hr"></div>

      <h3>A) Imaging equation from paraxial ray tracing</h3>
      <p><b>Geometry and symbols</b> (define everything):</p>
      <ul>
        <li>First interface: <span class="pill">z=0</span>. Second interface: <span class="pill">z=d</span>.</li>
        <li>Object point at <span class="pill">z=-s</span> with transverse coordinate <span class="pill">x=h</span> (off-axis point to test imaging).</li>
        <li>A generic ray intersects the first interface at <span class="pill">x=x₁</span>.</li>
        <li>Paraxial slope (angle) <span class="pill">u = dx/dz ≈ θ</span> (dimensionless).</li>
        <li>Indices: <span class="pill">n₁=1</span> (air), <span class="pill">n₂=n</span> (NIM slab, here <span class="pill">n=-2</span>).</li>
      </ul>

      <p><b>Step 1 — Incident slope in air</b></p>
      <p>
        The ray goes from <span class="pill">(z=-s, x=h)</span> to <span class="pill">(z=0, x=x₁)</span>, so its slope in air is
      </p>
      <div class="eq" data-copy>
        <pre>u1 = (x1 − h)/s</pre>
      </div>
      <p class="muted small">This is just “rise over run” in the x–z plane.</p>

      <p><b>Step 2 — Refraction into the NIM slab (paraxial Snell)</b></p>
      <p>
        For small angles: <span class="pill">n₁ u₁ = n₂ u₂</span>. With <span class="pill">n₁=1</span>, <span class="pill">n₂=n</span>:
      </p>
      <div class="eq" data-copy>
        <pre>u2 = (n1/n2) u1 = (1/n) u1</pre>
      </div>
      <p class="muted small">
        If <span class="pill">n&lt;0</span>, then <span class="pill">u2</span> has the opposite sign to <span class="pill">u1</span>:
        negative refraction.
      </p>

      <p><b>Step 3 — Propagate across slab to z=d</b></p>
      <p>
        In a uniform medium, rays are straight lines: <span class="pill">x(z)=x₁ + u₂ z</span>. At <span class="pill">z=d</span>:
      </p>
      <div class="eq" data-copy>
        <pre>x2 = x1 + u2 d = x1 + (u1/n) d</pre>
      </div>

      <p><b>Step 4 — Refraction back into air</b></p>
      <p>
        At the second interface (medium 2 → 1), paraxial Snell gives <span class="pill">n₂ u₂ = n₁ u₃</span>, so:
      </p>
      <div class="eq" data-copy>
        <pre>u3 = (n2/n1) u2 = n u2 = u1</pre>
      </div>
      <p class="muted small">
        The slab produces <b>no net angular deviation</b> (the exiting ray has the same slope as the incident ray),
        but it can still <b>shift</b> rays laterally and produce imaging because the internal segment has a different slope.
      </p>

      <p><b>Step 5 — Find where the exiting ray meets an image plane</b></p>
      <p>
        In the exit region (air), the ray line is <span class="pill">x(z) = x₂ + u₃ (z-d)</span>.
        Evaluate at a candidate image plane <span class="pill">z = d + s′</span> (distance <span class="pill">s′</span> from the second interface):
      </p>
      <div class="eq" data-copy>
        <pre>x_img = x2 + u3 s′ = x1 + (u1/n)d + u1 s′
      = x1 + u1 (s′ + d/n)</pre>
      </div>

      <p><b>Step 6 — Impose the imaging condition (independent of x₁)</b></p>
      <p>
        Substitute <span class="pill">u1 = (x1 − h)/s</span>:
      </p>
      <div class="eq" data-copy>
        <pre>x_img = x1 + (x1 − h)/s · (s′ + d/n)
     = x1[ 1 + (s′ + d/n)/s ] − h (s′ + d/n)/s</pre>
      </div>
      <p>
        For a sharp image of the object point, <span class="pill">x_img</span> must not depend on which ray we chose (i.e., on <span class="pill">x₁</span>).
        Therefore the coefficient of <span class="pill">x₁</span> must be zero:
      </p>
      <div class="eq" data-copy>
        <pre>1 + (s′ + d/n)/s = 0  →  s′ = −s − d/n</pre>
      </div>

      <div class="callout">
        <div class="tag good"><span class="dot"></span><span>Imaging equation (general air–NIM–air, paraxial)</span></div>
        <div class="eq" data-copy>
          <pre>s′ = −s − d/n</pre>
        </div>
        <p class="small muted">
          Here <span class="pill">s</span> is measured from the first interface (object at <span class="pill">z=-s</span>) and <span class="pill">s′</span> from the second interface (image at <span class="pill">z=d+s′</span>).
        </p>
      </div>

      <p><b>Specialize to n = −2</b></p>
      <div class="eq" data-copy>
        <pre>For n = −2:   s′ = −s − d/(−2) = d/2 − s</pre>
      </div>

      <p><b>Magnification</b></p>
      <p>
        When the imaging condition holds, the remaining term gives
      </p>
      <div class="eq" data-copy>
        <pre>x_img = h</pre>
      </div>
      <p>
        So the image is <b>upright</b> with <b>unit transverse magnification</b>:
        <span class="pill">M = x_img/h = +1</span>.
      </p>

      <p><b>Where is the (real) image?</b></p>
      <ul>
        <li>If <span class="pill">s′ &gt; 0</span> then the image is real on the right side of the slab: for <span class="pill">n=−2</span>, this requires <span class="pill">s &lt; d/2</span>.</li>
        <li>If <span class="pill">s′ = 0</span>, the image is at the second surface: <span class="pill">s=d/2</span>.</li>
        <li>If <span class="pill">s′ &lt; 0</span>, the image is virtual (would appear to come from a point left of the second surface).</li>
      </ul>

      <p><b>Sanity checks</b></p>
      <ul>
        <li><b>Units:</b> <span class="pill">s</span>, <span class="pill">s′</span>, <span class="pill">d</span> are lengths; <span class="pill">d/n</span> is a length. Good.</li>
        <li><b>Limiting case n = −1:</b> <span class="pill">s′ = d − s</span>, matching the classic slab-lens relation often shown in Fig. 8.1-6(b)-style diagrams.</li>
        <li><b>Sign reasoning:</b> negative <span class="pill">n</span> makes <span class="pill">−d/n</span> positive, enabling real images for some object positions.</li>
      </ul>

      <div class="hr"></div>

      <h3>B) Reflection and transmission at normal incidence</h3>
      <p>
        At normal incidence, the Fresnel amplitude coefficients (electric field) for a wave going from medium 1 to 2 are:
      </p>
      <div class="eq" data-copy>
        <pre>r = (η2 − η1)/(η2 + η1)
t = 2η2/(η2 + η1)</pre>
      </div>

      <p><b>Important:</b> the problem specifies <span class="pill">n</span>, but <span class="pill">r,t</span> depend on <span class="pill">η</span>.
        In metamaterials, <span class="pill">n = ±√(εr μr)</span> while <span class="pill">η = η0 √(μr/εr)</span>. Many different (εr, μr) pairs produce the same <span class="pill">n</span>.</p>

      <div class="callout">
        <div class="tag"><span class="dot"></span><span>Standard ideal NIM-lens assumption (lossless, matched DNG)</span></div>
        <p class="small muted">
          A common textbook choice is <span class="pill">εr = μr = −2</span>. Then
          <span class="pill">n = −√(εr μr) = −2</span> and the impedance ratio is
          <span class="pill">η2/η1 = √(μr/εr) = 1</span> (matched to air).
        </p>
        <div class="eq" data-copy>
          <pre>If η2 = η1  →  r = 0,  t = 1  (each boundary, normal incidence)</pre>
        </div>
        <p class="small muted">
          With no reflections at either interface, the slab has <b>unity transmittance</b> in magnitude for propagating normal-incidence waves; the field also acquires a phase factor through the slab.
        </p>
      </div>

      <p><b>Phase through the slab (propagating wave, normal incidence)</b></p>
      <p>
        In the slab, <span class="pill">k2 = n k0</span>, so propagation contributes <span class="pill">e^{i k2 d} = e^{i n k0 d}</span>.
        For <span class="pill">n=-2</span>, the phase advances in the opposite sense (negative phase).
      </p>

      <div class="hr"></div>

      <h3>C) Evanescent-wave amplitude profile across the slab (like Fig. 8.1-6(d))</h3>
      <p>
        Decompose the object field into spatial-frequency components <span class="pill">E(x, z=0) ∝ e^{i kx x}</span>. For each component:
      </p>
      <div class="eq" data-copy>
        <pre>kx^2 + kz^2 = (n k0)^2</pre>
      </div>
      <p>
        In air (<span class="pill">n=1</span>), if <span class="pill">kx &gt; k0</span> then <span class="pill">kz = iα1</span> with
      </p>
      <div class="eq" data-copy>
        <pre>α1 = √(kx^2 − k0^2)   (evanescent decay constant in air)</pre>
      </div>
      <p>
        so the magnitude decays away from the object plane as <span class="pill">|E| ∝ e^{−α1 z}</span>.
      </p>

      <p>
        Inside an ideal DNG slab, boundary conditions can excite surface-supported fields such that the relevant solution
        grows across the slab (this is the mechanism behind “evanescent restoration” in the idealized NIM lens discussion).
        For a component that is also evanescent in the slab, we write
      </p>
      <div class="eq" data-copy>
        <pre>α2 = √(kx^2 − (|n|k0)^2)    (evanescent constant in slab, when kx &gt; |n|k0)
|E| inside slab  ∝ e^{+α2 z}   (growth toward the exit interface)</pre>
      </div>

      <p class="muted">
        This produces the qualitative “decay in air → growth in slab → decay in air” semilog profile like Fig. 8.1-6(d).
        The interactive plot below shows this piecewise behavior using example values.
      </p>

      <div class="callout">
        <div class="tag good"><span class="dot"></span><span>Final results (boxed)</span></div>
        <div class="eq" data-copy id="finalAnswerEq">
          <pre>Imaging (paraxial, air–NIM–air slab):
  s′ = −s − d/n

For n = −2:
  s′ = d/2 − s   (upright, unit magnification)

Normal incidence (general):
  r = (η2 − η1)/(η2 + η1),   t = 2η2/(η2 + η1)

If impedance matched (η2=η1, e.g., εr=μr=−2):
  r = 0,  t = 1  (each boundary; unity transmittance in magnitude)</pre>
        </div>
        <div class="copyRow">
          <button class="copyBtn" data-copybtn="#finalAnswerEq pre">Copy final answer (plain text)</button>
          <span class="muted small">Tip: copy buttons work without MathJax; everything is plain text.</span>
        </div>
      </div>
    </section>

    <section id="part4" class="fadeIn">
      <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

      <h3>Re-interpreting the imaging equation</h3>
      <p>
        The paraxial imaging rule
        <span class="pill">s′ = −s − d/n</span>
        says the slab contributes an “effective shift length” <span class="pill">−d/n</span>.
        For negative <span class="pill">n</span>, this term is <b>positive</b>, making real images possible on the far side.
      </p>
      <ul>
        <li><b>Thickness d:</b> increasing <span class="pill">d</span> increases the available positive offset <span class="pill">−d/n</span>, expanding the range of <span class="pill">s</span> that produces a real image.</li>
        <li><b>Index magnitude |n|:</b> for <span class="pill">n=-2</span>, the offset is <span class="pill">d/2</span>, smaller than the <span class="pill">d</span> offset of the <span class="pill">n=-1</span> slab; thus the “imaging reach” (range of s giving s′>0) is reduced.</li>
        <li><b>Magnification:</b> the derivation gives <span class="pill">x_img = h</span> → <span class="pill">M=+1</span>. The slab reproduces transverse position (upright image) in this paraxial model.</li>
      </ul>

      <h3>Parameter effects (connect to plots)</h3>
      <ul>
        <li>As you increase <span class="pill">s/d</span> toward <span class="pill">d/2</span> (for <span class="pill">n=-2</span>), the image plane moves toward the exit surface (<span class="pill">s′ → 0</span>).</li>
        <li>Changing <span class="pill">n</span> changes the slope/intercept of the <span class="pill">s′(s)</span> line: <span class="pill">s′/d = −s/d − 1/n</span>.</li>
        <li>Increasing <span class="pill">kₓ/k₀</span> increases the decay constant <span class="pill">α</span>, so free-space decay becomes steeper; the slab must provide stronger growth to compensate.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p class="muted">
        Using ABCD matrices: propagate in air from object to first interface, apply a “refraction” matrix at the interface (paraxial),
        propagate in slab, refract out, propagate to the image plane. The imaging condition corresponds to the system mapping all rays from a point to a point,
        which again yields <span class="pill">s′ = −s − d/n</span>.
      </p>

      <h3>Concept checks (quick self-test)</h3>
      <ul>
        <li><b>Q:</b> Why can’t you compute <span class="pill">r</span> from <span class="pill">n</span> alone? <b>A:</b> Because at normal incidence <span class="pill">r</span> depends on impedance <span class="pill">η=√(μ/ε)</span>, while <span class="pill">n</span> depends on <span class="pill">√(εμ)</span>.</li>
        <li><b>Q:</b> For <span class="pill">n=-2</span>, when is the external image real? <b>A:</b> When <span class="pill">s′=d/2 − s &gt; 0</span> → <span class="pill">s &lt; d/2</span>.</li>
        <li><b>Q:</b> What makes a component “evanescent” in air? <b>A:</b> <span class="pill">kₓ &gt; k₀</span> so <span class="pill">k_z</span> becomes imaginary and the field decays exponentially.</li>
        <li><b>Q:</b> What is the qualitative signature of near-field restoration? <b>A:</b> Semilog amplitude vs z shows decay in air, growth in the slab, then decay again—aiming to recover amplitude near the image plane.</li>
      </ul>
    </section>

    <section id="part5" class="fadeIn">
      <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

      <figure>
        <div class="canvasCard">
          <div class="canvasGrid">
            <div>
              <canvas id="cDiagram" class="big" aria-label="Ray diagram canvas"></canvas>
              <p class="muted small">
                <b>Diagram:</b> ray tracing through an air–NIM–air slab. The object point (left) emits rays, which refract negatively in the slab and form an image
                at <span class="pill">z = d + s′</span>. The dashed vertical lines mark the interfaces.
              </p>
            </div>
            <div>
              <canvas id="cMain" class="small" aria-label="Main plot canvas"></canvas>
              <p class="muted small">
                <b>Main plot:</b> the imaging law <span class="pill">s′/d = −s/d − 1/n</span>. The marker shows the current slider setting.
              </p>
            </div>
          </div>
          <div style="margin-top:14px;">
            <canvas id="cSecondary" class="big" aria-label="Secondary plot canvas"></canvas>
            <p class="muted small">
              <b>Secondary plot:</b> semilog-style amplitude profile for one <b>evanescent</b> spatial-frequency component (example model):
              decay in air, growth in the slab, decay in air. The plot uses <span class="pill">log10(|E|/|Eobj|)</span> vs <span class="pill">z/d</span>.
            </p>
          </div>

          <div class="controls" aria-label="Interactive controls">
            <div class="control">
              <label>
                <span>Object distance <span class="pill">s/d</span></span>
                <span class="pill" id="labS">0.25</span>
              </label>
              <input id="sSlider" type="range" min="0.02" max="0.98" step="0.01" value="0.25"/>
              <p class="muted small" style="margin:6px 0 0;">Moves the object plane left of the slab; updates <span class="pill">s′</span>, rays, and profiles.</p>
            </div>

            <div class="control">
              <label>
                <span>Slab index <span class="pill">n</span></span>
                <span class="pill" id="labN">−2</span>
              </label>
              <select id="nSelect">
                <option value="-1">−1</option>
                <option value="-2" selected>−2</option>
                <option value="-3">−3</option>
              </select>
              <p class="muted small" style="margin:6px 0 0;">Changes the imaging intercept <span class="pill">−1/n</span> and the internal refraction angle.</p>
            </div>

            <div class="control">
              <label>
                <span>Evanescent spatial frequency <span class="pill">kₓ/k₀</span></span>
                <span class="pill" id="labKx">2.60</span>
              </label>
              <input id="kxSlider" type="range" min="1.05" max="4.0" step="0.01" value="2.60"/>
              <p class="muted small" style="margin:6px 0 0;">Controls decay/growth constants. (If <span class="pill">kₓ</span> is not evanescent in the slab, the plot indicates it.)</p>
            </div>
          </div>

          <div class="hr"></div>

          <div class="grid2">
            <div class="callout">
              <div class="tag"><span class="dot"></span><span>Copy key equations</span></div>
              <div class="eq" data-copy id="eqKey1">
                <pre>Paraxial Snell:  n1 θ1 = n2 θ2  (θ ≈ tanθ ≈ dx/dz)</pre>
              </div>
              <button class="copyBtn" data-copybtn="#eqKey1 pre">Copy</button>
            </div>
            <div class="callout">
              <div class="tag"><span class="dot"></span><span>Copy imaging law (general)</span></div>
              <div class="eq" data-copy id="eqKey2">
                <pre>Air–NIM–air slab (thickness d):
s′ = −s − d/n</pre>
              </div>
              <button class="copyBtn" data-copybtn="#eqKey2 pre">Copy</button>
            </div>
          </div>
        </div>
      </figure>

      <div class="callout">
        <div class="tag warn"><span class="dot"></span><span>Note on the evanescent plot model</span></div>
        <p class="small muted">
          The semilog amplitude profile is an <b>idealized teaching model</b> capturing the qualitative behavior shown in Fig. 8.1-6(d):
          free-space attenuation and slab-enhanced growth. Real metamaterials are dispersive and lossy, so the growth is limited.
          The ray-imaging law, however, comes from geometric optics and is plotted exactly in the paraxial approximation.
        </p>
      </div>
    </section>
  </div>
</main>

<footer class="fadeIn">
  <div class="hr"></div>
  <p>
    Built as a self-contained learning article (vanilla HTML/CSS/JS). If you paste this into your site, it will run offline with no external dependencies.
  </p>
</footer>

<script>
(function(){
  // ---------- helpers ----------
  function $(id){ return document.getElementById(id); }
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      toast("Copied ✓");
    }catch(e){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      document.body.appendChild(ta);
      ta.select();
      try{ document.execCommand("copy"); toast("Copied ✓"); }
      catch(err){ toast("Copy failed"); }
      document.body.removeChild(ta);
    }
  }

  let toastTimer = null;
  function toast(msg){
    let t = document.getElementById("toast");
    if(!t){
      t = document.createElement("div");
      t.id="toast";
      t.style.position="fixed";
      t.style.left="50%";
      t.style.bottom="18px";
      t.style.transform="translateX(-50%)";
      t.style.padding="10px 12px";
      t.style.borderRadius="12px";
      t.style.border="1px solid rgba(255,255,255,.16)";
      t.style.background="rgba(15,23,48,.92)";
      t.style.color="#eaf0ff";
      t.style.fontFamily="ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      t.style.boxShadow="0 12px 30px rgba(0,0,0,.35)";
      t.style.zIndex="9999";
      t.style.opacity="0";
      t.style.transition="opacity .2s ease, transform .2s ease";
      document.body.appendChild(t);
    }
    t.textContent = msg;
    t.style.opacity="1";
    t.style.transform="translateX(-50%) translateY(0)";
    if(toastTimer) clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>{
      t.style.opacity="0";
      t.style.transform="translateX(-50%) translateY(6px)";
    }, 1100);
  }

  // bind copy buttons
  document.querySelectorAll("[data-copybtn]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const sel = btn.getAttribute("data-copybtn");
      const node = document.querySelector(sel);
      if(node) copyText(node.textContent.trim());
    });
  });

  // ---------- canvas plotting utilities ----------
  function setupCanvas(canvas){
    const ctx = canvas.getContext("2d");
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(320, rect.width);
      const h = rect.height || 320;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {w, h, dpr};
    }
    return {ctx, resize};
  }

  function drawAxes(ctx, box, opts){
    // box: {x,y,w,h}
    const {
      xMin, xMax, yMin, yMax,
      xLabel, yLabel, title,
      xTicks=6, yTicks=6,
      grid=true
    } = opts;

    const padL = 52, padR=14, padT=34, padB=44;
    const ix = box.x + padL, iy = box.y + padT;
    const iw = box.w - padL - padR, ih = box.h - padT - padB;

    // background panel
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,.10)";
    ctx.fillRect(box.x, box.y, box.w, box.h);

    // title
    ctx.fillStyle = "rgba(234,240,255,.95)";
    ctx.font = "600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(title || "", box.x + 12, box.y + 20);

    // grid + ticks
    ctx.strokeStyle = "rgba(255,255,255,.10)";
    ctx.lineWidth = 1;

    function xToPx(x){ return ix + (x - xMin) * (iw/(xMax - xMin)); }
    function yToPx(y){ return iy + ih - (y - yMin) * (ih/(yMax - yMin)); }

    // grid + tick labels
    ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "rgba(185,196,230,.92)";

    for(let i=0;i<=xTicks;i++){
      const t = i/xTicks;
      const x = xMin + t*(xMax-xMin);
      const px = xToPx(x);
      if(grid){
        ctx.beginPath(); ctx.moveTo(px, iy); ctx.lineTo(px, iy+ih); ctx.stroke();
      }
      // tick
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.beginPath(); ctx.moveTo(px, iy+ih); ctx.lineTo(px, iy+ih+6); ctx.stroke();
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.fillText((Math.abs(x) < 1e-9 ? "0" : x.toFixed(2)), px-14, iy+ih+22);
    }
    for(let j=0;j<=yTicks;j++){
      const t = j/yTicks;
      const y = yMin + t*(yMax-yMin);
      const py = yToPx(y);
      if(grid){
        ctx.beginPath(); ctx.moveTo(ix, py); ctx.lineTo(ix+iw, py); ctx.stroke();
      }
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.beginPath(); ctx.moveTo(ix-6, py); ctx.lineTo(ix, py); ctx.stroke();
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.fillText((Math.abs(y) < 1e-9 ? "0" : y.toFixed(2)), ix-46, py+4);
    }

    // axes border
    ctx.strokeStyle = "rgba(255,255,255,.18)";
    ctx.strokeRect(ix, iy, iw, ih);

    // axis labels
    ctx.fillStyle = "rgba(234,240,255,.92)";
    ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(xLabel || "", ix + iw/2 - 40, iy + ih + 38);
    // y label rotated
    ctx.save();
    ctx.translate(box.x + 16, iy + ih/2 + 40);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel || "", 0, 0);
    ctx.restore();

    ctx.restore();

    return {ix, iy, iw, ih, xToPx, yToPx};
  }

  function strokePath(ctx, pts, color, width){
    if(pts.length<2) return;
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.stroke();
    ctx.restore();
  }

  // ---------- physics model (paraxial rays + simple evanescent profile) ----------
  // We use normalized lengths: d = 1 in plotting; later scale labels as "z/d".
  function imaging_sprime_over_d(s_over_d, n){
    // s' = -s - d/n  -> s'/d = -s/d - 1/n
    return -s_over_d - 1/n;
  }

  function rayTracePoints(s, n, d, h, x1){
    // object at z=-s, x=h; interface at z=0; second at z=d
    // slopes:
    const u1 = (x1 - h)/s;
    const u2 = (1/n)*u1;
    const x2 = x1 + u2*d;
    const u3 = u1;

    return {
      u1, u2, u3,
      obj:{z:-s,x:h},
      i1:{z:0,x:x1},
      i2:{z:d,x:x2}
    };
  }

  function evanescentProfile(zArr, s, sp, d, n, kx_over_k0){
    // Create a qualitative piecewise model for |E|/|Eobj|
    // Region A (left air): from object plane at z=-s to interface at z=0: decay exp(-α1*(z + s))
    // Region B (slab): growth exp(+α2*z)
    // Region C (right air): decay exp(-α1*(z - d))
    // We normalize such that |E| at object point (z=-s) is 1.
    // α1 = sqrt(kx^2 - k0^2) = k0*sqrt((kx/k0)^2 - 1); use normalized α1d = sqrt(...) since we plot vs z/d
    // α2 exists if kx > |n|k0. Otherwise we show oscillatory / "not evanescent in slab" by setting α2=0 and flag.
    const q = kx_over_k0;
    const a1 = Math.sqrt(Math.max(0, q*q - 1));         // in units of k0
    const a2 = Math.sqrt(Math.max(0, q*q - (Math.abs(n)*Math.abs(n)))); // in units of k0

    const slabEvan = (q > Math.abs(n)); // ensures kx > |n| k0
    // For pedagogy: if not evanescent in slab, we still compute a "weak growth" (0) and show flag in plot.
    const a2eff = slabEvan ? a2 : 0;

    // piecewise amplitude (log10)
    const out = [];
    for(const z of zArr){
      let amp = 1;

      if(z <= 0){
        // left air
        // distance from object plane: (z - (-s)) = z + s
        amp = Math.exp(-a1 * (z + s));
      }else if(z <= d){
        // inside slab: first, take amplitude at z=0 from left region, then grow
        const amp0 = Math.exp(-a1 * (0 + s));
        amp = amp0 * Math.exp(+a2eff * z);
      }else{
        // right air: amplitude at z=d from slab then decay
        const amp0 = Math.exp(-a1 * (0 + s));
        const ampD = amp0 * Math.exp(+a2eff * d);
        amp = ampD * Math.exp(-a1 * (z - d));
      }

      out.push({z, amp, log: Math.log10(Math.max(amp, 1e-12)), slabEvan, a1, a2:a2eff});
    }
    return out;
  }

  // ---------- renderers ----------
  const cDiagram = setupCanvas($("cDiagram"));
  const cMain = setupCanvas($("cMain"));
  const cSecondary = setupCanvas($("cSecondary"));

  function renderAll(){
    const sOverD = parseFloat($("sSlider").value);
    const n = parseFloat($("nSelect").value);
    const kx = parseFloat($("kxSlider").value);

    $("labS").textContent = sOverD.toFixed(2);
    $("labN").textContent = (n<0 ? "−" + Math.abs(n) : String(n));
    $("labKx").textContent = kx.toFixed(2);

    // normalized: d = 1
    const d = 1;
    const s = sOverD * d;
    const spOverD = imaging_sprime_over_d(sOverD, n);
    const sp = spOverD * d;

    // ---------- Diagram ----------
    {
      const {ctx, resize} = cDiagram;
      const {w,h} = resize();
      ctx.clearRect(0,0,w,h);

      // mapping world -> screen (z in [-s - 0.15, d + max(sp,0.15) + 0.2], x in [-0.75, 0.75])
      const zMin = -s - 0.22;
      const zMax = d + Math.max(sp, 0.18) + 0.22;
      const xMin = -0.75, xMax = 0.75;

      const pad = 18;
      const plot = {x:pad,y:pad,w:w-2*pad,h:h-2*pad};

      function zxToPx(z){ return plot.x + (z - zMin) * (plot.w/(zMax - zMin)); }
      function xxToPy(x){ return plot.y + plot.h/2 - (x - 0) * (plot.h*0.38/(xMax - xMin)); }

      // background
      ctx.fillStyle = "rgba(0,0,0,.10)";
      ctx.fillRect(plot.x, plot.y, plot.w, plot.h);

      // slab region shading
      const z0 = zxToPx(0), zD = zxToPx(d);
      ctx.fillStyle = "rgba(122,162,255,.08)";
      ctx.fillRect(z0, plot.y, zD-z0, plot.h);

      // interfaces
      ctx.strokeStyle = "rgba(255,255,255,.30)";
      ctx.lineWidth = 1.5;
      ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(z0, plot.y+10); ctx.lineTo(z0, plot.y+plot.h-10); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(zD, plot.y+10); ctx.lineTo(zD, plot.y+plot.h-10); ctx.stroke();
      ctx.setLineDash([]);

      // axis line (optical axis)
      ctx.strokeStyle = "rgba(255,255,255,.14)";
      ctx.beginPath();
      ctx.moveTo(plot.x+8, plot.y+plot.h/2);
      ctx.lineTo(plot.x+plot.w-8, plot.y+plot.h/2);
      ctx.stroke();

      // labels
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.font = "600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Ray diagram (paraxial): air → NIM slab → air", plot.x+12, plot.y+22);

      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillStyle = "rgba(185,196,230,.95)";
      ctx.fillText("z", plot.x+plot.w-18, plot.y+plot.h/2-10);
      ctx.fillText("x", plot.x+10, plot.y+16);

      // region labels
      ctx.fillStyle = "rgba(185,196,230,.85)";
      ctx.fillText("air (n=1)", plot.x+10, plot.y+plot.h-12);
      ctx.fillText("NIM slab (n="+(n<0?("−"+Math.abs(n)):n)+")", z0+10, plot.y+plot.h-12);
      ctx.fillText("air (n=1)", zD+10, plot.y+plot.h-12);

      // object and image points
      const hObj = 0.35; // transverse offset in diagram world units
      const obj = {z:-s, x:hObj};
      const img = {z:d+sp, x:hObj};

      // draw points
      function drawPoint(p, color, label){
        const px = zxToPx(p.z), py = xxToPy(p.x);
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.arc(px, py, 4.2, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "rgba(234,240,255,.92)";
        ctx.fillText(label, px+8, py-6);
      }
      drawPoint(obj, "rgba(125,255,204,.95)", "Object");
      if(sp > 0){
        drawPoint(img, "rgba(255,212,121,.95)", "Real image");
      }else{
        // virtual image: show dashed marker at z=d+sp (left of second interface)
        drawPoint(img, "rgba(255,122,158,.95)", "Virtual image");
      }

      // choose several rays by choosing x1 at interface
      const x1s = [-0.42, -0.22, 0.0, 0.22, 0.42];
      const rayColor = "rgba(255,122,158,.85)";

      x1s.forEach(x1=>{
        const tr = rayTracePoints(s, n, d, hObj, x1);
        // if image is real: draw until z=d+sp; else draw a bit past d for appearance
        const zEnd = d + Math.max(sp, 0.22);
        const endX = tr.i2.x + tr.u3*(zEnd - d);

        const pts = [
          {x: zxToPx(tr.obj.z), y: xxToPy(tr.obj.x)},
          {x: zxToPx(tr.i1.z), y: xxToPy(tr.i1.x)},
          {x: zxToPx(tr.i2.z), y: xxToPy(tr.i2.x)},
          {x: zxToPx(zEnd),   y: xxToPy(endX)}
        ];
        strokePath(ctx, pts, rayColor, 2);

        // if real image, draw a faint convergence highlight near the image
        if(sp > 0){
          const px = zxToPx(d+sp), py = xxToPy(hObj);
          ctx.strokeStyle = "rgba(255,212,121,.25)";
          ctx.beginPath(); ctx.arc(px, py, 16, 0, Math.PI*2); ctx.stroke();
        }
      });

      // annotate distances
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillText("s/d = "+sOverD.toFixed(2), zxToPx(-s)+10, plot.y+40);
      ctx.fillText("s′/d = "+spOverD.toFixed(2), zxToPx(d)+10, plot.y+56);
      ctx.fillText("Imaging law: s′/d = −s/d − 1/n", plot.x+12, plot.y+plot.h-34);

      // border
      ctx.strokeStyle = "rgba(255,255,255,.12)";
      ctx.strokeRect(plot.x, plot.y, plot.w, plot.h);
    }

    // ---------- Main plot: s'/d vs s/d ----------
    {
      const {ctx, resize} = cMain;
      const {w,h} = resize();
      ctx.clearRect(0,0,w,h);

      const box = {x:10,y:10,w:w-20,h:h-20};

      // choose axis bounds
      const xMin=0, xMax=1;
      const yMin=-1.2, yMax=1.2;

      const A = drawAxes(ctx, box, {
        xMin,xMax,yMin,yMax,
        xLabel:"s/d (object distance, normalized)",
        yLabel:"s′/d (image distance, normalized)",
        title:"Imaging graph (paraxial): s′/d = −s/d − 1/n",
        xTicks:5,yTicks:6,grid:true
      });

      // line
      const pts = [];
      for(let i=0;i<=200;i++){
        const x = xMin + (xMax-xMin)*i/200;
        const y = imaging_sprime_over_d(x, n);
        pts.push({x:A.xToPx(x), y:A.yToPx(y)});
      }
      strokePath(ctx, pts, "rgba(122,162,255,.92)", 2.4);

      // zero line
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(A.xToPx(xMin), A.yToPx(0));
      ctx.lineTo(A.xToPx(xMax), A.yToPx(0));
      ctx.stroke();
      ctx.restore();

      // marker for current s
      const yMark = spOverD;
      ctx.save();
      ctx.fillStyle = "rgba(255,212,121,.95)";
      ctx.beginPath();
      ctx.arc(A.xToPx(sOverD), A.yToPx(yMark), 5, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,.25)";
      ctx.stroke();
      ctx.restore();

      // legend
      ctx.save();
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      const legX = A.ix + 10, legY = A.iy + 10;
      ctx.fillText("n = " + (n<0?("−"+Math.abs(n)):n), legX, legY+12);
      ctx.fillStyle = "rgba(185,196,230,.92)";
      ctx.fillText("Real image when s′ > 0", legX, legY+30);
      ctx.restore();
    }

    // ---------- Secondary plot: evanescent amplitude profile ----------
    {
      const {ctx, resize} = cSecondary;
      const {w,h} = resize();
      ctx.clearRect(0,0,w,h);

      const box = {x:10,y:10,w:w-20,h:h-20};

      // z range: show object plane at z=-s and extend to right image plane z=d+sp (or at least d+0.25)
      const zMin = -s;
      const zMax = d + Math.max(sp, 0.25);

      // sample points
      const zArr = [];
      const N = 450;
      for(let i=0;i<=N;i++){
        zArr.push(zMin + (zMax-zMin)*i/N);
      }
      const prof = evanescentProfile(zArr, s, sp, d, n, kx);
      // log10 amplitude
      // choose y-limits adaptively
      let yLo = +Infinity, yHi = -Infinity;
      for(const p of prof){
        yLo = Math.min(yLo, p.log);
        yHi = Math.max(yHi, p.log);
      }
      // pad
      yLo = Math.floor((yLo-0.2)*2)/2;
      yHi = Math.ceil((yHi+0.2)*2)/2;
      yLo = clamp(yLo, -6, 1);
      yHi = clamp(yHi, -5, 1.5);
      if(yHi - yLo < 2){ yLo -= 1; yHi += 1; }

      const A = drawAxes(ctx, box, {
        xMin: zMin/d, xMax: zMax/d,
        yMin: yLo, yMax: yHi,
        xLabel:"z/d (normalized propagation direction)",
        yLabel:"log10(|E|/|Eobj|)",
        title:"Evanescent component amplitude profile (teaching model)",
        xTicks:6, yTicks:6, grid:true
      });

      // interface markers (z=0, z=d)
      ctx.save();
      ctx.setLineDash([6,6]);
      ctx.strokeStyle = "rgba(255,255,255,.30)";
      ctx.lineWidth = 1.3;
      ctx.beginPath(); ctx.moveTo(A.xToPx(0), A.iy); ctx.lineTo(A.xToPx(0), A.iy+A.ih); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(A.xToPx(1), A.iy); ctx.lineTo(A.xToPx(1), A.iy+A.ih); ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();

      // draw curve
      const pts = prof.map(p=>({x:A.xToPx(p.z/d), y:A.yToPx(p.log)}));
      strokePath(ctx, pts, "rgba(125,255,204,.92)", 2.4);

      // annotate object plane and image plane
      ctx.save();
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Object plane (z=-s)", A.xToPx((-s)/d)+8, A.yToPx(yHi)-10);
      const zp = (d+sp)/d;
      ctx.fillText("Image plane (z=d+s′)", A.xToPx(zp)-110, A.yToPx(yHi)-10);
      ctx.restore();

      // add a small legend / status line
      const last = prof[prof.length-1];
      const slabEvan = last.slabEvan;
      const a1 = last.a1, a2 = last.a2;

      ctx.save();
      const lx = A.ix + 10, ly = A.iy + A.ih - 54;
      ctx.fillStyle = "rgba(0,0,0,.25)";
      ctx.fillRect(lx-6, ly-16, 360, 58);
      ctx.strokeStyle = "rgba(255,255,255,.12)";
      ctx.strokeRect(lx-6, ly-16, 360, 58);

      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("kx/k0 = "+kx.toFixed(2)+",  n = "+(n<0?("−"+Math.abs(n)):n), lx, ly);
      ctx.fillStyle = "rgba(185,196,230,.92)";
      ctx.fillText("α1/k0 = √(q²−1) = "+a1.toFixed(2), lx, ly+18);
      if(slabEvan){
        ctx.fillText("α2/k0 = √(q²−|n|²) = "+a2.toFixed(2)+"  (evanescent in slab → growth shown)", lx, ly+36);
      }else{
        ctx.fillStyle = "rgba(255,212,121,.95)";
        ctx.fillText("Note: q ≤ |n| so this component is not evanescent in the slab; growth is not modeled.", lx, ly+36);
      }
      ctx.restore();
    }
  }

  // ---------- UI events ----------
  ["sSlider","nSelect","kxSlider"].forEach(id=>{
    $(id).addEventListener("input", renderAll);
    $(id).addEventListener("change", renderAll);
  });

  // Resize handling
  let rAF = null;
  window.addEventListener("resize", ()=>{
    if(rAF) cancelAnimationFrame(rAF);
    rAF = requestAnimationFrame(()=>{ renderAll(); });
  });

  // Initial render
  renderAll();

  // copy any equation block by clicking it (optional convenience)
  document.querySelectorAll(".eq[data-copy]").forEach(eq=>{
    eq.style.cursor = "pointer";
    eq.title = "Click to copy plain text";
    eq.addEventListener("click", ()=>{
      const pre = eq.querySelector("pre");
      if(pre) copyText(pre.textContent.trim());
    });
  });
})();
</script>
</body>
</html>
