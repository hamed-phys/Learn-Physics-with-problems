<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>SPP at a DPS–Lossy SNG Boundary (Small-Loss Approximations)</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#0f1626;
      --card:#121c2f;
      --ink:#e8eefc;
      --muted:#b8c4e6;
      --faint:#7f8bb0;
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.16);
      --accent:#7aa2ff;
      --accent2:#69e3c0;
      --warn:#ffcc66;
      --bad:#ff6b7a;
      --good:#7dff9a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 700px at 20% -10%, rgba(122,162,255,.22), transparent 55%),
                  radial-gradient(1000px 600px at 90% 10%, rgba(105,227,192,.14), transparent 55%),
                  var(--bg);
      color:var(--ink);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding: 28px 18px 10px;
      max-width: 1200px;
      margin: 0 auto;
    }
    header .title{
      display:flex; flex-direction:column; gap:6px;
    }
    h1{
      margin:0;
      font-size: clamp(1.6rem, 2.2vw + 1rem, 2.6rem);
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      font-size: 1.02rem;
      max-width: 80ch;
    }

    main{
      max-width:1200px;
      margin: 0 auto;
      padding: 14px 18px 46px;
      display:grid;
      grid-template-columns: 280px 1fr;
      gap: 18px;
      align-items:start;
    }
    nav#toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 12px;
      backdrop-filter: blur(10px);
    }
    #toc .toc-title{
      font-weight:700;
      letter-spacing:.3px;
      margin: 4px 8px 10px;
      color: var(--ink);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    #toc .pill{
      font-size:.75rem;
      color: var(--muted);
      border:1px solid var(--line);
      padding:2px 8px;
      border-radius:999px;
    }
    #toc a{
      display:block;
      padding: 8px 10px;
      margin: 2px 2px;
      border-radius: 12px;
      color: var(--muted);
      border:1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      font-size: .95rem;
    }
    #toc a:hover{
      background: rgba(122,162,255,.10);
      border-color: rgba(122,162,255,.25);
      transform: translateY(-1px);
      text-decoration:none;
      color: var(--ink);
    }

    article{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px;
      overflow:hidden;
    }

    section{scroll-margin-top: 18px;}
    h2{
      margin: 18px 0 10px;
      font-size: clamp(1.2rem, 1.2vw + .9rem, 1.65rem);
    }
    h3{
      margin: 16px 0 8px;
      font-size: 1.08rem;
      color: var(--ink);
    }
    p{margin: 10px 0; color: var(--muted)}
    ul{margin: 10px 0 10px 20px; color: var(--muted)}
    li{margin: 6px 0}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr;}
      nav#toc{position:relative; top:0}
      .grid2,.grid3{grid-template-columns:1fr}
    }

    .callout{
      border:1px solid var(--line);
      background: rgba(18,28,47,.75);
      border-radius: var(--radius);
      padding: 12px 12px 10px;
    }
    .callout strong{color: var(--ink)}
    .callout.assump{border-color: rgba(105,227,192,.35)}
    .callout.keyeq{border-color: rgba(122,162,255,.35)}
    .callout.mist{border-color: rgba(255,204,102,.35)}
    .callout.final{border-color: rgba(125,255,154,.30)}
    .callout .kicker{
      display:flex; align-items:center; gap:8px;
      font-weight:800;
      letter-spacing:.35px;
      color: var(--ink);
      margin-bottom: 6px;
      font-size: .92rem;
      text-transform: uppercase;
    }
    .dot{
      width:10px; height:10px; border-radius:999px;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(122,162,255,.12);
      flex: 0 0 auto;
    }
    .dot.g{background: var(--accent2); box-shadow: 0 0 0 4px rgba(105,227,192,.12)}
    .dot.y{background: var(--warn); box-shadow: 0 0 0 4px rgba(255,204,102,.12)}
    .dot.ok{background: var(--good); box-shadow: 0 0 0 4px rgba(125,255,154,.12)}

    .eq{
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      border-radius: 14px;
      padding: 10px 12px;
      margin: 10px 0;
      display:flex;
      gap: 10px;
      align-items:flex-start;
      justify-content:space-between;
    }
    .eq pre{
      margin:0;
      white-space:pre-wrap;
      word-break:break-word;
      font-family: var(--mono);
      font-size: .95rem;
      color: var(--ink);
      line-height: 1.45;
      flex: 1 1 auto;
    }
    .btn{
      appearance:none;
      border:1px solid var(--line2);
      background: rgba(255,255,255,.06);
      color: var(--ink);
      padding: 7px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 700;
      font-size: .86rem;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      user-select:none;
      flex: 0 0 auto;
    }
    .btn:hover{
      background: rgba(122,162,255,.14);
      border-color: rgba(122,162,255,.35);
      transform: translateY(-1px);
    }
    .btn:active{transform: translateY(0px) scale(.99)}
    .btn.small{padding:6px 9px; font-size:.83rem}

    .vizWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin: 10px 0 2px;
    }
    .vizCard{
      background: rgba(18,28,47,.72);
      border:1px solid var(--line);
      border-radius: var(--radius);
      overflow:hidden;
    }
    .vizHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
    }
    .vizHead .name{
      font-weight: 800;
      letter-spacing:.2px;
    }
    .vizHead .meta{
      color: var(--faint);
      font-size:.9rem;
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
      background: radial-gradient(900px 400px at 20% 0%, rgba(122,162,255,.08), transparent 55%),
                  radial-gradient(900px 400px at 80% 0%, rgba(105,227,192,.06), transparent 55%),
                  rgba(5,8,14,.35);
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin: 10px 0 6px;
    }
    @media (max-width: 980px){
      canvas{height: 280px;}
      .controls{grid-template-columns:1fr;}
    }
    .ctrl{
      background: rgba(18,28,47,.72);
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding: 10px 12px;
    }
    .ctrl label{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      font-weight:800;
      color: var(--ink);
      margin-bottom: 6px;
    }
    .ctrl .val{
      font-family: var(--mono);
      color: var(--accent2);
      font-weight:800;
      font-size: .92rem;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .mini{
      color: var(--faint);
      font-size: .9rem;
      margin-top: 6px;
    }

    .resultRow{
      display:grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 12px;
      align-items:start;
    }
    @media (max-width: 980px){ .resultRow{grid-template-columns:1fr;} }

    .tbl{
      width:100%;
      border-collapse:collapse;
      border:1px solid var(--line);
      border-radius: 14px;
      overflow:hidden;
      background: rgba(0,0,0,.12);
    }
    .tbl th, .tbl td{
      padding: 10px 10px;
      border-bottom: 1px solid var(--line);
      text-align:left;
      vertical-align:top;
      color: var(--muted);
      font-size: .95rem;
    }
    .tbl th{
      color: var(--ink);
      background: rgba(255,255,255,.04);
      font-weight: 900;
    }
    .tbl tr:last-child td{border-bottom:none}
    .num{font-family: var(--mono); color: var(--ink)}
    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 0 18px 32px;
      color: var(--faint);
      font-size: .92rem;
    }

    @media print{
      body{background:white; color:#111}
      header, main, footer{max-width: none}
      nav#toc{display:none}
      article, .callout, .vizCard, .ctrl, .eq{box-shadow:none}
      article{border:1px solid #ddd; background:white}
      .callout{background:#fafafa}
      canvas{background:white}
      .btn{display:none}
      a{color:#111; text-decoration:underline}
    }

    /* subtle entrance */
    .fadeIn{
      animation: pop .5s ease both;
    }
    @keyframes pop{
      from{opacity:0; transform: translateY(6px)}
      to{opacity:1; transform: translateY(0)}
    }
  </style>
</head>
<body>
  <header class="fadeIn">
    <div class="title">
      <h1>8.1-1 — SPP at a Boundary Between a DPS Medium and a Lossy SNG Medium</h1>
      <div class="subtitle">
        We derive the standard surface-plasmon polariton (SPP) dispersion at a planar interface, then use a <b>small-loss expansion</b> (|ε₂″| ≪ |ε₂′|) to obtain the approximate plasmon wavelength and propagation length formulas shown in the problem statement.
      </div>
    </div>
  </header>

  <main>
    <nav id="toc" aria-label="Table of contents" class="fadeIn">
      <div class="toc-title">
        <span>Contents</span>
        <span class="pill">sticky</span>
      </div>
      <a href="#qs">Quick Summary</a>
      <a href="#p0">PART 0 — Concept Primer</a>
      <a href="#p1">PART 1 — Problem Analysis</a>
      <a href="#p2">PART 2 — Strategy &amp; Tips</a>
      <a href="#p3">PART 3 — Full Solution</a>
      <a href="#p4">PART 4 — Deeper Understanding</a>
      <a href="#p5">PART 5 — Visualization Guide</a>
    </nav>

    <article class="fadeIn">
      <section id="qs">
        <h2>Quick Summary</h2>
        <ul>
          <li><b>Topic:</b> Surface-plasmon polariton (SPP) guided along a planar interface between a <b>DPS</b> dielectric (ε₁ &gt; 0, real) and a <b>lossy SNG</b> medium (ε₂ = ε₂′ + jε₂″ with ε₂′ &lt; 0 and |ε₂″| ≪ |ε₂′|).</li>
          <li><b>Key physics idea:</b> A TM surface wave exists when the normal field components are evanescent in both media and the boundary conditions allow a bound mode.</li>
          <li><b>Governing dispersion (μ₁ = μ₂ = μ₀):</b> β = k₀ √( ε₁ ε₂ / (ε₁ + ε₂) ) for the SPP propagation constant β (complex if ε₂ is complex).</li>
          <li><b>Small-loss expansion:</b> write β = β′ + jβ″ with β″ ≪ β′ and expand in ε₂″.</li>
          <li><b>Effective bound-mode permittivity:</b> ε_b ≈ ε₁ ε₂′/(ε₁ + ε₂′) (real, for ε₂″→0).</li>
          <li><b>Plasmon “index”:</b> n_b ≈ √(ε_b/ε₀) so the plasmon wavelength is λ_SPP ≈ λ₀/n_b.</li>
          <li><b>Propagation length (1/e intensity):</b> d_b ≈ 1/(2β″) which yields the requested approximate closed form in ε₂′, ε₂″, and n_b.</li>
        </ul>
      </section>

      <section id="p0">
        <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

        <div class="grid2">
          <div class="callout">
            <div class="kicker"><span class="dot"></span>Core definitions</div>
            <ul>
              <li><b>Permittivity</b> ε (F/m): relates D = εE. Here: ε₁ is <b>real &gt; 0</b> (DPS dielectric), ε₂ = ε₂′ + jε₂″ with ε₂′ &lt; 0 (SNG-like) and ε₂″ &gt; 0 (loss).</li>
              <li><b>Permeability</b> μ (H/m): relates B = μH. Given μ₁ = μ₂ = μ₀.</li>
              <li><b>Free-space wavenumber</b> k₀ = 2π/λ₀ = ω√(ε₀μ₀) (rad/m).</li>
              <li><b>Propagation constant along the interface</b> β (rad/m): field varies as exp(jβx). If lossy, β = β′ + jβ″ with decay along x.</li>
              <li><b>Evanescent decay constants</b> κᵢ (1/m): fields vary away from the interface as exp(−κᵢ|z|). Bound SPP requires κᵢ &gt; 0 in both media.</li>
            </ul>
          </div>

          <div class="callout">
            <div class="kicker"><span class="dot g"></span>Physical meaning</div>
            <ul>
              <li><b>SPP</b> is a <b>TM-polarized</b> surface wave: E has components (Eₓ, E_z), H is transverse (H_y).</li>
              <li><b>Why ε₂′ &lt; 0 matters:</b> it allows the boundary conditions to “lock” a surface wave whose energy is concentrated near the interface.</li>
              <li><b>Loss (ε₂″):</b> makes β complex. The mode still propagates, but its amplitude (and intensity) decays along x.</li>
              <li><b>Plasmon wavelength:</b> λ_SPP = 2π/β′; the problem expresses it as λ₀/n_b with n_b ≡ β′/k₀.</li>
              <li><b>Propagation length:</b> commonly defined as the <b>1/e intensity</b> distance: d_b = 1/(2β″).</li>
            </ul>
          </div>
        </div>

        <div class="callout assump" style="margin-top:14px;">
          <div class="kicker"><span class="dot g"></span>Key laws &amp; validity</div>
          <ul>
            <li>Use <b>Maxwell’s equations</b> for time-harmonic fields with convention exp(+jωt).</li>
            <li>Assume <b>linear, homogeneous, isotropic</b> media in each half-space; planar interface; no free surface charge/current (other than what is included via complex ε).</li>
            <li>The SPP dispersion comes from solving the <b>source-free wave equation</b> with <b>evanescent</b> z-dependence and applying <b>tangential field continuity</b>.</li>
          </ul>
        </div>

        <h3>Common models/approximations (and why)</h3>
        <ul>
          <li><b>Lossy medium modeled by complex ε:</b> ε₂ = ε₂′ + jε₂″ captures absorption without explicitly tracking microscopic currents.</li>
          <li><b>Small-loss expansion</b> (|ε₂″| ≪ |ε₂′|): lets us extract simple analytic approximations for β′ and β″ (and thus λ_SPP and d_b).</li>
          <li><b>Bound-mode effective permittivity ε_b:</b> many texts interpret the SPP as if it had an “effective” permittivity ε_b giving n_b ≈ √(ε_b/ε₀).</li>
        </ul>

        <h3>Mini intuition examples</h3>
        <ul>
          <li><b>If ε₂′ → −ε₁</b> (approaching the resonance denominator ε₁ + ε₂′ → 0), the SPP becomes strongly confined and β′ can become very large (short λ_SPP), but loss sensitivity increases.</li>
          <li><b>If ε₂″ increases</b> while ε₂′ is fixed, β″ increases and the propagation length d_b decreases—your SPP dies out sooner along the interface.</li>
        </ul>

        <div class="callout mist">
          <div class="kicker"><span class="dot y"></span>What to watch for (pitfalls)</div>
          <ul>
            <li>Confusing <b>amplitude</b> decay length (1/β″) with <b>intensity</b> decay length (1/(2β″)). This problem uses the standard <b>intensity</b> definition d_b = 1/(2β″).</li>
            <li>Forgetting that when ε₂ is complex, <b>β is complex</b> and you must expand the square root consistently.</li>
            <li>Mixing <b>relative</b> and <b>absolute</b> permittivities. We keep ε in F/m; then n_b ≈ √(ε_b/ε₀).</li>
          </ul>
        </div>
      </section>

      <section id="p1">
        <h2>PART 1 — Problem Analysis (no solving yet)</h2>

        <h3>Restatement (in plain words)</h3>
        <p>
          We have a planar interface between medium 1 (DPS dielectric: μ₁ = μ₀, ε₁ real positive) and medium 2 (lossy SNG-like: μ₂ = μ₀, ε₂ = ε₂′ + jε₂″ with ε₂′ real negative and |ε₂″| ≪ |ε₂′|).
          You must <b>show</b> that, in the small-loss limit, the plasmon wavelength and propagation length can be computed using the approximate formulas:
        </p>

        <div class="callout keyeq">
          <div class="kicker"><span class="dot"></span>Target approximations to demonstrate</div>
          <div class="eq">
            <pre id="eqTargets">
n_b ≈ √(ε_b/ε0)
ε_b ≈ (ε1 ε2') / (ε1 + ε2')
d_b ≈ (λ0 / 2π) · (1 / n_b^3) · ( (ε2')^2 / (ε0 ε2'') )     (small-loss, ε2'' ≪ |ε2'|)</pre>
            <button class="btn small" data-copy="#eqTargets">Copy</button>
          </div>
        </div>

        <div class="grid2" style="margin-top:14px;">
          <div class="callout">
            <div class="kicker"><span class="dot"></span>Given</div>
            <ul>
              <li>μ₁ = μ₂ = μ₀</li>
              <li>ε₁ ∈ ℝ, ε₁ &gt; 0</li>
              <li>ε₂ = ε₂′ + jε₂″ with ε₂′ &lt; 0 and |ε₂″| ≪ |ε₂′|</li>
              <li>Free-space wavelength λ₀ (so k₀ = 2π/λ₀)</li>
            </ul>
          </div>
          <div class="callout">
            <div class="kicker"><span class="dot g"></span>Unknowns / what to prove</div>
            <ul>
              <li>Define an effective ε_b and show n_b ≈ √(ε_b/ε₀).</li>
              <li>Show ε_b ≈ ε₁ ε₂′/(ε₁ + ε₂′) in the small-loss limit.</li>
              <li>Derive d_b in the stated approximate form using β″ from a first-order expansion in ε₂″.</li>
            </ul>
          </div>
        </div>

        <h3>Relevant principles (and why they apply)</h3>
        <ul>
          <li><b>Planar guided-mode solving:</b> In each homogeneous half-space, fields satisfy the Helmholtz equation with separation into x-propagation exp(jβx) and evanescent z-dependence exp(−κ|z|).</li>
          <li><b>Boundary conditions:</b> Continuity of tangential E and H at z = 0 gives the SPP condition for TM polarization.</li>
          <li><b>Small-loss perturbation:</b> Since ε₂″ is small, β acquires a small imaginary part; first-order Taylor expansion suffices.</li>
        </ul>

        <div class="callout assump">
          <div class="kicker"><span class="dot g"></span>Assumptions (explicit)</div>
          <ul>
            <li>Time-harmonic steady state, linear media, planar interface.</li>
            <li>TM SPP mode (TE surface mode does not exist for μ₁=μ₂ and ε₁&gt;0, ε₂′&lt;0 in the standard SPP setting).</li>
            <li>Small loss: |ε₂″| ≪ |ε₂′| so β″ ≪ β′ and first-order expansion is valid.</li>
            <li>Propagation length defined for <b>intensity</b>: I(x) ∝ exp(−2β″x) ⇒ d_b = 1/(2β″).</li>
          </ul>
        </div>

        <h3>Possible approaches (compare)</h3>
        <ul>
          <li><b>Approach A (best):</b> Start from known SPP dispersion β = k₀ √(ε₁ε₂/(ε₁+ε₂)), then expand in ε₂″. <i>Pros:</i> shortest, directly targets requested formulas. <i>Cons:</i> relies on recognizing the standard dispersion.</li>
          <li><b>Approach B:</b> Re-derive dispersion from scratch (field forms + boundary conditions), then expand. <i>Pros:</i> most instructive; <i>Cons:</i> longer algebra.</li>
          <li><b>Approach C:</b> Treat loss as perturbation using ∂β/∂ε₂ and complex analysis. <i>Pros:</i> elegant; <i>Cons:</i> abstract if you’re rusty.</li>
        </ul>
        <p><b>Choice:</b> We do <b>B + A</b>: a compact “from-scratch” derivation to anchor the theory, then a clean small-loss expansion to reach the approximate formulas.</p>
      </section>

      <section id="p2">
        <h2>PART 2 — Strategy &amp; Tips (roadmap only)</h2>

        <ol style="color:var(--muted); margin-left: 20px;">
          <li><b>Set geometry &amp; field form:</b> Assume interface at z=0, propagation along x with exp(jβx), decay away from interface with κ₁, κ₂.</li>
          <li><b>Use dispersion in each medium:</b> Relate κᵢ and β via κᵢ² = β² − k₀² εᵢ/ε₀ (since μᵢ=μ₀).</li>
          <li><b>Apply TM boundary conditions:</b> Continuity of Eₓ and H_y yields the SPP condition κ₁/ε₁ + κ₂/ε₂ = 0.</li>
          <li><b>Eliminate κ₁, κ₂:</b> Solve for β to obtain β = k₀ √(ε₁ε₂/(ε₁+ε₂)).</li>
          <li><b>Introduce small loss:</b> Write ε₂ = ε₂′ + jε₂″ with |ε₂″| small.</li>
          <li><b>Expand the effective fraction:</b> Compute f(ε₂)=ε₁ε₂/(ε₁+ε₂) ≈ f′ + j f″ to first order in ε₂″.</li>
          <li><b>Expand the square root:</b> √(f′+jf″) ≈ √f′ + j f″/(2√f′).</li>
          <li><b>Identify n_b and ε_b:</b> β′ = k₀√f′, define ε_b ≡ f′ so n_b = β′/k₀ = √(ε_b/ε₀).</li>
          <li><b>Find propagation length:</b> β″ = k₀ f″/(2√f′) ⇒ d_b = 1/(2β″), then algebraically reshape to match the target formula.</li>
        </ol>

        <div class="callout mist">
          <div class="kicker"><span class="dot y"></span>Common mistakes &amp; quick tips</div>
          <ul>
            <li>Use <b>first order</b> only in ε₂″; drop terms O((ε₂″)²).</li>
            <li>When expanding √(a+jb), remember: √(a+jb) ≈ √a + j b/(2√a) if |b|≪a and a&gt;0.</li>
            <li>Propagation length: check whether your definition is <b>amplitude</b> or <b>intensity</b>. Here: intensity ⇒ d_b=1/(2β″).</li>
          </ul>
        </div>
      </section>

      <section id="p3">
        <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

        <h3>Physical intuition (before math)</h3>
        <p>
          An SPP is a surface-confined electromagnetic wave. The dielectric side (ε₁&gt;0) alone would not guide a surface mode, but the negative-permittivity side (ε₂′&lt;0) allows a special TM solution where the normal field components satisfy boundary conditions and decay away from the interface.
          If medium 2 is slightly lossy (ε₂″&gt;0 but small), the mode still exists, but it <b>attenuates along the interface</b>. So we expect:
        </p>
        <ul>
          <li>β′ real part sets the <b>plasmon wavelength</b> λ_SPP = 2π/β′ (shorter than λ₀ if β′&gt;k₀).</li>
          <li>β″ imaginary part sets the <b>propagation length</b> (shorter when ε₂″ increases).</li>
        </ul>

        <div class="callout keyeq">
          <div class="kicker"><span class="dot"></span>Geometry &amp; field convention</div>
          <p style="margin:6px 0 0;">
            Interface at <b>z=0</b>. Medium 1 occupies z&gt;0 with ε₁, medium 2 occupies z&lt;0 with ε₂.
            Propagation along +x with exp(jβx). Time dependence exp(+jωt).
          </p>
        </div>

        <h3>Step 1 — Evanescent field form and κ–β relation</h3>
        <p>
          For a bound mode, fields must decay away from the interface:
        </p>
        <div class="eq">
          <pre id="eqFieldForm">
Fields ∝ exp(jβ x) · exp(-κ1 z)      for z > 0  (medium 1)
Fields ∝ exp(jβ x) · exp(+κ2 z)     for z < 0  (medium 2; since z is negative, +κ2 z decays)
with κ1>0, κ2>0.</pre>
          <button class="btn small" data-copy="#eqFieldForm">Copy</button>
        </div>
        <p>
          In each medium (μᵢ=μ₀), the wave equation implies the transverse (z) decay constant satisfies:
        </p>
        <div class="eq">
          <pre id="eqKappaBeta">
κ_i^2 = β^2 - k0^2 (ε_i / ε0),     i = 1,2
where k0 = ω√(ε0 μ0) = 2π/λ0.</pre>
          <button class="btn small" data-copy="#eqKappaBeta">Copy</button>
        </div>
        <p>
          <b>Meaning:</b> If β is larger than the bulk wavenumber in medium i, the mode cannot radiate into that medium and instead decays evanescently (κᵢ real).
        </p>

        <h3>Step 2 — TM boundary condition that creates the SPP</h3>
        <p>
          The conventional SPP is <b>TM polarized</b> (H along y, E in x–z plane). Applying tangential field continuity at z=0 leads to the well-known TM surface-wave condition:
        </p>
        <div class="eq">
          <pre id="eqSPPCondition">
(TM SPP condition at z=0)
κ1/ε1 + κ2/ε2 = 0</pre>
          <button class="btn small" data-copy="#eqSPPCondition">Copy</button>
        </div>
        <p>
          <b>What did we do and why?</b> We used continuity of Eₓ and H_y together with Maxwell’s curl relations for TM waves, which couples κ to ε. This is the “signature” of SPP guidance: the two evanescent tails must match so the boundary conditions are satisfied.
        </p>

        <h3>Step 3 — Solve for β (standard SPP dispersion)</h3>
        <p>
          Use κ₁² and κ₂² from Step 1, and κ₁/ε₁ = −κ₂/ε₂ from Step 2. Squaring the SPP condition gives:
        </p>
        <div class="eq">
          <pre id="eqDerive1">
(κ1/ε1)^2 = (κ2/ε2)^2
⇒ κ1^2 / ε1^2 = κ2^2 / ε2^2
⇒ (β^2 - k0^2 ε1/ε0)/ε1^2 = (β^2 - k0^2 ε2/ε0)/ε2^2</pre>
          <button class="btn small" data-copy="#eqDerive1">Copy</button>
        </div>
        <p>Now solve for β² (algebra carefully):</p>
        <div class="eq">
          <pre id="eqDerive2">
Multiply by ε1^2 ε2^2:

ε2^2 (β^2 - k0^2 ε1/ε0) = ε1^2 (β^2 - k0^2 ε2/ε0)

Expand:
ε2^2 β^2 - k0^2 (ε2^2 ε1)/ε0 = ε1^2 β^2 - k0^2 (ε1^2 ε2)/ε0

Bring β^2 terms together:
(ε2^2 - ε1^2) β^2 = (k0^2/ε0)(ε2^2 ε1 - ε1^2 ε2)

Factor:
ε2^2 - ε1^2 = (ε2 - ε1)(ε2 + ε1)
ε2^2 ε1 - ε1^2 ε2 = ε1 ε2 (ε2 - ε1)

Cancel (ε2 - ε1):
β^2 = (k0^2/ε0) · [ ε1 ε2 / (ε1 + ε2) ]</pre>
          <button class="btn small" data-copy="#eqDerive2">Copy</button>
        </div>
        <p>
          Taking the principal square root (and remembering ε₂ may be complex):
        </p>
        <div class="eq">
          <pre id="eqBetaStandard">
β = k0 · √( ε1 ε2 / (ε0 (ε1 + ε2)) )

Equivalently, define ε_eff ≡ ε1 ε2 /(ε1 + ε2) (units F/m),
then β = k0 √(ε_eff/ε0).</pre>
          <button class="btn small" data-copy="#eqBetaStandard">Copy</button>
        </div>
        <p>
          <b>Interpretation:</b> the SPP behaves like a guided wave with an effective permittivity ε_eff, so its phase constant is k₀ times an “effective index” √(ε_eff/ε₀).
        </p>

        <h3>Step 4 — Small-loss expansion: ε₂ = ε₂′ + jε₂″ with |ε₂″| ≪ |ε₂′|</h3>
        <p>
          Let
          <span class="num">ε₂ = ε₂′ + jε₂″</span>
          with ε₂′&lt;0 and ε₂″&gt;0 small. Define the fraction
        </p>
        <div class="eq">
          <pre id="eqfdef">
f(ε2) ≡ ε1 ε2 /(ε1 + ε2)   (this has units of permittivity)

Then β = k0 √( f(ε2) / ε0 ).</pre>
          <button class="btn small" data-copy="#eqfdef">Copy</button>
        </div>

        <p>
          Because ε₂ is only slightly complex, f(ε₂) will also be slightly complex:
          f ≈ f′ + j f″ with f″ small.
          We compute f′ and f″ to first order in ε₂″.
        </p>

        <h3>Step 5 — Expand f(ε₂) to first order in ε₂″</h3>
        <p>
          Start from
          f(ε₂) = ε₁ ε₂ /(ε₁ + ε₂).
          Consider ε₂ = ε₂′ + jε₂″ and treat the imaginary part as a perturbation:
        </p>

        <div class="eq">
          <pre id="eqfExpandIdea">
Write ε2 = ε2' + jε2''.

To first order:
f(ε2) ≈ f(ε2') + (df/dε2)|_{ε2'} · (jε2'')</pre>
          <button class="btn small" data-copy="#eqfExpandIdea">Copy</button>
        </div>

        <p>Compute the derivative (ε₁ constant):</p>
        <div class="eq">
          <pre id="eqDerivative">
f(ε2) = ε1 ε2 /(ε1 + ε2)

df/dε2 = ε1·(ε1 + ε2) - ε1 ε2·(1)  all over (ε1 + ε2)^2
       = ε1 ε1 /(ε1 + ε2)^2
       = ε1^2 /(ε1 + ε2)^2</pre>
          <button class="btn small" data-copy="#eqDerivative">Copy</button>
        </div>

        <p>Therefore, at ε₂ ≈ ε₂′:</p>
        <div class="eq">
          <pre id="eqfParts">
f' = f(ε2') = ε1 ε2' /(ε1 + ε2')            (real)
f'' = (ε1^2 /(ε1 + ε2')^2) · ε2''           (real, positive if ε2''>0)</pre>
          <button class="btn small" data-copy="#eqfParts">Copy</button>
        </div>

        <p>
          <b>What did we do and why?</b> We Taylor-expanded the effective permittivity f(ε₂) in the small parameter ε₂″. This isolates the leading effect of material loss on the mode.
        </p>

        <h3>Step 6 — Expand the square root to get β′ and β″</h3>
        <p>
          We need √(f′ + j f″). For |f″|≪f′ (and f′&gt;0 for a bound SPP in the usual regime),
        </p>
        <div class="eq">
          <pre id="eqSqrtApprox">
√(f' + j f'') ≈ √f' + j (f''/(2√f'))</pre>
          <button class="btn small" data-copy="#eqSqrtApprox">Copy</button>
        </div>

        <p>Thus</p>
        <div class="eq">
          <pre id="eqBetaParts">
β = k0 √( (f' + j f'') / ε0 )
  ≈ k0 [ √(f'/ε0) + j (f''/(2√(f' ε0))) ]

So:
β' = k0 √(f'/ε0)
β'' = k0 · f'' / (2 √(f' ε0))</pre>
          <button class="btn small" data-copy="#eqBetaParts">Copy</button>
        </div>

        <h3>Step 7 — Identify ε_b and n_b (plasmon wavelength)</h3>
        <p>
          Define the <b>effective bound-mode permittivity</b> as the <b>real</b> (lossless) value:
        </p>
        <div class="eq">
          <pre id="eqEpsbDef">
ε_b ≡ f' = ε1 ε2' /(ε1 + ε2')</pre>
          <button class="btn small" data-copy="#eqEpsbDef">Copy</button>
        </div>

        <p>
          Then the real part of the propagation constant becomes:
        </p>
        <div class="eq">
          <pre id="eqnbDef">
β' = k0 √(ε_b/ε0)

Define n_b ≡ β'/k0  ⇒  n_b ≈ √(ε_b/ε0)</pre>
          <button class="btn small" data-copy="#eqnbDef">Copy</button>
        </div>

        <p>
          Therefore the plasmon wavelength along the interface is:
        </p>
        <div class="eq">
          <pre id="eqLambdaSPP">
λ_SPP = 2π/β' = (2π/k0)·(1/n_b) = λ0 / n_b</pre>
          <button class="btn small" data-copy="#eqLambdaSPP">Copy</button>
        </div>

        <h3>Step 8 — Propagation length d_b from β″ (and match the target formula)</h3>
        <p>
          Using the intensity definition: if the field ∝ exp(jβx) = exp(jβ′x)·exp(−β″x),
          then intensity I ∝ |field|² ∝ exp(−2β″x).
          So the <b>1/e intensity</b> length is:
        </p>
        <div class="eq">
          <pre id="eqdbDef">
d_b ≡ 1/(2β'')</pre>
          <button class="btn small" data-copy="#eqdbDef">Copy</button>
        </div>

        <p>
          From Step 6:
          β″ = k₀ f″ /(2√(f′ ε₀)).
          Substitute f″ = ε₁² ε₂″ /(ε₁+ε₂′)² and f′ = ε_b:
        </p>
        <div class="eq">
          <pre id="eqdbStart">
β'' = k0 · [ε1^2 ε2'' /(ε1 + ε2')^2] / [2 √(ε_b ε0)]

⇒ d_b = 1/(2β'')
     = 1 / { k0 · [ε1^2 ε2'' /(ε1 + ε2')^2] / [2 √(ε_b ε0)] }
     = (1/k0) · ( √(ε_b ε0) / [ε1^2 ε2'' /(ε1 + ε2')^2] )</pre>
          <button class="btn small" data-copy="#eqdbStart">Copy</button>
        </div>

        <p>
          Replace 1/k₀ by λ₀/(2π), and use n_b = √(ε_b/ε₀) ⇒ √(ε_b ε₀) = ε₀ n_b:
        </p>
        <div class="eq">
          <pre id="eqdbMid">
d_b = (λ0/2π) · ( ε0 n_b ) · ( (ε1 + ε2')^2 / (ε1^2 ε2'') )</pre>
          <button class="btn small" data-copy="#eqdbMid">Copy</button>
        </div>

        <p>
          Now use the identity from n_b² = ε_b/ε₀:
        </p>
        <div class="eq">
          <pre id="eqIdentity">
n_b^2 = ε_b/ε0 = [ε1 ε2'/(ε1 + ε2')] / ε0

⇒ (ε1 + ε2') = (ε1 ε2') / (ε0 n_b^2)</pre>
          <button class="btn small" data-copy="#eqIdentity">Copy</button>
        </div>

        <p>
          Square it and substitute into d_b:
        </p>
        <div class="eq">
          <pre id="eqdbFinalDerive">
(ε1 + ε2')^2 = (ε1^2 (ε2')^2) / (ε0^2 n_b^4)

Plug into d_b:
d_b = (λ0/2π) · (ε0 n_b) · [ (ε1^2 (ε2')^2) / (ε0^2 n_b^4) ] / (ε1^2 ε2'')

Cancel ε1^2:
d_b = (λ0/2π) · (ε0 n_b) · [ (ε2')^2 / (ε0^2 n_b^4) ] · (1/ε2'')
    = (λ0/2π) · (1/n_b^3) · [ (ε2')^2 / (ε0 ε2'') ]</pre>
          <button class="btn small" data-copy="#eqdbFinalDerive">Copy</button>
        </div>

        <div class="callout final">
          <div class="kicker"><span class="dot ok"></span>Final answer (boxed)</div>
          <div class="eq">
            <pre id="eqFinal">
Small-loss (|ε2''| ≪ |ε2'|), μ1=μ2=μ0:

ε_b ≈ (ε1 ε2')/(ε1 + ε2')
n_b ≈ √(ε_b/ε0)
λ_SPP ≈ λ0 / n_b

Propagation length (1/e intensity):
d_b ≈ (λ0 / 2π) · (1 / n_b^3) · ( (ε2')^2 / (ε0 ε2'') )</pre>
            <button class="btn" data-copy="#eqFinal">Copy</button>
          </div>
          <p style="margin:6px 0 0;">
            These match the approximate formulas requested in the problem statement.
          </p>
        </div>

        <h3>Sanity checks</h3>
        <div class="grid2">
          <div class="callout">
            <div class="kicker"><span class="dot"></span>Units / dimensions</div>
            <ul>
              <li>ε_b has units F/m, so ε_b/ε₀ is dimensionless ⇒ n_b dimensionless ✔</li>
              <li>d_b uses λ₀ (m) times a dimensionless factor times (ε₂′²/(ε₀ ε₂″)) (dimensionless) ⇒ meters ✔</li>
            </ul>
          </div>
          <div class="callout">
            <div class="kicker"><span class="dot g"></span>Limiting behavior</div>
            <ul>
              <li>As ε₂″ → 0, d_b → ∞ (lossless SPP propagates without attenuation) ✔</li>
              <li>If |ε₂′| grows large, the factor (ε₂′²/ε₂″) tends to increase d_b (less relative damping) ✔</li>
              <li>If n_b becomes large (strong confinement), d_b decreases as 1/n_b³ (confinement increases loss sensitivity) ✔</li>
            </ul>
          </div>
        </div>

        <p>
          Connection to the diagram and plots: the interface-bound mode has a phase advance along x set by β′ (thus λ_SPP), while loss in the SNG medium makes β″&gt;0, causing an exponential decay of intensity over d_b. The interactive plots below let you see how ε₂′ and ε₂″ control n_b and d_b.
        </p>
      </section>

      <section id="p4">
        <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

        <h3>Re-interpreting the final formulas</h3>
        <ul>
          <li><b>ε_b = ε₁ ε₂′/(ε₁+ε₂′):</b> this is the “effective” permittivity that sets the real phase constant. Near ε₂′ ≈ −ε₁, the denominator is small ⇒ ε_b can become large ⇒ n_b large ⇒ λ_SPP short (strong confinement).</li>
          <li><b>n_b = √(ε_b/ε₀):</b> the SPP’s in-plane phase velocity is v_p = ω/β′ = c/n_b (in this effective-index sense).</li>
          <li><b>d_b ∝ (ε₂′²)/(ε₂″ n_b³):</b> loss increases β″ linearly (through ε₂″), while confinement (large n_b) penalizes propagation strongly via 1/n_b³.</li>
        </ul>

        <h3>How parameters affect outcomes (connect to plots)</h3>
        <ul>
          <li><b>Increase ε₂″ (more loss):</b> d_b decreases roughly as 1/ε₂″ (Plot 1 changes strongly).</li>
          <li><b>Make ε₂′ more negative:</b> typically shifts n_b (and λ_SPP) via ε_b; depending on proximity to −ε₁, you may get very large n_b (Plot 2 shows sharp variation near resonance).</li>
          <li><b>Increase ε₁:</b> changes the “resonance” condition ε₂′ ≈ −ε₁ and reshapes the n_b vs ε₂′ curve.</li>
        </ul>

        <h3>Alternative derivation idea (brief)</h3>
        <p>
          Instead of re-solving boundary conditions, you can treat β as a function of ε₂ and use complex differentiation:
          β(ε₂) = k₀ √( (ε₁ ε₂)/(ε₀(ε₁+ε₂)) ).
          Then for small imaginary perturbation δε₂ = jε₂″,
          β ≈ β(ε₂′) + (dβ/dε₂)|_{ε₂′} · jε₂″.
          The imaginary part directly yields β″ and thus d_b.
        </p>

        <h3>Concept checks (self-test)</h3>
        <ul>
          <li><b>Q:</b> Why is the SPP TM and not TE here? <b>A:</b> With μ₁=μ₂, the TE surface condition would require κ₁/μ₁ + κ₂/μ₂ = 0, which can’t be satisfied with κ₁,κ₂&gt;0 and equal μ; TM works because ε can change sign.</li>
          <li><b>Q:</b> If ε₂″ doubles, what happens to d_b? <b>A:</b> d_b halves (approximately), since d_b ∝ 1/ε₂″.</li>
          <li><b>Q:</b> What does very large n_b imply physically? <b>A:</b> Strong confinement and short plasmon wavelength, but typically more sensitivity to loss (d_b drops as 1/n_b³).</li>
          <li><b>Q:</b> What does ε₂′ ≈ −ε₁ represent? <b>A:</b> The condition where ε₁+ε₂′ is near zero, producing strong field enhancement and large β′ (a resonance-like regime).</li>
        </ul>
      </section>

      <section id="p5">
        <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

        <div class="controls" aria-label="Interactive controls">
          <div class="ctrl">
            <label for="eps1">
              <span>Dielectric permittivity ε₁ᵣ (relative)</span>
              <span class="val" id="eps1Val">2.25</span>
            </label>
            <input id="eps1" type="range" min="1.0" max="6.0" step="0.01" value="2.25">
            <div class="mini">Example value for plotting. Absolute ε₁ = ε₀ ε₁ᵣ.</div>
          </div>

          <div class="ctrl">
            <label for="eps2p">
              <span>SNG real part ε₂′ᵣ (relative, negative)</span>
              <span class="val" id="eps2pVal">-10.00</span>
            </label>
            <input id="eps2p" type="range" min="-40" max="-1.10" step="0.05" value="-10">
            <div class="mini">Controls confinement: near ε₂′ᵣ ≈ −ε₁ᵣ gives large n_b.</div>
          </div>

          <div class="ctrl">
            <label for="eps2pp">
              <span>Loss ε₂″ᵣ (relative)</span>
              <span class="val" id="eps2ppVal">0.20</span>
            </label>
            <input id="eps2pp" type="range" min="0.001" max="2.0" step="0.001" value="0.20">
            <div class="mini">Controls attenuation: d_b ≈ (λ₀/2π)(ε₂′ᵣ²/(ε₂″ᵣ n_b³)).</div>
          </div>
        </div>

        <div class="resultRow" style="margin-top:10px;">
          <div class="callout">
            <div class="kicker"><span class="dot g"></span>What each canvas shows</div>
            <ul>
              <li><b>Diagram:</b> interface geometry, propagation direction (+x), evanescent decay (±z), and which medium is DPS vs lossy SNG.</li>
              <li><b>Main plot (Plot 1):</b> <b>Propagation length d_b</b> vs <b>loss ε₂″ᵣ</b> (parameter sweep). A marker shows the current slider value.</li>
              <li><b>Secondary plot (Plot 2):</b> <b>Effective index n_b</b> and <b>plasmon wavelength ratio λ_SPP/λ₀ = 1/n_b</b> vs <b>ε₂′ᵣ</b>. A marker shows the current ε₂′ᵣ slider value.</li>
            </ul>
          </div>

          <div class="callout final">
            <div class="kicker"><span class="dot ok"></span>Live computed values (example λ₀ = 633 nm)</div>
            <table class="tbl" aria-label="Live computed values table">
              <thead>
                <tr>
                  <th>Quantity</th>
                  <th>Expression</th>
                  <th>Value (from sliders)</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>ε_b (absolute)</td>
                  <td class="num">ε_b = (ε₁ ε₂′)/(ε₁+ε₂′)</td>
                  <td class="num" id="liveEpsb">—</td>
                </tr>
                <tr>
                  <td>n_b</td>
                  <td class="num">n_b = √(ε_b/ε₀)</td>
                  <td class="num" id="liveNb">—</td>
                </tr>
                <tr>
                  <td>λ_SPP</td>
                  <td class="num">λ_SPP = λ₀ / n_b</td>
                  <td class="num" id="liveLam">—</td>
                </tr>
                <tr>
                  <td>d_b</td>
                  <td class="num">d_b ≈ (λ₀/2π)(1/n_b³)(ε₂′²/(ε₀ ε₂″))</td>
                  <td class="num" id="liveDb">—</td>
                </tr>
              </tbody>
            </table>
            <div class="eq" style="margin-top:10px;">
              <pre id="eqLiveText">—</pre>
              <button class="btn" data-copy="#eqLiveText">Copy</button>
            </div>
          </div>
        </div>

        <div class="vizWrap">
          <div class="vizCard">
            <div class="vizHead">
              <div>
                <div class="name">Canvas A — Physical Setup (Diagram)</div>
                <div class="meta">Planar interface SPP, TM mode, evanescent decay</div>
              </div>
              <button class="btn small" id="btnReset">Reset example values</button>
            </div>
            <canvas id="cDiagram" aria-label="SPP interface diagram canvas"></canvas>
          </div>

          <div class="vizCard">
            <div class="vizHead">
              <div>
                <div class="name">Canvas B — Main Plot: Propagation Length vs Loss</div>
                <div class="meta">d_b(ε₂″ᵣ) sweep; marker shows current ε₂″ᵣ</div>
              </div>
              <div class="meta" id="plot1Note">—</div>
            </div>
            <canvas id="cPlot1" aria-label="Propagation length plot canvas"></canvas>
          </div>

          <div class="vizCard">
            <div class="vizHead">
              <div>
                <div class="name">Canvas C — Secondary Plot: n_b and λ_SPP/λ₀ vs ε₂′ᵣ</div>
                <div class="meta">Two curves; marker shows current ε₂′ᵣ</div>
              </div>
              <div class="meta" id="plot2Note">—</div>
            </div>
            <canvas id="cPlot2" aria-label="Index and wavelength ratio plot canvas"></canvas>
          </div>
        </div>

        <p>
          <b>Interactive controls:</b> changing ε₂″ᵣ updates d_b strongly (main plot), while changing ε₂′ᵣ reshapes ε_b and n_b (secondary plot) and also affects d_b through the 1/n_b³ factor. Changing ε₁ᵣ moves the resonance-like region near ε₂′ᵣ ≈ −ε₁ᵣ.
        </p>
      </section>
    </article>
  </main>

  <footer>
    Built as a self-contained learning article (vanilla HTML/CSS/JS). The plots use example values for visualization (λ₀=633 nm) while the final derivation remains symbolic.
  </footer>

  <script>
    // ---------- Utilities ----------
    const $ = sel => document.querySelector(sel);
    function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
    function fmt(x, digits=4){
      if (!isFinite(x)) return "—";
      const ax = Math.abs(x);
      if (ax === 0) return "0";
      if (ax >= 1e4 || ax < 1e-3) return x.toExponential(digits);
      return x.toFixed(digits);
    }
    function fmtSI(m){
      if (!isFinite(m)) return "—";
      const ax = Math.abs(m);
      if (ax >= 1) return `${fmt(m,4)} m`;
      if (ax >= 1e-3) return `${fmt(m*1e3,4)} mm`;
      if (ax >= 1e-6) return `${fmt(m*1e6,4)} µm`;
      if (ax >= 1e-9) return `${fmt(m*1e9,4)} nm`;
      return `${m.toExponential(4)} m`;
    }

    // Copy buttons
    document.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-copy]');
      if(!btn) return;
      const target = btn.getAttribute('data-copy');
      const el = document.querySelector(target);
      if(!el) return;
      const text = el.innerText.trim();
      navigator.clipboard.writeText(text).then(()=>{
        const old = btn.textContent;
        btn.textContent = "Copied!";
        btn.style.borderColor = "rgba(125,255,154,.45)";
        btn.style.background = "rgba(125,255,154,.12)";
        setTimeout(()=>{
          btn.textContent = old;
          btn.style.borderColor = "";
          btn.style.background = "";
        }, 900);
      }).catch(()=>{ /* ignore */ });
    });

    // Smooth TOC scrolling
    document.querySelectorAll('#toc a').forEach(a=>{
      a.addEventListener('click', (ev)=>{
        ev.preventDefault();
        const id = a.getAttribute('href');
        const el = document.querySelector(id);
        if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
      });
    });

    // ---------- Physics model (absolute eps with relative sliders) ----------
    const EPS0 = 8.854187817e-12; // F/m
    const LAM0 = 633e-9;          // m (example for plotting)
    const TWO_PI = Math.PI*2;

    function computeFromRel(eps1r, eps2pr, eps2ppr){
      // absolute permittivities
      const eps1 = EPS0 * eps1r;
      const eps2p = EPS0 * eps2pr;     // negative
      const eps2pp = EPS0 * eps2ppr;   // positive

      // effective bound-mode permittivity (lossless real part)
      const epsb = (eps1 * eps2p) / (eps1 + eps2p); // could be >0 for typical SPP existence region

      // guard: epsb must be positive for real nb; if not, we still compute a "formal" nb via abs
      const epsbPos = epsb > 0 ? epsb : NaN;
      const nb = epsb > 0 ? Math.sqrt(epsb / EPS0) : NaN;

      // wavelength
      const lamSPP = (isFinite(nb) && nb>0) ? (LAM0 / nb) : NaN;

      // propagation length approximation from derived formula:
      // d_b ≈ (λ0 / 2π) · (1 / n_b^3) · ( (ε2')^2 / (ε0 ε2'') )
      // in relative terms this is: d_b ≈ (λ0 / 2π) · (1 / n_b^3) · ( (ε2'r)^2 / ε2''r )
      // because ε2' = ε0 ε2'r, ε2'' = ε0 ε2''r
      const db = (isFinite(nb) && nb>0 && eps2ppr>0)
        ? (LAM0 / TWO_PI) * (1 / (nb*nb*nb)) * ((eps2pr*eps2pr) / eps2ppr)
        : NaN;

      return {eps1r, eps2pr, eps2ppr, eps1, eps2p, eps2pp, epsb, nb, lamSPP, db};
    }

    // ---------- Canvas helpers ----------
    function setupCanvas(canvas){
      const ctx = canvas.getContext('2d');
      function resize(){
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.round(rect.width * dpr);
        canvas.height = Math.round(rect.height * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      }
      const ro = new ResizeObserver(resize);
      ro.observe(canvas);
      resize();
      return {ctx, resize};
    }

    function drawAxes(ctx, W, H, opt){
      const padL = opt.padL ?? 58;
      const padR = opt.padR ?? 16;
      const padT = opt.padT ?? 34;
      const padB = opt.padB ?? 44;

      // background
      ctx.clearRect(0,0,W,H);

      // panels
      ctx.fillStyle = "rgba(0,0,0,0.18)";
      ctx.fillRect(0,0,W,H);

      // plot area
      const x0 = padL, y0 = padT;
      const x1 = W - padR, y1 = H - padB;
      const pw = x1-x0, ph = y1-y0;

      // title
      ctx.fillStyle = "rgba(232,238,252,0.95)";
      ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(opt.title ?? "", x0, 18);

      // grid/ticks
      const nx = opt.nx ?? 6;
      const ny = opt.ny ?? 5;

      ctx.lineWidth = 1;
      for(let i=0;i<=nx;i++){
        const x = x0 + (pw*i/nx);
        ctx.strokeStyle = "rgba(255,255,255,0.07)";
        ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y1); ctx.stroke();
      }
      for(let j=0;j<=ny;j++){
        const y = y0 + (ph*j/ny);
        ctx.strokeStyle = "rgba(255,255,255,0.07)";
        ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke();
      }

      // axes
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(x0,y1); ctx.lineTo(x1,y1);
      ctx.moveTo(x0,y0); ctx.lineTo(x0,y1);
      ctx.stroke();

      // axis labels
      ctx.fillStyle = "rgba(184,196,230,0.95)";
      ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(opt.xLabel ?? "", x0, H-14);

      // y label (rotated)
      ctx.save();
      ctx.translate(16, (y0+y1)/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(opt.yLabel ?? "", 0, 0);
      ctx.restore();

      return {x0,y0,x1,y1,pw,ph,padL,padR,padT,padB};
    }

    function mapX(x, xmin, xmax, x0, x1){
      return x0 + (x - xmin) / (xmax - xmin) * (x1 - x0);
    }
    function mapY(y, ymin, ymax, y0, y1){
      return y1 - (y - ymin) / (ymax - ymin) * (y1 - y0);
    }

    function drawTicks(ctx, box, xmin,xmax,ymin,ymax, nx=6, ny=5, fmtX, fmtY){
      const {x0,x1,y0,y1,pw,ph} = box;
      ctx.fillStyle = "rgba(184,196,230,0.9)";
      ctx.font = "600 11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";

      for(let i=0;i<=nx;i++){
        const x = x0 + pw*i/nx;
        const v = xmin + (xmax-xmin)*i/nx;
        ctx.strokeStyle = "rgba(255,255,255,0.22)";
        ctx.beginPath(); ctx.moveTo(x,y1); ctx.lineTo(x,y1+6); ctx.stroke();
        const t = (fmtX?fmtX(v):v.toFixed(2));
        ctx.fillText(t, x-ctx.measureText(t).width/2, y1+18);
      }
      for(let j=0;j<=ny;j++){
        const y = y0 + ph*j/ny;
        const v = ymax - (ymax-ymin)*j/ny;
        ctx.strokeStyle = "rgba(255,255,255,0.22)";
        ctx.beginPath(); ctx.moveTo(x0-6,y); ctx.lineTo(x0,y); ctx.stroke();
        const t = (fmtY?fmtY(v):v.toFixed(2));
        ctx.fillText(t, x0-10-ctx.measureText(t).width, y+4);
      }
    }

    function drawLegend(ctx, items, x, y){
      ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      let yy = y;
      items.forEach(it=>{
        ctx.strokeStyle = it.color;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(x,yy); ctx.lineTo(x+20,yy); ctx.stroke();
        ctx.fillStyle = "rgba(232,238,252,0.95)";
        ctx.fillText(it.label, x+28, yy+4);
        yy += 18;
      });
    }

    // ---------- Drawing: Diagram ----------
    const diag = setupCanvas($("#cDiagram"));
    const p1 = setupCanvas($("#cPlot1"));
    const p2 = setupCanvas($("#cPlot2"));

    function drawDiagram(model){
      const canvas = $("#cDiagram");
      const ctx = diag.ctx;
      const rect = canvas.getBoundingClientRect();
      const W = rect.width, H = rect.height;

      ctx.clearRect(0,0,W,H);
      // backdrop
      ctx.fillStyle = "rgba(0,0,0,0.18)";
      ctx.fillRect(0,0,W,H);

      // interface line
      const z0 = H*0.52;
      ctx.strokeStyle = "rgba(255,255,255,0.30)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(0,z0); ctx.lineTo(W,z0); ctx.stroke();

      // regions
      ctx.fillStyle = "rgba(122,162,255,0.10)";
      ctx.fillRect(0,0,W,z0);
      ctx.fillStyle = "rgba(105,227,192,0.08)";
      ctx.fillRect(0,z0,W,H-z0);

      // labels
      ctx.fillStyle = "rgba(232,238,252,0.95)";
      ctx.font = "800 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Medium 1 (DPS)", 14, 28);
      ctx.fillText("Medium 2 (lossy SNG)", 14, z0+28);

      ctx.font = "600 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillStyle = "rgba(232,238,252,0.92)";
      ctx.fillText(`ε1 = ε0·${model.eps1r.toFixed(2)}  (>0)`, 14, 48);
      ctx.fillText(`ε2 = ε0·(${model.eps2pr.toFixed(2)} + j${model.eps2ppr.toFixed(3)})`, 14, z0+48);
      ctx.fillText("μ1 = μ2 = μ0", 14, z0-10);

      // axes arrows
      const ox = W*0.18, oy = z0;
      ctx.strokeStyle = "rgba(255,255,255,0.34)";
      ctx.lineWidth = 2;
      // x arrow
      ctx.beginPath(); ctx.moveTo(ox,oy); ctx.lineTo(ox+120,oy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ox+120,oy); ctx.lineTo(ox+110,oy-6); ctx.lineTo(ox+110,oy+6); ctx.closePath();
      ctx.fillStyle = "rgba(255,255,255,0.34)";
      ctx.fill();
      // z arrow
      ctx.strokeStyle = "rgba(255,255,255,0.34)";
      ctx.beginPath(); ctx.moveTo(ox,oy); ctx.lineTo(ox,oy-90); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ox,oy-90); ctx.lineTo(ox-6,oy-80); ctx.lineTo(ox+6,oy-80); ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "rgba(184,196,230,0.95)";
      ctx.font = "800 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("+x (propagation)", ox+130, oy+4);
      ctx.fillText("+z", ox-18, oy-98);

      // wave along interface
      const xStart = W*0.34, xEnd = W*0.94;
      const A = 10, k = 2*Math.PI/70;
      ctx.strokeStyle = "rgba(122,162,255,0.85)";
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      for(let x=xStart; x<=xEnd; x+=2){
        const y = z0 + A*Math.sin((x-xStart)*k);
        if(x===xStart) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();

      // evanescent decay arrows
      function decayArrow(x, y, dir){
        const len = 70;
        ctx.strokeStyle = "rgba(105,227,192,0.8)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x,y);
        ctx.lineTo(x,y + dir*len);
        ctx.stroke();
        ctx.fillStyle = "rgba(105,227,192,0.8)";
        ctx.beginPath();
        ctx.moveTo(x, y + dir*len);
        ctx.lineTo(x-6, y + dir*(len-10));
        ctx.lineTo(x+6, y + dir*(len-10));
        ctx.closePath(); ctx.fill();
      }
      decayArrow(W*0.68, z0-5, -1);
      decayArrow(W*0.68, z0+5, +1);

      ctx.fillStyle = "rgba(184,196,230,0.92)";
      ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("evanescent decay", W*0.68+10, z0-62);

      // annotate beta
      ctx.fillStyle = "rgba(232,238,252,0.95)";
      ctx.font = "800 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillText(`β = β' + jβ''`, W*0.72, z0-18);
      ctx.fillText(`λSPP = λ0/n_b`, W*0.72, z0+22);
    }

    // ---------- Plot 1: d_b vs eps2''r ----------
    function drawPlot1(model){
      const canvas = $("#cPlot1");
      const ctx = p1.ctx;
      const rect = canvas.getBoundingClientRect();
      const W = rect.width, H = rect.height;

      const box = drawAxes(ctx, W, H, {
        title: "Propagation length d_b vs loss ε₂″ᵣ (example λ₀ = 633 nm)",
        xLabel: "ε₂″ᵣ (relative, dimensionless)",
        yLabel: "d_b (µm)",
        nx: 6, ny: 5
      });

      // sweep eps2''r on log-ish spread but plot in linear x for readability
      const xMin = 0.001, xMax = 2.0;

      // y range based on sweep
      let yMin = Infinity, yMax = -Infinity;
      const N = 260;
      const xs = new Array(N), ys = new Array(N);
      for(let i=0;i<N;i++){
        const x = xMin + (xMax-xMin)*i/(N-1);
        const m = computeFromRel(model.eps1r, model.eps2pr, x);
        const y = m.db; // meters
        xs[i]=x; ys[i]=y;
        if(isFinite(y)){
          yMin = Math.min(yMin, y);
          yMax = Math.max(yMax, y);
        }
      }
      // Convert to microns for axis
      yMin = isFinite(yMin) ? yMin*1e6 : 1;
      yMax = isFinite(yMax) ? yMax*1e6 : 10;
      if(yMin===yMax){ yMin *= 0.5; yMax *= 1.5; }
      // pad
      const pad = 0.08*(yMax-yMin);
      yMin = Math.max(0, yMin - pad);
      yMax = yMax + pad;

      // ticks
      drawTicks(ctx, box, xMin, xMax, yMin, yMax, 6, 5,
        v => v.toFixed(3),
        v => (v>=1000? v.toFixed(0): v.toFixed(1))
      );

      // curve
      ctx.strokeStyle = "rgba(122,162,255,0.9)";
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      for(let i=0;i<N;i++){
        const x = xs[i];
        const y = ys[i]*1e6; // µm
        if(!isFinite(y)) continue;
        const px = mapX(x, xMin, xMax, box.x0, box.x1);
        const py = mapY(y, yMin, yMax, box.y0, box.y1);
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();

      // marker at current eps2''r
      const mx = clamp(model.eps2ppr, xMin, xMax);
      const my = model.db*1e6;
      if(isFinite(my)){
        const px = mapX(mx, xMin, xMax, box.x0, box.x1);
        const py = mapY(my, yMin, yMax, box.y0, box.y1);

        ctx.fillStyle = "rgba(105,227,192,0.95)";
        ctx.beginPath(); ctx.arc(px,py,5.2,0,TWO_PI); ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,0.4)";
        ctx.lineWidth = 2;
        ctx.stroke();

        // guide lines
        ctx.strokeStyle = "rgba(105,227,192,0.25)";
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(px, box.y1); ctx.lineTo(px, py); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(box.x0, py); ctx.lineTo(px, py); ctx.stroke();

        // label
        ctx.fillStyle = "rgba(232,238,252,0.95)";
        ctx.font = "700 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
        const label = `d_b ≈ ${fmt(my,3)} µm`;
        ctx.fillText(label, clamp(px+10, box.x0+6, box.x1-ctx.measureText(label).width-6), clamp(py-10, box.y0+14, box.y1-6));
      }

      drawLegend(ctx, [
        {color:"rgba(122,162,255,0.9)", label:"d_b(ε₂″ᵣ)"},
        {color:"rgba(105,227,192,0.9)", label:"current sliders"}
      ], box.x0+10, box.y0+18);

      $("#plot1Note").textContent = `Current: ε₂″ᵣ=${model.eps2ppr.toFixed(3)} ⇒ d_b≈${fmtSI(model.db)}`;
    }

    // ---------- Plot 2: n_b and λSPP/λ0 vs eps2' r ----------
    function drawPlot2(model){
      const canvas = $("#cPlot2");
      const ctx = p2.ctx;
      const rect = canvas.getBoundingClientRect();
      const W = rect.width, H = rect.height;

      const box = drawAxes(ctx, W, H, {
        title: "Effective index n_b and wavelength ratio (λ_SPP/λ₀) vs ε₂′ᵣ",
        xLabel: "ε₂′ᵣ (relative, negative)",
        yLabel: "value (dimensionless)",
        nx: 6, ny: 5
      });

      const xMin = -40, xMax = -1.10;

      // sweep
      const N = 320;
      const xs = new Array(N), nbs = new Array(N), wr = new Array(N);
      let yMin = Infinity, yMax = -Infinity;
      for(let i=0;i<N;i++){
        const x = xMin + (xMax-xMin)*i/(N-1);
        const m = computeFromRel(model.eps1r, x, model.eps2ppr);
        xs[i]=x;
        const nb = m.nb;
        const lamRatio = (isFinite(nb) && nb>0) ? (1/nb) : NaN;
        nbs[i]=nb;
        wr[i]=lamRatio;

        // choose y-range to include both curves
        if(isFinite(nb)){
          yMin = Math.min(yMin, nb);
          yMax = Math.max(yMax, nb);
        }
        if(isFinite(lamRatio)){
          yMin = Math.min(yMin, lamRatio);
          yMax = Math.max(yMax, lamRatio);
        }
      }
      if(!isFinite(yMin) || !isFinite(yMax)){ yMin = 0; yMax = 5; }
      if(yMin===yMax){ yMin*=0.5; yMax*=1.5; }
      const pad = 0.10*(yMax-yMin);
      yMin = Math.max(0, yMin - pad);
      yMax = yMax + pad;

      // ticks
      drawTicks(ctx, box, xMin, xMax, yMin, yMax, 6, 5,
        v => v.toFixed(1),
        v => v.toFixed(2)
      );

      // n_b curve
      ctx.strokeStyle = "rgba(122,162,255,0.9)";
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      for(let i=0;i<N;i++){
        const x = xs[i];
        const y = nbs[i];
        if(!isFinite(y)) continue;
        const px = mapX(x, xMin, xMax, box.x0, box.x1);
        const py = mapY(y, yMin, yMax, box.y0, box.y1);
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();

      // wavelength ratio curve
      ctx.strokeStyle = "rgba(105,227,192,0.9)";
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      for(let i=0;i<N;i++){
        const x = xs[i];
        const y = wr[i];
        if(!isFinite(y)) continue;
        const px = mapX(x, xMin, xMax, box.x0, box.x1);
        const py = mapY(y, yMin, yMax, box.y0, box.y1);
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();

      // marker at current eps2' r
      const mx = clamp(model.eps2pr, xMin, xMax);
      const mNow = computeFromRel(model.eps1r, mx, model.eps2ppr);
      const nbNow = mNow.nb;
      const wrNow = (isFinite(nbNow) && nbNow>0) ? (1/nbNow) : NaN;

      const px = mapX(mx, xMin, xMax, box.x0, box.x1);
      // vertical line
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(px, box.y0); ctx.lineTo(px, box.y1); ctx.stroke();

      // markers for both curves at mx
      if(isFinite(nbNow)){
        const py1 = mapY(nbNow, yMin, yMax, box.y0, box.y1);
        ctx.fillStyle = "rgba(122,162,255,0.95)";
        ctx.beginPath(); ctx.arc(px,py1,5.2,0,TWO_PI); ctx.fill();
      }
      if(isFinite(wrNow)){
        const py2 = mapY(wrNow, yMin, yMax, box.y0, box.y1);
        ctx.fillStyle = "rgba(105,227,192,0.95)";
        ctx.beginPath(); ctx.arc(px,py2,5.2,0,TWO_PI); ctx.fill();
      }

      drawLegend(ctx, [
        {color:"rgba(122,162,255,0.9)", label:"n_b"},
        {color:"rgba(105,227,192,0.9)", label:"λ_SPP/λ₀ = 1/n_b"}
      ], box.x0+10, box.y0+18);

      $("#plot2Note").textContent =
        `Current: ε₂′ᵣ=${model.eps2pr.toFixed(2)} ⇒ n_b≈${fmt(model.nb,4)}; λ_SPP/λ₀≈${isFinite(model.nb)?fmt(1/model.nb,4):"—"}`;
    }

    // ---------- Live values + update ----------
    const ui = {
      eps1: $("#eps1"),
      eps2p: $("#eps2p"),
      eps2pp: $("#eps2pp"),
      eps1Val: $("#eps1Val"),
      eps2pVal: $("#eps2pVal"),
      eps2ppVal: $("#eps2ppVal"),
      liveEpsb: $("#liveEpsb"),
      liveNb: $("#liveNb"),
      liveLam: $("#liveLam"),
      liveDb: $("#liveDb"),
      eqLiveText: $("#eqLiveText"),
      btnReset: $("#btnReset")
    };

    function update(){
      const eps1r = parseFloat(ui.eps1.value);
      const eps2pr = parseFloat(ui.eps2p.value);
      const eps2ppr = parseFloat(ui.eps2pp.value);

      ui.eps1Val.textContent = eps1r.toFixed(2);
      ui.eps2pVal.textContent = eps2pr.toFixed(2);
      ui.eps2ppVal.textContent = eps2ppr.toFixed(3);

      const m = computeFromRel(eps1r, eps2pr, eps2ppr);

      // live table
      ui.liveEpsb.textContent = isFinite(m.epsb) ? `${fmt(m.epsb,4)} F/m` : "—";
      ui.liveNb.textContent   = isFinite(m.nb) ? fmt(m.nb,6) : "—";
      ui.liveLam.textContent  = isFinite(m.lamSPP) ? fmtSI(m.lamSPP) : "—";
      ui.liveDb.textContent   = isFinite(m.db) ? fmtSI(m.db) : "—";

      // live equation block (plain text for copying)
      ui.eqLiveText.textContent =
`Example (λ0 = 633 nm, absolute ε = ε0 εr):
ε1r = ${eps1r.toFixed(2)}
ε2r = ${eps2pr.toFixed(2)} + j${eps2ppr.toFixed(3)}

ε_b = (ε1 ε2')/(ε1 + ε2') = ${isFinite(m.epsb)?fmt(m.epsb,6):"—"} F/m
n_b = √(ε_b/ε0) = ${isFinite(m.nb)?fmt(m.nb,6):"—"}
λ_SPP = λ0/n_b = ${isFinite(m.lamSPP)?fmtSI(m.lamSPP):"—"}
d_b ≈ (λ0/2π)(1/n_b^3)((ε2')^2/(ε0 ε2'')) = ${isFinite(m.db)?fmtSI(m.db):"—"}`;

      // redraw canvases
      drawDiagram(m);
      drawPlot1(m);
      drawPlot2(m);
    }

    ui.eps1.addEventListener('input', update);
    ui.eps2p.addEventListener('input', update);
    ui.eps2pp.addEventListener('input', update);

    ui.btnReset.addEventListener('click', ()=>{
      ui.eps1.value = "2.25";
      ui.eps2p.value = "-10";
      ui.eps2pp.value = "0.20";
      update();
    });

    // initial render
    update();

    // ensure redraw on DPR changes / resize (some browsers)
    window.addEventListener('resize', ()=>update(), {passive:true});
  </script>
</body>
</html>
