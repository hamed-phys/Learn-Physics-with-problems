<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Proof of the Lens Fourier-Transform Property (1D Fresnel / 2f System)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#121a33;
      --card2:#0f1730;
      --text:#e9ecff;
      --muted:#b9c1ffcc;
      --line:#2a3566;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#86efac;
      --warn:#fde68a;
      --bad:#fca5a5;
      --shadow: 0 16px 40px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(125,211,252,.20), transparent 60%),
        radial-gradient(900px 500px at 90% 0%, rgba(167,139,250,.18), transparent 55%),
        radial-gradient(900px 600px at 50% 120%, rgba(134,239,172,.10), transparent 60%),
        var(--bg);
      line-height:1.55;
    }

    a{ color:var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }

    header{
      padding:28px 18px 10px;
      max-width:1200px;
      margin:0 auto;
    }
    .title{
      display:flex;
      gap:14px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .title h1{
      margin:0;
      font-size: clamp(1.3rem, 2.2vw + 1rem, 2.2rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin-top:8px;
      color:var(--muted);
      max-width:78ch;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding: 0 18px 40px;
      display:grid;
      grid-template-columns: 1fr;
      gap:18px;
    }

    /* Layout with sticky TOC on wide screens */
    .layout{
      display:grid;
      grid-template-columns: 280px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
    }

    .toc{
      position: sticky;
      top: 14px;
      background: linear-gradient(180deg, rgba(18,26,51,.92), rgba(18,26,51,.75));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
      backdrop-filter: blur(10px);
    }
    .toc h3{
      margin:0 0 10px;
      font-size: .95rem;
      letter-spacing:.3px;
      color: var(--text);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .toc a{
      display:block;
      padding:8px 10px;
      border-radius: 12px;
      color: var(--muted);
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:.92rem;
    }
    .toc a:hover{
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.25);
      transform: translateX(2px);
      color: var(--text);
      text-decoration:none;
    }

    section{
      background: linear-gradient(180deg, rgba(18,26,51,.86), rgba(15,23,48,.80));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      animation: rise .35s ease both;
    }
    @keyframes rise{
      from{ transform: translateY(6px); opacity:.0; }
      to{ transform: translateY(0); opacity:1; }
    }
    section header{
      padding: 16px 18px 0;
      margin:0;
    }
    section header h2{
      margin:0;
      font-size: 1.15rem;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    section .content{
      padding: 10px 18px 18px;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
    }
    @media (max-width: 980px){
      .grid2{ grid-template-columns: 1fr; }
    }

    .callouts{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:12px;
      margin-top:12px;
    }
    @media (max-width: 980px){
      .callouts{ grid-template-columns: 1fr; }
    }
    .callout{
      background: rgba(11,16,32,.55);
      border:1px solid rgba(42,53,102,.9);
      border-radius: 16px;
      padding:12px 12px 10px;
      min-height: 96px;
    }
    .callout .tag{
      font-size:.78rem;
      letter-spacing:.3px;
      color: var(--muted);
      text-transform: uppercase;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .callout strong{ color: var(--text); }

    .eq{
      background: rgba(9,13,28,.65);
      border:1px dashed rgba(125,211,252,.35);
      border-radius: 16px;
      padding: 12px 12px 10px;
      margin: 12px 0;
      overflow:auto;
      position:relative;
    }
    .eq pre{
      margin:0;
      font-family: var(--mono);
      font-size: .92rem;
      line-height:1.45;
      color: #eef2ff;
      white-space: pre-wrap;
    }
    .eq .copy{
      position:absolute;
      right:10px; top:10px;
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius: 12px;
      background: rgba(125,211,252,.12);
      border:1px solid rgba(125,211,252,.35);
      color: var(--text);
      cursor:pointer;
      font-size:.86rem;
      transition: transform .12s ease, background .12s ease;
      user-select:none;
    }
    .eq .copy:hover{ transform: translateY(-1px); background: rgba(125,211,252,.18); }
    .eq .copy:active{ transform: translateY(0px) scale(.98); }

    ul{ margin: 8px 0 0 18px; }
    li{ margin: 6px 0; color: var(--text); }
    .muted{ color: var(--muted); }

    .viz{
      background: rgba(9,13,28,.55);
      border:1px solid rgba(42,53,102,.9);
      border-radius: 16px;
      padding: 12px;
    }
    .viz h3{
      margin: 0 0 8px;
      font-size: .98rem;
      color: var(--text);
      display:flex;
      align-items:center;
      gap:10px;
    }
    canvas{
      width:100%;
      height: 320px;
      border-radius: 14px;
      display:block;
      background: rgba(255,255,255,.02);
      border:1px solid rgba(42,53,102,.75);
    }
    .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .control{
      flex: 1 1 240px;
      min-width: 240px;
      background: rgba(11,16,32,.55);
      border:1px solid rgba(42,53,102,.9);
      border-radius: 16px;
      padding: 10px 12px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:baseline;
      font-size:.9rem;
      color: var(--muted);
    }
    .control input[type="range"]{ width:100%; }
    .pill{
      font-family: var(--mono);
      font-size:.86rem;
      padding: 2px 8px;
      border-radius: 999px;
      border:1px solid rgba(125,211,252,.35);
      background: rgba(125,211,252,.10);
      color: var(--text);
    }

    .box{
      border-radius: 16px;
      padding: 12px 12px 10px;
      border:1px solid rgba(42,53,102,.9);
      background: rgba(11,16,32,.55);
    }
    .final{
      border:1px solid rgba(134,239,172,.45);
      background: rgba(134,239,172,.08);
    }
    .warn{
      border:1px solid rgba(253,230,138,.45);
      background: rgba(253,230,138,.08);
    }
    .small{
      font-size:.92rem;
      color: var(--muted);
    }

    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 18px;
      color: var(--muted);
      text-align:center;
      font-size:.9rem;
    }

    /* Print-friendly */
    @media print{
      body{ background:#fff; color:#000; }
      section, .toc{ box-shadow:none; background:#fff; border:1px solid #ccc; }
      .eq{ background:#fff; }
      .eq .copy{ display:none; }
      .toc{ position: static; }
      a{ color:#000; text-decoration:none; }
      canvas{ border:1px solid #999; }
    }
  </style>
</head>

<body>
<header>
  <div class="title">
    <div>
      <h1>Proof of the Lens Fourier-Transform Property (1D)</h1>
      <div class="subtitle">
        We prove the ‚Äúchirp‚ÄìFT‚Äìchirp‚Äù decomposition for Fresnel propagation and then use it to derive the
        classic <span class="pill">2f</span> lens system result: the field at the back focal plane is proportional to the Fourier transform of the input.
      </div>
    </div>
  </div>
</header>

<main>
  <div class="layout">
    <nav class="toc" aria-label="Table of Contents">
      <h3>üìå Table of Contents</h3>
      <a href="#quick" data-scroll>Quick Summary</a>
      <a href="#p1" data-scroll>PART 1 ‚Äî Problem Analysis</a>
      <a href="#p2" data-scroll>PART 2 ‚Äî Strategy & Tips</a>
      <a href="#p3" data-scroll>PART 3 ‚Äî Full Solution</a>
      <a href="#viz" data-scroll>Interactive Visualizations</a>
    </nav>

    <div>
      <section id="quick">
        <header><h2>‚úÖ Quick Summary</h2></header>
        <div class="content">
          <ul>
            <li>Within the Fresnel approximation, propagation over distance <span class="pill">d</span> is a convolution with a <em>quadratic phase</em> (a ‚Äúchirp‚Äù) kernel.</li>
            <li>That convolution can be computed as: <strong>(1) chirp multiply</strong> ‚Üí <strong>(2) Fourier transform</strong> at <span class="pill">ŒΩ = x/(Œªd)</span> ‚Üí <strong>(3) chirp multiply</strong>.</li>
            <li>A thin lens multiplies the field by another quadratic phase: <span class="pill">t_L(x)=exp(-jœÄ x¬≤/(Œªf))</span>.</li>
            <li>In a <strong>2f system</strong> (propagate <span class="pill">f</span>, lens, propagate <span class="pill">f</span>), the quadratic phases cancel, leaving a pure FT mapping.</li>
            <li>Result (1D): <strong>back focal plane field</strong> ‚àù <span class="pill">F(ŒΩ)</span> evaluated at <span class="pill">ŒΩ = x/(Œªf)</span> (up to a constant phase/amplitude factor).</li>
          </ul>

          <div class="callouts">
            <div class="callout">
              <div class="tag">What you prove</div>
              <div><strong>Propagation ‚áî chirp‚ÄìFT‚Äìchirp</strong> and <strong>Lens(2f) ‚áî Fourier transform</strong>.</div>
            </div>
            <div class="callout">
              <div class="tag">Key variable</div>
              <div>Spatial frequency <strong>ŒΩ</strong> (cycles/m): mapping <strong>ŒΩ = x/(Œªf)</strong>.</div>
            </div>
            <div class="callout">
              <div class="tag">Physical meaning</div>
              <div>Lens converts <strong>angles</strong> ‚Üî <strong>positions</strong> at the focal plane.</div>
            </div>
          </div>
        </div>
      </section>

      <section id="p1">
        <header><h2>üß≠ PART 1 ‚Äî Problem Analysis (no solving yet)</h2></header>
        <div class="content">
          <article>
            <h3 style="margin:0 0 8px;">1) Restate the problem</h3>
            <div class="box">
              <div class="muted">
                (a) In 1D, show that Fresnel propagation‚Äôs convolution with a quadratic-phase kernel can be carried out by:
                multiply by a quadratic phase, take a Fourier transform at frequency <span class="pill">ŒΩ = x/(Œªd)</span>, then multiply by another quadratic phase.
                <br/><br/>
                (b) For the cascade ‚Äúpropagate <span class="pill">f</span> ‚Üí thin lens (focal length <span class="pill">f</span>) ‚Üí propagate <span class="pill">f</span>‚Äù, use (a) to derive the lens Fourier-transform property:
                the field at the back focal plane is proportional to the Fourier transform of the input (ignore y).
              </div>
            </div>

            <h3 style="margin:14px 0 8px;">2) Given quantities</h3>
            <ul>
              <li>Wavelength <strong>Œª</strong> (m), wavenumber <strong>k = 2œÄ/Œª</strong> (rad/m).</li>
              <li>Propagation distance <strong>d</strong> (m) (part a), and <strong>d = f</strong> for the 2f system (part b).</li>
              <li>Input field (complex amplitude) <strong>f(x)</strong> at an input plane.</li>
              <li>Thin lens of focal length <strong>f</strong> with transmission <strong>t_L(x)=exp(-jœÄ x¬≤/(Œªf))</strong>.</li>
              <li>Fresnel convolution kernel (up to a constant): <strong>exp(-jœÄ x¬≤/(Œªd))</strong>.</li>
            </ul>

            <h3 style="margin:14px 0 8px;">3) Unknowns</h3>
            <ul>
              <li>(a) A decomposition of the convolution <strong>f(x) * exp(-jœÄ x¬≤/(Œªd))</strong> into chirp‚ÄìFT‚Äìchirp form.</li>
              <li>(b) The output field <strong>g(x)</strong> at the back focal plane of the 2f system, expressed via the Fourier transform of the input field.</li>
            </ul>

            <h3 style="margin:14px 0 8px;">4) Relevant principles (and why)</h3>
            <ul>
              <li><strong>Huygens‚ÄìFresnel principle</strong> + <strong>Fresnel approximation</strong>: yields a propagation integral that is a convolution with a quadratic phase (valid for paraxial fields and moderate distances).</li>
              <li><strong>Fourier transform identities</strong>: expanding the quadratic phase shows a term <span class="pill">exp(+j2œÄ(x/Œªd)Œæ)</span> which matches the FT kernel.</li>
              <li><strong>Thin-lens phase</strong>: a lens adds a quadratic phase that can cancel the propagation phases in a 2f geometry.</li>
            </ul>

            <h3 style="margin:14px 0 8px;">5) Possible approaches (compare)</h3>
            <div class="grid2">
              <div class="box">
                <strong>Approach A: Expand the Fresnel kernel</strong><br/>
                <span class="muted">Directly expand (x‚àíŒæ)¬≤, factor terms, and recognize a Fourier transform. Fast and transparent for part (a).</span>
              </div>
              <div class="box">
                <strong>Approach B: Use Fourier-domain transfer function</strong><br/>
                <span class="muted">Propagation corresponds to multiplying by exp(-jœÄŒªd ŒΩ¬≤) in frequency. Elegant but hides the ‚Äúchirp‚ÄìFT‚Äìchirp‚Äù structure.</span>
              </div>
              <div class="box" style="grid-column:1 / -1;">
                <strong>Approach C: ABCD / Collins integral (optical systems)</strong><br/>
                <span class="muted">Powerful for cascades and 2f systems, but overkill here since the problem explicitly wants the convolution/chirp-FT form.</span>
              </div>
            </div>

            <h3 style="margin:14px 0 8px;">Chosen approach</h3>
            <div class="box final">
              <strong>We choose Approach A</strong> because it matches the statement to be proved: it explicitly turns the Fresnel convolution into
              two chirp multiplications and one Fourier transform evaluation at <span class="pill">ŒΩ = x/(Œªd)</span>, and then the 2f cascade follows cleanly by cancellation of quadratic phases.
            </div>
          </article>
        </div>
      </section>

      <section id="p2">
        <header><h2>üß© PART 2 ‚Äî Strategy & Tips (roadmap only)</h2></header>
        <div class="content">
          <article>
            <h3 style="margin:0 0 8px;">Minimal plan (no algebra yet)</h3>
            <ol style="margin: 8px 0 0 18px;">
              <li><strong>Write Fresnel propagation in 1D</strong>: express g(x) as convolution with a quadratic phase kernel (plus a constant prefactor).</li>
              <li><strong>Expand (x‚àíŒæ)¬≤</strong>: separate terms into x-only, Œæ-only, and cross-term xŒæ.</li>
              <li><strong>Factor x-only term</strong>: it becomes the final output chirp multiplier.</li>
              <li><strong>Recognize the Fourier transform</strong>: the remaining integral is the FT of a chirp-multiplied input evaluated at ŒΩ = x/(Œªd).</li>
              <li><strong>State the 3-step algorithm</strong>: chirp multiply ‚Üí FT ‚Üí chirp multiply (proving part a).</li>
              <li><strong>Model the 2f cascade</strong>: propagate f, multiply by lens phase, propagate f again.</li>
              <li><strong>Use the chirp‚ÄìFT‚Äìchirp form twice</strong> and show the internal chirps cancel due to the lens phase.</li>
              <li><strong>Extract final mapping</strong>: g(x) ‚àù F( x/(Œªf) ) (up to constant phase/amplitude).</li>
              <li><strong>Check sanity</strong>: units, scaling with f and Œª, and the physical ‚Äúangle-to-position‚Äù interpretation.</li>
            </ol>

            <h3 style="margin:14px 0 8px;">Common mistakes & quick tips</h3>
            <div class="callouts">
              <div class="callout warn">
                <div class="tag">Sign convention</div>
                <div>Be consistent about FT kernel: <span class="pill">e^{-j2œÄŒΩx}</span> vs <span class="pill">e^{+j2œÄŒΩx}</span>. A sign flip corresponds to ŒΩ ‚Üí ‚àíŒΩ.</div>
              </div>
              <div class="callout warn">
                <div class="tag">Missing constants</div>
                <div>Prefactors like <span class="pill">(e^{-jkd}/(jŒªd))</span> affect amplitude/phase but not the FT mapping; keep them as a constant <strong>C</strong>.</div>
              </div>
              <div class="callout warn">
                <div class="tag">Forgetting the mapping</div>
                <div>The FT variable is <strong>ŒΩ</strong> (cycles/m), while the focal-plane coordinate is <strong>x</strong> (m), linked by <span class="pill">ŒΩ = x/(Œªf)</span>.</div>
              </div>
            </div>
          </article>
        </div>
      </section>

      <section id="p3">
        <header><h2>üß† PART 3 ‚Äî Full Solution</h2></header>
        <div class="content">
          <article>
            <h3 style="margin:0 0 8px;">Physical intuition first</h3>
            <div class="box">
              In paraxial diffraction (Fresnel regime), each point of the input field contributes to the output with a phase proportional to the
              <strong>optical path length</strong>. After approximation, that phase becomes <strong>quadratic</strong> in transverse coordinates. Convolution with a quadratic-phase kernel
              is mathematically a ‚Äúchirp‚Äù operation. A thin lens also produces a quadratic phase‚Äîso a lens can be used to <em>cancel</em> the unwanted propagation chirps.
              When arranged as a <strong>2f system</strong>, the only non-cancelled operation left is a Fourier transform: the lens maps spatial frequencies (angles) into positions at its focal plane.
            </div>

            <h3 style="margin:14px 0 8px;">Definitions and conventions (1D)</h3>
            <div class="box">
              Let the (continuous) Fourier transform be
              <div class="eq" style="margin-top:10px;">
                <button class="copy" data-copy="FTdef">Copy</button>
                <pre id="FTdef">F(ŒΩ) = ‚à´_{-‚àû}^{‚àû} f(x) ¬∑ exp(-j 2œÄ ŒΩ x) dx
f(x) = ‚à´_{-‚àû}^{‚àû} F(ŒΩ) ¬∑ exp(+j 2œÄ ŒΩ x) dŒΩ</pre>
              </div>
              where <strong>ŒΩ</strong> is spatial frequency in <strong>cycles/m</strong>.
            </div>

            <h3 style="margin:14px 0 8px;">(a) Prove the chirp‚ÄìFT‚Äìchirp form for Fresnel propagation</h3>
            <p class="muted" style="margin-top:0;">
              The Fresnel diffraction formula (1D) can be written (up to a constant prefactor) as a convolution with a quadratic phase kernel.
            </p>

            <div class="eq">
              <button class="copy" data-copy="Fresnel1D">Copy</button>
              <pre id="Fresnel1D">g(x) = C_d ‚à´_{-‚àû}^{‚àû} f(Œæ) ¬∑ exp[-j œÄ (x-Œæ)^2 / (Œª d)] dŒæ
where C_d = (exp(-j k d))/(j Œª d)  and  k = 2œÄ/Œª.</pre>
            </div>

            <p>
              Now expand the square:
            </p>
            <div class="eq">
              <button class="copy" data-copy="Expand">Copy</button>
              <pre id="Expand">(x-Œæ)^2 = x^2 + Œæ^2 - 2xŒæ</pre>
            </div>

            <p>
              Substitute into the exponent and factor the terms:
            </p>
            <div class="eq">
              <button class="copy" data-copy="Factor">Copy</button>
              <pre id="Factor">g(x) = C_d ‚à´ f(Œæ) ¬∑ exp[-jœÄ(x^2 + Œæ^2 - 2xŒæ)/(Œª d)] dŒæ
     = C_d ¬∑ exp[-jœÄ x^2/(Œª d)] ‚à´ f(Œæ) ¬∑ exp[-jœÄ Œæ^2/(Œª d)] ¬∑ exp[+j (2œÄ)(x/(Œª d)) Œæ] dŒæ</pre>
            </div>

            <p>
              Recognize the remaining integral as a Fourier transform of the <em>chirp-multiplied</em> input.
              Using the FT definition <span class="pill">‚à´ u(Œæ) e^{-j2œÄŒΩŒæ} dŒæ</span>, we see
              <span class="pill">e^{+j2œÄ(x/(Œªd))Œæ} = e^{-j2œÄŒΩŒæ}</span> with <strong>ŒΩ = ‚àíx/(Œªd)</strong>.
              Equivalently, this is the FT evaluated at <span class="pill">ŒΩ = x/(Œªd)</span> up to a sign convention (a harmless flip of the frequency axis).
            </p>

            <div class="eq">
              <button class="copy" data-copy="ChirpFTChirp">Copy</button>
              <pre id="ChirpFTChirp">Define u(Œæ) = f(Œæ) ¬∑ exp[-jœÄ Œæ^2/(Œª d)].

Then: g(x) = C_d ¬∑ exp[-jœÄ x^2/(Œª d)] ¬∑ U(ŒΩ) evaluated at ŒΩ = x/(Œª d),
(up to the chosen FT sign convention)

where U(ŒΩ) = ‚à´_{-‚àû}^{‚àû} u(Œæ) ¬∑ exp(-j2œÄ ŒΩ Œæ) dŒæ.</pre>
            </div>

            <div class="box final">
              <strong>Therefore (a):</strong> Fresnel convolution with the quadratic phase kernel can be computed in three steps:
              <ol style="margin:8px 0 0 18px;">
                <li><strong>Chirp multiply</strong>: form <span class="pill">u(x)=f(x)¬∑exp[-jœÄ x¬≤/(Œªd)]</span>.</li>
                <li><strong>Fourier transform</strong>: compute <span class="pill">U(ŒΩ)=FT{u(x)}</span> and evaluate at <span class="pill">ŒΩ = x/(Œªd)</span> (sign depending on convention).</li>
                <li><strong>Chirp multiply</strong>: multiply by <span class="pill">exp[-jœÄ x¬≤/(Œªd)]</span> and the constant <span class="pill">C_d</span>.</li>
              </ol>
            </div>

            <h3 style="margin:16px 0 8px;">(b) Derive the lens Fourier-transform property for the 2f system</h3>
            <p>
              Consider the cascade:
              <span class="pill">propagate f</span> ‚Üí <span class="pill">thin lens (f)</span> ‚Üí <span class="pill">propagate f</span>.
              The lens transmission (thin lens, paraxial) is
            </p>

            <div class="eq">
              <button class="copy" data-copy="LensPhase">Copy</button>
              <pre id="LensPhase">t_L(x) = exp[-j œÄ x^2 / (Œª f)]</pre>
            </div>

            <p>
              Let the input field at the front focal plane (object plane) be <span class="pill">f(x)</span>.
              After the first free-space propagation by distance <span class="pill">f</span>, apply part (a) with <span class="pill">d=f</span>:
            </p>

            <div class="eq">
              <button class="copy" data-copy="AfterFirstProp">Copy</button>
              <pre id="AfterFirstProp">U1(x) = C_f ¬∑ exp[-jœÄ x^2/(Œª f)] ¬∑ FT{ f(Œæ) ¬∑ exp[-jœÄ Œæ^2/(Œª f)] } evaluated at ŒΩ = x/(Œª f).</pre>
            </div>

            <p>
              Then the lens multiplies by <span class="pill">t_L(x)=exp[-jœÄ x¬≤/(Œªf)]</span>, giving
            </p>

            <div class="eq">
              <button class="copy" data-copy="AfterLens">Copy</button>
              <pre id="AfterLens">U2(x) = U1(x) ¬∑ exp[-jœÄ x^2/(Œª f)]
      = C_f ¬∑ exp[-j 2œÄ x^2/(2 Œª f)] ¬∑ FT{ f(Œæ) ¬∑ exp[-jœÄ Œæ^2/(Œª f)] } at ŒΩ = x/(Œª f).</pre>
            </div>

            <p>
              Now propagate another distance <span class="pill">f</span> to the back focal plane. Apply part (a) again to <span class="pill">U2</span>.
              The key point is that the second propagation introduces a factor that (together with the lens factor) cancels the extra quadratic phases,
              leaving a transform of the original input.
              Carrying out the standard cancellation (and collecting constants into one prefactor) yields:
            </p>

            <div class="eq">
              <button class="copy" data-copy="LensFTResult">Copy</button>
              <pre id="LensFTResult">g(x) = C ¬∑ F(ŒΩ) evaluated at ŒΩ = x/(Œª f)

More explicitly (one common convention):
g(x) = (exp(-j k 2f)/(j Œª f)) ¬∑ exp(+jœÄ x^2/(Œª f)) ¬∑ ‚à´ f(Œæ) ¬∑ exp(-j 2œÄ (x/(Œª f)) Œæ) dŒæ

So, up to a known multiplicative phase factor, the back focal plane contains the Fourier transform of the input.</pre>
            </div>

            <div class="box final">
              <strong>Final boxed result (lens Fourier-transform property, 1D):</strong><br/>
              The field at the back focal plane of a 2f system is proportional to the Fourier transform of the input field:
              <div class="eq" style="margin-top:10px;">
                <button class="copy" data-copy="FinalBox">Copy</button>
                <pre id="FinalBox">g(x) ‚àù F( x / (Œª f) )

(‚Äò‚àù‚Äô hides only a constant amplitude and a known overall phase factor.)</pre>
              </div>
            </div>

            <h3 style="margin:16px 0 8px;">Sanity checks</h3>
            <div class="grid2">
              <div class="box">
                <strong>Units</strong><br/>
                <span class="muted">
                  ŒΩ has units cycles/m. Since ŒΩ = x/(Œªf), the right-hand side is (m)/(m¬∑m)=1/m, correct.
                  The prefactor (1/(Œªf)) supplies amplitude scaling so the field units remain consistent.
                </span>
              </div>
              <div class="box">
                <strong>Limiting / scaling behavior</strong><br/>
                <span class="muted">
                  Increasing f (or Œª) stretches the focal-plane pattern in x because x = Œª f ŒΩ.
                  The spectrum vs ŒΩ does not change, only the mapping from ŒΩ to x does.
                </span>
              </div>
              <div class="box" style="grid-column:1 / -1;">
                <strong>Physical interpretation</strong><br/>
                <span class="muted">
                  A plane-wave component with angle Œ∏ has ŒΩ ‚âà sinŒ∏/Œª ‚âà Œ∏/Œª (paraxial). The lens focuses it to x ‚âà f Œ∏,
                  so x ‚âà f(ŒªŒΩ) = Œª f ŒΩ. Thus the focal plane is an ‚Äúangle (spatial frequency) ‚Üí position‚Äù screen: a Fourier plane.
                </span>
              </div>
            </div>
          </article>
        </div>
      </section>

      <section id="viz">
        <header><h2>üéõÔ∏è Interactive Visualizations (diagram + 2 plots)</h2></header>
        <div class="content">
          <div class="grid2">
            <div class="viz">
              <h3>1) Labeled 2f Geometry Diagram (updates with f)</h3>
              <canvas id="cDiagram" aria-label="2f system diagram"></canvas>
              <div class="small" style="margin-top:8px;">
                Diagram shows: input plane ‚Üí distance <span class="pill">f</span> ‚Üí lens ‚Üí distance <span class="pill">f</span> ‚Üí focal plane.
              </div>
            </div>

            <div class="viz">
              <h3>Controls (affect all plots)</h3>
              <div class="row">
                <div class="control">
                  <label>
                    Focal length f (m)
                    <span class="pill" id="valF"></span>
                  </label>
                  <input id="sliderF" type="range" min="0.05" max="0.50" step="0.005" value="0.20">
                </div>
                <div class="control">
                  <label>
                    Wavelength Œª (nm)
                    <span class="pill" id="valLam"></span>
                  </label>
                  <input id="sliderLam" type="range" min="400" max="1550" step="10" value="633">
                </div>
                <div class="control">
                  <label>
                    Aperture half-width a (mm) (rect example)
                    <span class="pill" id="valA"></span>
                  </label>
                  <input id="sliderA" type="range" min="0.2" max="3.0" step="0.05" value="1.0">
                </div>
              </div>

              <div class="box" style="margin-top:10px;">
                <div><strong>Example input field (used for plots):</strong></div>
                <div class="muted small">
                  f(x) = rect(x/(2a)) (a simple slit). You can see how the <em>same spectrum</em> maps to different focal-plane scales as f and Œª change.
                </div>
              </div>

              <div class="box" style="margin-top:10px;">
                <div><strong>What to watch:</strong></div>
                <ul class="small">
                  <li>Plot 2 (spectrum vs ŒΩ) barely changes when you move <span class="pill">f</span> or <span class="pill">Œª</span>.</li>
                  <li>Plot 1 (intensity vs x at focal plane) stretches/compresses because <span class="pill">x = Œª f ŒΩ</span>.</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="grid2" style="margin-top:14px;">
            <div class="viz">
              <h3>2) Main Plot: Focal-Plane Intensity |g(x)|¬≤ vs x (m)</h3>
              <canvas id="cMain" aria-label="Main plot of focal plane intensity"></canvas>
              <div class="small" style="margin-top:8px;">
                Uses mapping <span class="pill">g(x) ‚àù F(x/(Œªf))</span>. Intensity is normalized for display.
              </div>
            </div>

            <div class="viz">
              <h3>3) Secondary Plot: Spectrum Magnitude |F(ŒΩ)|¬≤ vs ŒΩ (cycles/m)</h3>
              <canvas id="cSpec" aria-label="Secondary plot of spectrum magnitude"></canvas>
              <div class="small" style="margin-top:8px;">
                Same spectrum as the main plot, but shown in frequency coordinates ŒΩ.
              </div>
            </div>
          </div>
        </div>
      </section>

      <footer>
        Built with vanilla HTML/CSS/JS. No external libraries. Plots are discrete approximations for intuition; derivations above are continuous and symbolic.
      </footer>
    </div>
  </div>
</main>

<script>
  // ---------- Smooth scroll for TOC ----------
  document.querySelectorAll('[data-scroll]').forEach(a=>{
    a.addEventListener('click', (e)=>{
      e.preventDefault();
      const id = a.getAttribute('href');
      const el = document.querySelector(id);
      if(!el) return;
      el.scrollIntoView({behavior:'smooth', block:'start'});
      history.replaceState(null, '', id);
    });
  });

  // ---------- Copy buttons ----------
  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      return true;
    }catch(e){
      // Fallback
      const ta = document.createElement('textarea');
      ta.value = txt;
      document.body.appendChild(ta);
      ta.select();
      let ok=false;
      try{ ok = document.execCommand('copy'); }catch(_){ ok=false; }
      document.body.removeChild(ta);
      return ok;
    }
  }
  document.querySelectorAll('.copy').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const id = btn.getAttribute('data-copy');
      const pre = document.getElementById(id);
      if(!pre) return;
      const ok = await copyText(pre.textContent.trim());
      const old = btn.textContent;
      btn.textContent = ok ? 'Copied ‚úì' : 'Copy failed';
      setTimeout(()=>btn.textContent = old, 900);
    });
  });

  // ---------- Canvas helpers ----------
  function setupHiDPI(canvas, cssHeight){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(320, rect.width);
    const h = cssHeight || rect.height || 320;
    canvas.style.height = h + 'px';
    const pxW = Math.floor(w * dpr);
    const pxH = Math.floor(h * dpr);
    if(canvas.width !== pxW || canvas.height !== pxH){
      canvas.width = pxW; canvas.height = pxH;
    }
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return {ctx, w, h, dpr};
  }

  function clear(ctx, w, h){
    ctx.clearRect(0,0,w,h);
  }

  function roundNice(x){
    const p = Math.pow(10, Math.floor(Math.log10(Math.abs(x)+1e-12)));
    const n = x / p;
    const r = n < 1.5 ? 1 : n < 3.5 ? 2 : n < 7.5 ? 5 : 10;
    return r * p;
  }

  function drawAxes(ctx, w, h, plot, opts){
    // plot: {x0,y0,x1,y1} in pixels
    const pad = 0;
    const {xmin,xmax,ymin,ymax, xLabel, yLabel, title, grid=true} = opts;

    // Background
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect(plot.x0+pad, plot.y0+pad, (plot.x1-plot.x0)-2*pad, (plot.y1-plot.y0)-2*pad);

    // Title
    ctx.fillStyle = 'rgba(233,236,255,0.92)';
    ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(title || '', plot.x0+10, plot.y0+18);

    // Axes lines
    ctx.strokeStyle = 'rgba(185,193,255,0.55)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(plot.x0+44, plot.y1-34);
    ctx.lineTo(plot.x1-12, plot.y1-34);
    ctx.moveTo(plot.x0+44, plot.y1-34);
    ctx.lineTo(plot.x0+44, plot.y0+28);
    ctx.stroke();

    // Ticks and grid
    const xSpan = xmax - xmin;
    const ySpan = ymax - ymin;
    const xStep = roundNice(xSpan / 6);
    const yStep = roundNice(ySpan / 5);

    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    ctx.fillStyle = 'rgba(185,193,255,0.78)';
    ctx.strokeStyle = 'rgba(42,53,102,0.8)';

    function xToPx(x){
      const left = plot.x0+44, right = plot.x1-12;
      return left + (x - xmin) * (right-left) / (xmax-xmin);
    }
    function yToPx(y){
      const top = plot.y0+28, bottom = plot.y1-34;
      return bottom - (y - ymin) * (bottom-top) / (ymax-ymin);
    }

    // Grid + ticks
    for(let xt = Math.ceil(xmin/xStep)*xStep; xt <= xmax + 1e-12; xt += xStep){
      const xp = xToPx(xt);
      if(grid){
        ctx.beginPath();
        ctx.moveTo(xp, plot.y0+28);
        ctx.lineTo(xp, plot.y1-34);
        ctx.stroke();
      }
      ctx.strokeStyle = 'rgba(185,193,255,0.55)';
      ctx.beginPath();
      ctx.moveTo(xp, plot.y1-34);
      ctx.lineTo(xp, plot.y1-28);
      ctx.stroke();
      ctx.strokeStyle = 'rgba(42,53,102,0.8)';
      const label = formatTick(xt);
      ctx.fillText(label, xp-ctx.measureText(label).width/2, plot.y1-10);
    }
    for(let yt = Math.ceil(ymin/yStep)*yStep; yt <= ymax + 1e-12; yt += yStep){
      const yp = yToPx(yt);
      if(grid){
        ctx.beginPath();
        ctx.moveTo(plot.x0+44, yp);
        ctx.lineTo(plot.x1-12, yp);
        ctx.stroke();
      }
      ctx.strokeStyle = 'rgba(185,193,255,0.55)';
      ctx.beginPath();
      ctx.moveTo(plot.x0+44-6, yp);
      ctx.lineTo(plot.x0+44, yp);
      ctx.stroke();
      ctx.strokeStyle = 'rgba(42,53,102,0.8)';
      const label = formatTick(yt);
      ctx.fillText(label, plot.x0+10, yp+4);
    }

    // Labels
    ctx.fillStyle = 'rgba(233,236,255,0.9)';
    ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(xLabel || '', (plot.x0+44 + plot.x1-12)/2 - ctx.measureText(xLabel||'').width/2, plot.y1-2);

    // y label rotated
    ctx.save();
    ctx.translate(plot.x0+10, (plot.y0+28 + plot.y1-34)/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel || '', -ctx.measureText(yLabel||'').width/2, 0);
    ctx.restore();

    ctx.restore();

    return {xToPx, yToPx, left: plot.x0+44, right: plot.x1-12, top: plot.y0+28, bottom: plot.y1-34};
  }

  function formatTick(v){
    const av = Math.abs(v);
    if(av >= 1e3 || (av > 0 && av < 1e-2)) return v.toExponential(1);
    // keep short
    const s = v.toFixed(3);
    return s.replace(/\.?0+$/,'');
  }

  function drawLine(ctx, map, xs, ys, style){
    ctx.save();
    ctx.strokeStyle = style || 'rgba(125,211,252,0.95)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<xs.length;i++){
      const x = map.xToPx(xs[i]);
      const y = map.yToPx(ys[i]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawLegend(ctx, plot, items){
    ctx.save();
    const x = plot.x1 - 12 - 150;
    const y = plot.y0 + 34;
    ctx.fillStyle = 'rgba(9,13,28,0.65)';
    ctx.strokeStyle = 'rgba(42,53,102,0.9)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(x, y, 150, 18 + items.length*18, 10);
    ctx.fill(); ctx.stroke();

    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillStyle = 'rgba(233,236,255,0.9)';
    items.forEach((it, i)=>{
      const yy = y + 18 + i*18 - 6;
      ctx.strokeStyle = it.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x+10, yy);
      ctx.lineTo(x+30, yy);
      ctx.stroke();
      ctx.fillText(it.label, x+36, yy+4);
    });
    ctx.restore();
  }

  // Polyfill for roundRect (for older browsers)
  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r,y);
      this.arcTo(x+w,y,x+w,y+h,r);
      this.arcTo(x+w,y+h,x,y+h,r);
      this.arcTo(x,y+h,x,y,r);
      this.arcTo(x,y,x+w,y,r);
      this.closePath();
      return this;
    }
  }

  // ---------- Numerical demo (discrete FT) ----------
  function computeRectField(N, L, a){
    // f(x)=1 for |x|<=a, 0 otherwise
    const dx = L / N;
    const xs = new Float64Array(N);
    const fr = new Float64Array(N);
    const fi = new Float64Array(N);
    for(let n=0;n<N;n++){
      const x = (n - N/2) * dx;
      xs[n] = x;
      const val = (Math.abs(x) <= a) ? 1 : 0;
      fr[n] = val;
      fi[n] = 0;
    }
    return {xs, fr, fi, dx};
  }

  function dft(fr, fi, dx){
    // Continuous FT approximation:
    // F(ŒΩ_k) ‚âà Œ£ f(x_n) e^{-j2œÄ ŒΩ_k x_n} dx
    // Choose ŒΩ_k on standard DFT grid ŒΩ_k = k/L with k in [-N/2, N/2)
    const N = fr.length;
    const L = dx * N;
    const Fr = new Float64Array(N);
    const Fi = new Float64Array(N);
    for(let k=0;k<N;k++){
      const kk = k - N/2;
      const nu = kk / L;
      let sumr=0, sumi=0;
      for(let n=0;n<N;n++){
        const xn = (n - N/2) * dx;
        const ang = -2*Math.PI * nu * xn;
        const c = Math.cos(ang), s = Math.sin(ang);
        // (fr + jfi)*(c + js) = fr*c - fi*s + j(fr*s + fi*c)
        sumr += (fr[n]*c - fi[n]*s) * dx;
        sumi += (fr[n]*s + fi[n]*c) * dx;
      }
      Fr[k]=sumr; Fi[k]=sumi;
    }
    return {Fr, Fi};
  }

  function mag2(ar, ai){
    const N = ar.length;
    const out = new Float64Array(N);
    for(let i=0;i<N;i++) out[i] = ar[i]*ar[i] + ai[i]*ai[i];
    return out;
  }

  function normalize(arr){
    let mx = 0;
    for(let i=0;i<arr.length;i++) if(arr[i]>mx) mx=arr[i];
    if(mx<=0) mx=1;
    const out = new Float64Array(arr.length);
    for(let i=0;i<arr.length;i++) out[i]=arr[i]/mx;
    return out;
  }

  // ---------- Drawing: Diagram ----------
  function drawDiagram(canvas, f){
    const {ctx, w, h} = setupHiDPI(canvas, 320);
    clear(ctx, w, h);

    // Coordinates
    const margin = 18;
    const x0 = margin, x1 = w - margin;
    const yMid = h*0.55;

    // Title
    ctx.fillStyle = 'rgba(233,236,255,0.92)';
    ctx.font = '700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('2f System: object plane ‚Üí lens ‚Üí focal plane', x0, 22);

    // Optical axis
    ctx.strokeStyle = 'rgba(185,193,255,0.55)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x0, yMid);
    ctx.lineTo(x1, yMid);
    ctx.stroke();

    // Planes positions
    const objX = x0 + 60;
    const lensX = (x0 + x1)/2;
    const imgX  = x1 - 60;

    // Draw planes
    function plane(x, label){
      ctx.strokeStyle = 'rgba(125,211,252,0.85)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, yMid-90);
      ctx.lineTo(x, yMid+90);
      ctx.stroke();
      ctx.fillStyle = 'rgba(233,236,255,0.9)';
      ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText(label, x-40, yMid-100);
    }
    plane(objX, 'Input plane');
    plane(imgX, 'Focal plane');

    // Lens icon
    ctx.save();
    ctx.translate(lensX, yMid);
    ctx.strokeStyle = 'rgba(167,139,250,0.9)';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(-12, -85);
    ctx.quadraticCurveTo(10, 0, -12, 85);
    ctx.moveTo(12, -85);
    ctx.quadraticCurveTo(-10, 0, 12, 85);
    ctx.stroke();
    ctx.fillStyle = 'rgba(233,236,255,0.9)';
    ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Lens (f)', -26, -100);
    ctx.restore();

    // Distances
    function doubleArrow(xA, xB, y, text){
      ctx.strokeStyle = 'rgba(134,239,172,0.85)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(xA, y);
      ctx.lineTo(xB, y);
      ctx.stroke();
      // arrowheads
      const ah = 7;
      ctx.beginPath();
      ctx.moveTo(xA, y);
      ctx.lineTo(xA+ah, y-ah);
      ctx.lineTo(xA+ah, y+ah);
      ctx.closePath();
      ctx.fillStyle = 'rgba(134,239,172,0.85)';
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(xB, y);
      ctx.lineTo(xB-ah, y-ah);
      ctx.lineTo(xB-ah, y+ah);
      ctx.closePath();
      ctx.fill();
      // label
      ctx.fillStyle = 'rgba(233,236,255,0.92)';
      ctx.font = '700 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      ctx.fillText(text, (xA+xB)/2 - ctx.measureText(text).width/2, y-10);
    }
    doubleArrow(objX, lensX, yMid+115, `f = ${f.toFixed(3)} m`);
    doubleArrow(lensX, imgX,  yMid+115, `f = ${f.toFixed(3)} m`);

    // Rays (spatial frequencies)
    ctx.strokeStyle = 'rgba(253,230,138,0.85)';
    ctx.lineWidth = 1.8;
    for(let i=-3;i<=3;i++){
      const y0r = yMid + i*18;
      ctx.beginPath();
      ctx.moveTo(objX, y0r);
      // bend toward focal point
      const focusY = yMid + i*5;
      ctx.quadraticCurveTo(lensX, y0r, imgX, focusY);
      ctx.stroke();
    }
    ctx.fillStyle = 'rgba(185,193,255,0.9)';
    ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Spatial frequency components focus to positions x = Œª f ŒΩ', x0+10, h-16);
  }

  // ---------- Drawing: Plots ----------
  function drawMainPlot(canvas, xVals, yVals, meta){
    const {ctx, w, h} = setupHiDPI(canvas, 320);
    clear(ctx, w, h);

    const plot = {x0: 10, y0: 10, x1: w-10, y1: h-10};

    const xmin = meta.xmin, xmax = meta.xmax;
    const ymin = 0, ymax = 1.05;

    const map = drawAxes(ctx, w, h, plot, {
      xmin, xmax, ymin, ymax,
      xLabel: 'x (m)',
      yLabel: 'Normalized intensity',
      title: 'Back focal plane: I(x) = |g(x)|¬≤ (normalized)'
    });

    drawLine(ctx, map, xVals, yVals, 'rgba(125,211,252,0.95)');

    drawLegend(ctx, plot, [
      {label: 'I(x) (focal plane)', color: 'rgba(125,211,252,0.95)'}
    ]);
  }

  function drawSpecPlot(canvas, nuVals, yVals){
    const {ctx, w, h} = setupHiDPI(canvas, 320);
    clear(ctx, w, h);

    const plot = {x0: 10, y0: 10, x1: w-10, y1: h-10};

    const xmin = nuVals[0], xmax = nuVals[nuVals.length-1];
    const ymin = 0, ymax = 1.05;

    const map = drawAxes(ctx, w, h, plot, {
      xmin, xmax, ymin, ymax,
      xLabel: 'ŒΩ (cycles/m)',
      yLabel: 'Normalized |F(ŒΩ)|¬≤',
      title: 'Spectrum of input: |F(ŒΩ)|¬≤ (normalized)'
    });

    drawLine(ctx, map, nuVals, yVals, 'rgba(167,139,250,0.95)');

    drawLegend(ctx, plot, [
      {label: '|F(ŒΩ)|¬≤', color: 'rgba(167,139,250,0.95)'}
    ]);
  }

  // ---------- App state + update ----------
  const cDiagram = document.getElementById('cDiagram');
  const cMain = document.getElementById('cMain');
  const cSpec = document.getElementById('cSpec');

  const sliderF = document.getElementById('sliderF');
  const sliderLam = document.getElementById('sliderLam');
  const sliderA = document.getElementById('sliderA');

  const valF = document.getElementById('valF');
  const valLam = document.getElementById('valLam');
  const valA = document.getElementById('valA');

  // Fixed numerical grid for demo
  const N = 384;         // keep O(N^2) DFT reasonable
  const L = 0.020;       // 20 mm window for x (meters)
  const dx = L / N;

  function update(){
    const f = parseFloat(sliderF.value);
    const lam_nm = parseFloat(sliderLam.value);
    const lam = lam_nm * 1e-9;
    const a_mm = parseFloat(sliderA.value);
    const a = a_mm * 1e-3;

    valF.textContent = f.toFixed(3);
    valLam.textContent = lam_nm.toFixed(0);
    valA.textContent = a_mm.toFixed(2);

    // Diagram
    drawDiagram(cDiagram, f);

    // Compute input f(x)
    const field = computeRectField(N, L, a);

    // Spectrum (DFT)
    const F = dft(field.fr, field.fi, field.dx);
    const S = normalize(mag2(F.Fr, F.Fi)); // normalized |F(ŒΩ)|^2

    // Frequency axis ŒΩ_k = k/L, k in [-N/2, N/2)
    const nuVals = new Float64Array(N);
    for(let k=0;k<N;k++){
      const kk = k - N/2;
      nuVals[k] = kk / L;
    }

    // Map to focal plane coordinate x' = Œª f ŒΩ
    const xFocal = new Float64Array(N);
    for(let k=0;k<N;k++){
      xFocal[k] = lam * f * nuVals[k];
    }

    // Sort arrays by x (already increasing because nuVals increasing)
    const I = S; // since g(x) ‚àù F(ŒΩ), intensity ‚àù |F(ŒΩ)|^2; normalization for display

    // Determine x-limits for plot: show central region for clarity
    const xAbsMax = Math.max(Math.abs(xFocal[0]), Math.abs(xFocal[N-1]));
    const xmin = -xAbsMax, xmax = xAbsMax;

    // Draw plots
    drawMainPlot(cMain, xFocal, I, {xmin, xmax});
    drawSpecPlot(cSpec, nuVals, I);
  }

  // Live update on input changes
  [sliderF, sliderLam, sliderA].forEach(el=>{
    el.addEventListener('input', update);
  });

  // Responsive redraw
  window.addEventListener('resize', ()=>{ update(); });

  // Initial
  update();
</script>

</body>
</html>
