<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Frequency-Shift-Free Bragg Reflector (Two-Bragg-Cell Acousto-Optic Deflector)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --panel2:#0f1730;
      --text:#e9eefc;
      --muted:#b9c3e6;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 15% 10%, rgba(125,211,252,.18), transparent 60%),
        radial-gradient(900px 600px at 85% 20%, rgba(167,139,250,.16), transparent 55%),
        radial-gradient(900px 700px at 50% 100%, rgba(52,211,153,.10), transparent 60%),
        linear-gradient(180deg, #070a14, var(--bg));
      line-height:1.55;
    }

    header{
      padding: clamp(18px, 3vw, 34px);
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(17,26,51,.85), rgba(17,26,51,.35));
      backdrop-filter: blur(10px);
      position:relative;
      overflow:hidden;
    }
    header::after{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(600px 220px at 20% 0%, rgba(125,211,252,.18), transparent 70%),
        radial-gradient(500px 220px at 80% 0%, rgba(167,139,250,.16), transparent 70%);
      pointer-events:none;
      opacity:.9;
    }
    header .wrap{
      position:relative;
      max-width:1200px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:18px;
      align-items:end;
    }
    h1{
      margin:0 0 8px 0;
      font-size: clamp(24px, 3.2vw, 40px);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      max-width:70ch;
    }
    .meta{
      justify-self:end;
      text-align:right;
      color:var(--muted);
      font-size:14px;
    }
    .meta .pill{
      display:inline-block;
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      background: rgba(255,255,255,.04);
      margin-left:8px;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding: clamp(16px, 2.6vw, 28px);
      display:grid;
      grid-template-columns: 280px 1fr;
      gap:18px;
      align-items:start;
    }

    nav#toc{
      position:sticky;
      top:14px;
      align-self:start;
      background: rgba(17,26,51,.55);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:14px 14px 10px 14px;
      backdrop-filter: blur(10px);
    }
    nav#toc h2{
      font-size:14px;
      margin:0 0 10px 0;
      color:var(--muted);
      letter-spacing:.12em;
      text-transform:uppercase;
    }
    nav#toc a{
      display:block;
      padding:8px 10px;
      margin:4px 0;
      border-radius:12px;
      color:var(--text);
      text-decoration:none;
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:14px;
    }
    nav#toc a:hover{
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.25);
      transform: translateY(-1px);
    }
    nav#toc a small{color:var(--muted)}
    .content{
      min-width:0;
    }

    section{
      background: rgba(17,26,51,.40);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: clamp(14px, 2.2vw, 22px);
      margin-bottom:18px;
      backdrop-filter: blur(10px);
    }
    section h2{
      margin:0 0 10px 0;
      font-size: clamp(18px, 2.2vw, 26px);
    }
    section h3{
      margin:18px 0 8px 0;
      font-size: clamp(16px, 1.8vw, 20px);
      color: #dbe7ff;
    }
    p{margin:10px 0; color: var(--text)}
    .muted{color:var(--muted)}
    ul{margin:10px 0 0 18px}
    li{margin:6px 0}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
      nav#toc{position:relative; top:auto}
      header .wrap{grid-template-columns:1fr}
      .meta{justify-self:start; text-align:left}
      .grid2,.grid3{grid-template-columns:1fr}
    }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      margin-top:12px;
    }
    @media (max-width: 980px){
      .callouts{grid-template-columns:1fr}
    }
    .card{
      border-radius: 14px;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      padding:12px 12px 10px 12px;
      position:relative;
      overflow:hidden;
    }
    .card::before{
      content:"";
      position:absolute;
      inset:0;
      background: radial-gradient(500px 180px at 20% 0%, rgba(125,211,252,.12), transparent 60%);
      opacity:.9;
      pointer-events:none;
    }
    .card > *{position:relative}
    .tag{
      display:inline-block;
      font-size:12px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color:var(--muted);
      margin-bottom:6px;
    }
    .card.good{border-color: rgba(52,211,153,.35)}
    .card.good::before{background: radial-gradient(500px 180px at 20% 0%, rgba(52,211,153,.14), transparent 60%)}
    .card.warn{border-color: rgba(251,191,36,.35)}
    .card.warn::before{background: radial-gradient(500px 180px at 20% 0%, rgba(251,191,36,.14), transparent 60%)}
    .card.bad{border-color: rgba(251,113,133,.35)}
    .card.bad::before{background: radial-gradient(500px 180px at 20% 0%, rgba(251,113,133,.14), transparent 60%)}

    .eq{
      margin:12px 0;
      padding:12px;
      border-radius:14px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      font-family: var(--mono);
      font-size: 14px;
      overflow:auto;
      position:relative;
    }
    .eq .copy{
      position:absolute;
      top:10px;
      right:10px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 10px;
      padding:6px 10px;
      cursor:pointer;
      font-size:12px;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .eq .copy:hover{
      transform: translateY(-1px);
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.25);
    }
    .eq code{white-space:pre}
    .kpi{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:10px;
    }
    .kpi .box{
      flex: 1 1 180px;
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px 12px;
      background: rgba(255,255,255,.04);
    }
    .kpi .box .label{color:var(--muted); font-size:12px; letter-spacing:.08em; text-transform:uppercase}
    .kpi .box .value{font-family:var(--mono); font-size:14px; margin-top:6px}
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:12px;
      align-items:end;
    }
    @media (max-width: 980px){
      .controls{grid-template-columns:1fr}
    }
    .control{
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      background: rgba(255,255,255,.04);
    }
    .control label{
      display:block;
      color:var(--muted);
      font-size:12px;
      letter-spacing:.08em;
      text-transform:uppercase;
      margin-bottom:8px;
    }
    input[type="range"]{width:100%}
    select, button{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--text);
      font-size:14px;
      outline:none;
    }
    button{
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    button:hover{
      transform: translateY(-1px);
      background: rgba(167,139,250,.10);
      border-color: rgba(167,139,250,.25);
    }

    figure{
      margin:0;
      border:1px solid var(--line);
      border-radius: var(--radius);
      overflow:hidden;
      background: rgba(0,0,0,.18);
    }
    figcaption{
      padding:10px 12px;
      color:var(--muted);
      font-size:13px;
      border-top:1px solid var(--line);
    }
    canvas{
      display:block;
      width:100%;
      height:320px;
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    }
    .canvasTall{height:360px}
    .canvasShort{height:280px}

    .final{
      border-color: rgba(125,211,252,.35);
      background: linear-gradient(180deg, rgba(125,211,252,.10), rgba(255,255,255,.03));
    }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding: 0 28px 28px 28px;
      color: var(--muted);
      font-size: 13px;
    }

    /* Print-friendly */
    @media print{
      body{background:#fff; color:#000}
      header, nav#toc{display:none}
      section{box-shadow:none; background:#fff; border:1px solid #ddd}
      .eq{background:#f7f7f7}
      canvas{display:none}
      figure{display:none}
      a{color:#000; text-decoration:none}
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div>
        <h1>Frequency-Shift-Free Bragg Reflector</h1>
        <p class="subtitle">Design an acousto-optic system that deflects a laser beam like a “mirror,” but with <strong>zero net optical frequency shift</strong>—using <strong>two Bragg cells</strong>.</p>
      </div>
      <div class="meta">
        <div>
          <span class="pill">Acousto-optics</span>
          <span class="pill">Bragg diffraction</span>
          <span class="pill">System design</span>
        </div>
        <div style="margin-top:10px" class="muted">Interactive diagram + plots included</div>
      </div>
    </div>
  </header>

  <main>
    <nav id="toc" aria-label="Table of contents">
      <h2>Contents</h2>
      <a href="#quick-summary">Quick summary <small>— result at a glance</small></a>
      <a href="#part0">PART 0 — Concept primer</a>
      <a href="#part1">PART 1 — Problem analysis</a>
      <a href="#part2">PART 2 — Strategy & tips</a>
      <a href="#part3">PART 3 — Full solution</a>
      <a href="#part4">PART 4 — Deeper understanding</a>
      <a href="#part5">PART 5 — Visualization guide</a>
    </nav>

    <div class="content">
      <section id="quick-summary">
        <h2>Quick summary</h2>
        <ul>
          <li><strong>What this is about:</strong> Using acousto-optic Bragg diffraction to steer a beam while keeping its optical frequency unchanged.</li>
          <li><strong>Key physics idea:</strong> A Bragg cell acts like a moving diffraction grating—so it <em>usually</em> Doppler-shifts the diffracted light by the acoustic drive frequency.</li>
          <li><strong>Governing geometry:</strong> Bragg condition for first order: <span class="muted">sin&nbsp;θ<sub>B</sub> = (λ f<sub>a</sub>)/(2 n v)</span> (small-angle: θ<sub>B</sub> ≈ (λ f<sub>a</sub>)/(2 n v)).</li>
          <li><strong>Deflection per cell:</strong> First-order beam is separated from the input by approximately <span class="muted">Δθ ≈ 2θ<sub>B</sub></span>.</li>
          <li><strong>Frequency shift per cell:</strong> Diffracted light shifts by <span class="muted">±f<sub>a</sub></span> (sign depends on acoustic propagation direction and diffraction order).</li>
          <li><strong>Design trick:</strong> Use <strong>two Bragg cells</strong> so the first shifts <span class="muted">+f<sub>a</sub></span> and the second shifts <span class="muted">−f<sub>a</sub></span>, while both deflect in the same direction.</li>
          <li><strong>Final result type:</strong> Symbolic system design + symbolic net shift <span class="muted">Δf<sub>net</sub> = 0</span> and net deflection <span class="muted">≈ 4θ<sub>B</sub></span> (for identical cells).</li>
        </ul>
      </section>

      <section id="part0">
        <h2>PART 0 — Concept primer</h2>

        <h3>Core definitions (symbols + units)</h3>
        <ul>
          <li><strong>Optical wavelength (in vacuum) λ:</strong> meters (m). Example: 632.8 nm for a He–Ne laser.</li>
          <li><strong>Optical frequency f<sub>0</sub>:</strong> hertz (Hz), with f<sub>0</sub> = c/λ.</li>
          <li><strong>Refractive index n:</strong> dimensionless. Optical wavelength in the medium is λ/n.</li>
          <li><strong>Acoustic frequency f<sub>a</sub>:</strong> hertz (Hz). This is the RF drive frequency of the Bragg cell.</li>
          <li><strong>Acoustic speed v:</strong> m/s in the crystal (material-dependent).</li>
          <li><strong>Acoustic wavelength Λ:</strong> meters (m), Λ = v/f<sub>a</sub>.</li>
          <li><strong>Bragg angle θ<sub>B</sub>:</strong> radians (rad). The incidence angle (inside the medium) that satisfies Bragg diffraction.</li>
        </ul>

        <h3>Physical meaning of the key quantities</h3>
        <p>
          A Bragg cell launches a traveling sound wave through a crystal. That sound wave creates a periodic refractive-index modulation—an effective
          <em>moving</em> diffraction grating with period Λ. Because the grating moves at the acoustic phase velocity, light diffracted from it experiences a
          Doppler-like frequency shift. The Bragg angle θ<sub>B</sub> is the special incidence angle where the grating scatters light efficiently into a single diffracted order.
        </p>

        <h3>Key laws/principles (and validity conditions)</h3>
        <div class="callouts">
          <div class="card good">
            <div class="tag">Key principle</div>
            <p><strong>Bragg condition (momentum matching):</strong> Efficient diffraction occurs when the optical wavevector change matches the acoustic grating wavevector.</p>
            <p class="muted">Valid in the <em>Bragg regime</em>: thick interaction region, narrow angular acceptance, essentially two-wave coupling.</p>
          </div>
          <div class="card warn">
            <div class="tag">Key principle</div>
            <p><strong>Energy exchange with a moving grating:</strong> Diffracted light frequency changes by the acoustic frequency (±f<sub>a</sub>).</p>
            <p class="muted">Sign depends on whether the light gains or loses energy to the traveling acoustic wave.</p>
          </div>
        </div>

        <h3>Common models/approximations (why we use them)</h3>
        <ul>
          <li><strong>Small-angle approximation:</strong> For typical AO deflectors, θ<sub>B</sub> is small, so sin θ<sub>B</sub> ≈ θ<sub>B</sub>. This makes design scaling transparent.</li>
          <li><strong>First-order diffraction only:</strong> In Bragg regime, most power couples between the 0th and one 1st order—simplifying frequency-shift bookkeeping.</li>
          <li><strong>Identical cells (for design clarity):</strong> Same f<sub>a</sub>, v, n, and geometry so deflections add cleanly and shifts cancel exactly.</li>
        </ul>

        <h3>Mini intuition examples</h3>
        <ul>
          <li><strong>Single Bragg cell as a “moving mirror”:</strong> It steers the beam, but because the grating moves, the diffracted beam is shifted by ±f<sub>a</sub>.</li>
          <li><strong>Two moving gratings in series:</strong> If the second grating moves the opposite way (or you choose the opposite diffraction sign), it can undo the first Doppler shift—while still steering the beam.</li>
        </ul>

        <h3>What to watch for (pitfalls)</h3>
        <ul>
          <li><strong>Mixing up deflection vs. Bragg angle:</strong> The diffracted beam is separated from the incident beam by about 2θ<sub>B</sub>, not θ<sub>B</sub>.</li>
          <li><strong>Forgetting the sign of the frequency shift:</strong> ±f<sub>a</sub> depends on acoustic propagation direction and diffraction order choice.</li>
          <li><strong>Geometry mismatch between cells:</strong> If the second cell isn’t aligned to Bragg-match the already-deflected beam, efficiency collapses.</li>
        </ul>
      </section>

      <section id="part1">
        <h2>PART 1 — Problem analysis</h2>

        <h3>Problem restatement</h3>
        <p>
          We want an acousto-optic setup that deflects an input light beam (like a reflector/beam-steerer) but produces <strong>no net optical frequency shift</strong>.
          The hint says to use <strong>two Bragg cells</strong>, so the design must combine their angular deflections while canceling their Doppler shifts.
        </p>

        <h3>Given quantities</h3>
        <ul>
          <li><strong>Given:</strong> No specific numbers are provided; we are free to design symbolically.</li>
          <li><strong>Implied:</strong> Bragg-regime operation (a “Bragg cell” typically means thick AO interaction).</li>
        </ul>

        <h3>Unknowns</h3>
        <ul>
          <li><strong>Unknown:</strong> A configuration (geometry + acoustic directions + diffraction orders) that yields <span class="muted">Δf<sub>net</sub> = 0</span> while producing a nonzero net deflection.</li>
          <li><strong>Optional design outputs:</strong> Net deflection angle in terms of λ, n, v, f<sub>a</sub>.</li>
        </ul>

        <h3>Relevant principles (and why they apply)</h3>
        <ul>
          <li><strong>Bragg diffraction geometry:</strong> Needed to relate acoustic frequency to deflection angle and to ensure high efficiency.</li>
          <li><strong>Frequency shift from traveling grating:</strong> Needed because the problem is specifically about eliminating the shift.</li>
          <li><strong>Why not Raman–Nath?</strong> Raman–Nath (thin grating) produces multiple orders and complicates frequency bookkeeping; the problem explicitly says “Bragg reflector,” pointing to Bragg regime.</li>
        </ul>

        <div class="card warn" style="margin-top:12px">
          <div class="tag">Assumptions</div>
          <ul>
            <li><strong>Bragg regime:</strong> Two-wave coupling (0th ↔ 1st order) dominates.</li>
            <li><strong>Same acoustic frequency in both cells:</strong> f<sub>a</sub> is identical so shifts can cancel exactly.</li>
            <li><strong>Small angles:</strong> sin θ ≈ θ for clean scaling (used for interpretation; not required for the cancellation argument).</li>
            <li><strong>Neglect dispersion and walk-off:</strong> We focus on geometry and frequency shift, not detailed efficiency.</li>
          </ul>
        </div>

        <h3>Possible approaches (compare briefly)</h3>
        <ul>
          <li><strong>Approach A — Frequency bookkeeping + geometry:</strong> Track ±f<sub>a</sub> shifts through two cells and choose acoustic directions/orders to cancel. <span class="muted">Fast, design-oriented, best here.</span></li>
          <li><strong>Approach B — Wavevector diagrams:</strong> Use k-vector triangles for each cell (momentum + energy) to show deflection and shift signs. <span class="muted">More rigorous, slightly longer.</span></li>
          <li><strong>Approach C — Coupled-wave theory:</strong> Solve coupled-mode equations for two stages. <span class="muted">Overkill for this design question.</span></li>
        </ul>

        <p><strong>Chosen approach:</strong> Approach A, supported by a k-vector intuition, because the problem asks for a practical design and the key is the sign of the Doppler shift.</p>
      </section>

      <section id="part2">
        <h2>PART 2 — Strategy & tips</h2>

        <ol>
          <li><strong>Identify what causes the frequency shift:</strong> Use the fact that a traveling acoustic grating shifts diffracted light by ±f<sub>a</sub>.</li>
          <li><strong>Decide how to cancel the shift:</strong> Arrange the second interaction so it produces the opposite shift (− of the first).</li>
          <li><strong>Ensure deflections add:</strong> Align the second cell so the already-deflected beam meets its Bragg condition and is diffracted in the same overall angular direction.</li>
          <li><strong>Write the Bragg angle relation:</strong> Connect f<sub>a</sub> to θ<sub>B</sub> via Λ = v/f<sub>a</sub> and the Bragg condition.</li>
          <li><strong>Compute net deflection:</strong> Add the two angular deflections (typically ≈ 2θ<sub>B</sub> per cell for first order).</li>
          <li><strong>Sanity-check:</strong> Units, limiting cases (f<sub>a</sub> → 0), and sign logic (shift cancels, angle doesn’t).</li>
        </ol>

        <div class="callouts">
          <div class="card bad">
            <div class="tag">Common mistake</div>
            <p>Using two cells with the <em>same</em> acoustic propagation direction and the same diffraction order: you get <strong>double</strong> the frequency shift instead of cancellation.</p>
          </div>
          <div class="card good">
            <div class="tag">Quick tip</div>
            <p>Think “Doppler shift”: if the first cell makes the light “climb” by +f<sub>a</sub>, make the second cell make it “descend” by −f<sub>a</sub>, while still steering the beam.</p>
          </div>
        </div>
      </section>

      <section id="part3">
        <h2>PART 3 — Full solution</h2>

        <h3>Physical intuition (before math)</h3>
        <p>
          A single Bragg cell can steer a beam efficiently, but it behaves like a moving grating—so the diffracted beam is frequency-shifted by the RF drive.
          To get a “reflector” that only changes direction, we need a second moving grating that undoes the first Doppler shift. If we choose the second cell’s
          acoustic wave to travel in the opposite direction (or equivalently choose the opposite diffraction sign), the second interaction can shift the light back
          by the same amount, while still adding angular deflection.
        </p>

        <h3>Step 1 — Bragg geometry and deflection per cell</h3>
        <p>
          Let λ be the vacuum wavelength, n the refractive index of the AO medium, v the acoustic speed, and f<sub>a</sub> the acoustic frequency.
          The acoustic wavelength is:
        </p>

        <div class="eq" data-copy="Lambda = v / f_a">
          <button class="copy" type="button">Copy</button>
          <code>Λ = v / f_a</code>
        </div>

        <p>
          In first-order Bragg diffraction (m = 1), the Bragg condition can be written (inside the medium) as:
        </p>

        <div class="eq" data-copy="sin(theta_B) = (lambda * f_a) / (2 * n * v)   (first-order Bragg, small-angle: theta_B ≈ (lambda f_a)/(2 n v))">
          <button class="copy" type="button">Copy</button>
          <code>sin(θ_B) = (λ f_a) / (2 n v)
(small-angle: θ_B ≈ (λ f_a)/(2 n v))</code>
        </div>

        <p>
          In the Bragg regime, the diffracted beam exits at an angle roughly symmetric about the grating planes, so the angular separation between the incident
          (0th order direction) and the 1st-order diffracted beam is approximately:
        </p>

        <div class="eq" data-copy="Delta_theta_cell ≈ 2 * theta_B">
          <button class="copy" type="button">Copy</button>
          <code>Δθ_cell ≈ 2 θ_B</code>
        </div>

        <p class="muted">
          Interpretation: increasing f<sub>a</sub> decreases Λ, which increases θ<sub>B</sub>, which increases deflection—this is why AO deflectors are frequency-controlled beam steerers.
        </p>

        <h3>Step 2 — Frequency shift per Bragg cell</h3>
        <p>
          A traveling acoustic wave carries energy at frequency f<sub>a</sub>. When light is diffracted, it exchanges a quantum of acoustic frequency:
        </p>

        <div class="eq" data-copy="f_out = f_in ± f_a   (sign set by acoustic propagation direction and diffraction order)">
          <button class="copy" type="button">Copy</button>
          <code>f_out = f_in ± f_a</code>
        </div>

        <p>
          The <strong>sign</strong> depends on whether the optical wavevector change corresponds to absorbing (+) or emitting (−) an acoustic phonon, which in practice is controlled by:
          (i) the direction the acoustic wave travels in the cell, and (ii) which diffracted order you select.
        </p>

        <h3>Step 3 — Two-cell design that cancels the frequency shift</h3>
        <p>
          Use <strong>two Bragg cells in series</strong>. Drive both at the same acoustic frequency f<sub>a</sub>, but make their acoustic waves propagate in <strong>opposite directions</strong>.
          Align the second cell so that the beam diffracted by the first cell enters the second cell at its Bragg angle (for that opposite acoustic direction).
        </p>

        <div class="card good" style="margin-top:12px">
          <div class="tag">Design choice</div>
          <p>
            <strong>Cell 1:</strong> Diffract into the +1 order with frequency shift <span class="muted">+f<sub>a</sub></span> and deflection <span class="muted">≈ 2θ<sub>B</sub></span>.<br/>
            <strong>Cell 2:</strong> With acoustic wave reversed, diffract the incoming beam into the corresponding first order that produces shift <span class="muted">−f<sub>a</sub></span> while deflecting in the <em>same overall angular direction</em>.
          </p>
        </div>

        <p>
          Frequency bookkeeping:
        </p>

        <div class="eq" data-copy="After cell 1: f1 = f0 + f_a
After cell 2: f2 = f1 - f_a = f0">
          <button class="copy" type="button">Copy</button>
          <code>After cell 1:  f1 = f0 + f_a
After cell 2:  f2 = f1 − f_a = f0</code>
        </div>

        <p>
          Therefore the <strong>net frequency shift is zero</strong>:
        </p>

        <div class="eq final" data-copy="Delta_f_net = f2 - f0 = 0">
          <button class="copy" type="button">Copy</button>
          <code>Δf_net = f2 − f0 = 0</code>
        </div>

        <h3>Step 4 — Net deflection angle</h3>
        <p>
          If both cells are identical and each provides a deflection of approximately 2θ<sub>B</sub> (first order), and we align them so the deflections add, then:
        </p>

        <div class="eq" data-copy="Delta_theta_net ≈ 2*theta_B + 2*theta_B = 4*theta_B">
          <button class="copy" type="button">Copy</button>
          <code>Δθ_net ≈ 4 θ_B</code>
        </div>

        <p>
          Using the small-angle Bragg relation θ<sub>B</sub> ≈ (λ f<sub>a</sub>)/(2 n v), we get a simple scaling law:
        </p>

        <div class="eq final" data-copy="Delta_theta_net ≈ 4 * (lambda f_a)/(2 n v) = (2 lambda f_a)/(n v)   (small-angle, identical cells)">
          <button class="copy" type="button">Copy</button>
          <code>Δθ_net ≈ 4 · (λ f_a)/(2 n v) = (2 λ f_a)/(n v)</code>
        </div>

        <h3>Sanity checks</h3>
        <div class="callouts">
          <div class="card">
            <div class="tag">Units</div>
            <p>
              In <span class="muted">(2 λ f<sub>a</sub>)/(n v)</span>: λ has meters, f<sub>a</sub> has 1/s, v has m/s, so the ratio is dimensionless—an angle in radians. Good.
            </p>
          </div>
          <div class="card">
            <div class="tag">Limiting cases</div>
            <p>
              If f<sub>a</sub> → 0, then θ<sub>B</sub> → 0 and the deflection vanishes—exactly what you expect if the grating disappears.
            </p>
          </div>
          <div class="card">
            <div class="tag">Sign logic</div>
            <p>
              The frequency shifts cancel because they are equal magnitude and opposite sign; the deflections add because we align the second cell to diffract the already-steered beam in the same overall direction.
            </p>
          </div>
          <div class="card">
            <div class="tag">Physical interpretation</div>
            <p>
              The pair of cells behaves like a “Bragg mirror” that changes beam direction without changing optical color—useful when frequency stability matters (e.g., interferometry).
            </p>
          </div>
        </div>

        <p>
          The diagram and plots below visualize this: the beam bends twice (angle adds), while the frequency shift returns to zero after the second cell.
        </p>

        <h3>Interactive visualization</h3>
        <div class="controls" aria-label="Interactive controls">
          <div class="control">
            <label for="fa">Acoustic frequency f<sub>a</sub> (example) — MHz</label>
            <input id="fa" type="range" min="20" max="200" step="1" value="80" />
            <div class="kpi">
              <div class="box">
                <div class="label">Current f<sub>a</sub></div>
                <div class="value" id="faReadout">80 MHz</div>
              </div>
              <div class="box">
                <div class="label">Example θ<sub>B</sub> (small-angle)</div>
                <div class="value" id="thetaBReadout">—</div>
              </div>
              <div class="box">
                <div class="label">Example Δθ<sub>net</sub> ≈ 4θ<sub>B</sub></div>
                <div class="value" id="thetaNetReadout">—</div>
              </div>
            </div>
          </div>

          <div class="control">
            <label for="mode">Two-cell configuration (frequency shift behavior)</label>
            <select id="mode">
              <option value="cancel" selected>Shift-canceling ( +f_a then −f_a )</option>
              <option value="add">Shift-adding ( +f_a then +f_a )</option>
            </select>
            <div class="kpi">
              <div class="box">
                <div class="label">Net frequency shift</div>
                <div class="value" id="dfReadout">—</div>
              </div>
              <div class="box">
                <div class="label">Example values used in plots</div>
                <div class="value" id="exampleVals">λ=632.8 nm, n=1.5, v=4000 m/s</div>
              </div>
            </div>
            <button id="reset" type="button" style="margin-top:10px">Reset to defaults</button>
          </div>
        </div>

        <div class="grid2" style="margin-top:14px">
          <figure>
            <canvas id="diagram" class="canvasTall" aria-label="Diagram of two Bragg cells and beam path"></canvas>
            <figcaption><strong>Diagram:</strong> Two Bragg cells in series. Acoustic waves are opposite so frequency shifts cancel while deflection adds.</figcaption>
          </figure>

          <figure>
            <canvas id="plot1" class="canvasTall" aria-label="Plot of net deflection angle versus acoustic frequency"></canvas>
            <figcaption><strong>Main plot:</strong> Net deflection angle Δθ<sub>net</sub> versus acoustic frequency f<sub>a</sub> (example parameters).</figcaption>
          </figure>
        </div>

        <div style="margin-top:14px">
          <figure>
            <canvas id="plot2" class="canvasShort" aria-label="Plot of net frequency shift versus acoustic frequency for two configurations"></canvas>
            <figcaption><strong>Secondary plot:</strong> Net frequency shift Δf<sub>net</sub> versus f<sub>a</sub> for shift-canceling vs shift-adding configurations.</figcaption>
          </figure>
        </div>

        <div class="eq final" data-copy="Final design: Two Bragg cells in series, driven at the same acoustic frequency f_a, with opposite acoustic propagation directions (or opposite diffraction sign in the second cell). Choose geometry so both deflections add. Result: net optical frequency shift Δf_net = 0, net deflection Δθ_net ≈ 4 θ_B ≈ (2 λ f_a)/(n v) (small-angle, identical cells).">
          <button class="copy" type="button">Copy</button>
          <code>Final design:
Two Bragg cells in series, driven at the same acoustic frequency f_a, with opposite acoustic propagation directions (or opposite diffraction sign in the second cell). Align so both deflections add.

Result:
Δf_net = 0
Δθ_net ≈ 4 θ_B ≈ (2 λ f_a)/(n v)   (small-angle, identical cells)</code>
        </div>
      </section>

      <section id="part4">
        <h2>PART 4 — Deeper understanding</h2>

        <h3>Re-interpreting the final formula</h3>
        <p>
          The net deflection scaling
          <span class="muted">Δθ<sub>net</sub> ≈ (2 λ f<sub>a</sub>)/(n v)</span>
          tells you exactly what “controls the steering”:
        </p>
        <ul>
          <li><strong>λ (wavelength):</strong> Longer wavelengths deflect more for the same acoustic frequency (bigger Bragg angle).</li>
          <li><strong>f<sub>a</sub> (RF drive):</strong> Higher RF frequency means smaller acoustic period Λ, so stronger angular steering.</li>
          <li><strong>n (index):</strong> Higher index reduces the internal Bragg angle for a given Λ.</li>
          <li><strong>v (sound speed):</strong> Faster sound means larger Λ for the same f<sub>a</sub>, reducing deflection.</li>
        </ul>

        <h3>How parameter changes show up in the plots</h3>
        <p>
          When you move the f<sub>a</sub> slider, the deflection plot rises roughly linearly (small-angle regime). Meanwhile, the frequency-shift plot depends on the configuration:
          in the shift-canceling mode it stays at zero, while in the shift-adding mode it grows as 2f<sub>a</sub>.
        </p>

        <h3>Alternative derivation idea (brief)</h3>
        <p>
          You can derive the same design using a <strong>k-vector diagram</strong> for each cell: enforce momentum conservation
          (optical wavevector changes by the acoustic grating wavevector) and energy conservation (frequency changes by ±f<sub>a</sub>).
          Choosing the second cell’s acoustic wavevector opposite flips the sign of the energy exchange while allowing the momentum change to be arranged to add deflection.
        </p>

        <h3>Concept checks (quick self-test)</h3>
        <ul>
          <li><strong>Q:</strong> Why does a single Bragg cell shift frequency? <strong>A:</strong> The grating is traveling, so diffraction involves Doppler-like energy exchange ±f<sub>a</sub>.</li>
          <li><strong>Q:</strong> What must match for high efficiency in the second cell? <strong>A:</strong> The already-deflected beam must enter at the second cell’s Bragg angle (proper alignment).</li>
          <li><strong>Q:</strong> If both cells shift by +f<sub>a</sub>, what is Δf<sub>net</sub>? <strong>A:</strong> Δf<sub>net</sub> = +2f<sub>a</sub>.</li>
          <li><strong>Q:</strong> If f<sub>a</sub> doubles (small-angle), what happens to Δθ<sub>net</sub>? <strong>A:</strong> It approximately doubles.</li>
        </ul>
      </section>

      <section id="part5">
        <h2>PART 5 — Visualization guide</h2>

        <h3>What each canvas shows</h3>
        <ul>
          <li><strong>Diagram canvas:</strong> Two rectangular Bragg cells, an input beam, and the twice-diffracted output beam. Arrows indicate opposite acoustic propagation directions.</li>
          <li><strong>Main plot (Δθ<sub>net</sub> vs f<sub>a</sub>):</strong> Uses the example parameters (shown in the control panel) and the small-angle relation to show how steering scales with RF frequency.</li>
          <li><strong>Secondary plot (Δf<sub>net</sub> vs f<sub>a</sub>):</strong> Compares shift-canceling (0) and shift-adding (2f<sub>a</sub>) configurations.</li>
        </ul>

        <h3>Interactive controls</h3>
        <ul>
          <li><strong>Acoustic frequency slider:</strong> Changes f<sub>a</sub>. You should see the beam bend more in the diagram, the deflection curve update, and the frequency-shift plot update.</li>
          <li><strong>Configuration selector:</strong> Switches between <em>shift-canceling</em> and <em>shift-adding</em>. The deflection stays the same (geometry), but Δf<sub>net</sub> changes from 0 to 2f<sub>a</sub>.</li>
        </ul>

        <p class="muted">
          Note: Numerical values are <strong>example values for plotting</strong> only; the design result (Δf<sub>net</sub> = 0 with two cells) is symbolic and general.
        </p>
      </section>
    </div>
  </main>

  <footer>
    <p>
      Built as a learning-focused mini-lecture: theory → analysis → strategy → full derivation → interpretation → visualization.
      Copy buttons provide plain-text equations for notes.
    </p>
  </footer>

  <script>
    (function(){
      // ---------- Copy buttons ----------
      function attachCopyButtons(){
        document.querySelectorAll('.eq').forEach(eq=>{
          const btn = eq.querySelector('button.copy');
          if(!btn) return;
          btn.addEventListener('click', async ()=>{
            const text = eq.getAttribute('data-copy') || eq.innerText.replace('Copy','').trim();
            try{
              await navigator.clipboard.writeText(text);
              const old = btn.textContent;
              btn.textContent = 'Copied';
              setTimeout(()=>btn.textContent = old, 900);
            }catch(e){
              // Fallback
              const ta = document.createElement('textarea');
              ta.value = text;
              document.body.appendChild(ta);
              ta.select();
              document.execCommand('copy');
              document.body.removeChild(ta);
              const old = btn.textContent;
              btn.textContent = 'Copied';
              setTimeout(()=>btn.textContent = old, 900);
            }
          });
        });
      }

      // ---------- Canvas helpers ----------
      function setupHiDPICanvas(canvas){
        const ctx = canvas.getContext('2d');
        function resize(){
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          const rect = canvas.getBoundingClientRect();
          canvas.width = Math.round(rect.width * dpr);
          canvas.height = Math.round(rect.height * dpr);
          ctx.setTransform(dpr,0,0,dpr,0,0);
          return {w: rect.width, h: rect.height, dpr};
        }
        return {ctx, resize};
      }

      function drawGrid(ctx, x0, y0, w, h, xTicks, yTicks){
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;
        for(let i=0;i<=xTicks;i++){
          const x = x0 + (w*i/xTicks);
          ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+h); ctx.stroke();
        }
        for(let j=0;j<=yTicks;j++){
          const y = y0 + (h*j/yTicks);
          ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+w,y); ctx.stroke();
        }
        ctx.restore();
      }

      function drawAxes(ctx, x0, y0, w, h){
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.35)';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(x0, y0+h);
        ctx.lineTo(x0+w, y0+h);
        ctx.moveTo(x0, y0);
        ctx.lineTo(x0, y0+h);
        ctx.stroke();
        ctx.restore();
      }

      function niceTicks(min, max, count){
        const span = max - min;
        if(span <= 0) return {step:1, start:min, end:max};
        const raw = span / count;
        const pow = Math.pow(10, Math.floor(Math.log10(raw)));
        const norm = raw / pow;
        let step;
        if(norm < 1.5) step = 1 * pow;
        else if(norm < 3) step = 2 * pow;
        else if(norm < 7) step = 5 * pow;
        else step = 10 * pow;
        const start = Math.ceil(min/step)*step;
        const end = Math.floor(max/step)*step;
        return {step, start, end};
      }

      function drawTickLabels(ctx, x0, y0, w, h, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
        ctx.save();
        ctx.fillStyle = 'rgba(233,238,252,0.92)';
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

        // Title
        ctx.font = '13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        ctx.fillText(title, x0, y0 - 10);

        // X ticks
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        const xt = niceTicks(xMin, xMax, 6);
        for(let x=xt.start; x<=xt.end+1e-12; x+=xt.step){
          const px = x0 + (x - xMin) * (w/(xMax-xMin));
          ctx.strokeStyle = 'rgba(255,255,255,0.35)';
          ctx.beginPath();
          ctx.moveTo(px, y0+h);
          ctx.lineTo(px, y0+h+5);
          ctx.stroke();
          const s = (Math.abs(x) >= 1000) ? x.toFixed(0) : x.toFixed(0);
          ctx.fillStyle = 'rgba(185,195,230,0.95)';
          ctx.fillText(s, px-8, y0+h+18);
        }

        // Y ticks
        const yt = niceTicks(yMin, yMax, 5);
        for(let y=yt.start; y<=yt.end+1e-12; y+=yt.step){
          const py = y0 + h - (y - yMin) * (h/(yMax-yMin));
          ctx.strokeStyle = 'rgba(255,255,255,0.35)';
          ctx.beginPath();
          ctx.moveTo(x0-5, py);
          ctx.lineTo(x0, py);
          ctx.stroke();
          const s = (Math.abs(y) < 1e-6) ? '0' : (Math.abs(y) < 10 ? y.toFixed(2) : y.toFixed(0));
          ctx.fillStyle = 'rgba(185,195,230,0.95)';
          ctx.fillText(s, x0-48, py+4);
        }

        // Axis labels
        ctx.fillStyle = 'rgba(233,238,252,0.92)';
        ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        ctx.fillText(xLabel, x0 + w - ctx.measureText(xLabel).width, y0 + h + 38);

        ctx.save();
        ctx.translate(x0 - 62, y0 + 10);
        ctx.rotate(-Math.PI/2);
        ctx.fillText(yLabel, 0, 0);
        ctx.restore();

        ctx.restore();
      }

      function drawLegend(ctx, x, y, items){
        ctx.save();
        ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        const pad = 10;
        const lineH = 18;
        const w = Math.max(...items.map(it=>ctx.measureText(it.label).width)) + 44;
        const h = items.length*lineH + pad*2;
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.roundRect(x, y, w, h, 10);
        ctx.fill();
        ctx.stroke();

        items.forEach((it, i)=>{
          const yy = y + pad + i*lineH + 12;
          ctx.strokeStyle = it.color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(x+12, yy-4);
          ctx.lineTo(x+30, yy-4);
          ctx.stroke();
          ctx.fillStyle = 'rgba(233,238,252,0.92)';
          ctx.fillText(it.label, x+36, yy);
        });
        ctx.restore();
      }

      // Polyfill for roundRect if needed
      if(!CanvasRenderingContext2D.prototype.roundRect){
        CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
          r = Math.min(r, w/2, h/2);
          this.beginPath();
          this.moveTo(x+r, y);
          this.arcTo(x+w, y, x+w, y+h, r);
          this.arcTo(x+w, y+h, x, y+h, r);
          this.arcTo(x, y+h, x, y, r);
          this.arcTo(x, y, x+w, y, r);
          this.closePath();
          return this;
        };
      }

      // ---------- Physics model (example values for plotting) ----------
      const params = {
        lambda: 632.8e-9, // m (example)
        n: 1.5,           // example
        v: 4000,          // m/s (example)
        faMHz: 80,        // MHz
        mode: 'cancel'    // cancel or add
      };

      function thetaB_small(faHz){
        // θB ≈ (λ fa)/(2 n v)
        return (params.lambda * faHz) / (2 * params.n * params.v);
      }

      function deg(rad){ return rad * 180/Math.PI; }
      function mrad(rad){ return rad * 1e3; }

      // ---------- Diagram ----------
      const diagram = setupHiDPICanvas(document.getElementById('diagram'));
      function drawDiagram(){
        const {ctx, resize} = diagram;
        const {w, h} = resize();
        ctx.clearRect(0,0,w,h);

        // Background glow
        const g = ctx.createRadialGradient(w*0.2, h*0.2, 10, w*0.2, h*0.2, Math.max(w,h));
        g.addColorStop(0, 'rgba(125,211,252,0.10)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.fillRect(0,0,w,h);

        // Layout
        const pad = 18;
        const cellW = w*0.26;
        const cellH = h*0.55;
        const yCell = h*0.22;
        const x1 = w*0.18;
        const x2 = w*0.56;

        // Title
        ctx.fillStyle = 'rgba(233,238,252,0.92)';
        ctx.font = '13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        ctx.fillText('Two-Bragg-cell frequency-shift-free deflector (conceptual)', pad, 18);

        // Cells
        function drawCell(x, label, acousticDir){
          ctx.save();
          ctx.fillStyle = 'rgba(255,255,255,0.05)';
          ctx.strokeStyle = 'rgba(255,255,255,0.14)';
          ctx.lineWidth = 1.2;
          ctx.roundRect(x, yCell, cellW, cellH, 14);
          ctx.fill();
          ctx.stroke();

          // Label
          ctx.fillStyle = 'rgba(185,195,230,0.95)';
          ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
          ctx.fillText(label, x+12, yCell+20);

          // Acoustic arrow
          const ax0 = x + 18;
          const ay = yCell + cellH - 22;
          const ax1 = x + cellW - 18;
          ctx.strokeStyle = acousticDir > 0 ? 'rgba(125,211,252,0.9)' : 'rgba(167,139,250,0.9)';
          ctx.lineWidth = 2.2;
          ctx.beginPath();
          if(acousticDir > 0){
            ctx.moveTo(ax0, ay); ctx.lineTo(ax1, ay);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(ax1, ay); ctx.lineTo(ax1-10, ay-6);
            ctx.lineTo(ax1-10, ay+6);
            ctx.closePath();
            ctx.fillStyle = ctx.strokeStyle;
            ctx.fill();
          }else{
            ctx.moveTo(ax1, ay); ctx.lineTo(ax0, ay);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(ax0, ay); ctx.lineTo(ax0+10, ay-6);
            ctx.lineTo(ax0+10, ay+6);
            ctx.closePath();
            ctx.fillStyle = ctx.strokeStyle;
            ctx.fill();
          }
          ctx.fillStyle = 'rgba(185,195,230,0.95)';
          ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
          ctx.fillText('acoustic wave', x+12, yCell+cellH-30);

          ctx.restore();
        }

        drawCell(x1, 'Cell 1', +1);
        drawCell(x2, 'Cell 2 (opposite)', -1);

        // Beam path
        const faHz = params.faMHz * 1e6;
        const thB = thetaB_small(faHz);
        const dth = 2*thB; // per cell
        const net = 2*dth; // two cells add

        // Scale angles for drawing (exaggerate a bit for visibility)
        const scale = 1.8;
        const a1 = dth * scale;
        const a2 = net * scale;

        const y0 = yCell + cellH*0.35;
        const xIn = pad;
        const xMid1 = x1 + cellW;
        const xMid2 = x2 + cellW;
        const xOut = w - pad;

        function lineFromAngle(xStart, yStart, xEnd, angle){
          const dx = xEnd - xStart;
          const yEnd = yStart + Math.tan(angle) * dx;
          return {xEnd, yEnd};
        }

        // Segment 1: input beam (horizontal)
        ctx.strokeStyle = 'rgba(233,238,252,0.9)';
        ctx.lineWidth = 2.4;
        ctx.beginPath();
        ctx.moveTo(xIn, y0);
        ctx.lineTo(x1, y0);
        ctx.stroke();

        // Segment 2: after cell 1
        const p1 = lineFromAngle(x1, y0, xMid1, a1);
        ctx.strokeStyle = 'rgba(52,211,153,0.95)';
        ctx.beginPath();
        ctx.moveTo(x1, y0);
        ctx.lineTo(p1.xEnd, p1.yEnd);
        ctx.stroke();

        // Segment 3: after cell 2
        const p2 = lineFromAngle(x2, p1.yEnd, xMid2, a2);
        ctx.beginPath();
        ctx.moveTo(x2, p1.yEnd);
        ctx.lineTo(p2.xEnd, p2.yEnd);
        ctx.stroke();

        // Segment 4: output
        const p3 = lineFromAngle(xMid2, p2.yEnd, xOut, a2);
        ctx.beginPath();
        ctx.moveTo(xMid2, p2.yEnd);
        ctx.lineTo(p3.xEnd, p3.yEnd);
        ctx.stroke();

        // Labels
        ctx.fillStyle = 'rgba(185,195,230,0.95)';
        ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        ctx.fillText('input beam (f0)', xIn+6, y0-10);
        ctx.fillStyle = 'rgba(52,211,153,0.95)';
        ctx.fillText('after cell 1', x1+10, y0+18);
        ctx.fillText('after cell 2 (output)', x2+10, p1.yEnd+18);

        // Frequency shift annotation
        const mode = params.mode;
        const dfNet = (mode === 'cancel') ? 0 : 2*faHz;
        ctx.fillStyle = 'rgba(233,238,252,0.92)';
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        const dfText = (mode === 'cancel')
          ? 'Δf_net = 0'
          : 'Δf_net = +2 f_a';
        ctx.fillText(dfText, pad, h - 14);

        // Angle annotation
        ctx.fillStyle = 'rgba(185,195,230,0.95)';
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        ctx.fillText('Δθ_net ≈ 4 θ_B', w - 150, h - 14);
      }

      // ---------- Plot 1: deflection vs fa ----------
      const plot1 = setupHiDPICanvas(document.getElementById('plot1'));
      function drawPlot1(){
        const {ctx, resize} = plot1;
        const {w, h} = resize();
        ctx.clearRect(0,0,w,h);

        const padL = 70, padR = 18, padT = 34, padB = 54;
        const x0 = padL, y0 = padT, pw = w - padL - padR, ph = h - padT - padB;

        const xMin = 20, xMax = 200; // MHz
        // y in mrad for readability
        const yMin = 0;
        // compute yMax from model at xMax
        const thBmax = thetaB_small(xMax*1e6);
        const dthetaNetMax = 4*thBmax;
        const yMax = Math.max(1, mrad(dthetaNetMax) * 1.15);

        drawGrid(ctx, x0, y0, pw, ph, 8, 6);
        drawAxes(ctx, x0, y0, pw, ph);

        // Curve
        ctx.save();
        ctx.strokeStyle = 'rgba(125,211,252,0.95)';
        ctx.lineWidth = 2.6;
        ctx.beginPath();
        for(let i=0;i<=240;i++){
          const fa = xMin + (xMax-xMin)*i/240;
          const thB = thetaB_small(fa*1e6);
          const y = mrad(4*thB);
          const px = x0 + (fa - xMin) * (pw/(xMax-xMin));
          const py = y0 + ph - (y - yMin) * (ph/(yMax-yMin));
          if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.stroke();
        ctx.restore();

        // Current point
        const faC = params.faMHz;
        const thBC = thetaB_small(faC*1e6);
        const yC = mrad(4*thBC);
        const pxC = x0 + (faC - xMin) * (pw/(xMax-xMin));
        const pyC = y0 + ph - (yC - yMin) * (ph/(yMax-yMin));

        ctx.save();
        ctx.fillStyle = 'rgba(52,211,153,0.95)';
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(pxC, pyC, 5.5, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        drawTickLabels(
          ctx, x0, y0, pw, ph,
          xMin, xMax, yMin, yMax,
          'f_a (MHz)', 'Δθ_net (mrad)',
          'Net deflection vs acoustic frequency (example)'
        );

        drawLegend(ctx, x0 + pw - 210, y0 + 10, [
          {label:'Δθ_net ≈ 4θ_B', color:'rgba(125,211,252,0.95)'},
          {label:'current f_a', color:'rgba(52,211,153,0.95)'}
        ]);

        // Parameter note
        ctx.save();
        ctx.fillStyle = 'rgba(185,195,230,0.95)';
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        const note = `λ=${(params.lambda*1e9).toFixed(1)} nm, n=${params.n.toFixed(2)}, v=${params.v.toFixed(0)} m/s`;
        ctx.fillText(note, x0, y0 + ph + 48);
        ctx.restore();
      }

      // ---------- Plot 2: net frequency shift vs fa ----------
      const plot2 = setupHiDPICanvas(document.getElementById('plot2'));
      function drawPlot2(){
        const {ctx, resize} = plot2;
        const {w, h} = resize();
        ctx.clearRect(0,0,w,h);

        const padL = 70, padR = 18, padT = 34, padB = 54;
        const x0 = padL, y0 = padT, pw = w - padL - padR, ph = h - padT - padB;

        const xMin = 20, xMax = 200; // MHz
        // y in MHz for readability
        const yMin = -10;
        const yMax = 420; // enough for 2*200 MHz

        drawGrid(ctx, x0, y0, pw, ph, 8, 6);
        drawAxes(ctx, x0, y0, pw, ph);

        // Cancel curve: 0
        ctx.save();
        ctx.strokeStyle = 'rgba(52,211,153,0.95)';
        ctx.lineWidth = 2.6;
        ctx.beginPath();
        for(let i=0;i<=240;i++){
          const fa = xMin + (xMax-xMin)*i/240;
          const y = 0;
          const px = x0 + (fa - xMin) * (pw/(xMax-xMin));
          const py = y0 + ph - (y - yMin) * (ph/(yMax-yMin));
          if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.stroke();
        ctx.restore();

        // Add curve: 2 fa
        ctx.save();
        ctx.strokeStyle = 'rgba(251,113,133,0.95)';
        ctx.lineWidth = 2.6;
        ctx.beginPath();
        for(let i=0;i<=240;i++){
          const fa = xMin + (xMax-xMin)*i/240;
          const y = 2*fa;
          const px = x0 + (fa - xMin) * (pw/(xMax-xMin));
          const py = y0 + ph - (y - yMin) * (ph/(yMax-yMin));
          if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.stroke();
        ctx.restore();

        // Current point for selected mode
        const faC = params.faMHz;
        const yC = (params.mode === 'cancel') ? 0 : 2*faC;
        const pxC = x0 + (faC - xMin) * (pw/(xMax-xMin));
        const pyC = y0 + ph - (yC - yMin) * (ph/(yMax-yMin));

        ctx.save();
        ctx.fillStyle = 'rgba(125,211,252,0.95)';
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(pxC, pyC, 5.5, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        drawTickLabels(
          ctx, x0, y0, pw, ph,
          xMin, xMax, yMin, yMax,
          'f_a (MHz)', 'Δf_net (MHz)',
          'Net frequency shift vs acoustic frequency'
        );

        drawLegend(ctx, x0 + pw - 260, y0 + 10, [
          {label:'shift-canceling: 0', color:'rgba(52,211,153,0.95)'},
          {label:'shift-adding: 2 f_a', color:'rgba(251,113,133,0.95)'},
          {label:'current mode', color:'rgba(125,211,252,0.95)'}
        ]);
      }

      // ---------- UI wiring ----------
      const faSlider = document.getElementById('fa');
      const modeSel = document.getElementById('mode');
      const resetBtn = document.getElementById('reset');

      const faReadout = document.getElementById('faReadout');
      const thetaBReadout = document.getElementById('thetaBReadout');
      const thetaNetReadout = document.getElementById('thetaNetReadout');
      const dfReadout = document.getElementById('dfReadout');

      function updateReadouts(){
        const faHz = params.faMHz * 1e6;
        const thB = thetaB_small(faHz);
        const dthetaNet = 4*thB;

        faReadout.textContent = `${params.faMHz.toFixed(0)} MHz`;
        thetaBReadout.textContent = `${mrad(thB).toFixed(3)} mrad (${deg(thB).toFixed(4)}°)`;
        thetaNetReadout.textContent = `${mrad(dthetaNet).toFixed(3)} mrad (${deg(dthetaNet).toFixed(4)}°)`;

        const dfNetHz = (params.mode === 'cancel') ? 0 : 2*faHz;
        dfReadout.textContent = (params.mode === 'cancel')
          ? `0 Hz`
          : `+${(dfNetHz/1e6).toFixed(0)} MHz`;
      }

      function renderAll(){
        updateReadouts();
        drawDiagram();
        drawPlot1();
        drawPlot2();
      }

      faSlider.addEventListener('input', ()=>{
        params.faMHz = parseFloat(faSlider.value);
        renderAll();
      });

      modeSel.addEventListener('change', ()=>{
        params.mode = modeSel.value;
        renderAll();
      });

      resetBtn.addEventListener('click', ()=>{
        params.faMHz = 80;
        params.mode = 'cancel';
        faSlider.value = params.faMHz;
        modeSel.value = params.mode;
        renderAll();
      });

      window.addEventListener('resize', ()=>{
        renderAll();
      });

      attachCopyButtons();
      renderAll();
    })();
  </script>
</body>
</html>
