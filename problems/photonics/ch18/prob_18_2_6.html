<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Transition Cross Section in GaAs vs Carrier Injection (T = 0 K)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1633;
      --panel2:#0d1430;
      --text:#e9ecff;
      --muted:#b8c0ff;
      --faint:#8e97d6;
      --line:rgba(255,255,255,.12);
      --accent:#7cf0ff;
      --accent2:#a78bfa;
      --good:#48f1a6;
      --warn:#ffcc66;
      --bad:#ff6b6b;
      --shadow: 0 18px 60px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1100px 700px at 20% -10%, rgba(124,240,255,.22), transparent 60%),
        radial-gradient(900px 650px at 90% 0%, rgba(167,139,250,.20), transparent 55%),
        radial-gradient(1200px 800px at 60% 115%, rgba(72,241,166,.12), transparent 55%),
        linear-gradient(180deg, #070a14 0%, #0b1020 55%, #070a14 100%);
      line-height:1.55;
      overflow-x:hidden;
    }

    header{
      padding:34px 18px 12px;
      max-width:1180px;
      margin:0 auto;
      position:relative;
    }
    .hero{
      background: linear-gradient(135deg, rgba(124,240,255,.14), rgba(167,139,250,.12));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:22px 22px;
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .hero:before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(600px 200px at 20% 10%, rgba(124,240,255,.18), transparent 65%),
        radial-gradient(500px 240px at 80% 30%, rgba(167,139,250,.16), transparent 70%);
      filter: blur(6px);
      pointer-events:none;
    }
    .hero > *{position:relative}
    h1{
      margin:0 0 8px;
      font-weight:800;
      letter-spacing:.2px;
      font-size: clamp(22px, 3.2vw, 34px);
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      max-width: 70ch;
      font-size: 1.02rem;
    }

    main{
      max-width:1180px;
      margin: 0 auto;
      padding: 16px 18px 70px;
      display:grid;
      grid-template-columns: 310px 1fr;
      gap: 16px;
      align-items:start;
    }

    nav.toc{
      position:sticky;
      top:12px;
      align-self:start;
      background: rgba(15,22,51,.72);
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding: 14px 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .toc h2{
      margin:4px 0 10px;
      font-size: 13px;
      letter-spacing:.12em;
      text-transform: uppercase;
      color: var(--faint);
    }
    .toc a{
      display:block;
      padding: 7px 10px;
      border-radius: 12px;
      color: var(--muted);
      text-decoration:none;
      font-size: 14px;
      border: 1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .toc a:hover{
      background: rgba(124,240,255,.07);
      border-color: rgba(124,240,255,.18);
      transform: translateX(2px);
      color: var(--text);
    }
    .toc .small{
      font-size:12px;
      color: var(--faint);
      margin: 10px 0 0;
      padding: 0 8px;
    }

    article{
      background: rgba(15,22,51,.60);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    section{
      padding: 18px 18px;
      border-top: 1px solid var(--line);
    }
    section:first-child{border-top:none}
    h2{
      margin:0 0 10px;
      font-size: 20px;
      letter-spacing:.2px;
    }
    h3{
      margin: 14px 0 8px;
      font-size: 16px;
      color: var(--text);
    }
    p{margin: 8px 0}
    ul{margin: 8px 0 8px 20px}
    li{margin: 6px 0; color: var(--muted)}
    .muted{color: var(--muted)}
    .faint{color: var(--faint)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr; }
      nav.toc{position:relative; top:0}
      .grid2{grid-template-columns: 1fr}
    }

    .card{
      background: rgba(13,20,48,.72);
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 14px 14px;
      box-shadow: 0 12px 40px rgba(0,0,0,.25);
    }
    .callout{
      border-left: 4px solid rgba(124,240,255,.8);
      background: linear-gradient(180deg, rgba(124,240,255,.08), rgba(13,20,48,.5));
    }
    .assume{ border-left-color: rgba(72,241,166,.8); }
    .mistake{ border-left-color: rgba(255,204,102,.9); }
    .final{ border-left-color: rgba(167,139,250,.9); }

    .eqwrap{
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
      padding: 10px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      overflow:auto;
    }
    .eq{
      font-family: var(--mono);
      font-size: 13px;
      color: #f3f6ff;
      white-space: pre;
      line-height:1.45;
      margin:0;
      flex:1;
    }
    .copyBtn{
      appearance:none;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(124,240,255,.10);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      cursor:pointer;
      font-size: 12px;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      white-space:nowrap;
    }
    .copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(124,240,255,.16);
      border-color: rgba(124,240,255,.35);
    }
    .copyBtn:active{ transform: translateY(0px) scale(.99); }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items:end;
      margin-top: 6px;
    }
    @media (max-width: 780px){
      .controls{grid-template-columns:1fr}
    }
    label{
      font-size: 12px;
      color: var(--faint);
      display:block;
      margin: 2px 0 6px;
      letter-spacing:.04em;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    select, input[type="number"]{
      width:100%;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.15);
      background: rgba(0,0,0,.18);
      color: var(--text);
      padding: 10px 10px;
      outline:none;
    }
    .kpiRow{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    @media (max-width: 900px){
      .kpiRow{grid-template-columns:1fr}
    }
    .kpi{
      border:1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      padding: 12px;
      background: rgba(0,0,0,.14);
    }
    .kpi .label{color: var(--faint); font-size: 12px}
    .kpi .value{font-size: 16px; margin-top: 6px; font-weight: 800}
    .kpi .note{color: var(--muted); font-size: 12px; margin-top: 4px}

    .canvasWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }
    canvas{
      width:100%;
      height: 320px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      box-shadow: 0 14px 45px rgba(0,0,0,.22);
    }
    .canvasTall canvas{ height: 360px; }

    .badge{
      display:inline-block;
      padding: 4px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.16);
      color: var(--muted);
      background: rgba(255,255,255,.06);
      font-size: 12px;
      margin-right: 6px;
    }
    .badge.good{border-color: rgba(72,241,166,.35); background: rgba(72,241,166,.10); color: #d8fff0}
    .badge.warn{border-color: rgba(255,204,102,.35); background: rgba(255,204,102,.10); color: #fff2d2}
    .badge.bad{border-color: rgba(255,107,107,.35); background: rgba(255,107,107,.10); color: #ffe0e0}

    footer{
      max-width:1180px;
      margin: 0 auto;
      padding: 18px 18px 40px;
      color: var(--faint);
      font-size: 13px;
    }

    /* Subtle motion */
    @media (prefers-reduced-motion: no-preference){
      .hero{animation: floatIn .55s ease-out both;}
      article{animation: floatIn .65s ease-out both .05s;}
      @keyframes floatIn{
        from{opacity:0; transform: translateY(10px)}
        to{opacity:1; transform: translateY(0)}
      }
    }

    /* Print-friendly */
    @media print{
      body{background:#fff;color:#000}
      nav.toc{display:none}
      header, main, footer{max-width:100%; padding:0}
      article{box-shadow:none; border:1px solid #bbb; background:#fff}
      canvas{display:none}
      .copyBtn{display:none}
      .card{background:#fff}
      .eqwrap{background:#fff}
    }
  </style>
</head>

<body>
  <header>
    <div class="hero">
      <h1>Transition Cross Section Ïƒ(Î½) in GaAs vs Excess Carrier Density Î”n (T = 0 K)</h1>
      <p class="subtitle">
        We connect the â€œlaser-amplifierâ€ idea of a transition cross section to semiconductor band-to-band stimulated processes,
        derive Ïƒ(Î½) in a clean model (direct-gap, parabolic bands, T=0 K), and explain why Ïƒ is <em>less</em> useful for semiconductor optical amplifiers (SOAs)
        than for discrete-level laser media.
      </p>
    </div>
  </header>

  <main>
    <nav class="toc" aria-label="Table of Contents">
      <h2>Table of Contents</h2>
      <a href="#quick">Quick Summary</a>
      <a href="#part0">PART 0 â€” Concept Primer</a>
      <a href="#part1">PART 1 â€” Problem Analysis</a>
      <a href="#part2">PART 2 â€” Strategy & Tips</a>
      <a href="#part3">PART 3 â€” Full Solution</a>
      <a href="#part4">PART 4 â€” Deeper Understanding</a>
      <a href="#part5">PART 5 â€” Visualization Guide</a>
      <p class="small">
        Tip: use the Î”n slider to see how band-filling changes the gain window and the plotted Ïƒ(Î½).
      </p>
    </nav>

    <article>
      <!-- Quick Summary -->
      <section id="quick">
        <h2>Quick Summary</h2>
        <ul>
          <li><span class="badge good">Goal</span> Find the transition cross section <span class="eq" style="display:inline">Ïƒ(Î½)</span> for GaAs as a function of injected excess carriers <span class="eq" style="display:inline">Î”n</span> at <span class="eq" style="display:inline">T=0 K</span>.</li>
          <li><span class="badge">Key idea</span> Semiconductors have a <em>continuum</em> of band-to-band transitions; net stimulated gain/absorption at frequency Î½ depends on the occupation difference <span class="eq" style="display:inline">f_c - f_v</span>.</li>
          <li><span class="badge">Rate form</span> Stimulated transition probability density: <span class="eq" style="display:inline">Ï†(Î½) = Ïƒ(Î½) Î¦</span>, where <span class="eq" style="display:inline">Î¦</span> is photon-flux density (<span class="eq" style="display:inline">mâ»Â² sâ»Â¹</span>).</li>
          <li><span class="badge">Bridge to gain</span> Optical gain coefficient: <span class="eq" style="display:inline">g(Î½) = Ïƒ(Î½) (N_2 - N_1)</span>. In a band system, the â€œeffective inversionâ€ is energy-dependent, so Ïƒ is not a single medium constant.</li>
          <li><span class="badge">Model result</span> For direct-gap parabolic bands, the joint density of states gives <span class="eq" style="display:inline">g(hÎ½) âˆ âˆš(hÎ½ âˆ’ E_g)/hÎ½</span> times a step-like occupation factor at <span class="eq" style="display:inline">T=0</span>.</li>
          <li><span class="badge warn">Î”n dependence</span> Injected Î”n sets a Fermi wavevector <span class="eq" style="display:inline">k_F âˆ (Î”n)^{1/3}</span>, which sets the <em>gain bandwidth</em> <span class="eq" style="display:inline">Î”E_max âˆ k_F^2 âˆ (Î”n)^{2/3}</span>.</li>
          <li><span class="badge bad">Why Ïƒ is less useful</span> In SOAs, gain is governed by <span class="eq" style="display:inline">g(Î½, Î”n, T)</span> and differential gain, because Ïƒ depends strongly on carrier distribution, band filling, many-body effects, and broad spectraâ€”unlike discrete two-level doped media.</li>
        </ul>
      </section>

      <!-- PART 0 -->
      <section id="part0">
        <h2>PART 0 â€” Concept Primer (Theory Before Solving)</h2>

        <div class="grid2">
          <div class="card callout">
            <h3>Core definitions (symbols & units)</h3>
            <ul>
              <li><span class="eq">Î¦</span> = photon flux density (<span class="eq">photonsÂ·mâ»Â²Â·sâ»Â¹</span>)</li>
              <li><span class="eq">Ïƒ(Î½)</span> = transition cross section at optical frequency Î½ (<span class="eq">mÂ²</span>)</li>
              <li><span class="eq">Ï†(Î½) = Ïƒ(Î½) Î¦</span> = stimulated transition probability density (<span class="eq">sâ»Â¹</span> per particle)</li>
              <li><span class="eq">g(Î½)</span> = material gain coefficient (<span class="eq">mâ»Â¹</span>), defined by <span class="eq">dÎ¦/dz = g(Î½) Î¦</span></li>
              <li><span class="eq">E_g</span> = GaAs bandgap at 0 K (â‰ˆ 1.519 eV, used as an example constant for plots)</li>
              <li><span class="eq">f_c, f_v</span> = Fermi-Dirac occupation probabilities in conduction/valence bands</li>
              <li><span class="eq">Î”n</span> = injected excess electron density (and for charge neutrality, <span class="eq">Î”p â‰ˆ Î”n</span>)</li>
            </ul>
          </div>

          <div class="card callout">
            <h3>Physical meaning</h3>
            <p class="muted">
              In a two-level laser medium, <span class="eq">Ïƒ(Î½)</span> is a powerful â€œper-particle strengthâ€:
              it converts photon flux to a stimulated transition rate, and converts population inversion to gain.
            </p>
            <p class="muted">
              In a semiconductor, there are not just two levels: there are many k-states. A photon at energy <span class="eq">hÎ½</span> couples
              conduction and valence states with the same crystal momentum k (direct transition). Whether the net effect is absorption or gain depends on
              whether those states are occupied (electrons) or empty (holes).
            </p>
          </div>
        </div>

        <div class="card assume">
          <h3>Key laws/principles & validity</h3>
          <ul>
            <li><strong>Stimulated transition rate:</strong> For a given transition, rate âˆ photon flux and a coupling strength â†’ the cross section idea.</li>
            <li><strong>Gain definition:</strong> <span class="eq">dÎ¦/dz = g(Î½) Î¦</span> is a macroscopic statement; microscopic stimulated events sum to give <span class="eq">g</span>.</li>
            <li><strong>Direct-gap selection:</strong> In GaAs (direct gap), vertical (same-k) optical transitions dominate near the band edge.</li>
            <li><strong>Parabolic-band approximation:</strong> Near band edges, <span class="eq">E_c(k) â‰ˆ E_g + â„Â²kÂ²/(2m_e*)</span>, <span class="eq">E_v(k) â‰ˆ -â„Â²kÂ²/(2m_h*)</span>.</li>
            <li><strong>T = 0 K:</strong> Occupations become step functions â†’ sharp â€œband-fillingâ€ edges, making Î”n-dependence transparent.</li>
          </ul>
        </div>

        <div class="grid2">
          <div class="card">
            <h3>Common models/approximations (and why)</h3>
            <ul>
              <li><strong>Joint density of states (JDOS):</strong> compresses â€œhow many transitions exist at energy hÎ½â€ into a simple function.</li>
              <li><strong>Constant dipole (matrix element) approximation:</strong> treat optical coupling as slowly varying near the edge so the spectral shape is dominated by JDOS and occupations.</li>
              <li><strong>Charge neutrality:</strong> injected electrons â‰ˆ injected holes, so one parameter Î”n sets both quasi-Fermi levels at 0 K.</li>
            </ul>
          </div>
          <div class="card">
            <h3>Mini intuition examples</h3>
            <ul>
              <li><strong>No injection:</strong> valence full, conduction empty â†’ <span class="eq">f_c - f_v â‰ˆ -1</span> â†’ absorption near the band edge.</li>
              <li><strong>Strong injection:</strong> some conduction states filled and some valence states emptied (holes) â†’ <span class="eq">f_c - f_v > 0</span> for a band of photon energies â†’ gain window broadens with Î”n.</li>
            </ul>
            <h3>What to watch for</h3>
            <ul>
              <li>Mixing up <em>valence electron occupancy</em> <span class="eq">f_v</span> with <em>hole occupancy</em> <span class="eq">(1-f_v)</span>.</li>
              <li>Assuming a single constant Ïƒ like a two-level system (semiconductors are energy- and density-dependent).</li>
              <li>Forgetting units: Ïƒ is area, gain is inverse length, and Î”n is per volume.</li>
            </ul>
          </div>
        </div>
      </section>

      <!-- PART 1 -->
      <section id="part1">
        <h2>PART 1 â€” Problem Analysis (No solving yet)</h2>

        <div class="card">
          <h3>Problem re-statement</h3>
          <p class="muted">
            For GaAs at <span class="eq">T=0 K</span>, determine the transition cross section <span class="eq">Ïƒ(Î½)</span> for stimulated emission/absorption
            as a function of injected excess carrier density <span class="eq">Î”n</span>. The stimulated transition probability density is
            <span class="eq">Ï†(Î½)=Ïƒ(Î½)Î¦</span>, where <span class="eq">Î¦</span> is photon-flux density. Finally, explain why transition cross section is less useful
            for semiconductor optical amplifiers than for other laser amplifiers.
          </p>
        </div>

        <div class="grid2">
          <div class="card">
            <h3>Given / implied</h3>
            <ul>
              <li>Material: GaAs (direct-gap)</li>
              <li>Temperature: <span class="eq">T=0 K</span> (step-like occupations)</li>
              <li>Injection described by a single excess density <span class="eq">Î”n</span> (assume neutrality: <span class="eq">Î”pâ‰ˆÎ”n</span>)</li>
              <li>Stimulated probability density definition: <span class="eq">Ï†(Î½)=Ïƒ(Î½)Î¦</span></li>
            </ul>
          </div>
          <div class="card">
            <h3>Unknowns / what to find</h3>
            <ul>
              <li><span class="eq">Ïƒ(Î½;Î”n)</span> (frequency-dependent cross section, explicitly showing Î”n dependence)</li>
              <li>A clear physical explanation of â€œwhy Ïƒ is less usefulâ€ in SOAs</li>
            </ul>
          </div>
        </div>

        <div class="card assume">
          <h3>Relevant physics (and why it applies)</h3>
          <ul>
            <li><strong>Microscopicâ†’macroscopic link:</strong> Sum stimulated transitions over allowed k-states to obtain the macroscopic gain coefficient <span class="eq">g(Î½)</span>.</li>
            <li><strong>Direct transitions:</strong> Near the GaAs edge, optical transitions conserve k, so the JDOS of direct transitions controls spectral shape.</li>
            <li><strong>Carrier injection sets quasi-Fermi levels:</strong> at <span class="eq">T=0</span>, Î”n fixes a Fermi wavevector <span class="eq">k_F</span>, hence the occupied k-range in conduction and the emptied k-range in valence.</li>
          </ul>
          <p class="muted">
            What we <em>donâ€™t</em> use here: detailed many-body bandgap renormalization, excitons, and scattering-broadened lineshapesâ€”those refine real devices
            but obscure the clean Î”n-scaling asked for.
          </p>
        </div>

        <div class="card">
          <h3>Possible approaches (compare & choose)</h3>
          <ol class="muted">
            <li><strong>Two-level analogy:</strong> treat â€œeffective inversion densityâ€ and set <span class="eq">g=ÏƒÎ”n</span>. Fast and intuitive, but Ïƒ becomes model-dependent.</li>
            <li><strong>k-space + JDOS derivation (best):</strong> derive <span class="eq">g(hÎ½)</span> from JDOS and occupation difference, then define an effective Ïƒ by dividing by a chosen inversion measure (here, Î”n). Clear Î”n scaling at 0 K.</li>
            <li><strong>Einstein coefficient route:</strong> connect absorption/emission to spontaneous emission spectrum and detailed balance. Powerful but longer, and still ends at the same JDOS + occupations.</li>
          </ol>
          <p class="muted">
            We choose <strong>Approach 2</strong> because it cleanly exposes how Î”n reshapes the gain window at <span class="eq">T=0 K</span>,
            while keeping the cross-section concept tied to the macroscopic gain.
          </p>
        </div>
      </section>

      <!-- PART 2 -->
      <section id="part2">
        <h2>PART 2 â€” Strategy & Tips (Roadmap only)</h2>

        <div class="card">
          <ol class="muted">
            <li><strong>Model the bands:</strong> write parabolic <span class="eq">E_c(k)</span>, <span class="eq">E_v(k)</span>. (Tool: effective masses) â†’ connects photon energy to k.</li>
            <li><strong>Relate photon energy to k:</strong> use <span class="eq">hÎ½ = E_g + â„Â²kÂ²/(2m_r)</span>. (Tool: reduced mass) â†’ tells which k-states participate for a given Î½.</li>
            <li><strong>Write JDOS:</strong> <span class="eq">Ï_j(E) âˆ âˆš(Eâˆ’E_g)</span>. (Tool: density-of-states algebra) â†’ gives the spectral shape.</li>
            <li><strong>Write occupation factor:</strong> net stimulated term âˆ <span class="eq">f_c(k) âˆ’ f_v(k)</span>. At <span class="eq">T=0</span> these are step functions. â†’ tells gain vs absorption regions.</li>
            <li><strong>Connect Î”n to kF:</strong> <span class="eq">Î”n = k_F^3/(3Ï€Â²)</span>. â†’ sets the maximum k where conduction is filled and valence is emptied (holes exist).</li>
            <li><strong>Get gain spectrum:</strong> <span class="eq">g(Î½) = C Â· [Ï_j(hÎ½)] Â· [f_c âˆ’ f_v] / (hÎ½)</span> with a coupling constant C. â†’ macroscopic result.</li>
            <li><strong>Define Ïƒ(Î½):</strong> choose <span class="eq">g(Î½)=Ïƒ(Î½)Î”n</span> (effective cross section per injected carrier). â†’ yields <span class="eq">Ïƒ(Î½;Î”n)=g(Î½)/Î”n</span>.</li>
            <li><strong>Interpret & answer â€œwhy less usefulâ€:</strong> explain why Ïƒ is not a material constant in SOAs.</li>
          </ol>
        </div>

        <div class="card mistake">
          <h3>Common mistakes + quick tips</h3>
          <ul>
            <li><strong>Mistake:</strong> using <span class="eq">f_v</span> as â€œhole occupancy.â€ <strong>Tip:</strong> holes correspond to <span class="eq">(1-f_v)</span>.</li>
            <li><strong>Mistake:</strong> thinking Ïƒ is independent of Î”n. <strong>Tip:</strong> Î”n changes quasi-Fermi levels â†’ changes which photon energies see inversion.</li>
            <li><strong>Mistake:</strong> forgetting that GaAs transitions are broadband. <strong>Tip:</strong> always keep the Î½-dependence explicitly.</li>
          </ul>
        </div>
      </section>

      <!-- PART 3 -->
      <section id="part3">
        <h2>PART 3 â€” Full Solution (Detailed + Teaching)</h2>

        <div class="card">
          <h3>Physical intuition (before equations)</h3>
          <p class="muted">
            At <span class="eq">T=0 K</span>, injected electrons fill the lowest conduction states up to a Fermi wavevector <span class="eq">k_F</span>,
            and injected holes empty the highest valence states up to the same <span class="eq">k_F</span> (charge neutrality).
            For a photon of energy <span class="eq">hÎ½</span>, the relevant transition uses some k such that
            <span class="eq">hÎ½ = E_g + E_e(k)+E_h(k)</span>.
            If that k lies within the filled-electron/available-hole region, stimulated emission dominates (gain).
            Otherwise, absorption dominates.
            Therefore Î”n should mainly control the <em>width</em> of the gain window (band filling), and the spectral shape should follow the JDOS near the edge.
          </p>
        </div>

        <div class="card callout">
          <h3>Step 1 â€” Parabolic band model and photon energyâ€“k relation</h3>

          <div class="eqwrap">
            <pre class="eq" id="eq1">Conduction:   E_c(k) = E_g + (â„Â² kÂ²)/(2 m_e*)
Valence:      E_v(k) = - (â„Â² kÂ²)/(2 m_h*)      (measured from valence-band edge)
Transition:   E_ph â‰¡ hÎ½ = E_c(k) - E_v(k) = E_g + (â„Â² kÂ²)/(2 m_r)

where 1/m_r = 1/m_e* + 1/m_h*  (reduced effective mass)</pre>
            <button class="copyBtn" data-copy="#eq1">Copy</button>
          </div>

          <p class="muted">
            The direct-gap â€œverticalâ€ transition uses the <em>same k</em> in both bands, so the photon energy maps to a single k magnitude:
            <span class="eq">k(Î½) = (1/â„) âˆš(2 m_r (hÎ½ âˆ’ E_g))</span> for <span class="eq">hÎ½ â‰¥ E_g</span>.
          </p>
        </div>

        <div class="card callout">
          <h3>Step 2 â€” Joint density of states (JDOS) for direct transitions</h3>
          <p class="muted">
            The number of available interband transitions per unit energy per unit volume is the JDOS:
          </p>

          <div class="eqwrap">
            <pre class="eq" id="eq2">Ï_j(E) = (1/2Ï€Â²) * (2 m_r/â„Â²)^(3/2) * âˆš(E âˆ’ E_g)    for E â‰¥ E_g
Units: Ï_j â†’ (states Â· mâ»3 Â· Jâ»1)</pre>
            <button class="copyBtn" data-copy="#eq2">Copy</button>
          </div>

          <p class="muted">
            The square-root onset <span class="eq">âˆš(Eâˆ’E_g)</span> is the signature of 3D parabolic bands and will appear in gain/absorption spectra.
          </p>
        </div>

        <div class="card callout">
          <h3>Step 3 â€” Occupation difference at T = 0 K and how Î”n enters</h3>
          <p class="muted">
            The net stimulated effect at a given k is proportional to the occupation difference:
            absorption requires a valence electron and an empty conduction state; stimulated emission requires a conduction electron and an empty valence state (a hole).
            A compact â€œnetâ€ factor is
            <span class="eq">[f_c(k) âˆ’ f_v(k)]</span>.
          </p>

          <div class="eqwrap">
            <pre class="eq" id="eq3">At T = 0 K (step functions):
f_c(k) = 1  if k â‰¤ k_F   (filled conduction states)
       = 0  if k > k_F

f_v(k) = 0  if k â‰¤ k_F   (these top valence states are empty â†’ holes present)
       = 1  if k > k_F   (deeper valence states filled by electrons)

Therefore:
f_c(k) âˆ’ f_v(k) = +1  if k â‰¤ k_F   (inversion â†’ gain)
                = âˆ’1  if k > k_F   (no inversion â†’ absorption)</pre>
            <button class="copyBtn" data-copy="#eq3">Copy</button>
          </div>

          <p class="muted">
            Now relate injection density to the Fermi wavevector. For a 3D free-carrier gas with one valley and ignoring spin detail beyond the standard factor:
          </p>

          <div class="eqwrap">
            <pre class="eq" id="eq4">Î”n = k_F^3 / (3Ï€Â²)     â‡’     k_F = (3Ï€Â² Î”n)^(1/3)</pre>
            <button class="copyBtn" data-copy="#eq4">Copy</button>
          </div>

          <p class="muted">
            Using the photon energyâ€“k mapping, the â€œgain conditionâ€ <span class="eq">k(Î½) â‰¤ k_F</span> becomes a maximum photon energy for gain:
          </p>

          <div class="eqwrap">
            <pre class="eq" id="eq5">Gain window (T=0 K):
hÎ½ â‰¤ E_g + Î”E_max

Î”E_max = (â„Â² k_FÂ²)/(2 m_r)
       = (â„Â²/(2 m_r)) * (3Ï€Â² Î”n)^(2/3)</pre>
            <button class="copyBtn" data-copy="#eq5">Copy</button>
          </div>

          <p class="muted">
            So Î”n broadens the gain window with scaling <span class="eq">Î”E_max âˆ (Î”n)^(2/3)</span>.
          </p>
        </div>

        <div class="card callout">
          <h3>Step 4 â€” Gain coefficient g(Î½) and an effective Ïƒ(Î½)</h3>
          <p class="muted">
            A standard direct-gap interband gain/absorption expression (constant matrix element approximation) can be written as:
          </p>

          <div class="eqwrap">
            <pre class="eq" id="eq6">g(Î½) = ğ’ * [Ï_j(hÎ½)] * [f_c(k(Î½)) âˆ’ f_v(k(Î½))] / (hÎ½)

where ğ’ is a material coupling constant (contains dipole/momentum matrix element, refractive index, etc.).
Key point: spectral shape comes from Ï_j and the occupation factor.</pre>
            <button class="copyBtn" data-copy="#eq6">Copy</button>
          </div>

          <p class="muted">
            To connect to the problem statement <span class="eq">Ï†(Î½)=Ïƒ(Î½)Î¦</span>, we use the two-level-style macroscopic link:
            <span class="eq">dÎ¦/dz = g(Î½)Î¦</span> and <span class="eq">g(Î½) = Ïƒ(Î½) Â· (effective inversion density)</span>.
            In a continuum, â€œeffective inversionâ€ depends on energy. A common <em>effective</em> definition is to reference Ïƒ to the injected carrier density:
          </p>

          <div class="eqwrap">
            <pre class="eq" id="eq7">Define an effective transition cross section per injected carrier:
g(Î½) â‰¡ Ïƒ_eff(Î½;Î”n) Â· Î”n   â‡’   Ïƒ_eff(Î½;Î”n) = g(Î½)/Î”n</pre>
            <button class="copyBtn" data-copy="#eq7">Copy</button>
          </div>

          <p class="muted">
            Plugging the pieces in yields a compact, explicit Ïƒ(Î½;Î”n) with a clear Î”n-dependent step (gain vs absorption region).
          </p>
        </div>

        <div class="card final">
          <h3>Final result (symbolic, with T = 0 K band-filling)</h3>

          <div class="eqwrap">
            <pre class="eq" id="eqFinal">Let E â‰¡ hÎ½.

Joint DOS (direct, parabolic):
Ï_j(E) = (1/2Ï€Â²) (2 m_r/â„Â²)^(3/2) âˆš(E âˆ’ E_g) ,  E â‰¥ E_g

Fermi wavevector from injection:
k_F = (3Ï€Â² Î”n)^(1/3)

Gain cutoff energy:
E_g + Î”E_max ,   Î”E_max = (â„Â² k_FÂ²)/(2 m_r) = (â„Â²/(2 m_r)) (3Ï€Â² Î”n)^(2/3)

Occupation factor at T=0 K:
S(E;Î”n) = +1   for E_g â‰¤ E â‰¤ E_g + Î”E_max
        = âˆ’1   for E >  E_g + Î”E_max
        (and 0 for E < E_g because there are no direct transitions)

Gain coefficient model:
g(E) = ğ’ Â· Ï_j(E) Â· S(E;Î”n) / E

Effective transition cross section per injected carrier:
Ïƒ_eff(Î½;Î”n) = g(hÎ½)/Î”n
            = [ğ’/Î”n] Â· [(1/2Ï€Â²) (2 m_r/â„Â²)^(3/2) âˆš(hÎ½ âˆ’ E_g)] Â· S(hÎ½;Î”n) / (hÎ½)</pre>
            <button class="copyBtn" data-copy="#eqFinal">Copy</button>
          </div>

          <div class="kpiRow" id="kpis">
            <div class="kpi">
              <div class="label">Interpretation</div>
              <div class="value">Ïƒ is not a constant</div>
              <div class="note">It inherits the âˆš(hÎ½âˆ’E_g) edge + a Î”n-set gain cutoff.</div>
            </div>
            <div class="kpi">
              <div class="label">Key Î”n scaling (T=0 K)</div>
              <div class="value">Î”E_max âˆ (Î”n)^(2/3)</div>
              <div class="note">Band filling broadens the gain window with injection.</div>
            </div>
            <div class="kpi">
              <div class="label">Sign</div>
              <div class="value">gain vs absorption</div>
              <div class="note"><span class="badge good">+1</span> for inversion window, <span class="badge bad">âˆ’1</span> above it.</div>
            </div>
          </div>

          <h3>Sanity checks</h3>
          <ul class="muted">
            <li><strong>Units:</strong> <span class="eq">Ï_j</span> has units <span class="eq">mâ»3Â·Jâ»1</span>; <span class="eq">ğ’</span> carries units so that <span class="eq">g</span> is <span class="eq">mâ»1</span>, thus <span class="eq">Ïƒ_eff=g/Î”n</span> has units <span class="eq">mÂ²</span>.</li>
            <li><strong>Limiting case Î”n â†’ 0:</strong> <span class="eq">k_Fâ†’0</span> so <span class="eq">Î”E_maxâ†’0</span>; the gain window collapsesâ€”no inversionâ€”consistent with an unpumped semiconductor being absorptive near <span class="eq">E_g</span>.</li>
            <li><strong>Near the edge:</strong> for <span class="eq">E</gtrsim E_g</span>, the âˆš onset matches the known absorption-edge behavior of direct-gap semiconductors.</li>
          </ul>
        </div>

        <div class="card">
          <h3>Why the transition cross section is less useful for semiconductor optical amplifiers</h3>
          <ul class="muted">
            <li><strong>Continuum of states:</strong> There isnâ€™t a single â€œupperâ€ and â€œlowerâ€ level population; inversion is energy-resolved. A single Ïƒ cannot capture that.</li>
            <li><strong>Ïƒ depends on carrier distribution:</strong> Changing Î”n or T reshapes <span class="eq">f_c</span>, <span class="eq">f_v</span> and thus changes the effective Ïƒ spectrum.</li>
            <li><strong>Many-body & device realities:</strong> bandgap renormalization, carrier heating, spectral hole burning, inhomogeneous broadening, and scattering all modify <span class="eq">g(Î½)</span>. Designers therefore use <span class="eq">g(Î½,Î”n,T)</span>, modal gain, and <em>differential gain</em> rather than a â€œfixed Ïƒâ€.</li>
            <li><strong>Broadband nature:</strong> SOAs often exploit wide gain bandwidth; a single Ïƒ(Î½) is less compact than directly working with <span class="eq">g(Î½)</span>.</li>
          </ul>
        </div>
      </section>

      <!-- PART 4 -->
      <section id="part4">
        <h2>PART 4 â€” Deeper Understanding (Theory Around the Result)</h2>

        <div class="grid2">
          <div class="card">
            <h3>Re-reading the final formula</h3>
            <ul class="muted">
              <li><span class="eq">âˆš(hÎ½âˆ’E_g)</span>: sets the steep rise from the direct-gap JDOS.</li>
              <li><span class="eq">1/(hÎ½)</span>: photon-energy normalization typical of interband gain expressions.</li>
              <li><span class="eq">S(hÎ½;Î”n)</span>: the crucial <em>sign and window</em>; at 0 K it is a step controlled by <span class="eq">Î”E_max(Î”n)</span>.</li>
              <li><span class="eq">1/Î”n</span> in <span class="eq">Ïƒ_eff</span>: reminds you this is an â€œeffective per injected carrierâ€ quantity, not a universal constant.</li>
            </ul>
          </div>

          <div class="card">
            <h3>How changing Î”n affects outcomes (connect to plots)</h3>
            <ul class="muted">
              <li>Increasing Î”n increases <span class="eq">k_F âˆ (Î”n)^{1/3}</span>.</li>
              <li>That increases the gain cutoff energy <span class="eq">E_g+Î”E_max</span> with <span class="eq">Î”E_max âˆ (Î”n)^{2/3}</span>.</li>
              <li>So the <em>gain window widens</em> to higher photon energies (shorter wavelengths).</li>
              <li>Within the gain window, the spectral shape still follows the âˆš onsetâ€”so the plotted Ïƒ(Î½) curve â€œfills outâ€ over a broader span.</li>
            </ul>
          </div>
        </div>

        <div class="card">
          <h3>Alternative derivation idea (brief)</h3>
          <p class="muted">
            Instead of starting from JDOS, one can start from the spontaneous emission spectrum and use Einstein relations
            (or detailed balance) to relate spontaneous emission to stimulated emission/absorption in equilibrium, then replace equilibrium occupations with quasi-Fermi levels.
            The same key ingredients appear: matrix elements, density of states, and the factor <span class="eq">f_c - f_v</span>.
          </p>
        </div>

        <div class="card">
          <h3>Concept checks (quick self-test)</h3>
          <ul class="muted">
            <li><strong>Q:</strong> Why does the gain window widen with Î”n? <strong>A:</strong> Because injection raises the largest k for which conduction is filled and valence is emptied; higher-k transitions correspond to higher photon energies.</li>
            <li><strong>Q:</strong> Why does the JDOS scale like âˆš(Eâˆ’E_g)? <strong>A:</strong> 3D parabolic bands give DOS âˆ âˆšE; for direct transitions the JDOS inherits that âˆš onset.</li>
            <li><strong>Q:</strong> Why canâ€™t we use a single Ïƒ like in a two-level doped crystal? <strong>A:</strong> Because â€œinversionâ€ is not a single numberâ€”occupation difference varies with k (and thus with Î½), and depends on Î”n and T.</li>
            <li><strong>Q:</strong> What happens at <span class="eq">hÎ½ &gt; E_g+Î”E_max</span> in the 0 K model? <strong>A:</strong> The relevant k exceeds <span class="eq">k_F</span>, so conduction is empty and valence is full â†’ absorption dominates (negative sign).</li>
          </ul>
        </div>
      </section>

      <!-- PART 5 -->
      <section id="part5">
        <h2>PART 5 â€” Visualization Guide (How to Read the Plots)</h2>

        <div class="card">
          <h3>Interactive controls</h3>
          <div class="controls">
            <div>
              <label for="dn">Excess carrier density Î”n (cmâ»Â³)</label>
              <input id="dn" type="range" min="16" max="19" step="0.01" value="18.00" />
              <div class="muted" style="margin-top:6px">
                log<sub>10</sub>(Î”n) = <span id="dnLog">18.00</span> â†’ Î”n = <span id="dnVal">1.00Ã—10<sup>18</sup></span> cmâ»Â³
              </div>
            </div>
            <div>
              <label for="modelScale">Example coupling scale ğ’ (plot-only)</label>
              <select id="modelScale">
                <option value="1">Moderate (SOA-like)</option>
                <option value="0.4">Smaller coupling</option>
                <option value="2">Larger coupling</option>
              </select>
              <div class="muted" style="margin-top:6px">
                Note: ğ’ sets the <em>vertical scale</em> of g and Ïƒ; the Î”n-dependent <em>shape/window</em> is the key learning target.
              </div>
            </div>
          </div>
        </div>

        <div class="canvasWrap canvasTall">
          <div class="card">
            <h3>Canvas 1 â€” Labeled physical diagram (band filling & allowed transitions)</h3>
            <p class="muted">
              This diagram shows parabolic conduction/valence bands versus k, the injected Fermi boundary <span class="eq">k_F</span>, and how a photon at energy <span class="eq">hÎ½</span>
              picks out a transition at a specific k. Gain happens when that k lies within the filled-electron + hole-available region.
            </p>
            <canvas id="diag"></canvas>
          </div>

          <div class="card">
            <h3>Canvas 2 â€” Main plot: effective cross section Ïƒ<sub>eff</sub>(Î½;Î”n)</h3>
            <p class="muted">
              Plotted as a function of photon energy <span class="eq">E = hÎ½</span>. The curve is positive in the gain window and negative beyond the Î”n-set cutoff.
              Units shown are <span class="eq">cmÂ²</span>.
            </p>
            <canvas id="plot1"></canvas>
          </div>

          <div class="card">
            <h3>Canvas 3 â€” Secondary plot: gain cutoff energy Î”E<sub>max</sub>(Î”n) and cutoff wavelength</h3>
            <p class="muted">
              This sweep shows how the gain window width <span class="eq">Î”E_max âˆ (Î”n)^{2/3}</span> increases with injection, and the corresponding cutoff wavelength shortens.
            </p>
            <canvas id="plot2"></canvas>
          </div>
        </div>

        <div class="card final">
          <h3>Copy-ready final answer (plain text)</h3>
          <div class="eqwrap">
            <pre class="eq" id="eqAnswer">At T = 0 K for direct-gap GaAs (parabolic bands), define E â‰¡ hÎ½ and reduced mass 1/m_r = 1/m_e* + 1/m_h*.

Photon energyâ€“k relation:
E = E_g + (â„Â² kÂ²)/(2 m_r)

JDOS:
Ï_j(E) = (1/2Ï€Â²) (2 m_r/â„Â²)^(3/2) âˆš(E âˆ’ E_g),  E â‰¥ E_g

Injection sets k_F:
k_F = (3Ï€Â² Î”n)^(1/3)

Gain cutoff (band filling):
Î”E_max = (â„Â² k_FÂ²)/(2 m_r) = (â„Â²/(2 m_r)) (3Ï€Â² Î”n)^(2/3)

T=0 occupation factor:
S(E;Î”n) = +1 for E_g â‰¤ E â‰¤ E_g + Î”E_max   (net stimulated emission / gain)
        = âˆ’1 for E >  E_g + Î”E_max        (net absorption)

Gain model (constant matrix element approximation):
g(E) = ğ’ Â· Ï_j(E) Â· S(E;Î”n) / E

Effective transition cross section per injected carrier:
Ïƒ_eff(Î½;Î”n) = g(hÎ½)/Î”n = [ğ’/Î”n] Â· [(1/2Ï€Â²)(2 m_r/â„Â²)^(3/2) âˆš(hÎ½ âˆ’ E_g)] Â· S(hÎ½;Î”n)/(hÎ½).

Why Ïƒ is less useful in SOAs:
Because interband transitions form a continuum; the â€œeffective inversionâ€ is energy-dependent and changes with Î”n and T (band filling, carrier heating, many-body effects), so Ïƒ is not a single material constant. Designers use g(Î½,Î”n,T) and differential gain instead.</pre>
            <button class="copyBtn" data-copy="#eqAnswer">Copy</button>
          </div>
        </div>
      </section>
    </article>
  </main>

  <footer>
    <p>
      This article used a clean <strong>T = 0 K</strong> parabolic-band model to reveal the essential scaling
      <span class="eq" style="display:inline">Î”E_max âˆ (Î”n)^{2/3}</span>. Real GaAs SOAs at finite temperature include
      broadened Fermi edges, bandgap renormalization, and scattering, which smooth the step-like behavior but preserve the core intuition:
      injection controls the occupation factor and thus the gain spectrum.
    </p>
  </footer>

  <script>
    // -------------------------
    // Utilities
    // -------------------------
    const clamp = (x, a, b) => Math.max(a, Math.min(b, x));

    function fmtSci(x, sig=3){
      if (x === 0) return "0";
      const exp = Math.floor(Math.log10(Math.abs(x)));
      const mant = x / Math.pow(10, exp);
      return `${mant.toFixed(sig-1)}Ã—10<sup>${exp}</sup>`;
    }
    function fmtFixed(x, digits=3){
      return Number(x).toFixed(digits);
    }

    async function copyFromSelector(sel){
      const el = document.querySelector(sel);
      if(!el) return;
      const text = el.textContent.replace(/\u00A0/g,' ');
      try{
        await navigator.clipboard.writeText(text);
        toast("Copied!");
      }catch(e){
        // Fallback
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
        toast("Copied!");
      }
    }

    let toastTimer = null;
    function toast(msg){
      let t = document.getElementById("toast");
      if(!t){
        t = document.createElement("div");
        t.id="toast";
        t.style.position="fixed";
        t.style.left="50%";
        t.style.bottom="18px";
        t.style.transform="translateX(-50%)";
        t.style.padding="10px 14px";
        t.style.borderRadius="999px";
        t.style.border="1px solid rgba(255,255,255,.18)";
        t.style.background="rgba(0,0,0,.55)";
        t.style.color="white";
        t.style.fontFamily="ui-sans-serif,system-ui";
        t.style.fontSize="13px";
        t.style.backdropFilter="blur(10px)";
        t.style.boxShadow="0 16px 50px rgba(0,0,0,.35)";
        t.style.opacity="0";
        t.style.transition="opacity .18s ease, transform .18s ease";
        document.body.appendChild(t);
      }
      t.innerHTML = msg;
      t.style.opacity="1";
      t.style.transform="translateX(-50%) translateY(-2px)";
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=>{
        t.style.opacity="0";
        t.style.transform="translateX(-50%) translateY(0px)";
      }, 900);
    }

    // Smooth scroll for TOC
    document.querySelectorAll('nav.toc a').forEach(a=>{
      a.addEventListener('click', (e)=>{
        const href = a.getAttribute('href');
        if(href && href.startsWith('#')){
          e.preventDefault();
          document.querySelector(href).scrollIntoView({behavior:'smooth', block:'start'});
        }
      });
    });

    // Copy buttons
    document.querySelectorAll('.copyBtn').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const sel = btn.getAttribute('data-copy');
        if(sel) copyFromSelector(sel);
      });
    });

    // -------------------------
    // Physical constants (SI)
    // -------------------------
    const q = 1.602176634e-19;     // C
    const h = 6.62607015e-34;      // J*s
    const hbar = 1.054571817e-34;  // J*s
    const c = 299792458;           // m/s
    const m0 = 9.1093837015e-31;   // kg

    // GaAs example parameters (for plots only; the symbolic result stands)
    const Eg_eV = 1.519;           // eV (0 K)
    const Eg = Eg_eV * q;          // J
    const n_refr = 3.6;            // refractive index (example)
    const me = 0.067 * m0;         // electron effective mass
    const mh = 0.45 * m0;          // heavy-hole effective mass
    const mr = (me*mh)/(me+mh);    // reduced mass

    // Coupling constant for plot-only gain scale:
    // We keep a simple adjustable ğ’ so the shapes are the learning focus.
    // Units chosen so g comes out in 1/m when multiplied by Ï_j(E)/E (with E in J).
    const C0 = 2.2e-23; // "example coupling" (tuned to yield reasonable-looking curves; not a claim of exact GaAs value)

    // -------------------------
    // Model functions (T=0 K)
    // -------------------------
    function kF_from_dn(dn_m3){
      // dn = kF^3/(3Ï€^2)
      return Math.pow(3*Math.PI*Math.PI*dn_m3, 1/3);
    }

    function jdos(E){
      // Ï_j(E) = (1/2Ï€Â²) (2 mr/Ä§Â²)^(3/2) âˆš(E âˆ’ Eg), E>=Eg
      if(E < Eg) return 0;
      const pref = 1/(2*Math.PI*Math.PI) * Math.pow(2*mr/(hbar*hbar), 1.5);
      return pref * Math.sqrt(E - Eg); // units: m^-3 J^-1
    }

    function occupationSign(E, dn_m3){
      // S(E;Î”n): +1 for E in gain window, -1 above cutoff; 0 below Eg
      if(E < Eg) return 0;
      const kF = kF_from_dn(dn_m3);
      const dEmax = (hbar*hbar*kF*kF)/(2*mr);
      const Ecut = Eg + dEmax;
      return (E <= Ecut) ? 1 : -1;
    }

    function gain_g(E, dn_m3, scale=1){
      // g(E) = ğ’ * Ï_j(E) * S(E;dn)/E
      if(E <= 0) return 0;
      const C = C0 * scale;
      return C * jdos(E) * occupationSign(E, dn_m3) / E; // 1/m
    }

    function sigma_eff(E, dn_m3, scale=1){
      // Ïƒ_eff = g/Î”n
      if(dn_m3 <= 0) return 0;
      return gain_g(E, dn_m3, scale) / dn_m3; // m^2
    }

    // -------------------------
    // Canvas plotting helpers
    // -------------------------
    function setupCanvas(canvas){
      const ctx = canvas.getContext('2d');
      function resize(){
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.max(2, Math.floor(rect.width * dpr));
        canvas.height = Math.max(2, Math.floor(rect.height * dpr));
        ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      }
      resize();
      return {ctx, resize};
    }

    function clear(ctx, w, h){
      ctx.clearRect(0,0,w,h);
      // subtle background vignette
      const g = ctx.createRadialGradient(w*0.35, h*0.2, 10, w*0.5, h*0.5, Math.max(w,h));
      g.addColorStop(0, "rgba(124,240,255,0.06)");
      g.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);
    }

    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
      const {x,y,w,h} = box;

      // frame
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 1;
      roundRect(ctx, x, y, w, h, 14);
      ctx.stroke();

      // title
      ctx.fillStyle = "rgba(233,236,255,0.95)";
      ctx.font = "700 13px ui-sans-serif, system-ui";
      ctx.fillText(title, x+12, y+18);

      // plot area margins
      const padL = 58, padR = 18, padT = 32, padB = 44;
      const px = x + padL, py = y + padT, pw = w - padL - padR, ph = h - padT - padB;

      // grid
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;

      const nX = 6, nY = 6;
      for(let i=0;i<=nX;i++){
        const xx = px + (i/nX)*pw;
        ctx.beginPath();
        ctx.moveTo(xx, py);
        ctx.lineTo(xx, py+ph);
        ctx.stroke();
      }
      for(let j=0;j<=nY;j++){
        const yy = py + (j/nY)*ph;
        ctx.beginPath();
        ctx.moveTo(px, yy);
        ctx.lineTo(px+pw, yy);
        ctx.stroke();
      }

      // ticks + labels
      ctx.fillStyle = "rgba(184,192,255,0.95)";
      ctx.font = "12px ui-sans-serif, system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      for(let i=0;i<=nX;i++){
        const t = i/nX;
        const val = xMin + t*(xMax-xMin);
        const xx = px + t*pw;
        ctx.fillText(fmtFixed(val, 3), xx, py+ph+10);
      }

      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      for(let j=0;j<=nY;j++){
        const t = 1 - j/nY;
        const val = yMin + t*(yMax-yMin);
        const yy = py + (j/nY)*ph;
        ctx.fillText(fmtFixed(val, 3), px-10, yy);
      }

      // axis labels
      ctx.save();
      ctx.fillStyle = "rgba(184,192,255,0.95)";
      ctx.font = "600 12px ui-sans-serif, system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(xLabel, px + pw/2, y + h - 18);

      ctx.translate(x+16, py+ph/2);
      ctx.rotate(-Math.PI/2);
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();

      ctx.restore();
      return {plot:{x:px,y:py,w:pw,h:ph}, pad:{padL,padR,padT,padB}};
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function mapX(val, xMin, xMax, plot){
      return plot.x + (val-xMin)/(xMax-xMin)*plot.w;
    }
    function mapY(val, yMin, yMax, plot){
      return plot.y + (1-(val-yMin)/(yMax-yMin))*plot.h;
    }

    function drawPolyline(ctx, xs, ys, xMin, xMax, yMin, yMax, plot, strokeStyle="rgba(124,240,255,0.95)", width=2){
      ctx.save();
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = width;
      ctx.beginPath();
      for(let i=0;i<xs.length;i++){
        const xx = mapX(xs[i], xMin, xMax, plot);
        const yy = mapY(ys[i], yMin, yMax, plot);
        if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawLegend(ctx, box, items){
      // items: [{label, color}]
      const x = box.x + box.w - 18;
      let y = box.y + 16 + 18;
      ctx.save();
      ctx.font = "12px ui-sans-serif, system-ui";
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      items.forEach(it=>{
        ctx.fillStyle = "rgba(184,192,255,0.95)";
        ctx.fillText(it.label, x-22, y);
        ctx.strokeStyle = it.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x-14, y);
        ctx.lineTo(x, y);
        ctx.stroke();
        y += 18;
      });
      ctx.restore();
    }

    // -------------------------
    // Diagram canvas
    // -------------------------
    function drawDiagram(ctx, W, H, dn_m3){
      clear(ctx, W, H);

      const pad = 18;
      const box = {x:pad,y:pad,w:W-2*pad,h:H-2*pad};

      // frame
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 1;
      roundRect(ctx, box.x, box.y, box.w, box.h, 16);
      ctx.stroke();

      // title
      ctx.fillStyle = "rgba(233,236,255,0.95)";
      ctx.font = "700 13px ui-sans-serif, system-ui";
      ctx.fillText("Band-filling picture at T = 0 K (direct transition, same k)", box.x+12, box.y+20);

      // axes area inside
      const ax = box.x + 54, ay = box.y + 40, aw = box.w - 74, ah = box.h - 68;
      // grid
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;
      for(let i=0;i<=6;i++){
        const xx = ax + i/6*aw;
        ctx.beginPath(); ctx.moveTo(xx, ay); ctx.lineTo(xx, ay+ah); ctx.stroke();
      }
      for(let j=0;j<=5;j++){
        const yy = ay + j/5*ah;
        ctx.beginPath(); ctx.moveTo(ax, yy); ctx.lineTo(ax+aw, yy); ctx.stroke();
      }

      // labels
      ctx.fillStyle = "rgba(184,192,255,0.95)";
      ctx.font = "12px ui-sans-serif, system-ui";
      ctx.textAlign = "center";
      ctx.fillText("k (magnitude)", ax + aw/2, box.y + box.h - 16);

      ctx.save();
      ctx.translate(box.x+18, ay + ah/2);
      ctx.rotate(-Math.PI/2);
      ctx.textAlign = "center";
      ctx.fillText("Energy (schematic)", 0, 0);
      ctx.restore();

      // Draw parabolic bands vs k (schematic)
      // k axis in [0, kMaxPlot]
      const kF = kF_from_dn(dn_m3);
      const kMaxPlot = kF * 1.35 + 1e8; // avoid tiny for low dn
      const yMid = ay + ah*0.55; // valence near bottom
      const yTop = ay + ah*0.20; // conduction near top-ish
      const EgPix = (yMid - yTop) * 0.78;

      function kToX(k){ return ax + (k/kMaxPlot)*aw; }
      // energy curves in pixels (pure schematic, not to scale)
      function EcPix(k){
        const t = k/kMaxPlot;
        return (yTop + EgPix) - EgPix + (t*t)*(ah*0.22);
      }
      function EvPix(k){
        const t = k/kMaxPlot;
        return (yMid + (t*t)*(ah*0.22));
      }

      // band curves
      ctx.lineWidth = 2.5;
      ctx.strokeStyle = "rgba(124,240,255,0.9)";
      ctx.beginPath();
      for(let i=0;i<=160;i++){
        const k = i/160*kMaxPlot;
        const xx = kToX(k);
        const yy = EcPix(k);
        if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
      }
      ctx.stroke();

      ctx.strokeStyle = "rgba(167,139,250,0.9)";
      ctx.beginPath();
      for(let i=0;i<=160;i++){
        const k = i/160*kMaxPlot;
        const xx = kToX(k);
        const yy = EvPix(k);
        if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
      }
      ctx.stroke();

      // Shade filled electrons in conduction for k <= kF
      const xKF = kToX(kF);
      ctx.save();
      ctx.fillStyle = "rgba(72,241,166,0.10)";
      ctx.strokeStyle = "rgba(72,241,166,0.35)";
      ctx.lineWidth = 1.5;
      // region under Ec curve for k<=kF
      ctx.beginPath();
      ctx.moveTo(ax, EcPix(0));
      for(let i=0;i<=120;i++){
        const k = i/120*kF;
        ctx.lineTo(kToX(k), EcPix(k));
      }
      ctx.lineTo(xKF, yTop + ah*0.02);
      ctx.lineTo(ax, yTop + ah*0.02);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      // Shade holes in valence for k <= kF (empty valence states)
      ctx.save();
      ctx.fillStyle = "rgba(255,204,102,0.10)";
      ctx.strokeStyle = "rgba(255,204,102,0.35)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(ax, EvPix(0));
      for(let i=0;i<=120;i++){
        const k = i/120*kF;
        ctx.lineTo(kToX(k), EvPix(k));
      }
      ctx.lineTo(xKF, yMid + ah*0.40);
      ctx.lineTo(ax, yMid + ah*0.40);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      // kF marker line
      ctx.save();
      ctx.strokeStyle = "rgba(233,236,255,0.28)";
      ctx.setLineDash([6,5]);
      ctx.beginPath(); ctx.moveTo(xKF, ay); ctx.lineTo(xKF, ay+ah); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(233,236,255,0.92)";
      ctx.font = "600 12px ui-sans-serif, system-ui";
      ctx.textAlign = "center";
      ctx.fillText("k_F", xKF, ay + ah + 10);
      ctx.restore();

      // Example photon transition at some E inside gain window
      const dEmax = (hbar*hbar*kF*kF)/(2*mr);
      const Ecut = Eg + dEmax;

      // Choose a photon energy at 70% of cutoff window above Eg (if possible)
      const Eph = (Ecut > Eg) ? (Eg + 0.70*(Ecut - Eg)) : (Eg + 0.05*q);
      const kph = (Eph >= Eg) ? Math.sqrt(2*mr*(Eph-Eg))/hbar : 0;
      const xk = kToX(kph);

      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.65)";
      ctx.lineWidth = 2;
      // arrow from valence to conduction at kph
      const yv = EvPix(kph);
      const yc = EcPix(kph);
      ctx.beginPath();
      ctx.moveTo(xk, yv);
      ctx.lineTo(xk, yc);
      ctx.stroke();
      // arrow head
      ctx.beginPath();
      ctx.moveTo(xk, yc);
      ctx.lineTo(xk-6, yc+10);
      ctx.lineTo(xk+6, yc+10);
      ctx.closePath();
      ctx.fillStyle = "rgba(255,255,255,0.65)";
      ctx.fill();

      // label
      ctx.fillStyle = "rgba(184,192,255,0.95)";
      ctx.font = "12px ui-sans-serif, system-ui";
      ctx.textAlign = "left";
      ctx.fillText("Photon hÎ½ selects k(Î½)", xk+10, (yc+yv)/2 - 8);
      ctx.fillText("Gain if k(Î½) â‰¤ k_F", xk+10, (yc+yv)/2 + 10);

      // band labels
      ctx.fillStyle = "rgba(124,240,255,0.95)";
      ctx.font = "700 12px ui-sans-serif, system-ui";
      ctx.fillText("Conduction band", ax+8, yTop+14);
      ctx.fillStyle = "rgba(167,139,250,0.95)";
      ctx.fillText("Valence band", ax+8, yMid+18);

      // region labels
      ctx.fillStyle = "rgba(72,241,166,0.92)";
      ctx.font = "600 12px ui-sans-serif, system-ui";
      ctx.fillText("filled eâ» (k â‰¤ k_F)", ax+8, yTop+34);

      ctx.fillStyle = "rgba(255,204,102,0.92)";
      ctx.fillText("holes (empty valence, k â‰¤ k_F)", ax+8, yMid+38);

      ctx.restore();
      ctx.restore();
    }

    // -------------------------
    // Plot 1: sigma_eff vs energy
    // -------------------------
    function drawPlot1(ctx, W, H, dn_m3, scale){
      clear(ctx, W, H);

      const pad = 16;
      const box = {x:pad,y:pad,w:W-2*pad,h:H-2*pad};

      // energy range for plot (eV)
      const Emin_eV = Eg_eV - 0.02;
      const Emax_eV = Eg_eV + 0.55;

      // sample points
      const N = 520;
      const xs = [];
      const ys = [];

      // compute sigma in cm^2
      let yAbsMax = 0;
      for(let i=0;i<N;i++){
        const EeV = Emin_eV + (i/(N-1))*(Emax_eV - Emin_eV);
        const E = EeV * q;
        const s = sigma_eff(E, dn_m3, scale);     // m^2
        const s_cm2 = s * 1e4;                    // (m^2 -> cm^2)
        xs.push(EeV);
        ys.push(s_cm2);
        yAbsMax = Math.max(yAbsMax, Math.abs(s_cm2));
      }
      // symmetric y-limits centered at 0
      const yMax = (yAbsMax > 0) ? yAbsMax*1.10 : 1e-16;
      const yMin = -yMax;

      const axes = drawAxes(
        ctx, box,
        Emin_eV, Emax_eV,
        yMin, yMax,
        "Photon energy E = hÎ½ (eV)",
        "Ïƒ_eff (cmÂ²)",
        "Effective transition cross section vs photon energy"
      );

      // draw zero line
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(axes.plot.x, mapY(0, yMin, yMax, axes.plot));
      ctx.lineTo(axes.plot.x + axes.plot.w, mapY(0, yMin, yMax, axes.plot));
      ctx.stroke();
      ctx.restore();

      // curve
      drawPolyline(ctx, xs, ys, Emin_eV, Emax_eV, yMin, yMax, axes.plot, "rgba(124,240,255,0.95)", 2.5);

      // cutoff marker
      const kF = kF_from_dn(dn_m3);
      const dEmax = (hbar*hbar*kF*kF)/(2*mr); // J
      const Ecut_eV = (Eg + dEmax)/q;

      ctx.save();
      ctx.strokeStyle = "rgba(255,204,102,0.9)";
      ctx.lineWidth = 2;
      ctx.setLineDash([6,5]);
      const xCut = mapX(Ecut_eV, Emin_eV, Emax_eV, axes.plot);
      ctx.beginPath(); ctx.moveTo(xCut, axes.plot.y); ctx.lineTo(xCut, axes.plot.y+axes.plot.h); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(255,204,102,0.95)";
      ctx.font = "600 12px ui-sans-serif, system-ui";
      ctx.textAlign = "left";
      ctx.fillText("cutoff (E_g + Î”E_max)", clamp(xCut+6, axes.plot.x+6, axes.plot.x+axes.plot.w-160), axes.plot.y+14);
      ctx.restore();

      // legend
      drawLegend(ctx, box, [
        {label:"Ïƒ_eff(E)", color:"rgba(124,240,255,0.95)"},
        {label:"cutoff", color:"rgba(255,204,102,0.9)"}
      ]);
    }

    // -------------------------
    // Plot 2: sweep Î”Emax vs Î”n (and Î»_cutoff)
    // -------------------------
    function drawPlot2(ctx, W, H, dn_m3, scale){
      clear(ctx, W, H);

      const pad = 16;
      const box = {x:pad,y:pad,w:W-2*pad,h:H-2*pad};

      // sweep log10 Î”n from 16 to 19 (cm^-3), like slider bounds
      const dnMinLog = 16.0, dnMaxLog = 19.0;
      const N = 260;
      const xs = []; // log10 Î”n (cm^-3)
      const yE = []; // Î”Emax (eV)
      const yL = []; // cutoff wavelength (nm)

      let yEmax = 0;
      let yLmin = 1e12, yLmax = 0;

      for(let i=0;i<N;i++){
        const logcm = dnMinLog + (i/(N-1))*(dnMaxLog - dnMinLog);
        const dn_cm3 = Math.pow(10, logcm);
        const dn = dn_cm3 * 1e6; // to m^-3
        const kF = kF_from_dn(dn);
        const dEmax = (hbar*hbar*kF*kF)/(2*mr); // J
        const dE_eV = dEmax/q;
        const Ecut = Eg + dEmax; // J
        const lambda = (h*c)/Ecut; // m
        const lambda_nm = lambda * 1e9;

        xs.push(logcm);
        yE.push(dE_eV);
        yL.push(lambda_nm);

        yEmax = Math.max(yEmax, dE_eV);
        yLmin = Math.min(yLmin, lambda_nm);
        yLmax = Math.max(yLmax, lambda_nm);
      }

      // We'll plot Î”Emax on left axis (primary) and Î»_cutoff on same plot as a second curve (scaled to right axis visually).
      // To keep a single axis system (as requested), we normalize Î» into the same y-range (simple mapping) and label in legend.
      const yMin = 0;
      const yMax = yEmax*1.12 + 1e-6;

      const axes = drawAxes(
        ctx, box,
        dnMinLog, dnMaxLog,
        yMin, yMax,
        "log10(Î”n) (cmâ»Â³)",
        "Î”E_max (eV)  [Î»_cutoff mapped]",
        "Gain window widening with injection (T = 0 K model)"
      );

      // plot Î”Emax curve
      drawPolyline(ctx, xs, yE, dnMinLog, dnMaxLog, yMin, yMax, axes.plot, "rgba(72,241,166,0.95)", 2.6);

      // map lambda curve into same y-axis range
      // Larger Î”n -> smaller Î». We map Î» into [yMin,yMax] using min/max of Î».
      const yLambdaMapped = yL.map(l => yMin + ( (l - yLmin) / (yLmax - yLmin + 1e-30) ) * (yMax - yMin));
      drawPolyline(ctx, xs, yLambdaMapped, dnMinLog, dnMaxLog, yMin, yMax, axes.plot, "rgba(167,139,250,0.95)", 2.4);

      // highlight current dn point
      const logNow = Math.log10(dn_m3/1e6); // back to cm^-3 log
      const kFnow = kF_from_dn(dn_m3);
      const dEmaxNow = (hbar*hbar*kFnow*kFnow)/(2*mr);
      const dEmaxNow_eV = dEmaxNow/q;
      const EcutNow = Eg + dEmaxNow;
      const lambdaNow_nm = (h*c/EcutNow)*1e9;
      const lambdaNowMapped = yMin + ((lambdaNow_nm - yLmin)/(yLmax - yLmin + 1e-30))*(yMax - yMin);

      ctx.save();
      // marker on Î”E curve
      ctx.fillStyle = "rgba(72,241,166,0.95)";
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 2;
      let x0 = mapX(logNow, dnMinLog, dnMaxLog, axes.plot);
      let y0 = mapY(dEmaxNow_eV, yMin, yMax, axes.plot);
      ctx.beginPath(); ctx.arc(x0,y0,5.5,0,Math.PI*2); ctx.fill(); ctx.stroke();

      // marker on lambda curve
      ctx.fillStyle = "rgba(167,139,250,0.95)";
      y0 = mapY(lambdaNowMapped, yMin, yMax, axes.plot);
      ctx.beginPath(); ctx.arc(x0,y0,5.5,0,Math.PI*2); ctx.fill(); ctx.stroke();

      // small annotation
      ctx.fillStyle = "rgba(184,192,255,0.95)";
      ctx.font = "600 12px ui-sans-serif, system-ui";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      const tx = clamp(x0+10, axes.plot.x+10, axes.plot.x+axes.plot.w-220);
      const ty = clamp(mapY(dEmaxNow_eV, yMin, yMax, axes.plot)-34, axes.plot.y+8, axes.plot.y+axes.plot.h-50);
      ctx.fillText(`Î”E_max â‰ˆ ${fmtFixed(dEmaxNow_eV,3)} eV`, tx, ty);
      ctx.fillText(`Î»_cutoff â‰ˆ ${fmtFixed(lambdaNow_nm,0)} nm`, tx, ty+16);
      ctx.restore();

      // legend
      drawLegend(ctx, box, [
        {label:"Î”E_max (eV)", color:"rgba(72,241,166,0.95)"},
        {label:"Î»_cutoff (mapped)", color:"rgba(167,139,250,0.95)"}
      ]);
    }

    // -------------------------
    // State + UI wiring
    // -------------------------
    const dnSlider = document.getElementById("dn");
    const dnLogSpan = document.getElementById("dnLog");
    const dnValSpan = document.getElementById("dnVal");
    const scaleSel = document.getElementById("modelScale");

    const diagCanvas = document.getElementById("diag");
    const plot1Canvas = document.getElementById("plot1");
    const plot2Canvas = document.getElementById("plot2");

    const diag = setupCanvas(diagCanvas);
    const p1 = setupCanvas(plot1Canvas);
    const p2 = setupCanvas(plot2Canvas);

    function getState(){
      const logcm = parseFloat(dnSlider.value);
      const dn_cm3 = Math.pow(10, logcm);
      const dn_m3 = dn_cm3 * 1e6;
      const scale = parseFloat(scaleSel.value);
      return {logcm, dn_cm3, dn_m3, scale};
    }

    function updateText(state){
      dnLogSpan.textContent = state.logcm.toFixed(2);
      dnValSpan.innerHTML = fmtSci(state.dn_cm3, 3);

      // Update KPI fields in Quick-Answer area? (Optional small dynamic hint via tooltip not needed.)
    }

    function redraw(){
      const st = getState();
      updateText(st);

      // Resize canvases (responsive)
      diag.resize(); p1.resize(); p2.resize();

      // Draw
      const rectD = diagCanvas.getBoundingClientRect();
      drawDiagram(diag.ctx, rectD.width, rectD.height, st.dn_m3);

      const rect1 = plot1Canvas.getBoundingClientRect();
      drawPlot1(p1.ctx, rect1.width, rect1.height, st.dn_m3, st.scale);

      const rect2 = plot2Canvas.getBoundingClientRect();
      drawPlot2(p2.ctx, rect2.width, rect2.height, st.dn_m3, st.scale);
    }

    dnSlider.addEventListener("input", redraw);
    scaleSel.addEventListener("change", redraw);
    window.addEventListener("resize", ()=>{ redraw(); });

    // Initial draw
    redraw();
  </script>
</body>
</html>
