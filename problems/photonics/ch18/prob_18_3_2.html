<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Number of Longitudinal Modes in a Semiconductor Laser Cavity</title>
  <style>
    :root{
      --bg:#0b0f16;
      --panel:#101827;
      --panel2:#0f1b2d;
      --text:#e8eefc;
      --muted:#a9b6d6;
      --faint:#7f8db0;
      --accent:#7aa7ff;
      --accent2:#7dffcc;
      --warn:#ffcc66;
      --danger:#ff6b7a;
      --line:rgba(255,255,255,0.10);
      --shadow: 0 18px 60px rgba(0,0,0,0.45);
      --radius:18px;
      --radius2:22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 10% 10%, rgba(122,167,255,0.22), transparent 55%),
        radial-gradient(900px 700px at 85% 20%, rgba(125,255,204,0.14), transparent 55%),
        radial-gradient(900px 700px at 30% 95%, rgba(255,204,102,0.10), transparent 50%),
        linear-gradient(180deg, #070a10, var(--bg));
      line-height:1.55;
    }

    header{
      position:relative;
      padding:40px 18px 22px;
      max-width:1200px;
      margin:0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.25fr 0.75fr;
      gap:18px;
      align-items:stretch;
    }
    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border:1px solid var(--line);
      border-radius: var(--radius2);
      padding:22px 22px 18px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
      min-height: 180px;
    }
    .titleCard:before{
      content:"";
      position:absolute;
      inset:-1px;
      background:
        radial-gradient(600px 200px at 20% 10%, rgba(122,167,255,0.20), transparent 60%),
        radial-gradient(500px 220px at 90% 20%, rgba(125,255,204,0.16), transparent 55%);
      pointer-events:none;
      filter: blur(0.2px);
    }
    h1{
      margin:0 0 10px;
      font-size: clamp(22px, 3vw, 34px);
      letter-spacing:0.2px;
      position:relative;
    }
    .subtitle{
      position:relative;
      margin:0;
      color:var(--muted);
      font-size: 14.5px;
      max-width: 72ch;
    }
    .meta{
      margin-top:14px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      position:relative;
    }
    .pill{
      font-size:12px;
      color:var(--muted);
      border:1px solid var(--line);
      background: rgba(16,24,39,0.55);
      padding:6px 10px;
      border-radius: 999px;
      backdrop-filter: blur(6px);
    }

    .toc{
      background: linear-gradient(180deg, rgba(16,24,39,0.72), rgba(16,24,39,0.48));
      border:1px solid var(--line);
      border-radius: var(--radius2);
      padding:14px 14px 12px;
      box-shadow: var(--shadow);
      position: sticky;
      top: 14px;
      align-self:start;
      max-height: calc(100vh - 28px);
      overflow:auto;
    }
    .toc h2{
      margin:6px 6px 10px;
      font-size:13px;
      color:var(--muted);
      font-weight:650;
      letter-spacing:0.3px;
      text-transform: uppercase;
    }
    .toc a{
      display:block;
      padding:8px 10px;
      margin:4px 0;
      border-radius:12px;
      color:var(--text);
      text-decoration:none;
      border:1px solid transparent;
      background: rgba(255,255,255,0.03);
      transition: transform 140ms ease, background 140ms ease, border-color 140ms ease;
      font-size: 13px;
      line-height:1.25;
    }
    .toc a:hover{
      transform: translateY(-1px);
      background: rgba(122,167,255,0.10);
      border-color: rgba(122,167,255,0.25);
    }

    main{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 18px 40px;
    }

    section{
      margin-top: 18px;
      background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
      border:1px solid var(--line);
      border-radius: var(--radius2);
      padding: 18px;
      box-shadow: var(--shadow);
    }

    section h2{
      margin: 4px 0 10px;
      font-size: 18px;
      letter-spacing:0.2px;
    }
    section h3{
      margin: 14px 0 8px;
      font-size: 15px;
      color: var(--muted);
      font-weight: 650;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 14px;
    }

    .card{
      border:1px solid var(--line);
      background: rgba(16,24,39,0.55);
      border-radius: 16px;
      padding: 14px;
      min-height: 70px;
    }
    .card p, .card li {color: var(--muted)}
    .card strong{color: var(--text)}
    .callout{
      border-left: 4px solid rgba(122,167,255,0.85);
      background: rgba(122,167,255,0.08);
    }
    .callout.warn{
      border-left-color: rgba(255,204,102,0.95);
      background: rgba(255,204,102,0.10);
    }
    .callout.danger{
      border-left-color: rgba(255,107,122,0.95);
      background: rgba(255,107,122,0.10);
    }
    .eq{
      font-family: var(--mono);
      background: rgba(0,0,0,0.22);
      border: 1px solid rgba(255,255,255,0.10);
      padding: 10px 12px;
      border-radius: 14px;
      overflow:auto;
      position:relative;
      margin: 10px 0 8px;
      color: #eaf1ff;
    }
    .eq small{color: var(--faint)}
    .copyRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      margin-top: 6px;
    }
    button.copyBtn{
      border:1px solid rgba(122,167,255,0.30);
      background: rgba(122,167,255,0.12);
      color: var(--text);
      padding: 7px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-size: 12.5px;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      user-select:none;
    }
    button.copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(122,167,255,0.18);
      border-color: rgba(122,167,255,0.50);
    }
    .kpi{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .kpi .num{
      font-size: 22px;
      font-weight: 750;
      letter-spacing:0.2px;
    }
    .kpi .lab{
      color: var(--muted);
      font-size: 12.5px;
    }

    .vizWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }
    .vizPanel{
      border:1px solid var(--line);
      border-radius: 18px;
      background: rgba(16,24,39,0.50);
      overflow:hidden;
    }
    .vizHead{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      background: rgba(0,0,0,0.12);
    }
    .vizHead .title{
      font-weight: 700;
      color: var(--text);
      font-size: 13px;
      letter-spacing:0.2px;
    }
    .vizHead .sub{
      font-size: 12px;
      color: var(--muted);
    }
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:10px 12px;
      padding: 12px 14px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.02);
    }
    .control{
      flex: 1 1 220px;
      min-width: 220px;
      border:1px solid rgba(255,255,255,0.10);
      border-radius: 16px;
      padding: 10px 12px;
      background: rgba(0,0,0,0.18);
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size: 12.5px;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .control .val{
      font-family: var(--mono);
      color: var(--text);
      font-size: 12.5px;
      white-space:nowrap;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .canvasRow{
      padding: 10px 10px 14px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
      background: rgba(7,10,16,0.55);
      border:1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
    }
    .smallCanvas canvas{height: 280px;}
    .footnote{
      color: var(--muted);
      font-size: 12.5px;
      margin-top: 6px;
    }

    ul{
      margin: 8px 0 0 18px;
    }
    li{margin: 6px 0}
    .hr{
      height:1px;
      background: rgba(255,255,255,0.10);
      margin: 14px 0;
    }

    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 0 18px 30px;
      color: var(--muted);
      font-size: 12.5px;
    }

    @media (max-width: 980px){
      .hero{grid-template-columns: 1fr}
      .toc{position:relative; top:auto; max-height:none}
      .grid2, .grid3{grid-template-columns: 1fr}
      canvas{height: 300px}
    }

    @media print{
      body{background:#fff; color:#000}
      header, main, section{box-shadow:none}
      .toc{display:none}
      canvas{border:1px solid #ccc}
      .titleCard, section, .vizPanel, .card{background:#fff}
      .eq{background:#fff}
      button.copyBtn{display:none}
    }

    /* subtle motion */
    @keyframes floatIn {
      from {transform: translateY(6px); opacity: 0.0;}
      to   {transform: translateY(0); opacity: 1.0;}
    }
    section, .titleCard, .toc {animation: floatIn 260ms ease both;}
  </style>
</head>

<body>
<header>
  <div class="hero">
    <div class="titleCard">
      <h1>18.3-2 — Maximum Number of Longitudinal Modes That Can Oscillate</h1>
      <p class="subtitle">
        We connect semiconductor gain physics (quasi-Fermi level separation) to Fabry–Perot cavity mode spacing to count
        how many longitudinal resonances fit inside the available gain window.
      </p>
      <div class="meta">
        <span class="pill">Topic: semiconductor lasers</span>
        <span class="pill">Key idea: gain bandwidth vs. cavity mode spacing</span>
        <span class="pill">Result: mode count (integer)</span>
      </div>
    </div>

    <nav class="toc" aria-label="Table of contents">
      <h2>Contents</h2>
      <a href="#quick">Quick Summary</a>
      <a href="#part0">PART 0 — Concept Primer</a>
      <a href="#part1">PART 1 — Problem Analysis</a>
      <a href="#part2">PART 2 — Strategy & Tips</a>
      <a href="#part3">PART 3 — Full Solution</a>
      <a href="#part4">PART 4 — Deeper Understanding</a>
      <a href="#part5">PART 5 — Visualization Guide</a>
    </nav>
  </div>
</header>

<main>
  <!-- Quick Summary -->
  <section id="quick">
    <h2>Quick Summary</h2>
    <ul>
      <li><b>What this problem is about:</b> counting how many <b>longitudinal Fabry–Perot cavity modes</b> can lase in a semiconductor diode.</li>
      <li><b>Key physics idea:</b> lasing is possible only for photon energies where the material provides <b>net optical gain</b>; here that window is set by the <b>quasi-Fermi level separation</b>.</li>
      <li><b>Gain window (energy):</b> approximately <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">E_g ≤ hν ≤ (E_fc − E_fv)</span>.</li>
      <li><b>Convert to frequency bandwidth:</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_gain = ((E_fc − E_fv) − E_g)/h</span>.</li>
      <li><b>Longitudinal mode spacing:</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_mode = c/(2nd)</span>.</li>
      <li><b>Mode count estimate:</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">N_max ≈ Δν_gain/Δν_mode</span> (rounded down to an integer; optionally +1 depending on endpoint convention).</li>
      <li><b>Numeric result (given values):</b> about <b>70 longitudinal modes</b> can oscillate (order-of-magnitude tens to ~100).</li>
    </ul>
  </section>

  <!-- PART 0 -->
  <section id="part0">
    <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

    <div class="grid2">
      <article class="card">
        <h3>Core definitions (symbols & units)</h3>
        <ul>
          <li><b>Bandgap energy</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">E_g</span> (eV or J): minimum photon energy for band-to-band transitions.</li>
          <li><b>Quasi-Fermi levels</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">E_{fc}, E_{fv}</span> (eV): separate effective Fermi levels for electrons and holes under injection.</li>
          <li><b>Quasi-Fermi separation</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">ΔF = E_{fc} − E_{fv}</span> (eV): sets the maximum photon energy that can be amplified.</li>
          <li><b>Refractive index</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">n</span> (dimensionless): reduces phase velocity inside the cavity to <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">c/n</span>.</li>
          <li><b>Cavity length</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">d</span> (m): mirror separation (Fabry–Perot resonator).</li>
          <li><b>Optical frequency</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">ν</span> (Hz) and photon energy <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">E = hν</span>.</li>
        </ul>
      </article>

      <article class="card">
        <h3>Physical meaning (what these represent)</h3>
        <ul>
          <li><b>Longitudinal modes</b> are standing-wave solutions along the cavity axis. Each mode corresponds to an integer number of half-wavelengths fitting into the optical path length <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">nd</span>.</li>
          <li><b>Gain window</b>: the semiconductor can only provide amplification for photon energies where stimulated emission exceeds absorption. Under injection, this is controlled by how far apart the quasi-Fermi levels are.</li>
          <li><b>“No losses”</b> idealization: if mirrors and internal absorption introduce no loss, then <i>any</i> cavity mode inside the gain window can reach oscillation (threshold is effectively zero).</li>
        </ul>
      </article>
    </div>

    <div class="grid2" style="margin-top:14px;">
      <article class="card callout">
        <h3>Key laws / principles (validity & assumptions)</h3>
        <ul>
          <li><b>Fabry–Perot resonance condition:</b> a round trip phase must be an integer multiple of <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">2π</span>, giving mode spacing <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_mode = c/(2nd)</span>.</li>
          <li><b>Semiconductor gain onset:</b> net gain for photons roughly between <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">E_g</span> and <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">ΔF</span> (simple band-to-band picture, ignoring detailed lineshape).</li>
          <li><b>Counting modes:</b> number of resonances inside a bandwidth is approximately bandwidth divided by spacing.</li>
        </ul>
      </article>

      <article class="card callout warn">
        <h3>Common models / approximations (why used)</h3>
        <ul>
          <li><b>Rectangular gain window</b>: treat gain as nonzero for <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">E_g ≤ hν ≤ ΔF</span>. Real gain is peaked and finite-width, but this model gives a clean upper bound.</li>
          <li><b>Uniform index</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">n</span> and uniform cavity: ignores dispersion and waveguide effects; adequate for mode spacing estimates.</li>
          <li><b>No losses</b>: converts “which modes reach threshold?” into “which modes are inside gain?”.</li>
        </ul>
      </article>
    </div>

    <div class="grid2" style="margin-top:14px;">
      <article class="card">
        <h3>Mini intuition examples (quick)</h3>
        <ul>
          <li>If the cavity is made <b>longer</b>, mode spacing <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_mode</span> becomes <b>smaller</b>, so <b>more modes</b> fit into the same gain bandwidth.</li>
          <li>If injection increases <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">ΔF</span>, the gain window widens to higher energies (higher frequencies), so again <b>more modes</b> can oscillate.</li>
        </ul>
      </article>

      <article class="card callout danger">
        <h3>What to watch for (pitfalls)</h3>
        <ul>
          <li>Mixing <b>energy bandwidth</b> (eV) with <b>frequency bandwidth</b> (Hz) without dividing by <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">h</span>.</li>
          <li>Using the vacuum spacing <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">c/(2d)</span> instead of the medium spacing <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">c/(2nd)</span>.</li>
          <li>For mode count, deciding whether to add <b>+1</b> depends on whether you count both endpoints; the scale here is “tens”, so be clear about convention.</li>
        </ul>
      </article>
    </div>
  </section>

  <!-- PART 1 -->
  <section id="part1">
    <h2>PART 1 — Problem Analysis (No solving yet)</h2>

    <article class="card">
      <h3>Problem restatement (in plain words)</h3>
      <p>
        An InGaAsP diode laser has bandgap energy <b>E<sub>g</sub> = 0.91 eV</b>. Current injection produces a quasi-Fermi level
        separation <b>ΔF = E<sub>fc</sub> − E<sub>fv</sub> = 0.96 eV</b>. The laser forms a Fabry–Perot cavity of length
        <b>d = 250 μm</b> with refractive index <b>n = 3.5</b>. Assuming the resonator has <b>no losses</b>, find the
        <b>maximum number of longitudinal cavity modes</b> that can oscillate.
      </p>
    </article>

    <div class="grid2" style="margin-top:14px;">
      <article class="card">
        <h3>Given quantities</h3>
        <ul>
          <li><span class="eq">E_g = 0.91 eV</span></li>
          <li><span class="eq">ΔF = E_{fc} - E_{fv} = 0.96 eV</span></li>
          <li><span class="eq">n = 3.5</span></li>
          <li><span class="eq">d = 250 μm = 250 × 10^{-6} m</span></li>
          <li>Lossless cavity (idealized)</li>
        </ul>
      </article>

      <article class="card">
        <h3>Unknowns / what must be found</h3>
        <ul>
          <li><b>Maximum number of longitudinal modes</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">N_max</span> that can oscillate.</li>
          <li>Intermediate: gain bandwidth <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_gain</span> and mode spacing <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_mode</span>.</li>
        </ul>
      </article>
    </div>

    <div class="grid2" style="margin-top:14px;">
      <article class="card callout">
        <h3>Relevant principles (and why they apply)</h3>
        <ul>
          <li><b>Semiconductor gain condition:</b> Under injection, optical gain exists for photon energies roughly satisfying
            <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">E_g ≤ hν ≤ ΔF</span>.
            This is the simplest “available inversion window” argument.</li>
          <li><b>Fabry–Perot longitudinal resonances:</b> Mode spacing in frequency is
            <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_mode = c/(2nd)</span>.
            This directly counts how densely modes sit along the frequency axis.</li>
        </ul>
      </article>

      <article class="card">
        <h3>Assumptions (explicit)</h3>
        <ul>
          <li>Uniform refractive index <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">n</span>; ignore dispersion across the small bandwidth.</li>
          <li>Gain exists throughout the full interval <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">[E_g, ΔF]</span> (upper-bound model).</li>
          <li>Lossless cavity: any mode inside the gain window can oscillate; no threshold filtering.</li>
        </ul>
      </article>
    </div>

    <article class="card" style="margin-top:14px;">
      <h3>Possible approaches (compare & choose)</h3>
      <ul>
        <li><b>Approach A (best):</b> Convert the gain energy window to a frequency window, compute cavity mode spacing in frequency, then take a ratio.
          <br/><span style="color:var(--faint)">Pros: direct, minimal assumptions, matches what’s asked. Cons: endpoint rounding convention.</span>
        </li>
        <li><b>Approach B:</b> Convert energies to wavelengths and use cavity wavelength spacing near a central wavelength.
          <br/><span style="color:var(--faint)">Pros: intuitive if you think in wavelength. Cons: wavelength spacing varies with wavelength, so you must linearize carefully.</span>
        </li>
        <li><b>Approach C:</b> Estimate mode index range using resonance condition <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">mλ = 2nd</span> at the endpoints.
          <br/><span style="color:var(--faint)">Pros: mode counting by integers. Cons: must handle λ↔ν conversion and large m; A is cleaner.</span>
        </li>
      </ul>
      <p class="footnote"><b>Choice:</b> We use <b>Approach A</b> because both the gain window and the cavity spacing are naturally expressed in <b>frequency</b>.</p>
    </article>
  </section>

  <!-- PART 2 -->
  <section id="part2">
    <h2>PART 2 — Strategy & Tips (Roadmap only)</h2>

    <article class="card">
      <ol style="margin:8px 0 0 18px; color:var(--muted)">
        <li><b>Goal:</b> find the available photon <b>energy</b> interval for gain.
          <br/><b>Tool:</b> quasi-Fermi condition <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">E_g ≤ hν ≤ ΔF</span>.
          <br/><span style="color:var(--faint)">Meaning:</span> only those photon energies can be amplified.</li>

        <li><b>Goal:</b> convert that energy interval into a <b>frequency bandwidth</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_gain</span>.
          <br/><b>Tool:</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">E = hν</span> → <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν = ΔE/h</span>.
          <br/><span style="color:var(--faint)">Meaning:</span> how wide the “lasing-allowed” frequency window is.</li>

        <li><b>Goal:</b> compute cavity longitudinal mode spacing <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_mode</span>.
          <br/><b>Tool:</b> Fabry–Perot spacing <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_mode = c/(2nd)</span>.
          <br/><span style="color:var(--faint)">Meaning:</span> how far apart resonant frequencies are.</li>

        <li><b>Goal:</b> count modes in the window.
          <br/><b>Tool:</b> ratio <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">N_max ≈ Δν_gain / Δν_mode</span>, then round down (and discuss +1 convention).
          <br/><span style="color:var(--faint)">Meaning:</span> maximum number of longitudinal standing-wave frequencies that can be amplified.</li>

        <li><b>Goal:</b> sanity checks.
          <br/><b>Tool:</b> units (Hz), scaling with <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">d</span> and <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">ΔF</span>.
          <br/><span style="color:var(--faint)">Meaning:</span> confirm the result is physically reasonable (tens of modes for a 250 μm cavity).</li>
      </ol>
    </article>

    <div class="grid2" style="margin-top:14px;">
      <article class="card callout warn">
        <h3>Common mistakes</h3>
        <ul>
          <li>Forgetting <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">n</span> in <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_mode</span> (using vacuum spacing).</li>
          <li>Using <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">ħ</span> instead of <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">h</span> (would introduce a factor of <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">2π</span> error).</li>
          <li>Counting modes in wavelength without linearizing properly.</li>
        </ul>
      </article>

      <article class="card callout">
        <h3>Quick tips</h3>
        <ul>
          <li>Do the bandwidth in <b>frequency</b>, not wavelength, unless you carefully convert using differentials.</li>
          <li>When the answer is a “maximum number,” it’s fine to compute a real number and then take the <b>integer part</b>.</li>
          <li>If you’re unsure about “+1”, report the convention: “about 70 modes (≈70.5 spacings).”</li>
        </ul>
      </article>
    </div>
  </section>

  <!-- PART 3 -->
  <section id="part3">
    <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

    <article class="card">
      <h3>Physical intuition (before calculating)</h3>
      <p>
        A Fabry–Perot cavity supports a <b>comb</b> of resonant frequencies separated by <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_mode</span>.
        The semiconductor gain, however, only exists over a <b>finite frequency window</b> determined by injection (quasi-Fermi splitting).
        In a <b>lossless</b> resonator, every resonance inside that gain window is eligible to oscillate.
        So the maximum number of modes is essentially:
        <b>(gain bandwidth) ÷ (mode spacing)</b>.
      </p>
    </article>

    <div class="grid2" style="margin-top:14px;">
      <article class="card">
        <h3>Step 1 — Gain window in photon energy</h3>
        <p>
          Let the photon energy be <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">E = hν</span>.
          In the simple band-to-band picture under injection, stimulated emission can dominate absorption when the photon energy lies between:
        </p>
        <div class="eq" id="eq_gainwindow">
          E_g ≤ hν ≤ ΔF  &nbsp;&nbsp;&nbsp;where&nbsp; ΔF = E_fc − E_fv
          <br/><small>(Rectangular-gain-window approximation: used for an upper-bound mode count.)</small>
        </div>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="eq_gainwindow">Copy equation</button>
        </div>
        <p class="footnote">
          <b>Why?</b> Below <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">E_g</span> you can’t make a band-to-band photon. Above <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">ΔF</span>, the carriers do not provide inversion for those higher-energy transitions in this simplified picture.
        </p>
      </article>

      <article class="card">
        <h3>Step 2 — Convert energy bandwidth to frequency bandwidth</h3>
        <p>
          The energy interval width is:
        </p>
        <div class="eq" id="eq_dE">
          ΔE = ΔF − E_g
        </div>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="eq_dE">Copy equation</button>
        </div>

        <p>
          Using <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">E = hν</span>, an energy bandwidth corresponds to a frequency bandwidth:
        </p>
        <div class="eq" id="eq_dnu_gain">
          Δν_gain = ΔE / h = (ΔF − E_g) / h
        </div>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="eq_dnu_gain">Copy equation</button>
        </div>

        <p class="footnote">
          <b>Meaning:</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_gain</span> is the frequency range over which the material can (ideally) amplify light.
        </p>
      </article>
    </div>

    <div class="grid2" style="margin-top:14px;">
      <article class="card">
        <h3>Step 3 — Longitudinal mode spacing of a Fabry–Perot cavity</h3>
        <p>
          For a cavity of length <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">d</span> filled with index <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">n</span>,
          the round-trip optical path length is <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">2nd</span>.
          Adjacent longitudinal resonances are separated by:
        </p>
        <div class="eq" id="eq_modespacing">
          Δν_mode = c / (2 n d)
        </div>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="eq_modespacing">Copy equation</button>
        </div>
        <p class="footnote">
          <b>Why?</b> The resonance condition is that an integer number of half-wavelengths fits into the cavity, which produces evenly spaced frequencies in a uniform medium.
        </p>
      </article>

      <article class="card">
        <h3>Step 4 — Count how many modes fit inside the gain window</h3>
        <p>
          If the gain window has width <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_gain</span> and modes are spaced by <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_mode</span>,
          then an upper-bound mode count is:
        </p>
        <div class="eq" id="eq_modecount">
          N_max ≈ Δν_gain / Δν_mode = ((ΔF − E_g)/h) / (c/(2nd))
          = (2 n d / (h c)) (ΔF − E_g)
        </div>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="eq_modecount">Copy equation</button>
        </div>
        <p class="footnote">
          <b>Interpretation:</b> longer cavities (<span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">d</span> larger) and wider gain windows (<span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">ΔF−E_g</span> larger) increase the number of allowed modes.
        </p>
      </article>
    </div>

    <article class="card" style="margin-top:14px;">
      <h3>Step 5 — Plug in the numbers (carefully)</h3>

      <div class="grid3">
        <div class="card">
          <div class="kpi">
            <div class="num" id="kpi_dE">—</div>
            <div class="lab">Energy window ΔE = ΔF − E<sub>g</sub> (eV)</div>
          </div>
        </div>
        <div class="card">
          <div class="kpi">
            <div class="num" id="kpi_dnuGain">—</div>
            <div class="lab">Gain bandwidth Δν<sub>gain</sub> (THz)</div>
          </div>
        </div>
        <div class="card">
          <div class="kpi">
            <div class="num" id="kpi_dnuMode">—</div>
            <div class="lab">Mode spacing Δν<sub>mode</sub> (GHz)</div>
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <p>
        Compute the gain energy width:
        <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">ΔE = 0.96 − 0.91 = 0.05 eV</span>.
      </p>

      <p>
        Convert to frequency bandwidth. Using <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">1 eV = 1.602×10^{-19} J</span> and
        <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">h = 6.626×10^{-34} J·s</span>:
      </p>

      <div class="eq" id="eq_numeric_dnu">
        Δν_gain = (0.05 eV)(1.602×10^{-19} J/eV) / (6.626×10^{-34} J·s)
        ≈ 1.21×10^{13} Hz  (≈ 12.1 THz)
      </div>
      <div class="copyRow">
        <button class="copyBtn" data-copy-target="eq_numeric_dnu">Copy calculation</button>
      </div>

      <p>
        Mode spacing:
      </p>
      <div class="eq" id="eq_numeric_spacing">
        Δν_mode = c/(2nd) = (3.00×10^8 m/s) / (2·3.5·250×10^{-6} m)
        ≈ 1.71×10^{11} Hz  (≈ 171 GHz)
      </div>
      <div class="copyRow">
        <button class="copyBtn" data-copy-target="eq_numeric_spacing">Copy calculation</button>
      </div>

      <p>
        Therefore:
      </p>
      <div class="eq" id="eq_numeric_N">
        N_max ≈ Δν_gain / Δν_mode ≈ (1.21×10^{13})/(1.71×10^{11}) ≈ 70.5
      </div>
      <div class="copyRow">
        <button class="copyBtn" data-copy-target="eq_numeric_N">Copy calculation</button>
      </div>

      <div class="card callout" style="margin-top:12px;">
        <h3>Final Answer (boxed)</h3>
        <div class="eq" id="final_answer">
          Maximum number of longitudinal modes that can oscillate:
          N_max ≈ 70 (about seventy modes; ≈70.5 spacings within the gain window).
        </div>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="final_answer">Copy final answer</button>
        </div>
        <p class="footnote">
          <b>Rounding note:</b> If you count both endpoints as potentially lasing, you might report <b>~71</b>.
          The physically meaningful conclusion is that the maximum is <b>O(10^2)</b>, specifically around <b>70</b> for the given parameters.
        </p>
      </div>

      <div class="grid2" style="margin-top:12px;">
        <article class="card">
          <h3>Sanity checks</h3>
          <ul>
            <li><b>Units:</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_gain</span> and <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_mode</span> are both in Hz, so their ratio is dimensionless (good).</li>
            <li><b>Limiting case:</b> If <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">d</span> doubles, <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_mode</span> halves → <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">N_max</span> doubles (more modes fit). This matches intuition.</li>
            <li><b>Physical interpretation:</b> The injection provides only a modest energy window (0.05 eV), yet the cavity is short enough that mode spacing is large (~171 GHz). The ratio naturally lands in the tens.</li>
          </ul>
        </article>
        <article class="card">
          <h3>Connection to the diagram & plots</h3>
          <p>
            The diagram shows a Fabry–Perot diode cavity where longitudinal standing waves form between cleaved facets.
            The main plot draws the <b>gain window</b> (between <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">E_g</span> and <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">ΔF</span>, converted to frequency) and overlays vertical lines for each cavity resonance.
            The counted lines inside the window correspond to <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">N_max</span>.
          </p>
        </article>
      </div>
    </article>
  </section>

  <!-- PART 4 -->
  <section id="part4">
    <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

    <div class="grid2">
      <article class="card callout">
        <h3>Re-interpreting the final formula</h3>
        <p style="color:var(--muted); margin:0 0 8px;">
          From
          <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">N_max ≈ (2nd/(hc)) (ΔF − E_g)</span>,
          each factor has a clean meaning:
        </p>
        <ul>
          <li><b>(ΔF − E<sub>g</sub>)</b>: how much “excess” energy range injection opens beyond the bandgap → sets gain bandwidth.</li>
          <li><b>2nd/c</b>: round-trip time in the cavity → larger time means denser frequency resonances.</li>
          <li><b>1/h</b>: converts energy bandwidth into frequency bandwidth.</li>
        </ul>
      </article>

      <article class="card">
        <h3>How parameters change the outcome (connect to plots)</h3>
        <ul>
          <li>Increase <b>cavity length</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">d</span> → mode spacing decreases → <b>N increases linearly with d</b>.</li>
          <li>Increase <b>index</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">n</span> → mode spacing decreases → <b>N increases linearly with n</b>.</li>
          <li>Increase <b>injection splitting</b> <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">ΔF</span> → gain window widens → <b>N increases linearly with (ΔF − E_g)</b>.</li>
          <li>If <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">ΔF ≤ E_g</span>, there is <b>no gain window</b> in this model → <b>N ≈ 0</b>.</li>
        </ul>
      </article>
    </div>

    <div class="grid2" style="margin-top:14px;">
      <article class="card">
        <h3>Alternative derivation idea (brief)</h3>
        <p>
          Use the resonance condition <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">mλ = 2nd</span>.
          Convert the gain endpoints to wavelengths <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">λ_g = hc/E_g</span> and <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">λ_F = hc/ΔF</span>,
          then compute the difference in mode index <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">m</span> across that interval. You must handle that wavelength spacing is not uniform with frequency, which is why the frequency method is cleaner.
        </p>
      </article>

      <article class="card callout warn">
        <h3>Concept check (quick self-test)</h3>
        <ul>
          <li><b>Q:</b> If the cavity length is halved, what happens to the mode spacing?<br/><b>A:</b> It doubles (<span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_mode ∝ 1/d</span>).</li>
          <li><b>Q:</b> Why do we divide by <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">h</span> and not <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">ħ</span>?<br/><b>A:</b> Because <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">E = hν</span> uses frequency (Hz), while <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">E = ħω</span> uses angular frequency (rad/s).</li>
          <li><b>Q:</b> What physical assumption makes this an “upper bound”?<br/><b>A:</b> We assumed no losses and a flat gain window; real cavities have thresholds and gain spectra that reduce the number of lasing modes.</li>
        </ul>
      </article>
    </div>
  </section>

  <!-- PART 5 -->
  <section id="part5">
    <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

    <article class="card">
      <h3>What each canvas shows</h3>
      <ul>
        <li><b>Diagram canvas:</b> a labeled Fabry–Perot diode cavity of length <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">d</span> and index <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">n</span>, with standing-wave longitudinal modes.</li>
        <li><b>Main plot:</b> frequency axis showing the <b>gain-allowed window</b> (from <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">ν_g = E_g/h</span> to <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">ν_F = ΔF/h</span>) and vertical lines marking cavity resonances separated by <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_mode</span>.</li>
        <li><b>Secondary plot:</b> a parameter sweep of <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">N_max</span> versus cavity length <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">d</span> (holding other parameters fixed), with your current setting highlighted.</li>
      </ul>
    </article>

    <article class="card" style="margin-top:14px;">
      <h3>Interactive controls (what changes & why)</h3>
      <ul>
        <li><b>Cavity length slider</b> changes <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">d</span> → updates mode spacing <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_mode = c/(2nd)</span> → changes how many resonance lines fit in the gain window (all plots update).</li>
        <li><b>Quasi-Fermi separation slider</b> changes <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">ΔF</span> → changes gain bandwidth <span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">Δν_gain</span> → changes the number of eligible modes (all plots update).</li>
      </ul>
      <p class="footnote">
        The plotted symbols (<span class="eq" style="display:inline-block; padding:2px 8px; border-radius:10px;">E_g, ΔF, n, d</span>) match exactly the ones used in the derivation above.
      </p>
    </article>

    <!-- Visualizations -->
    <div class="vizWrap" style="margin-top:14px;">
      <div class="vizPanel">
        <div class="vizHead">
          <div>
            <div class="title">Interactive Visuals: Cavity + Mode Counting</div>
            <div class="sub">Adjust parameters; all canvases update live (high-DPI aware).</div>
          </div>
          <div class="sub" id="liveSummary">—</div>
        </div>

        <div class="controls" role="group" aria-label="Interactive controls">
          <div class="control">
            <label>
              <span>Cavity length <b>d</b> (μm)</span>
              <span class="val" id="val_d">250</span>
            </label>
            <input id="slider_d" type="range" min="50" max="1000" step="1" value="250" />
          </div>

          <div class="control">
            <label>
              <span>Quasi-Fermi separation <b>ΔF</b> (eV)</span>
              <span class="val" id="val_dF">0.96</span>
            </label>
            <input id="slider_dF" type="range" min="0.91" max="1.10" step="0.001" value="0.96" />
          </div>

          <div class="control">
            <label>
              <span>Refractive index <b>n</b></span>
              <span class="val" id="val_n">3.5</span>
            </label>
            <input id="slider_n" type="range" min="2.5" max="4.2" step="0.01" value="3.5" />
          </div>
        </div>

        <div class="canvasRow">
          <div class="vizPanel" style="border:none; background:transparent;">
            <div class="vizHead" style="border:1px solid rgba(255,255,255,0.08); border-radius:16px;">
              <div class="title">Diagram — Fabry–Perot diode cavity</div>
              <div class="sub">Geometry and standing-wave longitudinal modes</div>
            </div>
            <div style="padding:10px;">
              <canvas id="cDiagram" aria-label="Fabry-Perot cavity diagram"></canvas>
              <div class="footnote">Diagram is schematic (not to scale); it highlights the optical path length <b>nd</b> that controls mode spacing.</div>
            </div>
          </div>

          <div class="vizPanel" style="border:none; background:transparent;">
            <div class="vizHead" style="border:1px solid rgba(255,255,255,0.08); border-radius:16px;">
              <div class="title">Main plot — Gain window vs. cavity resonances (frequency domain)</div>
              <div class="sub">Vertical lines: longitudinal modes; shaded band: gain-allowed frequencies</div>
            </div>
            <div style="padding:10px;">
              <canvas id="cMain" aria-label="Gain window and cavity modes plot"></canvas>
              <div class="footnote">Count the resonance lines inside the shaded band to visualize <b>N<sub>max</sub></b>.</div>
            </div>
          </div>

          <div class="vizPanel smallCanvas" style="border:none; background:transparent;">
            <div class="vizHead" style="border:1px solid rgba(255,255,255,0.08); border-radius:16px;">
              <div class="title">Secondary plot — Mode count sweep: N<sub>max</sub> vs. cavity length</div>
              <div class="sub">Shows the linear scaling of mode count with d</div>
            </div>
            <div style="padding:10px;">
              <canvas id="cSweep" aria-label="Mode count versus cavity length sweep"></canvas>
              <div class="footnote">The highlighted marker corresponds to your current <b>d</b> setting.</div>
            </div>
          </div>

        </div>
      </div>
    </div>

  </section>
</main>

<footer>
  <div class="hr"></div>
  <p>
    Notes: This is an idealized “maximum possible modes” estimate. Real diode lasers typically lase on far fewer modes due to
    finite gain spectrum, spatial hole burning, mirror/internal losses, and mode competition. The math here is still the right
    starting point: <b>available gain bandwidth</b> divided by <b>cavity mode spacing</b>.
  </p>
</footer>

<script>
(function(){
  // ---------- Constants ----------
  const c = 2.99792458e8;              // m/s
  const h = 6.62607015e-34;            // J*s
  const eV = 1.602176634e-19;          // J per eV
  const Eg_eV_fixed = 0.91;            // given bandgap energy (eV)

  // ---------- Elements ----------
  const sliderD = document.getElementById('slider_d');
  const sliderDF = document.getElementById('slider_dF');
  const sliderN = document.getElementById('slider_n');

  const valD = document.getElementById('val_d');
  const valDF = document.getElementById('val_dF');
  const valN = document.getElementById('val_n');

  const kpi_dE = document.getElementById('kpi_dE');
  const kpi_dnuGain = document.getElementById('kpi_dnuGain');
  const kpi_dnuMode = document.getElementById('kpi_dnuMode');

  const liveSummary = document.getElementById('liveSummary');

  const cDiagram = document.getElementById('cDiagram');
  const cMain = document.getElementById('cMain');
  const cSweep = document.getElementById('cSweep');

  // Copy buttons
  function getPlainTextFromNode(id){
    const el = document.getElementById(id);
    if(!el) return '';
    return el.innerText.replace(/\u00A0/g,' ').trim();
  }
  document.querySelectorAll('button.copyBtn').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const target = btn.getAttribute('data-copy-target');
      const txt = getPlainTextFromNode(target);
      try{
        await navigator.clipboard.writeText(txt);
        const old = btn.textContent;
        btn.textContent = 'Copied ✓';
        setTimeout(()=>btn.textContent = old, 900);
      }catch(e){
        // Fallback
        const ta = document.createElement('textarea');
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        const old = btn.textContent;
        btn.textContent = 'Copied ✓';
        setTimeout(()=>btn.textContent = old, 900);
      }
    });
  });

  // ---------- HiDPI canvas helpers ----------
  function setupCanvas(canvas){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width * dpr));
    const hpx = Math.max(1, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== hpx){
      canvas.width = w;
      canvas.height = hpx;
    }
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return {ctx, w: rect.width, h: rect.height, dpr};
  }

  function clear(ctx, w, h){
    ctx.clearRect(0,0,w,h);
  }

  // ---------- Plot utilities ----------
  function drawGrid(ctx, x0, y0, x1, y1, nx, ny){
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    for(let i=0;i<=nx;i++){
      const x = x0 + (x1-x0)*i/nx;
      ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y1); ctx.stroke();
    }
    for(let j=0;j<=ny;j++){
      const y = y0 + (y1-y0)*j/ny;
      ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke();
    }
    ctx.restore();
  }

  function drawAxes(ctx, x0, y0, x1, y1, xlabel, ylabel, title){
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(title, x0, y0-10);

    ctx.strokeStyle = 'rgba(255,255,255,0.20)';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(x0, y1); ctx.lineTo(x1, y1); // x-axis
    ctx.moveTo(x0, y1); ctx.lineTo(x0, y0); // y-axis
    ctx.stroke();

    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(xlabel, (x0+x1)/2 - ctx.measureText(xlabel).width/2, y1+28);
    ctx.save();
    ctx.translate(x0-34, (y0+y1)/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(ylabel, -ctx.measureText(ylabel).width/2, 0);
    ctx.restore();
    ctx.restore();
  }

  function ticks(ctx, x0, y0, x1, y1, xTicks, yTicks, xMin, xMax, yMin, yMax, fmtX, fmtY){
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.fillStyle = 'rgba(255,255,255,0.70)';
    ctx.lineWidth = 1;
    ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';

    // x ticks
    for(let i=0;i<=xTicks;i++){
      const t = i/xTicks;
      const x = x0 + (x1-x0)*t;
      ctx.beginPath(); ctx.moveTo(x, y1); ctx.lineTo(x, y1+6); ctx.stroke();
      const val = xMin + (xMax-xMin)*t;
      const lab = fmtX(val);
      ctx.fillText(lab, x - ctx.measureText(lab).width/2, y1+18);
    }
    // y ticks
    for(let j=0;j<=yTicks;j++){
      const t = j/yTicks;
      const y = y1 - (y1-y0)*t;
      ctx.beginPath(); ctx.moveTo(x0-6, y); ctx.lineTo(x0, y); ctx.stroke();
      const val = yMin + (yMax-yMin)*t;
      const lab = fmtY(val);
      ctx.fillText(lab, x0 - 10 - ctx.measureText(lab).width, y+4);
    }

    ctx.restore();
  }

  function mapX(x, x0, x1, xMin, xMax){
    return x0 + (x1-x0) * (x - xMin) / (xMax - xMin);
  }
  function mapY(y, y0, y1, yMin, yMax){
    return y1 - (y1-y0) * (y - yMin) / (yMax - yMin);
  }

  // ---------- Physics calculations ----------
  function compute(d_um, n, dF_eV){
    const d = d_um * 1e-6;
    const Eg = Eg_eV_fixed;

    const dE_eV = Math.max(0, dF_eV - Eg);
    const dE_J = dE_eV * eV;

    const dnu_gain = dE_J / h;                 // Hz
    const dnu_mode = c / (2 * n * d);          // Hz

    const N_real = (dnu_mode > 0) ? (dnu_gain / dnu_mode) : 0;
    const N_floor = Math.floor(N_real + 1e-12);

    const nu_g = (Eg*eV)/h;
    const nu_f = (dF_eV*eV)/h;

    return {d, d_um, n, dF_eV, Eg, dE_eV, dnu_gain, dnu_mode, N_real, N_floor, nu_g, nu_f};
  }

  function niceEng(x){
    // returns value with SI-ish scaling for display, but simple
    const ax = Math.abs(x);
    if(ax >= 1e12) return (x/1e12).toFixed(2) + " THz";
    if(ax >= 1e9) return (x/1e9).toFixed(2) + " GHz";
    if(ax >= 1e6) return (x/1e6).toFixed(2) + " MHz";
    return x.toFixed(2) + " Hz";
  }

  // ---------- Drawing: Diagram ----------
  function drawDiagram(state){
    const {ctx, w, h} = setupCanvas(cDiagram);
    clear(ctx, w, h);

    // padding
    const pad = 18;
    const x0 = pad, x1 = w - pad;
    const y0 = pad+10, y1 = h - pad;

    // Background glow
    const grad = ctx.createLinearGradient(0, y0, 0, y1);
    grad.addColorStop(0, 'rgba(122,167,255,0.10)');
    grad.addColorStop(1, 'rgba(125,255,204,0.05)');
    ctx.fillStyle = grad;
    ctx.fillRect(x0, y0, x1-x0, y1-y0);

    // Cavity block
    const cavX = x0 + 60;
    const cavW = (x1-x0) - 120;
    const cavY = y0 + 70;
    const cavH = (y1-y0) - 130;

    // Facets
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.roundRect(cavX, cavY, cavW, cavH, 16);
    ctx.fill();
    ctx.stroke();

    // Mirror facets (cleaved faces)
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(cavX, cavY); ctx.lineTo(cavX, cavY+cavH); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cavX+cavW, cavY); ctx.lineTo(cavX+cavW, cavY+cavH); ctx.stroke();

    // Standing wave inside
    const midY = cavY + cavH/2;
    ctx.strokeStyle = 'rgba(122,167,255,0.85)';
    ctx.lineWidth = 2;

    const cycles = 7;
    ctx.beginPath();
    for(let i=0;i<=400;i++){
      const t = i/400;
      const x = cavX + t*cavW;
      const y = midY + 0.22*cavH*Math.sin(2*Math.PI*cycles*t);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // Axis arrow and length label
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    ctx.lineWidth = 1.6;

    // length bracket under cavity
    const by = cavY + cavH + 30;
    ctx.beginPath();
    ctx.moveTo(cavX, by); ctx.lineTo(cavX, by-10);
    ctx.moveTo(cavX+cavW, by); ctx.lineTo(cavX+cavW, by-10);
    ctx.moveTo(cavX, by-6); ctx.lineTo(cavX+cavW, by-6);
    ctx.stroke();

    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    const dLab = `d = ${state.d_um.toFixed(0)} μm`;
    ctx.fillText(dLab, cavX + cavW/2 - ctx.measureText(dLab).width/2, by + 14);

    // n label inside
    const nLab = `n = ${state.n.toFixed(2)}`;
    ctx.fillText(nLab, cavX + 10, cavY + 18);

    // Mode condition note
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillStyle = 'rgba(255,255,255,0.78)';
    const text1 = 'Fabry–Perot diode cavity: standing longitudinal modes';
    ctx.fillText(text1, x0+6, y0+16);

    ctx.font = '11.5px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.70)';
    const text2 = 'Mode spacing: Δν = c/(2nd)';
    ctx.fillText(text2, x0+6, y0+36);

    // Small arrows showing light bouncing
    function arrow(xa, ya, xb, yb){
      ctx.strokeStyle = 'rgba(125,255,204,0.85)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(xa,ya); ctx.lineTo(xb,yb); ctx.stroke();
      const ang = Math.atan2(yb-ya, xb-xa);
      const L = 10;
      ctx.beginPath();
      ctx.moveTo(xb, yb);
      ctx.lineTo(xb - L*Math.cos(ang - 0.45), yb - L*Math.sin(ang - 0.45));
      ctx.lineTo(xb - L*Math.cos(ang + 0.45), yb - L*Math.sin(ang + 0.45));
      ctx.closePath();
      ctx.fillStyle = 'rgba(125,255,204,0.85)';
      ctx.fill();
    }
    arrow(cavX + 0.18*cavW, cavY + 0.78*cavH, cavX + 0.82*cavW, cavY + 0.62*cavH);
    arrow(cavX + 0.82*cavW, cavY + 0.62*cavH, cavX + 0.22*cavW, cavY + 0.50*cavH);
  }

  // ---------- Drawing: Main plot (gain window + modes) ----------
  function drawMainPlot(state){
    const {ctx, w, h} = setupCanvas(cMain);
    clear(ctx, w, h);

    const padL = 64, padR = 18, padT = 40, padB = 54;
    const x0 = padL, x1 = w-padR, y0 = padT, y1 = h-padB;

    // Build an x-range around the gain window with margin
    const nuMin = Math.min(state.nu_g, state.nu_f);
    const nuMax = Math.max(state.nu_g, state.nu_f);
    const span = Math.max(1, nuMax - nuMin);
    const margin = 0.22 * span;
    const Xmin = nuMin - margin;
    const Xmax = nuMax + margin;

    // y is arbitrary "gain indicator" from 0..1
    const Ymin = 0, Ymax = 1;

    // Grid & axes
    drawGrid(ctx, x0, y0, x1, y1, 8, 6);
    drawAxes(ctx, x0, y0, x1, y1, 'Frequency ν (THz)', 'Normalized gain (a.u.)', 'Gain-allowed window and cavity resonances');

    ticks(
      ctx, x0,y0,x1,y1,
      8, 5,
      Xmin/1e12, Xmax/1e12,
      Ymin, Ymax,
      (v)=>v.toFixed(1),
      (v)=>v.toFixed(1)
    );

    // Draw gain window rectangle (normalized gain = 1 inside)
    const gx0 = mapX(nuMin/1e12, x0, x1, Xmin/1e12, Xmax/1e12);
    const gx1 = mapX(nuMax/1e12, x0, x1, Xmin/1e12, Xmax/1e12);
    const gy0 = mapY(1, y0, y1, Ymin, Ymax);
    const gy1 = mapY(0, y0, y1, Ymin, Ymax);

    ctx.save();
    ctx.fillStyle = 'rgba(125,255,204,0.10)';
    ctx.strokeStyle = 'rgba(125,255,204,0.55)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(gx0, gy0, gx1-gx0, gy1-gy0, 10);
    ctx.fill();
    ctx.stroke();

    // Label window
    ctx.fillStyle = 'rgba(255,255,255,0.80)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    const lab = `ν_g→ν_F  (Δν_gain ≈ ${(state.dnu_gain/1e12).toFixed(2)} THz)`;
    ctx.fillText(lab, gx0 + 10, gy0 + 18);
    ctx.restore();

    // Draw cavity mode lines within plot range
    // Choose a reference mode near nuMin (any integer shift is fine since we only care about spacing)
    const dnu = state.dnu_mode;
    let countInside = 0;

    // Find the first mode >= Xmin
    const k0 = Math.floor(Xmin / dnu);
    const k1 = Math.ceil(Xmax / dnu);

    ctx.save();
    ctx.lineWidth = 1.5;

    for(let k=k0; k<=k1; k++){
      const nu = k * dnu;
      const x = mapX(nu/1e12, x0, x1, Xmin/1e12, Xmax/1e12);
      // Determine if inside gain window
      const inside = (nu >= nuMin && nu <= nuMax && state.dE_eV > 0);

      ctx.strokeStyle = inside ? 'rgba(122,167,255,0.90)' : 'rgba(255,255,255,0.16)';
      ctx.beginPath();
      ctx.moveTo(x, y0);
      ctx.lineTo(x, y1);
      ctx.stroke();

      if(inside) countInside++;
    }

    // Legend
    const lx = x0 + 12, ly = y0 + 10;
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(lx-8, ly-6, 310, 44, 12);
    ctx.fill();
    ctx.stroke();

    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillStyle = 'rgba(255,255,255,0.82)';

    // Legend lines
    ctx.strokeStyle = 'rgba(122,167,255,0.90)';
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(lx, ly+10); ctx.lineTo(lx+22, ly+10); ctx.stroke();
    ctx.fillText('Cavity modes inside gain', lx+30, ly+14);

    ctx.strokeStyle = 'rgba(255,255,255,0.20)';
    ctx.beginPath(); ctx.moveTo(lx, ly+28); ctx.lineTo(lx+22, ly+28); ctx.stroke();
    ctx.fillText('Cavity modes outside gain', lx+30, ly+32);

    ctx.restore();

    // Annotate count
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.86)';
    ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    const note = (state.dE_eV <= 0) ? 'No gain window (ΔF ≤ Eg) ⇒ N ≈ 0'
                                   : `Counted modes inside window ≈ ${countInside}`;
    ctx.fillText(note, x0, y1 + 42);
    ctx.restore();

    return countInside;
  }

  // ---------- Drawing: Sweep plot N vs d ----------
  function drawSweep(state){
    const {ctx, w, h} = setupCanvas(cSweep);
    clear(ctx, w, h);

    const padL = 64, padR = 18, padT = 40, padB = 54;
    const x0 = padL, x1 = w-padR, y0 = padT, y1 = h-padB;

    // Sweep d from 50..1000 um at current n and dF
    const dMin = 50, dMax = 1000;
    const pts = 160;

    let yMax = 1;
    const arr = [];
    for(let i=0;i<=pts;i++){
      const d_um = dMin + (dMax-dMin)*i/pts;
      const st = compute(d_um, state.n, state.dF_eV);
      arr.push({d_um, N: st.N_real});
      yMax = Math.max(yMax, st.N_real);
    }
    // Make yMax nice-ish
    yMax = Math.ceil(yMax/10)*10;

    drawGrid(ctx, x0, y0, x1, y1, 8, 6);
    drawAxes(ctx, x0, y0, x1, y1, 'Cavity length d (μm)', 'Mode count N (a.u.)', 'Sweep: N_max vs cavity length');

    ticks(
      ctx, x0,y0,x1,y1,
      8, 5,
      dMin, dMax,
      0, yMax,
      (v)=>v.toFixed(0),
      (v)=>v.toFixed(0)
    );

    // Line
    ctx.save();
    ctx.strokeStyle = 'rgba(125,255,204,0.90)';
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    arr.forEach((p, idx)=>{
      const x = mapX(p.d_um, x0, x1, dMin, dMax);
      const y = mapY(p.N, y0, y1, 0, yMax);
      if(idx===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();

    // Highlight current
    const xc = mapX(state.d_um, x0, x1, dMin, dMax);
    const yc = mapY(state.N_real, y0, y1, 0, yMax);

    ctx.fillStyle = 'rgba(122,167,255,0.92)';
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(xc, yc, 5.8, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    // Annotation
    ctx.fillStyle = 'rgba(255,255,255,0.82)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    const tag = `d=${state.d_um.toFixed(0)} μm → N≈${state.N_real.toFixed(1)}`;
    ctx.fillText(tag, Math.min(x1-ctx.measureText(tag).width, xc+10), Math.max(y0+14, yc-10));

    // Legend (single)
    const lx = x0 + 12, ly = y0 + 10;
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(lx-8, ly-6, 240, 28, 12);
    ctx.fill();
    ctx.stroke();

    ctx.strokeStyle = 'rgba(125,255,204,0.90)';
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(lx, ly+8); ctx.lineTo(lx+22, ly+8); ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,0.82)';
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('N_max(d) at current n, ΔF', lx+30, ly+12);

    ctx.restore();
  }

  // ---------- Update all ----------
  function update(){
    const d_um = parseFloat(sliderD.value);
    const dF_eV = parseFloat(sliderDF.value);
    const n = parseFloat(sliderN.value);

    valD.textContent = d_um.toFixed(0);
    valDF.textContent = dF_eV.toFixed(3);
    valN.textContent = n.toFixed(2);

    const state = compute(d_um, n, dF_eV);

    // KPIs (match the worked numbers when d=250, n=3.5, ΔF=0.96)
    kpi_dE.textContent = state.dE_eV.toFixed(3);
    kpi_dnuGain.textContent = (state.dnu_gain/1e12).toFixed(2);
    kpi_dnuMode.textContent = (state.dnu_mode/1e9).toFixed(1);

    // Draw
    drawDiagram(state);
    const counted = drawMainPlot(state);
    drawSweep(state);

    // Live summary
    const Ndisp = (state.dE_eV <= 0) ? 0 : counted;
    liveSummary.textContent =
      `Δν_gain=${(state.dnu_gain/1e12).toFixed(2)} THz · Δν_mode=${(state.dnu_mode/1e9).toFixed(1)} GHz · N≈${Ndisp}`;
  }

  // Responsive redraw
  let raf = null;
  function requestUpdate(){
    if(raf) cancelAnimationFrame(raf);
    raf = requestAnimationFrame(update);
  }

  sliderD.addEventListener('input', requestUpdate);
  sliderDF.addEventListener('input', requestUpdate);
  sliderN.addEventListener('input', requestUpdate);
  window.addEventListener('resize', requestUpdate);

  // Initial
  // Also ensure KPIs reflect the stated problem values at load
  update();
})();
</script>
</body>
</html>
