<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gain Coefficient of a GaAs Semiconductor Optical Amplifier (SOA) — Theory, Computation, and Interactive Plots</title>
  <style>
    :root{
      --bg:#0b0f14;
      --card:#101824;
      --card2:#0f1621;
      --text:#e9eef7;
      --muted:#a9b6cc;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --ok:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --grid: rgba(233,238,247,.08);
      --grid2: rgba(233,238,247,.14);
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 600px at 20% 10%, rgba(125,211,252,.10), transparent 60%),
                  radial-gradient(900px 500px at 90% 20%, rgba(167,139,250,.10), transparent 55%),
                  radial-gradient(800px 600px at 50% 100%, rgba(52,211,153,.07), transparent 65%),
                  var(--bg);
      color:var(--text);
      line-height:1.55;
      overflow-x:hidden;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding: 28px 18px 14px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .topbar{
      display:flex;
      gap:14px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .title{
      flex:1 1 560px;
      min-width:280px;
    }
    h1{
      margin:0 0 6px 0;
      font-size: clamp(22px, 2.2vw + 14px, 40px);
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      font-size: 14.5px;
      max-width: 78ch;
    }
    .pillrow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
      flex: 0 0 auto;
      padding-top: 6px;
    }
    .pill{
      border: 1px solid rgba(233,238,247,.16);
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      padding: 8px 10px;
      border-radius: 999px;
      color: var(--muted);
      font-size: 12px;
      display:flex;
      gap:8px;
      align-items:center;
      box-shadow: 0 8px 22px rgba(0,0,0,.18);
    }
    .dot{width:8px;height:8px;border-radius:50%}
    .dot.a{background:var(--accent)}
    .dot.b{background:var(--accent2)}
    .dot.c{background:var(--ok)}
    main{
      max-width: 1200px;
      margin: 0 auto;
      padding: 12px 18px 70px;
      display:grid;
      grid-template-columns: 280px 1fr;
      gap: 18px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
    }

    /* TOC */
    nav#toc{
      position: sticky;
      top: 12px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border: 1px solid rgba(233,238,247,.14);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
    }
    nav#toc h2{
      margin:0 0 10px 0;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: .14em;
      color: var(--muted);
    }
    nav#toc a{
      display:block;
      padding: 8px 10px;
      border-radius: 12px;
      color: var(--text);
      font-size: 13px;
      border: 1px solid transparent;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
    }
    nav#toc a:hover{
      background: rgba(125,211,252,.08);
      border-color: rgba(125,211,252,.18);
      transform: translateY(-1px);
      text-decoration:none;
    }
    .content{
      display:flex;
      flex-direction:column;
      gap: 18px;
      min-width:0;
    }
    section, article{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border: 1px solid rgba(233,238,247,.14);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px;
      overflow:hidden;
    }
    section h2, article h2{
      margin: 0 0 12px 0;
      font-size: 18px;
      letter-spacing:.2px;
    }
    h3{
      margin: 18px 0 8px 0;
      font-size: 15.5px;
      color: var(--text);
    }
    p{margin: 8px 0; color: var(--text)}
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 860px){ .grid2{grid-template-columns:1fr} }
    .callout{
      background: linear-gradient(180deg, rgba(16,24,36,.9), rgba(16,24,36,.55));
      border: 1px solid rgba(233,238,247,.12);
      border-radius: 16px;
      padding: 12px 12px 10px;
    }
    .callout strong{color: var(--accent)}
    .kpi{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 8px;
    }
    .kpi .box{
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(233,238,247,.12);
      border-radius: 14px;
      padding: 10px 12px;
      min-width: 160px;
      flex: 1 1 160px;
    }
    .box .label{color:var(--muted); font-size: 12px}
    .box .value{font-family: var(--mono); font-size: 14px; margin-top:4px}
    ul{margin: 8px 0 10px 18px}
    li{margin: 6px 0; color: var(--text)}
    .eq{
      font-family: var(--mono);
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(233,238,247,.14);
      border-radius: 14px;
      padding: 12px;
      overflow:auto;
      position: relative;
    }
    .eq .small{color:var(--muted); font-size:12px; margin-top:6px}
    .btncopy{
      position:absolute;
      top:10px; right:10px;
      font-size:12px;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(233,238,247,.18);
      background: rgba(255,255,255,.04);
      color: var(--text);
      cursor:pointer;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
    }
    .btncopy:hover{
      transform: translateY(-1px);
      background: rgba(125,211,252,.08);
      border-color: rgba(125,211,252,.2);
    }

    /* Visualization */
    .vizgrid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }
    .vizpanel{
      background: linear-gradient(180deg, rgba(15,22,33,.9), rgba(15,22,33,.55));
      border: 1px solid rgba(233,238,247,.12);
      border-radius: 16px;
      padding: 12px;
      overflow:hidden;
    }
    .vizheader{
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap: 10px;
      flex-wrap:wrap;
      margin-bottom: 10px;
    }
    .viztitle{
      font-weight: 700;
      letter-spacing:.2px;
    }
    .controls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }
    .ctrl{
      display:flex;
      gap:8px;
      align-items:center;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(233,238,247,.14);
      background: rgba(0,0,0,.18);
      color: var(--text);
      font-size: 12.5px;
    }
    .ctrl input[type="range"]{width: 210px}
    .ctrl select, .ctrl button{
      background: rgba(255,255,255,.04);
      color: var(--text);
      border: 1px solid rgba(233,238,247,.16);
      border-radius: 12px;
      padding: 7px 10px;
      cursor:pointer;
      font-size: 12.5px;
    }
    .ctrl button:hover{
      background: rgba(125,211,252,.08);
      border-color: rgba(125,211,252,.2);
    }
    canvas{
      width:100%;
      height: 340px;
      display:block;
      border-radius: 14px;
      background: rgba(0,0,0,.16);
      border: 1px solid rgba(233,238,247,.10);
    }
    .smallnote{
      margin-top: 8px;
      color: var(--muted);
      font-size: 12px;
    }

    footer{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 18px 40px;
      color: var(--muted);
      font-size: 12.5px;
    }
    .printonly{display:none}
    @media print{
      body{background:white;color:black}
      nav#toc{display:none}
      header, main, footer{max-width: 100%}
      section, article{box-shadow:none}
      canvas{border:1px solid #aaa}
      .printonly{display:block}
      .btncopy{display:none}
      .pillrow{display:none}
    }
  </style>
</head>

<body>
<header>
  <div class="topbar">
    <div class="title">
      <h1>Gain Coefficient of a GaAs Semiconductor Optical Amplifier (SOA)</h1>
      <div class="subtitle">
        We model the <b>material gain spectrum</b> of a p-type GaAs SOA versus photon energy, for both <b>T = 0 K</b> and <b>T = 300 K</b>,
        then extract <b>peak gain</b>, <b>transparency</b>, and <b>bandwidth</b> as functions of injected carrier concentration Δn.
      </div>
    </div>
    <div class="pillrow">
      <div class="pill"><span class="dot a"></span>Interactive canvases</div>
      <div class="pill"><span class="dot b"></span>Fermi factors + parabolic bands</div>
      <div class="pill"><span class="dot c"></span>Bandwidth & transparency</div>
    </div>
  </div>
</header>

<main>
  <nav id="toc" aria-label="Table of contents">
    <h2>Contents</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
  </nav>

  <div class="content">
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li>This problem asks for the <b>GaAs SOA material gain coefficient</b> γ(ν) versus photon energy hν for different injected carrier densities Δn.</li>
        <li>Key idea: <b>gain = stimulated emission − absorption</b> and is controlled by the <b>population inversion factor</b> (Fermi occupations in the bands).</li>
        <li>We use a direct-gap, parabolic-band model where the “empty-band” absorption has the shape
          <span class="muted">(for hν &gt; E<sub>g</sub>)</span>:
          <b>α₀(hν) ∝ √(hν − E<sub>g</sub>)/(hν)</b>.</li>
        <li>The material gain spectrum is modeled as <b>g(hν) = α₀(hν) · (f<sub>c</sub> − f<sub>v</sub>)</b>, where f<sub>c</sub>, f<sub>v</sub> come from quasi-Fermi levels set by n and p.</li>
        <li>For <b>T = 0 K</b>, Fermi factors become step functions and the gain edge is sharp; for <b>T = 300 K</b>, thermal smearing broadens the spectrum.</li>
        <li>From g(hν) we compute (i) <b>peak gain</b> g<sub>pk</sub>(Δn), (ii) <b>transparency</b> Δn<sub>tr</sub> (where peak gain crosses 0 in the material model), and (iii) <b>full bandwidth</b> where net gain is positive.</li>
        <li>Final results are <b>numerical curves + extracted parameters</b>, visualized live with interactive plots.</li>
      </ul>
    </section>

    <article id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="grid2">
        <div class="callout">
          <strong>Core quantities (symbols & units)</strong>
          <ul>
            <li><b>E<sub>g</sub></b> (eV): bandgap energy (GaAs here ≈ 1.40 eV).</li>
            <li><b>hν</b> (eV): photon energy.</li>
            <li><b>α₀(hν)</b> (m⁻¹ or cm⁻¹): “empty-band” absorption coefficient (no Pauli blocking).</li>
            <li><b>g(hν)</b> (m⁻¹ or cm⁻¹): material gain coefficient (positive = amplification).</li>
            <li><b>f<sub>c</sub></b>, <b>f<sub>v</sub></b> (dimensionless): Fermi-Dirac occupation probabilities in conduction/valence states.</li>
            <li><b>Δn</b> (cm⁻³): injected electron density (and injected holes, for charge neutrality).</li>
            <li><b>n</b>, <b>p</b> (cm⁻³): electron and hole densities. Here p-type: p ≈ p₀ + Δn, n ≈ Δn.</li>
          </ul>
        </div>

        <div class="callout">
          <strong>Physical meaning</strong>
          <ul>
            <li><b>Absorption</b>: photons promote electrons from valence to conduction, but only if a final conduction state is empty.</li>
            <li><b>Stimulated emission</b>: photons induce recombination from conduction to valence, but only if an initial conduction state is occupied and a final valence state is empty.</li>
            <li><b>Pauli blocking</b>: occupations (f’s) “block” transitions; this is why gain needs population inversion.</li>
            <li><b>Quasi-Fermi levels</b>: under injection, electrons and holes each have their own Fermi level, setting f<sub>c</sub> and f<sub>v</sub>.</li>
          </ul>
        </div>
      </div>

      <h3>Key principle: gain from the same transitions as absorption</h3>
      <p>
        In a simple direct-gap model, the <b>spectral material gain</b> is written as the empty-band absorption shape multiplied by a population-inversion factor:
      </p>

      <div class="eq" id="eq_gain">
        <button class="btncopy" data-copy="g(hν) = α0(hν) · (fc(hν) − fv(hν))">Copy</button>
        <div><b>Material gain model:</b></div>
        <div style="margin-top:8px;">
          g(hν) = α₀(hν) · ( f<sub>c</sub>(E<sub>c</sub>) − f<sub>v</sub>(E<sub>v</sub>) )
        </div>
        <div class="small">
          Interpretation: α₀ sets the “available transition strength”; (f<sub>c</sub> − f<sub>v</sub>) sets whether the net transition is emission or absorption.
        </div>
      </div>

      <h3>Parabolic-band + direct-gap absorption shape</h3>
      <p>
        For 3D parabolic bands, the joint density of states scales as √(hν − E<sub>g</sub>) above the gap, giving the common spectral form
        (for hν &gt; E<sub>g</sub>):
      </p>

      <div class="eq" id="eq_alpha0">
        <button class="btncopy" data-copy="α0(hν) = A · sqrt(hν − Eg) / (hν),  for hν > Eg;  α0 = 0 otherwise.">Copy</button>
        <div><b>Empty-band absorption (shape):</b></div>
        <div style="margin-top:8px;">
          α₀(hν) = A · √(hν − E<sub>g</sub>) / (hν), &nbsp; hν &gt; E<sub>g</sub>; &nbsp; α₀ = 0 otherwise.
        </div>
        <div class="small">
          A is a material/structure prefactor (matrix element, refractive index, effective masses). In this article we calibrate A using the given radiative lifetime scale.
        </div>
      </div>

      <h3>Fermi-Dirac occupations and quasi-Fermi levels</h3>
      <p>
        At finite temperature, occupations are
        f(E) = 1 / (1 + exp((E − E<sub>F</sub>)/kT)).
        Under injection, electrons and holes have separate quasi-Fermi levels: E<sub>Fn</sub> for electrons and E<sub>Fp</sub> for holes.
        These are determined from carrier densities via effective densities of states and Fermi-Dirac integrals.
      </p>

      <div class="callout">
        <strong>Common models/approximations (and why)</strong>
        <ul>
          <li><b>Parabolic bands</b>: good near band edges and matches the √(E − E<sub>g</sub>) DOS behavior seen in many gain spectra.</li>
          <li><b>Quasi-equilibrium</b> in each band: fast carrier-carrier scattering makes each band describable by a Fermi distribution.</li>
          <li><b>T = 0 K limit</b>: turns f into step functions, giving sharp spectral edges and easier intuition.</li>
          <li><b>Linear gain model</b>: near transparency, peak gain vs Δn is often approximated linear to extract transparency and “loss-like” offsets.</li>
        </ul>
      </div>

      <h3>Mini intuition examples</h3>
      <ul>
        <li><b>No injection (Δn ≈ 0)</b>: conduction is mostly empty (f<sub>c</sub> small), valence mostly full (f<sub>v</sub> ≈ 1) → (f<sub>c</sub> − f<sub>v</sub>) ≈ −1 → absorption.</li>
        <li><b>Strong injection</b>: conduction partially filled and valence partially emptied near the edges → (f<sub>c</sub> − f<sub>v</sub>) becomes positive in a band of photon energies → gain band appears.</li>
      </ul>

      <h3>What to watch for (pitfalls)</h3>
      <ul>
        <li><b>Units</b>: gain is often plotted in cm⁻¹ while calculations are natural in SI (m⁻¹).</li>
        <li><b>Degeneracy</b>: at ~10¹⁸ cm⁻³, GaAs can be moderately degenerate; pure Maxwell-Boltzmann can distort results.</li>
        <li><b>Bandwidth definition</b>: “full bandwidth” must be defined (here: energy range where net gain is positive).</li>
        <li><b>Prefactor calibration</b>: absolute gain levels require a material constant; we anchor it using the provided radiative lifetime scale.</li>
      </ul>
    </article>

    <article id="part1">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Problem restatement (in plain language)</h3>
      <p>
        We have a <b>room-temperature p-type GaAs SOA</b> with given bandgap, effective masses, refractive index, doping p₀, and radiative lifetime scale τ<sub>r</sub>.
        For an injected steady-state carrier density <b>Δn</b>, compute the <b>gain spectrum g(hν)</b> versus photon energy for <b>T = 0 K</b> and <b>T = 300 K</b>.
        Then extract peak gain vs Δn, determine transparency and a loss-like offset using a linear model, and compute the amplifier bandwidth vs Δn.
      </p>

      <div class="grid2">
        <div class="callout">
          <strong>Given</strong>
          <ul>
            <li>T = 300 K (room temperature) for the physical device; also evaluate a T = 0 K idealized case.</li>
            <li>GaAs parameters: E<sub>g</sub> ≈ 1.40 eV, m<sub>c</sub> = 0.07 m₀, m<sub>v</sub> = 0.50 m₀.</li>
            <li>Refractive index: n = 3.6.</li>
            <li>p-type doping: p₀ = 1.2 × 10¹⁸ cm⁻³.</li>
            <li>Radiative recombination lifetime scale: τ<sub>r</sub> ≈ 2 ns.</li>
          </ul>
        </div>

        <div class="callout">
          <strong>Unknowns / outputs</strong>
          <ul>
            <li>g(hν) vs hν for selected Δn values at T=0 K and T=300 K.</li>
            <li>Peak gain g<sub>pk</sub>(Δn) for both temperatures.</li>
            <li>Transparency Δn<sub>tr</sub> and a “loss-like” offset α from a linearized peak-gain model.</li>
            <li>Full bandwidth vs Δn in <b>Hz</b>, <b>nm</b>, and <b>eV</b>.</li>
            <li>Qualitative comparison to the textbook figure curves.</li>
          </ul>
        </div>
      </div>

      <h3>Relevant physics (and why it applies)</h3>
      <ul>
        <li><b>Direct-gap interband transitions</b>: GaAs is direct-gap, so optical gain is dominated by vertical (k-conserving) interband transitions.</li>
        <li><b>Pauli blocking / Fermi factors</b>: net stimulated response depends on occupancy of initial and final states.</li>
        <li><b>Quasi-Fermi levels</b>: injection creates separate electron/hole chemical potentials in steady state.</li>
        <li><b>Parabolic bands near edges</b>: gives analytic DOS shape and standard √(hν − E<sub>g</sub>) dependence.</li>
      </ul>

      <h3>Assumptions (explicit)</h3>
      <div class="callout">
        <strong>Assumptions used in the computation below</strong>
        <ul>
          <li>Bulk-like 3D parabolic bands with effective masses m<sub>c</sub>, m<sub>v</sub>.</li>
          <li>Charge neutrality under injection: n ≈ Δn, p ≈ p₀ + Δn (p-type background).</li>
          <li>Quasi-equilibrium within each band: electrons described by E<sub>Fn</sub>, holes by E<sub>Fp</sub>.</li>
          <li>Empty-band absorption shape α₀(hν) = A √(hν − E<sub>g</sub>)/(hν), calibrated to the radiative lifetime scale τ<sub>r</sub> at a reference injection (explained in PART 3).</li>
          <li>Bandwidth definition: energy interval where <b>net gain</b> g(hν) − α is positive (α extracted from linearized peak-gain offset as requested).</li>
        </ul>
      </div>

      <h3>Possible approaches (and which we choose)</h3>
      <ul>
        <li><b>Approach A: full k-space Fermi’s golden rule</b> (most fundamental). Pros: clearest physics. Cons: heavy algebra and constants; needs matrix element.</li>
        <li><b>Approach B: absorption-shape × inversion factor</b> (standard textbook gain model). Pros: compact, captures lineshape and inversion. Cons: needs prefactor calibration for absolute gain.</li>
        <li><b>Approach C: purely empirical fit to the figure</b>. Pros: matches plot. Cons: not physics-first and doesn’t generalize.</li>
      </ul>
      <p>
        We choose <b>Approach B</b> because it matches the “(18.2-2)–(18.2-4)” style used in many optics texts:
        use the direct-gap absorption lineshape and multiply by Fermi inversion; then calibrate the overall scale using the given τ<sub>r</sub>.
      </p>
    </article>

    <article id="part2">
      <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>
      <ol>
        <li>
          <b>Set carrier densities</b>:
          n = Δn, p = p₀ + Δn (cm⁻³).
          <span class="muted">Meaning: background p-type doping shifts the hole quasi-Fermi level.</span>
        </li>
        <li>
          <b>Compute effective DOS</b>:
          N<sub>c</sub>(T), N<sub>v</sub>(T) from m<sub>c</sub>, m<sub>v</sub>.
          <span class="muted">Meaning: how many states are thermally accessible.</span>
        </li>
        <li>
          <b>Find quasi-Fermi levels</b> E<sub>Fn</sub>, E<sub>Fp</sub> such that the Fermi-Dirac integrals give the desired n and p.
          <span class="muted">Meaning: these fix occupations f<sub>c</sub>, f<sub>v</sub> for optical transitions.</span>
        </li>
        <li>
          <b>Build α₀(hν)</b>:
          α₀(hν)=A √(hν−E<sub>g</sub>)/(hν) for hν&gt;E<sub>g</sub>.
          <span class="muted">Meaning: spectral “transition strength” envelope.</span>
        </li>
        <li>
          <b>Compute inversion factor</b>:
          f<sub>c</sub>(E<sub>c</sub>) − f<sub>v</sub>(E<sub>v</sub>) at the transition energies that satisfy E<sub>c</sub>−E<sub>v</sub>=hν.
        </li>
        <li>
          <b>Gain spectrum</b>:
          g(hν)=α₀(hν)(f<sub>c</sub>−f<sub>v</sub>), convert to cm⁻¹.
        </li>
        <li>
          <b>Extract peak gain</b> g<sub>pk</sub>(Δn) and determine Δn<sub>tr</sub> by finding where g<sub>pk</sub> crosses 0 (material transparency).
        </li>
        <li>
          <b>Linear model near transparency</b>:
          fit g<sub>pk</sub>(Δn) ≈ a(Δn − Δn<sub>tr</sub>) and define a loss-like offset α as requested (we use α = −g<sub>pk</sub>(Δn=0) in this simplified “material-only” model; see PART 3).
        </li>
        <li>
          <b>Bandwidth</b>:
          compute net gain g(hν)−α and find full positive-gain width in eV; convert to Hz and nm.
        </li>
      </ol>

      <div class="callout">
        <strong>Common mistakes & quick tips</strong>
        <ul>
          <li>Use consistent energy units: compute in Joules internally, plot in eV.</li>
          <li>Don’t forget p-type background: p ≠ Δn, but p = p₀ + Δn.</li>
          <li>When converting bandwidth to nm, use λ = hc/E and compute a span using the two edge wavelengths, not a small-signal derivative unless the span is tiny.</li>
          <li>At T=0 K, enforce step-function occupations—sharp edges are expected.</li>
        </ul>
      </div>
    </article>

    <article id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Qualitative expectation (before math)</h3>
      <ul>
        <li>As Δn increases, the electron quasi-Fermi level rises into the conduction band, and the hole quasi-Fermi level moves deeper into the valence band (or equivalently, holes fill higher-energy valence states).</li>
        <li>This increases (f<sub>c</sub> − f<sub>v</sub>) near the band edge, creating a <b>gain band</b> just above E<sub>g</sub>.</li>
        <li>At T=0 K, occupations are sharp, so the gain spectrum has sharper onset/edges than at 300 K.</li>
      </ul>

      <h3>Step 1 — Carrier densities from Δn</h3>
      <p>
        For a p-type semiconductor with acceptor doping giving equilibrium hole density p₀, injection creates excess electrons and holes.
        Under the common SOA steady-state neutrality approximation:
      </p>
      <div class="eq" id="eq_np">
        <button class="btncopy" data-copy="n ≈ Δn,   p ≈ p0 + Δn">Copy</button>
        <div><b>Injected densities:</b></div>
        <div style="margin-top:8px;">
          n ≈ Δn, &nbsp;&nbsp; p ≈ p₀ + Δn.
        </div>
        <div class="small">Units: cm⁻³ in the problem statement; we convert to m⁻³ in computation.</div>
      </div>

      <h3>Step 2 — Quasi-Fermi levels at T = 300 K</h3>
      <p>
        For 3D parabolic bands, the carrier densities are related to quasi-Fermi levels by
        n = N<sub>c</sub> F<sub>1/2</sub>(η<sub>n</sub>) and p = N<sub>v</sub> F<sub>1/2</sub>(η<sub>p</sub>),
        where η is the reduced Fermi level (relative to the band edge) and F<sub>1/2</sub> is the Fermi-Dirac integral of order 1/2.
      </p>

      <div class="eq" id="eq_NcNv">
        <button class="btncopy" data-copy="Nc(T) = 2 (2π mc kT / h^2)^(3/2),   Nv(T) = 2 (2π mv kT / h^2)^(3/2)">Copy</button>
        <div><b>Effective densities of states:</b></div>
        <div style="margin-top:8px;">
          N<sub>c</sub>(T) = 2 · ( 2π m<sub>c</sub> kT / h² )<sup>3/2</sup>,<br/>
          N<sub>v</sub>(T) = 2 · ( 2π m<sub>v</sub> kT / h² )<sup>3/2</sup>.
        </div>
        <div class="small">
          The factor 2 is the spin degeneracy. (This is the standard bulk DOS expression.)
        </div>
      </div>

      <p class="muted">
        In the interactive code below, we solve for η using robust bisection on a numerically-evaluated F<sub>1/2</sub> integral
        (fast enough for live plotting).
      </p>

      <h3>Step 3 — Quasi-Fermi levels at T = 0 K</h3>
      <p>
        At T = 0 K, the Fermi-Dirac function becomes a step: all states below E<sub>F</sub> are filled, above are empty.
        The 3D density for a parabolic band gives:
      </p>

      <div class="eq" id="eq_T0">
        <button class="btncopy" data-copy="n = (1/(3π^2)) (2mc/ħ^2)^(3/2) (EFn − Ec)^(3/2),   p = (1/(3π^2)) (2mv/ħ^2)^(3/2) (Ev − EFp)^(3/2)">Copy</button>
        <div><b>T = 0 K density ↔ Fermi energy (relative to band edges):</b></div>
        <div style="margin-top:8px;">
          n = (1/(3π²)) (2m<sub>c</sub>/ħ²)<sup>3/2</sup> (E<sub>Fn</sub>−E<sub>c</sub>)<sup>3/2</sup>,<br/>
          p = (1/(3π²)) (2m<sub>v</sub>/ħ²)<sup>3/2</sup> (E<sub>v</sub>−E<sub>Fp</sub>)<sup>3/2</sup>.
        </div>
        <div class="small">
          These relations are inverted directly to obtain (E<sub>Fn</sub>−E<sub>c</sub>) and (E<sub>v</sub>−E<sub>Fp</sub>).
        </div>
      </div>

      <h3>Step 4 — Transition energies and the inversion factor (f<sub>c</sub> − f<sub>v</sub>)</h3>
      <p>
        For a photon energy E = hν, a vertical transition connects conduction and valence states with the same wavevector magnitude k.
        With parabolic bands, the energy partition is:
      </p>

      <div class="eq" id="eq_partition">
        <button class="btncopy" data-copy="E = Eg + (ħ^2 k^2)/(2mr),   with mr = (mc mv)/(mc + mv).   Then Ec−Ec0 = (mr/mc)(E−Eg),   and (Ev0−Ev) = (mr/mv)(E−Eg).">Copy</button>
        <div><b>Energy partition (parabolic bands):</b></div>
        <div style="margin-top:8px;">
          E = E<sub>g</sub> + ħ²k²/(2m<sub>r</sub>), &nbsp; m<sub>r</sub> = (m<sub>c</sub> m<sub>v</sub>)/(m<sub>c</sub>+m<sub>v</sub>).<br/><br/>
          Conduction kinetic energy: &nbsp;ε<sub>c</sub> = (m<sub>r</sub>/m<sub>c</sub>) (E − E<sub>g</sub>)<br/>
          Valence kinetic energy (measured downward from valence edge): &nbsp;ε<sub>v</sub> = (m<sub>r</sub>/m<sub>v</sub>) (E − E<sub>g</sub>)
        </div>
        <div class="small">
          So the electron occupation is evaluated at E<sub>c</sub> = E<sub>c0</sub> + ε<sub>c</sub>, and the valence occupation at E<sub>v</sub> = E<sub>v0</sub> − ε<sub>v</sub>.
        </div>
      </div>

      <p>
        Then the inversion factor is computed as
        f<sub>c</sub>(E<sub>c</sub>) − f<sub>v</sub>(E<sub>v</sub>).
        At T=0 K this becomes a piecewise constant depending on whether each energy is inside the filled region.
      </p>

      <h3>Step 5 — Spectral gain from empty-band absorption</h3>
      <p>
        We use the standard “shape × inversion” model:
        g(E) = α₀(E) (f<sub>c</sub> − f<sub>v</sub>),
        with α₀(E)=A √(E−E<sub>g</sub>)/E.
      </p>

      <h3>How do we set the absolute scale A?</h3>
      <p>
        The lineshape determines <i>relative</i> spectral gain, but the problem includes a radiative lifetime scale τ<sub>r</sub> to anchor the magnitude.
        A convenient physics-consistent bridge is that the same α₀(E) also controls spontaneous emission via detailed balance style relations.
        In a simplified quasi-equilibrium model, the spontaneous emission spectral rate per volume can be written (up to the same optical coupling constants) as:
      </p>

      <div class="eq" id="eq_rsp">
        <button class="btncopy" data-copy="R_sp(E) ∝ E^2 α0(E) · fc(Ec) · (1 − fv(Ev))">Copy</button>
        <div><b>Spontaneous emission (spectral) scaling used for calibration:</b></div>
        <div style="margin-top:8px;">
          R<sub>sp</sub>(E) ∝ E² α₀(E) · f<sub>c</sub>(E<sub>c</sub>) · (1 − f<sub>v</sub>(E<sub>v</sub>))
        </div>
        <div class="small">
          We integrate R<sub>sp</sub>(E) over E to get a total radiative recombination rate R<sub>rad</sub>. We then set R<sub>rad</sub> ≈ Δn/τ<sub>r</sub> at a reference Δn to determine A.
        </div>
      </div>

      <div class="callout">
        <strong>Calibration choice (clearly stated)</strong>
        <p style="margin:8px 0;">
          Because the problem statement provides τ<sub>r</sub> but not the interband momentum matrix element,
          we calibrate the single prefactor A by enforcing:
        </p>
        <ul>
          <li>At T=300 K and a reference injection <b>Δn<sub>ref</sub> = 1.0 × 10¹⁸ cm⁻³</b>, the computed radiative rate satisfies <b>R<sub>rad</sub> = Δn<sub>ref</sub>/τ<sub>r</sub></b>.</li>
        </ul>
        <p class="muted" style="margin:8px 0;">
          This keeps the model physics-based and produces gain magnitudes comparable to classic GaAs SOA plots (order 10²–10³ cm⁻¹).
        </p>
      </div>

      <h3>Step 6 — Peak gain, transparency, loss-like offset, and bandwidth</h3>
      <ul>
        <li><b>Peak gain</b>: g<sub>pk</sub>(Δn) = max<sub>E</sub> g(E).</li>
        <li><b>Material transparency</b>: Δn<sub>tr</sub> solves g<sub>pk</sub>(Δn<sub>tr</sub>) = 0.</li>
        <li><b>Linear approximation model</b>: near transparency, fit g<sub>pk</sub>(Δn) ≈ a(Δn − Δn<sub>tr</sub>).</li>
        <li><b>Loss-like offset α</b> (as requested): in this simplified material-only setting, we take α ≡ −g<sub>pk</sub>(Δn=0),
          i.e. the peak absorption magnitude at zero injection (a common way to represent an effective “loss” in a linearized net-gain picture).</li>
        <li><b>Full bandwidth</b>: energy span where net gain g(E) − α is positive. Convert to:
          ΔE (eV), Δν = ΔE/h (Hz), and Δλ using λ = hc/E at the two gain edges.</li>
      </ul>

      <div class="callout">
        <strong>Sanity checks</strong>
        <ul>
          <li><b>Units</b>: α₀ and g are computed in m⁻¹ then shown in cm⁻¹ (1 m⁻¹ = 0.01 cm⁻¹).</li>
          <li><b>Limits</b>: at Δn→0, f<sub>c</sub>→0 and f<sub>v</sub>→1 near the edge ⇒ g(E) ≈ −α₀(E) &lt; 0.</li>
          <li><b>Temperature</b>: T=300 K should broaden edges relative to T=0 K.</li>
        </ul>
      </div>

      <div class="eq" id="eq_final">
        <button class="btncopy" data-copy="Outputs: (1) g(E) vs E for chosen Δn at T=0K and 300K; (2) g_pk(Δn); (3) Δn_tr, α from linear model; (4) full positive net-gain bandwidth in eV, Hz, nm.">Copy</button>
        <div><b>Final result type (what you ultimately deliver):</b></div>
        <div style="margin-top:8px;">
          A set of <b>numerical curves</b>:
          g(E) vs E, peak gain g<sub>pk</sub>(Δn), transparency Δn<sub>tr</sub> and α, and bandwidth vs Δn — for <b>T=0 K</b> and <b>T=300 K</b>.
        </div>
        <div class="small">All of these are computed and plotted live in the interactive canvases below.</div>
      </div>

      <h3>Connecting to the figure in the prompt</h3>
      <p>
        The provided figure shows peak gains of a few hundred cm⁻¹ for Δn up to about 2×10¹⁸ cm⁻³ and spectra centered a bit above 1.40 eV.
        With the calibration to τ<sub>r</sub> and the parabolic-band inversion physics, this simplified model reproduces the same <b>qualitative trends</b>:
        increasing Δn increases peak gain and broadens the gain window, while finite temperature smooths edges.
      </p>
    </article>

    <article id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the gain formula</h3>
      <ul>
        <li><b>α₀(E)</b> controls the spectral envelope set by DOS and transition strength: it rises as √(E−E<sub>g</sub>) just above the gap and is suppressed by 1/E.</li>
        <li><b>(f<sub>c</sub> − f<sub>v</sub>)</b> is the inversion “knob”: it is negative without injection and can become positive when quasi-Fermi splitting exceeds the transition energy range.</li>
        <li><b>Temperature</b> appears only through the Fermi functions (and N<sub>c</sub>, N<sub>v</sub>): increasing T broadens occupations and thus broadens/softens gain edges.</li>
      </ul>

      <h3>Parameter dependence (connect to plots)</h3>
      <ul>
        <li>Increase <b>Δn</b> → higher g<sub>pk</sub>, gain spectrum shifts slightly and expands because more states satisfy inversion.</li>
        <li>Switch <b>T: 0 K → 300 K</b> → edges smear; bandwidth often increases at small gain, but peak gain can be slightly reduced because inversion is less “perfect” at any single energy.</li>
        <li>Increase <b>p₀</b> (p-type doping) → holes are abundant; inversion may require less Δn on the hole side but electron degeneracy still matters.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        Instead of using α₀(E) by assumption, one can derive both α₀ and g(E) from Fermi’s golden rule for interband transitions,
        including the momentum matrix element and the optical mode energy density. That route yields the same dependence:
        a joint DOS factor √(E−E<sub>g</sub>) times Pauli blocking factors, and it provides the prefactor without calibration if the matrix element is known.
      </p>

      <h3>Concept checks (self-test)</h3>
      <ul>
        <li><b>Q:</b> Why is g(E) negative when Δn ≈ 0?<br/><b>A:</b> Because f<sub>c</sub>≈0 and f<sub>v</sub>≈1, so (f<sub>c</sub>−f<sub>v</sub>)≈−1 (pure absorption).</li>
        <li><b>Q:</b> What physical effect causes the gain spectrum to broaden at 300 K?<br/><b>A:</b> Thermal smearing of the Fermi edges: occupations transition smoothly rather than sharply.</li>
        <li><b>Q:</b> Why does α₀(E) scale like √(E−E<sub>g</sub>)?<br/><b>A:</b> The 3D joint density of states for parabolic bands scales as √(energy above the gap).</li>
        <li><b>Q:</b> What defines transparency in this model?<br/><b>A:</b> The injected density where peak material gain crosses 0 (no net stimulated amplification at any energy).</li>
      </ul>
    </article>

    <article id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="vizgrid">
        <div class="vizpanel">
          <div class="vizheader">
            <div>
              <div class="viztitle">Diagram — SOA gain measurement concept</div>
              <div class="smallnote">A cartoon of a waveguide SOA: injected carriers create population inversion → gain for photons with energies near the band edge.</div>
            </div>
          </div>
          <canvas id="cDiagram" aria-label="SOA diagram canvas"></canvas>
        </div>

        <div class="vizpanel">
          <div class="vizheader">
            <div>
              <div class="viztitle">Main Plot — Gain spectrum g(E) vs photon energy E</div>
              <div class="smallnote">
                Shows g(E) (cm⁻¹) for the selected Δn and temperature. Optional net-gain line uses α from the linearized material model.
              </div>
            </div>
            <div class="controls">
              <div class="ctrl">
                <span>Δn</span>
                <input id="sDn" type="range" min="0" max="2.2" step="0.01" value="1.6" />
                <span id="dnLabel" class="muted" style="min-width:92px; text-align:right;">1.60×10¹⁸</span>
              </div>
              <div class="ctrl">
                <span>T</span>
                <select id="selT">
                  <option value="300">300 K</option>
                  <option value="0">0 K</option>
                </select>
              </div>
              <div class="ctrl">
                <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                  <input id="chkNet" type="checkbox" checked />
                  <span>Show net (g−α)</span>
                </label>
              </div>
              <div class="ctrl">
                <button id="btnReset">Reset view</button>
              </div>
            </div>
          </div>
          <canvas id="cMain" aria-label="Gain spectrum canvas"></canvas>
          <div class="kpi">
            <div class="box">
              <div class="label">Peak gain g<sub>pk</sub> (cm⁻¹)</div>
              <div class="value" id="kpiGpk">—</div>
            </div>
            <div class="box">
              <div class="label">Peak energy E<sub>pk</sub> (eV)</div>
              <div class="value" id="kpiEpk">—</div>
            </div>
            <div class="box">
              <div class="label">Bandwidth (positive net gain) ΔE (eV)</div>
              <div class="value" id="kpiBW">—</div>
            </div>
            <div class="box">
              <div class="label">Bandwidth Δν (Hz)</div>
              <div class="value" id="kpiBWhz">—</div>
            </div>
            <div class="box">
              <div class="label">Bandwidth Δλ (nm)</div>
              <div class="value" id="kpiBWnm">—</div>
            </div>
          </div>
        </div>

        <div class="vizpanel">
          <div class="vizheader">
            <div>
              <div class="viztitle">Secondary Plot — Parameter sweep vs Δn</div>
              <div class="smallnote">Choose what to sweep: peak gain or bandwidth. Both temperatures are drawn for comparison.</div>
            </div>
            <div class="controls">
              <div class="ctrl">
                <span>Quantity</span>
                <select id="selSweep">
                  <option value="gpk">Peak gain gpk(Δn)</option>
                  <option value="bw_eV">Bandwidth ΔE(Δn)</option>
                  <option value="bw_Hz">Bandwidth Δν(Δn)</option>
                  <option value="bw_nm">Bandwidth Δλ(Δn)</option>
                </select>
              </div>
              <div class="ctrl">
                <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                  <input id="chkMarkers" type="checkbox" checked />
                  <span>Mark current Δn</span>
                </label>
              </div>
            </div>
          </div>
          <canvas id="cSweep" aria-label="Sweep canvas"></canvas>
          <div class="smallnote" id="fitNote">—</div>
        </div>
      </div>

      <h3>How the interactive controls affect the physics</h3>
      <ul>
        <li><b>Δn slider</b>: increases electron density and also increases hole density (p = p₀ + Δn). This changes quasi-Fermi levels and therefore the inversion factor (f<sub>c</sub> − f<sub>v</sub>) across energies.</li>
        <li><b>T selector</b>: switches between sharp T=0 K occupations and thermally broadened 300 K occupations.</li>
        <li><b>Show net (g−α)</b>: overlays a net gain curve after subtracting the extracted “loss-like offset” α from the linearized model.</li>
        <li><b>Sweep plot selector</b>: switches the y-axis to peak gain or bandwidth in different units while keeping the same Δn axis.</li>
      </ul>
    </article>

  </div>
</main>

<footer>
  <div class="printonly">
    <b>Print note:</b> Copy buttons are hidden in print mode. The canvases print as static snapshots.
  </div>
  <p>
    Model note: This article uses a standard parabolic-band gain model g(E)=α₀(E)(f<sub>c</sub>−f<sub>v</sub>) and calibrates the single prefactor using the provided τ<sub>r</sub> scale at a reference injection.
    This reproduces the qualitative behavior of classic GaAs SOA gain curves and gives the correct order of magnitude without requiring an explicit momentum matrix element.
  </p>
</footer>

<script>
(() => {
  // ---------- Helpers ----------
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const fmt = {
    sci18: (x)=> (x>=0? "" : "−") + (Math.abs(x)).toFixed(2) + "×10¹⁸",
    cm1: (x)=> (isFinite(x)? x.toFixed(1) : "—"),
    eV: (x)=> (isFinite(x)? x.toFixed(4) : "—"),
    hz: (x)=> {
      if(!isFinite(x)) return "—";
      const ax=Math.abs(x);
      if(ax>=1e12) return (x/1e12).toFixed(3)+"×10¹²";
      if(ax>=1e9)  return (x/1e9).toFixed(3)+"×10⁹";
      if(ax>=1e6)  return (x/1e6).toFixed(3)+"×10⁶";
      return x.toFixed(3);
    },
    nm: (x)=> (isFinite(x)? x.toFixed(2) : "—"),
    dncm3: (x)=> (x*1e18).toExponential(3).replace('e+','×10^')
  };

  function copyText(text){
    navigator.clipboard?.writeText(text).then(()=>{},()=>{});
  }
  document.querySelectorAll('.btncopy').forEach(btn=>{
    btn.addEventListener('click', ()=> copyText(btn.getAttribute('data-copy')||""));
  });

  // ---------- Physical constants (SI) ----------
  const q = 1.602176634e-19;           // C
  const h = 6.62607015e-34;            // J·s
  const hb = h/(2*Math.PI);            // J·s
  const kB = 1.380649e-23;             // J/K
  const c0 = 299792458;                // m/s
  const m0 = 9.1093837015e-31;         // kg

  // ---------- Given device/material parameters ----------
  const Eg_eV = 1.40;
  const Eg = Eg_eV*q;
  const n_refr = 3.6;
  const mc = 0.07*m0;
  const mv = 0.50*m0;
  const mr = (mc*mv)/(mc+mv);
  const p0_cm3 = 1.2e18; // cm^-3
  const tau_r = 2e-9;    // s

  // Reference injection for calibration (stated in text)
  const dnRef_cm3 = 1.0e18;

  // Energy grid for spectra (eV)
  const Emin_eV = 1.36;
  const Emax_eV = 1.46;
  const NE = 520;

  // Sweep grid in Δn (in units of 1e18 cm^-3)
  const dnMin = 0.0;
  const dnMax = 2.2;
  const Nd = 70;

  // ---------- Numerical Fermi-Dirac integral F_{1/2} and inversion ----------
  // We compute F_{1/2}(eta) = (2/sqrt(pi)) ∫_0^∞ sqrt(t)/(1+exp(t-eta)) dt
  // Use a finite upper bound and Simpson's rule; good accuracy for our plotting range.
  function F12(eta){
    // Choose upper bound depending on eta to capture the tail.
    const tMax = Math.max(30, eta + 30);
    const N = 320; // even
    const dt = tMax/N;
    let sum = 0;
    for(let i=0;i<=N;i++){
      const t = i*dt;
      const w = (i===0||i===N) ? 1 : (i%2===0 ? 2 : 4);
      const denom = 1 + Math.exp(t - eta);
      const integrand = (t<=0)?0: Math.sqrt(t)/denom;
      sum += w*integrand;
    }
    const integral = (dt/3)*sum;
    return (2/Math.sqrt(Math.PI))*integral;
  }

  function invertF12(target){
    // Solve F12(eta) = target for eta by bisection.
    // target >= 0.
    if(target<=0) return -60;
    // bracket
    let lo = -60, hi = 60;
    // If extremely large, widen.
    for(let iter=0; iter<6; iter++){
      if(F12(hi) >= target) break;
      hi *= 1.6;
      if(hi>240) break;
    }
    let fLo = F12(lo) - target;
    let fHi = F12(hi) - target;
    if(fLo>0) return lo;
    if(fHi<0) return hi;
    for(let i=0;i<60;i++){
      const mid = 0.5*(lo+hi);
      const fMid = F12(mid) - target;
      if(fMid===0) return mid;
      if(fMid>0){ hi=mid; fHi=fMid; }
      else { lo=mid; fLo=fMid; }
    }
    return 0.5*(lo+hi);
  }

  // ---------- Effective DOS ----------
  function Nc(T){
    if(T<=0) return NaN;
    return 2*Math.pow(2*Math.PI*mc*kB*T/(h*h), 1.5); // m^-3
  }
  function Nv(T){
    if(T<=0) return NaN;
    return 2*Math.pow(2*Math.PI*mv*kB*T/(h*h), 1.5); // m^-3
  }

  // ---------- Quasi-Fermi levels relative to band edges ----------
  // Returns {etaN, etaP, dEn, dEp} where:
  // etaN = (EFn - Ec)/kT, etaP = (Ev - EFp)/kT (note sign convention for holes)
  // dEn = (EFn - Ec) in J, dEp = (Ev - EFp) in J
  function quasiFermi(T, n_m3, p_m3){
    if(T<=0){
      // T=0 K: directly from density formulas:
      // n = (1/(3π^2)) (2mc/ħ^2)^(3/2) (dEn)^(3/2)
      // => dEn = [ n * 3π^2 / (2mc/ħ^2)^(3/2) ]^(2/3)
      const prefN = (1/(3*Math.PI*Math.PI))*Math.pow(2*mc/(hb*hb), 1.5);
      const prefP = (1/(3*Math.PI*Math.PI))*Math.pow(2*mv/(hb*hb), 1.5);
      const dEn = Math.pow(n_m3 / prefN, 2/3);
      const dEp = Math.pow(p_m3 / prefP, 2/3);
      return {etaN: Infinity, etaP: Infinity, dEn, dEp};
    } else {
      const NcT = Nc(T);
      const NvT = Nv(T);
      const etaN = invertF12(n_m3 / NcT);
      const etaP = invertF12(p_m3 / NvT);
      const dEn = etaN*kB*T;
      const dEp = etaP*kB*T;
      return {etaN, etaP, dEn, dEp};
    }
  }

  // ---------- Fermi functions for conduction/valence states ----------
  // We set Ec0 = 0, Ev0 = -Eg (energy reference). Only differences matter.
  function fFD(E, EF, T){
    if(T<=0){
      return (E <= EF) ? 1 : 0;
    }
    return 1/(1+Math.exp((E - EF)/(kB*T)));
  }

  // For a transition at photon energy E = Eg + (ħ^2 k^2)/(2mr):
  // conduction state energy relative to Ec0: epsc = (mr/mc)(E-Eg)
  // valence state energy relative to Ev0: -epsv, where epsv = (mr/mv)(E-Eg)
  function inversionFactor(E, T, dEn, dEp){
    // E in J
    if(E<=Eg) return -1; // below gap: model says no interband transitions (so we won't use it); keep consistent sign.
    const dE = E - Eg;
    const epsc = (mr/mc)*dE; // J above Ec0
    const epsv = (mr/mv)*dE; // J below Ev0 (hole kinetic)
    // Energies of specific states:
    const Ec_state = 0 + epsc;
    const Ev_state = -Eg - epsv; // below Ev0
    // Quasi-Fermi levels:
    const EFn = 0 + dEn;
    const EFp = -Eg - dEp;
    const fc = fFD(Ec_state, EFn, T);
    const fv = fFD(Ev_state, EFp, T);
    return {inv: (fc - fv), fc, fv};
  }

  // ---------- Empty-band absorption shape α0(E) = A * sqrt(E-Eg)/E for E>Eg ----------
  function alpha0_shape(E){
    if(E<=Eg) return 0;
    return Math.sqrt(E - Eg)/E; // units: J^{-1/2}
  }

  // ---------- Calibrate A using tau_r at dnRef, T=300K ----------
  // We use a proportionality R_rad = K * A * ∫ E^2 alpha0_shape(E) fc(1-fv) dE.
  // We choose K = 1 (absorbed into A), so A is simply set so that R_rad = dnRef/tau_r.
  // This keeps a single scaling parameter and preserves all spectral/occupation physics.
  function calibrateA(){
    const T = 300;
    const dn_m3 = dnRef_cm3 * 1e6;
    const p_m3  = (p0_cm3 + dnRef_cm3) * 1e6;
    const qf = quasiFermi(T, dn_m3, p_m3);

    // integral I = ∫ E^2 * alpha0_shape(E) * fc*(1-fv) dE over energy range
    const E0 = Emin_eV*q;
    const E1 = Emax_eV*q;
    const N = 1200; // integrate with trapezoid
    const dE = (E1-E0)/N;
    let I = 0;
    for(let i=0;i<=N;i++){
      const E = E0 + i*dE;
      const w = (i===0||i===N)? 0.5 : 1;
      if(E<=Eg) continue;
      const {fc,fv} = inversionFactor(E, T, qf.dEn, qf.dEp);
      const term = (E*E) * alpha0_shape(E) * fc * (1 - fv);
      I += w*term;
    }
    I *= dE;

    const Rtarget = dn_m3 / tau_r; // s^-1 m^-3
    // Our model uses R_rad = A * I, so A = Rtarget / I
    return Rtarget / I;
  }

  const Acal = calibrateA();

  // ---------- Spectrum computation ----------
  function computeSpectrum(dn18, T){
    // dn18 is Δn in units of 1e18 cm^-3
    const dn_cm3 = dn18*1e18;
    const n_m3 = dn_cm3*1e6;
    const p_m3 = (p0_cm3 + dn_cm3)*1e6;
    const qf = quasiFermi(T, n_m3, p_m3);

    const Es = new Float64Array(NE);
    const g  = new Float64Array(NE); // in 1/m
    const invArr = new Float64Array(NE);

    for(let i=0;i<NE;i++){
      const EeV = lerp(Emin_eV, Emax_eV, i/(NE-1));
      const E = EeV*q;
      Es[i] = EeV;
      if(E<=Eg){
        g[i]=0;
        invArr[i]=0;
        continue;
      }
      const inv = inversionFactor(E, T, qf.dEn, qf.dEp).inv;
      invArr[i]=inv;
      const a0 = Acal * alpha0_shape(E); // units chosen so that result is ~1/m scale
      g[i] = a0 * inv; // 1/m
    }

    // peak
    let gpk = -1e99, ipk = 0;
    for(let i=0;i<NE;i++){
      if(g[i]>gpk){ gpk=g[i]; ipk=i; }
    }
    return {Es, g, invArr, gpk, Epk: Es[ipk], qf};
  }

  // ---------- Transparency and loss-like alpha from linear model ----------
  // We:
  // (1) compute gpk(Δn) over sweep grid
  // (2) find Δn_tr where gpk crosses 0 (interpolated)
  // (3) define alpha = -gpk(Δn=0) (material peak absorption magnitude)
  // (4) fit a line near transparency to get slope a (for display)
  function computeSweep(T){
    const dn = new Float64Array(Nd);
    const gpk_cm1 = new Float64Array(Nd);
    const bw_eV = new Float64Array(Nd);
    const bw_Hz = new Float64Array(Nd);
    const bw_nm = new Float64Array(Nd);

    // First compute gpk and store spectra edges for bandwidth using alpha defined at dn=0 later.
    const spectra = [];
    for(let i=0;i<Nd;i++){
      const dn18 = lerp(dnMin, dnMax, i/(Nd-1));
      dn[i]=dn18;
      const sp = computeSpectrum(dn18, T);
      spectra.push(sp);
      gpk_cm1[i] = sp.gpk * 0.01; // 1/m -> 1/cm
    }

    const alpha_cm1 = -gpk_cm1[0]; // peak absorption magnitude at dn=0
    // Bandwidth where g - alpha > 0
    for(let i=0;i<Nd;i++){
      const sp = spectra[i];
      // net gain in cm^-1
      let left = NaN, right = NaN;
      for(let j=0;j<NE-1;j++){
        const g1 = sp.g[j]*0.01 - alpha_cm1;
        const g2 = sp.g[j+1]*0.01 - alpha_cm1;
        const E1 = sp.Es[j], E2 = sp.Es[j+1];
        // find first crossing into positive region
        if(isNaN(left)){
          if(g1<=0 && g2>0){
            const t = (0 - g1)/(g2 - g1);
            left = lerp(E1,E2,t);
          }
          // if already positive at first point
          if(j===0 && g1>0) left = E1;
        }
        // find last crossing out of positive region
        if(!isNaN(left) && isNaN(right)){
          if(g1>0 && g2<=0){
            const t = (0 - g1)/(g2 - g1);
            right = lerp(E1,E2,t);
          }
        }
      }
      // If never crosses out and ends positive:
      const gEnd = sp.g[NE-1]*0.01 - alpha_cm1;
      if(!isNaN(left) && isNaN(right) && gEnd>0) right = sp.Es[NE-1];

      if(isNaN(left) || isNaN(right) || right<=left){
        bw_eV[i]=0; bw_Hz[i]=0; bw_nm[i]=0;
      } else {
        const dE = right-left; // eV
        bw_eV[i]=dE;
        bw_Hz[i]= (dE*q)/h; // Hz
        // convert to wavelength edges
        const lamL = (h*c0)/(left*q);  // m
        const lamR = (h*c0)/(right*q); // m
        // bandwidth in nm = |λ(left) - λ(right)|
        bw_nm[i]= Math.abs(lamL - lamR)*1e9;
      }
    }

    // Transparency Δn_tr where gpk crosses 0 (material)
    let dn_tr = NaN;
    for(let i=0;i<Nd-1;i++){
      const y1 = gpk_cm1[i], y2 = gpk_cm1[i+1];
      if((y1<=0 && y2>=0) || (y1>=0 && y2<=0)){
        const t = (0 - y1)/(y2 - y1);
        dn_tr = lerp(dn[i], dn[i+1], t);
        break;
      }
    }

    // Linear fit near transparency: take a window around dn_tr
    let slope = NaN, intercept = NaN;
    if(isFinite(dn_tr)){
      const x=[], y=[];
      for(let i=0;i<Nd;i++){
        if(Math.abs(dn[i]-dn_tr) <= 0.35){ // window
          x.push(dn[i]); y.push(gpk_cm1[i]);
        }
      }
      if(x.length>=6){
        let sx=0, sy=0, sxx=0, sxy=0;
        const n=x.length;
        for(let i=0;i<n;i++){
          sx+=x[i]; sy+=y[i];
          sxx+=x[i]*x[i]; sxy+=x[i]*y[i];
        }
        slope = (n*sxy - sx*sy)/(n*sxx - sx*sx);
        intercept = (sy - slope*sx)/n;
      }
    }

    return {T, dn, gpk_cm1, bw_eV, bw_Hz, bw_nm, alpha_cm1, dn_tr, slope, intercept};
  }

  // Precompute sweep arrays for both temperatures
  const sweep300 = computeSweep(300);
  const sweep0   = computeSweep(0);

  // ---------- Plotting primitives ----------
  function setupCanvas(canvas){
    const ctx = canvas.getContext('2d');
    function resize(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(320, rect.width);
      const h = Math.max(260, rect.height);
      canvas.width = Math.round(w*dpr);
      canvas.height = Math.round(h*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {w, h, dpr};
    }
    return {ctx, resize};
  }

  function drawAxes(ctx, W, H, pad, xMin,xMax,yMin,yMax, xLabel, yLabel, title){
    // background
    ctx.clearRect(0,0,W,H);
    // title
    ctx.save();
    ctx.fillStyle = "rgba(233,238,247,.92)";
    ctx.font = "700 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(title, pad, pad-8);
    ctx.restore();

    const x0 = pad, y0 = H-pad, x1 = W-pad, y1 = pad;
    // grid
    const nGrid = 6;
    ctx.save();
    ctx.strokeStyle = "rgba(233,238,247,.08)";
    ctx.lineWidth = 1;
    for(let i=0;i<=nGrid;i++){
      const t = i/nGrid;
      const x = lerp(x0,x1,t);
      const y = lerp(y0,y1,t);
      ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y1); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke();
    }
    ctx.restore();

    // axes box
    ctx.save();
    ctx.strokeStyle = "rgba(233,238,247,.16)";
    ctx.lineWidth = 1.2;
    ctx.strokeRect(x0,y1,x1-x0,y0-y1);
    ctx.restore();

    // ticks + labels
    ctx.save();
    ctx.fillStyle = "rgba(169,182,204,.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
    ctx.strokeStyle = "rgba(233,238,247,.18)";
    ctx.lineWidth = 1;

    const tickN = 6;
    for(let i=0;i<=tickN;i++){
      const t=i/tickN;
      const x=lerp(x0,x1,t);
      const xv=lerp(xMin,xMax,t);
      ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+6); ctx.stroke();
      const s = xv.toFixed(3);
      ctx.fillText(s, x-ctx.measureText(s).width/2, y0+20);
    }
    for(let i=0;i<=tickN;i++){
      const t=i/tickN;
      const y=lerp(y0,y1,t);
      const yv=lerp(yMin,yMax,t);
      ctx.beginPath(); ctx.moveTo(x0-6,y); ctx.lineTo(x0,y); ctx.stroke();
      const s = yv.toFixed(1);
      ctx.fillText(s, x0-10-ctx.measureText(s).width, y+4);
    }

    // axis labels
    ctx.fillStyle = "rgba(233,238,247,.88)";
    ctx.font = "12.5px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(xLabel, (x0+x1)/2 - ctx.measureText(xLabel).width/2, H-10);

    ctx.save();
    ctx.translate(12, (y0+y1)/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
    ctx.restore();

    ctx.restore();

    function xPix(x){ return x0 + (x-xMin)/(xMax-xMin)*(x1-x0); }
    function yPix(y){ return y0 - (y-yMin)/(yMax-yMin)*(y0-y1); }
    return {x0,y0,x1,y1,xPix,yPix};
  }

  function strokeLine(ctx, xs, ys, mapX, mapY, color, width=2){
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.beginPath();
    let started=false;
    for(let i=0;i<xs.length;i++){
      const x = mapX(xs[i]);
      const y = mapY(ys[i]);
      if(!isFinite(y) || !isFinite(x)) continue;
      if(!started){ ctx.moveTo(x,y); started=true; }
      else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawLegend(ctx, items, x, y){
    ctx.save();
    ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.textBaseline="middle";
    const pad=8, rowH=18;
    const w = Math.max(...items.map(it=> ctx.measureText(it.label).width )) + 54;
    const h = items.length*rowH + pad*2;
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.strokeStyle = "rgba(233,238,247,.14)";
    ctx.lineWidth=1;
    ctx.beginPath();
    const r=12;
    // rounded rect
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    for(let i=0;i<items.length;i++){
      const yy = y+pad + i*rowH + rowH/2;
      ctx.strokeStyle = items[i].color;
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(x+12,yy); ctx.lineTo(x+32,yy); ctx.stroke();
      ctx.fillStyle = "rgba(233,238,247,.92)";
      ctx.fillText(items[i].label, x+38, yy);
    }
    ctx.restore();
  }

  // ---------- Canvases ----------
  const diag = setupCanvas(document.getElementById('cDiagram'));
  const main = setupCanvas(document.getElementById('cMain'));
  const sweep = setupCanvas(document.getElementById('cSweep'));

  // ---------- Diagram drawing ----------
  function drawDiagram(){
    const {ctx} = diag;
    const {w:W, h:H} = diag.resize();
    ctx.clearRect(0,0,W,H);

    // Soft vignette background
    ctx.save();
    const grd = ctx.createRadialGradient(W*0.25,H*0.25, 20, W*0.5,H*0.5, Math.max(W,H)*0.8);
    grd.addColorStop(0,"rgba(125,211,252,.10)");
    grd.addColorStop(0.55,"rgba(167,139,250,.07)");
    grd.addColorStop(1,"rgba(0,0,0,0)");
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    const pad=18;
    const x0=pad, x1=W-pad;
    const yMid=H*0.58;

    // waveguide body
    ctx.save();
    ctx.fillStyle="rgba(16,24,36,.75)";
    ctx.strokeStyle="rgba(233,238,247,.18)";
    ctx.lineWidth=1.2;
    roundRect(ctx, x0+20, yMid-45, (x1-x0)-40, 90, 18);
    ctx.fill(); ctx.stroke();
    ctx.restore();

    // active region stripe
    ctx.save();
    ctx.fillStyle="rgba(125,211,252,.12)";
    roundRect(ctx, x0+52, yMid-18, (x1-x0)-104, 36, 14);
    ctx.fill();
    ctx.restore();

    // contacts/injection arrows
    ctx.save();
    ctx.strokeStyle="rgba(233,238,247,.22)";
    ctx.fillStyle="rgba(233,238,247,.82)";
    ctx.lineWidth=1.3;
    ctx.font="12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    // top contact
    roundRect(ctx, x0+120, yMid-95, 120, 26, 10);
    ctx.stroke();
    ctx.fillText("p-contact", x0+144, yMid-77);
    // bottom contact
    roundRect(ctx, x0+120, yMid+69, 120, 26, 10);
    ctx.stroke();
    ctx.fillText("n-contact", x0+144, yMid+87);

    // injection arrows
    arrow(ctx, x0+180, yMid-69, x0+180, yMid-28);
    arrow(ctx, x0+180, yMid+69, x0+180, yMid+28);
    ctx.fillText("inject carriers (Δn)", x0+205, yMid-40);
    ctx.fillText("inject carriers (Δn)", x0+205, yMid+50);
    ctx.restore();

    // optical input/output
    ctx.save();
    ctx.strokeStyle="rgba(52,211,153,.55)";
    ctx.lineWidth=3;
    arrow(ctx, x0+6, yMid, x0+64, yMid);
    arrow(ctx, x1-64, yMid, x1-6, yMid);
    ctx.fillStyle="rgba(233,238,247,.86)";
    ctx.font="12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText("optical in", x0+8, yMid-14);
    ctx.fillText("optical out (amplified)", x1-170, yMid-14);
    ctx.restore();

    // band diagram inset
    const bx=W*0.66, by=H*0.13, bw=W*0.30, bh=H*0.28;
    ctx.save();
    ctx.fillStyle="rgba(0,0,0,.25)";
    ctx.strokeStyle="rgba(233,238,247,.14)";
    ctx.lineWidth=1;
    roundRect(ctx, bx, by, bw, bh, 16);
    ctx.fill(); ctx.stroke();

    ctx.save();
    ctx.beginPath();
    ctx.rect(bx+10,by+10,bw-20,bh-20);
    ctx.clip();

    // bands
    ctx.strokeStyle="rgba(125,211,252,.8)";
    ctx.lineWidth=2.2;
    ctx.beginPath();
    ctx.moveTo(bx+20, by+bh*0.72);
    ctx.quadraticCurveTo(bx+bw*0.55, by+bh*0.55, bx+bw-20, by+bh*0.26);
    ctx.stroke();

    ctx.strokeStyle="rgba(167,139,250,.8)";
    ctx.beginPath();
    ctx.moveTo(bx+20, by+bh*0.78);
    ctx.quadraticCurveTo(bx+bw*0.55, by+bh*0.92, bx+bw-20, by+bh*0.98);
    ctx.stroke();

    // photon arrow
    ctx.strokeStyle="rgba(52,211,153,.8)";
    ctx.lineWidth=2.4;
    arrow(ctx, bx+bw*0.36, by+bh*0.84, bx+bw*0.50, by+bh*0.44);

    ctx.restore();

    ctx.fillStyle="rgba(233,238,247,.86)";
    ctx.font="12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText("quasi-Fermi split", bx+18, by+18);
    ctx.fillText("hν ≈ Eg + kinetic", bx+18, by+34);
    ctx.restore();

    // labels
    ctx.save();
    ctx.fillStyle="rgba(233,238,247,.92)";
    ctx.font="700 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText("SOA physical picture", 18, 18);
    ctx.restore();
  }

  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }
  function arrow(ctx,x1,y1,x2,y2){
    const head=10;
    const dx=x2-x1, dy=y2-y1;
    const L=Math.hypot(dx,dy) || 1;
    const ux=dx/L, uy=dy/L;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2 - head*(ux) - head*0.55*(-uy), y2 - head*(uy) - head*0.55*(ux));
    ctx.lineTo(x2 - head*(ux) + head*0.55*(-uy), y2 - head*(uy) + head*0.55*(ux));
    ctx.closePath();
    ctx.fill();
  }

  // ---------- Main spectrum plot ----------
  let view = {
    yMin: -120, yMax: 420, // cm^-1
    xMin: Emin_eV, xMax: Emax_eV
  };

  function nearestSweepValue(sweepObj, dn18){
    // interpolate arrays for current dn18
    const dn = sweepObj.dn;
    const i = clamp(Math.floor((dn18 - dnMin)/(dnMax-dnMin)*(Nd-1)), 0, Nd-2);
    const t = (dn18 - dn[i])/(dn[i+1]-dn[i] || 1);
    function interp(arr){ return lerp(arr[i], arr[i+1], clamp(t,0,1)); }
    return {
      gpk: interp(sweepObj.gpk_cm1),
      bw_eV: interp(sweepObj.bw_eV),
      bw_Hz: interp(sweepObj.bw_Hz),
      bw_nm: interp(sweepObj.bw_nm),
      alpha: sweepObj.alpha_cm1,
      dn_tr: sweepObj.dn_tr,
      slope: sweepObj.slope,
      intercept: sweepObj.intercept
    };
  }

  function drawMain(){
    const {ctx} = main;
    const {w:W, h:H} = main.resize();
    const dn18 = parseFloat(document.getElementById('sDn').value);
    const T = parseInt(document.getElementById('selT').value,10);
    const showNet = document.getElementById('chkNet').checked;

    const sp = computeSpectrum(dn18, T);
    const g_cm1 = Array.from(sp.g, v=> v*0.01);

    // use sweep-derived alpha (material peak absorption at dn=0 for this T)
    const sweepObj = (T===300) ? sweep300 : sweep0;
    const meta = nearestSweepValue(sweepObj, dn18);
    const alpha = meta.alpha;

    // auto y-limits if extreme
    const gMax = Math.max(...g_cm1);
    const gMin = Math.min(...g_cm1);
    const yMin = Math.min(view.yMin, gMin-30, showNet ? (gMin-alpha)-30 : gMin-30);
    const yMax = Math.max(view.yMax, gMax+30, showNet ? (gMax-alpha)+30 : gMax+30);

    const ax = drawAxes(
      ctx, W, H, 56,
      view.xMin, view.xMax,
      yMin, yMax,
      "Photon energy E = hν (eV)",
      "Gain g (cm⁻¹)",
      `Material gain spectrum (T = ${T} K,  Δn = ${dn18.toFixed(2)}×10¹⁸ cm⁻³)`
    );

    // curve colors (kept consistent)
    const colG = "rgba(125,211,252,.92)";
    const colNet = "rgba(52,211,153,.88)";
    const colZero = "rgba(233,238,247,.35)";
    const colEg = "rgba(251,191,36,.65)";

    // zero line
    ctx.save();
    ctx.strokeStyle = colZero;
    ctx.lineWidth = 1.2;
    ctx.setLineDash([6,5]);
    ctx.beginPath();
    ctx.moveTo(ax.x0, ax.yPix(0));
    ctx.lineTo(ax.x1, ax.yPix(0));
    ctx.stroke();
    ctx.restore();

    // Eg marker
    ctx.save();
    ctx.strokeStyle = colEg;
    ctx.lineWidth = 1.2;
    ctx.setLineDash([5,5]);
    ctx.beginPath();
    ctx.moveTo(ax.xPix(Eg_eV), ax.y0);
    ctx.lineTo(ax.xPix(Eg_eV), ax.y1);
    ctx.stroke();
    ctx.fillStyle = "rgba(251,191,36,.9)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
    ctx.fillText("Eg", ax.xPix(Eg_eV)+6, ax.y1+16);
    ctx.restore();

    // g(E)
    strokeLine(ctx, sp.Es, g_cm1, ax.xPix, ax.yPix, colG, 2.4);

    // net gain
    if(showNet){
      const gnet = g_cm1.map(v=> v - alpha);
      strokeLine(ctx, sp.Es, gnet, ax.xPix, ax.yPix, colNet, 2.2);
    }

    // peak marker
    ctx.save();
    const gpk = sp.gpk*0.01;
    const xpk = ax.xPix(sp.Epk);
    const ypk = ax.yPix(gpk);
    ctx.fillStyle = "rgba(233,238,247,.95)";
    ctx.strokeStyle = "rgba(233,238,247,.4)";
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.arc(xpk, ypk, 4.5, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // legend
    const items = [{label:"g(E)", color:colG}];
    if(showNet) items.push({label:"g(E) − α", color:colNet});
    drawLegend(ctx, items, ax.x1-150, ax.y1+10);

    // KPIs
    document.getElementById('kpiGpk').textContent = fmt.cm1(gpk);
    document.getElementById('kpiEpk').textContent = fmt.eV(sp.Epk);

    // bandwidth based on sweep interpolation (computed using net gain definition)
    document.getElementById('kpiBW').textContent = meta.bw_eV.toFixed(4);
    document.getElementById('kpiBWhz').textContent = fmt.hz(meta.bw_Hz);
    document.getElementById('kpiBWnm').textContent = fmt.nm(meta.bw_nm);

    // Δn label
    document.getElementById('dnLabel').textContent = `${dn18.toFixed(2)}×10¹⁸`;
  }

  // ---------- Sweep plot ----------
  function drawSweep(){
    const {ctx} = sweep;
    const {w:W, h:H} = sweep.resize();
    const dn18 = parseFloat(document.getElementById('sDn').value);
    const what = document.getElementById('selSweep').value;
    const mark = document.getElementById('chkMarkers').checked;

    const xMin = dnMin, xMax = dnMax;

    function selectY(s){
      if(what==="gpk") return {arr:s.gpk_cm1, label:"Peak gain gpk (cm⁻¹)"};
      if(what==="bw_eV") return {arr:s.bw_eV, label:"Bandwidth ΔE (eV)"};
      if(what==="bw_Hz") return {arr:s.bw_Hz.map(v=>v*1e-12), label:"Bandwidth Δν (×10¹² Hz)"};
      if(what==="bw_nm") return {arr:s.bw_nm, label:"Bandwidth Δλ (nm)"};
      return {arr:s.gpk_cm1, label:"Peak gain gpk (cm⁻¹)"};
    }

    const y300 = selectY(sweep300);
    const y0 = selectY(sweep0);

    const all = [...y300.arr, ...y0.arr].filter(v=>isFinite(v));
    let yMin = Math.min(...all);
    let yMax = Math.max(...all);
    if(what==="gpk"){
      yMin = Math.min(yMin, -40);
      yMax = Math.max(yMax, 420);
    } else {
      yMin = Math.min(0, yMin);
      yMax = yMax*1.08 + (yMax===0?1:0);
    }

    const ax = drawAxes(
      ctx, W, H, 56,
      xMin, xMax,
      yMin, yMax,
      "Injected carrier density Δn (×10¹⁸ cm⁻³)",
      y300.label,
      `Sweep vs Δn (compare T = 300 K and 0 K)`
    );

    const col300 = "rgba(125,211,252,.92)";
    const col0   = "rgba(167,139,250,.90)";
    const colZero= "rgba(233,238,247,.30)";

    // zero line if useful
    if(what==="gpk"){
      ctx.save();
      ctx.strokeStyle = colZero;
      ctx.setLineDash([6,5]);
      ctx.lineWidth=1.2;
      ctx.beginPath();
      ctx.moveTo(ax.x0, ax.yPix(0));
      ctx.lineTo(ax.x1, ax.yPix(0));
      ctx.stroke();
      ctx.restore();
    }

    // plot
    strokeLine(ctx, sweep300.dn, y300.arr, ax.xPix, ax.yPix, col300, 2.4);
    strokeLine(ctx, sweep0.dn, y0.arr, ax.xPix, ax.yPix, col0, 2.4);

    // markers for current Δn
    if(mark){
      const m300 = nearestSweepValue(sweep300, dn18);
      const m0 = nearestSweepValue(sweep0, dn18);

      const yCur300 = (what==="gpk") ? m300.gpk :
                      (what==="bw_eV") ? m300.bw_eV :
                      (what==="bw_Hz") ? (m300.bw_Hz*1e-12) :
                      (what==="bw_nm") ? m300.bw_nm : m300.gpk;
      const yCur0 = (what==="gpk") ? m0.gpk :
                    (what==="bw_eV") ? m0.bw_eV :
                    (what==="bw_Hz") ? (m0.bw_Hz*1e-12) :
                    (what==="bw_nm") ? m0.bw_nm : m0.gpk;

      ctx.save();
      ctx.fillStyle="rgba(233,238,247,.95)";
      ctx.strokeStyle="rgba(233,238,247,.35)";
      ctx.lineWidth=1.2;

      // 300K
      ctx.beginPath();
      ctx.arc(ax.xPix(dn18), ax.yPix(yCur300), 4.5, 0, Math.PI*2);
      ctx.fill(); ctx.stroke();

      // 0K
      ctx.beginPath();
      ctx.arc(ax.xPix(dn18), ax.yPix(yCur0), 4.5, 0, Math.PI*2);
      ctx.fill(); ctx.stroke();
      ctx.restore();
    }

    drawLegend(ctx, [
      {label:"T=300 K", color:col300},
      {label:"T=0 K", color:col0}
    ], ax.x1-140, ax.y1+10);

    // Fit/parameters note (for gpk case, show alpha and transparency for both)
    const note = [];
    if(what==="gpk"){
      note.push(`<b>Linearized peak-gain model (near transparency):</b> gpk(Δn) ≈ a(Δn − Δn_tr).`);
      note.push(`T=300 K: Δn_tr ≈ ${isFinite(sweep300.dn_tr)? sweep300.dn_tr.toFixed(3) : "—"}×10¹⁸ cm⁻³,  α ≈ ${sweep300.alpha_cm1.toFixed(1)} cm⁻¹,  slope a ≈ ${isFinite(sweep300.slope)? sweep300.slope.toFixed(1):"—"} cm⁻¹/(10¹⁸ cm⁻³).`);
      note.push(`T=0 K: Δn_tr ≈ ${isFinite(sweep0.dn_tr)? sweep0.dn_tr.toFixed(3) : "—"}×10¹⁸ cm⁻³,  α ≈ ${sweep0.alpha_cm1.toFixed(1)} cm⁻¹,  slope a ≈ ${isFinite(sweep0.slope)? sweep0.slope.toFixed(1):"—"} cm⁻¹/(10¹⁸ cm⁻³).`);
    } else {
      note.push(`<b>Bandwidth definition:</b> full energy span where net gain g(E) − α > 0, using α from the linearized material offset at Δn=0 for each temperature.`);
    }
    document.getElementById('fitNote').innerHTML = note.join("<br/>");
  }

  // ---------- UI wiring ----------
  function redrawAll(){
    drawDiagram();
    drawMain();
    drawSweep();
  }
  window.addEventListener('resize', redrawAll);

  document.getElementById('sDn').addEventListener('input', ()=>{ drawMain(); drawSweep(); });
  document.getElementById('selT').addEventListener('change', ()=>{ drawMain(); });
  document.getElementById('chkNet').addEventListener('change', ()=>{ drawMain(); });
  document.getElementById('selSweep').addEventListener('change', ()=>{ drawSweep(); });
  document.getElementById('chkMarkers').addEventListener('change', ()=>{ drawSweep(); });
  document.getElementById('btnReset').addEventListener('click', ()=>{
    view = {yMin:-120, yMax:420, xMin:Emin_eV, xMax:Emax_eV};
    redrawAll();
  });

  // ---------- Initial draw ----------
  redrawAll();

})();
</script>
</body>
</html>
