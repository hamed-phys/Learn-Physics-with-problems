<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Dependence of Laser-Diode Output Photon Flux on Refractive Index</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#0f1726;
      --card:#101a2e;
      --text:#e7eefc;
      --muted:#a9b8da;
      --faint:#7f93c6;
      --accent:#7cf0c6;
      --accent2:#7aa7ff;
      --warn:#ffd27d;
      --danger:#ff7a9e;
      --line:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 800px at 15% 10%, rgba(122,167,255,.12), transparent 60%),
        radial-gradient(1000px 700px at 85% 20%, rgba(124,240,198,.10), transparent 55%),
        radial-gradient(900px 700px at 50% 85%, rgba(255,122,158,.08), transparent 60%),
        var(--bg);
      color:var(--text);
      line-height:1.55;
    }

    header{
      padding:36px 18px 10px;
    }
    .wrap{
      width:min(1120px, 92vw);
      margin:0 auto;
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr}
    }

    .hero{
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:22px 22px 18px;
      box-shadow:var(--shadow);
      overflow:hidden;
      position:relative;
      min-height:180px;
    }
    .hero:before{
      content:"";
      position:absolute; inset:-2px -2px auto -2px;
      height:6px;
      background:linear-gradient(90deg, var(--accent2), var(--accent), var(--danger));
      opacity:.9;
    }
    h1{
      margin:0 0 8px 0;
      font-size:clamp(22px, 3.1vw, 34px);
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      margin:0 0 14px 0;
      font-size:15.5px;
    }
    .pillrow{
      display:flex; flex-wrap:wrap; gap:10px;
      margin-top:10px;
    }
    .pill{
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      padding:6px 10px;
      border-radius:999px;
      color:var(--muted);
      font-size:12.5px;
    }

    aside{
      position:sticky;
      top:14px;
      align-self:start;
    }
    .toc{
      background:rgba(15,23,38,.72);
      backdrop-filter: blur(10px);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:16px 14px;
      overflow:hidden;
    }
    .toc h2{
      margin:0 0 10px 0;
      font-size:14px;
      text-transform:uppercase;
      letter-spacing:.14em;
      color:var(--faint);
    }
    .toc a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      color:var(--text);
      text-decoration:none;
      border:1px solid transparent;
      transition:transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:14px;
    }
    .toc a:hover{
      background:rgba(255,255,255,.04);
      border-color:rgba(255,255,255,.10);
      transform:translateY(-1px);
    }
    .toc .small{
      color:var(--muted);
      font-size:12.5px;
      margin-top:10px;
      padding:0 10px 6px;
    }

    main{
      padding:8px 18px 46px;
    }
    section{
      width:min(1120px, 92vw);
      margin:0 auto;
      background:rgba(16,26,46,.58);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:18px 18px 14px;
      margin-top:18px;
      overflow:hidden;
      position:relative;
    }

    section h2{
      margin:4px 0 10px;
      font-size:20px;
    }
    section h3{
      margin:14px 0 8px;
      font-size:16px;
      color:var(--accent2);
    }
    p{margin:8px 0}
    ul{margin:8px 0 10px 20px}
    li{margin:6px 0;color:var(--text)}
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 860px){
      .grid2{grid-template-columns:1fr}
    }

    .callout{
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.03);
      padding:12px 12px 10px;
      border-radius:16px;
      margin:10px 0;
      position:relative;
      overflow:hidden;
    }
    .callout:before{
      content:"";
      position:absolute;
      left:0; top:0; bottom:0;
      width:4px;
      background:linear-gradient(180deg, var(--accent2), var(--accent));
      opacity:.9;
    }
    .callout.warn:before{background:linear-gradient(180deg, var(--warn), #ffb86b)}
    .callout.danger:before{background:linear-gradient(180deg, var(--danger), #ff5c82)}
    .callout h4{
      margin:0 0 6px 0;
      font-size:13px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color:var(--faint);
    }

    .eqbox{
      border:1px solid rgba(124,240,198,.22);
      background:rgba(124,240,198,.06);
      padding:12px 12px 10px;
      border-radius:16px;
      margin:10px 0;
      overflow:auto;
      position:relative;
    }
    .eq{
      font-family:var(--mono);
      font-size:13.5px;
      white-space:pre;
      margin:0;
    }
    .copybtn{
      position:absolute;
      top:10px; right:10px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(0,0,0,.18);
      color:var(--text);
      padding:6px 10px;
      border-radius:999px;
      cursor:pointer;
      font-size:12px;
      transition:transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .copybtn:hover{
      transform:translateY(-1px);
      background:rgba(255,255,255,.06);
      border-color:rgba(255,255,255,.22);
    }
    .copyhint{
      font-size:12px;
      color:var(--muted);
      margin-top:6px;
    }

    figure{
      margin:0;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.02);
      border-radius:16px;
      overflow:hidden;
    }
    figcaption{
      padding:10px 12px;
      color:var(--muted);
      font-size:13px;
      border-top:1px solid rgba(255,255,255,.08);
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      background:rgba(8,12,20,.65);
    }
    .canvasTall{height:360px;}
    .controls{
      display:flex; flex-wrap:wrap;
      gap:10px 12px;
      align-items:center;
      margin:10px 0 6px;
      padding:10px 12px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.03);
    }
    .controls label{
      font-size:13px;
      color:var(--muted);
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    input[type="range"]{width:260px}
    select, button{
      border:1px solid rgba(255,255,255,.16);
      background:rgba(0,0,0,.20);
      color:var(--text);
      padding:8px 10px;
      border-radius:12px;
      font-size:13px;
    }
    button{cursor:pointer}
    button:hover{background:rgba(255,255,255,.06)}
    .kpirow{
      display:grid;
      grid-template-columns:repeat(4, 1fr);
      gap:12px;
      margin-top:10px;
    }
    @media (max-width: 980px){ .kpirow{grid-template-columns:repeat(2,1fr)} }
    @media (max-width: 520px){ .kpirow{grid-template-columns:1fr} }
    .kpi{
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.03);
      border-radius:16px;
      padding:10px 12px;
    }
    .kpi .name{color:var(--muted); font-size:12.5px}
    .kpi .val{font-family:var(--mono); font-size:14px; margin-top:4px}
    footer{
      width:min(1120px, 92vw);
      margin:18px auto 34px;
      color:var(--muted);
      font-size:12.5px;
      padding:14px 4px 0;
    }
    .printnote{
      display:none;
    }
    @media print{
      body{background:#fff; color:#000}
      section, .hero, .toc{box-shadow:none}
      aside{display:none}
      canvas{display:none}
      .printnote{display:block; padding:10px 0; color:#000}
      .copybtn{display:none}
    }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="hero">
      <h1>Dependence of Laser-Diode Output Photon Flux on Refractive Index</h1>
      <p class="subtitle">
        We identify which factors in the output photon flux <span style="font-family:var(--mono)">Φ₀</span> depend on the crystal refractive index
        and why those dependencies appear (facet reflectivity, mirror loss, cavity resonance, group velocity, and mode confinement).
      </p>
      <div class="pillrow">
        <span class="pill">Topic: semiconductor laser diodes</span>
        <span class="pill">Key idea: cavity + facet Fresnel reflection</span>
        <span class="pill">Result: which terms carry <span style="font-family:var(--mono)">n</span>-dependence</span>
      </div>
    </div>

    <aside>
      <nav class="toc" aria-label="Table of contents">
        <h2>Table of Contents</h2>
        <a href="#quick">Quick Summary</a>
        <a href="#p0">PART 0 — Concept Primer</a>
        <a href="#p1">PART 1 — Problem Analysis</a>
        <a href="#p2">PART 2 — Strategy & Tips</a>
        <a href="#p3">PART 3 — Full Solution</a>
        <a href="#p4">PART 4 — Deeper Understanding</a>
        <a href="#p5">PART 5 — Visualization Guide</a>
        <div class="small">Sticky TOC • click to jump</div>
      </nav>
    </aside>
  </div>
</header>

<main>
  <section id="quick">
    <h2>Quick Summary</h2>
    <ul>
      <li><b>What this problem is about:</b> in the laser-diode output photon flux formula <span style="font-family:var(--mono)">Φ₀</span> (Eq. 18.3-10), identify which factors depend on the refractive index <span style="font-family:var(--mono)">n</span>.</li>
      <li><b>Key physics idea:</b> the refractive index controls <i>how well the cavity traps light</i> (facet Fresnel reflectivity → mirror loss) and <i>how light propagates in the cavity</i> (group velocity, resonance condition).</li>
      <li><b>Most important governing relation:</b> for an edge-emitting diode laser,
        output is “carrier injection above threshold” times “fraction coupled out through mirrors”.</li>
      <li><b>Canonical (textbook) structure:</b>
        <span style="font-family:var(--mono)">Φ₀ ∝ (I − I_th) × [outcoupling factor]</span> and <span style="font-family:var(--mono)">P_out = (hν) Φ₀</span>.</li>
      <li><b>Main <span style="font-family:var(--mono)">n</span>-dependent terms:</b> facet reflectivity <span style="font-family:var(--mono)">R(n)</span>, mirror loss <span style="font-family:var(--mono)">α_m(n)</span>, photon lifetime <span style="font-family:var(--mono)">τ_p(n)</span> (via group velocity), optical frequency/energy <span style="font-family:var(--mono)">ν(n)</span> or <span style="font-family:var(--mono)">hν(n)</span> if resonance is used, and often confinement factor <span style="font-family:var(--mono)">Γ(n)</span>.</li>
      <li><b>Final result type:</b> symbolic identification list (not a numerical value) plus plots showing how <span style="font-family:var(--mono)">R</span>, <span style="font-family:var(--mono)">α_m</span>, and an example <span style="font-family:var(--mono)">Φ₀</span> vary with <span style="font-family:var(--mono)">n</span>.</li>
    </ul>

    <div class="callout warn">
      <h4>Note about Eq. (18.3-10)</h4>
      <p class="muted">
        Different textbooks write Eq. (18.3-10) with slightly different groupings (some use mirror loss <span style="font-family:var(--mono)">α_m</span>,
        some use photon lifetime <span style="font-family:var(--mono)">τ_p</span>, some include slope efficiency factors). The <b>same</b> physical
        dependencies on <span style="font-family:var(--mono)">n</span> show up regardless: they come from <b>facet Fresnel reflection</b>,
        <b>propagation speed</b>, and <b>mode confinement/resonance</b>.
      </p>
    </div>
  </section>

  <section id="p0">
    <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

    <div class="grid2">
      <div>
        <h3>Core definitions (symbols & units)</h3>
        <ul>
          <li><span style="font-family:var(--mono)">Φ₀</span> — output photon flux (photons/s) leaving one facet (or total, depending on convention).</li>
          <li><span style="font-family:var(--mono)">P_out</span> — output optical power (W). Relation: <span style="font-family:var(--mono)">P_out = (hν) Φ₀</span>.</li>
          <li><span style="font-family:var(--mono)">I</span> — injection current (A); <span style="font-family:var(--mono)">I_th</span> — threshold current (A).</li>
          <li><span style="font-family:var(--mono)">η_i</span> — internal quantum efficiency (dimensionless): fraction of injected carriers that contribute to stimulated photons.</li>
          <li><span style="font-family:var(--mono)">q</span> — electron charge (C).</li>
          <li><span style="font-family:var(--mono)">α_i</span> — internal optical loss (1/length, e.g. cm⁻¹): absorption/scattering inside cavity.</li>
          <li><span style="font-family:var(--mono)">α_m</span> — mirror loss (cm⁻¹): “loss” due to photons leaving through facets.</li>
          <li><span style="font-family:var(--mono)">R</span> — facet power reflectivity (dimensionless), often Fresnel-limited for uncoated facets.</li>
          <li><span style="font-family:var(--mono)">L</span> — cavity length (cm or m).</li>
          <li><span style="font-family:var(--mono)">v_g</span> — group velocity (m/s), often <span style="font-family:var(--mono)">v_g ≈ c/n_g</span>.</li>
          <li><span style="font-family:var(--mono)">τ_p</span> — photon lifetime (s), typical form: <span style="font-family:var(--mono)">τ_p = 1 / [v_g(α_i + α_m)]</span>.</li>
          <li><span style="font-family:var(--mono)">n</span> — refractive index of the laser medium/waveguide (dimensionless).</li>
          <li><span style="font-family:var(--mono)">Γ</span> — optical confinement factor (dimensionless): fraction of mode energy overlapping the gain region.</li>
        </ul>
      </div>

      <div>
        <h3>Physical meaning (what these represent)</h3>
        <ul>
          <li><b>Photon flux</b> is the count rate of photons emitted; power adds energy per photon <span style="font-family:var(--mono)">(hν)</span>.</li>
          <li><b>Mirror loss</b> is not absorption: it measures how quickly photons are removed because they exit the cavity (useful “loss” that produces output).</li>
          <li><b>Facet reflectivity</b> tells how much light is reflected back into the cavity; higher <span style="font-family:var(--mono)">R</span> → lower outcoupling, lower threshold, but also less output coupling per photon.</li>
          <li><b>Photon lifetime</b> says how long, on average, photons stay in the cavity before being lost (internally or through the mirrors).</li>
          <li><b>Refractive index</b> influences (i) how strongly facets reflect (Fresnel) and (ii) how fast the field propagates (group velocity) and (iii) how resonance pins wavelength.</li>
        </ul>

        <div class="callout">
          <h4>Key principle</h4>
          <p class="muted">
            Above threshold, the diode laser behaves like a <b>clamped-gain</b> system:
            carrier density stays near its threshold value, and extra injected carriers mostly convert into <b>stimulated photons</b>.
            Output is then governed by <b>outcoupling</b> and <b>loss partition</b>.
          </p>
        </div>
      </div>
    </div>

    <h3>Key laws/principles & validity</h3>
    <ul>
      <li><b>Steady-state rate equations</b> (carrier + photon): valid when averaged over times long compared to relaxation oscillations and when single-mode approximation is acceptable.</li>
      <li><b>Fabry–Pérot cavity optics</b>: valid for edge-emitting diodes with two partially reflecting facets and well-defined longitudinal modes.</li>
      <li><b>Fresnel reflection</b> at an interface: for normal incidence, uncoated facet from index <span style="font-family:var(--mono)">n</span> to air (~1) gives
        <span style="font-family:var(--mono)">R(n) = ((n − 1)/(n + 1))²</span>.</li>
      <li><b>Photon lifetime model</b>: <span style="font-family:var(--mono)">τ_p = 1/[v_g(α_i + α_m)]</span>, where <span style="font-family:var(--mono)">α_m</span> is computed from mirror reflectivities.</li>
    </ul>

    <h3>Common models/approximations (why we use them)</h3>
    <ul>
      <li><b>Equal-facet reflectivity</b> (<span style="font-family:var(--mono)">R1 = R2 = R</span>): simplifies mirror loss and output split; reasonable for cleaved, symmetric devices.</li>
      <li><b>Normal-incidence Fresnel</b>: a good first estimate; real waveguides have effective indices and angle/spatial-mode effects.</li>
      <li><b>Group index ≈ refractive index</b> (<span style="font-family:var(--mono)">n_g ≈ n</span>): acceptable for qualitative dependence; dispersion can be included via <span style="font-family:var(--mono)">n_g</span>.</li>
      <li><b>Single-mode or dominant-mode operation</b>: lets us talk about a single <span style="font-family:var(--mono)">ν</span>, <span style="font-family:var(--mono)">τ_p</span>, and outcoupling factor.</li>
    </ul>

    <h3>Mini intuition examples</h3>
    <ul>
      <li><b>If <span style="font-family:var(--mono)">n</span> increases</b>, facet Fresnel reflectivity <span style="font-family:var(--mono)">R</span> increases → mirror loss <span style="font-family:var(--mono)">α_m</span> decreases → cavity holds photons longer → often lower threshold, but smaller outcoupling fraction.</li>
      <li><b>If <span style="font-family:var(--mono)">n</span> decreases</b>, <span style="font-family:var(--mono)">R</span> decreases → mirror loss increases → more outcoupling per round trip, but higher threshold and shorter photon lifetime.</li>
    </ul>

    <div class="callout warn">
      <h4>What to watch for (pitfalls)</h4>
      <ul class="muted">
        <li>Confusing <b>mirror loss</b> with “bad” loss: mirror loss is the channel that produces output.</li>
        <li>Mixing up <span style="font-family:var(--mono)">n</span> (phase index) with <span style="font-family:var(--mono)">n_g</span> (group index) when using photon lifetime formulas.</li>
        <li>For power vs flux: <span style="font-family:var(--mono)">Φ₀</span> depends on outcoupling; <span style="font-family:var(--mono)">P_out</span> has extra factor <span style="font-family:var(--mono)">hν</span> that can also depend on <span style="font-family:var(--mono)">n</span> through resonance.</li>
        <li>Not distinguishing “explicit” <span style="font-family:var(--mono)">n</span>-dependence (e.g., <span style="font-family:var(--mono)">R(n)</span>) from “implicit” dependence through parameters like <span style="font-family:var(--mono)">I_th</span>, <span style="font-family:var(--mono)">Γ</span>, or <span style="font-family:var(--mono)">g</span>.</li>
      </ul>
    </div>
  </section>

  <section id="p1">
    <h2>PART 1 — Problem Analysis (no solving yet)</h2>

    <h3>Problem rewritten (plain language)</h3>
    <p>
      You are given an expression for the output photon flux <span style="font-family:var(--mono)">Φ₀</span> of a laser diode (Eq. 18.3-10).
      The task is to <b>identify which terms in that expression depend on the refractive index</b> <span style="font-family:var(--mono)">n</span>
      of the semiconductor (or waveguide) crystal.
    </p>

    <div class="grid2">
      <div>
        <h3>Given quantities (typical)</h3>
        <ul>
          <li>The formula for <span style="font-family:var(--mono)">Φ₀</span> (Eq. 18.3-10) in terms of diode/cavity parameters.</li>
          <li>Parameters such as <span style="font-family:var(--mono)">I</span>, <span style="font-family:var(--mono)">I_th</span>, <span style="font-family:var(--mono)">η</span>-factors, <span style="font-family:var(--mono)">α_i</span>, <span style="font-family:var(--mono)">α_m</span>, <span style="font-family:var(--mono)">τ_p</span>, <span style="font-family:var(--mono)">ν</span>, etc.</li>
        </ul>
      </div>
      <div>
        <h3>Unknowns / what to find</h3>
        <ul>
          <li>A list of which factors are functions of <span style="font-family:var(--mono)">n</span>.</li>
          <li>A short explanation of the physical origin of each dependence.</li>
        </ul>
      </div>
    </div>

    <h3>Relevant principles & why they apply</h3>
    <ul>
      <li><b>Facet Fresnel reflection</b>: any expression involving facet reflectivity <span style="font-family:var(--mono)">R</span> depends on <span style="font-family:var(--mono)">n</span> because <span style="font-family:var(--mono)">R</span> is set by index contrast.</li>
      <li><b>Mirror loss and photon lifetime</b>: if Eq. (18.3-10) uses <span style="font-family:var(--mono)">α_m</span> or <span style="font-family:var(--mono)">τ_p</span>, both depend on <span style="font-family:var(--mono)">R</span> and on propagation speed <span style="font-family:var(--mono)">v_g</span>.</li>
      <li><b>Cavity resonance / photon energy</b>: if the output is converted to power using <span style="font-family:var(--mono)">hν</span>, then <span style="font-family:var(--mono)">ν</span> (or wavelength) can depend on <span style="font-family:var(--mono)">n</span> through the Fabry–Pérot mode condition.</li>
      <li><b>Waveguide confinement</b>: if modal quantities appear (e.g., <span style="font-family:var(--mono)">Γ</span>, modal gain), they can depend on <span style="font-family:var(--mono)">n</span> via the effective index and field distribution.</li>
    </ul>

    <div class="callout">
      <h4>Assumptions (typical for Eq. 18.3-10)</h4>
      <ul class="muted">
        <li>Steady-state (time derivatives ≈ 0) and operation above threshold.</li>
        <li>Edge-emitting Fabry–Pérot cavity with two facets.</li>
        <li>Single dominant optical mode for defining <span style="font-family:var(--mono)">ν</span>, <span style="font-family:var(--mono)">τ_p</span>, and outcoupling.</li>
        <li>Facet reflectivity dominated by Fresnel reflection (unless coatings are specified).</li>
      </ul>
    </div>

    <h3>Possible approaches (compare)</h3>
    <ul>
      <li><b>Approach A: “Look for R, α<sub>m</sub>, τ<sub>p</sub>”</b> — Scan the formula for known optical-cavity terms and label which depend on <span style="font-family:var(--mono)">n</span>. <span class="muted">Fast and most direct for this question.</span></li>
      <li><b>Approach B: Re-derive Φ₀ from rate equations</b> — Derive <span style="font-family:var(--mono)">Φ₀</span> and explicitly substitute <span style="font-family:var(--mono)">R(n)</span>, <span style="font-family:var(--mono)">v_g(n)</span>. <span class="muted">More work, but clarifies “why” each term appears.</span></li>
      <li><b>Approach C: Dimensional/physical origin mapping</b> — Classify each parameter as electrical, optical-propagation, or boundary-condition controlled; only optical boundary/progapation tends to depend on <span style="font-family:var(--mono)">n</span>. <span class="muted">Good for intuition and cross-checking.</span></li>
    </ul>

    <p><b>Best approach:</b> Combine A + a compact version of B. We’ll state a standard textbook form for <span style="font-family:var(--mono)">Φ₀</span>,
      then mark all places where <span style="font-family:var(--mono)">n</span> enters explicitly or implicitly.</p>
  </section>

  <section id="p2">
    <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

    <ol>
      <li><b>Goal:</b> Write a canonical output-flux expression for an edge-emitting diode laser above threshold.
        <br><span class="muted">Tool:</span> steady-state photon/carrier rate equations.
        <br><span class="muted">Meaning:</span> output is injection above threshold converted to photons.</li>

      <li><b>Goal:</b> Identify the outcoupling (mirror) fraction.
        <br><span class="muted">Tool:</span> mirror loss concept and loss partition <span style="font-family:var(--mono)">α_m/(α_i+α_m)</span>.
        <br><span class="muted">Meaning:</span> what fraction of generated photons leaves through mirrors vs being absorbed.</li>

      <li><b>Goal:</b> Express mirror loss <span style="font-family:var(--mono)">α_m</span> in terms of facet reflectivities.
        <br><span class="muted">Tool:</span> Fabry–Pérot mirror loss formula.
        <br><span class="muted">Meaning:</span> boundary conditions (facets) set how leaky the cavity is.</li>

      <li><b>Goal:</b> Connect reflectivity to refractive index.
        <br><span class="muted">Tool:</span> Fresnel reflectivity <span style="font-family:var(--mono)">R(n)=((n−1)/(n+1))²</span> (uncoated, normal incidence).
        <br><span class="muted">Meaning:</span> index contrast controls feedback/outcoupling.</li>

      <li><b>Goal:</b> If the formula uses photon lifetime <span style="font-family:var(--mono)">τ_p</span>, rewrite it using <span style="font-family:var(--mono)">v_g</span> and losses.
        <br><span class="muted">Tool:</span> <span style="font-family:var(--mono)">τ_p = 1/[v_g(α_i+α_m)]</span>, <span style="font-family:var(--mono)">v_g≈c/n_g</span>.
        <br><span class="muted">Meaning:</span> higher index (often) slows group velocity → affects stored photons.</li>

      <li><b>Goal:</b> Mark additional “implicit” dependencies (e.g., <span style="font-family:var(--mono)">I_th</span>, <span style="font-family:var(--mono)">Γ</span>, modal gain).
        <br><span class="muted">Tool:</span> cavity threshold condition (gain = losses).
        <br><span class="muted">Meaning:</span> changing index changes mode confinement/effective index → changes threshold parameters.</li>
    </ol>

    <div class="callout warn">
      <h4>Common mistakes & quick tips</h4>
      <ul class="muted">
        <li><b>Tip:</b> If you see <span style="font-family:var(--mono)">ln(1/R)</span> anywhere, that term is <b>definitely</b> index-dependent (via Fresnel).</li>
        <li><b>Mistake:</b> Treating <span style="font-family:var(--mono)">α_m</span> as independent of <span style="font-family:var(--mono)">n</span> for cleaved facets.</li>
        <li><b>Tip:</b> If Eq. (18.3-10) is for <b>power</b> rather than flux, then <span style="font-family:var(--mono)">hν</span> matters too.</li>
      </ul>
    </div>
  </section>

  <section id="p3">
    <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

    <h3>Qualitative intuition first</h3>
    <p>
      Increasing refractive index typically increases the facet reflectivity, which increases feedback and reduces mirror loss.
      That tends to <b>increase photon storage</b> (longer photon lifetime) and can reduce threshold.
      However, it also tends to <b>reduce the outcoupling fraction</b>—fewer photons escape per unit time—so the effect on
      <span style="font-family:var(--mono)">Φ₀</span> depends on how the flux formula is written (and whether current above threshold is held fixed).
      The point of this exercise is not to optimize, but to identify <b>where</b> <span style="font-family:var(--mono)">n</span> enters.
    </p>

    <h3>Step 1 — A standard above-threshold photon-flux form</h3>
    <p>
      A widely used steady-state result for an edge-emitting diode laser is:
      injected carriers above threshold convert to stimulated photons at a rate approximately
      <span style="font-family:var(--mono)">η_i (I − I_th)/q</span> (photons/s generated into the lasing mode),
      multiplied by an <b>outcoupling / loss-partition factor</b>.
    </p>

    <div class="eqbox" id="eq1box">
      <button class="copybtn" data-copy-target="eq1">Copy</button>
      <pre class="eq" id="eq1">Canonical structure (one-facet output):
Φ₀ = (η_i / q) (I − I_th) · [ α_m,1 / (α_i + α_m) ]

where
α_m = α_m,1 + α_m,2   (mirror losses add),
α_m,1 corresponds to the output facet you are counting,
α_i is internal loss.</pre>
      <div class="copyhint">This captures the universal idea: “generated photons” × “fraction that exits through the chosen mirror.”</div>
    </div>

    <p class="muted">
      Some books write the same physics using photon lifetime <span style="font-family:var(--mono)">τ_p</span>,
      slope efficiency, or “outcoupling efficiency” <span style="font-family:var(--mono)">η_out</span>. These are equivalent rearrangements.
    </p>

    <h3>Step 2 — Mirror loss in terms of facet reflectivities</h3>
    <p>
      For a Fabry–Pérot cavity of length <span style="font-family:var(--mono)">L</span> with facet reflectivities <span style="font-family:var(--mono)">R1</span> and <span style="font-family:var(--mono)">R2</span>,
      the mirror loss per unit length is commonly written as:
    </p>

    <div class="eqbox" id="eq2box">
      <button class="copybtn" data-copy-target="eq2">Copy</button>
      <pre class="eq" id="eq2">Mirror loss (Fabry–Pérot):
α_m = (1 / (2L)) · ln[ 1 / (R1 R2) ].

If R1 = R2 = R, then:
α_m = (1 / L) · ln(1 / R).</pre>
    </div>

    <p>
      This is already a strong hint: if your Eq. (18.3-10) contains <span style="font-family:var(--mono)">α_m</span> or <span style="font-family:var(--mono)">ln(1/R)</span>,
      it depends on <span style="font-family:var(--mono)">n</span> because <span style="font-family:var(--mono)">R</span> depends on index contrast.
    </p>

    <h3>Step 3 — Fresnel reflectivity depends on refractive index</h3>
    <p>
      For an uncoated semiconductor facet to air (approx. index 1) at normal incidence, the Fresnel power reflectivity is:
    </p>

    <div class="eqbox" id="eq3box">
      <button class="copybtn" data-copy-target="eq3">Copy</button>
      <pre class="eq" id="eq3">Uncoated facet Fresnel reflectivity (normal incidence):
R(n) = ((n − 1) / (n + 1))².

(General form: R = |(n1 − n2)/(n1 + n2)|².)</pre>
    </div>

    <p>
      Therefore, <span style="font-family:var(--mono)">α_m</span> is an explicit function of <span style="font-family:var(--mono)">n</span>:
      <span style="font-family:var(--mono)">α_m(n) = (1/L) ln(1/R(n))</span> for symmetric facets.
    </p>

    <h3>Step 4 — If Eq. (18.3-10) uses photon lifetime τ<sub>p</sub></h3>
    <p>
      Many diode-laser formulas replace loss partitioning with photon lifetime. A common identity is:
    </p>

    <div class="eqbox" id="eq4box">
      <button class="copybtn" data-copy-target="eq4">Copy</button>
      <pre class="eq" id="eq4">Photon lifetime model:
τ_p = 1 / [ v_g (α_i + α_m) ].

With v_g ≈ c / n_g (often n_g ≈ n for qualitative dependence).</pre>
    </div>

    <p>
      Here, <span style="font-family:var(--mono)">n</span>-dependence can appear twice:
      <b>(i)</b> via <span style="font-family:var(--mono)">α_m(n)</span> and <b>(ii)</b> via <span style="font-family:var(--mono)">v_g(n)</span> (or <span style="font-family:var(--mono)">n_g</span>).
      So any term involving <span style="font-family:var(--mono)">τ_p</span> implicitly depends on <span style="font-family:var(--mono)">n</span>.
    </p>

    <h3>Step 5 — If Eq. (18.3-10) converts flux to power</h3>
    <p>
      If the book presents output power or includes <span style="font-family:var(--mono)">hν</span>, then <span style="font-family:var(--mono)">ν</span>
      (and the photon energy) can also depend on <span style="font-family:var(--mono)">n</span> through the cavity resonance condition:
    </p>

    <div class="eqbox" id="eq5box">
      <button class="copybtn" data-copy-target="eq5">Copy</button>
      <pre class="eq" id="eq5">Fabry–Pérot longitudinal resonance (vacuum wavelength λ0):
m (λ0/2) = n_eff L   ⇒   λ0 = 2 n_eff L / m,
ν = c / λ0.

Thus, if λ0 is set by cavity modes, ν can depend on n_eff (and hence on n).</pre>
    </div>

    <p class="muted">
      In practice, semiconductor lasers are also constrained by the gain peak (band structure), so <span style="font-family:var(--mono)">ν</span> is not purely a cavity function.
      But if the formula explicitly uses cavity-mode relations, <span style="font-family:var(--mono)">n</span> appears.
    </p>

    <h3>Step 6 — Implicit dependencies: threshold current and confinement</h3>
    <p>
      Even if Eq. (18.3-10) looks like <span style="font-family:var(--mono)">Φ₀ ∝ (I − I_th)</span>, the threshold current itself can depend on index through the threshold condition:
      modal gain equals total loss.
    </p>

    <div class="eqbox" id="eq6box">
      <button class="copybtn" data-copy-target="eq6">Copy</button>
      <pre class="eq" id="eq6">Threshold (modal) condition (one common form):
Γ · g_th = α_i + α_m,

so g_th depends on α_m(n), and Γ can depend on waveguiding (n profile).

Therefore I_th can have n-dependence (often implicit, device-structure dependent).</pre>
    </div>

    <h3>Final identification (what depends on refractive index?)</h3>
    <div class="callout">
      <h4>Final answer (terms in Φ₀ that depend on n)</h4>

      <div class="eqbox" id="finalbox">
        <button class="copybtn" data-copy-target="finaltext">Copy</button>
        <pre class="eq" id="finaltext">In a standard diode-laser output-flux expression Φ₀ (Eq. 18.3-10 style),
the refractive-index-dependent terms are:

1) Facet reflectivities R1, R2 (or any R):
   R(n) = ((n − n_out)/(n + n_out))²  (Fresnel; for air n_out≈1 → R(n)=((n−1)/(n+1))²).

2) Mirror loss α_m:
   α_m = (1/(2L)) ln[1/(R1 R2)]  → depends on n through R(n).

3) Any outcoupling / loss-partition factor that uses α_m:
   e.g., α_m/(α_i+α_m) or α_m,1/(α_i+α_m) → depends on n via α_m(n).

4) Photon lifetime τ_p (if it appears):
   τ_p = 1/[v_g(α_i+α_m)] → depends on n via α_m(n) and via v_g≈c/n_g.

5) Optical frequency ν or photon energy hν (if power is included, or if ν is written via cavity resonance):
   ν = c/λ0 with λ0=2 n_eff L/m → can depend on n_eff (and hence on n).

6) Modal/confinement quantities (if present in Eq. 18.3-10):
   Γ(n) and any 'modal gain' terms, hence possibly I_th(n) through Γ g_th = α_i + α_m.</pre>
      </div>
    </div>

    <h3>Sanity checks</h3>
    <ul>
      <li><b>Units:</b> <span style="font-family:var(--mono)">(η_i/q)(I − I_th)</span> has units of 1/s (since A/C = 1/s), so multiplying by a dimensionless outcoupling fraction gives photons/s.</li>
      <li><b>Limiting case:</b> if <span style="font-family:var(--mono)">R → 1</span> (perfect mirrors), then <span style="font-family:var(--mono)">α_m → 0</span> and output flux through mirrors vanishes—consistent.</li>
      <li><b>Limiting case:</b> if <span style="font-family:var(--mono)">R → 0</span>, mirror loss is huge: cavity can’t build up photons well, so threshold rises; outcoupling fraction can be large but there may be little lasing. This flags why device physics (implicit <span style="font-family:var(--mono)">I_th</span>) matters.</li>
    </ul>

    <p class="printnote">
      (Print view hides canvases for readability. Use the on-screen view for diagrams and plots.)
    </p>
  </section>

  <section id="p4">
    <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

    <h3>Re-interpreting the final formula</h3>
    <ul>
      <li><b><span style="font-family:var(--mono)">(I − I_th)</span> sets the “photon budget”</b>: how many extra carriers are available to make stimulated photons.</li>
      <li><b><span style="font-family:var(--mono)">α_m/(α_i+α_m)</span> is a partition</b>: what fraction of photons leave through mirrors (useful output) rather than being dissipated internally.</li>
      <li><b><span style="font-family:var(--mono)">α_m(n)</span> captures facet physics</b>: higher index contrast → higher <span style="font-family:var(--mono)">R</span> → smaller <span style="font-family:var(--mono)">α_m</span>.</li>
      <li><b><span style="font-family:var(--mono)">τ_p(n)</span> (if used) captures storage time</b>: slower group velocity and smaller losses increase photon lifetime.</li>
      <li><b><span style="font-family:var(--mono)">hν(n)</span> matters for power</b>: even with identical photon flux, changing photon energy changes output power.</li>
    </ul>

    <h3>How changing n affects outcomes (connect to plots)</h3>
    <ul>
      <li>Increasing <span style="font-family:var(--mono)">n</span> increases <span style="font-family:var(--mono)">R(n)</span> → decreases <span style="font-family:var(--mono)">α_m(n)</span>.</li>
      <li>In the simple “fixed <span style="font-family:var(--mono)">(I − I_th)</span>” picture, decreasing <span style="font-family:var(--mono)">α_m</span> reduces the outcoupling fraction <span style="font-family:var(--mono)">α_m/(α_i+α_m)</span>, so <span style="font-family:var(--mono)">Φ₀</span> tends to drop.</li>
      <li>But <span style="font-family:var(--mono)">I_th</span> may also decrease when <span style="font-family:var(--mono)">α_m</span> decreases (threshold condition), which can offset or reverse trends depending on what is held fixed experimentally (current, voltage, temperature, etc.).</li>
    </ul>

    <h3>Alternative derivation idea (brief)</h3>
    <p>
      Instead of rate equations, one can derive output coupling using <b>energy decay per round trip</b> in a Fabry–Pérot cavity:
      the fractional power loss per pass is set by facet transmission (<span style="font-family:var(--mono)">T=1−R</span>) and internal attenuation.
      Translating “power decay rate” into an equivalent distributed loss produces the same <span style="font-family:var(--mono)">α_m</span> and hence the same <span style="font-family:var(--mono)">n</span>-dependencies.
    </p>

    <div class="callout warn">
      <h4>Concept checks (quick self-test)</h4>
      <ul class="muted">
        <li><b>Q:</b> Why does mirror loss depend on refractive index for a cleaved facet? <b>A:</b> Because cleaved facets reflect by Fresnel reflection, and Fresnel reflectivity depends on index contrast.</li>
        <li><b>Q:</b> If <span style="font-family:var(--mono)">Φ₀</span> is photon flux, why might <span style="font-family:var(--mono)">hν</span> appear in the book’s equation? <b>A:</b> The book might present output power <span style="font-family:var(--mono)">P_out</span>, where <span style="font-family:var(--mono)">P_out=(hν)Φ₀</span>.</li>
        <li><b>Q:</b> Does <span style="font-family:var(--mono)">α_i</span> necessarily depend on <span style="font-family:var(--mono)">n</span>? <b>A:</b> Not directly in the simplest model; it’s usually treated as a material/waveguide loss parameter, though it can change with wavelength and mode profile (indirectly).</li>
        <li><b>Q:</b> Why can <span style="font-family:var(--mono)">I_th</span> depend on <span style="font-family:var(--mono)">n</span>? <b>A:</b> Threshold requires <span style="font-family:var(--mono)">Γ g_th = α_i + α_m</span>; since <span style="font-family:var(--mono)">α_m</span> and possibly <span style="font-family:var(--mono)">Γ</span> depend on index, the carrier density needed for threshold (and thus <span style="font-family:var(--mono)">I_th</span>) can change.</li>
      </ul>
    </div>
  </section>

  <section id="p5">
    <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

    <div class="controls">
      <label>
        Refractive index <span style="font-family:var(--mono)">n</span>:
        <input id="nSlider" type="range" min="2.5" max="4.2" step="0.01" value="3.40"/>
        <span id="nRead" style="font-family:var(--mono)">3.40</span>
      </label>

      <label>
        Facet environment:
        <select id="envSelect">
          <option value="1.0" selected>Air (n_out = 1.00)</option>
          <option value="1.5">Dielectric coating / polymer (n_out = 1.50)</option>
        </select>
      </label>

      <label>
        Display convention:
        <select id="fluxMode">
          <option value="one" selected>Φ₀ from one facet</option>
          <option value="total">Φ₀ total (both facets)</option>
        </select>
      </label>

      <button id="resetBtn" title="Reset to typical diode values">Reset example values</button>
    </div>

    <div class="kpirow" aria-label="live computed values">
      <div class="kpi"><div class="name">Facet reflectivity R</div><div class="val" id="kpiR">—</div></div>
      <div class="kpi"><div class="name">Mirror loss α<sub>m</sub> (cm⁻¹)</div><div class="val" id="kpiAm">—</div></div>
      <div class="kpi"><div class="name">Outcoupling frac α<sub>m</sub>/(α<sub>i</sub>+α<sub>m</sub>)</div><div class="val" id="kpiFrac">—</div></div>
      <div class="kpi"><div class="name">Example Φ₀ (photons/s)</div><div class="val" id="kpiPhi">—</div></div>
    </div>

    <div class="grid2" style="margin-top:12px">
      <figure>
        <canvas id="diag" class="canvasTall" aria-label="Labeled diode laser diagram"></canvas>
        <figcaption>
          <b>Diagram:</b> edge-emitting diode laser as a Fabry–Pérot cavity. The refractive index affects facet reflectivity and thus mirror loss/outcoupling.
        </figcaption>
      </figure>

      <figure>
        <canvas id="plot1" class="canvasTall" aria-label="Main plot: reflectivity and mirror loss vs refractive index"></canvas>
        <figcaption>
          <b>Main plot:</b> Fresnel reflectivity <span style="font-family:var(--mono)">R(n)</span> and mirror loss <span style="font-family:var(--mono)">α_m(n)</span> for example cavity length <span style="font-family:var(--mono)">L</span>.
        </figcaption>
      </figure>
    </div>

    <figure style="margin-top:14px">
      <canvas id="plot2" aria-label="Secondary plot: example photon flux vs refractive index"></canvas>
      <figcaption>
        <b>Secondary plot:</b> Example output photon flux <span style="font-family:var(--mono)">Φ₀(n)</span> using a standard partition model with fixed <span style="font-family:var(--mono)">(I−I_th)</span> (example values).
        This visualizes how <span style="font-family:var(--mono)">n</span>-dependence enters through <span style="font-family:var(--mono)">R</span> and <span style="font-family:var(--mono)">α_m</span>.
      </figcaption>
    </figure>

    <h3>How to read what you see</h3>
    <ul>
      <li><b>Diagram canvas:</b> shows cavity length <span style="font-family:var(--mono)">L</span>, gain region, and facets with reflectivity <span style="font-family:var(--mono)">R(n)</span>.</li>
      <li><b>Main plot:</b>
        <ul>
          <li>Left vertical scale: <span style="font-family:var(--mono)">R</span> (dimensionless).</li>
          <li>Right vertical scale: <span style="font-family:var(--mono)">α_m</span> in cm⁻¹ (computed from <span style="font-family:var(--mono)">R</span> and <span style="font-family:var(--mono)">L</span>).</li>
        </ul>
      </li>
      <li><b>Secondary plot:</b> plots an <i>example</i> <span style="font-family:var(--mono)">Φ₀(n)</span> using fixed electrical drive above threshold and fixed internal loss; only optical terms vary with <span style="font-family:var(--mono)">n</span>.</li>
      <li><b>Interactive controls:</b>
        <ul>
          <li><span style="font-family:var(--mono)">n</span> slider: changes <span style="font-family:var(--mono)">R(n)</span> → changes <span style="font-family:var(--mono)">α_m(n)</span> → updates both plots and the computed example flux.</li>
          <li>“Facet environment” select: changes external index <span style="font-family:var(--mono)">n_out</span>; coatings reduce index contrast and can reduce reflectivity.</li>
          <li>“Φ₀ convention” select: toggles whether output is per facet or total (both facets).</li>
        </ul>
      </li>
    </ul>

    <div class="callout danger">
      <h4>Important interpretation note</h4>
      <p class="muted">
        The plotted <span style="font-family:var(--mono)">Φ₀(n)</span> holds <span style="font-family:var(--mono)">(I−I_th)</span> fixed as an “example”.
        In reality, <span style="font-family:var(--mono)">I_th</span> may itself change with <span style="font-family:var(--mono)">n</span> through the threshold condition,
        which can alter the overall trend. The plots are for <b>visualizing the pathway of dependence</b>, not a universal optimization curve.
      </p>
    </div>
  </section>

  <footer>
    <p>
      Built as a self-contained learning note: diode-laser output flux depends on refractive index primarily through facet Fresnel reflectivity and
      its consequences (mirror loss, photon lifetime, outcoupling). If your Eq. (18.3-10) has any of the symbols
      <span style="font-family:var(--mono)">R</span>, <span style="font-family:var(--mono)">α_m</span>, <span style="font-family:var(--mono)">τ_p</span>, <span style="font-family:var(--mono)">v_g</span>, <span style="font-family:var(--mono)">ν</span>, or <span style="font-family:var(--mono)">Γ</span>,
      those are the <span style="font-family:var(--mono)">n</span>-dependent suspects.
    </p>
  </footer>
</main>

<script>
/* ----------------------------
   Smooth TOC scrolling
----------------------------- */
(function(){
  document.querySelectorAll('.toc a').forEach(a=>{
    a.addEventListener('click', (e)=>{
      const href = a.getAttribute('href');
      if(!href || !href.startsWith('#')) return;
      const el = document.querySelector(href);
      if(!el) return;
      e.preventDefault();
      el.scrollIntoView({behavior:'smooth', block:'start'});
      history.replaceState(null, '', href);
    });
  });
})();

/* ----------------------------
   Copy buttons
----------------------------- */
(function(){
  function copyText(text){
    if(navigator.clipboard && window.isSecureContext){
      return navigator.clipboard.writeText(text);
    }else{
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.style.position='fixed';
      ta.style.left='-9999px';
      ta.style.top='-9999px';
      document.body.appendChild(ta);
      ta.focus(); ta.select();
      try{ document.execCommand('copy'); }catch(err){}
      document.body.removeChild(ta);
      return Promise.resolve();
    }
  }
  document.querySelectorAll('.copybtn').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const id = btn.getAttribute('data-copy-target');
      const node = document.getElementById(id);
      if(!node) return;
      const text = node.innerText.replace(/\u00A0/g,' ');
      const old = btn.textContent;
      btn.textContent = 'Copied!';
      btn.style.borderColor = 'rgba(124,240,198,.35)';
      btn.style.background = 'rgba(124,240,198,.10)';
      try{ await copyText(text); }catch(e){}
      setTimeout(()=>{
        btn.textContent = old;
        btn.style.borderColor = 'rgba(255,255,255,.16)';
        btn.style.background = 'rgba(0,0,0,.18)';
      }, 900);
    });
  });
})();

/* ----------------------------
   Math helpers for visuals
----------------------------- */
const CONST = {
  c: 299792458,     // m/s
  q: 1.602176634e-19
};

// Example device values for plotting (clearly "example values")
let EX = {
  L_um: 300,     // cavity length in micrometers
  alpha_i_cm: 10, // internal loss in cm^-1
  eta_i: 0.80,
  I_minus_Ith_mA: 20
};

function R_fresnel(n, nOut){
  // power reflectivity at normal incidence
  const r = (n - nOut) / (n + nOut);
  return r*r;
}

function alpha_m_cm(n, nOut){
  // symmetric facets: alpha_m = (1/L) ln(1/R), with L in cm
  const R = Math.max(1e-9, Math.min(0.999999999, R_fresnel(n, nOut)));
  const L_cm = (EX.L_um * 1e-4); // 1 um = 1e-4 cm
  return (1 / L_cm) * Math.log(1 / R);
}

function outcouplingFraction(n, nOut){
  const am = alpha_m_cm(n, nOut);
  return am / (EX.alpha_i_cm + am);
}

function phi_example(n, nOut, mode){
  // Example photon flux from partition model.
  // Generation rate (photons/s) ≈ eta_i/q * (I - Ith)
  const I = EX.I_minus_Ith_mA * 1e-3; // A
  const gen = (EX.eta_i / CONST.q) * I; // photons/s
  const frac = outcouplingFraction(n, nOut);
  // For symmetric facets, one facet gets half of mirror output.
  return (mode === 'total') ? gen * frac : gen * frac * 0.5;
}

/* ----------------------------
   Canvas utilities
----------------------------- */
function setupCanvas(canvas){
  const ctx = canvas.getContext('2d');
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  }
  resize();
  return {ctx, resize};
}

function clear(ctx, w, h){
  ctx.clearRect(0,0,w,h);
}

/* Drawing primitives */
function roundRect(ctx, x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

function drawGridAxes(ctx, plot){
  const {x,y,w,h, title, xLabel, yLabelL, yLabelR, xTicks, yTicksL, yTicksR} = plot;

  // Background
  ctx.save();
  ctx.fillStyle = 'rgba(8,12,20,.75)';
  roundRect(ctx, x,y,w,h, 14);
  ctx.fill();
  ctx.restore();

  // Title
  ctx.save();
  ctx.fillStyle = 'rgba(231,238,252,.95)';
  ctx.font = '600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(title, x+12, y+20);
  ctx.restore();

  // Plot area
  const padL = 54, padR = (yLabelR ? 54 : 18), padT = 34, padB = 44;
  const px = x + padL, py = y + padT, pw = w - padL - padR, ph = h - padT - padB;

  // Grid
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,.07)';
  ctx.lineWidth = 1;

  // Vertical grid lines from xTicks
  for(const t of xTicks){
    const gx = px + t.pos * pw;
    ctx.beginPath(); ctx.moveTo(gx, py); ctx.lineTo(gx, py+ph); ctx.stroke();
  }
  // Horizontal grid lines from yTicksL (use left ticks as reference)
  for(const t of yTicksL){
    const gy = py + (1 - t.pos) * ph;
    ctx.beginPath(); ctx.moveTo(px, gy); ctx.lineTo(px+pw, gy); ctx.stroke();
  }
  ctx.restore();

  // Axes
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,.22)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(px, py); ctx.lineTo(px, py+ph); // left axis
  ctx.lineTo(px+pw, py+ph); // bottom axis
  ctx.stroke();
  if(yLabelR){
    ctx.beginPath();
    ctx.moveTo(px+pw, py); ctx.lineTo(px+pw, py+ph); // right axis
    ctx.stroke();
  }
  ctx.restore();

  // Tick labels
  ctx.save();
  ctx.fillStyle = 'rgba(169,184,218,.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

  // x ticks
  for(const t of xTicks){
    const gx = px + t.pos * pw;
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,255,.22)';
    ctx.moveTo(gx, py+ph); ctx.lineTo(gx, py+ph+5);
    ctx.stroke();
    const s = t.label;
    const tw = ctx.measureText(s).width;
    ctx.fillText(s, gx - tw/2, py+ph+18);
  }
  // y ticks left
  for(const t of yTicksL){
    const gy = py + (1 - t.pos) * ph;
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,255,.22)';
    ctx.moveTo(px-5, gy); ctx.lineTo(px, gy);
    ctx.stroke();
    const s = t.label;
    const tw = ctx.measureText(s).width;
    ctx.fillText(s, px-10 - tw, gy+4);
  }
  // y ticks right
  if(yLabelR && yTicksR){
    for(const t of yTicksR){
      const gy = py + (1 - t.pos) * ph;
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,255,255,.22)';
      ctx.moveTo(px+pw, gy); ctx.lineTo(px+pw+5, gy);
      ctx.stroke();
      ctx.fillText(t.label, px+pw+10, gy+4);
    }
  }
  ctx.restore();

  // Axis labels
  ctx.save();
  ctx.fillStyle = 'rgba(231,238,252,.92)';
  ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  // x label
  const xw = ctx.measureText(xLabel).width;
  ctx.fillText(xLabel, px + pw/2 - xw/2, y + h - 12);
  // y left label (rotated)
  ctx.translate(x+16, py + ph/2);
  ctx.rotate(-Math.PI/2);
  const ylW = ctx.measureText(yLabelL).width;
  ctx.fillText(yLabelL, -ylW/2, 0);
  ctx.setTransform(1,0,0,1,0,0);
  // y right label
  if(yLabelR){
    ctx.translate(x+w-16, py + ph/2);
    ctx.rotate(Math.PI/2);
    const yrW = ctx.measureText(yLabelR).width;
    ctx.fillText(yLabelR, -yrW/2, 0);
    ctx.setTransform(1,0,0,1,0,0);
  }
  ctx.restore();

  return {px, py, pw, ph};
}

function niceTicks(min, max, count){
  // simple nice ticks
  const span = max - min;
  if(span <= 0) return [];
  const rawStep = span / (count-1);
  const pow = Math.pow(10, Math.floor(Math.log10(rawStep)));
  const candidates = [1,2,5,10].map(m => m*pow);
  let step = candidates[0];
  for(const s of candidates){
    if(Math.abs(rawStep - s) < Math.abs(rawStep - step)) step = s;
  }
  const start = Math.ceil(min/step)*step;
  const ticks = [];
  for(let v=start; v<=max+1e-12; v+=step){
    ticks.push(v);
  }
  return ticks;
}

function mapX(xVal, xMin, xMax, px, pw){
  return px + (xVal - xMin) / (xMax - xMin) * pw;
}
function mapY(yVal, yMin, yMax, py, ph){
  return py + (1 - (yVal - yMin) / (yMax - yMin)) * ph;
}

/* ----------------------------
   Drawing: Diagram
----------------------------- */
function drawDiagram(ctx, canvas, state){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  clear(ctx, w, h);

  // Background
  ctx.save();
  ctx.fillStyle = 'rgba(8,12,20,.75)';
  roundRect(ctx, 10, 10, w-20, h-20, 16);
  ctx.fill();
  ctx.restore();

  // Title
  ctx.save();
  ctx.fillStyle = 'rgba(231,238,252,.95)';
  ctx.font = '600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('Edge-Emitting Laser Diode (Fabry–Pérot Cavity)', 22, 32);
  ctx.restore();

  // Cavity block
  const x0 = 50, y0 = 80, cw = w - 100, ch = 120;
  ctx.save();
  ctx.fillStyle = 'rgba(122,167,255,.10)';
  ctx.strokeStyle = 'rgba(255,255,255,.18)';
  ctx.lineWidth = 1;
  roundRect(ctx, x0, y0, cw, ch, 18);
  ctx.fill();
  ctx.stroke();
  ctx.restore();

  // Active (gain) region
  ctx.save();
  ctx.fillStyle = 'rgba(124,240,198,.10)';
  ctx.strokeStyle = 'rgba(124,240,198,.22)';
  roundRect(ctx, x0 + cw*0.18, y0 + ch*0.35, cw*0.64, ch*0.30, 14);
  ctx.fill();
  ctx.stroke();
  ctx.restore();

  // Facets
  const facetW = 8;
  ctx.save();
  ctx.fillStyle = 'rgba(255,255,255,.18)';
  ctx.fillRect(x0 - facetW/2, y0, facetW, ch);
  ctx.fillRect(x0 + cw - facetW/2, y0, facetW, ch);
  ctx.restore();

  // Arrows for output
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,.30)';
  ctx.lineWidth = 2;
  // left
  ctx.beginPath();
  ctx.moveTo(x0-18, y0+ch/2);
  ctx.lineTo(x0-48, y0+ch/2);
  ctx.stroke();
  // arrowhead
  ctx.beginPath();
  ctx.moveTo(x0-48, y0+ch/2);
  ctx.lineTo(x0-38, y0+ch/2-6);
  ctx.lineTo(x0-38, y0+ch/2+6);
  ctx.closePath();
  ctx.fillStyle = 'rgba(255,255,255,.30)';
  ctx.fill();

  // right
  ctx.beginPath();
  ctx.moveTo(x0+cw+18, y0+ch/2);
  ctx.lineTo(x0+cw+48, y0+ch/2);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x0+cw+48, y0+ch/2);
  ctx.lineTo(x0+cw+38, y0+ch/2-6);
  ctx.lineTo(x0+cw+38, y0+ch/2+6);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // Labels
  ctx.save();
  ctx.fillStyle = 'rgba(169,184,218,.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillText(`n = ${state.n.toFixed(2)}`, x0 + 12, y0 - 14);
  ctx.fillText(`R(n) = ${state.R.toFixed(3)}`, x0 + cw - 160, y0 - 14);
  ctx.fillText(`L = ${EX.L_um.toFixed(0)} µm`, x0 + cw/2 - 56, y0 + ch + 26);

  ctx.fillText('Facet 1', x0 - 24, y0 + ch + 20);
  ctx.fillText('Facet 2', x0 + cw - 56, y0 + ch + 20);
  ctx.fillText('Gain / active region', x0 + cw*0.30, y0 + ch*0.55 + 36);

  // Show Φ0 label on chosen convention
  const fluxText = (state.mode === 'total') ? 'Φ₀ (total)' : 'Φ₀ (one facet)';
  ctx.fillStyle = 'rgba(231,238,252,.92)';
  ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(fluxText, x0 + cw*0.02, y0 + ch*0.92 + 60);
  ctx.restore();

  // Small callout: outcoupling fraction
  ctx.save();
  const bx = 50, by = y0 + ch + 44, bw = Math.min(520, w-100), bh = 70;
  ctx.fillStyle = 'rgba(255,255,255,.03)';
  ctx.strokeStyle = 'rgba(255,255,255,.12)';
  roundRect(ctx, bx, by, bw, bh, 16);
  ctx.fill();
  ctx.stroke();
  ctx.fillStyle = 'rgba(169,184,218,.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillText(`αm = ${state.alpha_m.toFixed(2)} cm⁻¹`, bx+12, by+26);
  ctx.fillText(`αi = ${EX.alpha_i_cm.toFixed(2)} cm⁻¹`, bx+12, by+46);
  ctx.fillText(`αm/(αi+αm) = ${state.frac.toFixed(3)}`, bx+220, by+26);
  ctx.fillText(`Φ₀ (example) = ${formatSci(state.phi)} ph/s`, bx+220, by+46);
  ctx.restore();
}

function formatSci(x){
  if(!isFinite(x)) return '—';
  const ax = Math.abs(x);
  if(ax === 0) return '0';
  if(ax < 1e-3 || ax >= 1e6){
    const e = Math.floor(Math.log10(ax));
    const m = x / Math.pow(10, e);
    return `${m.toFixed(3)}e${e}`;
  }
  return x.toFixed(3);
}

/* ----------------------------
   Drawing: Plots
----------------------------- */
function drawMainPlot(ctx, canvas, state){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  clear(ctx, w, h);

  const xMin = 2.5, xMax = 4.2;
  // Build data
  const nOut = state.nOut;
  const N = 240;
  const xs = [];
  const Rs = [];
  const ams = [];
  let amMin = Infinity, amMax = -Infinity;
  for(let i=0;i<=N;i++){
    const n = xMin + (xMax-xMin)*i/N;
    const R = R_fresnel(n, nOut);
    const am = alpha_m_cm(n, nOut);
    xs.push(n); Rs.push(R); ams.push(am);
    amMin = Math.min(amMin, am);
    amMax = Math.max(amMax, am);
  }
  // y ranges
  const yRMin = 0, yRMax = Math.max(0.45, Math.max(...Rs)*1.05);
  const yAMin = Math.max(0, amMin*0.9);
  const yAMax = amMax*1.05;

  // ticks
  const xTicksV = [2.5, 3.0, 3.5, 4.0, 4.2];
  const xTicks = xTicksV.map(v => ({pos:(v-xMin)/(xMax-xMin), label:v.toFixed(v===4.2?1:1)}));
  const yTicksLvals = niceTicks(yRMin, yRMax, 5);
  const yTicksL = yTicksLvals.map(v => ({pos:(v-yRMin)/(yRMax-yRMin), label:v.toFixed(2)}));
  const yTicksRvals = niceTicks(yAMin, yAMax, 5);
  const yTicksR = yTicksRvals.map(v => ({pos:(v-yAMin)/(yAMax-yAMin), label:v.toFixed(0)}));

  const plot = {
    x: 10, y: 10, w: w-20, h: h-20,
    title: 'R(n) and mirror loss αm(n) (example L)',
    xLabel: 'Refractive index n (dimensionless)',
    yLabelL: 'Reflectivity R (—)',
    yLabelR: 'Mirror loss αm (cm⁻¹)',
    xTicks, yTicksL, yTicksR
  };
  const P = drawGridAxes(ctx, plot);

  // lines
  ctx.save();
  // R line
  ctx.strokeStyle = 'rgba(122,167,255,.95)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const X = mapX(xs[i], xMin, xMax, P.px, P.pw);
    const Y = mapY(Rs[i], yRMin, yRMax, P.py, P.ph);
    if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
  }
  ctx.stroke();

  // alpha_m line (right axis scaling)
  ctx.strokeStyle = 'rgba(124,240,198,.92)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const X = mapX(xs[i], xMin, xMax, P.px, P.pw);
    const Y = mapY(ams[i], yAMin, yAMax, P.py, P.ph);
    if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
  }
  ctx.stroke();
  ctx.restore();

  // marker at current n
  ctx.save();
  const mx = mapX(state.n, xMin, xMax, P.px, P.pw);
  ctx.strokeStyle = 'rgba(255,255,255,.25)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(mx, P.py); ctx.lineTo(mx, P.py+P.ph); ctx.stroke();

  // dots
  const yR = mapY(state.R, yRMin, yRMax, P.py, P.ph);
  const yA = mapY(state.alpha_m, yAMin, yAMax, P.py, P.ph);

  ctx.fillStyle = 'rgba(122,167,255,.95)';
  ctx.beginPath(); ctx.arc(mx, yR, 4, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = 'rgba(124,240,198,.92)';
  ctx.beginPath(); ctx.arc(mx, yA, 4, 0, Math.PI*2); ctx.fill();
  ctx.restore();

  // Legend
  ctx.save();
  const lx = P.px + 10, ly = P.py + 8;
  ctx.fillStyle = 'rgba(255,255,255,.03)';
  ctx.strokeStyle = 'rgba(255,255,255,.12)';
  roundRect(ctx, lx, ly, 190, 56, 12);
  ctx.fill(); ctx.stroke();
  ctx.lineWidth = 3;
  ctx.strokeStyle = 'rgba(122,167,255,.95)';
  ctx.beginPath(); ctx.moveTo(lx+12, ly+20); ctx.lineTo(lx+42, ly+20); ctx.stroke();
  ctx.strokeStyle = 'rgba(124,240,198,.92)';
  ctx.beginPath(); ctx.moveTo(lx+12, ly+40); ctx.lineTo(lx+42, ly+40); ctx.stroke();
  ctx.fillStyle = 'rgba(231,238,252,.92)';
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('R(n) (left axis)', lx+52, ly+24);
  ctx.fillText('αm(n) (right axis)', lx+52, ly+44);
  ctx.restore();
}

function drawSecondaryPlot(ctx, canvas, state){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  clear(ctx, w, h);

  const xMin = 2.5, xMax = 4.2;
  const nOut = state.nOut;
  const mode = state.mode;

  const N = 260;
  const xs = [];
  const phis = [];
  let yMin = Infinity, yMax = -Infinity;
  for(let i=0;i<=N;i++){
    const n = xMin + (xMax-xMin)*i/N;
    const phi = phi_example(n, nOut, mode);
    xs.push(n); phis.push(phi);
    yMin = Math.min(yMin, phi);
    yMax = Math.max(yMax, phi);
  }
  // give margins
  yMin = Math.max(0, yMin*0.92);
  yMax = yMax*1.05;

  // ticks
  const xTicksV = [2.5, 3.0, 3.5, 4.0, 4.2];
  const xTicks = xTicksV.map(v => ({pos:(v-xMin)/(xMax-xMin), label:v.toFixed(v===4.2?1:1)}));

  // y ticks in scientific-ish labels
  const yTicksVals = niceTicks(yMin, yMax, 5);
  const yTicksL = yTicksVals.map(v => ({pos:(v-yMin)/(yMax-yMin), label:formatSci(v)}));

  const plot = {
    x: 10, y: 10, w: w-20, h: h-20,
    title: 'Example Φ₀(n) via outcoupling fraction (fixed I−Ith; example values)',
    xLabel: 'Refractive index n (dimensionless)',
    yLabelL: 'Photon flux Φ₀ (photons/s)',
    yLabelR: '',
    xTicks, yTicksL, yTicksR: null
  };
  const P = drawGridAxes(ctx, plot);

  // curve
  ctx.save();
  ctx.strokeStyle = 'rgba(255,210,125,.92)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const X = mapX(xs[i], xMin, xMax, P.px, P.pw);
    const Y = mapY(phis[i], yMin, yMax, P.py, P.ph);
    if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
  }
  ctx.stroke();
  ctx.restore();

  // marker at current n
  ctx.save();
  const mx = mapX(state.n, xMin, xMax, P.px, P.pw);
  const my = mapY(state.phi, yMin, yMax, P.py, P.ph);
  ctx.strokeStyle = 'rgba(255,255,255,.25)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(mx, P.py); ctx.lineTo(mx, P.py+P.ph); ctx.stroke();
  ctx.fillStyle = 'rgba(255,210,125,.95)';
  ctx.beginPath(); ctx.arc(mx, my, 4.5, 0, Math.PI*2); ctx.fill();

  // annotation bubble
  const label = `Φ₀ = ${formatSci(state.phi)} ph/s`;
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  const tw = ctx.measureText(label).width;
  const bx = Math.min(P.px+P.pw-12-tw-14, mx+10);
  const by = Math.max(P.py+10, my-26);
  ctx.fillStyle = 'rgba(0,0,0,.30)';
  ctx.strokeStyle = 'rgba(255,255,255,.14)';
  roundRect(ctx, bx, by, tw+14, 22, 10);
  ctx.fill(); ctx.stroke();
  ctx.fillStyle = 'rgba(231,238,252,.92)';
  ctx.fillText(label, bx+7, by+15);
  ctx.restore();

  // legend / assumptions
  ctx.save();
  const txt = `Example: ηi=${EX.eta_i.toFixed(2)}, (I−Ith)=${EX.I_minus_Ith_mA.toFixed(0)} mA, αi=${EX.alpha_i_cm.toFixed(0)} cm⁻¹, L=${EX.L_um.toFixed(0)} µm`;
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  const ttw = ctx.measureText(txt).width;
  const lx = P.px + 10, ly = P.py + P.ph - 30;
  ctx.fillStyle = 'rgba(255,255,255,.03)';
  ctx.strokeStyle = 'rgba(255,255,255,.12)';
  roundRect(ctx, lx, ly, Math.min(P.pw-20, ttw+18), 22, 10);
  ctx.fill(); ctx.stroke();
  ctx.fillStyle = 'rgba(169,184,218,.95)';
  ctx.fillText(txt, lx+9, ly+15);
  ctx.restore();
}

/* ----------------------------
   Wiring + render loop
----------------------------- */
const diag = document.getElementById('diag');
const plot1 = document.getElementById('plot1');
const plot2 = document.getElementById('plot2');

const diagC = setupCanvas(diag);
const p1C = setupCanvas(plot1);
const p2C = setupCanvas(plot2);

const nSlider = document.getElementById('nSlider');
const nRead = document.getElementById('nRead');
const envSelect = document.getElementById('envSelect');
const fluxMode = document.getElementById('fluxMode');
const resetBtn = document.getElementById('resetBtn');

const kpiR = document.getElementById('kpiR');
const kpiAm = document.getElementById('kpiAm');
const kpiFrac = document.getElementById('kpiFrac');
const kpiPhi = document.getElementById('kpiPhi');

function getState(){
  const n = parseFloat(nSlider.value);
  const nOut = parseFloat(envSelect.value);
  const mode = fluxMode.value;
  const R = R_fresnel(n, nOut);
  const am = alpha_m_cm(n, nOut);
  const frac = outcouplingFraction(n, nOut);
  const phi = phi_example(n, nOut, mode);
  return {n, nOut, mode, R, alpha_m: am, frac, phi};
}

function updateKPIs(state){
  nRead.textContent = state.n.toFixed(2);
  kpiR.textContent = state.R.toFixed(4);
  kpiAm.textContent = state.alpha_m.toFixed(2);
  kpiFrac.textContent = state.frac.toFixed(4);
  kpiPhi.textContent = `${formatSci(state.phi)}`;
}

function render(){
  const state = getState();
  updateKPIs(state);
  drawDiagram(diagC.ctx, diag, state);
  drawMainPlot(p1C.ctx, plot1, state);
  drawSecondaryPlot(p2C.ctx, plot2, state);
}

function resizeAll(){
  diagC.resize(); p1C.resize(); p2C.resize();
  render();
}

nSlider.addEventListener('input', render);
envSelect.addEventListener('change', render);
fluxMode.addEventListener('change', render);

resetBtn.addEventListener('click', ()=>{
  // Reset to typical diode values and n
  EX = { L_um: 300, alpha_i_cm: 10, eta_i: 0.80, I_minus_Ith_mA: 20 };
  nSlider.value = '3.40';
  envSelect.value = '1.0';
  fluxMode.value = 'one';
  render();
});

window.addEventListener('resize', ()=>{
  // Debounced-ish
  clearTimeout(window.__rz);
  window.__rz = setTimeout(resizeAll, 80);
});

// Initial render
render();
</script>
</body>
</html>
