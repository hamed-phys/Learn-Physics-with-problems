<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Minimum Gain Required for Lasing — Reflection-Loss Limited Fabry–Pérot Laser</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#101826;
      --panel2:#0f1622;
      --text:#e7eefc;
      --muted:#b9c6e4;
      --faint:#7f8fb3;
      --brand:#66e3ff;
      --brand2:#a78bfa;
      --ok:#4ade80;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,0.10);
      --line2:rgba(255,255,255,0.14);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --maxw: 1150px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background: radial-gradient(1200px 800px at 15% 10%, rgba(102,227,255,0.12), transparent 55%),
                  radial-gradient(900px 700px at 90% 30%, rgba(167,139,250,0.10), transparent 60%),
                  linear-gradient(180deg, #070a0f, var(--bg));
      color:var(--text);
      font-family:var(--sans);
      line-height:1.55;
    }
    header{
      padding: 44px 18px 24px;
    }
    .wrap{max-width:var(--maxw); margin:0 auto;}
    .hero{
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border:1px solid var(--line);
      border-radius: calc(var(--radius) + 6px);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .heroTop{
      padding: 22px 22px 10px;
      display:flex;
      gap:18px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-weight:800;
      letter-spacing:-0.02em;
      font-size: clamp(1.45rem, 2.3vw, 2.25rem);
    }
    .sub{
      color:var(--muted);
      margin-top:8px;
      max-width: 70ch;
      font-size: 1.02rem;
    }
    .metaRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
      margin-left:auto;
    }
    .pill{
      border:1px solid var(--line2);
      background: rgba(255,255,255,0.03);
      padding: 7px 10px;
      border-radius: 999px;
      font-size: 0.86rem;
      color: var(--muted);
      backdrop-filter: blur(6px);
    }
    .pill b{color:var(--text)}
    main{
      padding: 18px 18px 60px;
    }
    .grid{
      display:grid;
      grid-template-columns: 290px 1fr;
      gap: 18px;
      align-items:start;
    }
    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding: 14px 12px;
      box-shadow: var(--shadow);
    }
    .tocTitle{
      font-weight: 800;
      letter-spacing: 0.01em;
      color: var(--text);
      margin: 4px 8px 10px;
      font-size: 0.92rem;
      text-transform: uppercase;
      opacity:0.9;
    }
    .toc a{
      display:block;
      padding: 8px 10px;
      border-radius: 12px;
      color: var(--muted);
      text-decoration:none;
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size: 0.94rem;
    }
    .toc a:hover{
      background: rgba(102,227,255,0.08);
      border-color: rgba(102,227,255,0.20);
      transform: translateY(-1px);
      color: var(--text);
    }
    .toc a.small{font-size:0.90rem; color:var(--faint)}
    .content{
      min-width: 0;
    }
    section{
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding: 18px 18px;
      box-shadow: var(--shadow);
      margin-bottom: 14px;
      overflow:hidden;
    }
    section h2{
      margin: 0 0 10px;
      font-size: 1.25rem;
      letter-spacing: -0.01em;
    }
    section h3{
      margin: 14px 0 8px;
      font-size: 1.05rem;
      color: var(--text);
      letter-spacing: -0.01em;
    }
    p{margin: 10px 0; color: var(--muted)}
    ul{margin: 8px 0 10px 20px; color: var(--muted)}
    li{margin: 6px 0}
    .cards{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
      margin-top: 10px;
    }
    .card{
      grid-column: span 6;
      background: rgba(0,0,0,0.18);
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 12px 12px;
      overflow:hidden;
    }
    .card.full{grid-column: 1 / -1;}
    .card h4{margin: 0 0 6px; font-size: 0.98rem;}
    .note{
      border-left: 4px solid rgba(102,227,255,0.65);
      padding: 10px 12px;
      background: rgba(102,227,255,0.06);
      border-radius: 14px;
      color: var(--muted);
      margin: 12px 0;
    }
    .warn{
      border-left: 4px solid rgba(251,191,36,0.75);
      background: rgba(251,191,36,0.07);
    }
    .assump{
      border-left: 4px solid rgba(167,139,250,0.75);
      background: rgba(167,139,250,0.07);
    }
    .final{
      border-left: 4px solid rgba(74,222,128,0.75);
      background: rgba(74,222,128,0.07);
    }
    .eq{
      background: rgba(0,0,0,0.30);
      border:1px solid var(--line);
      border-radius: 14px;
      padding: 12px 12px;
      margin: 12px 0;
      position: relative;
      overflow:hidden;
    }
    .eq pre{
      margin:0;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: var(--mono);
      font-size: 0.95rem;
      color: #eef5ff;
      line-height:1.45;
    }
    .copyBtn{
      position:absolute;
      top:10px;
      right:10px;
      border:1px solid var(--line2);
      background: rgba(255,255,255,0.05);
      color: var(--text);
      padding: 7px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-size: 0.85rem;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
    }
    .copyBtn:hover{
      transform: translateY(-1px);
      border-color: rgba(102,227,255,0.35);
      background: rgba(102,227,255,0.10);
    }
    .copyBtn:active{transform: translateY(0px) scale(0.99);}
    .twoCol{
      display:grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 12px;
      align-items: start;
    }
    .vizBox{
      background: rgba(0,0,0,0.22);
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
    }
    .controls{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 10px;
      margin-top: 8px;
    }
    .ctl{
      grid-column: span 6;
      background: rgba(255,255,255,0.03);
      border:1px solid var(--line);
      border-radius: 14px;
      padding: 10px 10px;
    }
    .ctl label{
      display:flex;
      justify-content:space-between;
      align-items: baseline;
      gap: 10px;
      font-size: 0.92rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .ctl label b{color:var(--text)}
    input[type="range"]{
      width:100%;
      accent-color: var(--brand);
    }
    .readout{
      font-family: var(--mono);
      font-size: 0.88rem;
      color: #eaf3ff;
      opacity: 0.95;
    }
    canvas{
      width: 100%;
      height: 320px;
      display:block;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0.12));
      border:1px solid rgba(255,255,255,0.08);
    }
    .caption{
      color: var(--faint);
      font-size: 0.88rem;
      margin-top: 8px;
    }
    footer{
      padding: 18px 18px 34px;
      color: var(--faint);
      text-align:center;
    }
    .kpiRow{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
      margin-top: 10px;
    }
    .kpi{
      grid-column: span 4;
      background: rgba(0,0,0,0.20);
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 12px 12px;
    }
    .kpi .lab{color:var(--faint); font-size:0.85rem}
    .kpi .val{font-family:var(--mono); font-size:1.08rem; margin-top:4px; color:#eef5ff}
    .kpi .val small{color:var(--muted)}
    .divider{
      height:1px;
      background: var(--line);
      margin: 10px 0;
    }

    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr;}
      nav.toc{position:relative; top:auto;}
      .twoCol{grid-template-columns:1fr;}
      .card{grid-column: 1 / -1;}
      .ctl{grid-column: 1 / -1;}
      .kpi{grid-column: 1 / -1;}
      canvas{height: 300px;}
    }

    /* subtle motion */
    @keyframes floatIn{
      from{opacity:0; transform: translateY(10px);}
      to{opacity:1; transform: translateY(0px);}
    }
    section{animation: floatIn .35s ease both;}
    section:nth-child(2){animation-delay:.03s}
    section:nth-child(3){animation-delay:.06s}
    section:nth-child(4){animation-delay:.09s}
    section:nth-child(5){animation-delay:.12s}
    section:nth-child(6){animation-delay:.15s}

    /* print */
    @media print{
      body{background:#fff; color:#000}
      header, nav.toc, .copyBtn, .controls {display:none !important;}
      section{box-shadow:none; border-color:#ddd; background:#fff}
      canvas{border-color:#ddd; background:#fff}
      .eq{background:#fff; border-color:#ddd}
      .eq pre{color:#000}
      p, ul, li{color:#000}
    }
  </style>
</head>

<body>
  <header class="wrap">
    <div class="hero">
      <div class="heroTop">
        <div>
          <h1>Minimum Gain Required for Lasing (Reflection-Loss Limited)</h1>
          <div class="sub">
            A short, rigorous walkthrough of how facet reflections in a Fabry–Pérot semiconductor cavity set a
            <b>threshold gain</b> even when you neglect scattering, absorption, and other internal losses.
          </div>
        </div>
        <div class="metaRow">
          <div class="pill"><b>Device</b> Fabry–Pérot cavity</div>
          <div class="pill"><b>Given</b> L = 500&nbsp;µm, n = 3.5</div>
          <div class="pill"><b>Find</b> g<sub>th</sub> (gain coefficient)</div>
        </div>
      </div>
      <div class="divider"></div>
      <div style="padding: 0 22px 18px;">
        <div class="kpiRow">
          <div class="kpi">
            <div class="lab">Facet power reflectivity (normal incidence)</div>
            <div class="val" id="kpiR">R = —</div>
          </div>
          <div class="kpi">
            <div class="lab">Threshold gain (per length)</div>
            <div class="val" id="kpigcm">g<sub>th</sub> = —</div>
          </div>
          <div class="kpi">
            <div class="lab">Round-trip condition (intensity)</div>
            <div class="val"><small>R<sub>1</sub>R<sub>2</sub> · e<sup>2gL</sup> = 1</small></div>
          </div>
        </div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <div class="grid">
      <nav class="toc" aria-label="Table of contents">
        <div class="tocTitle">Table of Contents</div>
        <a href="#quick">Quick Summary</a>
        <a href="#p0">PART 0 — Concept Primer</a>
        <a href="#p1">PART 1 — Problem Analysis</a>
        <a href="#p2">PART 2 — Strategy & Tips</a>
        <a href="#p3">PART 3 — Full Solution</a>
        <a href="#p4">PART 4 — Deeper Understanding</a>
        <a href="#p5">PART 5 — Visualization Guide</a>
        <a class="small" href="#viz">Interactive Visualizations</a>
      </nav>

      <div class="content">
        <section id="quick">
          <h2>Quick Summary</h2>
          <ul>
            <li>We have a <b>500&nbsp;µm</b> InGaAsP crystal acting as a <b>Fabry–Pérot laser cavity</b> with refractive index <b>n = 3.5</b>.</li>
            <li>Neglecting all internal losses, the only loss mechanism is <b>escape through the facets</b> (finite reflectivity).</li>
            <li>At normal incidence (to air), facet power reflectivity is <b>R = ((n−1)/(n+1))²</b>.</li>
            <li>Lasing threshold occurs when the <b>round-trip intensity gain</b> exactly balances <b>round-trip mirror loss</b>:
              <b>R<sub>1</sub>R<sub>2</sub> e<sup>2 g L</sup> = 1</b>.</li>
            <li>Therefore, the threshold gain coefficient is
              <b>g<sub>th</sub> = (1/(2L)) ln(1/(R<sub>1</sub>R<sub>2</sub>))</b>, which becomes <b>g<sub>th</sub> = (1/L) ln(1/R)</b> for identical facets.</li>
            <li>Numerically for <b>L = 500&nbsp;µm</b>, <b>n = 3.5</b>: <b>R ≈ 0.3086</b> and <b>g<sub>th</sub> ≈ 23.5 cm⁻¹</b> (≈ 2350 m⁻¹).</li>
          </ul>
        </section>

        <section id="p0">
          <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

          <div class="cards">
            <div class="card">
              <h4>Core definitions</h4>
              <ul>
                <li><b>Gain coefficient</b> <span style="font-family:var(--mono)">g</span> (units: m⁻¹ or cm⁻¹): exponential amplification per unit length.</li>
                <li><b>Cavity length</b> <span style="font-family:var(--mono)">L</span> (m): physical separation between the two reflecting facets.</li>
                <li><b>Power reflectivity</b> <span style="font-family:var(--mono)">R</span> (dimensionless): fraction of optical power reflected at a surface.</li>
                <li><b>Threshold condition</b>: net round-trip intensity multiplication equals 1 (steady circulating intensity).</li>
              </ul>
            </div>

            <div class="card">
              <h4>Physical meaning</h4>
              <ul>
                <li><b>Facet losses</b>: every time light hits a facet, a fraction <span style="font-family:var(--mono)">(1−R)</span> escapes; that leakage must be replenished by gain.</li>
                <li><b>Exponential gain</b>: as light propagates through the active medium, intensity grows like
                  <span style="font-family:var(--mono)">I(z)=I(0) e^{g z}</span> (for intensity-based gain coefficient).</li>
                <li><b>Why “round trip”?</b> A resonator repeats the same path; stability requires the product of all multipliers over one loop to be 1.</li>
              </ul>
            </div>

            <div class="card full assump note">
              <b>Key principles & validity</b><br/>
              We use (i) <b>Fresnel reflection</b> at normal incidence for the facet reflectivity, and (ii) the <b>Fabry–Pérot threshold condition</b>
              for a traveling wave making a round trip. Valid when:
              <ul>
                <li>the facets are approximately planar and parallel (so a FP cavity exists),</li>
                <li>gain is uniform along the cavity,</li>
                <li>internal distributed losses (absorption/scattering) are neglected (as stated),</li>
                <li>we treat normal incidence (typical for cleaved semiconductor facets in a simple model).</li>
              </ul>
            </div>

            <div class="card">
              <h4>Common models/approximations</h4>
              <ul>
                <li><b>Normal-incidence Fresnel reflectivity</b> (air–semiconductor): <span style="font-family:var(--mono)">R=((n-1)/(n+1))^2</span>.</li>
                <li><b>Mirror-loss-only threshold</b>: ignore internal loss α; then <span style="font-family:var(--mono)">g_th = (1/(2L)) ln(1/(R1 R2))</span>.</li>
                <li><b>Intensity vs field convention</b>: here <span style="font-family:var(--mono)">g</span> is an <i>intensity</i> gain coefficient (so intensity scales as <span style="font-family:var(--mono)">e^{gL}</span>).</li>
              </ul>
            </div>

            <div class="card">
              <h4>Mini intuition examples</h4>
              <ul>
                <li>If <b>R → 1</b> (perfect mirrors), mirror loss vanishes and <b>g<sub>th</sub> → 0</b>.</li>
                <li>If the cavity gets <b>longer</b> (larger L), the required gain <b>decreases</b> because the wave has more distance to amplify each pass.</li>
              </ul>
            </div>

            <div class="card full warn note">
              <b>What to watch for (pitfalls)</b>
              <ul>
                <li>Using <b>field reflectivity</b> instead of <b>power reflectivity</b> (they differ by a square).</li>
                <li>Mixing <b>amplitude gain</b> vs <b>intensity gain</b> conventions (factors of 2 appear).</li>
                <li>Forgetting the <b>round trip is 2L</b>, not L.</li>
                <li>Unit slip: 500&nbsp;µm = 5×10⁻⁴ m = 0.05 cm.</li>
              </ul>
            </div>
          </div>
        </section>

        <section id="p1">
          <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

          <h3>Restate the problem</h3>
          <p>
            A 500&nbsp;µm long InGaAsP crystal forms a simple Fabry–Pérot cavity with refractive index n = 3.5.
            Ignoring scattering and all other internal losses, find the gain coefficient needed to <b>just</b> compensate
            the <b>reflection (mirror) losses</b> at the two crystal boundaries.
          </p>

          <div class="cards">
            <div class="card">
              <h4>Given</h4>
              <ul>
                <li>Cavity length: <b>L = 500&nbsp;µm</b></li>
                <li>Refractive index: <b>n = 3.5</b></li>
                <li>External medium: air (assumed): <b>n<sub>out</sub> ≈ 1</b></li>
                <li>Other losses: <b>neglected</b></li>
              </ul>
            </div>
            <div class="card">
              <h4>Unknowns</h4>
              <ul>
                <li>Facet reflectivity <b>R</b> (power)</li>
                <li>Threshold gain coefficient <b>g<sub>th</sub></b> (per length)</li>
              </ul>
            </div>
            <div class="card full">
              <h4>What must be found</h4>
              <ul>
                <li>A numeric value for <b>g<sub>th</sub></b> that makes the round-trip net multiplier equal to 1.</li>
              </ul>
            </div>
          </div>

          <div class="note assump">
            <b>Relevant physics & why it applies</b><br/>
            <ul>
              <li><b>Fresnel reflection</b> gives the facet power reflectivity because boundaries are dielectric interfaces.</li>
              <li><b>Fabry–Pérot threshold condition</b> applies because a laser cavity requires the circulating wave to reproduce itself after a round trip.</li>
              <li>We do <i>not</i> need detailed mode spacing, standing-wave patterns, or gain spectrum because the question asks only for gain to compensate mirror losses.</li>
            </ul>
          </div>

          <h3>Assumptions (explicit)</h3>
          <ul>
            <li>Normal incidence at facets; planar, parallel boundaries.</li>
            <li>Uniform gain along the crystal; steady-state threshold.</li>
            <li>No internal distributed loss (α = 0): only mirror (facet) loss matters.</li>
            <li>Both facets identical: <span style="font-family:var(--mono)">R1 = R2 = R</span>.</li>
          </ul>

          <h3>Possible approaches (compare)</h3>
          <ul>
            <li><b>Round-trip intensity balance (best)</b>: directly apply <span style="font-family:var(--mono)">R1 R2 e^{2 g L} = 1</span>. Fast, transparent, minimal assumptions.</li>
            <li><b>Mirror-loss coefficient</b>: define an equivalent distributed loss <span style="font-family:var(--mono)">α_m = (1/(2L)) ln(1/(R1 R2))</span> and set <span style="font-family:var(--mono)">g_th = α_m</span>. Same physics, slightly more “laser-textbook” style.</li>
            <li><b>Quality-factor method</b>: relate mirror loss to cavity photon lifetime and Q. Useful if the question asked about linewidth or lifetime; overkill here.</li>
          </ul>
          <p><b>Choice:</b> Use round-trip intensity balance because it directly encodes “barely compensate reflection losses.”</p>
        </section>

        <section id="p2">
          <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

          <ol style="color:var(--muted); margin: 8px 0 10px 20px;">
            <li>
              <b>Goal:</b> find facet power reflectivity.<br/>
              <b>Tool:</b> Fresnel (normal incidence) <span style="font-family:var(--mono)">R=((n-1)/(n+1))^2</span> (for air outside).<br/>
              <b>Meaning:</b> fraction of optical power that stays in the cavity at each bounce.
            </li>
            <li>
              <b>Goal:</b> write the threshold condition for one round trip.<br/>
              <b>Tool:</b> intensity multiplies by <span style="font-family:var(--mono)">e^{g·(2L)}</span> from gain and by <span style="font-family:var(--mono)">R1 R2</span> from mirrors.<br/>
              <b>Meaning:</b> threshold means “no net growth/decay” per round trip.
            </li>
            <li>
              <b>Goal:</b> solve for <span style="font-family:var(--mono)">g</span> symbolically.<br/>
              <b>Tool:</b> logarithms: <span style="font-family:var(--mono)">g = (1/(2L)) ln(1/(R1 R2))</span>.<br/>
              <b>Meaning:</b> required exponential amplification per unit length.
            </li>
            <li>
              <b>Goal:</b> insert numbers with consistent units.<br/>
              <b>Tool:</b> convert <span style="font-family:var(--mono)">L</span> to cm (or m).<br/>
              <b>Meaning:</b> answer in standard laser units (cm⁻¹ is common in semiconductor lasers).
            </li>
            <li>
              <b>Goal:</b> sanity-check limits and dimensions.<br/>
              <b>Tool:</b> check <span style="font-family:var(--mono)">R→1</span> gives <span style="font-family:var(--mono)">g→0</span>; check units are inverse length.<br/>
              <b>Meaning:</b> confirms we used the right convention.
            </li>
          </ol>

          <div class="warn note">
            <b>Common mistakes & quick tips</b>
            <ul>
              <li><b>Tip:</b> Use <i>power</i> reflectivity in the threshold equation for intensity.</li>
              <li><b>Mistake:</b> forgetting the factor <span style="font-family:var(--mono)">2L</span> for a round trip.</li>
              <li><b>Tip:</b> If facets are identical, simplify: <span style="font-family:var(--mono)">g_th = (1/L) ln(1/R)</span>.</li>
            </ul>
          </div>
        </section>

        <section id="p3">
          <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

          <h3>Physical intuition first</h3>
          <p>
            With no internal loss, the only way energy leaves the cavity is through the facets.
            Each bounce leaks a fraction (1−R), so the circulating light would decay unless the medium provides gain.
            At threshold, the gain exactly replaces that leaked power over each round trip.
          </p>

          <h3>Step 1: Facet reflectivity from Fresnel (normal incidence)</h3>
          <p>
            For a dielectric interface at normal incidence (from index <span style="font-family:var(--mono)">n</span> inside
            to <span style="font-family:var(--mono)">n_out≈1</span> outside), the <b>power reflectivity</b> is
          </p>

          <div class="eq" data-copy="R = ((n - 1)/(n + 1))^2">
            <button class="copyBtn" aria-label="Copy equation">Copy</button>
            <pre>R = ((n - 1)/(n + 1))^2     (normal incidence, power reflectivity)</pre>
          </div>

          <p>
            Here <b>n = 3.5</b>, so
            <span style="font-family:var(--mono)">R = ((3.5−1)/(3.5+1))^2 = (2.5/4.5)^2</span>.
          </p>

          <h3>Step 2: Round-trip threshold condition</h3>
          <p>
            Let <span style="font-family:var(--mono)">g</span> be the <b>intensity gain coefficient</b> (units: m⁻¹ or cm⁻¹),
            meaning intensity grows as <span style="font-family:var(--mono)">I(z)=I(0)e^{g z}</span>.
            A round trip traverses distance <span style="font-family:var(--mono)">2L</span>, so gain multiplies intensity by <span style="font-family:var(--mono)">e^{2gL}</span>.
          </p>
          <p>
            Each round trip also includes one reflection from each facet, multiplying intensity by <span style="font-family:var(--mono)">R1R2</span>.
            At <b>threshold</b>, the circulating intensity reproduces itself after a round trip:
          </p>

          <div class="eq" data-copy="R1*R2*exp(2*g*L) = 1">
            <button class="copyBtn" aria-label="Copy equation">Copy</button>
            <pre>R1 · R2 · exp(2 g L) = 1     (threshold: net round-trip multiplier = 1)</pre>
          </div>

          <h3>Step 3: Solve for the threshold gain</h3>
          <p>
            Take the natural logarithm of both sides:
          </p>

          <div class="eq" data-copy="2*g*L + ln(R1*R2) = 0  =>  g_th = (1/(2*L))*ln(1/(R1*R2))">
            <button class="copyBtn" aria-label="Copy equation">Copy</button>
            <pre>2 g L + ln(R1 R2) = 0
⇒ g_th = (1/(2L)) ln(1/(R1 R2))</pre>
          </div>

          <p>
            For identical facets <span style="font-family:var(--mono)">R1=R2=R</span>, this simplifies to:
          </p>

          <div class="eq" data-copy="g_th = (1/L)*ln(1/R)">
            <button class="copyBtn" aria-label="Copy equation">Copy</button>
            <pre>g_th = (1/L) ln(1/R)     (identical facets)</pre>
          </div>

          <h3>Step 4: Insert numbers carefully (unit-consistent)</h3>
          <p>
            First compute reflectivity:
            <span style="font-family:var(--mono)">R = (2.5/4.5)^2 ≈ 0.30864</span>.
          </p>
          <p>
            Convert length: <b>L = 500&nbsp;µm = 5×10⁻⁴ m = 0.05 cm</b>.
          </p>
          <p>
            Then
            <span style="font-family:var(--mono)">g_th = (1/L) ln(1/R)</span> gives
          </p>

          <div class="eq" data-copy="R ≈ 0.30864;  L = 0.05 cm;  g_th = (1/0.05)*ln(1/0.30864) ≈ 23.51 cm^-1">
            <button class="copyBtn" aria-label="Copy final numeric">Copy</button>
            <pre>R ≈ 0.30864
L = 0.05 cm

g_th = (1/L) ln(1/R)
     = (1/0.05) ln(1/0.30864)
     ≈ 23.51 cm^-1</pre>
          </div>

          <div class="final note">
            <b>Final Answer (mirror-loss limited threshold gain)</b><br/>
            <span style="font-family:var(--mono)">
              g_th = (1/(2L)) ln(1/(R1 R2)),  with R = ((n−1)/(n+1))^2.
            </span><br/>
            For <b>n=3.5</b>, <b>L=500 µm</b> (air outside, identical facets):<br/>
            <b><span style="font-family:var(--mono)">R ≈ 0.3086</span></b> and
            <b><span style="font-family:var(--mono)">g_th ≈ 23.5 cm^-1</span></b>
            (≈ <b><span style="font-family:var(--mono)">2350 m^-1</span></b>).
          </div>

          <h3>Sanity checks</h3>
          <ul>
            <li><b>Units:</b> ln(…) is dimensionless; dividing by L gives inverse length → correct.</li>
            <li><b>Limiting case R→1:</b> ln(1/R)→0 ⇒ g<sub>th</sub>→0 → perfect mirrors need no gain to offset mirror loss.</li>
            <li><b>Trend with length:</b> g<sub>th</sub> ∝ 1/L, so longer cavity lowers threshold gain → matches intuition.</li>
          </ul>

          <p>
            Connection to the diagram/plots: the diagram shows the two partially reflecting facets (each with reflectivity R),
            and the plots show how g<sub>th</sub> changes as you vary <span style="font-family:var(--mono)">n</span> (which changes R) and <span style="font-family:var(--mono)">L</span>.
          </p>
        </section>

        <section id="p4">
          <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

          <h3>Re-interpreting the final formula</h3>
          <p>
            The threshold gain
            <span style="font-family:var(--mono)">g_th = (1/(2L)) ln(1/(R1 R2))</span>
            has two clear “knobs”:
          </p>
          <ul>
            <li><b>Mirror strength</b> (<span style="font-family:var(--mono)">R1, R2</span>): higher reflectivity lowers the logarithmic loss, reducing required gain.</li>
            <li><b>Cavity length</b> (<span style="font-family:var(--mono)">L</span>): longer cavities need less gain per unit length because amplification accrues over more distance per pass.</li>
          </ul>

          <h3>How changing parameters affects the outcome (connect to plots)</h3>
          <ul>
            <li>Increasing <b>n</b> increases the Fresnel reflectivity <b>R</b>, so <b>g<sub>th</sub></b> decreases.</li>
            <li>Increasing <b>L</b> decreases <b>g<sub>th</sub></b> roughly as <b>1/L</b>.</li>
            <li>If you set <b>n close to 1</b>, reflectivity becomes tiny and the required gain skyrockets (almost all light leaks out each hit).</li>
          </ul>

          <h3>Alternative derivation idea (brief)</h3>
          <p>
            You can define a <b>mirror loss coefficient</b> (an equivalent distributed loss) as
            <span style="font-family:var(--mono)">α_m = (1/(2L)) ln(1/(R1 R2))</span>.
            Then the standard textbook threshold condition is <span style="font-family:var(--mono)">g_th = α_m + α_i</span>,
            where <span style="font-family:var(--mono)">α_i</span> is internal loss. Here <span style="font-family:var(--mono)">α_i = 0</span>, so the same result follows immediately.
          </p>

          <h3>Concept check (quick Q&A)</h3>
          <ul>
            <li><b>Q:</b> If both mirrors become twice as reflective (R increases), what happens to g<sub>th</sub>? <b>A:</b> It decreases, because ln(1/R) shrinks.</li>
            <li><b>Q:</b> Why is there a factor of 2 in exp(2gL)? <b>A:</b> The wave traverses the cavity twice per round trip: forward + backward.</li>
            <li><b>Q:</b> What physical loss is being compensated at threshold here? <b>A:</b> Only power escaping through the facets (mirror loss).</li>
            <li><b>Q:</b> Would adding an anti-reflection coating increase or decrease threshold gain? <b>A:</b> Increase (it reduces R, increasing mirror loss).</li>
          </ul>
        </section>

        <section id="p5">
          <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

          <div class="twoCol" id="viz">
            <div class="vizBox">
              <h3 style="margin-top:0;">What each canvas shows</h3>
              <ul>
                <li><b>Diagram canvas:</b> A labeled Fabry–Pérot cavity of length L with two facets of reflectivity R and an internal gain g.</li>
                <li><b>Main plot:</b> <span style="font-family:var(--mono)">g_th(n)</span> for fixed L (your chosen L), computed via Fresnel R(n).</li>
                <li><b>Secondary plot:</b> <span style="font-family:var(--mono)">g_th(L)</span> for fixed n (your chosen n), showing the ~1/L trend.</li>
              </ul>

              <h3>Interactive controls</h3>
              <ul>
                <li><b>n slider:</b> changes facet reflectivity R and updates the marked point on both plots.</li>
                <li><b>L slider:</b> changes cavity length and updates the threshold curves and marked point.</li>
              </ul>

              <p class="caption">
                Note: The plots are computed from the <b>same equations</b> used in the solution, so you can “feel” how mirror loss translates into required gain.
              </p>
            </div>

            <div class="vizBox">
              <h3 style="margin-top:0;">Interactive Visualizations</h3>

              <div class="controls" aria-label="Interactive controls">
                <div class="ctl">
                  <label>
                    <span>Refractive index <b>n</b></span>
                    <span class="readout" id="nRead">3.50</span>
                  </label>
                  <input id="nSlider" type="range" min="1.10" max="4.50" step="0.01" value="3.50"/>
                </div>
                <div class="ctl">
                  <label>
                    <span>Cavity length <b>L</b> (µm)</span>
                    <span class="readout" id="LRead">500</span>
                  </label>
                  <input id="LSlider" type="range" min="50" max="2000" step="10" value="500"/>
                </div>
              </div>

              <div style="margin-top:10px;">
                <canvas id="cavityCanvas" aria-label="Cavity diagram"></canvas>
                <div class="caption">Diagram: FP cavity with facet reflectivities and gain medium.</div>
              </div>

              <div style="margin-top:12px;">
                <canvas id="mainPlot" aria-label="Main plot: threshold gain vs refractive index"></canvas>
                <div class="caption">Main plot: g<sub>th</sub> versus n (for current L).</div>
              </div>

              <div style="margin-top:12px;">
                <canvas id="secondaryPlot" aria-label="Secondary plot: threshold gain vs cavity length"></canvas>
                <div class="caption">Secondary plot: g<sub>th</sub> versus L (for current n).</div>
              </div>
            </div>
          </div>
        </section>

      </div>
    </div>
  </main>

  <footer class="wrap">
    Built with vanilla HTML/CSS/JS. Equations and plots use the same symbols and assumptions as the written solution.
  </footer>

  <script>
    // --------------------------
    // Utilities
    // --------------------------
    function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function niceTicks(min, max, targetCount){
      // Simple "nice number" tick generator
      const span = max - min;
      if(span <= 0) return {step:1, ticks:[min]};
      const raw = span / Math.max(2, targetCount);
      const pow = Math.pow(10, Math.floor(Math.log10(raw)));
      const candidates = [1,2,5,10].map(m => m*pow);
      let step = candidates[0];
      for(const s of candidates){
        if(raw <= s){ step = s; break; }
      }
      const t0 = Math.ceil(min/step)*step;
      const ticks = [];
      for(let v=t0; v<=max+1e-12; v+=step) ticks.push(+v.toFixed(12));
      return {step, ticks};
    }

    function setHiDPI(canvas){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect.width * dpr));
      const h = Math.max(2, Math.floor(rect.height * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {ctx, dpr, w:rect.width, h:rect.height};
    }

    // --------------------------
    // Physics model
    // --------------------------
    function reflectivityPower(n, nOut=1.0){
      // normal incidence power reflectivity
      const r = (n - nOut) / (n + nOut);
      return r*r;
    }
    function gThreshold(R1, R2, L_m){
      // intensity gain coefficient g (1/m) from round-trip intensity balance
      // R1*R2*exp(2*g*L)=1 => g=(1/(2L))*ln(1/(R1R2))
      const prod = Math.max(1e-12, R1*R2);
      return (1/(2*L_m)) * Math.log(1/prod);
    }

    function fmt(x, digits=3){
      if(!isFinite(x)) return "—";
      const abs = Math.abs(x);
      if(abs >= 1000) return x.toFixed(0);
      if(abs >= 100) return x.toFixed(1);
      if(abs >= 10) return x.toFixed(2);
      return x.toFixed(digits);
    }

    // --------------------------
    // Plotting primitives
    // --------------------------
    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
      const {x, y, w, h, padL, padR, padT, padB} = box;
      ctx.save();

      // Panel
      ctx.fillStyle = "rgba(0,0,0,0.18)";
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      roundRect(ctx, x, y, w, h, 14);
      ctx.fill();
      ctx.stroke();

      // Title
      ctx.fillStyle = "rgba(231,238,252,0.92)";
      ctx.font = "700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(title, x + padL, y + 20);

      // Plot region
      const px = x + padL, py = y + padT, pw = w - padL - padR, ph = h - padT - padB;

      // Grid + ticks
      ctx.strokeStyle = "rgba(255,255,255,0.07)";
      ctx.lineWidth = 1;

      const xt = niceTicks(xMin, xMax, 6);
      const yt = niceTicks(yMin, yMax, 6);

      // Grid lines
      for(const xv of xt.ticks){
        const X = px + (xv - xMin) / (xMax - xMin) * pw;
        ctx.beginPath();
        ctx.moveTo(X, py);
        ctx.lineTo(X, py + ph);
        ctx.stroke();
      }
      for(const yv of yt.ticks){
        const Y = py + ph - (yv - yMin) / (yMax - yMin) * ph;
        ctx.beginPath();
        ctx.moveTo(px, Y);
        ctx.lineTo(px + pw, Y);
        ctx.stroke();
      }

      // Axes border
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.strokeRect(px, py, pw, ph);

      // Tick labels
      ctx.fillStyle = "rgba(185,198,228,0.92)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";

      for(const xv of xt.ticks){
        const X = px + (xv - xMin) / (xMax - xMin) * pw;
        const label = (Math.abs(xv) < 1e-9) ? "0" : fmt(xv, 2);
        ctx.fillText(label, X - 10, py + ph + 16);
      }
      for(const yv of yt.ticks){
        const Y = py + ph - (yv - yMin) / (yMax - yMin) * ph;
        const label = (Math.abs(yv) < 1e-9) ? "0" : fmt(yv, 2);
        ctx.fillText(label, px - 46, Y + 4);
      }

      // Axis labels
      ctx.fillStyle = "rgba(231,238,252,0.86)";
      ctx.font = "600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(xLabel, px + pw/2 - ctx.measureText(xLabel).width/2, y + h - 10);

      ctx.save();
      ctx.translate(x + 14, py + ph/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
      ctx.restore();

      ctx.restore();

      return {px, py, pw, ph};
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function plotLine(ctx, region, xMin, xMax, yMin, yMax, xs, ys){
      const {px, py, pw, ph} = region;
      ctx.save();
      ctx.beginPath();
      for(let i=0;i<xs.length;i++){
        const X = px + (xs[i]-xMin)/(xMax-xMin)*pw;
        const Y = py + ph - (ys[i]-yMin)/(yMax-yMin)*ph;
        if(i===0) ctx.moveTo(X,Y);
        else ctx.lineTo(X,Y);
      }
      ctx.strokeStyle = "rgba(102,227,255,0.85)";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }

    function plotMarker(ctx, region, xMin, xMax, yMin, yMax, x0, y0, label){
      const {px, py, pw, ph} = region;
      const X = px + (x0-xMin)/(xMax-xMin)*pw;
      const Y = py + ph - (y0-yMin)/(yMax-yMin)*ph;

      ctx.save();
      ctx.fillStyle = "rgba(167,139,250,0.95)";
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(X, Y, 5, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // callout
      const pad=6;
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      const tw = ctx.measureText(label).width;
      const bx = clamp(X + 10, px, px+pw - (tw+pad*2));
      const by = clamp(Y - 24, py, py+ph - 18);
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      roundRect(ctx, bx, by, tw+pad*2, 18, 8);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = "rgba(231,238,252,0.92)";
      ctx.fillText(label, bx+pad, by+13);
      ctx.restore();
    }

    // --------------------------
    // Diagram drawing
    // --------------------------
    function drawCavityDiagram(canvas, n, L_um, R){
      const {ctx, w, h} = setHiDPI(canvas);
      ctx.clearRect(0,0,w,h);

      // layout in CSS pixels
      const W = w, H = h;
      const margin = 18;
      const left = margin, right = W - margin;
      const top = 24, bottom = H - margin;

      // Background
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.18)";
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      roundRect(ctx, 10, 10, W-20, H-20, 14);
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      // Title
      ctx.fillStyle = "rgba(231,238,252,0.92)";
      ctx.font = "700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Diagram: Fabry–Pérot cavity (mirror loss only)", left, 26);

      // Cavity bar
      const barY = 120;
      const barH = 56;
      const barX = 70;
      const barW = W - 140;

      // medium
      ctx.save();
      ctx.fillStyle = "rgba(102,227,255,0.10)";
      ctx.strokeStyle = "rgba(102,227,255,0.28)";
      roundRect(ctx, barX, barY, barW, barH, 14);
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      // facets
      ctx.save();
      ctx.strokeStyle = "rgba(231,238,252,0.70)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(barX, barY-6);
      ctx.lineTo(barX, barY+barH+6);
      ctx.moveTo(barX+barW, barY-6);
      ctx.lineTo(barX+barW, barY+barH+6);
      ctx.stroke();
      ctx.restore();

      // arrows (round trip)
      ctx.save();
      ctx.strokeStyle = "rgba(167,139,250,0.85)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(barX+18, barY+barH/2);
      ctx.lineTo(barX+barW-18, barY+barH/2);
      ctx.stroke();
      arrowHead(ctx, barX+barW-18, barY+barH/2, 0);

      ctx.beginPath();
      ctx.moveTo(barX+barW-18, barY+barH/2+18);
      ctx.lineTo(barX+18, barY+barH/2+18);
      ctx.stroke();
      arrowHead(ctx, barX+18, barY+barH/2+18, Math.PI);
      ctx.restore();

      // labels
      ctx.fillStyle = "rgba(185,198,228,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      ctx.fillText(`inside index n = ${n.toFixed(2)}`, barX+14, barY-14);
      ctx.fillText(`length L = ${Math.round(L_um)} µm`, barX+14, barY+barH+22);

      // Reflectivity labels
      ctx.fillStyle = "rgba(231,238,252,0.92)";
      ctx.font = "600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(`Facet reflectivity (power): R = ${R.toFixed(4)}`, barX+14, barY+barH+44);

      // gain label in medium
      ctx.fillStyle = "rgba(231,238,252,0.90)";
      ctx.font = "700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Gain medium (g)", barX + barW/2 - ctx.measureText("Gain medium (g)").width/2, barY + barH/2 + 5);

      // show leakage
      ctx.save();
      ctx.strokeStyle = "rgba(251,191,36,0.85)";
      ctx.lineWidth = 2;
      // left leakage
      ctx.beginPath();
      ctx.moveTo(barX-2, barY+barH/2);
      ctx.lineTo(barX-28, barY+barH/2-16);
      ctx.stroke();
      arrowHead(ctx, barX-28, barY+barH/2-16, -Math.PI*3/4);
      // right leakage
      ctx.beginPath();
      ctx.moveTo(barX+barW+2, barY+barH/2);
      ctx.lineTo(barX+barW+28, barY+barH/2-16);
      ctx.stroke();
      arrowHead(ctx, barX+barW+28, barY+barH/2-16, -Math.PI/4);
      ctx.restore();

      ctx.fillStyle = "rgba(251,191,36,0.92)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      ctx.fillText("leakage ~ (1−R)", barX+barW-150, barY-14);

      // bottom formula
      ctx.fillStyle = "rgba(185,198,228,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      const f = "Threshold: R1*R2*exp(2*g*L) = 1";
      ctx.fillText(f, left, bottom-8);

      function arrowHead(ctx, x, y, ang){
        const s = 8;
        ctx.save();
        ctx.translate(x,y);
        ctx.rotate(ang);
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(-s, -s*0.55);
        ctx.lineTo(-s, s*0.55);
        ctx.closePath();
        ctx.fillStyle = "rgba(167,139,250,0.85)";
        ctx.fill();
        ctx.restore();
      }
    }

    // --------------------------
    // Main plotting functions
    // --------------------------
    function drawMainPlot(canvas, nSel, L_m){
      const {ctx, w, h} = setHiDPI(canvas);
      ctx.clearRect(0,0,w,h);

      // sweep n
      const nMin = 1.1, nMax = 4.5;
      const N = 220;
      const xs = new Array(N);
      const ys = new Array(N);
      let yMax = 0;

      for(let i=0;i<N;i++){
        const n = lerp(nMin, nMax, i/(N-1));
        const R = reflectivityPower(n, 1.0);
        const g = gThreshold(R, R, L_m); // 1/m
        const g_cm = g / 100.0; // 1/cm
        xs[i]=n;
        ys[i]=g_cm;
        yMax = Math.max(yMax, g_cm);
      }
      const yMin = 0;
      const yTop = yMax*1.08;

      const box = {x:10,y:10,w:w-20,h:h-20,padL:64,padR:18,padT:40,padB:44};
      const region = drawAxes(
        ctx, box,
        nMin, nMax,
        yMin, yTop,
        "refractive index n (dimensionless)",
        "threshold gain g_th (cm^-1)",
        "Main plot: threshold gain vs refractive index"
      );
      plotLine(ctx, region, nMin, nMax, yMin, yTop, xs, ys);

      // selected point
      const Rsel = reflectivityPower(nSel, 1.0);
      const gSel_cm = gThreshold(Rsel, Rsel, L_m) / 100.0;
      plotMarker(ctx, region, nMin, nMax, yMin, yTop, nSel, gSel_cm, `n=${nSel.toFixed(2)}, g=${gSel_cm.toFixed(2)} cm^-1`);

      // small legend
      ctx.save();
      ctx.fillStyle = "rgba(231,238,252,0.86)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Curve uses R=((n-1)/(n+1))^2 and g_th=(1/L)ln(1/R)", 74, h-24);
      ctx.restore();
    }

    function drawSecondaryPlot(canvas, nSel, L_um_sel){
      const {ctx, w, h} = setHiDPI(canvas);
      ctx.clearRect(0,0,w,h);

      // sweep L
      const Lmin_um = 50, Lmax_um = 2000;
      const N = 220;
      const xs = new Array(N);
      const ys = new Array(N);
      let yMax = 0;

      const R = reflectivityPower(nSel, 1.0);
      for(let i=0;i<N;i++){
        const Lum = lerp(Lmin_um, Lmax_um, i/(N-1));
        const Lm = Lum * 1e-6;
        const g_cm = gThreshold(R, R, Lm) / 100.0;
        xs[i]=Lum;
        ys[i]=g_cm;
        yMax = Math.max(yMax, g_cm);
      }
      const yMin = 0;
      const yTop = yMax*1.08;

      const box = {x:10,y:10,w:w-20,h:h-20,padL:64,padR:18,padT:40,padB:44};
      const region = drawAxes(
        ctx, box,
        Lmin_um, Lmax_um,
        yMin, yTop,
        "cavity length L (µm)",
        "threshold gain g_th (cm^-1)",
        "Secondary plot: threshold gain vs cavity length"
      );
      plotLine(ctx, region, Lmin_um, Lmax_um, yMin, yTop, xs, ys);

      // selected point
      const gSel_cm = gThreshold(R, R, L_um_sel*1e-6) / 100.0;
      plotMarker(ctx, region, Lmin_um, Lmax_um, yMin, yTop, L_um_sel, gSel_cm, `L=${Math.round(L_um_sel)} µm, g=${gSel_cm.toFixed(2)} cm^-1`);

      // trend note
      ctx.save();
      ctx.fillStyle = "rgba(231,238,252,0.86)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("For fixed n, g_th ∝ 1/L (log factor constant).", 74, h-24);
      ctx.restore();
    }

    // --------------------------
    // Copy buttons
    // --------------------------
    function setupCopyButtons(){
      document.querySelectorAll(".eq").forEach(eq => {
        const btn = eq.querySelector(".copyBtn");
        const txt = eq.getAttribute("data-copy") || (eq.innerText || "").trim();
        btn.addEventListener("click", async () => {
          try{
            await navigator.clipboard.writeText(txt);
            const old = btn.textContent;
            btn.textContent = "Copied!";
            setTimeout(()=>btn.textContent=old, 850);
          }catch(e){
            // fallback
            const ta = document.createElement("textarea");
            ta.value = txt;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand("copy");
            document.body.removeChild(ta);
            const old = btn.textContent;
            btn.textContent = "Copied!";
            setTimeout(()=>btn.textContent=old, 850);
          }
        });
      });
    }

    // --------------------------
    // Smooth TOC scrolling
    // --------------------------
    function setupTOC(){
      document.querySelectorAll('nav.toc a[href^="#"]').forEach(a=>{
        a.addEventListener("click", (e)=>{
          const id = a.getAttribute("href");
          const el = document.querySelector(id);
          if(!el) return;
          e.preventDefault();
          el.scrollIntoView({behavior:"smooth", block:"start"});
          history.replaceState(null, "", id);
        });
      });
    }

    // --------------------------
    // App state + rendering
    // --------------------------
    const nSlider = document.getElementById("nSlider");
    const LSlider = document.getElementById("LSlider");
    const nRead = document.getElementById("nRead");
    const LRead = document.getElementById("LRead");

    const cavityCanvas = document.getElementById("cavityCanvas");
    const mainPlot = document.getElementById("mainPlot");
    const secondaryPlot = document.getElementById("secondaryPlot");

    const kpiR = document.getElementById("kpiR");
    const kpigcm = document.getElementById("kpigcm");

    function update(){
      const n = parseFloat(nSlider.value);
      const Lum = parseFloat(LSlider.value);
      const Lm = Lum * 1e-6;

      const R = reflectivityPower(n, 1.0);
      const g_m = gThreshold(R, R, Lm);
      const g_cm = g_m / 100.0;

      nRead.textContent = n.toFixed(2);
      LRead.textContent = `${Math.round(Lum)}`;

      kpiR.textContent = `R = ${R.toFixed(4)}`;
      kpigcm.innerHTML = `g<sub>th</sub> = ${g_cm.toFixed(2)} <small>cm^-1</small>`;

      drawCavityDiagram(cavityCanvas, n, Lum, R);
      drawMainPlot(mainPlot, n, Lm);
      drawSecondaryPlot(secondaryPlot, n, Lum);
    }

    function setupResize(){
      let t=null;
      window.addEventListener("resize", ()=>{
        if(t) cancelAnimationFrame(t);
        t = requestAnimationFrame(update);
      });
    }

    // init
    setupCopyButtons();
    setupTOC();
    setupResize();
    update();

    // live controls
    nSlider.addEventListener("input", update);
    LSlider.addEventListener("input", update);
  </script>
</body>
</html>
