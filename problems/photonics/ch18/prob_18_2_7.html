<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Facet Reflectance Tolerance from Fabry–Perot Ripple (1550-nm InGaAsP SOA)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#101823;
      --panel2:#0e1520;
      --text:#e9eef6;
      --muted:#a9b4c4;
      --accent:#66d9ff;
      --accent2:#a7ff83;
      --warn:#ffd166;
      --danger:#ff6b6b;
      --ok:#3ddc97;
      --line:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 700px at 20% -10%, rgba(102,217,255,.14), transparent 60%),
                  radial-gradient(900px 600px at 80% 0%, rgba(167,255,131,.10), transparent 55%),
                  linear-gradient(180deg, #070a0f 0%, var(--bg) 35%, #070a0f 100%);
      color:var(--text);
      line-height:1.55;
    }
    header{
      padding: 32px 18px 18px;
      max-width: 1180px;
      margin: 0 auto;
    }
    .title{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
      padding: 22px 22px;
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.015));
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .title:before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(500px 220px at 20% 0%, rgba(102,217,255,.16), transparent 55%),
                  radial-gradient(520px 240px at 90% 20%, rgba(167,255,131,.12), transparent 55%);
      filter: blur(10px);
      opacity:.9;
      pointer-events:none;
    }
    .title > *{position:relative; z-index:1;}
    h1{
      font-size: clamp(22px, 3.2vw, 34px);
      margin:0;
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      margin:0;
      max-width: 90ch;
    }

    main{
      max-width:1180px;
      margin: 0 auto;
      padding: 0 18px 60px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }

    nav{
      position: sticky;
      top: 14px;
      align-self:start;
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.035), rgba(255,255,255,.015));
      box-shadow: var(--shadow);
      padding:14px 14px;
      overflow:hidden;
    }
    nav .toc-title{
      font-weight:700;
      font-size:14px;
      letter-spacing:.6px;
      text-transform:uppercase;
      margin: 2px 0 10px;
      color: rgba(233,238,246,.9);
    }
    nav a{
      display:block;
      text-decoration:none;
      color: var(--muted);
      padding:8px 10px;
      border-radius: 12px;
      border:1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      font-size:14px;
    }
    nav a:hover{
      background: rgba(102,217,255,.06);
      border-color: rgba(102,217,255,.20);
      color: var(--text);
      transform: translateX(2px);
    }
    nav .mini{
      margin-top:10px;
      padding-top:10px;
      border-top:1px solid var(--line);
      color: var(--muted);
      font-size:13px;
    }

    article{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.012));
      box-shadow: var(--shadow);
      padding: 18px 18px 10px;
      overflow:hidden;
    }

    section{
      padding: 12px 2px 8px;
      border-top:1px solid var(--line);
    }
    section:first-of-type{border-top:none}
    h2{
      font-size: clamp(18px, 2.3vw, 24px);
      margin: 6px 0 10px;
    }
    h3{
      font-size: 16px;
      margin: 14px 0 8px;
      color: rgba(233,238,246,.96);
    }
    p{margin: 8px 0 10px; color: rgba(233,238,246,.92);}
    ul{margin: 8px 0 12px 18px; color: rgba(233,238,246,.90);}
    li{margin: 6px 0;}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1.2fr 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr; }
      nav{position:relative; top:auto;}
    }
    @media (max-width: 760px){
      .grid2,.grid3{grid-template-columns: 1fr;}
    }

    .callout{
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 12px 12px;
      background: rgba(16,24,35,.60);
      box-shadow: 0 8px 20px rgba(0,0,0,.25);
      position:relative;
      overflow:hidden;
    }
    .callout:before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(420px 160px at 0% 0%, rgba(102,217,255,.12), transparent 60%),
                  radial-gradient(420px 160px at 100% 0%, rgba(167,255,131,.09), transparent 60%);
      opacity:.7;
      pointer-events:none;
    }
    .callout > *{position:relative; z-index:1;}
    .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size:12px;
      letter-spacing:.4px;
      text-transform:uppercase;
      color: rgba(233,238,246,.85);
      margin-bottom:8px;
    }
    .dot{
      width:10px; height:10px; border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(102,217,255,.12);
    }
    .warn .dot{background: var(--warn); box-shadow:0 0 0 3px rgba(255,209,102,.14);}
    .danger .dot{background: var(--danger); box-shadow:0 0 0 3px rgba(255,107,107,.14);}
    .ok .dot{background: var(--ok); box-shadow:0 0 0 3px rgba(61,220,151,.14);}

    .eq{
      font-family: var(--mono);
      font-size: 13px;
      line-height: 1.45;
      padding: 10px 10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      overflow:auto;
      position:relative;
      margin: 8px 0 10px;
      white-space: pre;
    }
    .eq .copy-btn{
      position:absolute;
      top:8px; right:8px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 10px;
      padding: 6px 9px;
      font-size: 12px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .eq .copy-btn:hover{
      transform: translateY(-1px);
      background: rgba(102,217,255,.10);
      border-color: rgba(102,217,255,.30);
    }

    .vizWrap{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin: 10px 0 6px;
    }
    @media (max-width: 860px){
      .vizWrap{grid-template-columns: 1fr;}
    }
    figure{
      margin:0;
      padding: 10px 10px 12px;
      border:1px solid var(--line);
      border-radius: 16px;
      background: rgba(16,24,35,.55);
      box-shadow: 0 10px 24px rgba(0,0,0,.22);
    }
    figcaption{
      color: var(--muted);
      font-size: 13px;
      margin-top: 10px;
    }
    canvas{
      width:100%;
      height: 290px;
      display:block;
      border-radius: 14px;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
    }
    #diagramCanvas{height: 260px;}
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:10px 14px;
      align-items:center;
      padding: 10px 10px;
      border-radius: 16px;
      border:1px solid var(--line);
      background: rgba(16,24,35,.55);
      margin: 12px 0 8px;
    }
    .control{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 220px;
      flex: 1 1 260px;
    }
    .control label{
      font-size: 13px;
      color: var(--muted);
      display:flex;
      justify-content:space-between;
      gap:10px;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .readouts{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 8px;
    }
    @media (max-width: 760px){
      .readouts{grid-template-columns: 1fr;}
    }
    .metric{
      padding: 10px 10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }
    .metric .k{color:var(--muted); font-size:12px; margin-bottom:6px;}
    .metric .v{font-size:16px; font-weight:700;}
    .pill{
      display:inline-flex;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      margin-left: 8px;
      vertical-align: middle;
      color: rgba(233,238,246,.9);
    }
    footer{
      max-width:1180px;
      margin: 0 auto;
      padding: 14px 18px 40px;
      color: var(--muted);
      font-size: 13px;
    }
    .printNote{
      margin-top: 10px;
      font-size: 12px;
      color: rgba(169,180,196,.9);
    }
    @media print{
      body{background:#fff; color:#000;}
      header, main, footer{max-width: 100%; }
      nav{display:none;}
      article{box-shadow:none; border:1px solid #ccc; background:#fff;}
      canvas{border:1px solid #ccc; background:#fff;}
      .title{box-shadow:none;}
      .eq{background:#f7f7f7; border:1px solid #ccc;}
      .eq .copy-btn{display:none;}
    }
  </style>
</head>
<body>
<header>
  <div class="title">
    <h1>Facet Reflectance Tolerance for an AR-Coated InGaAsP SOA (1550&nbsp;nm) from Fabry–Perot Gain Ripple</h1>
    <p class="subtitle">
      We treat the semiconductor optical amplifier (SOA) as a short Fabry–Perot (FP) cavity formed by its two facets.
      Residual reflectance after antireflection (AR) coatings causes frequency-dependent transmission, imprinting ripple on the gain profile.
      The goal: limit that ripple to &lt; 10%.
    </p>
  </div>
</header>

<main>
  <nav aria-label="Table of contents">
    <div class="toc-title">Contents</div>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
    <div class="mini">
      <div><b>Interactive:</b> slide the facet reflectance <span class="pill">R</span> to see FP ripple change.</div>
      <div class="printNote">Print-friendly styling included.</div>
    </div>
  </nav>

  <article>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>What this problem is about:</b> How small the <b>facet reflectance</b> must be (after AR coatings) so FP interference does <b>not</b> introduce &gt;10% ripple in an SOA’s gain/transmission versus frequency.</li>
        <li><b>Key physics idea:</b> Two weakly reflecting facets form a <b>Fabry–Perot etalon</b>. Its transmission oscillates with round-trip phase, even if the gain medium is otherwise smooth.</li>
        <li><b>Governing equation:</b> Symmetric FP intensity transmission
          <span class="pill">T(δ) = (1−R)² / (1 − 2R cosδ + R²)</span>, where <span class="pill">δ</span> is the round-trip phase.</li>
        <li><b>Ripple measure:</b> Peak-to-valley fractional ripple
          <span class="pill">m = (T<sub>max</sub> − T<sub>min</sub>)/T<sub>max</sub></span>.</li>
        <li><b>Key result:</b> For identical facets, <span class="pill">T<sub>max</sub>=1</span> and <span class="pill">T<sub>min</sub> = ((1−R)/(1+R))²</span>.</li>
        <li><b>Design constraint:</b> Require <span class="pill">m &lt; 0.10</span> ⇒ <span class="pill">T<sub>min</sub> &gt; 0.90</span>.</li>
        <li><b>Final numeric tolerance:</b> <b>R &lt; 2.63%</b> per facet (assuming ripple referenced to the peak transmission).</li>
      </ul>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="grid2">
        <div class="callout">
          <div class="tag"><span class="dot"></span>Core definitions</div>
          <ul>
            <li><b>Facet reflectance</b> <span class="pill">R</span> (unitless): fraction of <i>intensity</i> reflected at each SOA facet.</li>
            <li><b>Transmission</b> <span class="pill">T</span> (unitless): fraction of incident intensity transmitted through the two-facet structure.</li>
            <li><b>Round-trip phase</b> <span class="pill">δ</span> (radians): for cavity length <span class="pill">L</span> and refractive index <span class="pill">n</span>,
              <span class="pill">δ = 4π n L / λ</span> (normal incidence).</li>
            <li><b>Free spectral range</b> (FSR): resonance spacing in frequency,
              <span class="pill">Δν = c/(2nL)</span>. (This sets how fast ripple oscillates with frequency, not its amplitude.)</li>
          </ul>
        </div>

        <div class="callout">
          <div class="tag"><span class="dot"></span>Physical meaning</div>
          <p>
            A short semiconductor chip with partially reflecting facets acts like a <b>low-finesse interferometer</b>.
            Multiple internal reflections create constructive/destructive interference depending on <span class="pill">δ(ν)</span>.
            Even with perfect internal gain uniformity, the <b>outgoing power versus frequency</b> is modulated by the FP transmission.
          </p>
          <p>
            AR coatings aim to make <span class="pill">R</span> tiny so the device behaves like a traveling-wave amplifier
            rather than an unintended cavity (which would add ripple and even lase).
          </p>
        </div>
      </div>

      <h3>Key law/model: Fabry–Perot (Airy) transmission</h3>
      <p>
        For a symmetric, lossless FP with identical intensity reflectances <span class="pill">R</span> on both mirrors (facets),
        the intensity transmission as a function of round-trip phase <span class="pill">δ</span> is:
      </p>
      <div class="eq" data-copy="T(δ) = (1−R)^2 / (1 − 2R cos(δ) + R^2)">
        <button class="copy-btn" aria-label="Copy equation">Copy</button>
T(δ) = (1−R)^2 / (1 − 2R cos(δ) + R^2)
      </div>
      <p>
        This is the standard <b>Airy function</b>. It assumes: normal incidence, coherent multiple reflections,
        identical mirrors, and negligible absorption inside the cavity for the purpose of computing fringe contrast.
      </p>

      <div class="grid2">
        <div class="callout">
          <div class="tag"><span class="dot"></span>Common approximations (why useful)</div>
          <ul>
            <li><b>Low reflectance (AR-coated):</b> if <span class="pill">R ≪ 1</span>, ripple amplitude scales roughly like <span class="pill">~4R</span> (a quick mental check).</li>
            <li><b>Symmetric facets:</b> identical AR coatings ⇒ same <span class="pill">R</span> and simplest closed-form ripple bounds.</li>
            <li><b>Ripple amplitude vs ripple period:</b> <span class="pill">R</span> sets contrast; <span class="pill">n, L</span> set how rapidly it varies with frequency.</li>
          </ul>
        </div>

        <div class="callout warn">
          <div class="tag"><span class="dot"></span>What to watch for (pitfalls)</div>
          <ul>
            <li><b>Confusing “FSR” with “ripple size”:</b> <span class="pill">n</span> and <span class="pill">L</span> set spacing, not the peak-to-valley magnitude.</li>
            <li><b>Amplitude vs intensity:</b> reflectance <span class="pill">R</span> is an <i>intensity</i> ratio. Field reflection is <span class="pill">r=√R</span> (with phase).</li>
            <li><b>What “10% variation” means:</b> here we interpret it as <b>peak-to-valley relative to the peak</b>: <span class="pill">(Tmax−Tmin)/Tmax &lt; 0.10</span>.</li>
          </ul>
        </div>
      </div>

      <h3>Mini intuition examples</h3>
      <ul>
        <li>If <span class="pill">R = 0</span>, then <span class="pill">T(δ)=1</span> for all δ → perfectly ripple-free traveling-wave behavior.</li>
        <li>If <span class="pill">R</span> increases, interference becomes stronger: resonant peaks stay near 1, but troughs drop, creating larger ripple.</li>
      </ul>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (No solving yet)</h2>

      <h3>Restate the problem</h3>
      <p>
        We have a 1550-nm InGaAsP amplifier with refractive index <span class="pill">n = 3.5</span>,
        and identical AR coatings on input and output facets.
        Residual facet reflectance forms a Fabry–Perot cavity whose transmission varies with frequency.
        Find the <b>maximum allowable facet reflectance</b> <span class="pill">R</span> so the resulting gain/transmission ripple stays below <b>10%</b>.
      </p>

      <div class="grid2">
        <div class="callout">
          <div class="tag"><span class="dot"></span>Given</div>
          <ul>
            <li>Wavelength: <span class="pill">λ ≈ 1550 nm</span></li>
            <li>Index: <span class="pill">n = 3.5</span></li>
            <li>Identical facets with AR coatings ⇒ <span class="pill">R1 = R2 = R</span></li>
            <li>Ripple requirement: variations due to FP transmission &lt; <span class="pill">10%</span></li>
          </ul>
        </div>

        <div class="callout">
          <div class="tag"><span class="dot"></span>Unknowns / what to find</div>
          <ul>
            <li>Maximum tolerable <b>intensity reflectance</b> per facet: <span class="pill">R<sub>max</sub></span></li>
          </ul>
          <div class="tag" style="margin-top:10px;"><span class="dot"></span>Final result type</div>
          <p>Closed-form inequality + numeric value.</p>
        </div>
      </div>

      <h3>Relevant principles and why they apply</h3>
      <ul>
        <li><b>Fabry–Perot interference:</b> Two parallel partially reflecting facets create multiple internal reflections → Airy transmission.</li>
        <li><b>Frequency dependence:</b> The phase <span class="pill">δ</span> changes with frequency (or wavelength), so transmission oscillates.</li>
        <li><b>AR-coated SOA as low-finesse cavity:</b> Residual <span class="pill">R</span> is small, so the ripple constraint can be enforced by bounding FP fringe contrast.</li>
      </ul>
      <p>
        Other physics (carrier dynamics, gain saturation, amplified spontaneous emission) can matter for SOA operation,
        but the question explicitly targets variations “arising from the frequency dependence of the Fabry–Perot transmittance,”
        so the FP model is the right focus.
      </p>

      <div class="callout ok">
        <div class="tag"><span class="dot"></span>Assumptions (explicit)</div>
        <ul>
          <li>Normal incidence; facets parallel; coherent interference (etalon model).</li>
          <li>Identical facet reflectances: <span class="pill">R1=R2=R</span>.</li>
          <li>Use the <b>lossless symmetric Airy</b> transmission to bound ripple (a conservative, standard design check).</li>
          <li>Interpret “&lt;10% variation” as <span class="pill">(Tmax−Tmin)/Tmax &lt; 0.10</span> (peak-to-valley relative to peak).</li>
        </ul>
      </div>

      <h3>Possible approaches (compare 2–3)</h3>
      <ul>
        <li><b>Approach A: Use Airy max/min directly</b> (best): compute <span class="pill">Tmax</span> and <span class="pill">Tmin</span> as functions of <span class="pill">R</span>, then enforce ripple &lt; 10%. <i>Pros:</i> exact, short, clear. <i>Cons:</i> assumes symmetric lossless etalon for contrast.</li>
        <li><b>Approach B: Small-R approximation</b>: expand Airy formula for <span class="pill">R≪1</span>, get an approximate bound <span class="pill">R ≲ 0.025</span>. <i>Pros:</i> fast mental estimate. <i>Cons:</i> less precise near the threshold.</li>
        <li><b>Approach C: Convert to finesse parameter</b> <span class="pill">F = 4R/(1−R)²</span> and relate ripple to <span class="pill">1/(1+F)</span>. <i>Pros:</i> connects to cavity optics language. <i>Cons:</i> one extra step.</li>
      </ul>
      <p><b>We choose Approach A</b> because it gives a clean exact inequality for <span class="pill">R</span> with minimal algebra.</p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>
      <ol>
        <li><b>Goal:</b> express FP transmission as a function of phase. <br><b>Tool:</b> Airy formula <span class="pill">T(δ)</span>. <br><b>Meaning:</b> tells how much power exits the chip vs frequency.</li>
        <li><b>Goal:</b> find the maximum and minimum transmission over one phase period. <br><b>Tool:</b> evaluate at <span class="pill">δ=0</span> (constructive) and <span class="pill">δ=π</span> (destructive). <br><b>Meaning:</b> peak and valley of ripple.</li>
        <li><b>Goal:</b> define the ripple constraint mathematically. <br><b>Tool:</b> <span class="pill">m=(Tmax−Tmin)/Tmax</span>. <br><b>Meaning:</b> fractional gain/transmission variation.</li>
        <li><b>Goal:</b> impose <span class="pill">m&lt;0.10</span> and solve for <span class="pill">R</span>. <br><b>Tool:</b> simple algebra (square roots + inequality). <br><b>Meaning:</b> allowable AR-coating residual reflectance.</li>
        <li><b>Goal:</b> sanity-check for small <span class="pill">R</span>. <br><b>Tool:</b> low-R expansion or numeric comparison. <br><b>Meaning:</b> confirms order-of-magnitude design expectation.</li>
      </ol>

      <div class="callout warn">
        <div class="tag"><span class="dot"></span>Common mistakes & quick tips</div>
        <ul>
          <li><b>Tip:</b> Use intensity reflectance <span class="pill">R</span>, not field reflectivity.</li>
          <li><b>Mistake:</b> Using FSR to bound ripple magnitude—FSR only sets oscillation spacing.</li>
          <li><b>Tip:</b> If you forget the Airy formula, remember the max/min trick: at resonance <span class="pill">cosδ=1</span>, at antiresonance <span class="pill">cosδ=−1</span>.</li>
        </ul>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Qualitative expectation (before math)</h3>
      <p>
        With ideal AR coatings (<span class="pill">R→0</span>), the SOA behaves like a traveling-wave device and its gain profile is smooth.
        Residual reflections create an FP cavity: transmission oscillates between a peak and a valley.
        The smaller <span class="pill">R</span> is, the shallower the valley, so ripple shrinks.
        Therefore, a 10% ripple requirement should imply a few-percent (or lower) reflectance tolerance.
      </p>

      <h3>Step 1: Write the Fabry–Perot transmission for identical facets</h3>
      <p>
        Let <span class="pill">R</span> be the (intensity) reflectance of each facet.
        For a symmetric FP (two identical mirrors), the intensity transmission versus round-trip phase <span class="pill">δ</span> is:
      </p>
      <div class="eq" data-copy="T(δ) = (1−R)^2 / (1 − 2R cos(δ) + R^2)">
        <button class="copy-btn" aria-label="Copy equation">Copy</button>
T(δ) = (1−R)^2 / (1 − 2R cos(δ) + R^2)
      </div>
      <p>
        <b>What we did:</b> we adopted the standard Airy model for an etalon formed by the two facets.
        <b>Why:</b> the question asks specifically about variations from FP transmittance.
      </p>

      <h3>Step 2: Find the maximum transmission</h3>
      <p>
        The transmission is largest when interference is fully constructive, i.e. <span class="pill">δ = 2πm</span> so <span class="pill">cosδ = 1</span>.
        Substitute into the denominator:
      </p>
      <div class="eq" data-copy="Tmax = (1−R)^2 / (1 − 2R(1) + R^2) = (1−R)^2 / (1−R)^2 = 1">
        <button class="copy-btn" aria-label="Copy equation">Copy</button>
Tmax = (1−R)^2 / (1 − 2R(1) + R^2)
     = (1−R)^2 / (1−R)^2
     = 1
      </div>
      <p>
        <b>Interpretation:</b> in the ideal lossless symmetric FP, resonant transmission reaches unity—energy “builds up” and exits fully.
        In a real SOA there may be internal loss/gain, but for ripple <i>contrast</i> this max/min method is the standard bound.
      </p>

      <h3>Step 3: Find the minimum transmission</h3>
      <p>
        The minimum occurs at antiresonance: <span class="pill">δ = (2m+1)π</span> so <span class="pill">cosδ = −1</span>.
        Then the denominator becomes:
      </p>
      <div class="eq" data-copy="Tmin = (1−R)^2 / (1 − 2R(−1) + R^2) = (1−R)^2 / (1 + 2R + R^2) = ((1−R)/(1+R))^2">
        <button class="copy-btn" aria-label="Copy equation">Copy</button>
Tmin = (1−R)^2 / (1 − 2R(−1) + R^2)
     = (1−R)^2 / (1 + 2R + R^2)
     = (1−R)^2 / (1+R)^2
     = ((1−R)/(1+R))^2
      </div>
      <p>
        <b>What we did:</b> evaluated the Airy formula at the phase giving destructive interference.
        <b>Why:</b> ripple is set by the extremes over frequency/phase.
      </p>

      <h3>Step 4: Convert the “&lt;10% variation” requirement into an inequality</h3>
      <p>
        Define the peak-to-valley fractional ripple (relative to the peak):
      </p>
      <div class="eq" data-copy="m = (Tmax − Tmin)/Tmax">
        <button class="copy-btn" aria-label="Copy equation">Copy</button>
m = (Tmax − Tmin)/Tmax
      </div>
      <p>
        Since <span class="pill">Tmax = 1</span>, we have:
      </p>
      <div class="eq" data-copy="m = 1 − Tmin = 1 − ((1−R)/(1+R))^2">
        <button class="copy-btn" aria-label="Copy equation">Copy</button>
m = 1 − Tmin
  = 1 − ((1−R)/(1+R))^2
      </div>
      <p>
        The requirement “variations &lt; 10%” becomes <span class="pill">m &lt; 0.10</span>, i.e.
      </p>
      <div class="eq" data-copy="1 − ((1−R)/(1+R))^2 < 0.10  ⟺  ((1−R)/(1+R))^2 > 0.90">
        <button class="copy-btn" aria-label="Copy equation">Copy</button>
1 − ((1−R)/(1+R))^2 < 0.10
⟺ ((1−R)/(1+R))^2 > 0.90
      </div>

      <h3>Step 5: Solve for the maximum allowed reflectance</h3>
      <p>
        Take the positive square root (since <span class="pill">1−R</span> and <span class="pill">1+R</span> are positive for physical <span class="pill">0≤R&lt;1</span>):
      </p>
      <div class="eq" data-copy="(1−R)/(1+R) > √0.90">
        <button class="copy-btn" aria-label="Copy equation">Copy</button>
(1−R)/(1+R) > √0.90
      </div>
      <p>
        Let <span class="pill">s = √0.90</span>. Then:
      </p>
      <div class="eq" data-copy="1−R > s(1+R)  ⇒  1−s > R(1+s)  ⇒  R < (1−s)/(1+s)">
        <button class="copy-btn" aria-label="Copy equation">Copy</button>
1−R > s(1+R)
⇒ 1−R > s + sR
⇒ 1−s > R(1+s)
⇒ R < (1−s)/(1+s)
      </div>
      <p>
        Now compute numerically: <span class="pill">s = √0.90 ≈ 0.948683</span>, so
      </p>

      <div class="callout danger" style="margin-top:10px;">
        <div class="tag"><span class="dot"></span>Final answer (tolerance per facet)</div>
        <div class="eq" id="finalEq" data-copy="Rmax = (1−√0.90)/(1+√0.90) ≈ 0.0263  (≈ 2.63% per facet)">
          <button class="copy-btn" aria-label="Copy final answer">Copy</button>
Rmax = (1−√0.90)/(1+√0.90) ≈ 0.0263
≈ 2.63% per facet
        </div>
        <p>
          <b>Meaning:</b> to keep FP-induced gain/transmission ripple below 10% (peak-to-valley relative to peak),
          each facet’s residual reflectance should be no larger than about <b>2.6%</b>.
        </p>
      </div>

      <h3>Sanity checks</h3>
      <div class="grid2">
        <div class="callout">
          <div class="tag"><span class="dot"></span>Units / dimensions</div>
          <p>
            <span class="pill">R</span>, <span class="pill">T</span>, and <span class="pill">m</span> are dimensionless ratios. The inequality is dimensionally consistent.
          </p>
        </div>
        <div class="callout">
          <div class="tag"><span class="dot"></span>Limiting cases</div>
          <ul>
            <li><span class="pill">R→0</span> ⇒ <span class="pill">Tmin→1</span> ⇒ <span class="pill">m→0</span> (no ripple).</li>
            <li><span class="pill">R→1</span> ⇒ <span class="pill">Tmin→0</span> ⇒ <span class="pill">m→1</span> (maximal ripple).</li>
          </ul>
        </div>
      </div>
      <p>
        <b>Connection to the diagram and plots:</b> the two facets act as mirrors. The phase <span class="pill">δ</span> changes with frequency,
        so as you scan frequency you slide along the horizontal axis of the Airy plot, producing ripple in transmitted (and thus amplified) power.
      </p>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the final formula</h3>
      <p>
        The bound
        <span class="pill">R &lt; (1−√0.90)/(1+√0.90)</span>
        comes from insisting the <b>valley</b> of the Airy transmission stays above 0.90.
        The structure is typical of “contrast” constraints because <span class="pill">(1−R)/(1+R)</span> is the amplitude-like mismatch factor
        between constructive and destructive interference in a symmetric etalon.
      </p>

      <h3>How parameters affect the outcome</h3>
      <ul>
        <li><b>Reflectance R:</b> controls ripple depth (contrast). Small increases near a few percent noticeably deepen valleys.</li>
        <li><b>Index n and cavity length L:</b> control how fast ripple oscillates with frequency (FSR), but not the max/min values for a given R.</li>
        <li><b>Wavelength λ:</b> sets phase for a given L; again it changes the “x-position” on the Airy curve, not the contrast itself.</li>
      </ul>

      <h3>An alternative derivation idea (brief)</h3>
      <p>
        You can rewrite the Airy function using the coefficient
        <span class="pill">F = 4R/(1−R)²</span> and show
        <span class="pill">T(δ) = 1 / (1 + F sin²(δ/2))</span>.
        Then <span class="pill">Tmin = 1/(1+F)</span> (at <span class="pill">sin²(δ/2)=1</span>) and enforcing <span class="pill">Tmin&gt;0.90</span>
        yields the same <span class="pill">Rmax</span>.
      </p>

      <h3>Concept checks (self-test)</h3>
      <ul>
        <li><b>Q:</b> If you reduce <span class="pill">R</span> by 2× (in the small-R regime), what happens to ripple? <b>A:</b> It roughly halves (contrast scales approximately linearly with <span class="pill">R</span> when <span class="pill">R≪1</span>).</li>
        <li><b>Q:</b> Does changing <span class="pill">n</span> change the ripple amplitude? <b>A:</b> Not for this symmetric max/min contrast; it changes the oscillation period vs frequency.</li>
        <li><b>Q:</b> Why can ripple matter even if the SOA is “not a laser”? <b>A:</b> Any nonzero reflectance forms a cavity; it can modulate transmission and, at higher R/gain, even reach lasing threshold.</li>
      </ul>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="controls" role="group" aria-label="Interactive controls">
        <div class="control">
          <label for="rSlider">
            Facet reflectance <span class="pill">R</span> (intensity)
            <span><span id="rVal" class="pill">0.026</span></span>
          </label>
          <input id="rSlider" type="range" min="0" max="0.10" step="0.0005" value="0.0263" />
          <div style="color:var(--muted); font-size:12px;">
            Slide to see how FP transmission ripple deepens. Threshold line at <span class="pill">m = 10%</span>.
          </div>
        </div>

        <div class="readouts" aria-label="Computed readouts">
          <div class="metric">
            <div class="k">Ripple (peak-to-valley / peak)</div>
            <div class="v"><span id="mVal">0.100</span> <span class="pill" id="mFlag">at limit</span></div>
          </div>
          <div class="metric">
            <div class="k">Minimum transmission</div>
            <div class="v"><span id="tminVal">0.900</span></div>
          </div>
          <div class="metric">
            <div class="k">Allowed max (for 10%)</div>
            <div class="v"><span id="rMaxVal">0.0263</span> <span class="pill">≈ 2.63%</span></div>
          </div>
        </div>
      </div>

      <div class="vizWrap">
        <figure>
          <canvas id="diagramCanvas" aria-label="SOA geometry diagram"></canvas>
          <figcaption>
            <b>Diagram:</b> A simple SOA chip acts like a weak FP cavity: photons propagate along the chip length
            while carriers are injected across the p–n junction. Residual facet reflectance <span class="pill">R</span> causes internal multiple reflections.
          </figcaption>
        </figure>

        <figure>
          <canvas id="airyCanvas" aria-label="Fabry–Perot transmission vs phase"></canvas>
          <figcaption>
            <b>Main plot:</b> Airy transmission <span class="pill">T(δ)</span> versus round-trip phase <span class="pill">δ</span> (radians).
            Peaks at <span class="pill">δ=2πm</span>, valleys at <span class="pill">δ=(2m+1)π</span>. The valley level sets ripple.
          </figcaption>
        </figure>

        <figure>
          <canvas id="sweepCanvas" aria-label="Ripple versus reflectance parameter sweep"></canvas>
          <figcaption>
            <b>Secondary plot (parameter sweep):</b> Ripple <span class="pill">m(R) = 1 - ((1−R)/(1+R))²</span> across reflectance values.
            The current slider choice is marked, and the <span class="pill">10%</span> requirement is drawn as a horizontal threshold.
          </figcaption>
        </figure>

        <figure>
          <canvas id="tminCanvas" aria-label="Minimum transmission versus reflectance"></canvas>
          <figcaption>
            <b>Secondary plot (alternate view):</b> Minimum transmission <span class="pill">Tmin(R)=((1−R)/(1+R))²</span>.
            The design rule “<span class="pill">Tmin&gt;0.90</span>” is equivalent to “ripple &lt; 10%”.
          </figcaption>
        </figure>
      </div>

      <p>
        <b>Controls:</b> The slider changes <span class="pill">R</span>. All plots update live:
        the Airy curve’s valley deepens, the ripple marker moves on the sweep plot, and the minimum-transmission curve highlights the same constraint.
      </p>
    </section>
  </article>
</main>

<footer>
  <div>
    Built as a self-contained learning article (vanilla HTML/CSS/JS). Equation copy buttons copy plain text.
  </div>
</footer>

<script>
(function(){
  // ---------- Utilities ----------
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function fmt(x, digits=4){
    if (!isFinite(x)) return "—";
    const ax = Math.abs(x);
    if (ax >= 1) return x.toFixed(digits);
    if (ax >= 0.1) return x.toFixed(digits);
    if (ax >= 0.01) return x.toFixed(digits+1);
    return x.toFixed(digits+2);
  }

  function setupCanvas(canvas){
    const ctx = canvas.getContext('2d');
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.max(2, Math.floor(rect.width * dpr));
      canvas.height = Math.max(2, Math.floor(rect.height * dpr));
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {w: rect.width, h: rect.height, dpr};
    }
    return {ctx, resize};
  }

  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, opts){
    const {
      title="",
      xLabel="",
      yLabel="",
      grid=true,
      ticks=5,
      font="12px system-ui",
      mono="12px ui-monospace",
      colorText="rgba(233,238,246,.92)",
      colorMuted="rgba(169,180,196,.85)",
      colorGrid="rgba(255,255,255,.08)",
      colorAxis="rgba(255,255,255,.18)"
    } = (opts||{});

    const {x,y,w,h} = box;

    ctx.save();
    ctx.clearRect(x,y,w,h);

    // Background is canvas-level; keep transparent here.
    // Title
    ctx.fillStyle = colorText;
    ctx.font = "700 13px system-ui";
    ctx.fillText(title, x + 10, y + 18);

    // Plot area
    const padL = 54, padR = 16, padT = 30, padB = 44;
    const px = x + padL, py = y + padT, pw = w - padL - padR, ph = h - padT - padB;

    // Grid + ticks
    ctx.strokeStyle = colorGrid;
    ctx.lineWidth = 1;

    function xTo(u){ return px + (u - xMin) * pw / (xMax - xMin); }
    function yTo(v){ return py + ph - (v - yMin) * ph / (yMax - yMin); }

    if (grid){
      for (let i=0;i<=ticks;i++){
        const t = i/ticks;
        const gx = px + t*pw;
        const gy = py + t*ph;
        ctx.beginPath(); ctx.moveTo(gx, py); ctx.lineTo(gx, py+ph); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(px, gy); ctx.lineTo(px+pw, gy); ctx.stroke();
      }
    }

    // Axes
    ctx.strokeStyle = colorAxis;
    ctx.lineWidth = 1.2;
    ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px, py+ph); ctx.lineTo(px+pw, py+ph); ctx.stroke();

    // Tick labels
    ctx.fillStyle = colorMuted;
    ctx.font = mono;

    for (let i=0;i<=ticks;i++){
      const t = i/ticks;
      const xv = xMin + t*(xMax-xMin);
      const yv = yMin + (1-t)*(yMax-yMin);

      const gx = px + t*pw;
      const gy = py + t*ph;

      // x ticks
      ctx.beginPath();
      ctx.strokeStyle = colorAxis;
      ctx.moveTo(gx, py+ph); ctx.lineTo(gx, py+ph+5); ctx.stroke();
      const xt = (Math.abs(xv) >= 1000) ? xv.toFixed(0) : (Math.abs(xv)>=10? xv.toFixed(1) : xv.toFixed(2));
      ctx.fillText(xt, gx - 12, py+ph+18);

      // y ticks
      ctx.beginPath();
      ctx.moveTo(px-5, gy); ctx.lineTo(px, gy); ctx.stroke();
      const yt = (Math.abs(yv) >= 1000) ? yv.toFixed(0) : (Math.abs(yv)>=10? yv.toFixed(1) : yv.toFixed(2));
      ctx.fillText(yt, px-46, gy+4);
    }

    // Labels
    ctx.fillStyle = colorText;
    ctx.font = font;
    ctx.fillText(xLabel, px + pw/2 - ctx.measureText(xLabel).width/2, y + h - 12);

    // yLabel rotated
    ctx.save();
    ctx.translate(x + 14, py + ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
    ctx.restore();

    ctx.restore();

    return {px,py,pw,ph,xTo,yTo};
  }

  function polyline(ctx, pts, strokeStyle, lineWidth){
    ctx.save();
    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = lineWidth || 2;
    ctx.beginPath();
    for (let i=0;i<pts.length;i++){
      const p = pts[i];
      if (i===0) ctx.moveTo(p[0], p[1]);
      else ctx.lineTo(p[0], p[1]);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawLegend(ctx, box, items){
    // items: [{label, color}]
    const {x,y,w,h} = box;
    ctx.save();
    const pad = 10;
    let lx = x + pad, ly = y + pad + 22;
    ctx.font = "12px system-ui";
    items.forEach((it, idx)=>{
      const yy = ly + idx*18;
      ctx.strokeStyle = it.color;
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(lx, yy); ctx.lineTo(lx+18, yy); ctx.stroke();
      ctx.fillStyle = "rgba(233,238,246,.9)";
      ctx.fillText(it.label, lx+24, yy+4);
    });
    ctx.restore();
  }

  // ---------- Physics functions ----------
  function airyT(delta, R){
    // T(δ) = (1−R)^2 / (1 − 2R cosδ + R^2)
    const num = (1-R)*(1-R);
    const den = 1 - 2*R*Math.cos(delta) + R*R;
    return num/den;
  }
  function Tmin(R){
    // ((1−R)/(1+R))^2
    return ((1-R)/(1+R))*((1-R)/(1+R));
  }
  function ripple(R){
    // m = 1 - Tmin (since Tmax = 1)
    return 1 - Tmin(R);
  }
  const s = Math.sqrt(0.90);
  const Rmax = (1 - s)/(1 + s);

  // ---------- Copy buttons ----------
  function wireCopy(){
    document.querySelectorAll('.eq').forEach(block=>{
      const btn = block.querySelector('.copy-btn');
      if(!btn) return;
      btn.addEventListener('click', async ()=>{
        const txt = block.getAttribute('data-copy') || block.innerText.replace("Copy","").trim();
        try{
          await navigator.clipboard.writeText(txt);
          const old = btn.textContent;
          btn.textContent = "Copied!";
          setTimeout(()=>btn.textContent = old, 900);
        }catch(e){
          const old = btn.textContent;
          btn.textContent = "Copy failed";
          setTimeout(()=>btn.textContent = old, 900);
        }
      });
    });
  }

  // ---------- Diagram ----------
  const diagram = setupCanvas(document.getElementById('diagramCanvas'));
  function drawDiagram(){
    const {ctx, resize} = diagram;
    const {w,h} = resize();
    ctx.clearRect(0,0,w,h);

    const pad = 16;
    const cx = pad, cy = pad, cw = w - 2*pad, ch = h - 2*pad;

    // Title
    ctx.fillStyle = "rgba(233,238,246,.92)";
    ctx.font = "700 13px system-ui";
    ctx.fillText("SOA as a weak Fabry–Perot cavity (two facets)", cx+6, cy+14);

    // Chip block
    const bx = cx + 40, by = cy + 40, bw = cw - 80, bh = ch - 70;
    const depth = 26;

    // Back face
    ctx.fillStyle = "rgba(102,217,255,.06)";
    ctx.strokeStyle = "rgba(255,255,255,.16)";
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.rect(bx+depth, by-depth, bw, bh);
    ctx.fill(); ctx.stroke();

    // Front face
    ctx.fillStyle = "rgba(167,255,131,.07)";
    ctx.beginPath();
    ctx.rect(bx, by, bw, bh);
    ctx.fill(); ctx.stroke();

    // Connect edges for pseudo-3D
    ctx.strokeStyle = "rgba(255,255,255,.14)";
    ctx.beginPath();
    ctx.moveTo(bx, by);
    ctx.lineTo(bx+depth, by-depth);
    ctx.moveTo(bx+bw, by);
    ctx.lineTo(bx+bw+depth, by-depth);
    ctx.moveTo(bx, by+bh);
    ctx.lineTo(bx+depth, by+bh-depth);
    ctx.moveTo(bx+bw, by+bh);
    ctx.lineTo(bx+bw+depth, by+bh-depth);
    ctx.stroke();

    // Facet labels
    ctx.font = "12px system-ui";
    ctx.fillStyle = "rgba(233,238,246,.9)";
    ctx.fillText("Input facet (AR)", bx-6, by-10);
    ctx.fillText("Output facet (AR)", bx+bw-94, by-10);

    // Reflectance markers
    function facetMarker(x0,y0,dir){
      ctx.save();
      ctx.strokeStyle = "rgba(255,209,102,.85)";
      ctx.fillStyle = "rgba(255,209,102,.85)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x0 + dir*28, y0);
      ctx.stroke();
      // arrow head
      ctx.beginPath();
      ctx.moveTo(x0 + dir*28, y0);
      ctx.lineTo(x0 + dir*20, y0-5);
      ctx.lineTo(x0 + dir*20, y0+5);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
    facetMarker(bx, by+bh/2, -1);
    facetMarker(bx+bw, by+bh/2, +1);

    // Photon propagation arrow
    ctx.save();
    ctx.strokeStyle = "rgba(102,217,255,.9)";
    ctx.fillStyle = "rgba(102,217,255,.9)";
    ctx.lineWidth = 3;
    const ax0 = bx + 20, ay0 = by + bh/2;
    const ax1 = bx + bw - 20, ay1 = ay0;
    ctx.beginPath(); ctx.moveTo(ax0, ay0); ctx.lineTo(ax1, ay1); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(ax1, ay1);
    ctx.lineTo(ax1-12, ay1-7);
    ctx.lineTo(ax1-12, ay1+7);
    ctx.closePath(); ctx.fill();
    ctx.font = "12px system-ui";
    ctx.fillStyle = "rgba(233,238,246,.9)";
    ctx.fillText("Photon propagation", bx + bw/2 - 56, ay0 - 12);
    ctx.restore();

    // Carrier injection arrow (vertical)
    ctx.save();
    ctx.strokeStyle = "rgba(167,255,131,.9)";
    ctx.fillStyle = "rgba(167,255,131,.9)";
    ctx.lineWidth = 3;
    const vx = bx + bw/2, vy0 = by + bh - 10, vy1 = by + 10;
    ctx.beginPath(); ctx.moveTo(vx, vy0); ctx.lineTo(vx, vy1); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(vx, vy1);
    ctx.lineTo(vx-7, vy1+12);
    ctx.lineTo(vx+7, vy1+12);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle = "rgba(233,238,246,.9)";
    ctx.font = "12px system-ui";
    ctx.fillText("Carrier injection (current)", vx - 74, by + 20);
    ctx.restore();

    // Key annotation
    ctx.save();
    ctx.font = "12px ui-monospace";
    ctx.fillStyle = "rgba(233,238,246,.88)";
    ctx.fillText("Residual facet reflectance: R", bx + 8, by + bh + 18);
    ctx.fillText("Round-trip phase: δ = 4π n L / λ", bx + 8, by + bh + 36);
    ctx.restore();
  }

  // ---------- Plots ----------
  const airyPlot = setupCanvas(document.getElementById('airyCanvas'));
  const sweepPlot = setupCanvas(document.getElementById('sweepCanvas'));
  const tminPlot  = setupCanvas(document.getElementById('tminCanvas'));

  function drawAiry(R){
    const {ctx, resize} = airyPlot;
    const {w,h} = resize();

    const box = {x:0,y:0,w:w,h:h};
    const xMin = 0, xMax = 2*Math.PI;
    const yMin = 0, yMax = 1.05;

    const ax = drawAxes(ctx, box, xMin, xMax, yMin, yMax, {
      title: "Fabry–Perot transmission T(δ) for identical facets",
      xLabel: "Round-trip phase δ (rad)",
      yLabel: "Transmission T (unitless)",
      ticks: 5
    });

    // Curve
    const pts = [];
    const N = 900;
    for (let i=0;i<=N;i++){
      const d = xMin + (xMax-xMin)*i/N;
      const T = airyT(d,R);
      pts.push([ax.xTo(d), ax.yTo(T)]);
    }
    polyline(ctx, pts, "rgba(102,217,255,.92)", 2.2);

    // Mark max/min
    const tmin = Tmin(R);
    const pMax = [ax.xTo(0), ax.yTo(1)];
    const pMin = [ax.xTo(Math.PI), ax.yTo(tmin)];

    ctx.save();
    ctx.fillStyle = "rgba(167,255,131,.95)";
    ctx.strokeStyle = "rgba(0,0,0,.25)";
    ctx.lineWidth = 2;
    function dot(p){
      ctx.beginPath(); ctx.arc(p[0], p[1], 4.6, 0, Math.PI*2); ctx.fill();
    }
    dot(pMax);

    ctx.fillStyle = "rgba(255,209,102,.95)";
    dot(pMin);

    // Labels
    ctx.font = "12px ui-monospace";
    ctx.fillStyle = "rgba(233,238,246,.92)";
    ctx.fillText("Tmax=1", pMax[0]+8, pMax[1]-10);
    ctx.fillText("Tmin="+fmt(tmin,3), pMin[0]+8, pMin[1]-10);
    ctx.restore();

    drawLegend(ctx, box, [
      {label:"T(δ)", color:"rgba(102,217,255,.92)"},
      {label:"Tmax", color:"rgba(167,255,131,.95)"},
      {label:"Tmin", color:"rgba(255,209,102,.95)"}
    ]);
  }

  function drawSweep(R){
    const {ctx, resize} = sweepPlot;
    const {w,h} = resize();
    const box = {x:0,y:0,w:w,h:h};

    const xMin = 0, xMax = 0.10;
    const yMin = 0, yMax = 0.22;

    const ax = drawAxes(ctx, box, xMin, xMax, yMin, yMax, {
      title: "Ripple m(R) = (Tmax−Tmin)/Tmax (peak-to-valley / peak)",
      xLabel: "Facet reflectance R (intensity)",
      yLabel: "Ripple m (unitless)",
      ticks: 5
    });

    // Curve m(R)
    const pts = [];
    const N = 600;
    for (let i=0;i<=N;i++){
      const r = xMin + (xMax-xMin)*i/N;
      pts.push([ax.xTo(r), ax.yTo(ripple(r))]);
    }
    polyline(ctx, pts, "rgba(167,255,131,.92)", 2.2);

    // Threshold line at 0.10
    ctx.save();
    ctx.strokeStyle = "rgba(255,107,107,.75)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(ax.xTo(xMin), ax.yTo(0.10));
    ctx.lineTo(ax.xTo(xMax), ax.yTo(0.10));
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.font = "12px ui-monospace";
    ctx.fillStyle = "rgba(255,107,107,.9)";
    ctx.fillText("limit m = 0.10", ax.xTo(0.055), ax.yTo(0.10)-8);
    ctx.restore();

    // Marker at current R
    const m = ripple(R);
    ctx.save();
    ctx.fillStyle = "rgba(102,217,255,.95)";
    ctx.beginPath();
    ctx.arc(ax.xTo(R), ax.yTo(m), 5, 0, Math.PI*2);
    ctx.fill();
    ctx.font = "12px ui-monospace";
    ctx.fillStyle = "rgba(233,238,246,.92)";
    ctx.fillText("R="+fmt(R,4)+"  m="+fmt(m,4), ax.xTo(R)+10, ax.yTo(m)-10);
    ctx.restore();

    // Mark Rmax
    ctx.save();
    ctx.strokeStyle = "rgba(255,209,102,.75)";
    ctx.lineWidth = 2;
    ctx.setLineDash([5,5]);
    ctx.beginPath();
    ctx.moveTo(ax.xTo(Rmax), ax.yTo(yMin));
    ctx.lineTo(ax.xTo(Rmax), ax.yTo(yMax));
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.font = "12px ui-monospace";
    ctx.fillStyle = "rgba(255,209,102,.92)";
    ctx.fillText("Rmax≈"+fmt(Rmax,4), ax.xTo(Rmax)+6, ax.yTo(0.205));
    ctx.restore();

    drawLegend(ctx, box, [
      {label:"m(R)", color:"rgba(167,255,131,.92)"},
      {label:"10% limit", color:"rgba(255,107,107,.75)"},
      {label:"current R", color:"rgba(102,217,255,.95)"}
    ]);
  }

  function drawTmin(R){
    const {ctx, resize} = tminPlot;
    const {w,h} = resize();
    const box = {x:0,y:0,w:w,h:h};

    const xMin = 0, xMax = 0.10;
    const yMin = 0.75, yMax = 1.01;

    const ax = drawAxes(ctx, box, xMin, xMax, yMin, yMax, {
      title: "Minimum transmission Tmin(R) = ((1−R)/(1+R))^2",
      xLabel: "Facet reflectance R (intensity)",
      yLabel: "Tmin (unitless)",
      ticks: 5
    });

    // Curve Tmin(R)
    const pts = [];
    const N = 600;
    for (let i=0;i<=N;i++){
      const r = xMin + (xMax-xMin)*i/N;
      pts.push([ax.xTo(r), ax.yTo(Tmin(r))]);
    }
    polyline(ctx, pts, "rgba(102,217,255,.92)", 2.2);

    // Requirement Tmin > 0.90
    ctx.save();
    ctx.strokeStyle = "rgba(255,107,107,.75)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(ax.xTo(xMin), ax.yTo(0.90));
    ctx.lineTo(ax.xTo(xMax), ax.yTo(0.90));
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.font = "12px ui-monospace";
    ctx.fillStyle = "rgba(255,107,107,.9)";
    ctx.fillText("require Tmin = 0.90", ax.xTo(0.048), ax.yTo(0.90)-8);
    ctx.restore();

    // Marker at current
    const tmin = Tmin(R);
    ctx.save();
    ctx.fillStyle = "rgba(167,255,131,.95)";
    ctx.beginPath(); ctx.arc(ax.xTo(R), ax.yTo(tmin), 5, 0, Math.PI*2); ctx.fill();
    ctx.font = "12px ui-monospace";
    ctx.fillStyle = "rgba(233,238,246,.92)";
    ctx.fillText("R="+fmt(R,4)+"  Tmin="+fmt(tmin,4), ax.xTo(R)+10, ax.yTo(tmin)-10);
    ctx.restore();

    // Rmax line
    ctx.save();
    ctx.strokeStyle = "rgba(255,209,102,.75)";
    ctx.lineWidth = 2;
    ctx.setLineDash([5,5]);
    ctx.beginPath();
    ctx.moveTo(ax.xTo(Rmax), ax.yTo(yMin));
    ctx.lineTo(ax.xTo(Rmax), ax.yTo(yMax));
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.font = "12px ui-monospace";
    ctx.fillStyle = "rgba(255,209,102,.92)";
    ctx.fillText("Rmax≈"+fmt(Rmax,4), ax.xTo(Rmax)+6, ax.yTo(0.995));
    ctx.restore();

    drawLegend(ctx, box, [
      {label:"Tmin(R)", color:"rgba(102,217,255,.92)"},
      {label:"0.90 threshold", color:"rgba(255,107,107,.75)"},
      {label:"current R", color:"rgba(167,255,131,.95)"}
    ]);
  }

  // ---------- UI wiring ----------
  const rSlider = document.getElementById('rSlider');
  const rVal = document.getElementById('rVal');
  const mVal = document.getElementById('mVal');
  const tminVal = document.getElementById('tminVal');
  const rMaxVal = document.getElementById('rMaxVal');
  const mFlag = document.getElementById('mFlag');

  function update(){
    const R = parseFloat(rSlider.value);
    const m = ripple(R);
    const tmin = Tmin(R);

    rVal.textContent = fmt(R,4);
    mVal.textContent = fmt(m,4);
    tminVal.textContent = fmt(tmin,4);
    rMaxVal.textContent = fmt(Rmax,4);

    // Status pill
    const eps = 1e-4;
    if (m < 0.10 - eps){
      mFlag.textContent = "OK";
      mFlag.style.borderColor = "rgba(61,220,151,.45)";
      mFlag.style.background = "rgba(61,220,151,.12)";
    } else if (Math.abs(m-0.10) <= eps){
      mFlag.textContent = "at limit";
      mFlag.style.borderColor = "rgba(255,209,102,.55)";
      mFlag.style.background = "rgba(255,209,102,.12)";
    } else {
      mFlag.textContent = "too high";
      mFlag.style.borderColor = "rgba(255,107,107,.55)";
      mFlag.style.background = "rgba(255,107,107,.12)";
    }

    drawDiagram();
    drawAiry(R);
    drawSweep(R);
    drawTmin(R);
  }

  rSlider.addEventListener('input', update);
  window.addEventListener('resize', update);

  // Smooth TOC scrolling
  document.querySelectorAll('nav a[href^="#"]').forEach(a=>{
    a.addEventListener('click', (e)=>{
      const id = a.getAttribute('href');
      const el = document.querySelector(id);
      if(el){
        e.preventDefault();
        el.scrollIntoView({behavior:"smooth", block:"start"});
        history.replaceState(null, "", id);
      }
    });
  });

  wireCopy();
  update();
})();
</script>
</body>
</html>
