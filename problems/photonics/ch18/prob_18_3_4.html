<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Modal Spacings with a Wavelength-Dependent Refractive Index (Laser Diode)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --panel2:#0c1329;
      --text:#e9eefc;
      --muted:#b9c4e6;
      --faint:#7f8ab3;
      --accent:#7aa7ff;
      --accent2:#7dffcf;
      --warn:#ffcf5a;
      --danger:#ff6b7a;
      --ok:#7dff7a;
      --border:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 800px at 30% 15%, rgba(122,167,255,.18), transparent 60%),
                  radial-gradient(900px 700px at 85% 35%, rgba(125,255,207,.10), transparent 55%),
                  linear-gradient(180deg, var(--bg), #070a14 70%);
      color:var(--text);
      line-height:1.55;
    }

    header{
      padding: 28px 18px 10px;
      border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.06), transparent);
    }
    .wrap{
      max-width:1180px;
      margin:0 auto;
      padding: 0 14px 40px;
    }
    .title{
      display:flex;
      flex-wrap:wrap;
      gap:14px 18px;
      align-items:flex-end;
      justify-content:space-between;
    }
    h1{
      margin:0;
      font-weight:800;
      letter-spacing:.2px;
      font-size: clamp(1.55rem, 2.4vw, 2.25rem);
    }
    .subtitle{
      margin:8px 0 0;
      color:var(--muted);
      max-width:70ch;
      font-size: 1.02rem;
    }

    main{
      padding: 18px 0 0;
    }

    .layout{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 16px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns: 1fr}
    }

    aside{
      position: sticky;
      top: 12px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius: 16px;
      padding: 14px 14px 10px;
      box-shadow: var(--shadow);
    }
    @media (max-width: 980px){
      aside{position:relative; top:auto}
    }

    .toc-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin: 0 0 10px;
    }
    .toc-title h2{
      margin:0;
      font-size: 1.05rem;
      letter-spacing:.2px;
    }
    .toc small{
      color:var(--faint);
    }
    .toc a{
      display:block;
      padding: 8px 10px;
      margin: 6px 0;
      border-radius: 12px;
      color:var(--muted);
      text-decoration:none;
      border:1px solid rgba(255,255,255,.07);
      background: rgba(10,16,35,.35);
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .toc a:hover{
      transform: translateY(-1px);
      background: rgba(122,167,255,.10);
      border-color: rgba(122,167,255,.22);
      color: var(--text);
    }

    section, article{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius: 18px;
      padding: 16px 16px 14px;
      box-shadow: var(--shadow);
    }

    section + section, article + article{margin-top: 14px;}
    h2{
      margin: 0 0 10px;
      font-size: 1.35rem;
    }
    h3{
      margin: 14px 0 8px;
      font-size: 1.08rem;
      color: var(--text);
    }
    p{margin: 10px 0; color: var(--muted);}
    ul{margin: 10px 0 10px 22px; color: var(--muted);}
    li{margin: 6px 0;}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 860px){ .grid2{grid-template-columns:1fr} }

    .card{
      background: rgba(10,16,35,.42);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 16px;
      padding: 12px 12px 10px;
    }
    .callout{
      border-left: 4px solid var(--accent);
      padding-left: 12px;
      background: rgba(122,167,255,.08);
    }
    .warn{
      border-left-color: var(--warn);
      background: rgba(255,207,90,.08);
    }
    .mistake{
      border-left-color: var(--danger);
      background: rgba(255,107,122,.08);
    }
    .ok{
      border-left-color: var(--accent2);
      background: rgba(125,255,207,.08);
    }

    .eq{
      font-family: var(--mono);
      color: #f0f4ff;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.08);
      padding: 2px 6px;
      border-radius: 10px;
      display:inline-block;
      white-space: nowrap;
    }
    .eqblock{
      margin: 10px 0;
      padding: 10px 10px;
      border-radius: 14px;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      overflow:auto;
      position:relative;
    }
    .eqblock pre{
      margin:0;
      color:#f0f4ff;
      font-family: var(--mono);
      font-size: .98rem;
      line-height: 1.45;
      white-space: pre;
    }

    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:10px 12px;
      align-items:center;
      margin-top: 10px;
    }
    .controls label{
      display:flex;
      gap:10px;
      align-items:center;
      color: var(--muted);
      font-size: .95rem;
    }
    input[type="range"]{width: 260px; max-width: 70vw;}
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(10,16,35,.45);
      color: var(--text);
      font-size: .92rem;
    }
    .btn{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(122,167,255,.12);
      color: var(--text);
      padding: 7px 10px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease;
      font-weight: 650;
    }
    .btn:hover{ transform: translateY(-1px); background: rgba(122,167,255,.18);}
    .btn:active{ transform: translateY(0px);}

    .copy-btn{
      position:absolute;
      top: 8px;
      right: 8px;
      padding: 6px 9px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      color: var(--text);
      cursor:pointer;
      font-size:.88rem;
    }
    .copy-btn:hover{ background: rgba(122,167,255,.16);}

    figure{margin: 0;}
    figcaption{
      margin-top: 8px;
      color: var(--faint);
      font-size: .92rem;
    }

    canvas{
      width: 100%;
      height: 320px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.01));
      display:block;
    }
    .canvasTall{height: 360px;}
    .canvasShort{height: 280px;}

    footer{
      margin-top: 16px;
      color: var(--faint);
      font-size: .92rem;
      padding: 12px 2px 0;
    }

    /* subtle entrance */
    @keyframes rise {
      from {opacity:0; transform: translateY(8px)}
      to {opacity:1; transform: translateY(0)}
    }
    section, article, aside{ animation: rise .22s ease-out both; }

    /* print-friendly */
    @media print{
      body{background:#fff; color:#000;}
      header, aside{display:none;}
      section, article{box-shadow:none; border:1px solid #ddd; background:#fff;}
      .eq, .eqblock{background:#f6f6f6; border:1px solid #ddd; color:#000;}
      p, ul{color:#000;}
      canvas{border:1px solid #bbb;}
      .copy-btn, .btn{display:none;}
    }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="title">
      <div>
        <h1>Modal Spacings with a Wavelength-Dependent Refractive Index</h1>
        <p class="subtitle">
          A laser diode is a Fabry–Pérot cavity, but its refractive index depends on wavelength. That dispersion changes the
          mode spacing: the cavity is governed by the <em>group index</em>, not just the phase index.
        </p>
      </div>
      <div class="pill" id="givenPill" title="Problem data used throughout">
        <span>Given:</span>
        <span class="eq">d = 430 μm</span>
        <span class="eq">λ<sub>c</sub> = 650 nm</span>
        <span class="eq">n(λ<sub>c</sub>) = 3.4</span>
        <span class="eq">Δλ ≈ 0.12 nm</span>
      </div>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="layout">
    <aside class="toc" aria-label="Table of contents">
      <div class="toc-title">
        <h2>Table of Contents</h2>
        <small>sticky</small>
      </div>
      <a href="#quick">Quick Summary</a>
      <a href="#part0">PART 0 — Concept Primer</a>
      <a href="#part1">PART 1 — Problem Analysis</a>
      <a href="#part2">PART 2 — Strategy & Tips</a>
      <a href="#part3">PART 3 — Full Solution</a>
      <a href="#part4">PART 4 — Deeper Understanding</a>
      <a href="#part5">PART 5 — Visualization Guide</a>
    </aside>

    <div>
      <section id="quick">
        <h2>Quick Summary</h2>
        <ul>
          <li><strong>What this is:</strong> Find the longitudinal mode spacing of a laser diode when the refractive index is dispersive: <span class="eq">n(λ) = n<sub>0</sub> − a(λ − λ<sub>c</sub>)</span>.</li>
          <li><strong>Key physics idea:</strong> Mode spacing is governed by the <em>group index</em> <span class="eq">n<sub>g</sub> = n − λ(dn/dλ)</span>, not just <span class="eq">n</span>.</li>
          <li><strong>Governing resonance condition:</strong> Fabry–Pérot longitudinal modes satisfy <span class="eq">mλ = 2n(λ)d</span>.</li>
          <li><strong>Frequency spacing (general):</strong> <span class="eq">Δν ≈ c / (2 d n<sub>g</sub>)</span> (dispersion enters through <span class="eq">n<sub>g</sub></span>).</li>
          <li><strong>Wavelength spacing near λ:</strong> <span class="eq">Δλ ≈ λ² / (2 d n<sub>g</sub>)</span> (small-spacing approximation).</li>
          <li><strong>Why the “usual” spacing fails:</strong> The common formula <span class="eq">Δν = c/(2nd)</span> assumes <span class="eq">n</span> is constant (no dispersion), i.e. <span class="eq">n<sub>g</sub> = n</span>.</li>
          <li><strong>Estimated dispersion slope:</strong> From the observed <span class="eq">Δλ ≈ 0.12 nm</span>, we get <span class="eq">n<sub>g</sub> ≈ 4.09</span> and <span class="eq">a ≈ 1.07×10⁶ m⁻¹ ≈ 1.07×10⁻³ nm⁻¹</span>.</li>
        </ul>
      </section>

      <article id="part0">
        <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

        <div class="grid2">
          <div class="card callout">
            <h3>Core definitions (symbols & units)</h3>
            <ul>
              <li><span class="eq">d</span>: cavity length (m)</li>
              <li><span class="eq">λ</span>: vacuum wavelength (m), <span class="eq">ν = c/λ</span> frequency (Hz)</li>
              <li><span class="eq">n(λ)</span>: phase refractive index (dimensionless)</li>
              <li><span class="eq">dn/dλ</span>: dispersion slope (m⁻¹)</li>
              <li><span class="eq">n<sub>g</sub></span>: group index, <span class="eq">n<sub>g</sub> = n − λ(dn/dλ)</span> (dimensionless)</li>
              <li><span class="eq">FSR</span>: free spectral range, mode spacing in frequency <span class="eq">Δν</span> (Hz) or wavelength <span class="eq">Δλ</span> (m)</li>
            </ul>
          </div>

          <div class="card ok">
            <h3>Physical meaning</h3>
            <ul>
              <li><strong>Phase index</strong> <span class="eq">n</span>: sets the phase accumulated per unit length for a monochromatic wave.</li>
              <li><strong>Group index</strong> <span class="eq">n<sub>g</sub></span>: sets how the <em>round-trip phase changes with frequency</em>; equivalently, it controls the round-trip <em>group delay</em> (<span class="eq">τ<sub>rt</sub> = 2dn<sub>g</sub>/c</span>).</li>
              <li>Mode spacing is basically “one extra round-trip phase of <span class="eq">2π</span> per mode,” so it depends on how phase changes with frequency → dispersion matters.</li>
            </ul>
          </div>
        </div>

        <h3>Key laws/principles & validity</h3>
        <ul>
          <li><strong>Fabry–Pérot resonance (longitudinal modes):</strong> constructive interference after a round trip requires
            <span class="eq">2k(λ)d = 2πm</span>, where <span class="eq">k(λ) = 2πn(λ)/λ</span> and <span class="eq">m</span> is an integer.</li>
          <li><strong>Small-spacing approximation:</strong> If neighboring modes are close (<span class="eq">|Δλ| ≪ λ</span>), we can linearize to relate <span class="eq">Δν</span> and <span class="eq">Δλ</span>.</li>
          <li><strong>Dispersion assumed linear across emission bandwidth:</strong> <span class="eq">n(λ) = n<sub>0</sub> − a(λ − λ<sub>c</sub>)</span>, valid only near <span class="eq">λ≈λ<sub>c</sub></span>.</li>
        </ul>

        <div class="card warn">
          <h3>Common models/approximations (and why)</h3>
          <ul>
            <li><strong>No dispersion model:</strong> <span class="eq">n(λ)=const</span> → easy: <span class="eq">Δν = c/(2nd)</span>. Good only when <span class="eq">dn/dλ≈0</span> over the relevant band.</li>
            <li><strong>Linear dispersion model:</strong> keep <span class="eq">dn/dλ</span> constant near <span class="eq">λ<sub>c</sub></span>. Captures first-order effect on spacing and “pulling.”</li>
            <li><strong>Group-index model:</strong> trade <span class="eq">n</span> and <span class="eq">dn/dλ</span> for one effective parameter <span class="eq">n<sub>g</sub></span> that directly controls FSR.</li>
          </ul>
        </div>

        <h3>Mini intuition examples</h3>
        <ul>
          <li><strong>If dispersion is negligible:</strong> <span class="eq">n<sub>g</sub>≈n</span> and you recover the textbook FSR.</li>
          <li><strong>If <span class="eq">dn/dλ&lt;0</span> (normal dispersion in this sign convention):</strong> then
            <span class="eq">n<sub>g</sub> = n − λ(dn/dλ) &gt; n</span> → the cavity has a larger group delay → modes are closer in frequency (and also in wavelength near a fixed λ).</li>
        </ul>

        <div class="card mistake">
          <h3>What to watch for (pitfalls)</h3>
          <ul>
            <li>Confusing <span class="eq">Δν</span> (frequency spacing) with <span class="eq">Δλ</span> (wavelength spacing). They are not linearly related.</li>
            <li>Using <span class="eq">Δν=c/(2nd)</span> when <span class="eq">n</span> is dispersive; the correct replacement is <span class="eq">n→n<sub>g</sub></span>.</li>
            <li>Sign errors: here <span class="eq">n(λ)=n<sub>0</sub>−a(λ−λ<sub>c</sub>)</span> implies <span class="eq">dn/dλ=-a</span>.</li>
          </ul>
        </div>
      </article>

      <article id="part1">
        <h2>PART 1 — Problem Analysis (no solving yet)</h2>

        <h3>Problem restatement (in plain language)</h3>
        <p>
          A laser diode of length <span class="eq">d = 430 μm</span> emits around <span class="eq">λ<sub>c</sub> = 650 nm</span>.
          The refractive index depends on wavelength and can be approximated as
          <span class="eq">n(λ)=n<sub>0</sub>−a(λ−λ<sub>c</sub>)</span> near the emission band, with <span class="eq">n<sub>0</sub>=3.4</span>.
          The observed spacing between adjacent longitudinal modes near <span class="eq">λ<sub>c</sub></span> is <span class="eq">Δλ≈0.12 nm</span>.
          (a) Explain why this isn’t the usual constant-index spacing. (b) Estimate <span class="eq">a</span>. (c) Explain mode pulling in a gas laser and compare it to the semiconductor case.
        </p>

        <div class="grid2">
          <div class="card">
            <h3>Given</h3>
            <ul>
              <li><span class="eq">d = 430 μm</span></li>
              <li><span class="eq">λ<sub>c</sub> = 650 nm</span></li>
              <li><span class="eq">n(λ<sub>c</sub>) = n<sub>0</sub> = 3.4</span></li>
              <li><span class="eq">Δλ (observed) ≈ 0.12 nm</span></li>
              <li><span class="eq">n(λ)=n<sub>0</sub>−a(λ−λ<sub>c</sub>)</span> (linearized)</li>
            </ul>
          </div>
          <div class="card">
            <h3>Unknowns / tasks</h3>
            <ul>
              <li>(a) Conceptual explanation: why the usual FSR formula doesn’t apply directly.</li>
              <li>(b) Numerical estimate of <span class="eq">a</span> (dispersion slope magnitude).</li>
              <li>(c) A qualitative comparison: gas-laser mode pulling vs semiconductor dispersion effect.</li>
            </ul>
          </div>
        </div>

        <h3>Relevant physics (and why)</h3>
        <ul>
          <li><strong>Fabry–Pérot longitudinal resonance</strong> applies because the diode facets form a cavity and lasing occurs on standing-wave resonances.</li>
          <li><strong>Dispersion / group index</strong> is essential because mode spacing is determined by how resonance phase changes with frequency.</li>
          <li>We do <em>not</em> need transverse modes, diffraction, or detailed gain modeling for parts (a) and (b); only longitudinal phase matching plus linear dispersion.</li>
        </ul>

        <div class="card callout">
          <h3>Assumptions</h3>
          <ul>
            <li>1D Fabry–Pérot cavity of length <span class="eq">d</span> (effective optical length set by <span class="eq">n(λ)</span>).</li>
            <li>Dispersion is linear across the small emission bandwidth around <span class="eq">λ<sub>c</sub></span>.</li>
            <li>Neighboring modes are close: <span class="eq">|Δλ|≪λ</span> so linearization is valid.</li>
            <li>We ignore mirror phase shifts and waveguide dispersion details; they would slightly modify <span class="eq">n(λ)</span> but not the method.</li>
          </ul>
        </div>

        <h3>Possible approaches (compare & choose)</h3>
        <ul>
          <li><strong>Approach A (group index method):</strong> derive <span class="eq">Δν</span> from round-trip group delay, then convert to <span class="eq">Δλ</span>. <em>Pros:</em> shortest, most physical. <em>Cons:</em> must remember relation <span class="eq">n<sub>g</sub>=n−λdn/dλ</span>.</li>
          <li><strong>Approach B (differentiate resonance condition):</strong> start from <span class="eq">mλ=2n(λ)d</span>, take a differential to connect <span class="eq">Δm=1</span> to <span class="eq">Δλ</span>. <em>Pros:</em> straightforward calculus. <em>Cons:</em> easy to drop the <span class="eq">dn/dλ</span> term.</li>
          <li><strong>Approach C (explicit solution for λ<sub>m</sub>):</strong> solve for <span class="eq">λ<sub>m</sub></span> with linear <span class="eq">n(λ)</span>, then compute spacing. <em>Pros:</em> gives intuition for nonuniform spacing. <em>Cons:</em> a bit more algebra.</li>
        </ul>
        <p class="card ok">
          <strong>Best choice:</strong> Use <strong>Approach A</strong> for clarity (group delay → FSR), and use a quick cross-check with Approach B.
        </p>
      </article>

      <article id="part2">
        <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

        <ol style="color:var(--muted); margin-left: 22px;">
          <li>
            <strong>Write the resonance condition.</strong>
            <div class="eq">mλ = 2n(λ)d</div>
            <div style="margin-top:6px;">Goal: identify what sets the spacing between consecutive integers <span class="eq">m</span>.</div>
          </li>
          <li>
            <strong>Connect mode spacing to how phase changes with frequency.</strong>
            Use the idea: neighboring modes differ by <span class="eq">2π</span> in round-trip phase → spacing depends on round-trip <em>group delay</em>.
          </li>
          <li>
            <strong>Introduce group index.</strong>
            Use <span class="eq">n<sub>g</sub> = n − λ(dn/dλ)</span>, evaluated near <span class="eq">λ≈λ<sub>c</sub></span>.
          </li>
          <li>
            <strong>Compute frequency FSR.</strong>
            <span class="eq">Δν ≈ c/(2dn<sub>g</sub>)</span>.
            Tip: this is the dispersion-corrected version of the textbook formula.
          </li>
          <li>
            <strong>Convert to wavelength spacing near λ<sub>c</sub>.</strong>
            For small spacing, <span class="eq">|Δλ| ≈ (λ²/c)|Δν|</span> → <span class="eq">Δλ ≈ λ²/(2dn<sub>g</sub>)</span>.
          </li>
          <li>
            <strong>Use the measured Δλ to infer n<sub>g</sub>.</strong>
            Rearrange: <span class="eq">n<sub>g</sub> ≈ λ²/(2dΔλ)</span>.
          </li>
          <li>
            <strong>Relate n<sub>g</sub> to a.</strong>
            With <span class="eq">dn/dλ = -a</span>, get <span class="eq">n<sub>g</sub> = n + λa</span> at <span class="eq">λ=λ<sub>c</sub></span>.
          </li>
          <li>
            <strong>Mode pulling explanation.</strong>
            Discuss how a frequency-dependent refractive index (especially steep near atomic lines) shifts cavity resonances toward the gain peak.
          </li>
        </ol>

        <div class="card mistake">
          <strong>Common mistakes:</strong>
          <ul>
            <li>Using <span class="eq">Δλ = λ²/(2nd)</span> even when <span class="eq">dn/dλ ≠ 0</span> (must use <span class="eq">n<sub>g</sub></span>).</li>
            <li>Forgetting that <span class="eq">dn/dλ=-a</span> for the given linear model.</li>
            <li>Mixing nm and m in the same computation without converting.</li>
          </ul>
        </div>
      </article>

      <article id="part3">
        <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

        <h3>Physical intuition first (what we expect)</h3>
        <p>
          In a simple Fabry–Pérot cavity with constant refractive index, the round-trip time is <span class="eq">τ<sub>rt</sub>=2nd/c</span>,
          so the frequency spacing is <span class="eq">Δν≈1/τ<sub>rt</sub>=c/(2nd)</span>.
          But when <span class="eq">n</span> depends on wavelength (or frequency), the round-trip time relevant for spacing is the
          <em>group delay</em>, which uses <span class="eq">n<sub>g</sub></span>. If dispersion makes <span class="eq">n<sub>g</sub> &gt; n</span>,
          the cavity “acts longer in time,” so modes become closer together than the constant-index prediction.
        </p>

        <div class="grid2">
          <figure class="card">
            <canvas id="diagCanvas" class="canvasShort" aria-label="Cavity diagram"></canvas>
            <figcaption>
              Diagram: Fabry–Pérot diode cavity of length <span class="eq">d</span>. Dispersion means the optical phase condition depends on <span class="eq">n(λ)</span>.
            </figcaption>
          </figure>
          <figure class="card">
            <canvas id="plot1" class="canvasShort" aria-label="Mode spacing vs wavelength"></canvas>
            <figcaption>
              Main plot: predicted <span class="eq">Δλ(λ)</span> using <span class="eq">n<sub>g</sub>=n−λdn/dλ</span>, compared to the no-dispersion case.
            </figcaption>
          </figure>
        </div>

        <figure class="card" style="margin-top:12px;">
          <canvas id="plot2" class="canvasTall" aria-label="Resonant wavelength comb near lambda c"></canvas>
          <figcaption>
            Secondary plot: resonance “comb” <span class="eq">λ<sub>m</sub></span> near <span class="eq">λ<sub>c</sub></span> for the linear dispersion model. Changing <span class="eq">a</span> shifts spacing.
          </figcaption>

          <div class="controls">
            <label>
              Dispersion slope
              <span class="eq">a</span> (nm<sup>−1</sup>):
              <input id="aSlider" type="range" min="0" max="3" step="0.01" value="1.07" />
            </label>
            <span class="pill" id="aReadout"></span>
            <button class="btn" id="setEstimated">Set to estimated a</button>
            <span class="pill" id="ngReadout"></span>
          </div>
        </figure>

        <h3>(a) Why the observed spacing does not correspond to the “usual” <span class="eq">Δν = c/(2nd)</span></h3>
        <p>
          Start from the resonance condition for longitudinal modes in a Fabry–Pérot cavity:
          the round-trip phase must be an integer multiple of <span class="eq">2π</span>:
        </p>

        <div class="eqblock" id="eq-res">
          <button class="copy-btn" data-copy="2k(λ)d = 2πm,   k(λ) = 2π n(λ) / λ   ⇒   mλ = 2 n(λ) d">Copy</button>
          <pre>2k(λ)d = 2πm
k(λ) = 2π n(λ) / λ
⇒  mλ = 2 n(λ) d</pre>
        </div>

        <p>
          If <span class="eq">n</span> were constant, consecutive modes differ by <span class="eq">Δm=1</span>, giving the textbook frequency spacing:
          <span class="eq">Δν = c/(2nd)</span>. However, when <span class="eq">n</span> depends on frequency, the resonance phase changes with frequency
          at a rate set by the <em>group index</em> <span class="eq">n<sub>g</sub></span>.
        </p>

        <div class="card callout">
          <h3>Key replacement due to dispersion</h3>
          <p>
            The spacing is controlled by the round-trip group delay
            <span class="eq">τ<sub>rt</sub> = 2 d n<sub>g</sub> / c</span>,
            so
            <span class="eq">Δν ≈ 1/τ<sub>rt</sub> = c/(2 d n<sub>g</sub>)</span>,
            where
            <span class="eq">n<sub>g</sub> = n − λ(dn/dλ)</span>.
          </p>
        </div>

        <p>
          Therefore, the observed wavelength spacing near <span class="eq">λ<sub>c</sub></span> reflects <span class="eq">n<sub>g</sub></span>, not simply <span class="eq">n</span>.
          Since semiconductor material (and waveguide) dispersion typically makes <span class="eq">n<sub>g</sub> &gt; n</span>, the modes are closer together
          than you would predict using <span class="eq">n=3.4</span> alone.
        </p>

        <h3>(b) Estimate <span class="eq">a</span> from the observed <span class="eq">Δλ</span></h3>
        <p>
          We first relate <span class="eq">Δν</span> and <span class="eq">Δλ</span>. For small separations:
          <span class="eq">ν = c/λ</span> implies <span class="eq">dν = -(c/λ²)dλ</span>, so in magnitude:
          <span class="eq">|Δν| ≈ (c/λ²)|Δλ|</span>.
        </p>

        <div class="eqblock" id="eq-dl">
          <button class="copy-btn" data-copy="Δν ≈ c/(2 d n_g)  and  |Δν| ≈ (c/λ^2)|Δλ|  ⇒  Δλ ≈ λ^2/(2 d n_g)">Copy</button>
          <pre>Δν ≈ c/(2 d n_g)
|Δν| ≈ (c/λ^2)|Δλ|
⇒  Δλ ≈ λ^2/(2 d n_g)   (near a given λ)</pre>
        </div>

        <p>
          Solve this for <span class="eq">n<sub>g</sub></span> at <span class="eq">λ=λ<sub>c</sub></span>:
        </p>

        <div class="eqblock" id="eq-ng">
          <button class="copy-btn" data-copy="n_g ≈ λ_c^2 / (2 d Δλ)">Copy</button>
          <pre>n_g ≈ λ_c^2 / (2 d Δλ)</pre>
        </div>

        <p>
          Insert the numbers (convert everything to SI units):
        </p>
        <ul>
          <li><span class="eq">λ<sub>c</sub> = 650 nm = 650×10⁻⁹ m</span></li>
          <li><span class="eq">d = 430 μm = 430×10⁻⁶ m</span></li>
          <li><span class="eq">Δλ = 0.12 nm = 0.12×10⁻⁹ m</span></li>
        </ul>

        <p>
          Then:
          <span class="eq">n<sub>g</sub> ≈ (650×10⁻⁹)² / [2(430×10⁻⁶)(0.12×10⁻⁹)] ≈ 4.09</span>.
        </p>

        <p>
          Now connect <span class="eq">n<sub>g</sub></span> to the parameter <span class="eq">a</span>.
          The model is <span class="eq">n(λ)=n<sub>0</sub>−a(λ−λ<sub>c</sub>)</span>, so
          <span class="eq">dn/dλ = -a</span>.
          Therefore:
        </p>

        <div class="eqblock" id="eq-a">
          <button class="copy-btn" data-copy="n_g = n − λ(dn/dλ) = n − λ(-a) = n + λ a   ⇒   a = (n_g − n)/λ">Copy</button>
          <pre>dn/dλ = -a
n_g = n − λ(dn/dλ) = n − λ(-a) = n + λ a
⇒  a = (n_g − n)/λ   (evaluate at λ = λ_c)</pre>
        </div>

        <p>
          Using <span class="eq">n(λ<sub>c</sub>)=n<sub>0</sub>=3.4</span>, <span class="eq">λ<sub>c</sub>=650 nm</span>, and <span class="eq">n<sub>g</sub>≈4.09</span>:
        </p>

        <div class="card ok" style="position:relative;">
          <button class="copy-btn" data-copy="Estimated: n_g ≈ 4.09.   a ≈ (4.09 − 3.4)/(650 nm) ≈ 1.07×10^6 m^-1 ≈ 1.07×10^-3 nm^-1.   dn/dλ = −a ≈ −1.07×10^-3 nm^-1.">Copy</button>
          <h3 style="margin-top:0;">Final numeric estimate</h3>
          <p style="margin:6px 0 0; color:var(--text);">
            <span class="eq">n<sub>g</sub> ≈ 4.09</span><br/>
            <span class="eq">a ≈ 1.07×10⁶ m⁻¹ ≈ 1.07×10⁻³ nm⁻¹</span><br/>
            <span class="eq">dn/dλ = −a ≈ −1.07×10⁻³ nm⁻¹</span>
          </p>
        </div>

        <h3>Sanity checks</h3>
        <ul>
          <li><strong>Units:</strong> <span class="eq">a</span> has units of inverse length (since it multiplies <span class="eq">λ</span> in meters). Converting to nm⁻¹ is consistent.</li>
          <li><strong>Limiting case:</strong> if <span class="eq">a→0</span>, then <span class="eq">n<sub>g</sub>→n</span> and <span class="eq">Δλ→λ²/(2dn)</span>, the constant-index result.</li>
          <li><strong>Sign reasoning:</strong> Here <span class="eq">a&gt;0</span> means <span class="eq">dn/dλ=-a&lt;0</span> → <span class="eq">n<sub>g</sub>&gt;n</span> → modes closer than constant-n prediction, consistent with the observed relatively small spacing.</li>
        </ul>

        <h3>(c) Mode pulling in a gas laser (and comparison)</h3>
        <p>
          <strong>Mode pulling</strong> is the shift of the lasing frequency away from the “empty-cavity” resonance toward the center of the gain line
          due to the dispersive refractive index associated with the atomic/molecular transition.
        </p>

        <div class="grid2">
          <div class="card callout">
            <h3>Gas laser: why pulling happens</h3>
            <ul>
              <li>Near a narrow atomic transition, the medium has strong dispersion (often steep, and can be anomalous on parts of the line).</li>
              <li>The refractive index becomes frequency-dependent: <span class="eq">n(ν)</span> changes noticeably across the gain profile.</li>
              <li>Cavity resonance condition depends on <span class="eq">n(ν)</span>, so the resonance frequencies shift as the active medium’s dispersion “loads” the cavity.</li>
              <li>The lasing mode tends to be pulled toward the frequency where gain is highest, because that is where net amplification wins the threshold competition.</li>
            </ul>
          </div>

          <div class="card ok">
            <h3>Semiconductor diode: what’s analogous here</h3>
            <ul>
              <li>In the diode problem, dispersion is modeled as a smooth linear slope <span class="eq">dn/dλ = -a</span> across the emission band.</li>
              <li>This changes the <em>mode spacing</em> primarily through <span class="eq">n<sub>g</sub></span> (and slightly shifts individual resonances).</li>
              <li>Both cases share the same root cause: <strong>frequency-dependent refractive index modifies the cavity phase condition</strong>.</li>
              <li>Difference: gas lasers often have <em>much sharper</em> dispersion tied to a narrow resonance, leading to more dramatic pulling near line center; semiconductor dispersion is typically broader and includes material + waveguide contributions.</li>
            </ul>
          </div>
        </div>

        <p>
          In short: <strong>gas-laser mode pulling</strong> is usually discussed as a competition between cavity resonances and a narrow gain/dispersion feature,
          whereas in this diode problem the key observable is the altered FSR due to a (locally) linear dispersion slope—yet both are manifestations of the same
          “index vs frequency” physics.
        </p>
      </article>

      <article id="part4">
        <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

        <div class="card callout">
          <h3>Re-interpreting the final formulas</h3>
          <p>
            The dispersion-corrected free spectral range is:
            <span class="eq">Δν ≈ c/(2 d n<sub>g</sub>)</span>, with <span class="eq">n<sub>g</sub> = n − λ(dn/dλ)</span>.
            This says:
          </p>
          <ul>
            <li><span class="eq">d</span> larger → longer round-trip time → smaller spacing.</li>
            <li><span class="eq">n<sub>g</sub></span> larger (stronger dispersion or higher index) → smaller spacing.</li>
            <li>Measured <span class="eq">Δλ</span> is essentially a way to measure <span class="eq">n<sub>g</sub></span> (and thus dispersion) of the cavity mode.</li>
          </ul>
        </div>

        <h3>How changing parameters affects outcomes (connect to plots)</h3>
        <ul>
          <li>Increasing <span class="eq">a</span> (stronger slope magnitude with <span class="eq">dn/dλ=-a</span>) increases <span class="eq">n<sub>g</sub>=n+λa</span> → decreases <span class="eq">Δλ</span>. You’ll see the main curve drop and the mode-comb lines pack closer.</li>
          <li>Setting <span class="eq">a=0</span> collapses the dispersive prediction onto the “no dispersion” curve in the main plot.</li>
        </ul>

        <h3>Alternative derivation idea (brief)</h3>
        <p>
          You can differentiate the resonance condition <span class="eq">mλ = 2n(λ)d</span>. For <span class="eq">Δm=1</span> and small <span class="eq">Δλ</span>, you get
          <span class="eq">Δλ ≈ λ / [m − 2d(dn/dλ)]</span>. Rewriting <span class="eq">m≈2nd/λ</span> leads back to <span class="eq">Δλ ≈ λ²/(2dn<sub>g</sub>)</span>.
          This is a good cross-check and highlights exactly where the <span class="eq">dn/dλ</span> term enters.
        </p>

        <div class="card ok">
          <h3>Concept checks (quick self-test)</h3>
          <ul>
            <li><strong>Q:</strong> If <span class="eq">dn/dλ</span> were positive, would <span class="eq">n<sub>g</sub></span> be larger or smaller than <span class="eq">n</span>?<br/>
              <strong>A:</strong> <span class="eq">n<sub>g</sub>=n−λ(dn/dλ)</span> would be <em>smaller</em> than <span class="eq">n</span> (for positive slope).</li>
            <li><strong>Q:</strong> Why does dispersion affect spacing more naturally in frequency than in wavelength?<br/>
              <strong>A:</strong> The cavity’s phase changes “linearly” with frequency via group delay; wavelength is a nonlinear transform <span class="eq">ν=c/λ</span>.</li>
            <li><strong>Q:</strong> In one sentence, what does measuring <span class="eq">Δλ</span> tell you?<br/>
              <strong>A:</strong> It gives you the cavity’s effective group index <span class="eq">n<sub>g</sub></span> near the lasing wavelength.</li>
          </ul>
        </div>
      </article>

      <article id="part5">
        <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

        <h3>What each canvas shows</h3>
        <ul>
          <li><strong>Diagram canvas:</strong> A Fabry–Pérot diode cavity (two facets) with length <span class="eq">d</span>, showing longitudinal standing-wave modes and labeling <span class="eq">λ<sub>c</sub></span> and <span class="eq">Δλ</span>.</li>
          <li><strong>Main plot (Mode spacing vs wavelength):</strong> The curve <span class="eq">Δλ(λ)=λ²/[2d(n+λa)]</span> (dispersive case) and the reference <span class="eq">Δλ(λ)=λ²/(2dn)</span> (no dispersion). A marker shows the measured point at <span class="eq">λ<sub>c</sub></span>.</li>
          <li><strong>Secondary plot (Resonant comb):</strong> Vertical lines are the individual resonant wavelengths <span class="eq">λ<sub>m</sub></span> around <span class="eq">λ<sub>c</sub></span> predicted by the linear dispersion model. As dispersion changes, the comb spacing changes.</li>
        </ul>

        <h3>Interactive control</h3>
        <p>
          The slider changes the dispersion slope <span class="eq">a</span> (shown in nm<sup>−1</sup>). Increasing <span class="eq">a</span> makes <span class="eq">dn/dλ=-a</span> more negative,
          so <span class="eq">n<sub>g</sub>=n+λa</span> increases. That should:
        </p>
        <ul>
          <li>Lower the dispersive <span class="eq">Δλ(λ)</span> curve in the main plot.</li>
          <li>Pack the resonance lines closer in the comb plot.</li>
        </ul>
        <p class="card warn">
          <strong>Note:</strong> The plots use the <em>same symbols and constants as the text</em>. The slider value is purely for exploration; the “Set to estimated a” button returns to the estimate from part (b).
        </p>

        <footer>
          <p>
            End of article. Tip for studying: re-derive <span class="eq">Δν = c/(2dn<sub>g</sub>)</span> starting from round-trip phase <span class="eq">Φ(ω)</span> and using <span class="eq">Δω ≈ 2π / (dΦ/dω)</span>.
            That one line explains why group delay is the key.
          </p>
        </footer>
      </article>
    </div>
  </div>
</main>

<script>
(function(){
  // ---------------------------
  // Constants (problem data)
  // ---------------------------
  const c = 299792458;
  const d = 430e-6;            // m
  const lamC = 650e-9;         // m
  const n0 = 3.4;              // at lamC
  const dLamObs = 0.12e-9;     // m observed
  // Estimated from text:
  const ngEst = (lamC*lamC) / (2*d*dLamObs);
  const aEst_mInv = (ngEst - n0) / lamC; // 1/m
  const aEst_nmInv = aEst_mInv * 1e-9;

  // Slider mapping: slider in nm^-1, 0..3e-3. We store in "m^-1".
  const aSlider = document.getElementById('aSlider');
  const aReadout = document.getElementById('aReadout');
  const ngReadout = document.getElementById('ngReadout');
  const setEstimated = document.getElementById('setEstimated');

  // Slider value shown as x10^-3 nm^-1 for nicer handling:
  // aSlider value is in units of 1e-3 nm^-1 (so 1.07 -> 1.07e-3 nm^-1)
  function sliderToA_nmInv(){
    return parseFloat(aSlider.value) * 1e-3; // nm^-1
  }
  function A_nmInv_to_mInv(a_nmInv){
    return a_nmInv * 1e9; // (1/nm) -> (1/m)
  }
  function nOfLam(lam, a_mInv){
    // n(λ)=n0 - a(λ-λc)
    return n0 - a_mInv*(lam - lamC);
  }
  function ngOfLam(lam, a_mInv){
    // dn/dλ = -a => n_g = n - λ dn/dλ = n + λ a
    return nOfLam(lam, a_mInv) + lam * a_mInv;
  }

  // ---------------------------
  // Canvas helpers (HiDPI + resizing)
  // ---------------------------
  function setupCanvas(canvas){
    const ctx = canvas.getContext('2d');
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(10, Math.floor(rect.width * dpr));
      const h = Math.max(10, Math.floor(rect.height * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {cssW: rect.width, cssH: rect.height, dpr};
    }
    return {ctx, resize};
  }

  function lerp(a,b,t){ return a + (b-a)*t; }

  // Axis + grid drawing
  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
    const {x,y,w,h} = box;
    // panel background
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.14)';
    roundRect(ctx, x, y, w, h, 14);
    ctx.fill();
    ctx.restore();

    // title
    ctx.save();
    ctx.fillStyle = 'rgba(233,238,252,0.95)';
    ctx.font = '700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(title, x+12, y+22);
    ctx.restore();

    // plot area inset
    const padL = 54, padR = 16, padT = 32, padB = 42;
    const px = x + padL, py = y + padT, pw = w - padL - padR, ph = h - padT - padB;

    // grid + ticks
    const xTicks = 6;
    const yTicks = 6;

    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 1;

    // grid lines
    for(let i=0;i<=xTicks;i++){
      const t = i/xTicks;
      const gx = px + t*pw;
      ctx.beginPath(); ctx.moveTo(gx, py); ctx.lineTo(gx, py+ph); ctx.stroke();
    }
    for(let j=0;j<=yTicks;j++){
      const t = j/yTicks;
      const gy = py + t*ph;
      ctx.beginPath(); ctx.moveTo(px, gy); ctx.lineTo(px+pw, gy); ctx.stroke();
    }
    ctx.restore();

    // axes
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.28)';
    ctx.lineWidth = 1.25;
    ctx.beginPath();
    ctx.moveTo(px, py+ph); ctx.lineTo(px+pw, py+ph);
    ctx.moveTo(px, py); ctx.lineTo(px, py+ph);
    ctx.stroke();
    ctx.restore();

    // tick labels
    ctx.save();
    ctx.fillStyle = 'rgba(185,196,230,0.95)';
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    for(let i=0;i<=xTicks;i++){
      const t = i/xTicks;
      const xv = lerp(xMin, xMax, t);
      const gx = px + t*pw;
      const txt = formatTick(xv);
      ctx.fillText(txt, gx - ctx.measureText(txt).width/2, py+ph+18);
    }
    for(let j=0;j<=yTicks;j++){
      const t = j/yTicks;
      const yv = lerp(yMax, yMin, t); // top is yMax
      const gy = py + t*ph;
      const txt = formatTick(yv);
      ctx.fillText(txt, px - 10 - ctx.measureText(txt).width, gy + 4);
    }

    // labels
    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(xLabel, px + pw/2 - ctx.measureText(xLabel).width/2, y + h - 12);

    // y label rotated
    ctx.translate(x + 14, py + ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
    ctx.restore();

    // mapping functions
    function X(xv){ return px + (xv - xMin)/(xMax - xMin)*pw; }
    function Y(yv){ return py + (yMax - yv)/(yMax - yMin)*ph; }

    return {plot:{x:px,y:py,w:pw,h:ph}, X, Y};
  }

  function formatTick(v){
    // choose a compact format
    const av = Math.abs(v);
    if(av >= 1000) return v.toFixed(0);
    if(av >= 100) return v.toFixed(1);
    if(av >= 10) return v.toFixed(2);
    if(av >= 1) return v.toFixed(3);
    if(av >= 0.1) return v.toFixed(4);
    return v.toExponential(2);
  }

  function roundRect(ctx,x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  // ---------------------------
  // Draw: Diagram
  // ---------------------------
  const diag = setupCanvas(document.getElementById('diagCanvas'));
  function drawDiagram(){
    const {ctx, resize} = diag;
    const {cssW:W, cssH:H} = resize();

    ctx.clearRect(0,0,W,H);

    // title
    ctx.save();
    ctx.fillStyle = 'rgba(233,238,252,0.95)';
    ctx.font = '700 14px ui-sans-serif, system-ui';
    ctx.fillText('Fabry–Pérot Laser Diode (Longitudinal Modes)', 14, 22);
    ctx.restore();

    const x0 = 18, y0 = 46, w = W-36, h = H-64;

    // cavity block
    const cavX = x0 + 30, cavY = y0 + 20, cavW = w - 60, cavH = h - 70;
    ctx.save();
    ctx.fillStyle = 'rgba(122,167,255,0.08)';
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1.2;
    roundRect(ctx, cavX, cavY, cavW, cavH, 16);
    ctx.fill(); ctx.stroke();
    ctx.restore();

    // mirrors (facets)
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.40)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(cavX, cavY); ctx.lineTo(cavX, cavY+cavH);
    ctx.moveTo(cavX+cavW, cavY); ctx.lineTo(cavX+cavW, cavY+cavH);
    ctx.stroke();
    ctx.restore();

    // standing wave sketch
    ctx.save();
    ctx.strokeStyle = 'rgba(125,255,207,0.70)';
    ctx.lineWidth = 2;
    const midY = cavY + cavH/2;
    const A = cavH*0.22;
    ctx.beginPath();
    const N = 240;
    for(let i=0;i<=N;i++){
      const t = i/N;
      const xx = cavX + t*cavW;
      // a few lobes
      const yy = midY + A*Math.sin(2*Math.PI*4*t);
      if(i===0) ctx.moveTo(xx,yy);
      else ctx.lineTo(xx,yy);
    }
    ctx.stroke();
    ctx.restore();

    // arrows
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.24)';
    ctx.lineWidth = 1.5;
    // length arrow
    const ax1 = cavX+10, ax2 = cavX+cavW-10, ay = cavY+cavH+22;
    arrow(ctx, ax1, ay, ax2, ay);
    arrow(ctx, ax2, ay, ax1, ay);
    ctx.fillStyle = 'rgba(233,238,252,0.9)';
    ctx.font = '600 12px ui-sans-serif, system-ui';
    ctx.fillText('cavity length d = 430 μm', cavX + cavW/2 - 70, ay - 6);

    // labels
    ctx.fillStyle = 'rgba(185,196,230,0.95)';
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillText('facet mirror', cavX+6, cavY-6);
    ctx.fillText('facet mirror', cavX+cavW-72, cavY-6);

    const a_nmInv = sliderToA_nmInv();
    const a_mInv = A_nmInv_to_mInv(a_nmInv);
    const ng = ngOfLam(lamC, a_mInv);

    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.font = '600 12px ui-sans-serif, system-ui';
    ctx.fillText(`n(λ) = n0 − a(λ−λc),   n0=3.4`, cavX+16, cavY + 18);
    ctx.fillStyle = 'rgba(185,196,230,0.95)';
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillText(`at λc=650 nm:  n_g = n − λ dn/dλ = n + λa ≈ ${ng.toFixed(2)}`, cavX+16, cavY + 36);
    ctx.fillText(`observed mode spacing near λc:  Δλ ≈ 0.12 nm`, cavX+16, cavY + 54);

    ctx.restore();
  }

  function arrow(ctx,x1,y1,x2,y2){
    const ang = Math.atan2(y2-y1, x2-x1);
    const head = 8;
    ctx.beginPath();
    ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2 - head*Math.cos(ang) + head*0.6*Math.sin(ang), y2 - head*Math.sin(ang) - head*0.6*Math.cos(ang));
    ctx.lineTo(x2 - head*Math.cos(ang) - head*0.6*Math.sin(ang), y2 - head*Math.sin(ang) + head*0.6*Math.cos(ang));
    ctx.closePath();
    ctx.fillStyle = 'rgba(255,255,255,0.24)';
    ctx.fill();
  }

  // ---------------------------
  // Plot 1: Δλ(λ)
  // ---------------------------
  const p1 = setupCanvas(document.getElementById('plot1'));
  function drawPlot1(){
    const {ctx, resize} = p1;
    const {cssW:W, cssH:H} = resize();
    ctx.clearRect(0,0,W,H);

    const a_nmInv = sliderToA_nmInv();
    const a_mInv = A_nmInv_to_mInv(a_nmInv);

    const lamMin = (lamC - 10e-9), lamMax = (lamC + 10e-9); // +/- 10 nm
    // compute y-range from both curves
    function dLamDisp(lam){
      const ng = ngOfLam(lam, a_mInv);
      return (lam*lam) / (2*d*ng);
    }
    function dLamNoDisp(lam){
      return (lam*lam) / (2*d*n0);
    }

    let yMin = Infinity, yMax = -Infinity;
    for(let i=0;i<=200;i++){
      const lam = lerp(lamMin, lamMax, i/200);
      const y1 = dLamDisp(lam);
      const y2 = dLamNoDisp(lam);
      yMin = Math.min(yMin, y1, y2);
      yMax = Math.max(yMax, y1, y2);
    }
    // pad
    const pad = 0.08*(yMax-yMin);
    yMin -= pad; yMax += pad;

    // axes in nm for x and pm for y maybe; here use nm and nm
    const xMin_nm = lamMin*1e9, xMax_nm = lamMax*1e9;
    const yMin_nm = yMin*1e9, yMax_nm = yMax*1e9;

    const ax = drawAxes(ctx, {x:10,y:10,w:W-20,h:H-20},
      xMin_nm, xMax_nm, yMin_nm, yMax_nm,
      'wavelength λ (nm)',
      'mode spacing Δλ (nm)',
      'Mode spacing with dispersion (group index effect)'
    );

    // draw curves
    function drawCurve(fn, strokeStyle){
      ctx.save();
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      for(let i=0;i<=300;i++){
        const lam_nm = lerp(xMin_nm, xMax_nm, i/300);
        const lam = lam_nm*1e-9;
        const y_nm = fn(lam)*1e9;
        const X = ax.X(lam_nm), Y = ax.Y(y_nm);
        if(i===0) ctx.moveTo(X,Y);
        else ctx.lineTo(X,Y);
      }
      ctx.stroke();
      ctx.restore();
    }

    drawCurve(dLamNoDisp, 'rgba(255,255,255,0.55)');      // reference
    drawCurve(dLamDisp, 'rgba(125,255,207,0.85)');        // dispersive

    // observed point at lamC
    const obsX = ax.X(lamC*1e9);
    const obsY = ax.Y(dLamObs*1e9);
    ctx.save();
    ctx.fillStyle = 'rgba(255,207,90,0.95)';
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(obsX, obsY, 5.5, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();
    ctx.restore();

    // legend
    ctx.save();
    const lx = ax.plot.x + 10, ly = ax.plot.y + 10;
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    roundRect(ctx, lx, ly, 250, 56, 12);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.stroke();

    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.fillText('Legend', lx+10, ly+18);

    // items
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(125,255,207,0.85)';
    ctx.beginPath(); ctx.moveTo(lx+10, ly+30); ctx.lineTo(lx+34, ly+30); ctx.stroke();
    ctx.fillStyle = 'rgba(185,196,230,0.95)';
    ctx.fillText('with dispersion: Δλ = λ²/(2 d n_g)', lx+44, ly+34);

    ctx.strokeStyle = 'rgba(255,255,255,0.55)';
    ctx.beginPath(); ctx.moveTo(lx+10, ly+46); ctx.lineTo(lx+34, ly+46); ctx.stroke();
    ctx.fillText('no dispersion: Δλ = λ²/(2 d n)', lx+44, ly+50);

    // marker label
    ctx.fillStyle = 'rgba(255,207,90,0.95)';
    ctx.beginPath(); ctx.arc(lx+200, ly+46, 4.5, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = 'rgba(185,196,230,0.95)';
    ctx.fillText('measured at λc', lx+210, ly+50);

    ctx.restore();
  }

  // ---------------------------
  // Plot 2: Resonant comb λ_m near λc
  // Using explicit linear-dispersion solution:
  // m λ = 2 d (n0 - a(λ-λc))  =>  (m + 2 d a) λ = 2 d (n0 + a λc)
  // => λ_m = 2 d (n0 + a λc) / (m + 2 d a)
  // ---------------------------
  const p2 = setupCanvas(document.getElementById('plot2'));
  function lambdaOfM(m, a_mInv){
    const num = 2*d*(n0 + a_mInv*lamC);
    const den = (m + 2*d*a_mInv);
    return num/den;
  }

  function drawPlot2(){
    const {ctx, resize} = p2;
    const {cssW:W, cssH:H} = resize();
    ctx.clearRect(0,0,W,H);

    const a_nmInv = sliderToA_nmInv();
    const a_mInv = A_nmInv_to_mInv(a_nmInv);

    // mode number near center (use constant-n estimate for location)
    const mC = Math.round(2*n0*d/lamC);

    // window around λc
    const span = 4e-9; // ±4 nm
    const lamMin = lamC - span, lamMax = lamC + span;

    // collect m values whose λ falls in window
    const lines = [];
    for(let dm=-120; dm<=120; dm++){
      const m = mC + dm;
      const lam = lambdaOfM(m, a_mInv);
      if(lam>=lamMin && lam<=lamMax) lines.push({m, lam});
    }
    // y range is just categorical; use y as line height / intensity proxy
    const xMin_nm = lamMin*1e9, xMax_nm = lamMax*1e9;
    const yMin = 0, yMax = 1;

    const ax = drawAxes(ctx, {x:10,y:10,w:W-20,h:H-20},
      xMin_nm, xMax_nm, yMin, yMax,
      'wavelength λ (nm)',
      'normalized',
      'Resonant wavelengths near λc (mode comb)'
    );

    // draw gain center band (visual reference)
    const xC = ax.X(lamC*1e9);
    ctx.save();
    ctx.strokeStyle = 'rgba(255,207,90,0.55)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(xC, ax.plot.y);
    ctx.lineTo(xC, ax.plot.y + ax.plot.h);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(255,207,90,0.9)';
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillText('λc', xC + 6, ax.plot.y + 14);
    ctx.restore();

    // draw resonance lines
    ctx.save();
    ctx.strokeStyle = 'rgba(125,255,207,0.85)';
    ctx.lineWidth = 1.5;

    lines.forEach((L, i) => {
      const x = ax.X(L.lam*1e9);
      const top = ax.plot.y + 20;
      const bottom = ax.plot.y + ax.plot.h;
      // vary height slightly just to visually separate
      const height = 0.55 + 0.35*Math.sin(0.65*i);
      const yTop = ax.Y(height);
      ctx.beginPath();
      ctx.moveTo(x, bottom);
      ctx.lineTo(x, yTop);
      ctx.stroke();
    });
    ctx.restore();

    // annotate spacing near center (between two closest lines around λc)
    if(lines.length >= 2){
      // find two lines closest to λc (one below, one above), then estimate Δλ between adjacent around center
      lines.sort((a,b)=>a.lam-b.lam);
      let idx = 0;
      while(idx<lines.length && lines[idx].lam < lamC) idx++;
      const i1 = Math.max(1, idx); // ensure in range for i1-1
      if(i1 < lines.length){
        const below = lines[i1-1], above = lines[i1];
        const dLam = (above.lam - below.lam)*1e9; // nm
        const x1 = ax.X(below.lam*1e9), x2 = ax.X(above.lam*1e9);
        const y = ax.plot.y + ax.plot.h - 18;

        ctx.save();
        ctx.strokeStyle = 'rgba(233,238,252,0.80)';
        ctx.fillStyle = 'rgba(233,238,252,0.92)';
        ctx.lineWidth = 1.5;
        arrow(ctx, x1, y, x2, y);
        arrow(ctx, x2, y, x1, y);
        const label = `~Δλ near λc ≈ ${dLam.toFixed(3)} nm`;
        ctx.font = '12px ui-sans-serif, system-ui';
        const tw = ctx.measureText(label).width;
        ctx.fillText(label, (x1+x2)/2 - tw/2, y - 8);
        ctx.restore();
      }
    }

    // info box
    const ng = ngOfLam(lamC, a_mInv);
    const dLamPred = (lamC*lamC)/(2*d*ng)*1e9; // nm
    ctx.save();
    const bx = ax.plot.x + 10, by = ax.plot.y + ax.plot.h - 74;
    ctx.fillStyle = 'rgba(0,0,0,0.28)';
    roundRect(ctx, bx, by, 330, 60, 12);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.stroke();

    ctx.fillStyle = 'rgba(185,196,230,0.95)';
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillText(`a = ${(a_nmInv).toExponential(3)} nm⁻¹  (dn/dλ = −a)`, bx+10, by+18);
    ctx.fillText(`n_g(λc) = ${ng.toFixed(3)}   ⇒   predicted Δλ(λc) ≈ ${dLamPred.toFixed(3)} nm`, bx+10, by+36);
    ctx.fillStyle = 'rgba(255,207,90,0.95)';
    ctx.fillText(`measured Δλ ≈ ${(dLamObs*1e9).toFixed(2)} nm`, bx+10, by+54);
    ctx.restore();
  }

  // ---------------------------
  // UI updates
  // ---------------------------
  function updateReadouts(){
    const a_nmInv = sliderToA_nmInv();
    const a_mInv = A_nmInv_to_mInv(a_nmInv);
    const ng = ngOfLam(lamC, a_mInv);
    aReadout.innerHTML = `a = <span class="eq">${a_nmInv.toExponential(3)} nm⁻¹</span> (so dn/dλ = −a)`;
    ngReadout.innerHTML = `at λc: <span class="eq">n_g ≈ ${ng.toFixed(3)}</span>`;
  }

  function redrawAll(){
    updateReadouts();
    drawDiagram();
    drawPlot1();
    drawPlot2();
  }

  aSlider.addEventListener('input', redrawAll);
  setEstimated.addEventListener('click', () => {
    // slider expects value in units of 1e-3 nm^-1
    aSlider.value = (aEst_nmInv / 1e-3).toFixed(2); // about 1.07
    redrawAll();
  });

  // ---------------------------
  // Copy buttons
  // ---------------------------
  function attachCopyButtons(){
    document.querySelectorAll('.copy-btn').forEach(btn=>{
      btn.addEventListener('click', async () => {
        const txt = btn.getAttribute('data-copy') || '';
        try{
          await navigator.clipboard.writeText(txt);
          const old = btn.textContent;
          btn.textContent = 'Copied!';
          setTimeout(()=>btn.textContent = old, 900);
        }catch(e){
          // fallback
          const ta = document.createElement('textarea');
          ta.value = txt;
          document.body.appendChild(ta);
          ta.select();
          try{ document.execCommand('copy'); }catch(_){}
          document.body.removeChild(ta);
          const old = btn.textContent;
          btn.textContent = 'Copied!';
          setTimeout(()=>btn.textContent = old, 900);
        }
      });
    });
  }

  // resize handling
  let rAF = null;
  window.addEventListener('resize', () => {
    if(rAF) cancelAnimationFrame(rAF);
    rAF = requestAnimationFrame(redrawAll);
  });

  // initialize slider to estimated
  aSlider.value = (aEst_nmInv / 1e-3).toFixed(2); // ~1.07
  attachCopyButtons();
  redrawAll();
})();
</script>
</body>
</html>
