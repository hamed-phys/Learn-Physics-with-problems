<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Numerical Aperture: Step-Index vs Graded-Index Fiber (Parabolic p=2)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1731;
      --panel2:#111c3a;
      --text:#eaf0ff;
      --muted:#b7c3ea;
      --faint:#7f8bb5;
      --line:#24305a;
      --accent:#77a7ff;
      --accent2:#6df0c2;
      --warn:#ffcc66;
      --ok:#7cff9a;
      --bad:#ff6b8a;
      --shadow: 0 14px 38px rgba(0,0,0,.35);
      --radius: 18px;
      --radius2: 24px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      background:
        radial-gradient(1200px 700px at 20% -10%, rgba(119,167,255,.18), transparent 55%),
        radial-gradient(900px 600px at 90% 10%, rgba(109,240,194,.14), transparent 55%),
        radial-gradient(700px 520px at 40% 120%, rgba(255,204,102,.10), transparent 60%),
        var(--bg);
      color:var(--text);
      font-family:var(--sans);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:44px 18px 22px;
      max-width:1200px;
      margin:0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap:18px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns:1fr}
    }
    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius2);
      padding:22px 20px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .titleCard:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(800px 280px at 20% 0%, rgba(119,167,255,.22), transparent 55%);
      pointer-events:none;
      opacity:.9;
    }
    .titleCard > *{position:relative}
    h1{
      margin:0 0 8px;
      font-size: clamp(1.45rem, 1.25rem + 1.2vw, 2.25rem);
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      margin:0;
      font-size:1.02rem;
      max-width: 70ch;
    }
    .metaRow{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top:14px;
    }
    .pill{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(15,23,49,.55);
      color:var(--muted);
      padding:6px 10px;
      border-radius:999px;
      font-size:.9rem;
    }
    .tocCard{
      background: rgba(15,23,49,.55);
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius2);
      padding:14px 14px;
      box-shadow: var(--shadow);
      position:sticky;
      top:14px;
      align-self:start;
      max-height: calc(100vh - 28px);
      overflow:auto;
    }
    .tocTitle{
      display:flex; justify-content:space-between; align-items:center;
      margin-bottom:8px;
    }
    .tocTitle b{letter-spacing:.3px}
    .toc small{color:var(--faint)}
    .toc a{
      display:block;
      padding:8px 10px;
      margin:4px 0;
      border-radius: 12px;
      border:1px solid transparent;
      color:var(--text);
      background: rgba(255,255,255,.03);
    }
    .toc a:hover{border-color: rgba(119,167,255,.35); background: rgba(119,167,255,.10); text-decoration:none}
    main{
      max-width:1200px;
      margin: 0 auto;
      padding: 0 18px 44px;
      display:grid;
      grid-template-columns: 1fr 340px;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
      .tocCard{position:relative; top:auto; max-height:none}
    }
    section{
      background: rgba(15,23,49,.55);
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius2);
      padding:18px 18px;
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    section:after{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(180deg, rgba(255,255,255,.03), transparent 36%);
      pointer-events:none;
    }
    section > *{position:relative}
    h2{
      margin:0 0 10px;
      font-size:1.35rem;
      letter-spacing:.2px;
    }
    h3{
      margin:16px 0 8px;
      font-size:1.1rem;
      color:var(--text);
    }
    p{margin: 8px 0}
    ul{margin:8px 0 8px 18px}
    li{margin:6px 0}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 780px){
      .grid2{grid-template-columns:1fr}
    }
    .callout{
      border-radius: var(--radius);
      border:1px solid rgba(255,255,255,.12);
      background: rgba(17,28,58,.62);
      padding:12px 12px;
    }
    .callout strong{color:var(--text)}
    .callout.assump{border-color: rgba(255,204,102,.35)}
    .callout.keyeq{border-color: rgba(119,167,255,.35)}
    .callout.mist{border-color: rgba(255,107,138,.30)}
    .callout.ans{border-color: rgba(124,255,154,.30)}
    .eqRow{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
      margin:10px 0;
      padding:10px 10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
    }
    code, .mono{font-family:var(--mono)}
    .eqText{
      white-space:pre-wrap;
      word-break:break-word;
      font-family:var(--mono);
      color: #eaf0ff;
      font-size:.95rem;
      line-height:1.45;
    }
    .btn{
      cursor:pointer;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(119,167,255,.10);
      color: var(--text);
      border-radius: 12px;
      padding:8px 10px;
      font-size:.88rem;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{transform: translateY(-1px); background: rgba(119,167,255,.16); border-color: rgba(119,167,255,.35)}
    .btn:active{transform: translateY(0px)}
    .mini{
      font-size:.85rem;
      color:var(--muted);
    }
    .vizWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .vizCard{
      border-radius: var(--radius2);
      border:1px solid rgba(255,255,255,.12);
      background: rgba(17,28,58,.55);
      padding:12px;
      overflow:hidden;
    }
    .vizHeader{
      display:flex; align-items:baseline; justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .vizHeader .title{
      font-weight:700;
      letter-spacing:.2px;
    }
    .vizHeader .sub{
      color:var(--muted);
      font-size:.85rem;
    }
    canvas{
      width:100%;
      height: 280px;
      display:block;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(11,16,32,.60);
    }
    .controls{
      display:grid;
      grid-template-columns: 1.25fr 1fr;
      gap:10px;
    }
    @media (max-width: 980px){
      .controls{grid-template-columns:1fr}
    }
    .ctrl{
      border-radius: var(--radius);
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      padding:10px;
    }
    .ctrl label{
      display:flex; justify-content:space-between; gap:10px;
      font-size:.9rem;
      color:var(--muted);
      margin-bottom:8px;
    }
    .ctrl input[type="range"]{width:100%}
    .ctrl select{
      width:100%;
      background: rgba(11,16,32,.7);
      border:1px solid rgba(255,255,255,.14);
      color: var(--text);
      border-radius: 12px;
      padding:10px;
      outline:none;
    }
    .readout{
      margin-top:8px;
      font-family: var(--mono);
      color: var(--text);
      font-size:.92rem;
    }
    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 12px 18px 44px;
      color: var(--faint);
      font-size:.9rem;
    }
    .printHint{display:none}
    @media print{
      body{background:#fff; color:#000}
      header, main, footer{max-width:100%; padding:0}
      .tocCard{display:none}
      section, .titleCard, .vizCard{box-shadow:none; background:#fff; border:1px solid #bbb}
      .btn{display:none}
      canvas{border:1px solid #999; background:#fff}
      .printHint{display:block}
      a{color:#000; text-decoration:underline}
    }
  </style>
</head>
<body>
<header>
  <div class="hero">
    <div class="titleCard">
      <h1>Numerical Aperture of a Fiber: Step-Index vs Graded-Index (Parabolic p = 2)</h1>
      <p class="subtitle">
        We compare how much light each fiber type can accept from air, using the
        <span class="mono">numerical aperture (NA)</span> under the weakly guiding approximation.
      </p>
      <div class="metaRow">
        <span class="pill">Given: n₁ = 1.45</span>
        <span class="pill">Given: Δ = 0.01</span>
        <span class="pill">Graded index: parabolic (p = 2)</span>
        <span class="pill">Goal: compare NA values</span>
      </div>
      <p class="mini printHint">Print-friendly note: interactive plots are static in print.</p>
    </div>

    <nav class="tocCard toc" aria-label="Table of Contents">
      <div class="tocTitle">
        <b>Table of Contents</b>
        <small>sticky</small>
      </div>
      <a href="#quick">Quick Summary</a>
      <a href="#primer">PART 0 — Concept Primer</a>
      <a href="#analysis">PART 1 — Problem Analysis</a>
      <a href="#strategy">PART 2 — Strategy & Tips</a>
      <a href="#solution">PART 3 — Full Solution</a>
      <a href="#deeper">PART 4 — Deeper Understanding</a>
      <a href="#guide">PART 5 — Visualization Guide</a>
      <a href="#viz">Interactive Visuals</a>
    </nav>
  </div>
</header>

<main>
  <article>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>What this is about:</b> comparing the <b>acceptance</b> of light into a <b>step-index</b> fiber vs a <b>graded-index</b> fiber.</li>
        <li><b>Key physics idea:</b> guided rays must satisfy <b>total internal reflection</b> at the core–cladding edge (or equivalently, must have transverse wavevector below cutoff).</li>
        <li><b>Governing relationship:</b> for launch from air, <span class="mono">NA ≡ sin(θₐ)</span>, where <span class="mono">θₐ</span> is the maximum acceptance half-angle in air.</li>
        <li><b>Step-index NA:</b> <span class="mono">NA = √(n₁² − n₂²) ≈ n₁√(2Δ)</span> (weak guidance).</li>
        <li><b>Graded-index (parabolic p=2):</b> the <b>same NA</b> for the same edge indices <span class="mono">n₁</span> and <span class="mono">n₂</span> (acceptance is set by the boundary).</li>
        <li><b>Numeric result:</b> with <span class="mono">n₁=1.45</span>, <span class="mono">Δ=0.01</span>, both fibers have <span class="mono">NA ≈ 0.205</span> (dimensionless), so <span class="mono">θₐ ≈ arcsin(0.205) ≈ 11.8°</span>.</li>
        <li><b>Result type:</b> symbolic formula + numeric comparison.</li>
      </ul>
    </section>

    <section id="primer">
      <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

      <div class="grid2">
        <div class="callout keyeq">
          <strong>Core definitions (symbols & units)</strong>
          <ul>
            <li><span class="mono">n</span> (dimensionless): refractive index.</li>
            <li><span class="mono">n₁</span>: maximum (on-axis) core index.</li>
            <li><span class="mono">n₂</span>: cladding index (or edge index at the core boundary).</li>
            <li><span class="mono">Δ</span> (dimensionless): relative index difference (weak guidance parameter).</li>
            <li><span class="mono">NA</span> (dimensionless): numerical aperture, <span class="mono">NA = n₀ sin(θₐ)</span>. For launch from air, <span class="mono">n₀ ≈ 1</span>, so <span class="mono">NA = sin(θₐ)</span>.</li>
          </ul>
        </div>

        <div class="callout assump">
          <strong>Physical meaning</strong>
          <ul>
            <li><b>NA measures “light-gathering power”</b>: larger NA means a larger acceptance cone of input angles that can be guided.</li>
            <li><b>Δ measures guidance strength</b>: bigger Δ means bigger index contrast, hence higher NA and more confined modes.</li>
            <li><b>Step vs graded:</b> step-index has a sharp boundary; graded-index changes smoothly (reducing modal dispersion), but the acceptance is still governed by the <i>edge contrast</i>.</li>
          </ul>
        </div>
      </div>

      <h3>Key laws/principles (and validity)</h3>
      <ul>
        <li><b>Snell’s law + total internal reflection (TIR):</b> for rays, guidance requires that, at the core–cladding boundary, the incidence angle exceeds the critical angle.</li>
        <li><b>Weakly guiding approximation:</b> when <span class="mono">Δ ≪ 1</span>, many expressions simplify (e.g., <span class="mono">NA ≈ n₁√(2Δ)</span>), and ray/mode pictures agree well.</li>
        <li><b>Launch from air:</b> we typically take external medium index <span class="mono">n₀≈1</span> (air). If launching from another medium, replace <span class="mono">NA = n₀ sin θₐ</span>.</li>
      </ul>

      <h3>Common models/approximations (why we use them)</h3>
      <ul>
        <li><b>Step-index model:</b> easiest analytic NA: depends only on <span class="mono">n₁</span> and <span class="mono">n₂</span>.</li>
        <li><b>Power-law graded index:</b> often written as <span class="mono">n(r) = n₁ √(1 − 2Δ (r/a)^p)</span> for <span class="mono">r ≤ a</span>. Parabolic means <span class="mono">p=2</span>.</li>
        <li><b>Why graded index:</b> smooth profile makes rays/modes travel with more equal group delays → reduced intermodal dispersion (but NA is primarily set by boundary indices).</li>
      </ul>

      <h3>Mini intuition examples</h3>
      <ul>
        <li><b>Increase Δ:</b> bigger contrast → higher NA → accepts steeper input rays.</li>
        <li><b>Change the grading p (keep n₁ and n₂ fixed):</b> the <i>shape</i> of <span class="mono">n(r)</span> changes, affecting dispersion and mode structure, but the <b>maximum acceptance</b> remains tied to the edge contrast <span class="mono">n₁ vs n₂</span>.</li>
      </ul>

      <div class="callout mist">
        <strong>What to watch for (pitfalls)</strong>
        <ul>
          <li>Mixing two common definitions of <span class="mono">Δ</span>. In weak guidance, <span class="mono">Δ ≈ (n₁ − n₂)/n₁</span>, but a more precise definition is <span class="mono">Δ = (n₁² − n₂²)/(2 n₁²)</span>.</li>
          <li>Forgetting the outside medium index <span class="mono">n₀</span>. Here we assume air so <span class="mono">n₀ ≈ 1</span>.</li>
          <li>Assuming graded index automatically changes NA—often it does <i>not</i> if <span class="mono">n₁</span> and <span class="mono">n₂</span> are the same.</li>
        </ul>
      </div>
    </section>

    <section id="analysis">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>Problem restatement</h3>
      <p>
        We are given two fibers:
        (1) a <b>step-index</b> fiber with <span class="mono">n₁ = 1.45</span> and <span class="mono">Δ = 0.01</span>;
        (2) a <b>graded-index</b> fiber with the same <span class="mono">n₁</span> and <span class="mono">Δ</span>, with a <b>parabolic</b> refractive-index profile (power-law exponent <span class="mono">p = 2</span>).
        Compare their numerical apertures.
      </p>

      <div class="grid2">
        <div class="callout">
          <strong>Given quantities</strong>
          <ul>
            <li><span class="mono">n₁ = 1.45</span></li>
            <li><span class="mono">Δ = 0.01</span></li>
            <li>Step-index vs graded-index (parabolic, <span class="mono">p=2</span>)</li>
            <li>Assume launch from air: <span class="mono">n₀ ≈ 1</span></li>
          </ul>
        </div>
        <div class="callout">
          <strong>Unknowns / what to find</strong>
          <ul>
            <li>The numerical aperture <span class="mono">NA_step</span> for the step-index fiber</li>
            <li>The numerical aperture <span class="mono">NA_grad</span> for the graded-index fiber</li>
            <li>A clear comparison (same? different? why?)</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li><b>Ray/TIR picture:</b> NA comes from the maximum input angle that still yields TIR at the core boundary. This is directly about indices <span class="mono">n₁</span> and <span class="mono">n₂</span>.</li>
        <li><b>Weak guidance:</b> since <span class="mono">Δ = 0.01</span> is small, approximations like <span class="mono">NA ≈ n₁√(2Δ)</span> are accurate and simplify comparison.</li>
        <li><b>Why not something else?</b> We do not need full mode solutions (Bessel/Airy/WKB) because NA is an <i>acceptance</i> condition governed by boundary contrast, not detailed field distributions.</li>
      </ul>

      <div class="callout assump">
        <strong>Assumptions (explicit)</strong>
        <ul>
          <li>External medium is air: <span class="mono">n₀ = 1</span>.</li>
          <li>Fiber is lossless, isotropic, and cylindrically symmetric.</li>
          <li>Weakly guiding: <span class="mono">Δ ≪ 1</span> so scalar/ray relations hold well.</li>
          <li>The graded-index fiber has the same edge index <span class="mono">n(a)=n₂</span> implied by the same <span class="mono">n₁</span> and <span class="mono">Δ</span>.</li>
        </ul>
      </div>

      <h3>Possible approaches (pros/cons)</h3>
      <ul>
        <li><b>Approach A — Use standard NA formula with Δ:</b> fastest, highlights weak-guidance physics. <span class="mono">NA ≈ n₁√(2Δ)</span>.</li>
        <li><b>Approach B — Compute n₂ from Δ then use exact NA:</b> slightly more algebra, but very clean and robust: <span class="mono">NA = √(n₁² − n₂²)</span>.</li>
        <li><b>Approach C — Ray invariant in graded index:</b> more “from first principles”, but longer; ultimately yields same acceptance controlled by edge contrast.</li>
      </ul>
      <p><b>Chosen approach:</b> Approach B (compute <span class="mono">n₂</span> from <span class="mono">Δ</span> and use <span class="mono">NA = √(n₁² − n₂²)</span>), then show the weak-guidance simplification. It is clear, accurate, and makes the comparison immediate.</p>
    </section>

    <section id="strategy">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

      <ol>
        <li><b>Goal:</b> relate <span class="mono">Δ</span> to <span class="mono">n₂</span>.
          <br><span class="mini">Tool:</span> use the standard weak-guidance definition <span class="mono">Δ = (n₁² − n₂²)/(2n₁²)</span>.
          <br><span class="mini">Meaning:</span> converts a “contrast parameter” into the actual cladding/edge index.</li>
        <li><b>Goal:</b> write NA in terms of indices.
          <br><span class="mini">Tool:</span> <span class="mono">NA = √(n₁² − n₂²)</span> for launch from air.
          <br><span class="mini">Meaning:</span> acceptance is driven by the maximum transverse component that can still be guided.</li>
        <li><b>Goal:</b> simplify NA in terms of <span class="mono">Δ</span>.
          <br><span class="mini">Tool:</span> substitute the <span class="mono">Δ</span> definition.
          <br><span class="mini">Meaning:</span> shows <span class="mono">NA = n₁√(2Δ)</span> (independent of grading exponent <span class="mono">p</span> when edge indices match).</li>
        <li><b>Goal:</b> compute the numeric value for <span class="mono">n₁=1.45</span>, <span class="mono">Δ=0.01</span>.
          <br><span class="mini">Tool:</span> arithmetic + (optionally) compute <span class="mono">θₐ = arcsin(NA)</span>.
          <br><span class="mini">Meaning:</span> concrete comparison for the two fibers.</li>
        <li><b>Goal:</b> argue why graded index (parabolic) has the same NA here.
          <br><span class="mini">Tool:</span> acceptance depends on <span class="mono">n₁</span> and the minimum/edge index <span class="mono">n₂</span>, not the interior shape.
          <br><span class="mini">Meaning:</span> grading changes dispersion, not the maximum acceptance cone (for fixed boundary indices).</li>
      </ol>

      <div class="callout mist">
        <strong>Common mistakes & quick tips</strong>
        <ul>
          <li><b>Mistake:</b> using <span class="mono">Δ = (n₁ − n₂)/n₁</span> as exact. <b>Tip:</b> it’s an approximation; prefer <span class="mono">(n₁² − n₂²)/(2n₁²)</span> when possible.</li>
          <li><b>Mistake:</b> thinking graded index implies a different NA automatically. <b>Tip:</b> if <span class="mono">n₁</span> and <span class="mono">n₂</span> match, the acceptance condition matches.</li>
          <li><b>Mistake:</b> forgetting the outside medium. <b>Tip:</b> for general medium, <span class="mono">NA = n₀ sin θₐ</span>.</li>
        </ul>
      </div>
    </section>

    <section id="solution">
      <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

      <h3>Physical intuition first</h3>
      <p>
        A fiber accepts rays within an “acceptance cone.” If a ray enters too steeply, its transverse component is too large,
        so when it reaches the core edge it will refract out into the cladding rather than being trapped by total internal reflection.
        The steepest guided ray is set by the contrast between the maximum core index and the cladding (or edge) index.
        That is why NA is mainly about <span class="mono">n₁</span> and <span class="mono">n₂</span>.
      </p>

      <div class="callout keyeq">
        <strong>Key equation (launch from air)</strong>
        <div class="eqRow">
          <div class="eqText" id="eq_na_indices">NA = sin(θₐ) = √(n₁² − n₂²)</div>
          <button class="btn" data-copy="#eq_na_indices">Copy</button>
        </div>
        <p class="mini">Here <span class="mono">θₐ</span> is the maximum acceptance half-angle in air (dimensionless NA).</p>
      </div>

      <h3>Step 1: Connect Δ to n₂</h3>
      <p>
        In weakly guiding fiber theory, a common and very useful definition of the relative index difference is
      </p>
      <div class="eqRow">
        <div class="eqText" id="eq_delta_def">Δ = (n₁² − n₂²) / (2 n₁²)</div>
        <button class="btn" data-copy="#eq_delta_def">Copy</button>
      </div>
      <p>
        <b>What did we do and why?</b> We used a definition that directly involves <span class="mono">n₁² − n₂²</span>, because NA also
        involves that same difference. This makes the algebra almost “plug-and-play.”
      </p>

      <h3>Step 2: Solve for (n₁² − n₂²)</h3>
      <p>
        Multiply both sides by <span class="mono">2 n₁²</span>:
      </p>
      <div class="eqRow">
        <div class="eqText" id="eq_delta_rearrange">n₁² − n₂² = 2 n₁² Δ</div>
        <button class="btn" data-copy="#eq_delta_rearrange">Copy</button>
      </div>
      <p>
        <b>Meaning:</b> the “index-squared contrast” is proportional to <span class="mono">Δ</span>. This is the contrast that sets confinement and acceptance.
      </p>

      <h3>Step 3: Compute NA for the step-index fiber</h3>
      <p>
        Substitute <span class="mono">n₁² − n₂² = 2 n₁² Δ</span> into <span class="mono">NA = √(n₁² − n₂²)</span>:
      </p>
      <div class="eqRow">
        <div class="eqText" id="eq_na_delta">NA = √(2 n₁² Δ) = n₁ √(2Δ)</div>
        <button class="btn" data-copy="#eq_na_delta">Copy</button>
      </div>
      <p>
        <b>What did we do and why?</b> We expressed NA directly in terms of the given parameters <span class="mono">n₁</span> and <span class="mono">Δ</span>.
        This is the standard weak-guidance NA formula.
      </p>

      <h3>Step 4: Compute NA for the graded-index (parabolic p=2) fiber</h3>
      <p>
        A standard power-law graded-index core can be written (for <span class="mono">r ≤ a</span>) as
      </p>
      <div class="eqRow">
        <div class="eqText" id="eq_grad_profile">n(r) = n₁ √(1 − 2Δ (r/a)^p)  (core),  with p = 2 (parabolic)</div>
        <button class="btn" data-copy="#eq_grad_profile">Copy</button>
      </div>
      <p>
        At the core edge <span class="mono">r=a</span>, the index becomes
        <span class="mono">n(a) = n₁ √(1 − 2Δ) ≡ n₂</span>.
        The <b>maximum acceptance</b> is governed by whether rays can remain guided when they reach this edge region.
        Therefore the same boundary contrast applies, and the numerical aperture is still
      </p>
      <div class="eqRow">
        <div class="eqText" id="eq_na_grad">NA_grad = √(n₁² − n₂²) = n₁ √(2Δ)</div>
        <button class="btn" data-copy="#eq_na_grad">Copy</button>
      </div>
      <p>
        <b>What did we do and why?</b> We recognized that changing the interior shape of <span class="mono">n(r)</span> changes ray trajectories and dispersion,
        but the <i>maximum entrance angle</i> for guidance is still set by the contrast between the largest index encountered (near the axis)
        and the smallest index at the guiding boundary (the cladding/edge).
      </p>

      <h3>Step 5: Plug in numbers</h3>
      <p>Given <span class="mono">n₁ = 1.45</span>, <span class="mono">Δ = 0.01</span>:</p>
      <div class="eqRow">
        <div class="eqText" id="eq_numeric">NA = n₁ √(2Δ) = 1.45 √(0.02) ≈ 1.45 × 0.141421 ≈ 0.205</div>
        <button class="btn" data-copy="#eq_numeric">Copy</button>
      </div>
      <p>
        The acceptance half-angle in air is
        <span class="mono">θₐ = arcsin(NA) ≈ arcsin(0.205) ≈ 11.8°</span>.
      </p>

      <div class="callout ans">
        <strong>Final Answer (comparison)</strong>
        <div class="eqRow">
          <div class="eqText" id="final_answer">
Step-index:    NA_step = n₁ √(2Δ) ≈ 0.205  (for n₁=1.45, Δ=0.01)
Graded-index (parabolic p=2): NA_grad = √(n₁² − n₂²) = n₁ √(2Δ) ≈ 0.205
Conclusion: NA_step = NA_grad (same), because acceptance is set by the edge/boundary indices.
          </div>
          <button class="btn" data-copy="#final_answer">Copy</button>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><b>Units:</b> <span class="mono">n</span>, <span class="mono">Δ</span>, and <span class="mono">NA</span> are dimensionless → consistent.</li>
        <li><b>Limiting case Δ → 0:</b> <span class="mono">NA → 0</span> (no guidance/acceptance cone shrinks) → makes sense.</li>
        <li><b>Trend:</b> larger <span class="mono">n₁</span> or larger <span class="mono">Δ</span> increases NA → stronger guidance accepts more angles.</li>
        <li><b>Physical interpretation:</b> both fibers accept the same maximum input angles if they share the same <span class="mono">n₁</span> and <span class="mono">n₂</span> (hence the same contrast).</li>
      </ul>

      <p>
        <b>Connection to the diagram and plots:</b> the diagram shows the acceptance cone at the input face.
        The plots show (i) NA vs Δ (step and graded overlap), and (ii) the refractive-index profile <span class="mono">n(r)</span>,
        where the step profile and parabolic profile differ inside the core, yet share the same edge contrast that controls NA.
      </p>
    </section>

    <section id="deeper">
      <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

      <h3>Re-interpreting the final formula</h3>
      <p>
        <span class="mono">NA = n₁ √(2Δ)</span> tells you:
      </p>
      <ul>
        <li><b><span class="mono">n₁</span> sets an overall scale:</b> higher core index increases NA proportionally.</li>
        <li><b><span class="mono">Δ</span> sets contrast strength:</b> NA grows like <span class="mono">√Δ</span>, so doubling Δ does not double NA—it increases it by <span class="mono">√2</span>.</li>
        <li><b>Independence from grading exponent <span class="mono">p</span> (here):</b> for the same boundary indices, the maximum acceptance is the same. What <span class="mono">p</span> changes is how rays oscillate and how modal delays spread out.</li>
      </ul>

      <h3>How parameter changes affect the outcome (connect to the interactive plots)</h3>
      <ul>
        <li>Move the <b>Δ slider</b>: the NA curve rises as <span class="mono">√Δ</span>; the acceptance cone in the diagram widens.</li>
        <li>Move the <b>n₁ slider</b>: NA scales linearly with <span class="mono">n₁</span>.</li>
        <li>Change the <b>profile selector (step vs graded p)</b>: the <span class="mono">n(r)</span> curve changes shape (secondary plot), but NA vs Δ stays the same (main plot), emphasizing the “boundary-set acceptance” idea.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        One can derive NA from wave optics: guided modes require a propagation constant <span class="mono">β</span> satisfying
        <span class="mono">n₂ k₀ &lt; β &lt; n₁ k₀</span>, and the maximum transverse component corresponds to the difference
        <span class="mono">n₁² − n₂²</span>. This leads to the same <span class="mono">NA = √(n₁² − n₂²)</span> result for the acceptance.
      </p>

      <h3>Concept checks (quick self-test)</h3>
      <ul>
        <li><b>Q:</b> If Δ is quadrupled, what happens to NA? <b>A:</b> NA doubles because <span class="mono">NA ∝ √Δ</span>.</li>
        <li><b>Q:</b> Does a parabolic graded index always have a different NA than step-index? <b>A:</b> Not if <span class="mono">n₁</span> and <span class="mono">n₂</span> are the same; acceptance is boundary-set.</li>
        <li><b>Q:</b> What does grading improve if not NA? <b>A:</b> It mainly reduces intermodal dispersion (rays take more equal-time paths).</li>
        <li><b>Q:</b> If the fiber is immersed in water (<span class="mono">n₀≈1.33</span>), what changes? <b>A:</b> <span class="mono">NA = n₀ sin θₐ</span>; for the same internal indices, the acceptance angle in the external medium changes.</li>
      </ul>
    </section>

    <section id="guide">
      <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

      <h3>What each canvas shows</h3>
      <ul>
        <li><b>Diagram (top canvas):</b> fiber cross-section + input acceptance cone. The cone half-angle is <span class="mono">θₐ = arcsin(NA)</span>.</li>
        <li><b>Main plot:</b> <span class="mono">NA</span> versus <span class="mono">Δ</span>. Step-index and graded-index curves overlap when boundary indices match.</li>
        <li><b>Secondary plot:</b> refractive-index profile <span class="mono">n(r)</span> vs normalized radius <span class="mono">r/a</span>. Step profile is flat in the core; graded profile is smooth (parabolic when <span class="mono">p=2</span>).</li>
      </ul>

      <h3>Interactive controls</h3>
      <ul>
        <li><b>Slider Δ:</b> changes the index contrast. Expect NA and cone width to increase like <span class="mono">√Δ</span>.</li>
        <li><b>Slider n₁:</b> scales NA linearly and changes the index levels in the profile plot.</li>
        <li><b>Profile selector:</b> toggles step vs graded power-law. Expect the index profile shape to change, while the NA curves remain the same (for fixed <span class="mono">n₁</span> and <span class="mono">Δ</span>).</li>
      </ul>

      <p class="mini">
        Note: The plots use the same symbols as the derivation: <span class="mono">n₁</span>, <span class="mono">Δ</span>, <span class="mono">n₂ = n₁√(1−2Δ)</span>, and <span class="mono">NA = √(n₁²−n₂²) = n₁√(2Δ)</span>.
      </p>
    </section>
  </article>

  <aside>
    <section id="viz">
      <h2>Interactive Visuals</h2>

      <div class="controls" role="group" aria-label="Interactive Controls">
        <div class="ctrl">
          <label for="n1">
            <span>Core index <span class="mono">n₁</span></span>
            <span class="mono" id="n1Val">1.45</span>
          </label>
          <input id="n1" type="range" min="1.30" max="1.60" step="0.001" value="1.45" />
          <div class="readout">Using: <span class="mono">n₁ = <span id="n1Read">1.45</span></span></div>
        </div>

        <div class="ctrl">
          <label for="delta">
            <span>Relative index difference <span class="mono">Δ</span></span>
            <span class="mono" id="dVal">0.010</span>
          </label>
          <input id="delta" type="range" min="0.000" max="0.050" step="0.0005" value="0.010" />
          <div class="readout">Using: <span class="mono">Δ = <span id="dRead">0.010</span></span></div>
        </div>

        <div class="ctrl" style="grid-column: 1 / -1;">
          <label for="profile">
            <span>Index profile for secondary plot</span>
            <span class="mono" id="pLabel">graded p=2</span>
          </label>
          <select id="profile">
            <option value="step">step-index (core constant)</option>
            <option value="2" selected>graded-index (power-law p=2, parabolic)</option>
            <option value="4">graded-index (power-law p=4)</option>
            <option value="8">graded-index (power-law p=8)</option>
          </select>
          <div class="readout" id="derivedReadout"></div>
        </div>
      </div>

      <div class="vizWrap">
        <div class="vizCard">
          <div class="vizHeader">
            <div>
              <div class="title">Diagram: Acceptance Cone & Fiber Cross-Section</div>
              <div class="sub">Shows θₐ = arcsin(NA) for launch from air</div>
            </div>
          </div>
          <canvas id="cDiagram" aria-label="Fiber diagram"></canvas>
        </div>

        <div class="vizCard">
          <div class="vizHeader">
            <div>
              <div class="title">Main Plot: Numerical Aperture vs Δ</div>
              <div class="sub">Step-index and graded-index overlap for fixed n₁ and n₂</div>
            </div>
          </div>
          <canvas id="cMain" aria-label="NA versus Delta plot"></canvas>
        </div>

        <div class="vizCard">
          <div class="vizHeader">
            <div>
              <div class="title">Secondary Plot: Refractive Index Profile n(r)</div>
              <div class="sub">Compare step vs graded (power-law exponent p)</div>
            </div>
          </div>
          <canvas id="cProfile" aria-label="Index profile plot"></canvas>
        </div>
      </div>

      <p class="mini" style="margin-top:10px;">
        Tip: Try changing <span class="mono">Δ</span> and observe how the cone widens and NA rises like <span class="mono">√Δ</span>.
      </p>
    </section>
  </aside>
</main>

<footer>
  <p>
    Built with vanilla HTML/CSS/JS. No external libraries. High-DPI canvas rendering included.
  </p>
</footer>

<script>
/* =========================
   Utilities: copy buttons
========================= */
(function(){
  function copyText(text){
    return navigator.clipboard.writeText(text);
  }
  document.addEventListener('click', (e) => {
    const btn = e.target.closest('.btn');
    if(!btn) return;
    const sel = btn.getAttribute('data-copy');
    if(!sel) return;
    const el = document.querySelector(sel);
    if(!el) return;
    const text = el.innerText.trim();
    btn.textContent = "Copied!";
    copyText(text).catch(()=>{ /* ignore */ }).finally(()=>{
      setTimeout(()=>btn.textContent="Copy", 900);
    });
  });
})();

/* =========================
   Math helpers
========================= */
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function niceTicks(min,max,approxCount){
  const span = max-min;
  if(span<=0) return {step:1, ticks:[min]};
  const rawStep = span/Math.max(2,approxCount);
  const mag = Math.pow(10, Math.floor(Math.log10(rawStep)));
  const norm = rawStep/mag;
  let step;
  if(norm<1.5) step=1*mag;
  else if(norm<3.5) step=2*mag;
  else if(norm<7.5) step=5*mag;
  else step=10*mag;
  const start = Math.ceil(min/step)*step;
  const ticks=[];
  for(let t=start; t<=max+1e-12; t+=step) ticks.push(t);
  return {step, ticks};
}
function fmt(x, digits=3){
  if(!isFinite(x)) return "—";
  return x.toFixed(digits);
}

/* =========================
   Fiber formulas (weak guidance)
   Δ defined as (n1^2 - n2^2)/(2 n1^2)
========================= */
function n2From(n1, Delta){
  // n2 = n1 * sqrt(1 - 2Δ)
  return n1 * Math.sqrt(Math.max(0, 1 - 2*Delta));
}
function NAFrom(n1, Delta){
  // NA = sqrt(n1^2 - n2^2) = n1*sqrt(2Δ)
  return n1 * Math.sqrt(Math.max(0, 2*Delta));
}
function thetaAFromNA(NA){
  // acceptance half-angle in air (degrees)
  const s = clamp(NA, 0, 1);
  return Math.asin(s) * 180/Math.PI;
}
function nProfile(rOverA, n1, Delta, profile){
  const n2 = n2From(n1, Delta);
  if(rOverA<=1){
    if(profile==="step"){
      return n1;
    }else{
      const p = parseFloat(profile);
      const x = Math.pow(clamp(rOverA,0,1), p);
      return n1 * Math.sqrt(Math.max(0, 1 - 2*Delta*x));
    }
  }else{
    return n2;
  }
}

/* =========================
   Canvas plotting engine
========================= */
function setupCanvas(canvas){
  const ctx = canvas.getContext('2d');
  function resize(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(280, rect.width);
    const h = rect.height;
    canvas.width = Math.floor(w*dpr);
    canvas.height = Math.floor(h*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return {w, h, dpr};
  }
  return {ctx, resize};
}

function drawAxes(ctx, W, H, plot, opts){
  const {
    xMin, xMax, yMin, yMax,
    xLabel, yLabel, title,
    xTickCount=6, yTickCount=6,
    legend=[]
  } = opts;

  // Background
  ctx.clearRect(0,0,W,H);

  // Margins
  const m = {l:56, r:16, t:34, b:44};
  const pw = W - m.l - m.r;
  const ph = H - m.t - m.b;

  // helpers
  const X = (x)=> m.l + (x-xMin)/(xMax-xMin)*pw;
  const Y = (y)=> m.t + (yMax-y)/(yMax-yMin)*ph;

  // Title
  ctx.save();
  ctx.fillStyle = "rgba(234,240,255,.95)";
  ctx.font = "700 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText(title, m.l, 18);
  ctx.restore();

  // Ticks & grid
  const xt = niceTicks(xMin, xMax, xTickCount);
  const yt = niceTicks(yMin, yMax, yTickCount);

  ctx.save();
  ctx.lineWidth = 1;

  // gridlines
  ctx.strokeStyle = "rgba(255,255,255,.08)";
  xt.ticks.forEach(t=>{
    const x = X(t);
    ctx.beginPath();
    ctx.moveTo(x, m.t);
    ctx.lineTo(x, m.t+ph);
    ctx.stroke();
  });
  yt.ticks.forEach(t=>{
    const y = Y(t);
    ctx.beginPath();
    ctx.moveTo(m.l, y);
    ctx.lineTo(m.l+pw, y);
    ctx.stroke();
  });

  // axes
  ctx.strokeStyle = "rgba(255,255,255,.20)";
  ctx.beginPath();
  ctx.moveTo(m.l, m.t);
  ctx.lineTo(m.l, m.t+ph);
  ctx.lineTo(m.l+pw, m.t+ph);
  ctx.stroke();

  // tick labels
  ctx.fillStyle = "rgba(183,195,234,.95)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";

  xt.ticks.forEach(t=>{
    const x = X(t);
    ctx.beginPath();
    ctx.moveTo(x, m.t+ph);
    ctx.lineTo(x, m.t+ph+6);
    ctx.strokeStyle = "rgba(255,255,255,.20)";
    ctx.stroke();

    const s = (Math.abs(t) < 1e-6) ? "0" : (Math.abs(t) < 1 ? t.toFixed(3) : t.toFixed(2));
    const tw = ctx.measureText(s).width;
    ctx.fillText(s, x - tw/2, m.t+ph+20);
  });

  yt.ticks.forEach(t=>{
    const y = Y(t);
    ctx.beginPath();
    ctx.moveTo(m.l-6, y);
    ctx.lineTo(m.l, y);
    ctx.strokeStyle = "rgba(255,255,255,.20)";
    ctx.stroke();

    const s = (Math.abs(t) < 1e-6) ? "0" : (Math.abs(t) < 1 ? t.toFixed(3) : t.toFixed(2));
    const tw = ctx.measureText(s).width;
    ctx.fillText(s, m.l-10 - tw, y+4);
  });

  // axis labels
  ctx.fillStyle = "rgba(234,240,255,.90)";
  ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  // x label
  const xlw = ctx.measureText(xLabel).width;
  ctx.fillText(xLabel, m.l + (pw - xlw)/2, H - 12);
  // y label (rotated)
  ctx.save();
  ctx.translate(14, m.t + ph/2);
  ctx.rotate(-Math.PI/2);
  const ylw = ctx.measureText(yLabel).width;
  ctx.fillText(yLabel, -ylw/2, 0);
  ctx.restore();

  // legend
  if(legend.length){
    const lx = m.l + 8;
    const ly = m.t + 8;
    ctx.save();
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    legend.forEach((it,i)=>{
      const y = ly + i*18;
      ctx.strokeStyle = it.stroke;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(lx, y);
      ctx.lineTo(lx+20, y);
      ctx.stroke();
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.fillText(it.label, lx+28, y+4);
    });
    ctx.restore();
  }

  ctx.restore();

  return {m, pw, ph, X, Y};
}

function drawPolyline(ctx, mapper, xs, ys, strokeStyle, lineWidth=2){
  ctx.save();
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = lineWidth;
  ctx.lineJoin = "round";
  ctx.lineCap = "round";
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const x = mapper.X(xs[i]);
    const y = mapper.Y(ys[i]);
    if(i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.restore();
}

/* =========================
   Draw diagram: acceptance cone + fiber
========================= */
function drawDiagram(ctx, W, H, state){
  const {n1, Delta} = state;
  const n2 = n2From(n1, Delta);
  const NA = NAFrom(n1, Delta);
  const theta = thetaAFromNA(NA);

  // background
  ctx.clearRect(0,0,W,H);

  // layout
  const pad = 14;
  const cx = W*0.63, cy = H*0.56;
  const coreR = Math.min(W,H)*0.26;
  const cladR = coreR*1.55;

  // subtle glow
  ctx.save();
  ctx.fillStyle = "rgba(119,167,255,.06)";
  ctx.beginPath();
  ctx.arc(cx, cy, cladR*1.18, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // cladding circle
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.22)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(cx, cy, cladR, 0, Math.PI*2);
  ctx.stroke();
  ctx.restore();

  // core circle
  ctx.save();
  ctx.fillStyle = "rgba(109,240,194,.10)";
  ctx.beginPath();
  ctx.arc(cx, cy, coreR, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = "rgba(109,240,194,.55)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(cx, cy, coreR, 0, Math.PI*2);
  ctx.stroke();
  ctx.restore();

  // labels
  ctx.save();
  ctx.fillStyle = "rgba(234,240,255,.95)";
  ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText("cladding (n₂)", cx - 40, cy - cladR - 10);
  ctx.fillText("core (max n₁)", cx - 36, cy - coreR - 10);

  ctx.fillStyle = "rgba(183,195,234,.95)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
  ctx.fillText(`n₁ = ${fmt(n1,3)}   Δ = ${fmt(Delta,4)}`, pad, 18);
  ctx.fillText(`n₂ = n₁√(1−2Δ) = ${fmt(n2,3)}`, pad, 38);
  ctx.fillText(`NA = n₁√(2Δ) = ${fmt(NA,3)}   θₐ ≈ ${fmt(theta,1)}°`, pad, 58);
  ctx.restore();

  // acceptance cone at left: input plane at x = W*0.16
  const ix = W*0.18;
  const iy = H*0.56;
  const coneLen = W*0.30;
  const th = Math.asin(clamp(NA,0,1));
  const yTop = iy - Math.tan(th)*coneLen;
  const yBot = iy + Math.tan(th)*coneLen;

  // input face line
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.22)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(ix, iy - H*0.30);
  ctx.lineTo(ix, iy + H*0.30);
  ctx.stroke();

  // cone lines
  ctx.strokeStyle = "rgba(119,167,255,.75)";
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(ix, iy);
  ctx.lineTo(ix+coneLen, yTop);
  ctx.moveTo(ix, iy);
  ctx.lineTo(ix+coneLen, yBot);
  ctx.stroke();

  // central axis
  ctx.strokeStyle = "rgba(255,255,255,.18)";
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.moveTo(ix, iy);
  ctx.lineTo(ix+coneLen*1.08, iy);
  ctx.stroke();
  ctx.setLineDash([]);

  // ray inside (example)
  const rayX0 = ix+coneLen*0.15, rayY0 = iy;
  const rayX1 = cx - coreR*0.2, rayY1 = iy - Math.tan(th*0.7)*(cx - rayX0);
  ctx.strokeStyle = "rgba(109,240,194,.85)";
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(rayX0, rayY0);
  ctx.lineTo(rayX1, rayY1);
  ctx.stroke();

  // angle arc
  const arcR = 36;
  ctx.strokeStyle = "rgba(255,204,102,.70)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(ix, iy, arcR, -th, 0);
  ctx.stroke();
  ctx.fillStyle = "rgba(255,204,102,.90)";
  ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText("θₐ", ix + arcR*0.58, iy - arcR*0.20);

  // labels
  ctx.fillStyle = "rgba(183,195,234,.95)";
  ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText("input face", ix - 26, iy + H*0.30 + 18);
  ctx.fillText("acceptance cone in air", ix + 14, yBot + 18);

  ctx.restore();
}

/* =========================
   Plot 1: NA vs Delta
========================= */
function drawMainPlot(ctx, W, H, state){
  const {n1, Delta} = state;

  const xMin = 0, xMax = 0.05;
  const yMin = 0, yMax = n1*Math.sqrt(2*xMax);

  const mapper = drawAxes(ctx, W, H, null, {
    xMin, xMax, yMin, yMax,
    xLabel: "Δ (dimensionless)",
    yLabel: "NA (dimensionless)",
    title: "Numerical Aperture vs Δ (launch from air)",
    legend: [
      {label: "step-index", stroke: "rgba(119,167,255,.9)"},
      {label: "graded-index (same boundary)", stroke: "rgba(109,240,194,.9)"}
    ]
  });

  // curves
  const N = 260;
  const xs = [];
  const ys = [];
  const ys2 = [];
  for(let i=0;i<=N;i++){
    const d = xMin + (xMax-xMin)*i/N;
    xs.push(d);
    ys.push(NAFrom(n1, d));
    ys2.push(NAFrom(n1, d)); // identical under these assumptions
  }
  drawPolyline(ctx, mapper, xs, ys, "rgba(119,167,255,.9)", 2.6);
  // draw graded on top with slight dash to show coincidence
  ctx.save();
  ctx.setLineDash([7,6]);
  drawPolyline(ctx, mapper, xs, ys2, "rgba(109,240,194,.9)", 2.6);
  ctx.restore();

  // highlight current Delta point
  const NAcur = NAFrom(n1, Delta);
  const x = mapper.X(Delta), y = mapper.Y(NAcur);
  ctx.save();
  ctx.fillStyle = "rgba(255,204,102,.95)";
  ctx.strokeStyle = "rgba(255,204,102,.95)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x, y, 4.6, 0, Math.PI*2);
  ctx.fill();

  // annotation box
  const label = `Δ=${fmt(Delta,3)}, NA≈${fmt(NAcur,3)}`;
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
  const tw = ctx.measureText(label).width;
  const bx = clamp(x + 10, mapper.m.l + 8, W - tw - 26);
  const by = clamp(y - 24, mapper.m.t + 8, mapper.m.t + mapper.ph - 28);
  ctx.fillStyle = "rgba(17,28,58,.82)";
  ctx.strokeStyle = "rgba(255,255,255,.14)";
  ctx.beginPath();
  ctx.roundRect(bx-8, by-14, tw+16, 24, 10);
  ctx.fill();
  ctx.stroke();
  ctx.fillStyle = "rgba(234,240,255,.95)";
  ctx.fillText(label, bx, by+3);
  ctx.restore();
}

/* =========================
   Plot 2: n(r) profile
========================= */
function drawProfilePlot(ctx, W, H, state){
  const {n1, Delta, profile} = state;
  const n2 = n2From(n1, Delta);

  // radius range a bit beyond core edge
  const xMin = 0, xMax = 1.2;
  const yMin = Math.min(n2, n1) - 0.03;
  const yMax = Math.max(n2, n1) + 0.03;

  const mapper = drawAxes(ctx, W, H, null, {
    xMin, xMax, yMin, yMax,
    xLabel: "r/a (dimensionless)",
    yLabel: "n(r) (dimensionless)",
    title: "Refractive-Index Profile n(r)",
    legend: [
      {label: profile==="step" ? "step-index" : `graded-index (p=${profile})`, stroke: "rgba(109,240,194,.9)"},
      {label: "cladding level n₂", stroke: "rgba(119,167,255,.55)"}
    ]
  });

  // curve
  const N=320;
  const xs=[], ys=[];
  for(let i=0;i<=N;i++){
    const r = xMin + (xMax-xMin)*i/N;
    xs.push(r);
    ys.push(nProfile(r, n1, Delta, profile));
  }
  drawPolyline(ctx, mapper, xs, ys, "rgba(109,240,194,.9)", 2.6);

  // cladding line
  const xs2=[xMin,xMax], ys2=[n2,n2];
  ctx.save();
  ctx.setLineDash([6,6]);
  drawPolyline(ctx, mapper, xs2, ys2, "rgba(119,167,255,.55)", 2.2);
  ctx.restore();

  // mark core edge at r/a=1
  const xEdge = mapper.X(1);
  ctx.save();
  ctx.strokeStyle = "rgba(255,204,102,.70)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(xEdge, mapper.m.t);
  ctx.lineTo(xEdge, mapper.m.t + mapper.ph);
  ctx.stroke();
  ctx.fillStyle = "rgba(255,204,102,.90)";
  ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText("core edge r=a", xEdge - 36, mapper.m.t + 16);
  ctx.restore();

  // annotate n1 and n2
  ctx.save();
  ctx.fillStyle = "rgba(234,240,255,.92)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
  ctx.fillText(`n₁≈${fmt(n1,3)}`, mapper.m.l + 10, mapper.Y(n1) - 6);
  ctx.fillText(`n₂≈${fmt(n2,3)}`, mapper.m.l + 10, mapper.Y(n2) + 14);
  ctx.restore();
}

/* =========================
   State + update loop
========================= */
const elN1 = document.getElementById('n1');
const elD = document.getElementById('delta');
const elProfile = document.getElementById('profile');

const n1Val = document.getElementById('n1Val');
const dVal = document.getElementById('dVal');
const n1Read = document.getElementById('n1Read');
const dRead = document.getElementById('dRead');
const pLabel = document.getElementById('pLabel');
const derivedReadout = document.getElementById('derivedReadout');

const cDiagram = document.getElementById('cDiagram');
const cMain = document.getElementById('cMain');
const cProfile = document.getElementById('cProfile');

const D = setupCanvas(cDiagram);
const M = setupCanvas(cMain);
const P = setupCanvas(cProfile);

function getState(){
  const n1 = parseFloat(elN1.value);
  const Delta = parseFloat(elD.value);
  const profile = elProfile.value; // "step" or "2" ...
  return {n1, Delta, profile};
}

function updateReadouts(state){
  const {n1, Delta, profile} = state;
  n1Val.textContent = fmt(n1,3);
  dVal.textContent = fmt(Delta,3);
  n1Read.textContent = fmt(n1,3);
  dRead.textContent = fmt(Delta,3);
  pLabel.textContent = (profile==="step") ? "step" : `graded p=${profile}`;
  const n2 = n2From(n1, Delta);
  const NA = NAFrom(n1, Delta);
  const theta = thetaAFromNA(NA);
  derivedReadout.innerHTML =
    `<span class="mono">n₂ = n₁√(1−2Δ) = ${fmt(n2,3)}</span><br>`+
    `<span class="mono">NA = n₁√(2Δ) = ${fmt(NA,3)}</span><br>`+
    `<span class="mono">θₐ = arcsin(NA) ≈ ${fmt(theta,1)}°</span>`;
}

function redraw(){
  const state = getState();
  updateReadouts(state);

  const dsz = D.resize();
  const msz = M.resize();
  const psz = P.resize();

  drawDiagram(D.ctx, dsz.w, dsz.h, state);
  drawMainPlot(M.ctx, msz.w, msz.h, state);
  drawProfilePlot(P.ctx, psz.w, psz.h, state);
}

['input','change'].forEach(evt=>{
  elN1.addEventListener(evt, redraw);
  elD.addEventListener(evt, redraw);
  elProfile.addEventListener(evt, redraw);
});
window.addEventListener('resize', () => { redraw(); });

// polyfill for roundRect if missing (older browsers)
if(!CanvasRenderingContext2D.prototype.roundRect){
  CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    this.beginPath();
    this.moveTo(x+r, y);
    this.arcTo(x+w, y, x+w, y+h, r);
    this.arcTo(x+w, y+h, x, y+h, r);
    this.arcTo(x, y+h, x, y, r);
    this.arcTo(x, y, x+w, y, r);
    this.closePath();
    return this;
  };
}

redraw();
</script>
</body>
</html>
