<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Coupling Efficiency into an Optical Fiber (NA-squared Law)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101833;
      --panel2:#0f1730;
      --text:#e9ecff;
      --muted:#b8c0ffcc;
      --faint:#b8c0ff55;
      --accent:#8be9fd;
      --accent2:#a7ff83;
      --warn:#ffb86c;
      --bad:#ff5555;
      --good:#50fa7b;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 800px at 20% 0%, #19255c 0%, rgba(25,37,92,0) 60%),
                  radial-gradient(900px 700px at 90% 20%, #1b4f5a 0%, rgba(27,79,90,0) 55%),
                  linear-gradient(180deg, #070a14 0%, #0b1020 35%, #070a14 100%);
      color:var(--text);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding: 28px 18px 8px 18px;
      max-width: 1180px;
      margin: 0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:18px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns:1fr}
    }
    .titlecard{
      background: linear-gradient(135deg, rgba(139,233,253,.14), rgba(167,255,131,.10));
      border:1px solid rgba(184,192,255,.18);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:18px 18px 16px 18px;
      overflow:hidden;
      position:relative;
    }
    .titlecard:before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(700px 180px at 20% 20%, rgba(139,233,253,.25), transparent 60%),
                  radial-gradient(550px 160px at 85% 60%, rgba(167,255,131,.18), transparent 55%);
      pointer-events:none;
      filter: blur(0px);
      opacity:.9;
    }
    .titlecard > *{position:relative}
    h1{
      margin:0 0 8px 0;
      font-size: clamp(1.4rem, 2.6vw, 2.1rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size: 0.98rem;
      max-width: 70ch;
    }
    .mini-meta{
      margin-top:12px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      color:var(--muted);
      font-size:.92rem;
    }
    .pill{
      border:1px solid rgba(184,192,255,.20);
      background: rgba(16,24,51,.55);
      padding:6px 10px;
      border-radius:999px;
      display:inline-flex;
      gap:8px;
      align-items:center;
      backdrop-filter: blur(6px);
    }
    .dot{width:8px;height:8px;border-radius:50%;}
    .dot.a{background:var(--accent)}
    .dot.b{background:var(--accent2)}
    .dot.c{background:var(--warn)}
    main{
      max-width:1180px;
      margin: 0 auto;
      padding: 10px 18px 40px 18px;
      display:grid;
      grid-template-columns: 300px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
    }
    nav#toc{
      position: sticky;
      top: 12px;
      align-self:start;
      background: rgba(16,24,51,.72);
      border:1px solid rgba(184,192,255,.18);
      border-radius: var(--radius);
      padding: 14px 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      max-height: calc(100vh - 24px);
      overflow:auto;
    }
    nav#toc h2{
      font-size:1rem;
      margin:0 0 10px 0;
      color:var(--text);
      letter-spacing:.2px;
    }
    .toclink{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      color:var(--muted);
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:.93rem;
    }
    .toclink:hover{
      background: rgba(139,233,253,.08);
      border-color: rgba(139,233,253,.22);
      transform: translateY(-1px);
      color:var(--text);
      text-decoration:none;
    }
    article{
      display:flex;
      flex-direction:column;
      gap:18px;
    }
    section{
      background: rgba(16,24,51,.62);
      border:1px solid rgba(184,192,255,.16);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px 16px 14px 16px;
      backdrop-filter: blur(8px);
    }
    section h2{
      margin:0 0 10px 0;
      font-size:1.12rem;
      letter-spacing:.2px;
    }
    section h3{
      margin:14px 0 8px 0;
      font-size:1.02rem;
      color: var(--text);
    }
    p{margin:8px 0; color: var(--text)}
    ul{margin:8px 0 8px 18px; color: var(--text)}
    li{margin:6px 0}
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 820px){
      .grid2{grid-template-columns:1fr}
    }
    .callout{
      background: rgba(11,16,32,.65);
      border:1px solid rgba(184,192,255,.16);
      border-left: 4px solid rgba(139,233,253,.8);
      border-radius: 14px;
      padding: 12px 12px;
      margin: 10px 0;
    }
    .callout.warn{border-left-color: rgba(255,184,108,.9)}
    .callout.bad{border-left-color: rgba(255,85,85,.9)}
    .callout.good{border-left-color: rgba(80,250,123,.9)}
    .callout h4{
      margin:0 0 6px 0;
      font-size:.98rem;
      letter-spacing:.15px;
    }
    .eq{
      font-family: var(--mono);
      font-size: .95rem;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(184,192,255,.16);
      border-radius: 12px;
      padding: 10px 10px;
      overflow:auto;
      position:relative;
    }
    .eq .copybtn{
      position:absolute;
      top:8px;
      right:8px;
      border:1px solid rgba(184,192,255,.22);
      background: rgba(16,24,51,.75);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 999px;
      cursor:pointer;
      font-size:.82rem;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .eq .copybtn:hover{
      transform: translateY(-1px);
      background: rgba(139,233,253,.10);
      border-color: rgba(139,233,253,.35);
    }
    .eq small{color:var(--muted)}
    .kpiRow{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:12px;
      margin-top:10px;
    }
    @media (max-width: 820px){
      .kpiRow{grid-template-columns:1fr}
    }
    .kpi{
      background: rgba(11,16,32,.55);
      border:1px solid rgba(184,192,255,.16);
      border-radius: 14px;
      padding: 12px 12px;
    }
    .kpi .label{color:var(--muted); font-size:.88rem}
    .kpi .value{font-size:1.18rem; margin-top:4px; font-family: var(--mono)}
    .kpi .hint{color:var(--muted); font-size:.86rem; margin-top:6px}
    figure{
      margin:0;
      padding:0;
    }
    .vizWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .canvasCard{
      background: rgba(11,16,32,.55);
      border:1px solid rgba(184,192,255,.16);
      border-radius: 16px;
      padding: 12px 12px;
      overflow:hidden;
    }
    .canvasHeader{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:12px;
      margin-bottom:8px;
    }
    .canvasHeader .ctitle{
      font-size: .98rem;
      margin:0;
    }
    .canvasHeader .cmeta{
      color: var(--muted);
      font-size:.86rem;
      white-space:nowrap;
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid rgba(184,192,255,.10);
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    @media (max-width: 980px){
      .controls{grid-template-columns:1fr}
    }
    .control{
      background: rgba(11,16,32,.55);
      border:1px solid rgba(184,192,255,.16);
      border-radius: 14px;
      padding: 10px 10px 8px 10px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      color: var(--muted);
      font-size:.88rem;
      margin-bottom:6px;
    }
    input[type="range"]{width:100%}
    .readout{font-family:var(--mono); color:var(--text)}
    .btnRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    button.action{
      border:1px solid rgba(184,192,255,.22);
      background: rgba(16,24,51,.75);
      color: var(--text);
      padding: 9px 12px;
      border-radius: 999px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:.9rem;
    }
    button.action:hover{
      transform: translateY(-1px);
      background: rgba(167,255,131,.10);
      border-color: rgba(167,255,131,.35);
    }
    footer{
      max-width:1180px;
      margin: 0 auto;
      padding: 10px 18px 30px 18px;
      color: var(--muted);
      font-size:.9rem;
    }
    .printNote{
      display:none;
    }
    @media print{
      body{background:white;color:black}
      nav#toc{display:none}
      section{break-inside: avoid; box-shadow:none; background:white; border:1px solid #ddd}
      .titlecard{box-shadow:none; background:white; border:1px solid #ddd}
      .printNote{display:block;color:#444}
      canvas{border:1px solid #ddd}
      .eq{background:#f7f7f7;border:1px solid #ddd}
      .eq .copybtn{display:none}
      button.action{display:none}
    }
  </style>
</head>
<body>
<header>
  <div class="hero">
    <div class="titlecard">
      <h1>Coupling Efficiency into a Step-Index Fiber: Why It Scales as NA²</h1>
      <p class="subtitle">
        We derive the <span class="muted">NA-squared coupling law</span> for a cosine-emitting source and then compute the
        numerical aperture and coupling efficiency for a planar LED bonded to a fiber.
      </p>
      <div class="mini-meta">
        <span class="pill"><span class="dot a"></span>Radiometry → solid-angle integration</span>
        <span class="pill"><span class="dot b"></span>Waveguide acceptance cone (NA)</span>
        <span class="pill"><span class="dot c"></span>Bonded source index reduces capture angle</span>
      </div>
      <p class="printNote">Print tip: interactive plots won’t update on paper; values are summarized in the Final Answer box.</p>
    </div>

    <div class="titlecard" style="background:linear-gradient(135deg, rgba(255,184,108,.14), rgba(139,233,253,.10));">
      <h2 style="margin:0 0 10px 0; font-size:1.08rem;">Quick Summary</h2>
      <ul style="margin:0 0 0 18px;">
        <li>We integrate the source’s <span class="muted">power per unit solid angle</span> over the fiber’s acceptance cone.</li>
        <li>Given emission: <span class="muted">I(θ) = (P₀/π) cos θ</span> [W/sr], axis aligned with fiber axis.</li>
        <li>Acceptance half-angle in the launch medium (index <span class="muted">n₀</span>): <span class="muted">sin θ<sub>max</sub> = NA / n₀</span>.</li>
        <li>Solid-angle element: <span class="muted">dΩ = 2π sinθ dθ</span> (azimuthal symmetry).</li>
        <li>Result (symbolic): <span class="muted">P = P₀ sin²θ<sub>max</sub></span> ⇒ <span class="muted">η ≡ P/P₀ = (NA/n₀)²</span>.</li>
        <li>For air (n₀=1): <span class="muted">η = NA²</span> and <span class="muted">P = NA² P₀</span>.</li>
        <li>For a step-index fiber: <span class="muted">NA = √(n₁² − n₂²)</span> (core n₁, cladding n₂).</li>
        <li>Numeric (given n₁=1.46, n₂=1.455, bonded LED n₀=n<sub>s</sub>=3.5): <span class="muted">NA≈0.1207</span>, <span class="muted">η≈1.19×10⁻³ ≈ 0.119%</span>.</li>
      </ul>
    </div>
  </div>
</header>

<main>
  <nav id="toc" aria-label="Table of contents">
    <h2>On this page</h2>
    <a class="toclink" href="#primer">PART 0 — Concept Primer</a>
    <a class="toclink" href="#analysis">PART 1 — Problem Analysis</a>
    <a class="toclink" href="#strategy">PART 2 — Strategy & Tips</a>
    <a class="toclink" href="#solution">PART 3 — Full Solution</a>
    <a class="toclink" href="#deeper">PART 4 — Deeper Understanding</a>
    <a class="toclink" href="#vizguide">PART 5 — Visualization Guide</a>
    <a class="toclink" href="#interactive">Interactive Visuals</a>
  </nav>

  <article>
    <section id="primer">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="grid2">
        <div>
          <h3>Core definitions (symbols & units)</h3>
          <ul>
            <li><b>P₀</b> — total optical power emitted by the source [W].</li>
            <li><b>I(θ)</b> — power per unit solid angle in direction θ (radiant intensity) [W/sr].</li>
            <li><b>Ω</b> — solid angle [sr].</li>
            <li><b>θ</b> — polar angle from the fiber axis (θ=0 is along the axis) [rad].</li>
            <li><b>NA</b> — numerical aperture (acceptance “strength”) [dimensionless].</li>
            <li><b>n₀</b> — refractive index of the medium where rays originate (air, glue, LED material) [dimensionless].</li>
            <li><b>n₁, n₂</b> — core and cladding indices of a step-index fiber [dimensionless].</li>
          </ul>

          <div class="callout">
            <h4>Physical meaning</h4>
            <p class="muted">
              The fiber only accepts rays whose directions lie within a cone around its axis.
              Coupling efficiency is “how much of the source’s angular emission fits inside that cone”.
            </p>
          </div>
        </div>

        <div>
          <h3>Key principles and validity</h3>
          <ul>
            <li><b>Radiometry:</b> collected power is an integral of intensity over the accepted solid angle: <span class="muted">P = ∫ I(θ) dΩ</span>.</li>
            <li><b>Geometric optics acceptance:</b> for a step-index fiber, paraxial ray acceptance in an external medium of index n₀ obeys
              <span class="muted">n₀ sinθ<sub>max</sub> = NA</span>.</li>
            <li><b>Step-index NA:</b> <span class="muted">NA = √(n₁² − n₂²)</span> (derived from total internal reflection conditions / ray model).</li>
          </ul>

          <div class="callout warn">
            <h4>Assumptions (common in “coupling efficiency” problems)</h4>
            <ul>
              <li>Axis alignment: source axis and fiber axis are the same.</li>
              <li>Large fiber area compared to source area (so no spatial overlap loss).</li>
              <li>No Fresnel reflection, scattering, or absorption at the interface (ideal bonding).</li>
              <li>Ray/solid-angle model (good when the source is not diffraction-limited and dimensions are large compared to wavelength).</li>
            </ul>
          </div>
        </div>
      </div>

      <h3>Common models/approximations and why we use them</h3>
      <ul>
        <li><b>Lambertian-like emission:</b> the given <span class="muted">cosθ</span> dependence is typical of planar emitters; it makes the angular integral analytic.</li>
        <li><b>Acceptance cone model:</b> the fiber acts like an “angular filter”: accept all rays with θ ≤ θ<sub>max</sub>, reject others.</li>
        <li><b>Neglecting polarization:</b> NA-based acceptance is largely polarization-independent in the simple ray picture.</li>
      </ul>

      <h3>Mini intuition examples (quick)</h3>
      <ul>
        <li>If the acceptance cone is <b>very narrow</b> (small θ<sub>max</sub>), the accepted solid angle scales like θ<sub>max</sub><sup>2</sup>, so efficiency is tiny.</li>
        <li>If you place the source in a <b>higher-index medium</b> (larger n₀), the same NA corresponds to a <b>smaller θ<sub>max</sub></b> because sinθ<sub>max</sub>=NA/n₀ → less capture.</li>
      </ul>

      <div class="callout bad">
        <h4>What to watch for (pitfalls)</h4>
        <ul>
          <li>Confusing <b>NA</b> with <b>sinθ</b> without checking the launch medium index n₀.</li>
          <li>Forgetting the solid-angle element: <span class="muted">dΩ = 2π sinθ dθ</span> (not just dθ).</li>
          <li>Using <span class="muted">NA = n₁ sinθ</span> incorrectly for a fiber—use <span class="muted">NA = √(n₁² − n₂²)</span> for step-index.</li>
        </ul>
      </div>
    </section>

    <section id="analysis">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Problem restatement (in plain words)</h3>
      <p>
        A light source emits total power <b>P₀</b> with angular distribution
        <span class="muted">I(θ) = (P₀/π) cosθ</span>, where I is power per unit solid angle in direction θ from the fiber axis.
        A fiber only accepts light within its acceptance cone. (a) Show the collected power is <span class="muted">P = (NA)² P₀</span> (for air launch), so efficiency is <span class="muted">(NA)²</span>.
        (b) If the source is a planar LED (index n<sub>s</sub>) bonded to the fiber (and fiber area is larger than emitting area),
        compute the fiber’s NA and coupling efficiency for given indices.
      </p>

      <div class="grid2">
        <div>
          <h3>Given</h3>
          <ul>
            <li>Angular intensity: <span class="muted">I(θ) = (P₀/π) cosθ</span> [W/sr].</li>
            <li>Step-index fiber indices (part b): <span class="muted">n₁ = 1.46</span>, <span class="muted">n₂ = 1.455</span>.</li>
            <li>LED refractive index (bonded launch medium): <span class="muted">n<sub>s</sub> = 3.5</span>.</li>
            <li>Fiber cross-sectional area larger than LED emitting area (no area mismatch loss).</li>
          </ul>
        </div>
        <div>
          <h3>Unknowns / targets</h3>
          <ul>
            <li>(a) Prove collected power: <span class="muted">P = NA² P₀</span> (air launch).</li>
            <li>(a) Coupling efficiency: <span class="muted">η = P/P₀ = NA²</span> (air launch).</li>
            <li>(b) Compute: <span class="muted">NA = √(n₁² − n₂²)</span> (numeric).</li>
            <li>(b) Compute coupling efficiency for bonded LED launch medium (index n<sub>s</sub>).</li>
          </ul>
        </div>
      </div>

      <h3>Relevant physics (and why it applies)</h3>
      <ul>
        <li><b>Radiant intensity integration:</b> Because I(θ) is already “power per steradian”, total captured power is the integral over the accepted solid angle.</li>
        <li><b>Acceptance cone from NA:</b> NA encodes the maximum launch angle the fiber can guide (ray model). This directly sets the integration limit θ<sub>max</sub>.</li>
      </ul>

      <div class="callout">
        <h4>Assumptions made explicitly</h4>
        <ul>
          <li>Axisymmetry of the emission about the fiber axis.</li>
          <li>Perfect alignment and bonding; ignore Fresnel reflection.</li>
          <li>Step-index approximation; NA constant with angle (no graded-index effects).</li>
        </ul>
      </div>

      <h3>Possible approaches (2–3) and comparison</h3>
      <ul>
        <li><b>Solid-angle integration (best here):</b> Directly integrate <span class="muted">P = ∫ I(θ) dΩ</span>. Pros: short, exact, matches given I(θ). Cons: requires comfort with solid angle.</li>
        <li><b>Etendue / radiance conservation:</b> Use invariance of A·Ω (or n²A·Ω). Pros: powerful for more complex optics. Cons: overkill for this problem; must be careful with n² factors.</li>
        <li><b>Ray counting / probability:</b> Interpret emission as angular probability density. Pros: intuitive. Cons: essentially the same math as solid-angle integration.</li>
      </ul>
      <p><b>Chosen approach:</b> Solid-angle integration, because the problem literally gives I(θ) in units of W/sr and asks for captured power.</p>
    </section>

    <section id="strategy">
      <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

      <ol style="margin:8px 0 8px 18px;">
        <li>
          <b>Identify θ<sub>max</sub></b> (goal: set integration limit).<br/>
          Tool: <span class="muted">n₀ sinθ<sub>max</sub> = NA</span>.<br/>
          Meaning: acceptance cone boundary.
        </li>
        <li>
          <b>Write the solid-angle element</b> (goal: integrate correctly).<br/>
          Tool: <span class="muted">dΩ = 2π sinθ dθ</span> (axial symmetry).<br/>
          Meaning: “ring” on a sphere at polar angle θ.
        </li>
        <li>
          <b>Compute captured power</b> (goal: do the integral).<br/>
          Tool: <span class="muted">P = ∫₀^{θmax} I(θ) dΩ</span>.<br/>
          Meaning: sum power from all accepted directions.
        </li>
        <li>
          <b>Convert to coupling efficiency</b> (goal: dimensionless result).<br/>
          Tool: <span class="muted">η = P/P₀</span>.<br/>
          Meaning: fraction of total emitted power guided.
        </li>
        <li>
          <b>Part (b): compute NA</b> (goal: numeric NA).<br/>
          Tool: <span class="muted">NA = √(n₁² − n₂²)</span>.<br/>
          Meaning: intrinsic fiber acceptance.
        </li>
        <li>
          <b>Adjust for bonded LED medium</b> (goal: correct θ<sub>max</sub> in source medium).<br/>
          Tool: <span class="muted">sinθ<sub>max</sub> = NA/n<sub>s</sub></span>.<br/>
          Meaning: higher source index narrows the cone.
        </li>
      </ol>

      <div class="callout bad">
        <h4>Common mistakes (and quick fixes)</h4>
        <ul>
          <li><b>Mistake:</b> using η = NA² even when the source medium is not air. <br/><b>Fix:</b> use <span class="muted">η = (NA/n₀)²</span>.</li>
          <li><b>Mistake:</b> forgetting the factor <span class="muted">2π</span> in dΩ. <br/><b>Fix:</b> remember full azimuthal sweep for a cone.</li>
          <li><b>Mistake:</b> plugging <span class="muted">n₁</span> where <span class="muted">n₀</span> belongs. <br/><b>Fix:</b> n₀ is the launch medium, not the fiber core.</li>
        </ul>
      </div>
    </section>

    <section id="solution">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Qualitative expectation (before math)</h3>
      <p>
        The fiber only accepts a cone of directions. If that cone is narrow, only a small fraction of the source’s emission
        gets in. Because cones have solid angle proportional to <span class="muted">sin²θ<sub>max</sub></span>,
        we expect efficiency to scale like the square of the acceptance “angle measure”. Since NA is essentially
        <span class="muted">n₀ sinθ<sub>max</sub></span>, an <span class="muted">NA²</span> scaling is very plausible.
      </p>

      <h3>(a) Show that P = (NA)² P₀ (air launch)</h3>

      <p><b>Step 1 — Define the acceptance cone.</b></p>
      <p>
        Let the medium outside the fiber be air so <span class="muted">n₀ = 1</span>.
        The numerical aperture is defined by
        <span class="muted">NA = n₀ sinθ<sub>max</sub></span>,
        therefore for air:
        <span class="muted">sinθ<sub>max</sub> = NA</span>.
      </p>

      <div class="eq" data-copy="NA = n0*sin(theta_max)  (so in air: sin(theta_max)=NA)">
        <button class="copybtn" type="button">Copy</button>
        NA = n₀ · sin(θ_max)  &nbsp;&nbsp; (air: n₀ = 1 ⇒ sin(θ_max) = NA)
        <br><small>θ_max is the maximum polar angle (from the fiber axis) that is guided.</small>
      </div>

      <p><b>Step 2 — Write the solid-angle element dΩ.</b></p>
      <p>
        Because the distribution depends only on θ (not on azimuth φ), we integrate over φ from 0 to 2π.
        The solid-angle element is
      </p>

      <div class="eq" data-copy="dOmega = sin(theta) dtheta dphi  -> with symmetry: dOmega = 2*pi*sin(theta)*dtheta">
        <button class="copybtn" type="button">Copy</button>
        dΩ = sinθ dθ dφ  &nbsp;⇒&nbsp; (axisymmetry) dΩ = 2π sinθ dθ
        <br><small>This represents a thin ring on the unit sphere at polar angle θ.</small>
      </div>

      <p><b>Step 3 — Integrate the captured power.</b></p>
      <p>
        The radiant intensity is given (define it carefully):
      </p>

      <div class="eq" data-copy="I(theta) = (P0/pi)*cos(theta)   [W/sr]">
        <button class="copybtn" type="button">Copy</button>
        I(θ) = (P₀/π) · cosθ  &nbsp;&nbsp; [W/sr]
      </div>

      <p>
        The fiber collects all directions with <span class="muted">0 ≤ θ ≤ θ<sub>max</sub></span>, so
      </p>

      <div class="eq" data-copy="P = integral_0^{theta_max} I(theta) dOmega = integral_0^{theta_max} (P0/pi)*cos(theta) * 2*pi*sin(theta) dtheta">
        <button class="copybtn" type="button">Copy</button>
        P = ∫₀^{θ_max} I(θ) dΩ
          = ∫₀^{θ_max} (P₀/π) cosθ · (2π sinθ dθ)
      </div>

      <p><b>Step 4 — Compute the integral (no jumps).</b></p>
      <p>
        Simplify constants and integrate:
      </p>
      <div class="eq" data-copy="P = 2*P0*integral_0^{theta_max} sin(theta)cos(theta) dtheta = P0*sin^2(theta_max)">
        <button class="copybtn" type="button">Copy</button>
        P = 2P₀ ∫₀^{θ_max} sinθ cosθ dθ
        <br>
        Let u = sinθ  ⇒ du = cosθ dθ
        <br>
        P = 2P₀ ∫_{u=0}^{u=sinθ_max} u du
        = 2P₀ [u²/2]₀^{sinθ_max}
        = P₀ sin²(θ_max)
      </div>
      <p class="muted">
        What we did: the angular pattern is weighted by the solid-angle ring size; the integral collapses neatly because
        sinθ cosθ is the derivative structure of sin²θ.
      </p>

      <p><b>Step 5 — Express in terms of NA (air).</b></p>
      <p>
        In air, <span class="muted">sinθ<sub>max</sub> = NA</span>, so:
      </p>

      <div class="eq" data-copy="P = P0*(NA)^2   ;   eta = P/P0 = (NA)^2">
        <button class="copybtn" type="button">Copy</button>
        P = P₀ sin²(θ_max) = P₀ (NA)²
        <br>
        η ≡ P/P₀ = (NA)²
      </div>

      <div class="callout good">
        <h4>Final result for (a)</h4>
        <p style="margin:6px 0;">
          <b>Collected power:</b> <span class="muted">P = (NA)² P₀</span> (air launch).<br/>
          <b>Coupling efficiency:</b> <span class="muted">η = (NA)²</span>.
        </p>
      </div>

      <h3>Sanity checks for (a)</h3>
      <ul>
        <li><b>Units:</b> I is W/sr and dΩ is sr, so P is W. Efficiency η is dimensionless.</li>
        <li><b>Limiting case NA → 0:</b> θ<sub>max</sub>→0, so η→0 (makes sense: no acceptance).</li>
        <li><b>Upper bound:</b> if θ<sub>max</sub>→90° then sin²θ<sub>max</sub>=1, so P→P₀ (capture all forward hemisphere). Our formula agrees.</li>
      </ul>

      <h3>(b) Bonded planar LED: compute NA and coupling efficiency</h3>
      <p>
        For a step-index fiber with core index n₁ and cladding index n₂, the numerical aperture is
      </p>

      <div class="eq" data-copy="NA = sqrt(n1^2 - n2^2)">
        <button class="copybtn" type="button">Copy</button>
        NA = √(n₁² − n₂²)
      </div>

      <p>
        With <span class="muted">n₁ = 1.46</span>, <span class="muted">n₂ = 1.455</span>:
      </p>

      <div class="eq" data-copy="NA = sqrt(1.46^2 - 1.455^2) = 0.1207269647 ≈ 0.1207">
        <button class="copybtn" type="button">Copy</button>
        NA = √(1.46² − 1.455²)
           = √(2.1316 − 2.117025)
           = √(0.014575)
           ≈ 0.1207269647 ≈ 0.1207
      </div>

      <p>
        Now the key subtlety: the LED is <b>bonded</b> to the fiber, so rays originate inside a medium of refractive index
        <span class="muted">n₀ = n<sub>s</sub> = 3.5</span>. The acceptance condition is
        <span class="muted">n₀ sinθ<sub>max</sub> = NA</span>, hence
        <span class="muted">sinθ<sub>max</sub> = NA / n<sub>s</sub></span>.
        The same solid-angle integral from part (a) gives
        <span class="muted">η = sin²θ<sub>max</sub> = (NA/n<sub>s</sub>)²</span>.
      </p>

      <div class="eq" data-copy="Bonded source (index ns): sin(theta_max)=NA/ns, so eta=(NA/ns)^2">
        <button class="copybtn" type="button">Copy</button>
        Bonded launch medium (n₀ = n_s):
        <br>
        sin(θ_max) = NA / n_s
        <br>
        η = P/P₀ = sin²(θ_max) = (NA / n_s)²
      </div>

      <p>Plug in numbers:</p>
      <div class="eq" data-copy="eta = (0.1207269647/3.5)^2 = 0.0011897959 ≈ 1.19e-3 = 0.119%">
        <button class="copybtn" type="button">Copy</button>
        η = (NA/n_s)² = (0.1207269647 / 3.5)²
          ≈ (0.0344934185)²
          ≈ 0.0011897959
          ≈ 1.19×10⁻³  ≈ 0.119%
      </div>

      <div class="callout good">
        <h4>Final answer for (b)</h4>
        <p style="margin:6px 0;">
          <b>Numerical aperture:</b> <span class="muted">NA ≈ 0.1207</span>.<br/>
          <b>Coupling efficiency (bonded LED, n<sub>s</sub>=3.5):</b> <span class="muted">η ≈ 1.19×10⁻³ ≈ 0.119%</span>.
        </p>
        <div class="btnRow">
          <button class="action" id="copyFinal" type="button">Copy final answer (plain text)</button>
        </div>
      </div>

      <p class="muted">
        Connection to the diagram/plots below: θ<sub>max</sub> shrinks when the launch medium index n₀ increases, which
        dramatically reduces η because η scales as sin²θ<sub>max</sub>.
      </p>
    </section>

    <section id="deeper">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the final formula</h3>
      <ul>
        <li><span class="muted">η = (NA/n₀)²</span> says coupling is controlled by an <b>angular etendue match</b>: larger NA means a wider acceptance cone; larger n₀ narrows that cone in angular coordinates.</li>
        <li><b>Why squared?</b> Because a cone’s solid angle scales like sin²θ, and the given source intensity includes another cosθ that still integrates to sin²θ.</li>
        <li><b>What NA encodes:</b> <span class="muted">NA = √(n₁² − n₂²)</span> increases when the core-cladding contrast increases.</li>
      </ul>

      <div class="callout">
        <h4>How parameters affect coupling (tie-in to interactive plots)</h4>
        <ul>
          <li>Increase <b>n₁</b> (core index) → NA increases → η increases strongly (quadratic).</li>
          <li>Increase <b>n₂</b> (cladding index) → NA decreases → η drops quickly.</li>
          <li>Increase <b>n₀</b> (source medium index: bonding/LED) → η decreases as 1/n₀² for fixed NA.</li>
        </ul>
      </div>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        You can also derive the scaling using <b>etendue conservation</b>:
        the source emits into a certain angular phase space (A·Ω), while the fiber accepts a limited angular phase space.
        For a given emission model, the fraction that fits into the fiber’s acceptance etendue ends up scaling like the
        accepted solid angle, which here leads to the same <span class="muted">sin²θ<sub>max</sub></span> (thus NA²) dependence.
      </p>

      <h3>Concept check (quick self-test)</h3>
      <ul>
        <li><b>Q:</b> If NA doubles (air launch), what happens to η? <b>A:</b> It increases by a factor of 4 (η ∝ NA²).</li>
        <li><b>Q:</b> Why does bonding to a high-index LED reduce η? <b>A:</b> Because θ<sub>max</sub> in that medium satisfies sinθ<sub>max</sub>=NA/n<sub>s</sub>, so the acceptance cone is narrower in angle.</li>
        <li><b>Q:</b> If n₁ ≈ n₂, what should η be? <b>A:</b> Near zero; the fiber barely guides and NA → 0.</li>
        <li><b>Q:</b> Does this include Fresnel loss at the interface? <b>A:</b> No—this is purely geometric acceptance (ideal interface).</li>
      </ul>
    </section>

    <section id="vizguide">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>
      <ul>
        <li><b>Diagram canvas:</b> shows a planar source next to a fiber face. The shaded cone indicates accepted rays up to θ<sub>max</sub>. Labels indicate n₀, n₁, n₂, NA, and θ<sub>max</sub>.</li>
        <li><b>Main plot:</b> coupling efficiency η versus NA. Two curves are shown:
          <span class="muted">η = NA²</span> for air (n₀=1) and <span class="muted">η = (NA/n₀)²</span> for the chosen launch medium index n₀.</li>
        <li><b>Secondary plot:</b> parameter sweep of η versus cladding index n₂ (holding n₁ and n₀ fixed). This visualizes how tiny changes in index contrast can change NA and thus η.</li>
        <li><b>Interactive controls:</b> sliders for n₁, n₂, and n₀ (launch medium index). Adjust them to see all canvases update live:
          NA changes with (n₁,n₂); θ<sub>max</sub> and η change with NA and n₀.</li>
      </ul>
    </section>

    <section id="interactive">
      <h2>Interactive Visuals</h2>

      <div class="controls" aria-label="Interactive controls">
        <div class="control">
          <label for="n1"><span>Core index <b>n₁</b></span><span class="readout" id="n1Val">1.460</span></label>
          <input id="n1" type="range" min="1.40" max="1.60" step="0.001" value="1.46" />
          <div class="muted" style="font-size:.85rem;margin-top:6px;">Example slider (fiber material / wavelength dependence).</div>
        </div>
        <div class="control">
          <label for="n2"><span>Cladding index <b>n₂</b></span><span class="readout" id="n2Val">1.455</span></label>
          <input id="n2" type="range" min="1.40" max="1.59" step="0.001" value="1.455" />
          <div class="muted" style="font-size:.85rem;margin-top:6px;">Keep n₂ &lt; n₁ to guide.</div>
        </div>
        <div class="control">
          <label for="n0"><span>Launch medium index <b>n₀</b></span><span class="readout" id="n0Val">3.500</span></label>
          <input id="n0" type="range" min="1.00" max="3.80" step="0.01" value="3.50" />
          <div class="muted" style="font-size:.85rem;margin-top:6px;">n₀=1 (air) vs bonded LED (e.g., 3.5).</div>
        </div>
      </div>

      <div class="kpiRow" aria-label="Live computed values">
        <div class="kpi">
          <div class="label">Numerical aperture</div>
          <div class="value" id="kNA">—</div>
          <div class="hint">NA = √(n₁² − n₂²)</div>
        </div>
        <div class="kpi">
          <div class="label">Acceptance half-angle</div>
          <div class="value" id="kTheta">—</div>
          <div class="hint">sin(θ_max) = NA / n₀</div>
        </div>
        <div class="kpi">
          <div class="label">Coupling efficiency</div>
          <div class="value" id="kEta">—</div>
          <div class="hint">η = (NA / n₀)² (cosθ source)</div>
        </div>
      </div>

      <div class="vizWrap">
        <div class="canvasCard">
          <div class="canvasHeader">
            <p class="ctitle"><b>Diagram:</b> Source → Fiber acceptance cone</p>
            <p class="cmeta" id="diagMeta">—</p>
          </div>
          <canvas id="cDiagram" aria-label="Diagram canvas"></canvas>
        </div>

        <div class="canvasCard">
          <div class="canvasHeader">
            <p class="ctitle"><b>Main plot:</b> Coupling efficiency vs numerical aperture</p>
            <p class="cmeta">η(NA) curves</p>
          </div>
          <canvas id="cMain" aria-label="Main plot canvas"></canvas>
        </div>

        <div class="canvasCard">
          <div class="canvasHeader">
            <p class="ctitle"><b>Secondary plot:</b> Sweep η vs cladding index n₂</p>
            <p class="cmeta">shows sensitivity to index contrast</p>
          </div>
          <canvas id="cSweep" aria-label="Secondary plot canvas"></canvas>
        </div>
      </div>
    </section>
  </article>
</main>

<footer>
  <p>
    This page used the standard ray/solid-angle coupling model: it isolates <b>angular acceptance</b> (NA) and assumes
    perfect spatial overlap and negligible interface losses. In real systems, add Fresnel reflection, misalignment,
    and mode-field overlap for a more complete budget.
  </p>
</footer>

<script>
(function(){
  // ---------- Utilities ----------
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const fmt = (x, d=3)=>Number(x).toFixed(d);
  const fmtSci = (x)=>{
    if (x===0) return "0";
    const e = Math.floor(Math.log10(Math.abs(x)));
    const m = x / Math.pow(10,e);
    const mstr = (Math.abs(e) >= 2) ? m.toFixed(3) : m.toFixed(6);
    return `${mstr}×10^${e}`;
  };
  const deg = (rad)=>rad*180/Math.PI;

  function copyText(t){
    if (navigator.clipboard && navigator.clipboard.writeText){
      navigator.clipboard.writeText(t);
    } else {
      const ta = document.createElement("textarea");
      ta.value = t;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
    }
  }

  // Attach copy buttons to equation blocks
  document.querySelectorAll(".eq").forEach(eq=>{
    const btn = eq.querySelector(".copybtn");
    if(!btn) return;
    btn.addEventListener("click", ()=>{
      const t = eq.getAttribute("data-copy") || eq.innerText;
      copyText(t.trim());
      btn.textContent = "Copied!";
      setTimeout(()=>btn.textContent="Copy", 900);
    });
  });

  // Copy final answer
  document.getElementById("copyFinal").addEventListener("click", ()=>{
    // Default values as in part (b)
    const txt =
`(a) Air launch: P = (NA)^2 P0, so eta = (NA)^2.
(b) Step-index NA = sqrt(n1^2 - n2^2).
For n1=1.46, n2=1.455: NA ≈ 0.1207.
Bonded LED with ns=3.5 (n0=ns): eta = (NA/ns)^2 ≈ 1.19e-3 ≈ 0.119%.`;
    copyText(txt);
  });

  // Smooth scroll for TOC
  document.querySelectorAll('a.toclink').forEach(a=>{
    a.addEventListener('click', (e)=>{
      e.preventDefault();
      const id = a.getAttribute('href').slice(1);
      const el = document.getElementById(id);
      if(el) el.scrollIntoView({behavior:"smooth", block:"start"});
    });
  });

  // ---------- State ----------
  const ui = {
    n1: document.getElementById("n1"),
    n2: document.getElementById("n2"),
    n0: document.getElementById("n0"),
    n1Val: document.getElementById("n1Val"),
    n2Val: document.getElementById("n2Val"),
    n0Val: document.getElementById("n0Val"),
    kNA: document.getElementById("kNA"),
    kTheta: document.getElementById("kTheta"),
    kEta: document.getElementById("kEta"),
    diagMeta: document.getElementById("diagMeta"),
    cDiagram: document.getElementById("cDiagram"),
    cMain: document.getElementById("cMain"),
    cSweep: document.getElementById("cSweep")
  };

  const canvases = [
    {el: ui.cDiagram, ctx: ui.cDiagram.getContext("2d")},
    {el: ui.cMain, ctx: ui.cMain.getContext("2d")},
    {el: ui.cSweep, ctx: ui.cSweep.getContext("2d")}
  ];

  function resizeCanvas(canvas){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(320, rect.width);
    const h = rect.height;
    canvas.width = Math.round(w*dpr);
    canvas.height = Math.round(h*dpr);
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return {w, h, dpr};
  }

  function getParams(){
    const n1 = parseFloat(ui.n1.value);
    const n2 = parseFloat(ui.n2.value);
    const n0 = parseFloat(ui.n0.value);
    const NA = (n1>n2) ? Math.sqrt(Math.max(0, n1*n1 - n2*n2)) : 0;
    const s = (n0>0) ? (NA/n0) : 0;
    const sClamped = clamp(s, 0, 1);
    const theta = Math.asin(sClamped);
    const eta = sClamped*sClamped; // from part (a): eta = sin^2(theta_max) = (NA/n0)^2
    return {n1,n2,n0,NA,theta,eta,sClamped};
  }

  // ---------- Plotting helpers ----------
  function clear(ctx, w, h){
    ctx.clearRect(0,0,w,h);
  }

  function drawPanelFrame(ctx, w, h){
    // subtle border already exists via CSS; add inner padding shading
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.restore();
  }

  function drawText(ctx, x, y, text, color="rgba(233,236,255,.92)", size=12, align="left", baseline="alphabetic", mono=false){
    ctx.save();
    ctx.fillStyle = color;
    ctx.font = `${size}px ${mono ? "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace" : "ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial"}`;
    ctx.textAlign = align;
    ctx.textBaseline = baseline;
    ctx.fillText(text, x, y);
    ctx.restore();
  }

  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
    const {x,y,w,h,padL,padR,padT,padB} = box;
    // Plot area
    const ax = x + padL;
    const ay = y + padT;
    const aw = w - padL - padR;
    const ah = h - padT - padB;

    // grid + ticks
    ctx.save();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(184,192,255,.16)";
    ctx.fillStyle = "rgba(184,192,255,.16)";

    // background
    ctx.fillStyle = "rgba(255,255,255,.02)";
    ctx.fillRect(ax, ay, aw, ah);

    const nGrid = 6;
    for(let i=0;i<=nGrid;i++){
      const gx = ax + (aw*i/nGrid);
      const gy = ay + (ah*i/nGrid);

      // vertical grid
      ctx.strokeStyle = "rgba(184,192,255,.12)";
      ctx.beginPath(); ctx.moveTo(gx, ay); ctx.lineTo(gx, ay+ah); ctx.stroke();

      // horizontal grid
      ctx.beginPath(); ctx.moveTo(ax, gy); ctx.lineTo(ax+aw, gy); ctx.stroke();
    }

    // axes border
    ctx.strokeStyle = "rgba(184,192,255,.28)";
    ctx.strokeRect(ax, ay, aw, ah);

    // ticks + labels
    ctx.strokeStyle = "rgba(184,192,255,.35)";
    ctx.fillStyle = "rgba(233,236,255,.9)";
    const tickLen = 6;

    // x ticks
    for(let i=0;i<=nGrid;i++){
      const gx = ax + (aw*i/nGrid);
      ctx.beginPath(); ctx.moveTo(gx, ay+ah); ctx.lineTo(gx, ay+ah+tickLen); ctx.stroke();
      const xv = xMin + (xMax-xMin)*i/nGrid;
      drawText(ctx, gx, ay+ah+tickLen+12, (Math.abs(xv) < 1e-8 ? "0" : xv.toFixed(2)), "rgba(233,236,255,.85)", 11, "center", "alphabetic", true);
    }

    // y ticks
    for(let i=0;i<=nGrid;i++){
      const gy = ay + ah - (ah*i/nGrid);
      ctx.beginPath(); ctx.moveTo(ax, gy); ctx.lineTo(ax-tickLen, gy); ctx.stroke();
      const yv = yMin + (yMax-yMin)*i/nGrid;
      let label = (Math.abs(yMax) <= 0.01) ? yv.toExponential(1) : yv.toFixed(2);
      if (yMax <= 0.02) label = yv.toExponential(1);
      drawText(ctx, ax-tickLen-6, gy, label, "rgba(233,236,255,.85)", 11, "right", "middle", true);
    }

    // labels
    drawText(ctx, ax+aw/2, y+14, title, "rgba(233,236,255,.95)", 13, "center", "alphabetic", false);
    drawText(ctx, ax+aw/2, ay+ah+38, xLabel, "rgba(184,192,255,.92)", 12, "center", "alphabetic", false);

    // y label rotated
    ctx.save();
    ctx.translate(x+14, ay+ah/2);
    ctx.rotate(-Math.PI/2);
    drawText(ctx, 0, 0, yLabel, "rgba(184,192,255,.92)", 12, "center", "alphabetic", false);
    ctx.restore();

    ctx.restore();

    // return mapping functions
    const xToPx = (vx)=> ax + (vx-xMin)/(xMax-xMin) * aw;
    const yToPx = (vy)=> ay + ah - (vy-yMin)/(yMax-yMin) * ah;
    return {ax,ay,aw,ah,xToPx,yToPx};
  }

  function drawLine(ctx, map, xs, ys, stroke="rgba(139,233,253,.95)", width=2){
    ctx.save();
    ctx.strokeStyle = stroke;
    ctx.lineWidth = width;
    ctx.beginPath();
    for(let i=0;i<xs.length;i++){
      const px = map.xToPx(xs[i]);
      const py = map.yToPx(ys[i]);
      if(i===0) ctx.moveTo(px,py);
      else ctx.lineTo(px,py);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawLegend(ctx, x, y, items){
    // items: {label,color}
    ctx.save();
    const pad = 10, lh = 18;
    const w = 10 + Math.max(...items.map(it=>it.label.length))*7.2 + 52;
    const h = pad*2 + items.length*lh;
    ctx.fillStyle = "rgba(11,16,32,.72)";
    ctx.strokeStyle = "rgba(184,192,255,.18)";
    ctx.lineWidth = 1;
    roundRect(ctx, x, y, w, h, 12);
    ctx.fill(); ctx.stroke();

    for(let i=0;i<items.length;i++){
      const yy = y + pad + i*lh + 5;
      ctx.strokeStyle = items[i].color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x+12, yy);
      ctx.lineTo(x+34, yy);
      ctx.stroke();
      drawText(ctx, x+42, yy, items[i].label, "rgba(233,236,255,.9)", 12, "left", "middle", false);
    }
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  // ---------- Diagram ----------
  function drawDiagram(ctx, W, H, params){
    clear(ctx, W, H);
    const {n1,n2,n0,NA,theta,eta} = params;

    // Layout
    const pad = 18;
    const left = pad;
    const right = W - pad;
    const top = pad;
    const bottom = H - pad;

    // Source rectangle (planar emitter)
    const srcW = W*0.18;
    const srcH = H*0.26;
    const srcX = left + 8;
    const srcY = H*0.55 - srcH/2;

    // Fiber face and core/clad
    const fibX = W*0.45;
    const fibR = Math.min(H*0.22, W*0.10);
    const coreR = fibR*0.62;

    // acceptance cone origin point on fiber axis at the face center
    const origin = {x: fibX, y: H*0.55};

    // Draw source
    ctx.save();
    ctx.fillStyle = "rgba(255,184,108,.16)";
    ctx.strokeStyle = "rgba(255,184,108,.55)";
    ctx.lineWidth = 2;
    roundRect(ctx, srcX, srcY, srcW, srcH, 14);
    ctx.fill(); ctx.stroke();
    drawText(ctx, srcX+srcW/2, srcY-8, "Planar source", "rgba(233,236,255,.92)", 12, "center", "alphabetic", false);
    drawText(ctx, srcX+srcW/2, srcY+srcH+16, `index n₀ = ${fmt(n0,2)}`, "rgba(184,192,255,.92)", 12, "center", "alphabetic", true);

    // Draw rays within acceptance
    const maxAngle = theta; // radians
    const rayLen = W*0.42;
    const nRays = 9;
    ctx.globalAlpha = 0.9;
    for(let i=0;i<nRays;i++){
      const t = (i/(nRays-1))*2 - 1; // -1..1
      const ang = t*maxAngle;
      const x2 = origin.x + rayLen*Math.cos(ang);
      const y2 = origin.y + rayLen*Math.sin(ang);
      ctx.strokeStyle = "rgba(139,233,253,.55)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(srcX+srcW, srcY+srcH/2);
      // aim rays toward origin then into fiber axis
      ctx.lineTo(origin.x, origin.y);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    // Draw acceptance cone fill (inside fiber side)
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "rgba(139,233,253,.65)";
    ctx.beginPath();
    ctx.moveTo(origin.x, origin.y);
    ctx.arc(origin.x, origin.y, rayLen*0.92, -maxAngle, +maxAngle, false);
    ctx.closePath();
    ctx.fill();

    // Draw fiber cross section at face
    ctx.globalAlpha = 1;
    ctx.strokeStyle = "rgba(184,192,255,.38)";
    ctx.fillStyle = "rgba(255,255,255,.03)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(origin.x, origin.y, fibR, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // core
    ctx.strokeStyle = "rgba(167,255,131,.72)";
    ctx.fillStyle = "rgba(167,255,131,.10)";
    ctx.beginPath();
    ctx.arc(origin.x, origin.y, coreR, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // Axis
    ctx.strokeStyle = "rgba(184,192,255,.28)";
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(origin.x, top);
    ctx.lineTo(origin.x, bottom);
    ctx.stroke();
    ctx.setLineDash([]);

    // Theta_max arc indicator
    const arcR = fibR*1.25;
    ctx.strokeStyle = "rgba(255,255,255,.60)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(origin.x, origin.y, arcR, 0, maxAngle);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(origin.x, origin.y, arcR, 0, -maxAngle, true);
    ctx.stroke();

    // Label theta
    const lx = origin.x + arcR*Math.cos(maxAngle*0.65) + 8;
    const ly = origin.y + arcR*Math.sin(maxAngle*0.65) - 2;
    drawText(ctx, lx, ly, "θ_max", "rgba(233,236,255,.92)", 12, "left", "alphabetic", true);

    // Labels n1, n2
    drawText(ctx, origin.x, origin.y - fibR - 14, "Fiber face", "rgba(233,236,255,.92)", 12, "center", "alphabetic", false);
    drawText(ctx, origin.x + fibR + 14, origin.y - 6, `clad n₂=${fmt(n2,3)}`, "rgba(184,192,255,.92)", 11, "left", "alphabetic", true);
    drawText(ctx, origin.x + coreR + 14, origin.y + 14, `core n₁=${fmt(n1,3)}`, "rgba(184,192,255,.92)", 11, "left", "alphabetic", true);

    // NA & eta box
    ctx.fillStyle = "rgba(11,16,32,.70)";
    ctx.strokeStyle = "rgba(184,192,255,.18)";
    ctx.lineWidth = 1;
    const bx = W*0.64, by = H*0.12, bw = W*0.33, bh = H*0.23;
    roundRect(ctx, bx, by, bw, bh, 14);
    ctx.fill(); ctx.stroke();
    drawText(ctx, bx+12, by+22, `NA = √(n₁²−n₂²) = ${fmt(NA,4)}`, "rgba(233,236,255,.92)", 12, "left", "alphabetic", true);
    drawText(ctx, bx+12, by+44, `sinθ_max = NA/n₀ = ${(NA/params.n0).toFixed(4)}`, "rgba(233,236,255,.90)", 12, "left", "alphabetic", true);
    drawText(ctx, bx+12, by+66, `η = (NA/n₀)² = ${eta.toFixed(6)}`, "rgba(233,236,255,.90)", 12, "left", "alphabetic", true);
    drawText(ctx, bx+12, by+88, `θ_max ≈ ${fmt(deg(theta),2)}°`, "rgba(233,236,255,.90)", 12, "left", "alphabetic", true);

    ctx.restore();
  }

  // ---------- Main plot: eta vs NA ----------
  function drawMain(ctx, W, H, params){
    clear(ctx, W, H);
    const box = {x:10,y:10,w:W-20,h:H-20,padL:62,padR:14,padT:36,padB:54};

    const NAmax = 0.6;
    const xMin = 0, xMax = NAmax;
    const yMin = 0, yMax = 0.40; // show up to NA=0.6 => NA^2=0.36

    const map = drawAxes(ctx, box, xMin, xMax, yMin, yMax, "NA (dimensionless)", "η (dimensionless)", "Coupling efficiency vs numerical aperture");

    // Curves
    const N = 400;
    const xs = new Array(N);
    const ysAir = new Array(N);
    const ysMed = new Array(N);
    for(let i=0;i<N;i++){
      const na = xMin + (xMax-xMin)*i/(N-1);
      xs[i] = na;
      ysAir[i] = na*na;                 // n0=1
      ysMed[i] = (na/params.n0)*(na/params.n0); // chosen n0
    }

    drawLine(ctx, map, xs, ysAir, "rgba(139,233,253,.95)", 2.2);
    drawLine(ctx, map, xs, ysMed, "rgba(167,255,131,.95)", 2.2);

    // Current point markers
    const x0 = params.NA;
    const y0Air = x0*x0;
    const y0Med = (x0/params.n0)*(x0/params.n0);

    // Marker function
    function marker(px, py, color){
      ctx.save();
      ctx.fillStyle = color;
      ctx.strokeStyle = "rgba(11,16,32,.95)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(px, py, 5.6, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }
    marker(map.xToPx(x0), map.yToPx(y0Air), "rgba(139,233,253,.95)");
    marker(map.xToPx(x0), map.yToPx(y0Med), "rgba(167,255,131,.95)");

    // Legend
    drawLegend(ctx, map.ax + 12, map.ay + 12, [
      {label:"Air: η = NA²", color:"rgba(139,233,253,.95)"},
      {label:`Medium n₀=${params.n0.toFixed(2)}: η=(NA/n₀)²`, color:"rgba(167,255,131,.95)"}
    ]);

    // Note about current values
    drawText(ctx, map.ax + map.aw - 10, map.ay + map.ah - 10,
      `current NA=${params.NA.toFixed(4)}  →  η=${params.eta.toFixed(6)}`,
      "rgba(233,236,255,.85)", 11, "right", "alphabetic", true
    );
  }

  // ---------- Secondary plot: sweep eta vs n2 ----------
  function drawSweep(ctx, W, H, params){
    clear(ctx, W, H);
    const box = {x:10,y:10,w:W-20,h:H-20,padL:72,padR:14,padT:36,padB:54};

    // Sweep n2 around a range below n1
    const n2Min = Math.max(1.0, params.n1 - 0.10);
    const n2Max = Math.min(params.n1 - 0.001, params.n1 - 0.0005 + 0.10); // keep slightly below n1
    const xMin = n2Min, xMax = n2Max;

    // y scale based on current or plausible max
    const NAmax = Math.sqrt(Math.max(0, params.n1*params.n1 - xMin*xMin));
    const yMax = Math.min(0.4, (NAmax/params.n0)*(NAmax/params.n0)*1.05 + 1e-6);
    const yMin = 0;

    const map = drawAxes(ctx, box, xMin, xMax, yMin, yMax, "n₂ (dimensionless)", "η (dimensionless)", "Sensitivity: efficiency vs cladding index n₂");

    const N = 450;
    const xs = new Array(N);
    const ys = new Array(N);
    for(let i=0;i<N;i++){
      const n2 = xMin + (xMax-xMin)*i/(N-1);
      xs[i] = n2;
      const NA = Math.sqrt(Math.max(0, params.n1*params.n1 - n2*n2));
      const eta = (NA/params.n0)*(NA/params.n0);
      ys[i] = eta;
    }

    drawLine(ctx, map, xs, ys, "rgba(255,184,108,.95)", 2.4);

    // Current n2 marker
    const x0 = params.n2;
    const NA0 = params.NA;
    const y0 = params.eta;
    ctx.save();
    ctx.strokeStyle = "rgba(233,236,255,.55)";
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(map.xToPx(x0), map.ay);
    ctx.lineTo(map.xToPx(x0), map.ay+map.ah);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();

    // point
    ctx.save();
    ctx.fillStyle = "rgba(255,184,108,.95)";
    ctx.strokeStyle = "rgba(11,16,32,.95)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(map.xToPx(x0), map.yToPx(y0), 5.6, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();
    ctx.restore();

    drawText(ctx, map.ax + 12, map.ay + 18, `fixed: n₁=${params.n1.toFixed(3)}, n₀=${params.n0.toFixed(2)}`, "rgba(184,192,255,.92)", 12, "left", "alphabetic", true);
    drawText(ctx, map.ax + 12, map.ay + 38, `current: n₂=${params.n2.toFixed(3)} → NA=${NA0.toFixed(4)} → η=${y0.toFixed(6)}`, "rgba(233,236,255,.88)", 12, "left", "alphabetic", true);
  }

  // ---------- Render all ----------
  function render(){
    ui.n1Val.textContent = fmt(parseFloat(ui.n1.value), 3);
    ui.n2Val.textContent = fmt(parseFloat(ui.n2.value), 3);
    ui.n0Val.textContent = fmt(parseFloat(ui.n0.value), 3);

    const params = getParams();

    ui.kNA.textContent = params.NA ? params.NA.toFixed(6) : "0.000000";
    ui.kTheta.textContent = `${deg(params.theta).toFixed(3)}°`;
    ui.kEta.textContent = `${params.eta.toFixed(6)} (${(params.eta*100).toFixed(3)}%)`;

    const thetaDeg = deg(params.theta);
    ui.diagMeta.textContent = `θ_max ≈ ${thetaDeg.toFixed(2)}°, NA ≈ ${params.NA.toFixed(4)}, η ≈ ${params.eta.toFixed(6)}`;

    // Resize and draw
    const r0 = resizeCanvas(ui.cDiagram);
    drawDiagram(ui.cDiagram.getContext("2d"), r0.w, r0.h, params);

    const r1 = resizeCanvas(ui.cMain);
    drawMain(ui.cMain.getContext("2d"), r1.w, r1.h, params);

    const r2 = resizeCanvas(ui.cSweep);
    drawSweep(ui.cSweep.getContext("2d"), r2.w, r2.h, params);
  }

  // Events
  ["input","change"].forEach(ev=>{
    ui.n1.addEventListener(ev, render);
    ui.n2.addEventListener(ev, render);
    ui.n0.addEventListener(ev, render);
  });

  window.addEventListener("resize", ()=>{
    // Throttle a bit
    clearTimeout(window.__rz);
    window.__rz = setTimeout(render, 80);
  });

  // Ensure n2 < n1 by gently constraining when user drags
  ui.n1.addEventListener("input", ()=>{
    const n1 = parseFloat(ui.n1.value);
    const n2 = parseFloat(ui.n2.value);
    if (n2 >= n1){
      ui.n2.value = (n1 - 0.001).toFixed(3);
    }
  });
  ui.n2.addEventListener("input", ()=>{
    const n1 = parseFloat(ui.n1.value);
    const n2 = parseFloat(ui.n2.value);
    if (n2 >= n1){
      ui.n2.value = (n1 - 0.001).toFixed(3);
    }
  });

  // Initial render
  render();
})();
</script>
</body>
</html>
