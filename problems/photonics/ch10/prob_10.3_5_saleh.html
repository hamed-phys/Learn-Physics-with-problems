<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Modal Dispersion in Graded-Index Fibers (Power-Law Profile)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --card2:#0f1730;
      --text:#e9eefc;
      --muted:#b7c3ea;
      --faint:#7f8bb8;
      --accent:#77d4ff;
      --accent2:#a7ffb0;
      --warn:#ffd27a;
      --danger:#ff7aa5;
      --line:rgba(255,255,255,.10);
      --shadow: 0 12px 28px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html{ scroll-behavior:smooth; }
    body{
      margin:0;
      font-family: var(--sans);
      background: radial-gradient(1200px 700px at 20% 0%, rgba(119,212,255,.14), transparent 55%),
                  radial-gradient(900px 650px at 85% 15%, rgba(167,255,176,.12), transparent 55%),
                  radial-gradient(800px 900px at 50% 110%, rgba(255,210,122,.08), transparent 55%),
                  var(--bg);
      color: var(--text);
      line-height: 1.55;
    }

    header{
      padding: 28px 20px 18px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(to bottom, rgba(255,255,255,.04), transparent);
    }

    .wrap{
      max-width: 1200px;
      margin:0 auto;
      padding: 0 18px 36px;
    }

    .title{
      display:grid;
      gap:10px;
    }
    .title h1{
      margin:0;
      font-size: clamp(1.55rem, 2.4vw, 2.2rem);
      letter-spacing: .2px;
    }
    .subtitle{
      margin:0;
      color: var(--muted);
      max-width: 80ch;
    }

    .layout{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 18px;
      align-items:start;
      margin-top: 18px;
    }

    nav{
      position: sticky;
      top: 14px;
      align-self:start;
      background: rgba(17,26,51,.65);
      backdrop-filter: blur(10px);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
    }
    nav .toc-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    nav .toc-title strong{
      font-size:.95rem;
      letter-spacing:.3px;
    }
    nav a{
      display:block;
      padding: 8px 10px;
      margin: 6px 0;
      text-decoration:none;
      color: var(--muted);
      border-radius: 12px;
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:.95rem;
    }
    nav a:hover{
      background: rgba(119,212,255,.08);
      border-color: rgba(119,212,255,.18);
      color: var(--text);
      transform: translateY(-1px);
    }
    nav .small{
      color: var(--faint);
      font-size:.85rem;
      margin: 8px 0 0;
    }

    main{
      min-width: 0;
    }

    section{
      background: rgba(17,26,51,.55);
      backdrop-filter: blur(10px);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px;
      margin-bottom: 16px;
      overflow:hidden;
    }

    section h2{
      margin: 0 0 10px;
      font-size: 1.25rem;
    }
    section h3{
      margin: 16px 0 8px;
      font-size: 1.05rem;
      color: var(--text);
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
      nav{ position: relative; top:auto; }
      .grid2{ grid-template-columns: 1fr; }
    }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
      margin-top: 10px;
    }
    @media (max-width: 980px){
      .callouts{ grid-template-columns: 1fr; }
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.015));
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 14px;
    }
    .card h4{
      margin:0 0 8px;
      font-size: .98rem;
      color: var(--text);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .pill{
      font-size:.78rem;
      padding: 3px 8px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.15);
      color: var(--muted);
      background: rgba(0,0,0,.12);
      white-space:nowrap;
    }

    ul{ margin: 8px 0 0 18px; }
    li{ margin: 6px 0; color: var(--muted); }
    .muted{ color: var(--muted); }
    .faint{ color: var(--faint); }

    .eq{
      font-family: var(--mono);
      font-size: .95rem;
      line-height: 1.4;
      background: rgba(0,0,0,.20);
      border:1px dashed rgba(255,255,255,.16);
      padding: 10px 12px;
      border-radius: 14px;
      color: #f2f6ff;
      overflow:auto;
      margin: 8px 0 8px;
      position:relative;
    }

    .copyRow{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
      margin: 6px 0 0;
      flex-wrap:wrap;
    }
    button.copy{
      appearance:none;
      border:none;
      cursor:pointer;
      padding: 8px 10px;
      border-radius: 12px;
      color: var(--text);
      background: rgba(119,212,255,.12);
      border:1px solid rgba(119,212,255,.25);
      transition: transform .12s ease, background .12s ease;
      font-size:.9rem;
    }
    button.copy:hover{ transform: translateY(-1px); background: rgba(119,212,255,.18); }
    button.copy:active{ transform: translateY(0); }

    .assump{
      border-left: 4px solid var(--accent);
      background: rgba(119,212,255,.08);
    }
    .warn{
      border-left: 4px solid var(--warn);
      background: rgba(255,210,122,.08);
    }
    .final{
      border-left: 4px solid var(--accent2);
      background: rgba(167,255,176,.08);
    }

    .table{
      width:100%;
      border-collapse: collapse;
      margin-top: 8px;
      overflow:hidden;
      border-radius: 14px;
      border:1px solid var(--line);
    }
    .table th, .table td{
      padding: 10px 10px;
      border-bottom: 1px solid var(--line);
      text-align:left;
      vertical-align:top;
      font-size:.95rem;
    }
    .table th{
      color: var(--text);
      background: rgba(255,255,255,.04);
      font-weight:600;
    }
    .table td{ color: var(--muted); }
    .table tr:last-child td{ border-bottom:none; }

    .viz{
      display:grid;
      gap: 12px;
    }
    figure{
      margin: 0;
      background: rgba(0,0,0,.16);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      padding: 12px;
      overflow:hidden;
    }
    figcaption{
      margin-top: 10px;
      color: var(--muted);
      font-size: .92rem;
    }
    canvas{
      width: 100%;
      height: 320px;
      display:block;
      border-radius: 14px;
      background: rgba(10,14,30,.45);
    }
    .controls{
      display:flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      background: rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
    }
    .ctrl{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    label{
      color: var(--muted);
      font-size: .95rem;
    }
    input[type="range"]{
      width: 280px;
      max-width: 60vw;
      accent-color: #77d4ff;
    }
    select, input[type="checkbox"]{
      accent-color: #77d4ff;
    }
    select{
      background: rgba(0,0,0,.20);
      border:1px solid rgba(255,255,255,.16);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      outline:none;
    }

    .kpiRow{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
    }
    @media (max-width: 980px){
      .kpiRow{ grid-template-columns: 1fr; }
    }
    .kpi{
      padding: 12px 14px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.10));
    }
    .kpi .label{ color: var(--muted); font-size: .9rem; }
    .kpi .value{ font-size: 1.25rem; margin-top: 6px; }
    .kpi .unit{ color: var(--faint); font-size:.9rem; margin-left:6px; }

    footer{
      padding: 18px 0 42px;
      color: var(--faint);
      text-align:center;
      font-size:.9rem;
    }

    @media print{
      body{ background:#fff; color:#000; }
      nav{ display:none; }
      section{ box-shadow:none; border:1px solid #ddd; background:#fff; }
      .eq{ background:#f7f7f7; color:#000; }
      canvas{ background:#fff; border:1px solid #ddd; }
      button.copy{ display:none; }
    }

    /* subtle entrance */
    section{ animation: pop .45s ease both; transform-origin: 50% 20%; }
    @keyframes pop{ from{ opacity:0; transform: translateY(8px) scale(.985);} to{opacity:1; transform:none;} }
  </style>
</head>

<body>
<header>
  <div class="wrap title">
    <h1>Modal Dispersion in Graded-Index Fibers (Power-Law Profile)</h1>
    <p class="subtitle">
      We compute (i) the <strong>number of guided modes</strong> in a multimode graded-index fiber and (ii) the
      <strong>modal-dispersion pulse-broadening rate</strong> for several profile exponents <span class="muted">p</span>,
      using standard weakly guiding (ray + LP-mode) approximations.
    </p>
  </div>
</header>

<div class="wrap layout">
  <nav aria-label="Table of contents">
    <div class="toc-title">
      <strong>Table of Contents</strong>
      <span class="pill">sticky</span>
    </div>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy &amp; Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
    <p class="small">Tip: use the interactive controls to see how <span class="muted">p</span> changes both mode count and intermodal broadening.</p>
  </nav>

  <main>

    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><strong>What this is about:</strong> A graded-index (GI) multimode fiber with a power-law index profile; find the <strong>mode count</strong> <span class="muted">M</span> and <strong>modal (intermodal) dispersion</strong> broadening rate <span class="muted">σ<sub>t</sub>/L</span>.</li>
        <li><strong>Key physics idea:</strong> In GI fibers, rays that travel longer paths also sample lower refractive index, partially equalizing transit times. A <strong>parabolic</strong> profile (<span class="muted">p=2</span>) ideally cancels first-order modal dispersion.</li>
        <li><strong>Governing parameter:</strong> Normalized frequency (V-number) <span class="muted">V = (2πa/λ<sub>0</sub>) NA</span>, with <span class="muted">NA ≈ n<sub>1</sub>√(2Δ)</span> for weak guidance.</li>
        <li><strong>Mode count model:</strong> For a power-law GI profile, the total guided-mode count (including polarization) is approximately
          <span class="muted">M ≈ (V²/2)·(p/(p+2))</span> (weak guidance, large V).</li>
        <li><strong>Modal broadening model:</strong> A common ray-theory estimate for the intermodal RMS spread per length is
          <span class="muted">σ<sub>t</sub>/L ≈ (n<sub>1</sub>Δ/c)·| (p−2)/(p+2) | / √12</span>, giving <span class="muted">0</span> at <span class="muted">p=2</span> and approaching the step-index value as <span class="muted">p→∞</span>.</li>
        <li><strong>Final result type:</strong> Numeric results for <span class="muted">p = 1.9, 2, 2.1, ∞</span> using the given <span class="muted">a/λ<sub>0</sub>, n<sub>1</sub>, Δ</span>.</li>
      </ul>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="callouts">
        <div class="card">
          <h4>Core definitions (symbols &amp; units) <span class="pill">essentials</span></h4>
          <ul>
            <li><span class="muted">a</span>: core radius (m)</li>
            <li><span class="muted">λ<sub>0</sub></span>: free-space wavelength (m)</li>
            <li><span class="muted">n<sub>1</sub></span>: on-axis/core-center refractive index (dimensionless)</li>
            <li><span class="muted">Δ</span>: relative index difference, typically <span class="muted">Δ ≈ (n<sub>1</sub> − n<sub>2</sub>)/n<sub>1</sub></span> (dimensionless, weak guidance)</li>
            <li><span class="muted">NA</span>: numerical aperture (dimensionless)</li>
            <li><span class="muted">V</span>: normalized frequency (dimensionless)</li>
            <li><span class="muted">M</span>: number of guided modes (count)</li>
            <li><span class="muted">σ<sub>t</sub></span>: RMS pulse broadening due to intermodal delay (s)</li>
            <li><span class="muted">L</span>: propagation length (m)</li>
            <li><span class="muted">c</span>: speed of light in vacuum (m/s)</li>
          </ul>
        </div>

        <div class="card">
          <h4>Physical meaning <span class="pill">intuition</span></h4>
          <ul>
            <li><strong>Modes</strong> are distinct field patterns that can propagate without changing shape; in multimode fibers many such patterns exist.</li>
            <li><strong>Modal dispersion</strong> occurs because different modes (or rays) have different group delays, so a short pulse spreads out over distance.</li>
            <li><strong>Graded index</strong> (GI) reduces this: higher-order rays travel longer geometric paths but spend more time in lower-index regions where light goes faster.</li>
            <li><strong>Parabolic profile</strong> (<span class="muted">p=2</span>) is special: the ray oscillation period becomes (nearly) independent of ray amplitude, equalizing group delays.</li>
          </ul>
        </div>
      </div>

      <h3>Key models/approximations and validity</h3>
      <div class="card assump">
        <h4>Assumptions used here <span class="pill">weak guidance</span></h4>
        <ul>
          <li><strong>Weakly guiding fiber:</strong> <span class="muted">Δ ≪ 1</span>, so polarization effects are small and modes are well approximated by LP modes; <span class="muted">NA ≈ n<sub>1</sub>√(2Δ)</span>.</li>
          <li><strong>Many-mode (large-V) counting:</strong> Mode-count formulas use continuum approximations, accurate when <span class="muted">V ≳ 5</span>.</li>
          <li><strong>Ray picture for modal dispersion:</strong> Intermodal delay estimates treat energy distributed across modes/rays and ignore material dispersion &amp; waveguide dispersion (those are separate effects).</li>
        </ul>
      </div>

      <h3>Power-law graded-index profile</h3>
      <p class="muted">
        A common GI model is the <em>power-law</em> profile (often called an “α-profile” with <span class="muted">α=p</span>):
      </p>
      <div class="eq" id="eq_profile">n(r) ≈ n1 · sqrt( 1 − 2Δ · (r/a)^p ),   0 ≤ r ≤ a</div>
      <div class="copyRow">
        <button class="copy" data-copy="#eq_profile">Copy profile equation</button>
      </div>
      <p class="muted">
        For <span class="muted">p → ∞</span>, the profile becomes step-index-like (nearly constant core index with a sharp drop at <span class="muted">r=a</span>). For <span class="muted">p=2</span>, it is parabolic.
      </p>

      <h3>Mini intuition examples (no heavy algebra)</h3>
      <ul>
        <li><strong>Step-index:</strong> high-angle rays bounce more and travel longer paths → arrive later → large intermodal pulse spread.</li>
        <li><strong>Parabolic GI:</strong> high-angle rays go farther out where <span class="muted">n</span> is smaller → higher local speed offsets longer path → near-equal arrival times.</li>
      </ul>

      <div class="card warn">
        <h4>What to watch for <span class="pill">pitfalls</span></h4>
        <ul>
          <li>Mode-count formulas depend on whether you count polarization degeneracy (here: <strong>included</strong>, the common textbook convention).</li>
          <li><span class="muted">Δ</span> and <span class="muted">NA</span> have multiple equivalent definitions; under weak guidance use <span class="muted">NA ≈ n1√(2Δ)</span>.</li>
          <li>“Modal dispersion” here means <strong>intermodal</strong> delay (rays/modes), not chromatic/material dispersion.</li>
          <li>For <span class="muted">p=2</span>, ray theory predicts <em>ideal</em> cancellation; real fibers still have residual broadening from imperfections and higher-order effects.</li>
        </ul>
      </div>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Restate the problem</h3>
      <p class="muted">
        We have a graded-index fiber with core radius-to-wavelength ratio <span class="muted">a/λ<sub>0</sub> = 10</span>,
        center index <span class="muted">n<sub>1</sub> = 1.45</span>, relative index difference <span class="muted">Δ = 0.01</span>,
        and a power-law index profile with exponent <span class="muted">p</span>.
        Determine the <strong>number of guided modes</strong> <span class="muted">M</span> and the
        <strong>modal-dispersion pulse-broadening rate</strong> <span class="muted">σ<sub>t</sub>/L</span>
        for <span class="muted">p = 1.9, 2, 2.1, ∞</span>.
      </p>

      <div class="grid2">
        <div class="card">
          <h4>Given <span class="pill">data</span></h4>
          <ul>
            <li><span class="muted">a/λ<sub>0</sub> = 10</span></li>
            <li><span class="muted">n<sub>1</sub> = 1.45</span></li>
            <li><span class="muted">Δ = 0.01</span></li>
            <li>Power-law exponent: <span class="muted">p</span> (cases: 1.9, 2, 2.1, ∞)</li>
          </ul>
        </div>
        <div class="card">
          <h4>Unknowns <span class="pill">targets</span></h4>
          <ul>
            <li>Mode count <span class="muted">M</span> (dimensionless count)</li>
            <li>Modal broadening rate <span class="muted">σ<sub>t</sub>/L</span> (s/m, often reported as ns/km)</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles and why they apply</h3>
      <ul>
        <li><strong>Normalized frequency:</strong> determines how many transverse solutions exist in a cylindrical waveguide; for large <span class="muted">V</span> we can approximate counts analytically.</li>
        <li><strong>Weak guidance:</strong> since <span class="muted">Δ=0.01</span> is small, LP-mode approximations and simple <span class="muted">NA</span> relations are appropriate.</li>
        <li><strong>Ray theory for modal dispersion:</strong> in multimode fibers, modal dispersion is well captured by comparing transit times of ray families; GI profiles change those times via spatially varying <span class="muted">n(r)</span>.</li>
        <li><strong>What we are not using:</strong> material dispersion (depends on <span class="muted">dn/dλ</span>) and waveguide dispersion (mode-dependent chromatic effects) because the question asks specifically for <em>modal dispersion</em> from the index profile exponent.</li>
      </ul>

      <div class="card assump">
        <h4>Assumptions made explicit <span class="pill">model</span></h4>
        <ul>
          <li>Weak guidance (<span class="muted">Δ ≪ 1</span>), paraxial rays, and multimode regime.</li>
          <li>Mode count uses large-<span class="muted">V</span> approximation.</li>
          <li>Pulse broadening uses a standard ray-theory intermodal delay model; RMS computed assuming roughly uniform delay distribution (a common textbook convention for “modal dispersion rate”).</li>
        </ul>
      </div>

      <h3>Possible approaches (and best choice)</h3>
      <div class="callouts">
        <div class="card">
          <h4>Approach A: Full wave eigenvalue problem <span class="pill">accurate</span></h4>
          <ul>
            <li>Solve vector wave equation numerically for LP modes for each <span class="muted">p</span>.</li>
            <li><strong>Pros:</strong> high accuracy, includes detailed mode structure.</li>
            <li><strong>Cons:</strong> heavy computation; overkill for quick textbook parameters.</li>
          </ul>
        </div>
        <div class="card">
          <h4>Approach B: Weak-guidance asymptotics + ray theory <span class="pill">textbook</span></h4>
          <ul>
            <li>Compute <span class="muted">V</span> from <span class="muted">NA</span>, use analytic <span class="muted">M(V,p)</span> and <span class="muted">σ<sub>t</sub>/L(p)</span>.</li>
            <li><strong>Pros:</strong> fast, transparent, matches “back-of-the-envelope” design rules.</li>
            <li><strong>Cons:</strong> approximate; assumes ideal profile and large <span class="muted">V</span>.</li>
          </ul>
        </div>
      </div>

      <p class="muted"><strong>We choose Approach B</strong> because the problem provides only <span class="muted">a/λ<sub>0</sub>, n<sub>1</sub>, Δ, p</span> and asks for standard textbook quantities across several <span class="muted">p</span> values—exactly what analytic GI formulas are designed for.</p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>
      <ol class="muted" style="margin:8px 0 0 18px;">
        <li><strong>Goal:</strong> Compute <span class="muted">NA</span>. <strong>Tool:</strong> weak guidance relation <span class="muted">NA ≈ n1√(2Δ)</span>. <strong>Meaning:</strong> sets the acceptance cone and transverse confinement strength.</li>
        <li><strong>Goal:</strong> Compute <span class="muted">V</span>. <strong>Tool:</strong> <span class="muted">V = (2πa/λ0) NA</span>. <strong>Meaning:</strong> roughly measures how many transverse wavelengths fit across the core.</li>
        <li><strong>Goal:</strong> Mode count <span class="muted">M</span> for each <span class="muted">p</span>. <strong>Tool:</strong> GI mode-count formula <span class="muted">M ≈ (V²/2)·(p/(p+2))</span>. <strong>Meaning:</strong> more modes → higher capacity for spatial multiplexing, but also more dispersion potential.</li>
        <li><strong>Goal:</strong> Compute modal RMS broadening rate <span class="muted">σt/L</span>. <strong>Tool:</strong> ray-theory intermodal factor <span class="muted">|(p−2)/(p+2)|</span> times step-index scale <span class="muted">n1Δ/c</span>, convert to RMS via <span class="muted">1/√12</span>. <strong>Meaning:</strong> tells how fast pulses spread per unit length due solely to modal delay differences.</li>
        <li><strong>Goal:</strong> Sanity checks. <strong>Tool:</strong> limits <span class="muted">p=2 → 0</span>, <span class="muted">p→∞ → step-index</span>, units in <span class="muted">s/m</span> (or <span class="muted">ns/km</span>).</li>
      </ol>

      <div class="card warn" style="margin-top:12px;">
        <h4>Common mistakes &amp; quick tips <span class="pill">avoid</span></h4>
        <ul>
          <li>Forgetting that <span class="muted">a/λ0</span> is already dimensionless—don’t insert extra powers of 10.</li>
          <li>Mixing up <span class="muted">Δ</span> definitions; under weak guidance the simplest scaling is <span class="muted">NA ≈ n1√(2Δ)</span>.</li>
          <li>Reporting <span class="muted">σt/L</span> without units; designers often prefer <span class="muted">ns/km</span>.</li>
          <li>Interpreting <span class="muted">p=2</span> as “absolutely zero” in practice; here it’s the ideal ray-theory prediction.</li>
        </ul>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Qualitative expectation (before calculating)</h3>
      <p class="muted">
        Because <span class="muted">Δ</span> is small, we expect weak guidance and many modes. A graded index near parabolic
        (<span class="muted">p≈2</span>) should strongly suppress intermodal delay, so <span class="muted">σt/L</span> should be tiny for
        <span class="muted">p=1.9</span> and <span class="muted">p=2.1</span>, and ideally zero for <span class="muted">p=2</span>.
        For <span class="muted">p→∞</span> (step-index limit), modal dispersion becomes large.
      </p>

      <h3>Step 1 — Numerical aperture and V-number</h3>
      <p class="muted">
        In weak guidance (<span class="muted">Δ ≪ 1</span>), the numerical aperture is well approximated by
      </p>
      <div class="eq" id="eq_NA">NA ≈ n1 · sqrt(2Δ)</div>
      <div class="copyRow">
        <button class="copy" data-copy="#eq_NA">Copy NA equation</button>
      </div>

      <p class="muted">
        With <span class="muted">n1 = 1.45</span> and <span class="muted">Δ = 0.01</span>:
      </p>
      <div class="eq" id="eq_NA_num">NA ≈ 1.45 · sqrt(2·0.01) = 1.45 · sqrt(0.02) ≈ 0.2051</div>

      <p class="muted">
        The normalized frequency (V-number) is
      </p>
      <div class="eq" id="eq_V">V = (2πa/λ0) · NA</div>
      <div class="copyRow">
        <button class="copy" data-copy="#eq_V">Copy V equation</button>
      </div>

      <p class="muted">
        Given <span class="muted">a/λ0 = 10</span>, we get
      </p>
      <div class="eq" id="eq_V_num">V = 2π · (a/λ0) · NA = 2π · 10 · 0.2051 ≈ 12.884</div>

      <p class="muted">
        <strong>Why this matters:</strong> since <span class="muted">V ≈ 12.9</span> is comfortably above a few units, the fiber is multimode and large-<span class="muted">V</span> counting formulas are reasonable.
      </p>

      <h3>Step 2 — Number of guided modes for a power-law GI profile</h3>
      <p class="muted">
        For a power-law graded-index profile (weak guidance, large <span class="muted">V</span>), the total number of guided modes (including polarization) is approximated by:
      </p>
      <div class="eq" id="eq_M">M ≈ (V^2 / 2) · ( p / (p + 2) )</div>
      <div class="copyRow">
        <button class="copy" data-copy="#eq_M">Copy mode-count equation</button>
      </div>

      <p class="muted">
        <strong>Interpretation:</strong> for fixed <span class="muted">V</span>, increasing <span class="muted">p</span> makes the profile more step-like and increases the number of modes up toward the step-index limit <span class="muted">M → V²/2</span>.
        For a parabolic profile <span class="muted">p=2</span>, <span class="muted">M ≈ V²/4</span>.
      </p>

      <p class="muted">
        Compute <span class="muted">V²</span>:
      </p>
      <div class="eq" id="eq_V2">V^2 ≈ (12.884)^2 ≈ 166.01</div>

      <p class="muted">
        Now evaluate <span class="muted">M</span> for each case:
      </p>

      <table class="table" aria-label="Mode count results">
        <thead>
          <tr>
            <th>Profile exponent p</th>
            <th>Factor p/(p+2)</th>
            <th>M ≈ (V²/2)·p/(p+2)</th>
            <th>Rounded mode count</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>1.9</td>
            <td class="muted">1.9/3.9 ≈ 0.48718</td>
            <td class="muted">≈ 83.003 · 0.48718 ≈ 40.44</td>
            <td><strong>≈ 40</strong></td>
          </tr>
          <tr>
            <td>2.0</td>
            <td class="muted">2/4 = 0.5</td>
            <td class="muted">≈ 83.003 · 0.5 ≈ 41.50</td>
            <td><strong>≈ 42</strong></td>
          </tr>
          <tr>
            <td>2.1</td>
            <td class="muted">2.1/4.1 ≈ 0.51220</td>
            <td class="muted">≈ 83.003 · 0.51220 ≈ 42.51</td>
            <td><strong>≈ 43</strong></td>
          </tr>
          <tr>
            <td>∞ (step-index limit)</td>
            <td class="muted">→ 1</td>
            <td class="muted">≈ 83.003</td>
            <td><strong>≈ 83</strong></td>
          </tr>
        </tbody>
      </table>

      <h3>Step 3 — Modal-dispersion pulse-broadening rate σ<sub>t</sub>/L</h3>
      <p class="muted">
        A widely used ray-theory estimate for intermodal delay in an α-profile (power-law) GI fiber scales with how far the profile deviates from parabolic (<span class="muted">p=2</span>).
        One convenient form is:
      </p>
      <div class="eq" id="eq_sigma">
σt/L ≈ (n1·Δ / c) · |(p − 2)/(p + 2)| · (1/√12)
      </div>
      <div class="copyRow">
        <button class="copy" data-copy="#eq_sigma">Copy σt/L equation</button>
      </div>

      <p class="muted">
        <strong>What each piece means:</strong>
        <span class="muted">(n1Δ/c)</span> sets the step-index intermodal time scale per meter, the factor
        <span class="muted">|(p−2)/(p+2)|</span> encodes how well the GI profile equalizes path delays, and
        <span class="muted">1/√12</span> converts a roughly uniform delay spread into an RMS width.
      </p>

      <h3>Compute the base scale (n1Δ/c)</h3>
      <p class="muted">
        Using <span class="muted">n1 = 1.45</span>, <span class="muted">Δ = 0.01</span>, <span class="muted">c = 3.00×10^8 m/s</span>:
      </p>
      <div class="eq" id="eq_base">n1Δ/c = (1.45·0.01)/(3.00×10^8) ≈ 4.833×10^-11 s/m</div>

      <p class="muted">
        The step-index RMS broadening rate (the <span class="muted">p→∞</span> limit of the formula) is then:
      </p>
      <div class="eq" id="eq_step_rms">(σt/L)step ≈ (n1Δ/c)/√12 ≈ 1.395×10^-11 s/m = 13.95 ns/km</div>

      <h3>Evaluate σ<sub>t</sub>/L for p = 1.9, 2, 2.1, ∞</h3>
      <table class="table" aria-label="Modal broadening results">
        <thead>
          <tr>
            <th>p</th>
            <th>|(p−2)/(p+2)|</th>
            <th>σt/L (s/m)</th>
            <th>σt/L (ns/km)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>1.9</td>
            <td class="muted">|−0.1/3.9| ≈ 0.02564</td>
            <td class="muted">≈ 3.58×10^-13</td>
            <td><strong>0.358</strong></td>
          </tr>
          <tr>
            <td>2.0</td>
            <td class="muted">0</td>
            <td class="muted">0</td>
            <td><strong>0</strong> (ideal GI)</td>
          </tr>
          <tr>
            <td>2.1</td>
            <td class="muted">|0.1/4.1| ≈ 0.02439</td>
            <td class="muted">≈ 3.40×10^-13</td>
            <td><strong>0.340</strong></td>
          </tr>
          <tr>
            <td>∞</td>
            <td class="muted">→ 1</td>
            <td class="muted">≈ 1.395×10^-11</td>
            <td><strong>13.95</strong></td>
          </tr>
        </tbody>
      </table>

      <div class="card final" style="margin-top:12px;">
        <h4>Final Answer (numbers for the given fiber) <span class="pill">boxed</span></h4>
        <div class="eq" id="eq_finalText">Given a/λ0 = 10, n1 = 1.45, Δ = 0.01:
NA ≈ 0.2051,   V ≈ 12.884.

Mode count:   M ≈ (V^2/2)·(p/(p+2)).
Modal RMS broadening rate:   σt/L ≈ (n1Δ/c)·|(p−2)/(p+2)|/√12.

Results:
p = 1.9:  M ≈ 40.44 (≈ 40),   σt/L ≈ 0.358 ns/km
p = 2.0:  M ≈ 41.50 (≈ 42),   σt/L ≈ 0 ns/km (ideal parabolic)
p = 2.1:  M ≈ 42.51 (≈ 43),   σt/L ≈ 0.340 ns/km
p = ∞:    M ≈ 83.00 (≈ 83),   σt/L ≈ 13.95 ns/km</div>
        <div class="copyRow">
          <button class="copy" data-copy="#eq_finalText">Copy final answer (plain text)</button>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><strong>Units:</strong> <span class="muted">n1Δ/c</span> has units of <span class="muted">s/m</span>, the remaining factors are dimensionless, so <span class="muted">σt/L</span> is <span class="muted">s/m</span>. Converting: <span class="muted">1 s/m = 10^12 ps/m = 10^9 ns/km</span>.</li>
        <li><strong>Limiting case p = 2:</strong> formula gives zero → matches the “parabolic cancels modal dispersion” design principle (idealized).</li>
        <li><strong>Limiting case p → ∞:</strong> factor → 1, so <span class="muted">σt/L</span> becomes the step-index RMS broadening rate.</li>
        <li><strong>Direction/physical sense:</strong> making <span class="muted">p</span> closer to 2 reduces delay spread dramatically, which the numbers show (from ~14 ns/km to ~0.35 ns/km).</li>
      </ul>

      <p class="muted">
        Connection to the visuals below: the diagram shows how the index profile changes with <span class="muted">p</span>,
        while the plots show how <span class="muted">σt/L</span> dips sharply near <span class="muted">p=2</span> and how <span class="muted">M</span> rises toward the step-index limit as <span class="muted">p</span> increases.
      </p>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the formulas</h3>
      <ul>
        <li class="muted"><strong>Mode count:</strong> <span class="muted">M ∝ V²</span> (more transverse “room” → more modes). The factor <span class="muted">p/(p+2)</span> tells you that gentler grading (smaller <span class="muted">p</span>) reduces the number of modes for the same <span class="muted">V</span>.</li>
        <li class="muted"><strong>Modal dispersion:</strong> the scale <span class="muted">n1Δ/c</span> is basically the step-index intermodal delay per meter; GI multiplies this by how imperfectly the profile compensates path length, captured by <span class="muted">|(p−2)/(p+2)|</span>.</li>
        <li class="muted"><strong>Design takeaway:</strong> keep <span class="muted">p</span> as close to 2 as manufacturing allows to minimize intermodal broadening, even if the fiber remains strongly multimode.</li>
      </ul>

      <h3>How changing parameters affects outcomes (connect to plots)</h3>
      <ul>
        <li class="muted">Increasing <span class="muted">a/λ0</span> increases <span class="muted">V</span> linearly → increases <span class="muted">M</span> quadratically (big effect on mode count).</li>
        <li class="muted">Increasing <span class="muted">Δ</span> increases <span class="muted">NA</span> and <span class="muted">V</span>, so it increases <span class="muted">M</span>; it also increases the modal-dispersion scale <span class="muted">n1Δ/c</span>, tending to increase broadening unless <span class="muted">p</span> is very close to 2.</li>
        <li class="muted">Moving <span class="muted">p</span> away from 2 makes <span class="muted">σt/L</span> grow approximately linearly with <span class="muted">|p−2|</span> near 2, which is why the main plot has a sharp “V-shaped” minimum.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p class="muted">
        Instead of ray theory, one can derive modal delay by computing group indices of LP mode families in the weak-guidance approximation, then
        averaging their arrival times with a launch distribution. In the large-<span class="muted">V</span> limit this reproduces the same functional trends:
        <span class="muted">p=2</span> minimizes differential group delay, while <span class="muted">p→∞</span> recovers step-index behavior.
      </p>

      <h3>Concept check (quick self-test)</h3>
      <ul>
        <li class="muted"><strong>Q:</strong> Why does <span class="muted">σt/L</span> vanish at <span class="muted">p=2</span> in the ideal model? <strong>A:</strong> Parabolic grading makes the ray oscillation period independent of amplitude, equalizing transit times across ray families.</li>
        <li class="muted"><strong>Q:</strong> Why does <span class="muted">M</span> scale like <span class="muted">V²</span>? <strong>A:</strong> The number of transverse states in a 2D cross-section grows like area in transverse k-space, which scales as <span class="muted">V²</span>.</li>
        <li class="muted"><strong>Q:</strong> If you increase <span class="muted">Δ</span> while keeping <span class="muted">p=2</span>, what happens to modal dispersion? <strong>A:</strong> Ideal ray theory still predicts ~0 first-order intermodal dispersion, but in practice higher-order imperfections may reintroduce some; mode count still rises because <span class="muted">V</span> rises.</li>
        <li class="muted"><strong>Q:</strong> Why does step-index have larger modal dispersion? <strong>A:</strong> There is no compensating “speed-up” region: longer geometric paths directly translate to longer arrival times.</li>
      </ul>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="viz">
        <div class="controls" role="group" aria-label="Interactive controls">
          <div class="ctrl">
            <label for="pSlider"><strong>Profile exponent</strong> p</label>
            <input id="pSlider" type="range" min="1.0" max="10.0" step="0.01" value="2.00" />
            <span class="pill" id="pReadout">p = 2.00</span>
          </div>

          <div class="ctrl">
            <label for="preset"><strong>Presets</strong></label>
            <select id="preset" aria-label="Preset p values">
              <option value="1.9">p = 1.9</option>
              <option value="2.0" selected>p = 2.0</option>
              <option value="2.1">p = 2.1</option>
              <option value="inf">p = ∞ (step-index)</option>
            </select>
          </div>

          <div class="ctrl">
            <label><input id="infToggle" type="checkbox" /> Treat as step-index (p → ∞)</label>
          </div>
        </div>

        <div class="kpiRow" aria-label="Live computed KPIs">
          <div class="kpi">
            <div class="label">V-number (given fiber)</div>
            <div class="value" id="kpiV">12.884</div>
          </div>
          <div class="kpi">
            <div class="label">Mode count M (approx.)</div>
            <div class="value" id="kpiM">41.50<span class="unit">modes</span></div>
          </div>
          <div class="kpi">
            <div class="label">Modal RMS rate σt/L</div>
            <div class="value" id="kpiSigma">0.000<span class="unit">ns/km</span></div>
          </div>
        </div>

        <figure>
          <canvas id="canvasDiagram" aria-label="Fiber diagram"></canvas>
          <figcaption>
            <strong>Diagram:</strong> Cross-section view: core radius <span class="muted">a</span>, refractive index profile <span class="muted">n(r)</span>,
            and qualitative ray paths. As <span class="muted">p</span> increases, the profile becomes more step-like.
          </figcaption>
        </figure>

        <figure>
          <canvas id="canvasMain" aria-label="Main plot of modal broadening vs p"></canvas>
          <figcaption>
            <strong>Main plot:</strong> Modal RMS broadening rate <span class="muted">σt/L</span> versus <span class="muted">p</span> for this fiber.
            Notice the sharp minimum near <span class="muted">p=2</span> (parabolic GI).
          </figcaption>
        </figure>

        <figure>
          <canvas id="canvasSecondary" aria-label="Secondary plot of mode count vs p"></canvas>
          <figcaption>
            <strong>Secondary plot:</strong> Mode count <span class="muted">M</span> versus <span class="muted">p</span>.
            The count increases toward the step-index limit as <span class="muted">p</span> grows.
          </figcaption>
        </figure>

        <div class="card warn">
          <h4>How the interactive control works <span class="pill">what to expect</span></h4>
          <ul>
            <li>Move the slider to change <span class="muted">p</span> continuously (1 to 10). The diagram updates the index curve, and both plots update live.</li>
            <li>Use presets to jump to the problem’s requested values: <span class="muted">1.9</span>, <span class="muted">2.0</span>, <span class="muted">2.1</span>, and <span class="muted">∞</span>.</li>
            <li>Toggle “step-index” to force <span class="muted">p → ∞</span> and see the modal dispersion rise to the step-index value.</li>
          </ul>
        </div>
      </div>
    </section>

    <footer>
      Built with vanilla HTML/CSS/JS. Formulas use standard weak-guidance multimode approximations for graded-index fibers.
    </footer>

  </main>
</div>

<script>
(function(){
  // ---------- Copy buttons ----------
  async function copyTextFromSelector(sel){
    const el = document.querySelector(sel);
    if(!el) return;
    const text = el.textContent.replace(/\u00A0/g,' ').trim();
    try{
      await navigator.clipboard.writeText(text);
      toast("Copied!");
    }catch(e){
      // fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.style.position='fixed';
      ta.style.left='-9999px';
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      toast("Copied!");
    }
  }

  let toastTimer=null;
  function toast(msg){
    let t = document.getElementById('toast');
    if(!t){
      t = document.createElement('div');
      t.id='toast';
      t.style.position='fixed';
      t.style.right='16px';
      t.style.bottom='16px';
      t.style.padding='10px 12px';
      t.style.borderRadius='14px';
      t.style.border='1px solid rgba(255,255,255,.18)';
      t.style.background='rgba(17,26,51,.85)';
      t.style.backdropFilter='blur(10px)';
      t.style.color='white';
      t.style.boxShadow='0 12px 28px rgba(0,0,0,.35)';
      t.style.fontSize='.95rem';
      t.style.zIndex='9999';
      t.style.transform='translateY(8px)';
      t.style.opacity='0';
      t.style.transition='opacity .18s ease, transform .18s ease';
      document.body.appendChild(t);
    }
    t.textContent = msg;
    t.style.opacity='1';
    t.style.transform='translateY(0)';
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>{ t.style.opacity='0'; t.style.transform='translateY(8px)'; }, 900);
  }

  document.querySelectorAll('button.copy').forEach(btn=>{
    btn.addEventListener('click', ()=> copyTextFromSelector(btn.getAttribute('data-copy')));
  });

  // ---------- Physics parameters (given) ----------
  const n1 = 1.45;
  const Delta = 0.01;
  const aOverLambda = 10.0;  // a / λ0
  const c = 3.0e8;

  // Weak guidance NA
  const NA = n1 * Math.sqrt(2*Delta);
  const V = 2*Math.PI * aOverLambda * NA;
  const V2 = V*V;

  // Base scale for intermodal dispersion
  const base = (n1*Delta)/c;          // s/m
  const baseRMS = base / Math.sqrt(12);

  // ---------- Model functions ----------
  function modeCount(p){
    if(!isFinite(p)) return (V2/2); // p→∞ step-index
    return (V2/2) * (p/(p+2));
  }
  function sigmaRate(p){
    let f;
    if(!isFinite(p)) f = 1.0;
    else f = Math.abs((p-2)/(p+2));
    return baseRMS * f; // s/m (RMS)
  }
  function nProfile(rNorm, p){
    // rNorm = r/a in [0,1]. Use the textbook power-law model.
    if(!isFinite(p)) return n1; // step-like: flat inside core (idealized)
    const inside = Math.max(0, 1 - 2*Delta*Math.pow(rNorm, p));
    return n1 * Math.sqrt(inside);
  }

  // ---------- Controls ----------
  const pSlider = document.getElementById('pSlider');
  const pReadout = document.getElementById('pReadout');
  const preset = document.getElementById('preset');
  const infToggle = document.getElementById('infToggle');

  const kpiV = document.getElementById('kpiV');
  const kpiM = document.getElementById('kpiM');
  const kpiSigma = document.getElementById('kpiSigma');
  kpiV.textContent = V.toFixed(3);

  function getP(){
    if(infToggle.checked) return Infinity;
    return parseFloat(pSlider.value);
  }

  function setP(p){
    if(!isFinite(p)){
      infToggle.checked = true;
      pSlider.disabled = true;
      pReadout.textContent = "p = ∞";
      preset.value = "inf";
      return;
    }
    infToggle.checked = false;
    pSlider.disabled = false;
    pSlider.value = String(p);
    pReadout.textContent = `p = ${p.toFixed(2)}`;
    // Try to match preset if close
    if(Math.abs(p-1.9)<1e-6) preset.value="1.9";
    else if(Math.abs(p-2.0)<1e-6) preset.value="2.0";
    else if(Math.abs(p-2.1)<1e-6) preset.value="2.1";
    else preset.value="2.0"; // harmless default display
  }

  pSlider.addEventListener('input', ()=>{
    if(!infToggle.checked){
      pReadout.textContent = `p = ${parseFloat(pSlider.value).toFixed(2)}`;
      renderAll();
    }
  });

  preset.addEventListener('change', ()=>{
    const v = preset.value;
    if(v === "inf"){ setP(Infinity); }
    else setP(parseFloat(v));
    renderAll();
  });

  infToggle.addEventListener('change', ()=>{
    if(infToggle.checked){
      pSlider.disabled = true;
      pReadout.textContent = "p = ∞";
      preset.value = "inf";
    }else{
      pSlider.disabled = false;
      pReadout.textContent = `p = ${parseFloat(pSlider.value).toFixed(2)}`;
      // if preset was inf, don't force it
    }
    renderAll();
  });

  // Initialize to p=2
  setP(2.0);

  // ---------- Canvas helpers ----------
  function setupCanvas(canvas){
    const ctx = canvas.getContext('2d');
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(260, Math.floor(rect.width));
      const h = Math.max(260, Math.floor(rect.height));
      canvas.width = Math.floor(w*dpr);
      canvas.height = Math.floor(h*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {w,h,dpr};
    }
    return {ctx, resize};
  }

  function niceTicks(min, max, target=6){
    const span = Math.max(1e-12, max-min);
    const raw = span/target;
    const pow = Math.pow(10, Math.floor(Math.log10(raw)));
    const frac = raw/pow;
    let step;
    if(frac<1.5) step=1*pow;
    else if(frac<3) step=2*pow;
    else if(frac<7) step=5*pow;
    else step=10*pow;
    const start = Math.ceil(min/step)*step;
    const ticks=[];
    for(let t=start; t<=max+1e-9; t+=step) ticks.push(t);
    return {step, ticks};
  }

  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
    const {x,y,w,h} = box;
    ctx.save();

    // Background panel
    ctx.fillStyle = "rgba(255,255,255,0.02)";
    ctx.fillRect(x,y,w,h);

    // Title
    ctx.fillStyle = "rgba(233,238,252,0.95)";
    ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(title, x+10, y+18);

    // Plot region
    const padL=54, padR=16, padT=32, padB=46;
    const px = x+padL, py=y+padT, pw=w-padL-padR, ph=h-padT-padB;

    // Axis labels
    ctx.fillStyle = "rgba(183,195,234,0.95)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(xLabel, px + pw/2 - ctx.measureText(xLabel).width/2, py+ph+34);

    ctx.save();
    ctx.translate(px-40, py + ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
    ctx.restore();

    // Ticks
    const xt = niceTicks(xMin,xMax,6);
    const yt = niceTicks(yMin,yMax,5);

    // Grid + ticks
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.lineWidth = 1;

    ctx.beginPath();
    // vertical grid
    xt.ticks.forEach(t=>{
      const X = px + (t-xMin)/(xMax-xMin)*pw;
      ctx.moveTo(X, py);
      ctx.lineTo(X, py+ph);
    });
    // horizontal grid
    yt.ticks.forEach(t=>{
      const Y = py+ph - (t-yMin)/(yMax-yMin)*ph;
      ctx.moveTo(px, Y);
      ctx.lineTo(px+pw, Y);
    });
    ctx.stroke();

    // Axes lines
    ctx.strokeStyle = "rgba(255,255,255,0.22)";
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(px, py+ph);
    ctx.lineTo(px+pw, py+ph);
    ctx.stroke();

    // Tick labels
    ctx.fillStyle = "rgba(183,195,234,0.95)";
    ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";

    xt.ticks.forEach(t=>{
      const X = px + (t-xMin)/(xMax-xMin)*pw;
      const s = (Math.abs(t) >= 1000 || Math.abs(t) < 0.01) ? t.toExponential(1) : t.toFixed( (Math.abs(xt.step)<1) ? 2 : 0);
      ctx.fillText(s, X-ctx.measureText(s).width/2, py+ph+18);
      ctx.beginPath();
      ctx.moveTo(X, py+ph);
      ctx.lineTo(X, py+ph+6);
      ctx.strokeStyle="rgba(255,255,255,0.22)";
      ctx.stroke();
    });

    yt.ticks.forEach(t=>{
      const Y = py+ph - (t-yMin)/(yMax-yMin)*ph;
      const s = (Math.abs(t) >= 1000 || Math.abs(t) < 0.01) ? t.toExponential(1) : t.toFixed( (Math.abs(yt.step)<1) ? 2 : 0);
      ctx.fillText(s, px-8-ctx.measureText(s).width, Y+4);
      ctx.beginPath();
      ctx.moveTo(px-6, Y);
      ctx.lineTo(px, Y);
      ctx.strokeStyle="rgba(255,255,255,0.22)";
      ctx.stroke();
    });

    ctx.restore();
    return {px,py,pw,ph};
  }

  function plotLine(ctx, region, xMin,xMax,yMin,yMax, data, style){
    const {px,py,pw,ph} = region;
    ctx.save();
    ctx.strokeStyle = style.stroke || "rgba(119,212,255,0.95)";
    ctx.lineWidth = style.width || 2;
    ctx.beginPath();
    data.forEach((pt,i)=>{
      const X = px + (pt.x-xMin)/(xMax-xMin)*pw;
      const Y = py+ph - (pt.y-yMin)/(yMax-yMin)*ph;
      if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
    });
    ctx.stroke();
    ctx.restore();
  }

  function plotMarker(ctx, region, xMin,xMax,yMin,yMax, x,y, style){
    const {px,py,pw,ph} = region;
    const X = px + (x-xMin)/(xMax-xMin)*pw;
    const Y = py+ph - (y-yMin)/(yMax-yMin)*ph;
    ctx.save();
    ctx.fillStyle = style.fill || "rgba(167,255,176,0.95)";
    ctx.strokeStyle = style.stroke || "rgba(0,0,0,0)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(X,Y,5,0,Math.PI*2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function drawLegend(ctx, box, items){
    const {x,y,w} = box;
    ctx.save();
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    let lx = x + 10;
    let ly = y + 30;
    items.forEach(it=>{
      ctx.strokeStyle = it.stroke;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(lx, ly);
      ctx.lineTo(lx+22, ly);
      ctx.stroke();
      ctx.fillStyle="rgba(183,195,234,0.95)";
      ctx.fillText(it.label, lx+28, ly+4);
      lx += 28 + ctx.measureText(it.label).width + 18;
      if(lx > x + w - 150){
        lx = x + 10;
        ly += 18;
      }
    });
    ctx.restore();
  }

  // ---------- Canvases ----------
  const diagram = setupCanvas(document.getElementById('canvasDiagram'));
  const mainPlot = setupCanvas(document.getElementById('canvasMain'));
  const secPlot = setupCanvas(document.getElementById('canvasSecondary'));

  // Responsive resize
  const ro = new ResizeObserver(()=> renderAll());
  ro.observe(document.getElementById('canvasDiagram'));
  ro.observe(document.getElementById('canvasMain'));
  ro.observe(document.getElementById('canvasSecondary'));

  // ---------- Drawing: Diagram ----------
  function drawDiagram(p){
    const {ctx, resize} = diagram;
    const {w,h} = resize();
    ctx.clearRect(0,0,w,h);

    // Regions
    const pad = 14;
    const box = {x:pad, y:pad, w:w-2*pad, h:h-2*pad};

    // Title
    ctx.fillStyle = "rgba(233,238,252,0.95)";
    ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText("Fiber cross-section + index profile (schematic)", box.x+10, box.y+18);

    // Split area: left circle, right profile
    const left = {x:box.x+10, y:box.y+32, w:(box.w-30)*0.52, h:box.h-44};
    const right = {x:left.x+left.w+20, y:left.y, w:box.x+box.w - (left.x+left.w+30), h:left.h};

    // Left: cross-section
    const cx = left.x + left.w*0.5;
    const cy = left.y + left.h*0.56;
    const R = Math.min(left.w, left.h)*0.36;

    // Core circle
    ctx.strokeStyle = "rgba(255,255,255,0.28)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx,cy,R,0,Math.PI*2);
    ctx.stroke();

    // Cladding circle
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx,cy,R*1.35,0,Math.PI*2);
    ctx.stroke();

    // Labels
    ctx.fillStyle = "rgba(183,195,234,0.95)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText("core (r ≤ a)", cx - 40, cy - R - 10);
    ctx.fillText("cladding", cx - 26, cy + R*1.35 + 18);

    // Radius arrow
    ctx.strokeStyle = "rgba(119,212,255,0.9)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + R, cy);
    ctx.stroke();
    ctx.fillStyle = "rgba(119,212,255,0.95)";
    ctx.fillText("a", cx + R/2 - 4, cy - 8);

    // Rays (schematic)
    ctx.strokeStyle = "rgba(167,255,176,0.65)";
    ctx.lineWidth = 1.8;
    const rayCount = 5;
    for(let i=0;i<rayCount;i++){
      const t = i/(rayCount-1);
      const amp = (0.15 + 0.5*t) * R;
      ctx.beginPath();
      for(let k=0;k<=80;k++){
        const s = k/80;
        const xx = cx - R*0.9 + 1.8*R*0.9*s;
        const yy = cy + amp*Math.sin(2*Math.PI*s);
        if(k===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
      }
      ctx.stroke();
    }

    // Right: index profile plot inside diagram canvas
    const rx = right.x, ry = right.y, rw = right.w, rh = right.h;

    // mini axes
    const padL=46, padR=12, padT=18, padB=34;
    const px = rx+padL, py = ry+padT, pw = rw-padL-padR, ph = rh-padT-padB;

    // Background
    ctx.fillStyle = "rgba(255,255,255,0.02)";
    ctx.fillRect(rx,ry,rw,rh);

    // axes
    ctx.strokeStyle = "rgba(255,255,255,0.22)";
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(px, py+ph);
    ctx.lineTo(px+pw, py+ph);
    ctx.stroke();

    // labels
    ctx.fillStyle = "rgba(183,195,234,0.95)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText("Index profile n(r)", rx+8, ry+14);

    // axis labels
    ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText("r/a", px + pw/2 - 10, py+ph+26);
    ctx.save();
    ctx.translate(px-32, py+ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText("n", -6, 0);
    ctx.restore();

    // compute profile data
    const nMin = n1*Math.sqrt(Math.max(0, 1-2*Delta)); // approximate edge index
    const nMax = n1;
    const xMin=0, xMax=1;
    const yMin = nMin - 0.003;
    const yMax = nMax + 0.001;

    // grid
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.lineWidth = 1;
    for(let i=0;i<=5;i++){
      const X = px + pw*(i/5);
      ctx.beginPath(); ctx.moveTo(X,py); ctx.lineTo(X,py+ph); ctx.stroke();
    }
    for(let i=0;i<=4;i++){
      const Y = py + ph*(i/4);
      ctx.beginPath(); ctx.moveTo(px,Y); ctx.lineTo(px+pw,Y); ctx.stroke();
    }

    // profile line
    ctx.strokeStyle = "rgba(119,212,255,0.95)";
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    for(let i=0;i<=140;i++){
      const rr = i/140;
      const nn = nProfile(rr, p);
      const X = px + (rr-xMin)/(xMax-xMin)*pw;
      const Y = py+ph - (nn-yMin)/(yMax-yMin)*ph;
      if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
    }
    ctx.stroke();

    // annotate p
    ctx.fillStyle="rgba(167,255,176,0.95)";
    ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    const pText = isFinite(p) ? `p = ${p.toFixed(2)}` : "p = ∞ (step)";
    ctx.fillText(pText, px+8, py+18);

    // edge marker at r=a
    const nEdge = nProfile(1, p);
    const Xedge = px + pw;
    const Yedge = py+ph - (nEdge-yMin)/(yMax-yMin)*ph;
    ctx.fillStyle="rgba(255,210,122,0.95)";
    ctx.beginPath(); ctx.arc(Xedge, Yedge, 4, 0, Math.PI*2); ctx.fill();
    ctx.fillText("r=a", px+pw-28, py+ph+14);
  }

  // ---------- Drawing: Main plot (sigma vs p) ----------
  function drawMain(pNow){
    const {ctx, resize} = mainPlot;
    const {w,h} = resize();
    ctx.clearRect(0,0,w,h);

    const pad = 14;
    const box = {x:pad, y:pad, w:w-2*pad, h:h-2*pad};

    // Sweep p in [1,10] plus show step-index asymptote as a dashed segment at right edge.
    const pMin = 1.0, pMax = 10.0;

    // Compute sigma in ns/km
    const data=[];
    let yMax=0;
    for(let i=0;i<=240;i++){
      const pp = pMin + (pMax-pMin)*i/240;
      const s = sigmaRate(pp) * 1e9 * 1000; // ns/km
      data.push({x:pp, y:s});
      yMax = Math.max(yMax, s);
    }
    const stepVal = sigmaRate(Infinity) * 1e9 * 1000;

    // Scale y to include step-index if it is within range? It's huge compared to near 2.
    // For readability, we cap yMax to show detail near p=2, but also show step as a marker line at top if larger.
    const showCap = Math.max(0.6, yMax*1.25); // typically < 1 ns/km for this fiber in [1,10]
    const yCap = showCap;
    const yMin = 0;
    const yMaxPlot = yCap;

    const region = drawAxes(ctx, box, pMin, pMax, yMin, yMaxPlot, "p (profile exponent)", "σt/L (ns/km)", "Modal RMS broadening rate vs profile exponent");

    // Line (clipped to yMaxPlot)
    const clipped = data.map(pt => ({x:pt.x, y:Math.min(pt.y, yMaxPlot)}));
    plotLine(ctx, region, pMin, pMax, yMin, yMaxPlot, clipped, {stroke:"rgba(119,212,255,0.95)", width:2.4});

    // Marker for current p
    const pDisplay = isFinite(pNow) ? pNow : pMax;
    const sNow = (isFinite(pNow) ? sigmaRate(pNow) : sigmaRate(Infinity)) * 1e9 * 1000;
    plotMarker(ctx, region, pMin, pMax, yMin, yMaxPlot, pDisplay, Math.min(sNow, yMaxPlot), {fill:"rgba(167,255,176,0.95)"});

    // Step-index indicator (horizontal dashed line at top edge if above yMaxPlot)
    ctx.save();
    const {px,py,pw,ph} = region;
    ctx.strokeStyle = "rgba(255,210,122,0.85)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);
    if(stepVal > yMaxPlot){
      // draw at y = yMaxPlot (cap), annotate true value
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(px+pw, py);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(255,210,122,0.95)";
      ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillText(`step-index RMS = ${stepVal.toFixed(2)} ns/km (off-scale)`, px+10, py+16);
    } else {
      const Y = py+ph - (stepVal-yMin)/(yMaxPlot-yMin)*ph;
      ctx.beginPath();
      ctx.moveTo(px, Y);
      ctx.lineTo(px+pw, Y);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(255,210,122,0.95)";
      ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillText(`step-index RMS = ${stepVal.toFixed(2)} ns/km`, px+10, Y-8);
    }
    ctx.restore();

    // Legend
    drawLegend(ctx, box, [
      {stroke:"rgba(119,212,255,0.95)", label:"GI model σt/L(p)"},
      {stroke:"rgba(167,255,176,0.95)", label:"current p"},
      {stroke:"rgba(255,210,122,0.85)", label:"step-index RMS"}
    ]);

    // Note about scaling
    ctx.save();
    ctx.fillStyle="rgba(183,195,234,0.85)";
    ctx.font="11px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText("Note: y-axis focuses on GI behavior near p≈2; step-index value may be off-scale.", box.x+10, box.y+box.h-8);
    ctx.restore();
  }

  // ---------- Drawing: Secondary plot (M vs p) ----------
  function drawSecondary(pNow){
    const {ctx, resize} = secPlot;
    const {w,h} = resize();
    ctx.clearRect(0,0,w,h);

    const pad = 14;
    const box = {x:pad, y:pad, w:w-2*pad, h:h-2*pad};

    const pMin=1.0, pMax=10.0;
    const data=[];
    let yMax=0;
    for(let i=0;i<=200;i++){
      const pp = pMin + (pMax-pMin)*i/200;
      const m = modeCount(pp);
      data.push({x:pp, y:m});
      yMax = Math.max(yMax, m);
    }
    const stepM = modeCount(Infinity);

    const yMin=0;
    const yMaxPlot = Math.max(stepM, yMax)*1.05;

    const region = drawAxes(ctx, box, pMin,pMax, yMin,yMaxPlot, "p (profile exponent)", "M (modes)", "Number of guided modes vs profile exponent");

    plotLine(ctx, region, pMin,pMax, yMin,yMaxPlot, data, {stroke:"rgba(167,255,176,0.95)", width:2.4});

    // current marker
    const pDisplay = isFinite(pNow) ? pNow : pMax;
    const mNow = isFinite(pNow) ? modeCount(pNow) : stepM;
    plotMarker(ctx, region, pMin,pMax, yMin,yMaxPlot, pDisplay, mNow, {fill:"rgba(119,212,255,0.95)"});

    // step-index horizontal line
    const {px,py,pw,ph} = region;
    ctx.save();
    const Y = py+ph - (stepM-yMin)/(yMaxPlot-yMin)*ph;
    ctx.strokeStyle="rgba(255,210,122,0.85)";
    ctx.lineWidth=2;
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(px, Y);
    ctx.lineTo(px+pw, Y);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle="rgba(255,210,122,0.95)";
    ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ctx.fillText(`step-index M = ${stepM.toFixed(1)}`, px+10, Math.max(py+14, Y-8));
    ctx.restore();

    drawLegend(ctx, box, [
      {stroke:"rgba(167,255,176,0.95)", label:"M(p)"},
      {stroke:"rgba(119,212,255,0.95)", label:"current p"},
      {stroke:"rgba(255,210,122,0.85)", label:"step-index limit"}
    ]);
  }

  // ---------- Render all ----------
  function renderAll(){
    const p = getP();

    // KPIs
    const Mnow = modeCount(p);
    const snow = sigmaRate(p) * 1e9 * 1000; // ns/km
    kpiM.innerHTML = `${Mnow.toFixed(2)}<span class="unit">modes</span>`;
    kpiSigma.innerHTML = `${snow.toFixed(3)}<span class="unit">ns/km</span>`;

    // Readout
    if(isFinite(p)) pReadout.textContent = `p = ${p.toFixed(2)}`;
    else pReadout.textContent = "p = ∞";

    drawDiagram(p);
    drawMain(p);
    drawSecondary(p);
  }

  window.addEventListener('resize', renderAll, {passive:true});
  renderAll();
})();
</script>

</body>
</html>
