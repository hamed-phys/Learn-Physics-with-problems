<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Step-Index Fiber: V-Parameter, Propagation Constants, Phase & Group Velocities (LP0m)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#101a33;
      --card2:#0e1630;
      --ink:#eaf0ff;
      --muted:#b7c3e6;
      --faint:#7f8bb6;
      --accent:#7cf0c6;
      --accent2:#89a7ff;
      --warn:#ffcc66;
      --bad:#ff6b8a;
      --good:#7cf0c6;
      --line:rgba(255,255,255,.10);
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1100px 700px at 20% 0%, rgba(137,167,255,.18), transparent 55%),
                  radial-gradient(900px 700px at 90% 10%, rgba(124,240,198,.12), transparent 55%),
                  linear-gradient(180deg, #070a14, var(--bg));
      color:var(--ink);
      line-height:1.55;
    }

    header{
      padding:28px 18px 10px;
      max-width:1200px;
      margin:0 auto;
    }
    header .top{
      display:flex;
      gap:18px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-size:clamp(1.35rem, 2.2vw, 2.05rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:.35rem 0 0;
      color:var(--muted);
      max-width:70ch;
      font-size:1rem;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding:14px 18px 70px;
      display:grid;
      grid-template-columns: 1fr 290px;
      gap:18px;
    }

    @media (max-width: 980px){
      main{grid-template-columns:1fr}
      .toc{position:relative; top:auto}
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .card .pad{padding:16px 16px 14px}
    .card h2, .card h3{
      margin:0 0 10px;
      letter-spacing:.2px;
    }
    .card h2{font-size:1.25rem}
    .card h3{font-size:1.05rem; color:var(--ink)}

    .grid2{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:14px;
    }
    @media (max-width: 980px){
      .grid2{grid-template-columns:1fr}
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      background:rgba(124,240,198,.10);
      border:1px solid rgba(124,240,198,.25);
      border-radius:999px;
      color:var(--ink);
      font-size:.9rem;
      margin-top:10px;
      flex-wrap:wrap;
    }
    .pill b{color:var(--accent)}
    .kpi{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:10px;
      margin-top:10px;
    }
    .kpi .box{
      background:rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:10px 12px;
    }
    .kpi .label{color:var(--faint); font-size:.85rem}
    .kpi .val{font-weight:650; margin-top:2px}
    .kpi .val small{color:var(--muted); font-weight:500}

    .callouts{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:12px;
      margin-top:12px;
    }
    @media (max-width: 980px){
      .callouts{grid-template-columns:1fr}
    }
    .callout{
      border-radius:16px;
      padding:12px 12px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.16);
    }
    .callout .t{font-weight:700; margin-bottom:6px}
    .callout.assump .t{color:var(--accent)}
    .callout.eq .t{color:var(--accent2)}
    .callout.warn .t{color:var(--warn)}
    .callout.bad .t{color:var(--bad)}

    ul{margin:10px 0 0 18px}
    li{margin:6px 0}
    .muted{color:var(--muted)}
    .faint{color:var(--faint)}

    .toc{
      position:sticky;
      top:14px;
      align-self:start;
      padding:14px;
    }
    .toc h3{
      margin:0 0 10px;
      font-size:1.02rem;
    }
    .toc a{
      display:block;
      text-decoration:none;
      color:var(--muted);
      padding:6px 8px;
      border-radius:10px;
      border:1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      font-size:.95rem;
      line-height:1.2;
    }
    .toc a:hover{
      background:rgba(137,167,255,.10);
      border-color:rgba(137,167,255,.22);
      transform:translateX(2px);
      color:var(--ink);
    }

    .eqblock{
      background:rgba(0,0,0,.20);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:10px 10px 8px;
      margin:10px 0 0;
      overflow:auto;
      position:relative;
    }
    pre{
      margin:0;
      font-family:var(--mono);
      font-size:.92rem;
      line-height:1.35;
      color:#eaf0ff;
      white-space:pre-wrap;
    }
    .copyrow{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-top:8px;
      flex-wrap:wrap;
    }
    .btn{
      cursor:pointer;
      user-select:none;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.06);
      color:var(--ink);
      padding:8px 10px;
      border-radius:12px;
      font-weight:650;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:.92rem;
    }
    .btn:hover{
      transform:translateY(-1px);
      background:rgba(255,255,255,.10);
      border-color:rgba(255,255,255,.22);
    }
    .btn:active{transform:translateY(0px) scale(.99)}
    .btn.good{border-color:rgba(124,240,198,.35); background:rgba(124,240,198,.10)}
    .btn.good:hover{background:rgba(124,240,198,.14)}
    .btn.bad{border-color:rgba(255,107,138,.35); background:rgba(255,107,138,.08)}
    .btn.small{padding:6px 9px; font-size:.88rem}

    .controls{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:10px;
      margin-top:10px;
      align-items:end;
    }
    @media (max-width: 700px){
      .controls{grid-template-columns:1fr}
    }
    label{display:block; color:var(--muted); font-size:.9rem; margin-bottom:6px}
    input[type="range"]{width:100%}
    select{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(0,0,0,.18);
      color:var(--ink);
      outline:none;
    }
    .note{
      font-size:.92rem;
      color:var(--muted);
      margin-top:10px;
    }

    .canvasWrap{
      background:rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      padding:10px;
      margin-top:10px;
    }
    canvas{
      width:100%;
      height:300px;
      display:block;
      border-radius:12px;
      background:rgba(9,13,28,.6);
    }
    .cap{
      margin-top:8px;
      color:var(--muted);
      font-size:.92rem;
    }

    .divider{
      height:1px;
      background:linear-gradient(90deg, transparent, rgba(255,255,255,.14), transparent);
      margin:12px 0;
    }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding:18px 18px 40px;
      color:var(--faint);
      font-size:.92rem;
    }

    /* subtle motion */
    @media (prefers-reduced-motion: no-preference){
      .card{animation: rise .45s ease both}
      @keyframes rise{from{opacity:0; transform:translateY(8px)} to{opacity:1; transform:translateY(0)}}
    }

    /* print-friendly */
    @media print{
      body{background:#fff; color:#000}
      main{grid-template-columns:1fr}
      .toc{display:none}
      .card{box-shadow:none}
      canvas{display:none}
      .btn{display:none}
      .eqblock{border:1px solid #ccc; background:#fff}
      .callout{background:#fff; border:1px solid #ccc}
    }
  </style>
</head>

<body>
  <header>
    <div class="top">
      <div>
        <h1>Propagation Constants &amp; Group Velocities in a Step-Index Fiber (LP<sub>0m</sub>)</h1>
        <p class="subtitle">
          We connect the <span class="muted">V-parameter</span>, the scalar (LP) eigenvalue equation, and
          <span class="muted">waveguide dispersion</span> to compute core radius, propagation constants, phase velocity,
          and group velocity (material dispersion ignored).
        </p>
        <div class="pill">
          <span>Given:</span>
          <b>n<sub>1</sub>=1.444</b> <span class="muted">(core)</span> ·
          <b>n<sub>2</sub>=1.443</b> <span class="muted">(clad)</span> ·
          <b>&lambda;<sub>0</sub>=1.55&nbsp;&mu;m</b>
        </div>
      </div>
    </div>
  </header>

  <main>
    <article class="card">
      <div class="pad" id="quick-summary">
        <h2>Quick Summary</h2>
        <ul>
          <li>This problem is about <b>step-index fiber modes</b>: how many are guided and what their <b>propagation constants</b> &beta; are.</li>
          <li>Key physics idea: guidance is set by the <b>normalized frequency</b> <b>V</b>, and each LP mode corresponds to an eigenvalue <b>u</b> solving a Bessel-function characteristic equation.</li>
          <li>Governing equation (for <b>l=0</b>): <span class="muted">u J<sub>1</sub>(u)/J<sub>0</sub>(u) = w K<sub>1</sub>(w)/K<sub>0</sub>(w)</span>, with <span class="muted">w = sqrt(V² − u²)</span>.</li>
          <li>Once <b>u</b> is known: <b>b = 1 − (u/V)²</b>, <b>n<sub>eff</sub> = sqrt(n<sub>2</sub>² + b (n<sub>1</sub>²−n<sub>2</sub>²))</b>, <b>&beta; = k<sub>0</sub> n<sub>eff</sub></b>.</li>
          <li>Core radius for a target V: <b>a = V &lambda;<sub>0</sub> / (2&pi; NA)</b>, where <b>NA = sqrt(n<sub>1</sub>² − n<sub>2</sub>²)</b>.</li>
          <li>Waveguide (group) velocity ignoring material dispersion: <b>n<sub>g</sub> = d&beta;/dk<sub>0</sub> = n<sub>eff</sub> + (V (n<sub>1</sub>²−n<sub>2</sub>²)/(2 n<sub>eff</sub>)) (db/dV)</b>, so <b>v<sub>g</sub>=c/n<sub>g</sub></b>.</li>
          <li>Final results are primarily <b>numeric</b>: core radii for V=10 and V=4, and (&beta;, v<sub>p</sub>, v<sub>g</sub>) for LP<sub>01</sub> at V=4.</li>
        </ul>
      </div>

      <div class="divider"></div>

      <div class="pad" id="part0">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <div class="callouts">
          <div class="callout eq">
            <div class="t">Core definitions</div>
            <ul>
              <li><b>k<sub>0</sub></b> = 2&pi;/&lambda;<sub>0</sub> (rad/m): free-space wavenumber.</li>
              <li><b>NA</b> = sqrt(n<sub>1</sub>² − n<sub>2</sub>²): numerical aperture (dimensionless).</li>
              <li><b>V</b> = k<sub>0</sub> a NA: normalized frequency (dimensionless).</li>
              <li><b>&beta;</b> (1/m): axial propagation constant, sets phase advance exp(i&beta;z).</li>
              <li><b>n<sub>eff</sub></b> = &beta;/k<sub>0</sub>: effective index of a mode.</li>
              <li><b>b</b> = (n<sub>eff</sub>²−n<sub>2</sub>²)/(n<sub>1</sub>²−n<sub>2</sub>²): normalized propagation constant (0→1).</li>
            </ul>
          </div>

          <div class="callout assump">
            <div class="t">Physical meaning</div>
            <ul>
              <li><b>V</b> measures how many transverse oscillations “fit” in the core: bigger V → more guided modes.</li>
              <li><b>&beta;</b> lies between k<sub>0</sub>n<sub>2</sub> and k<sub>0</sub>n<sub>1</sub>. Closer to n<sub>1</sub> means stronger confinement.</li>
              <li><b>Group velocity</b> differs from phase velocity because the modal shape changes with frequency (waveguide dispersion).</li>
            </ul>
          </div>
        </div>

        <div class="callouts">
          <div class="callout eq">
            <div class="t">Key laws / model</div>
            <ul>
              <li>We use the <b>weakly guiding approximation</b> (Δ ≪ 1) so modes are well-described by <b>LP<sub>lm</sub></b> fields.</li>
              <li>Radial field behavior: oscillatory in core (Bessel J) and evanescent in cladding (modified Bessel K).</li>
              <li>Boundary conditions at r=a lead to a <b>characteristic equation</b> for the eigenvalue <b>u</b>.</li>
            </ul>
          </div>

          <div class="callout warn">
            <div class="t">What to watch for (pitfalls)</div>
            <ul>
              <li><b>Don’t confuse</b> V (dimensionless) with velocity v.</li>
              <li>For l=0, higher-order LP<sub>0m</sub> modes have <b>cutoffs</b> near zeros of J<sub>1</sub>.</li>
              <li>“Ignore material dispersion” means n<sub>1</sub>, n<sub>2</sub> constant vs wavelength, but <b>waveguide dispersion remains</b>.</li>
            </ul>
          </div>
        </div>

        <div class="callout" style="margin-top:12px">
          <div class="t" style="color:var(--accent2)">Mini intuition examples</div>
          <ul>
            <li>If V is just above a cutoff, a higher-order mode barely fits: <b>b ≈ 0</b>, so n<sub>eff</sub> ≈ n<sub>2</sub> and confinement is weak.</li>
            <li>If V is very large, the fundamental mode is tightly confined: <b>b → 1</b>, so n<sub>eff</sub> → n<sub>1</sub>.</li>
          </ul>
        </div>
      </div>

      <div class="divider"></div>

      <div class="pad" id="part1">
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

        <p>
          <b>Restatement:</b> A step-index fiber (core index n<sub>1</sub>, cladding index n<sub>2</sub>) operates at
          &lambda;<sub>0</sub>=1.55&nbsp;&mu;m. (i) Find the core radius <b>a</b> such that the V-parameter equals 10.
          (ii) For that V=10, estimate the propagation constants of all guided modes with azimuthal index <b>l=0</b>
          (i.e., LP<sub>0m</sub> family). (iii) Then change the core radius so that V=4, and determine for LP<sub>01</sub>:
          phase velocity, propagation constant, and group velocity, ignoring material dispersion.
        </p>

        <div class="grid2">
          <div class="callout">
            <div class="t" style="color:var(--accent)">Given</div>
            <ul>
              <li>n<sub>1</sub> = 1.444</li>
              <li>n<sub>2</sub> = 1.443</li>
              <li>&lambda;<sub>0</sub> = 1.55 &mu;m</li>
              <li>Target V values: 10 and 4</li>
            </ul>
          </div>

          <div class="callout">
            <div class="t" style="color:var(--accent)">Unknowns / tasks</div>
            <ul>
              <li>Core radius a for V=10 (and for V=4)</li>
              <li>For V=10: all guided <b>l=0</b> propagation constants &beta;<sub>0m</sub></li>
              <li>For V=4 (LP<sub>01</sub>): v<sub>p</sub>, &beta;, v<sub>g</sub></li>
            </ul>
          </div>
        </div>

        <div class="callouts" style="margin-top:12px">
          <div class="callout assump">
            <div class="t">Relevant principles (and why)</div>
            <ul>
              <li><b>V-parameter</b> connects geometry (a), wavelength (&lambda;<sub>0</sub>), and index contrast via NA.</li>
              <li><b>Scalar LP eigenvalue equation</b> gives u (hence b, n<sub>eff</sub>, &beta;) for each mode.</li>
              <li><b>Group velocity</b> comes from dispersion relation &beta;(ω); here dispersion is purely waveguide (n’s constant).</li>
            </ul>
          </div>

          <div class="callout warn">
            <div class="t">Assumptions</div>
            <ul>
              <li>Weak guidance (Δ small), so LP mode model is valid.</li>
              <li>Step-index profile, lossless, straight fiber.</li>
              <li>Ignore material dispersion: n<sub>1</sub>, n<sub>2</sub> independent of wavelength (but mode confinement still changes with V).</li>
            </ul>
          </div>
        </div>

        <div class="callout" style="margin-top:12px">
          <div class="t" style="color:var(--accent2)">Possible approaches (choose best)</div>
          <ul>
            <li><b>Graphical (as in the figures):</b> plot LHS and RHS vs u and read intersections. Pro: matches textbook workflow. Con: limited precision.</li>
            <li><b>Numeric eigenvalue solve:</b> compute intersections by root-finding. Pro: precise and reproducible; also supports interactive plots. Con: requires Bessel evaluation code.</li>
            <li><b>Asymptotic approximations:</b> good for large V. Pro: quick intuition. Con: not accurate near moderate V (e.g., V=4).</li>
          </ul>
          <p class="muted" style="margin:8px 0 0">
            <b>Chosen here:</b> We keep the figure-based logic (intersections per branch) but compute the intersections numerically
            to produce clean propagation constants and live plots (equivalent to “reading the graph,” just higher resolution).
          </p>
        </div>
      </div>

      <div class="divider"></div>

      <div class="pad" id="part2">
        <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>

        <ol style="margin:10px 0 0 18px">
          <li>
            <b>Compute NA</b> from n<sub>1</sub>, n<sub>2</sub>.
            <span class="muted">Tool:</span> NA = sqrt(n<sub>1</sub>²−n<sub>2</sub>²).
            <span class="muted">Meaning:</span> sets acceptance and modal scaling.
          </li>
          <li>
            <b>Find core radius a</b> for a target V.
            <span class="muted">Tool:</span> V = (2&pi;/&lambda;<sub>0</sub>) a NA ⇒ a = V &lambda;<sub>0</sub>/(2&pi;NA).
            <span class="muted">Meaning:</span> the geometry that yields a given modal “capacity.”
          </li>
          <li>
            <b>For l=0, solve eigenvalue equation</b> for u in (0,V).
            <span class="muted">Tool:</span> u J<sub>1</sub>(u)/J<sub>0</sub>(u) = w K<sub>1</sub>(w)/K<sub>0</sub>(w), w=sqrt(V²−u²).
            <span class="muted">Meaning:</span> boundary matching for each guided LP<sub>0m</sub>.
          </li>
          <li>
            <b>Convert u → b → n<sub>eff</sub> → &beta;</b>.
            <span class="muted">Tool:</span> b=1-(u/V)²; n<sub>eff</sub>=sqrt(n<sub>2</sub>²+b(n<sub>1</sub>²−n<sub>2</sub>²)); &beta;=k<sub>0</sub>n<sub>eff</sub>.
            <span class="muted">Meaning:</span> how strongly the mode is guided and its axial phase evolution.
          </li>
          <li>
            <b>Phase velocity</b> for LP<sub>01</sub> at V=4.
            <span class="muted">Tool:</span> v<sub>p</sub>=ω/&beta;=c/n<sub>eff</sub>.
            <span class="muted">Meaning:</span> speed of constant-phase planes.
          </li>
          <li>
            <b>Group velocity (waveguide dispersion)</b>.
            <span class="muted">Tool:</span> n<sub>g</sub>=d&beta;/dk<sub>0</sub>=n<sub>eff</sub>+(V(n<sub>1</sub>²−n<sub>2</sub>²)/(2n<sub>eff</sub>)) (db/dV); v<sub>g</sub>=c/n<sub>g</sub>.
            <span class="muted">Meaning:</span> pulse/envelope speed.
          </li>
        </ol>

        <div class="callouts">
          <div class="callout warn">
            <div class="t">Common mistakes</div>
            <ul>
              <li>Using n<sub>1</sub> or n<sub>2</sub> directly for v<sub>g</sub> without accounting for db/dV.</li>
              <li>Forgetting that V changes with k<sub>0</sub> when computing v<sub>g</sub> (even if indices are constant).</li>
              <li>Mixing units: &lambda; in &mu;m vs meters when computing a and &beta;.</li>
            </ul>
          </div>
          <div class="callout">
            <div class="t" style="color:var(--accent)">Quick tips</div>
            <ul>
              <li>Sanity: n<sub>2</sub> &lt; n<sub>eff</sub> &lt; n<sub>1</sub> and k<sub>0</sub>n<sub>2</sub> &lt; &beta; &lt; k<sub>0</sub>n<sub>1</sub>.</li>
              <li>Higher radial order m → smaller b → n<sub>eff</sub> closer to n<sub>2</sub>.</li>
              <li>At cutoff, b→0 and confinement vanishes.</li>
            </ul>
          </div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="pad" id="part3">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Physical intuition first</h3>
        <p>
          With a small index contrast (n<sub>1</sub>−n<sub>2</sub>=0.001), the fiber is weakly guiding.
          When V=10, the core is “large enough” (relative to &lambda;) to support several LP modes. For l=0, we expect the
          fundamental LP<sub>01</sub> plus a few radial higher orders LP<sub>02</sub>, LP<sub>03</sub>, ... until V drops below the next cutoff.
          When V is reduced to 4, fewer modes exist, but LP<sub>01</sub> remains guided and has an effective index closer to n<sub>1</sub> than n<sub>2</sub>.
        </p>

        <div class="callout eq">
          <div class="t">Key equations (copyable)</div>
          <div class="eqblock" id="eqKey">
<pre>NA = sqrt(n1^2 - n2^2)
V = k0 * a * NA = (2π/λ0) * a * NA
a = V * λ0 / (2π * NA)

(l = 0) eigenvalue equation:
u * J1(u)/J0(u) = w * K1(w)/K0(w),   w = sqrt(V^2 - u^2)

b = 1 - (u/V)^2
neff = sqrt(n2^2 + b*(n1^2 - n2^2))
β = k0 * neff

vp = c / neff
ng = dβ/dk0 = neff + [V*(n1^2 - n2^2)/(2*neff)] * (db/dV)
vg = c / ng</pre>
          </div>
          <div class="copyrow">
            <button class="btn small good" onclick="copyFrom('eqKey')">Copy key equations</button>
            <span class="faint">Copied text is plain (no formatting).</span>
          </div>
        </div>

        <h3>Step 1: Compute NA</h3>
        <p>
          <b>Definition:</b> NA = sqrt(n<sub>1</sub>² − n<sub>2</sub>²).
        </p>
        <div class="eqblock" id="eqNA">
<pre>n1 = 1.444,  n2 = 1.443
NA = sqrt(1.444^2 - 1.443^2) ≈ 0.0537308</pre>
        </div>
        <div class="copyrow">
          <button class="btn small" onclick="copyFrom('eqNA')">Copy NA step</button>
        </div>

        <h3>Step 2: Core radius a for V = 10</h3>
        <p>
          Using V = (2&pi;/&lambda;<sub>0</sub>) a NA, solve for a:
          a = V &lambda;<sub>0</sub>/(2&pi;NA).
        </p>
        <div class="eqblock" id="eqA10">
<pre>λ0 = 1.55e-6 m
a(V=10) = 10 * λ0 / (2π * NA)
       ≈ 10 * 1.55e-6 / (2π * 0.0537308)
       ≈ 4.591e-5 m = 45.9 μm</pre>
        </div>
        <div class="copyrow">
          <button class="btn small" onclick="copyFrom('eqA10')">Copy a(V=10)</button>
        </div>

        <h3>Step 3: Guided l = 0 modes at V = 10 and their propagation constants</h3>
        <p>
          For <b>l = 0</b>, the characteristic equation can be visualized exactly like your Fig. 10.2-3:
          the LHS has branches separated by zeros of J<sub>0</sub>(u) (poles), and each branch intersects the RHS at most once.
          Each intersection gives one guided LP<sub>0m</sub> mode.
        </p>

        <p class="muted">
          Numerically (equivalent to “reading the intersections”), the eigenvalues u for V=10 are:
          u<sub>01</sub>≈2.1845, u<sub>02</sub>≈4.9966, u<sub>03</sub>≈7.7642.
          These correspond to LP<sub>01</sub>, LP<sub>02</sub>, LP<sub>03</sub> (the next cutoff is near the next J<sub>1</sub> zero at ≈10.173, so LP<sub>04</sub> is not guided at V=10).
        </p>

        <div class="callout">
          <div class="t" style="color:var(--accent2)">Compute b, n<sub>eff</sub>, and &beta; for each mode</div>
          <div class="eqblock" id="eqModes10">
<pre>k0 = 2π/λ0 ≈ 4.053667e6  1/m
Δn2 = n1^2 - n2^2

For each mode:  b = 1 - (u/V)^2
               neff = sqrt(n2^2 + b*Δn2)
               β = k0 * neff

V = 10:

LP01: u ≈ 2.1845 → b ≈ 0.95228 → neff ≈ 1.4439523 → β ≈ 5.853303e6 1/m
LP02: u ≈ 4.9966 → b ≈ 0.75034 → neff ≈ 1.4437504 → β ≈ 5.852485e6 1/m
LP03: u ≈ 7.7642 → b ≈ 0.39717 → neff ≈ 1.4433973 → β ≈ 5.851053e6 1/m</pre>
          </div>
          <div class="copyrow">
            <button class="btn small good" onclick="copyFrom('eqModes10')">Copy V=10 mode results</button>
            <span class="faint">Sanity: β is between k0 n2 and k0 n1.</span>
          </div>
        </div>

        <h3>Step 4: Change core radius so V = 4</h3>
        <p>
          Same formula: a = V &lambda;<sub>0</sub>/(2&pi;NA).
        </p>
        <div class="eqblock" id="eqA4">
<pre>a(V=4) = 4 * λ0 / (2π * NA)
      ≈ 1.836e-5 m = 18.36 μm</pre>
        </div>
        <div class="copyrow">
          <button class="btn small" onclick="copyFrom('eqA4')">Copy a(V=4)</button>
        </div>

        <h3>Step 5: LP<sub>01</sub> at V = 4 — phase velocity, propagation constant, group velocity</h3>
        <p>
          Solve the l=0 eigenvalue equation again but now with V=4, taking the <b>first branch</b> (fundamental).
          Numerically: u<sub>01</sub>(V=4) ≈ 1.9069, hence b = 1 − (u/V)² ≈ 0.7727.
        </p>

        <div class="callout eq">
          <div class="t">LP<sub>01</sub> quantities at V = 4</div>
          <div class="eqblock" id="eqLP01V4">
<pre>V = 4:
u ≈ 1.9069
b = 1 - (u/V)^2 ≈ 0.772734
neff = sqrt(n2^2 + b*(n1^2 - n2^2)) ≈ 1.4437728

β = k0 * neff ≈ 5.852575e6 1/m

Phase velocity:
vp = c / neff ≈ 2.07645e8 m/s

Group velocity (material dispersion ignored):
Compute db/dV near V=4 (waveguide dispersion):
db/dV ≈ 0.08840

ng = neff + [V*(n1^2 - n2^2)/(2*neff)] * (db/dV) ≈ 1.4441263
vg = c / ng ≈ 2.07594e8 m/s</pre>
          </div>
          <div class="copyrow">
            <button class="btn small good" onclick="copyFrom('eqLP01V4')">Copy LP01 (V=4) results</button>
          </div>
        </div>

        <div class="callouts">
          <div class="callout assump">
            <div class="t">Sanity checks</div>
            <ul>
              <li><b>Units:</b> a in meters; k<sub>0</sub> in 1/m; &beta; in 1/m; velocities in m/s.</li>
              <li><b>Bounds:</b> n<sub>2</sub> &lt; n<sub>eff</sub> &lt; n<sub>1</sub> ⇒ k<sub>0</sub>n<sub>2</sub> &lt; &beta; &lt; k<sub>0</sub>n<sub>1</sub> (satisfied).</li>
              <li><b>Limiting case:</b> as V → cutoff for higher modes, b → 0 and n<sub>eff</sub> → n<sub>2</sub>.</li>
              <li><b>Interpretation:</b> v<sub>g</sub> is slightly smaller than v<sub>p</sub> because confinement increases with frequency (db/dV &gt; 0) → waveguide dispersion.</li>
            </ul>
          </div>
          <div class="callout">
            <div class="t" style="color:var(--accent2)">Connect to the diagram &amp; plots</div>
            <p class="muted" style="margin:0">
              The diagram shows a core of radius <b>a</b> and indices n<sub>1</sub>, n<sub>2</sub>.
              The plots track how eigenvalues (u), normalized propagation (b), and the derived quantities
              (&beta;, n<sub>eff</sub>, v<sub>p</sub>, v<sub>g</sub>) change as V is varied—exactly the graphical idea behind your Fig. 10.2-3 and Fig. 10.26(a).
            </p>
          </div>
        </div>

        <div class="callout" style="margin-top:12px">
          <div class="t" style="color:var(--good)">FINAL ANSWERS (plain text)</div>
          <div class="eqblock" id="finalAnswers">
<pre>NA ≈ 0.0537308

Core radius for V=10:
a ≈ 45.9 μm

Guided l=0 modes at V=10 (LP0m) and propagation constants:
LP01: β ≈ 5.853303×10^6 1/m   (neff ≈ 1.4439523)
LP02: β ≈ 5.852485×10^6 1/m   (neff ≈ 1.4437504)
LP03: β ≈ 5.851053×10^6 1/m   (neff ≈ 1.4433973)

Core radius for V=4:
a ≈ 18.36 μm

LP01 at V=4:
neff ≈ 1.4437728
β ≈ 5.852575×10^6 1/m
vp ≈ 2.07645×10^8 m/s
vg ≈ 2.07594×10^8 m/s   (material dispersion ignored)</pre>
          </div>
          <div class="copyrow">
            <button class="btn good" onclick="copyFrom('finalAnswers')">Copy final answers</button>
            <span class="faint">Tip: paste into a report as-is.</span>
          </div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="pad" id="part4">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpreting the formulas</h3>
        <ul>
          <li><b>V = k<sub>0</sub>aNA</b> shows three levers: larger core radius a, shorter wavelength, or larger NA all increase mode capacity.</li>
          <li><b>b = 1 − (u/V)²</b> says confinement is controlled by how “far” u sits below V: small u/V ⇒ b close to 1 ⇒ strong confinement.</li>
          <li><b>n<sub>g</sub> = d&beta;/dk<sub>0</sub></b> adds the key dispersion term proportional to <b>db/dV</b>, i.e. how confinement changes with frequency.</li>
        </ul>

        <h3>Parameter effects (connect to interactive plots)</h3>
        <ul>
          <li>Increasing <b>V</b> (via a or decreasing &lambda;) makes <b>b</b> larger for a given mode → <b>n<sub>eff</sub></b> increases toward n<sub>1</sub> → &beta; increases.</li>
          <li>Higher-order LP<sub>0m</sub> modes (larger m) have larger u, so at the same V they have smaller b → weaker confinement and smaller n<sub>eff</sub>.</li>
          <li>Waveguide dispersion magnitude is related to the slope <b>db/dV</b>. It is often largest when confinement is changing rapidly (moderate V region).</li>
        </ul>

        <h3>Alternative derivation idea (brief)</h3>
        <p class="muted">
          Instead of using b(V), you can compute v<sub>g</sub> from the dispersion relation &beta;(ω) directly:
          solve the eigenvalue equation at multiple ω (thus multiple V) and approximate d&beta;/dω numerically. This is conceptually the same as using db/dV, just written in a different variable.
        </p>

        <h3>Concept checks (with answers)</h3>
        <ul>
          <li><b>Q:</b> If a mode is near cutoff, what is n<sub>eff</sub>? <b>A:</b> n<sub>eff</sub> → n<sub>2</sub> (b → 0).</li>
          <li><b>Q:</b> Why can v<sub>g</sub> differ from c/n<sub>eff</sub> even if indices are constant? <b>A:</b> because the modal field distribution changes with frequency (waveguide dispersion).</li>
          <li><b>Q:</b> For fixed V, which has larger n<sub>eff</sub>: LP<sub>01</sub> or LP<sub>03</sub>? <b>A:</b> LP<sub>01</sub>, because its u is smaller ⇒ b is larger.</li>
          <li><b>Q:</b> What happens to number of modes if &lambda; increases (same a, n’s)? <b>A:</b> V decreases, so fewer modes are guided.</li>
        </ul>
      </div>

      <div class="divider"></div>

      <div class="pad" id="part5">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

        <div class="grid2">
          <div>
            <p>
              <b>Diagram canvas:</b> a cross-section of a step-index fiber. The inner circle is the core (radius <b>a</b>, index n<sub>1</sub>),
              and outside is cladding (index n<sub>2</sub>). The slider changes <b>V</b>, which corresponds (for fixed n’s and &lambda;<sub>0</sub>)
              to changing the <b>core radius a</b>. The diagram updates the drawn core size label accordingly.
            </p>
            <p>
              <b>Main plot:</b> <b>b(V)</b> curves for LP<sub>01</sub>, LP<sub>02</sub>, LP<sub>03</sub>. A mode exists only above its cutoff (curve appears).
              Higher modes start at higher V and lie lower (smaller b).
            </p>
            <p>
              <b>Secondary plot:</b> derived quantities for the selected mode (default LP<sub>01</sub>): <b>n<sub>eff</sub>(V)</b> and <b>n<sub>g</sub>(V)</b>.
              The vertical marker shows the current slider V. Expect n<sub>g</sub> slightly above n<sub>eff</sub> when db/dV &gt; 0.
            </p>
          </div>

          <div class="callout">
            <div class="t" style="color:var(--accent)">Interactive controls</div>
            <ul>
              <li><b>V slider:</b> changes core radius a and updates <i>all</i> canvases.</li>
              <li><b>Mode selector:</b> chooses which LP<sub>0m</sub> curve is emphasized and which mode’s n<sub>eff</sub>, n<sub>g</sub>, v<sub>p</sub>, v<sub>g</sub> are reported.</li>
            </ul>
            <p class="muted" style="margin:8px 0 0">
              Use the slider to compare the problem’s two cases quickly: set V=10 (multiple l=0 modes) and V=4 (only LP<sub>01</sub> robustly guided).
            </p>
          </div>
        </div>

        <div class="controls">
          <div>
            <label for="vSlider">Interactive V (dimensionless): <span id="vRead" style="color:var(--ink); font-weight:800">10.00</span></label>
            <input id="vSlider" type="range" min="1.8" max="12" step="0.01" value="10" />
            <div class="note">For fixed n<sub>1</sub>, n<sub>2</sub>, &lambda;<sub>0</sub>, changing V corresponds to changing core radius a.</div>
          </div>
          <div>
            <label for="modeSel">Mode (l = 0):</label>
            <select id="modeSel">
              <option value="0">LP01</option>
              <option value="1">LP02</option>
              <option value="2">LP03</option>
            </select>
            <div class="kpi">
              <div class="box">
                <div class="label">Core radius a (μm)</div>
                <div class="val" id="kpiA">—</div>
              </div>
              <div class="box">
                <div class="label">Selected β (×10⁶ 1/m)</div>
                <div class="val" id="kpiB">—</div>
              </div>
              <div class="box">
                <div class="label">v<sub>p</sub> (×10⁸ m/s)</div>
                <div class="val" id="kpiVp">—</div>
              </div>
              <div class="box">
                <div class="label">v<sub>g</sub> (×10⁸ m/s)</div>
                <div class="val" id="kpiVg">—</div>
              </div>
            </div>
          </div>
        </div>

        <div class="canvasWrap">
          <canvas id="cDiagram" aria-label="Fiber diagram"></canvas>
          <div class="cap"><b>Diagram:</b> step-index fiber cross-section (core radius a, indices n<sub>1</sub>, n<sub>2</sub>).</div>
        </div>

        <div class="canvasWrap">
          <canvas id="cMain" aria-label="b vs V plot"></canvas>
          <div class="cap"><b>Main plot:</b> normalized propagation constant <b>b</b> versus V for LP<sub>0m</sub> modes (l=0).</div>
        </div>

        <div class="canvasWrap">
          <canvas id="cSecondary" aria-label="neff and ng vs V plot"></canvas>
          <div class="cap"><b>Secondary plot:</b> effective index n<sub>eff</sub>(V) and group index n<sub>g</sub>(V) for selected mode.</div>
        </div>

      </div>
    </article>

    <aside class="card toc" aria-label="Table of contents">
      <div class="pad">
        <h3>Table of Contents</h3>
        <nav id="tocNav"></nav>
        <div class="divider"></div>
        <p class="muted" style="margin:0">
          Tip: jump between sections while adjusting V to see how the solution logic maps to the plots.
        </p>
      </div>
    </aside>
  </main>

  <footer class="card">
    <div class="pad">
      <b>Notes on fidelity:</b> The original textbook instruction references estimating from plots (Fig. 10.2-3 and Fig. 10.26(a)).
      Here, the same intersections/curves are reproduced numerically using the same characteristic equation, which effectively gives the “best possible graph reading.”
      All results assume weak guidance and no material dispersion.
    </div>
  </footer>

<script>
/* -------------------------
   Utilities: Copy buttons
--------------------------*/
function copyFrom(id){
  const el = document.getElementById(id);
  if(!el) return;
  const txt = el.innerText.replace(/\n{3,}/g, "\n\n").trim();
  navigator.clipboard.writeText(txt).then(()=>{
    toast("Copied!");
  }).catch(()=>{
    toast("Copy failed (browser permissions).");
  });
}
let toastTimer=null;
function toast(msg){
  let t=document.getElementById("toast");
  if(!t){
    t=document.createElement("div");
    t.id="toast";
    t.style.position="fixed";
    t.style.left="50%";
    t.style.bottom="20px";
    t.style.transform="translateX(-50%)";
    t.style.padding="10px 12px";
    t.style.borderRadius="14px";
    t.style.background="rgba(0,0,0,.72)";
    t.style.border="1px solid rgba(255,255,255,.18)";
    t.style.color="white";
    t.style.fontWeight="700";
    t.style.zIndex="9999";
    t.style.boxShadow="0 16px 40px rgba(0,0,0,.45)";
    t.style.backdropFilter="blur(6px)";
    document.body.appendChild(t);
  }
  t.textContent=msg;
  t.style.opacity="1";
  clearTimeout(toastTimer);
  toastTimer=setTimeout(()=>{ t.style.opacity="0"; }, 1200);
}

/* -------------------------
   Build sticky TOC
--------------------------*/
(function buildTOC(){
  const toc = document.getElementById("tocNav");
  const targets = [
    {id:"quick-summary", label:"Quick Summary"},
    {id:"part0", label:"PART 0 — Concept Primer"},
    {id:"part1", label:"PART 1 — Problem Analysis"},
    {id:"part2", label:"PART 2 — Strategy & Tips"},
    {id:"part3", label:"PART 3 — Full Solution"},
    {id:"part4", label:"PART 4 — Deeper Understanding"},
    {id:"part5", label:"PART 5 — Visualization Guide"},
  ];
  targets.forEach(t=>{
    const a=document.createElement("a");
    a.href="#"+t.id;
    a.textContent=t.label;
    a.addEventListener("click",(e)=>{
      e.preventDefault();
      document.getElementById(t.id).scrollIntoView({behavior:"smooth", block:"start"});
      history.replaceState(null,"","#"+t.id);
    });
    toc.appendChild(a);
  });
})();

/* -------------------------
   Physics constants & helpers
--------------------------*/
const n1 = 1.444;
const n2 = 1.443;
const lam0 = 1.55e-6; // m
const c0 = 299792458;
const k0 = 2*Math.PI/lam0;
const dN2 = n1*n1 - n2*n2;
const NA = Math.sqrt(dN2);

/* -------------------------
   Bessel approximations (Numerical Recipes / Cephes-style)
   J0, J1, I0, I1, K0, K1
--------------------------*/
function j0(x){
  const ax = Math.abs(x);
  if(ax < 8.0){
    const y = x*x;
    const ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7 +
                 y*(-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));
    const ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718 +
                 y*(59272.64853 + y*(267.8532712 + y*1.0))));
    return ans1/ans2;
  }else{
    const z = 8.0/ax;
    const y = z*z;
    const xx = ax - 0.785398164;
    const ans1 = 1.0 + y*(-0.001098628627 + y*(0.00002734510407 +
                 y*(-0.000002073370639 + y*0.0000002093887211)));
    const ans2 = -0.01562499995 + y*(0.0001430488765 + y*(-0.000006911147651 +
                 y*(0.0000007621095161 - y*0.0000000934945152)));
    return Math.sqrt(0.636619772/ax)*(Math.cos(xx)*ans1 - z*Math.sin(xx)*ans2);
  }
}
function j1(x){
  const ax = Math.abs(x);
  if(ax < 8.0){
    const y = x*x;
    const ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1 +
                  y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));
    const ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74 +
                  y*(99447.43394 + y*(376.9991397 + y*1.0))));
    return ans1/ans2;
  }else{
    const z = 8.0/ax;
    const y = z*z;
    const xx = ax - 2.356194491;
    const ans1 = 1.0 + y*(0.00183105 + y*(-0.00003516396496 +
                  y*(0.000002457520174 + y*(-0.000000240337019))));
    const ans2 = 0.04687499995 + y*(-0.0002002690873 + y*(0.000008449199096 +
                  y*(-0.00000088228987 + y*0.000000105787412)));
    let out = Math.sqrt(0.636619772/ax)*(Math.cos(xx)*ans1 - z*Math.sin(xx)*ans2);
    return x < 0 ? -out : out;
  }
}
function i0(x){
  const ax = Math.abs(x);
  if(ax < 3.75){
    const y = (x/3.75)*(x/3.75);
    return 1.0 + y*(3.5156229 + y*(3.0899424 + y*(1.2067492 +
           y*(0.2659732 + y*(0.0360768 + y*0.0045813)))));
  }else{
    const y = 3.75/ax;
    const ans = 0.39894228 + y*(0.01328592 + y*(0.00225319 +
               y*(-0.00157565 + y*(0.00916281 + y*(-0.02057706 +
               y*(0.02635537 + y*(-0.01647633 + y*0.00392377)))))));
    return (Math.exp(ax)/Math.sqrt(ax))*ans;
  }
}
function i1(x){
  const ax = Math.abs(x);
  let ans;
  if(ax < 3.75){
    const y = (x/3.75)*(x/3.75);
    ans = ax*(0.5 + y*(0.87890594 + y*(0.51498869 + y*(0.15084934 +
          y*(0.02658733 + y*(0.00301532 + y*0.00032411))))));
  }else{
    const y = 3.75/ax;
    ans = 0.39894228 + y*(-0.03988024 + y*(-0.00362018 +
          y*(0.00163801 + y*(-0.01031555 + y*(0.02282967 +
          y*(-0.02895312 + y*(0.01787654 - y*0.00420059)))))));
    ans = (Math.exp(ax)/Math.sqrt(ax))*ans;
  }
  return x < 0 ? -ans : ans;
}
function k0(x){
  if(x <= 0) return Infinity;
  if(x <= 2.0){
    const y = (x*x)/4.0;
    return -Math.log(x/2.0)*i0(x) + (-0.57721566 + y*(0.42278420 + y*(0.23069756 +
           y*(0.03488590 + y*(0.00262698 + y*(0.00010750 + y*0.00000740))))));
  }else{
    const y = 2.0/x;
    return (Math.exp(-x)/Math.sqrt(x))*(1.25331414 + y*(-0.07832358 + y*(0.02189568 +
           y*(-0.01062446 + y*(0.00587872 + y*(-0.00251540 + y*0.00053208))))));
  }
}
function k1(x){
  if(x <= 0) return Infinity;
  if(x <= 2.0){
    const y = (x*x)/4.0;
    return Math.log(x/2.0)*i1(x) + (1.0/x)*(1.0 + y*(0.15443144 + y*(-0.67278579 +
           y*(-0.18156897 + y*(-0.01919402 + y*(-0.00110404 + y*(-0.00004686)))))));
  }else{
    const y = 2.0/x;
    return (Math.exp(-x)/Math.sqrt(x))*(1.25331414 + y*(0.23498619 + y*(-0.03655620 +
           y*(0.01504268 + y*(-0.00780353 + y*(0.00325614 + y*(-0.00068245)))))));
  }
}

/* -------------------------
   Mode solver for l=0:
   F(u) = u J1(u)/J0(u) - w K1(w)/K0(w) = 0
   Find roots u in (0, V) for LP0m
--------------------------*/
function F_u(u, V){
  const w = Math.sqrt(Math.max(0, V*V - u*u));
  const lhs = u * j1(u) / j0(u);
  const rhs = w * k1(w) / k0(w);
  return lhs - rhs;
}

// zeros of J0 are poles for LHS; use intervals between them
const zerosJ0 = [2.4048255577, 5.5200781103, 8.6537279129, 11.7915344391, 14.9309177086];

function findRoots_l0(V){
  // build intervals between poles (zeros of J0), clipped to (0,V)
  const eps = 1e-4;
  const poles = zerosJ0.filter(z => z < V - eps);
  const bounds = [eps, ...poles.map(z=>z-eps), ...poles.map(z=>z+eps), V-eps].sort((a,b)=>a-b);

  // intervals are [bounds[i], bounds[i+1]] where there is no pole inside
  const intervals = [];
  for(let i=0;i<bounds.length-1;i++){
    const a = bounds[i], b = bounds[i+1];
    if(b-a > 5e-3){
      // reject intervals that cross a pole by checking if midpoint is near a pole (rough)
      intervals.push([a,b]);
    }
  }

  const roots = [];
  for(const [a0,b0] of intervals){
    if(b0 <= 0 || a0 >= V) continue;
    const a = Math.max(a0, eps);
    const b = Math.min(b0, V-eps);
    const xs = [a, a + 0.45*(b-a), a + 0.75*(b-a), b];
    const fs = [];
    let ok = true;
    for(const x of xs){
      const j0x = j0(x);
      const w = Math.sqrt(Math.max(0, V*V - x*x));
      const k0w = k0(w);
      if(!isFinite(j0x) || !isFinite(k0w) || Math.abs(j0x) < 1e-8 || k0w===0){
        ok=false; break;
      }
      const fx = F_u(x,V);
      if(!isFinite(fx)) { ok=false; break; }
      fs.push(fx);
    }
    if(!ok) continue;

    // look for sign change in adjacent segments
    for(let i=0;i<xs.length-1;i++){
      const f1 = fs[i], f2 = fs[i+1];
      if(f1===0){ roots.push(xs[i]); break; }
      if(f1*f2 < 0){
        // bisection
        let lo = xs[i], hi = xs[i+1];
        let flo = f1, fhi = f2;
        for(let it=0; it<60; it++){
          const mid = 0.5*(lo+hi);
          const fmid = F_u(mid,V);
          if(!isFinite(fmid)) break;
          if(flo*fmid <= 0){ hi=mid; fhi=fmid; }
          else { lo=mid; flo=fmid; }
        }
        const r = 0.5*(lo+hi);
        if(r>0 && r<V && roots.every(rr=>Math.abs(rr-r)>1e-2)){
          roots.push(r);
        }
        break;
      }
    }
  }
  roots.sort((x,y)=>x-y);
  return roots;
}

function modeParamsFromU(u, V){
  const b = 1 - (u/V)*(u/V);
  const neff = Math.sqrt(n2*n2 + b*dN2);
  const beta = k0 * neff;
  return {b, neff, beta};
}

function bForModeAtV(modeIndex, V){
  const roots = findRoots_l0(V);
  if(modeIndex===0){
    if(roots.length<1) return null;
    return 1 - (roots[0]/V)*(roots[0]/V);
  }else{
    if(roots.length < (modeIndex+1)) return null;
    return 1 - (roots[modeIndex]/V)*(roots[modeIndex]/V);
  }
}

function dbdV_numeric(modeIndex, V){
  const h = 0.06; // moderate for stability (plots)
  const V1 = Math.max(1.85, V-h);
  const V2 = Math.min(12.0, V+h);
  const b1 = bForModeAtV(modeIndex, V1);
  const b2 = bForModeAtV(modeIndex, V2);
  if(b1==null || b2==null) return null;
  return (b2 - b1)/(V2 - V1);
}

function groupIndex(modeIndex, V){
  const roots = findRoots_l0(V);
  if(roots.length < (modeIndex+1)) return null;
  const u = roots[modeIndex];
  const mp = modeParamsFromU(u, V);
  const slope = dbdV_numeric(modeIndex, V);
  if(slope==null) return null;
  const ng = mp.neff + (V * dN2 / (2*mp.neff)) * slope;
  return ng;
}

/* -------------------------
   Canvas drawing helpers
--------------------------*/
function setupCanvas(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(320, Math.floor(rect.width));
  const h = Math.max(240, Math.floor(rect.height));
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  const ctx = canvas.getContext("2d");
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return {ctx, w, h, dpr};
}

function drawAxes(ctx, x0,y0, w,h, xMin,xMax,yMin,yMax, xLab,yLab, title){
  // background
  ctx.save();
  ctx.clearRect(0,0,w,h);
  // title
  ctx.fillStyle = "rgba(234,240,255,.92)";
  ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(title, x0, y0-12);

  // plot area
  ctx.fillStyle = "rgba(0,0,0,.12)";
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(x0,y0,w,h,12);
  ctx.fill();
  ctx.stroke();

  // gridlines & ticks
  const nx=6, ny=6;
  ctx.strokeStyle = "rgba(255,255,255,.08)";
  ctx.lineWidth=1;
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  ctx.fillStyle = "rgba(183,195,230,.95)";

  for(let i=0;i<=nx;i++){
    const t=i/nx;
    const x=x0+t*w;
    ctx.beginPath();
    ctx.moveTo(x,y0);
    ctx.lineTo(x,y0+h);
    ctx.stroke();
    const val = xMin + t*(xMax-xMin);
    const s = (Math.round(val*100)/100).toFixed( (xMax-xMin<2)?2: (xMax-xMin<10?1:0) );
    ctx.fillText(s, x-10, y0+h+16);
  }
  for(let j=0;j<=ny;j++){
    const t=j/ny;
    const y=y0+(1-t)*h;
    ctx.beginPath();
    ctx.moveTo(x0,y);
    ctx.lineTo(x0+w,y);
    ctx.stroke();
    const val = yMin + t*(yMax-yMin);
    const s = (Math.round(val*1000)/1000).toFixed( (yMax-yMin<1)?2:1 );
    ctx.fillText(s, x0-42, y+4);
  }

  // axis labels
  ctx.fillStyle="rgba(234,240,255,.92)";
  ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(xLab, x0+w-70, y0+h+34);

  ctx.save();
  ctx.translate(x0-56, y0+18);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLab, 0,0);
  ctx.restore();
  ctx.restore();
}

function mapX(x, x0,w, xMin,xMax){ return x0 + (x-xMin)/(xMax-xMin)*w; }
function mapY(y, y0,h, yMin,yMax){ return y0 + (1-(y-yMin)/(yMax-yMin))*h; }

CanvasRenderingContext2D.prototype.roundRect = CanvasRenderingContext2D.prototype.roundRect || function(x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  this.beginPath();
  this.moveTo(x+rr,y);
  this.arcTo(x+w,y,x+w,y+h,rr);
  this.arcTo(x+w,y+h,x,y+h,rr);
  this.arcTo(x,y+h,x,y,rr);
  this.arcTo(x,y,x+w,y,rr);
  this.closePath();
  return this;
};

/* -------------------------
   Draw: Diagram
--------------------------*/
function drawDiagram(V){
  const canvas = document.getElementById("cDiagram");
  const {ctx,w,h} = setupCanvas(canvas);

  const pad=18;
  const cx = w*0.35, cy = h*0.55;
  const R = Math.min(w,h)*0.28;

  // a derived from V
  const a = V*lam0/(2*Math.PI*NA); // meters

  // Background
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = "rgba(0,0,0,.12)";
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth=1;
  ctx.roundRect(pad,pad,w-2*pad,h-2*pad,14);
  ctx.fill(); ctx.stroke();

  // Outer cladding circle
  ctx.beginPath();
  ctx.arc(cx,cy,R*1.4,0,Math.PI*2);
  ctx.fillStyle = "rgba(137,167,255,.10)";
  ctx.fill();
  ctx.strokeStyle = "rgba(137,167,255,.25)";
  ctx.stroke();

  // Core circle
  ctx.beginPath();
  ctx.arc(cx,cy,R,0,Math.PI*2);
  ctx.fillStyle = "rgba(124,240,198,.12)";
  ctx.fill();
  ctx.strokeStyle = "rgba(124,240,198,.35)";
  ctx.lineWidth=2;
  ctx.stroke();

  // Radius arrow
  ctx.strokeStyle="rgba(234,240,255,.85)";
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(cx,cy);
  ctx.lineTo(cx+R,cy);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(cx+R,cy);
  ctx.lineTo(cx+R-10,cy-6);
  ctx.lineTo(cx+R-10,cy+6);
  ctx.closePath();
  ctx.fillStyle="rgba(234,240,255,.85)";
  ctx.fill();

  // Labels
  ctx.fillStyle="rgba(234,240,255,.92)";
  ctx.font="700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("Step-index fiber (cross-section)", pad+10, pad+22);

  ctx.font="650 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillStyle="rgba(183,195,230,.95)";
  ctx.fillText(`Core: n1 = ${n1.toFixed(3)}`, cx+R*1.65, cy-R*0.35);
  ctx.fillText(`Cladding: n2 = ${n2.toFixed(3)}`, cx+R*1.65, cy-R*0.10);

  ctx.fillStyle="rgba(234,240,255,.92)";
  ctx.fillText(`a = ${ (a*1e6).toFixed(2) } μm`, cx+R*0.35, cy-10);

  // Prop direction
  ctx.strokeStyle="rgba(255,255,255,.18)";
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(cx-R*0.6, cy+R*1.05);
  ctx.lineTo(cx+R*0.6, cy+R*1.05);
  ctx.stroke();
  ctx.fillStyle="rgba(255,255,255,.85)";
  ctx.beginPath();
  ctx.moveTo(cx+R*0.6, cy+R*1.05);
  ctx.lineTo(cx+R*0.6-10, cy+R*1.05-6);
  ctx.lineTo(cx+R*0.6-10, cy+R*1.05+6);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle="rgba(183,195,230,.95)";
  ctx.font="650 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("propagation z", cx-40, cy+R*1.05-10);

  // V box
  ctx.fillStyle="rgba(0,0,0,.22)";
  ctx.strokeStyle="rgba(255,255,255,.12)";
  ctx.roundRect(w*0.62, pad+42, w*0.34, 92, 14);
  ctx.fill(); ctx.stroke();

  ctx.fillStyle="rgba(234,240,255,.92)";
  ctx.font="750 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(`V = ${V.toFixed(2)}`, w*0.62+12, pad+66);

  ctx.font="600 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  ctx.fillStyle="rgba(183,195,230,.95)";
  ctx.fillText(`NA = sqrt(n1²-n2²) = ${NA.toFixed(6)}`, w*0.62+12, pad+88);
  ctx.fillText(`λ0 = ${(lam0*1e6).toFixed(2)} μm`, w*0.62+12, pad+108);
}

/* -------------------------
   Draw: Main plot b(V) for LP0m
--------------------------*/
function drawMainPlot(Vcur, modeSel){
  const canvas = document.getElementById("cMain");
  const {ctx,w,h} = setupCanvas(canvas);

  const x0=58, y0=44, pw=w-78, ph=h-92;
  const xMin=1.8, xMax=12.0, yMin=0, yMax=1.0;

  drawAxes(ctx,x0,y0,pw,ph,xMin,xMax,yMin,yMax,"V (dimensionless)","b (dimensionless)","b(V) for LP0m modes (l=0)");

  const modes = [
    {name:"LP01", idx:0},
    {name:"LP02", idx:1},
    {name:"LP03", idx:2},
  ];

  // plot each mode curve
  const N=220;
  for(const m of modes){
    // styling: highlight selected
    const isSel = (m.idx===modeSel);
    ctx.lineWidth = isSel ? 2.8 : 2.0;
    ctx.strokeStyle = isSel ? "rgba(124,240,198,.95)" : "rgba(137,167,255,.60)";
    ctx.beginPath();
    let started=false;

    for(let i=0;i<=N;i++){
      const V = xMin + (xMax-xMin)*(i/N);
      const roots = findRoots_l0(V);
      if(roots.length < (m.idx+1)){
        started=false;
        continue;
      }
      const u = roots[m.idx];
      const b = 1 - (u/V)*(u/V);
      const X = mapX(V,x0,pw,xMin,xMax);
      const Y = mapY(b,y0,ph,yMin,yMax);
      if(!started){
        ctx.moveTo(X,Y);
        started=true;
      }else ctx.lineTo(X,Y);
    }
    ctx.stroke();
  }

  // vertical marker at Vcur
  const xV = mapX(Vcur,x0,pw,xMin,xMax);
  ctx.strokeStyle="rgba(255,255,255,.22)";
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(xV,y0);
  ctx.lineTo(xV,y0+ph);
  ctx.stroke();

  // legend
  ctx.fillStyle="rgba(0,0,0,.30)";
  ctx.strokeStyle="rgba(255,255,255,.12)";
  ctx.roundRect(x0+12,y0+10,170,64,12);
  ctx.fill(); ctx.stroke();

  ctx.font="700 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillStyle="rgba(234,240,255,.92)";
  ctx.fillText("Legend", x0+22, y0+30);

  let yL=y0+48;
  for(const m of modes){
    const isSel = (m.idx===modeSel);
    ctx.strokeStyle = isSel ? "rgba(124,240,198,.95)" : "rgba(137,167,255,.60)";
    ctx.lineWidth = isSel ? 3.0 : 2.0;
    ctx.beginPath();
    ctx.moveTo(x0+22,yL);
    ctx.lineTo(x0+52,yL);
    ctx.stroke();
    ctx.fillStyle="rgba(183,195,230,.95)";
    ctx.font= (isSel? "800 12px":"600 12px") + " system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(m.name, x0+62, yL+4);
    yL+=18;
  }

  // annotate cutoffs roughly (zeros of J1 for l=0 cutoffs)
  // For LP02 cutoff ~ 3.8317, LP03 cutoff ~ 7.0156, LP04 cutoff ~ 10.1735
  const cutoffs = [
    {V:3.8317, label:"cutoff LP02"},
    {V:7.0156, label:"cutoff LP03"},
    {V:10.1735, label:"cutoff LP04"}
  ];
  ctx.font="600 11px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillStyle="rgba(183,195,230,.75)";
  cutoffs.forEach(cu=>{
    if(cu.V < xMin || cu.V > xMax) return;
    const x = mapX(cu.V,x0,pw,xMin,xMax);
    ctx.strokeStyle="rgba(255,255,255,.10)";
    ctx.setLineDash([4,4]);
    ctx.beginPath();
    ctx.moveTo(x,y0);
    ctx.lineTo(x,y0+ph);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillText(cu.label, x-26, y0+ph-10);
  });
}

/* -------------------------
   Draw: Secondary plot neff(V), ng(V) for selected mode
--------------------------*/
function drawSecondaryPlot(Vcur, modeSel){
  const canvas = document.getElementById("cSecondary");
  const {ctx,w,h} = setupCanvas(canvas);

  const x0=58, y0=44, pw=w-78, ph=h-92;
  const xMin=1.8, xMax=12.0;

  // y range around n2..n1 but tight for readability
  const yMin = 1.4428, yMax = 1.4442;

  drawAxes(ctx,x0,y0,pw,ph,xMin,xMax,yMin,yMax,"V (dimensionless)","n (dimensionless)","n_eff(V) and n_g(V) for selected LP0m");

  // curves
  const N=220;

  // neff
  ctx.strokeStyle="rgba(137,167,255,.88)";
  ctx.lineWidth=2.4;
  ctx.beginPath();
  let started=false;
  for(let i=0;i<=N;i++){
    const V = xMin + (xMax-xMin)*(i/N);
    const roots = findRoots_l0(V);
    if(roots.length < (modeSel+1)){ started=false; continue; }
    const u = roots[modeSel];
    const mp = modeParamsFromU(u,V);
    const X = mapX(V,x0,pw,xMin,xMax);
    const Y = mapY(mp.neff,y0,ph,yMin,yMax);
    if(!started){ ctx.moveTo(X,Y); started=true; }
    else ctx.lineTo(X,Y);
  }
  ctx.stroke();

  // ng
  ctx.strokeStyle="rgba(124,240,198,.90)";
  ctx.lineWidth=2.4;
  ctx.beginPath();
  started=false;
  for(let i=0;i<=N;i++){
    const V = xMin + (xMax-xMin)*(i/N);
    const ng = groupIndex(modeSel,V);
    if(ng==null){ started=false; continue; }
    const X = mapX(V,x0,pw,xMin,xMax);
    const Y = mapY(ng,y0,ph,yMin,yMax);
    if(!started){ ctx.moveTo(X,Y); started=true; }
    else ctx.lineTo(X,Y);
  }
  ctx.stroke();

  // vertical marker at Vcur
  const xV = mapX(Vcur,x0,pw,xMin,xMax);
  ctx.strokeStyle="rgba(255,255,255,.22)";
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(xV,y0);
  ctx.lineTo(xV,y0+ph);
  ctx.stroke();

  // marker points at current V
  const rootsNow = findRoots_l0(Vcur);
  if(rootsNow.length >= modeSel+1){
    const u = rootsNow[modeSel];
    const mp = modeParamsFromU(u,Vcur);
    const ng = groupIndex(modeSel,Vcur);

    const X = xV;

    // neff marker
    const Yn = mapY(mp.neff,y0,ph,yMin,yMax);
    ctx.fillStyle="rgba(137,167,255,.95)";
    ctx.beginPath(); ctx.arc(X,Yn,4.5,0,Math.PI*2); ctx.fill();

    // ng marker
    if(ng!=null){
      const Yg = mapY(ng,y0,ph,yMin,yMax);
      ctx.fillStyle="rgba(124,240,198,.95)";
      ctx.beginPath(); ctx.arc(X,Yg,4.5,0,Math.PI*2); ctx.fill();
    }

    // legend
    ctx.fillStyle="rgba(0,0,0,.30)";
    ctx.strokeStyle="rgba(255,255,255,.12)";
    ctx.roundRect(x0+12,y0+10,210,64,12);
    ctx.fill(); ctx.stroke();

    ctx.font="700 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle="rgba(234,240,255,.92)";
    ctx.fillText(`Selected: ${["LP01","LP02","LP03"][modeSel]}`, x0+22, y0+30);

    ctx.strokeStyle="rgba(137,167,255,.88)";
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(x0+22,y0+44); ctx.lineTo(x0+52,y0+44); ctx.stroke();
    ctx.fillStyle="rgba(183,195,230,.95)";
    ctx.font="600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("n_eff(V)", x0+62, y0+48);

    ctx.strokeStyle="rgba(124,240,198,.90)";
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(x0+22,y0+60); ctx.lineTo(x0+52,y0+60); ctx.stroke();
    ctx.fillText("n_g(V)", x0+62, y0+64);
  }
}

/* -------------------------
   Update KPIs and all plots
--------------------------*/
function updateAll(){
  const V = parseFloat(document.getElementById("vSlider").value);
  const modeSel = parseInt(document.getElementById("modeSel").value,10);
  document.getElementById("vRead").textContent = V.toFixed(2);

  // compute a
  const a = V*lam0/(2*Math.PI*NA); // m
  document.getElementById("kpiA").textContent = (a*1e6).toFixed(2);

  // mode properties
  const roots = findRoots_l0(V);
  let betaTxt="—", vpTxt="—", vgTxt="—";
  if(roots.length >= modeSel+1){
    const u = roots[modeSel];
    const mp = modeParamsFromU(u,V);
    const neff = mp.neff;
    const beta = mp.beta;

    const vp = c0/neff;
    const ng = groupIndex(modeSel,V);
    const vg = (ng!=null) ? c0/ng : null;

    betaTxt = (beta/1e6).toFixed(6);
    vpTxt = (vp/1e8).toFixed(5);
    vgTxt = (vg!=null) ? (vg/1e8).toFixed(5) : "—";
  }
  document.getElementById("kpiB").textContent = betaTxt;
  document.getElementById("kpiVp").textContent = vpTxt;
  document.getElementById("kpiVg").textContent = vgTxt;

  // redraw canvases
  drawDiagram(V);
  drawMainPlot(V, modeSel);
  drawSecondaryPlot(V, modeSel);
}

/* -------------------------
   Responsive redraw
--------------------------*/
let resizeTimer=null;
window.addEventListener("resize", ()=>{
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(updateAll, 80);
});

document.getElementById("vSlider").addEventListener("input", updateAll);
document.getElementById("modeSel").addEventListener("change", updateAll);

// initial paint
updateAll();
</script>
</body>
</html>
