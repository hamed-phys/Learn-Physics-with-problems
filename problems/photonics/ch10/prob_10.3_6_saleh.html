<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pulse Propagation in a Graded-Index Fiber: How Parameters Control Temporal Broadening</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1731;
      --panel2:#0c1328;
      --text:#e9ecff;
      --muted:#b9c0ff;
      --faint:#7f88c9;
      --accent:#7cf0d6;
      --accent2:#8aa2ff;
      --warn:#ffcc66;
      --bad:#ff6b8a;
      --good:#7CFF9A;
      --line:rgba(255,255,255,.10);
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(124,240,214,.10), transparent 60%),
        radial-gradient(900px 600px at 80% 0%, rgba(138,162,255,.12), transparent 55%),
        radial-gradient(1000px 700px at 60% 95%, rgba(255,204,102,.08), transparent 60%),
        var(--bg);
      color:var(--text);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:28px 18px 10px;
      max-width:1180px;
      margin:0 auto;
    }
    .title{
      display:flex; gap:14px; align-items:flex-start; justify-content:space-between;
      flex-wrap:wrap;
    }
    h1{
      font-size:clamp(1.35rem, 2.4vw, 2.1rem);
      margin:0;
      letter-spacing:.2px;
    }
    .subtitle{
      margin:8px 0 0;
      color:var(--muted);
      max-width:78ch;
    }
    .grid{
      max-width:1180px;
      margin:0 auto;
      padding:10px 18px 40px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }
    nav{
      position:sticky;
      top:14px;
      background:linear-gradient(180deg, rgba(15,23,49,.92), rgba(12,19,40,.88));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:14px 14px 10px;
      backdrop-filter: blur(10px);
    }
    nav .toc-title{
      font-weight:700;
      font-size:.95rem;
      margin:2px 0 10px;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .pill{
      font-family:var(--mono);
      font-size:.75rem;
      color:var(--bg);
      background:var(--accent);
      padding:2px 8px;
      border-radius:999px;
      letter-spacing:.3px;
    }
    nav ol{
      margin:0;
      padding-left:18px;
      color:var(--muted);
    }
    nav li{margin:7px 0}
    nav a{color:var(--muted)}
    nav a:hover{color:var(--accent)}
    main{
      display:flex;
      flex-direction:column;
      gap:18px;
      min-width:0;
    }
    section, article{
      background:linear-gradient(180deg, rgba(15,23,49,.86), rgba(12,19,40,.82));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:18px 18px 16px;
      overflow:hidden;
      backdrop-filter: blur(10px);
      transform: translateY(0);
      transition: transform .25s ease;
    }
    section:hover, article:hover{transform: translateY(-2px)}
    h2{
      margin:0 0 10px;
      font-size:1.2rem;
      letter-spacing:.2px;
    }
    h3{
      margin:16px 0 8px;
      font-size:1.02rem;
      color:var(--accent2);
    }
    .muted{color:var(--muted)}
    .kicker{
      color:var(--faint);
      font-family:var(--mono);
      font-size:.86rem;
      letter-spacing:.3px;
      margin-bottom:10px;
    }
    ul{margin:10px 0 0; padding-left:20px}
    li{margin:6px 0}
    .cols{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .cols{grid-template-columns:1fr}
    }
    .callouts{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:12px;
      margin-top:10px;
    }
    .box{
      grid-column: span 6;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:12px 12px 10px;
    }
    .box strong{color:var(--text)}
    .box .tag{
      display:inline-block;
      font-family:var(--mono);
      font-size:.78rem;
      padding:2px 8px;
      border-radius:999px;
      margin-bottom:8px;
      border:1px solid rgba(255,255,255,.14);
      color:var(--muted);
      background:rgba(0,0,0,.12);
    }
    .box.assumptions .tag{border-color: rgba(124,240,214,.40); color: var(--accent)}
    .box.keyeq .tag{border-color: rgba(138,162,255,.45); color: var(--accent2)}
    .box.pitfalls .tag{border-color: rgba(255,204,102,.55); color: var(--warn)}
    .box.final .tag{border-color: rgba(124,255,154,.55); color: var(--good)}
    .box.final{grid-column: span 12}
    @media (max-width: 720px){
      .box{grid-column: span 12}
    }

    .eq{
      margin:10px 0 0;
      padding:10px 10px 8px;
      border-radius:12px;
      border:1px dashed rgba(255,255,255,.18);
      background: rgba(0,0,0,.18);
      font-family:var(--mono);
      color:#eaf0ff;
      white-space:pre-wrap;
      overflow-x:auto;
      position:relative;
    }
    .copyRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
      align-items:center;
    }
    button.copy{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:8px 10px;
      border-radius:12px;
      cursor:pointer;
      font-weight:650;
      letter-spacing:.2px;
      transition: transform .12s ease, background .2s ease, border-color .2s ease;
    }
    button.copy:hover{
      background:rgba(124,240,214,.10);
      border-color:rgba(124,240,214,.35);
      transform: translateY(-1px);
    }
    button.copy:active{transform: translateY(0)}
    .smallNote{
      font-size:.92rem;
      color:var(--muted);
      margin:8px 0 0;
    }

    .vizWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
      margin-top:8px;
    }
    .vizRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .vizRow{grid-template-columns:1fr}
    }
    figure{
      margin:0;
      padding:12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.16);
      overflow:hidden;
    }
    figcaption{
      margin-top:8px;
      color:var(--muted);
      font-size:.92rem;
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius:12px;
      background: rgba(10,14,30,.65);
    }
    .controls{
      display:grid;
      grid-template-columns: 1.2fr 1fr 1fr;
      gap:12px;
      margin-top:8px;
    }
    @media (max-width: 980px){
      .controls{grid-template-columns:1fr}
    }
    .control{
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.05);
      border-radius:14px;
      padding:12px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-weight:700;
      font-size:.92rem;
      margin-bottom:8px;
      color:var(--text);
    }
    .control .val{
      font-family:var(--mono);
      color:var(--accent);
      font-weight:800;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .foot{
      max-width:1180px;
      margin:0 auto;
      padding:0 18px 28px;
      color:var(--muted);
      font-size:.92rem;
    }
    .hr{
      height:1px;
      background:var(--line);
      margin:10px 0 0;
    }

    /* Print friendly */
    @media print{
      body{background:#fff; color:#000}
      nav{display:none}
      section,article{box-shadow:none; background:#fff; border:1px solid #ddd}
      canvas{background:#fff; border:1px solid #ddd}
      a{color:#000; text-decoration:underline}
      .grid{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
<header>
  <div class="title">
    <div>
      <h1>Pulse Propagation in a Graded-Index Fiber (Power-Law Profile): How Each Parameter Changes the Received Pulse Width</h1>
      <p class="subtitle">
        We connect the physics of <b>modal dispersion</b> (many ray paths / modes) and <b>material (chromatic) dispersion</b>
        (wavelength-dependent refractive index) to a compact broadening model, then use interactive plots to see how
        <span class="muted">L, τ<sub>0</sub>, p, |D<sub>λ</sub>|, σ<sub>λ</sub>, λ<sub>0</sub></span> affect the output pulse duration.
      </p>
    </div>
    <div class="pill">self-contained • vanilla JS • interactive</div>
  </div>
</header>

<div class="grid">
  <nav aria-label="Table of contents">
    <div class="toc-title">Table of Contents <span class="pill">TOC</span></div>
    <ol>
      <li><a href="#quick" data-scroll>Quick Summary</a></li>
      <li><a href="#part0" data-scroll>PART 0 — Concept Primer</a></li>
      <li><a href="#part1" data-scroll>PART 1 — Problem Analysis</a></li>
      <li><a href="#part2" data-scroll>PART 2 — Strategy &amp; Tips</a></li>
      <li><a href="#part3" data-scroll>PART 3 — Full Solution</a></li>
      <li><a href="#part4" data-scroll>PART 4 — Deeper Understanding</a></li>
      <li><a href="#part5" data-scroll>PART 5 — Visualization Guide</a></li>
    </ol>
    <div class="hr"></div>
    <p class="smallNote">
      Interactive controls live under the plots. Slide <b>p</b> and <b>L</b> to update <i>all</i> canvases.
    </p>
  </nav>

  <main>
    <!-- Quick Summary -->
    <section id="quick">
      <div class="kicker">Quick Summary</div>
      <h2>What this problem is about &amp; what you’ll conclude</h2>
      <ul>
        <li><b>Goal:</b> Discuss how the <b>received temporal pulse width</b> grows when you increase fiber/laser/profile parameters.</li>
        <li><b>Key idea:</b> Output broadening comes from (i) <b>intermodal (modal) dispersion</b> in multimode fibers and (ii) <b>material (chromatic) dispersion</b> from wavelength-dependent <b>n<sub>1</sub>(λ)</b>.</li>
        <li><b>Power-law graded index:</b> Profile exponent <b>p</b> controls how well the fiber equalizes modal transit times; <b>p = 2</b> (parabolic) minimizes modal dispersion.</li>
        <li><b>Governing broadening model (typical):</b> treat pulse as Gaussian so widths add in quadrature:
          <span class="muted">τ<sub>out</sub> ≈ √(τ<sub>0</sub><sup>2</sup> + Δτ<sub>modal</sub><sup>2</sup> + Δτ<sub>mat</sub><sup>2</sup>)</span>.
        </li>
        <li><b>Modal term scaling:</b> Δτ<sub>modal</sub> ∝ L · (n<sub>1</sub>Δ/c) · F(p) with <span class="muted">F(2)=0</span> and <span class="muted">F(p→∞)→1</span>.</li>
        <li><b>Material term scaling:</b> Δτ<sub>mat</sub> ∝ L · |D<sub>λ</sub>(λ<sub>0</sub>)| · σ<sub>λ</sub>, where <span class="muted">D<sub>λ</sub> = −(λ<sub>0</sub>/c) (d²n<sub>1</sub>/dλ²)|<sub>λ0</sub></span>.</li>
        <li><b>Final result type:</b> a <b>qualitative monotonicity discussion</b> (with one important caveat: the effect of λ<sub>0</sub> depends on the dispersion curve).</li>
      </ul>

      <div class="callouts">
        <div class="box keyeq">
          <div class="tag">Key equations</div>
          <div class="eq" id="eqKey">
τ_out ≈ √( τ0^2 + (Δτ_modal)^2 + (Δτ_mat)^2 )

Δτ_modal ≈ (n1 Δ / c0) · L · F(p)   (multimode graded-index, power-law exponent p)

F(p) ≈ |(p − 2)/(p + 2)|   (simple, widely-used scaling: F(2)=0, F→1 as p→∞)

Δτ_mat ≈ |Dλ(λ0)| · L · σλ
Dλ(λ0) = −(λ0/c0) · [ d²n1/dλ² ]_(λ0)
          </div>
          <div class="copyRow">
            <button class="copy" data-copy-target="eqKey">Copy key equations (plain text)</button>
          </div>
          <p class="smallNote">
            Note: the exact prefactors can vary by definition (rms vs full-width, mode set, launch conditions).
            The <b>parameter dependences</b> asked in this problem are robust.
          </p>
        </div>

        <div class="box assumptions">
          <div class="tag">Assumptions</div>
          <ul>
            <li>Linear propagation (no Kerr nonlinearity), small-signal pulse.</li>
            <li>Multimode graded-index fiber with <b>power-law</b> profile exponent <b>p</b>.</li>
            <li>Δ is approximately wavelength-independent (as stated).</li>
            <li>Chromatic broadening comes mainly from <b>material dispersion</b> via n<sub>1</sub>(λ).</li>
            <li>Gaussian-width model: independent broadening mechanisms add in quadrature.</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- PART 0 -->
    <article id="part0">
      <div class="kicker">PART 0 — Concept Primer (Theory Before Solving)</div>
      <h2>Pulse broadening in fibers: what sets the received temporal width?</h2>

      <div class="cols">
        <div>
          <h3>Core definitions (symbols &amp; units)</h3>
          <ul>
            <li><b>τ<sub>0</sub></b> (s): initial pulse temporal width (often rms or FWHM; be consistent).</li>
            <li><b>τ<sub>out</sub></b> (s): received pulse width after propagating distance <b>L</b>.</li>
            <li><b>L</b> (m or km): fiber length.</li>
            <li><b>n<sub>1</sub>(λ)</b> (dimensionless): peak/core refractive index (wavelength-dependent here).</li>
            <li><b>Δ</b> (dimensionless): relative index difference (core vs cladding), assumed ~ constant vs λ.</li>
            <li><b>p</b> (dimensionless): power-law index-profile exponent of a graded-index (GI) fiber.</li>
            <li><b>σ<sub>λ</sub></b> (m or nm): source spectral width (rms wavelength spread).</li>
            <li><b>λ<sub>0</sub></b> (m): operating (central) wavelength.</li>
            <li><b>D<sub>λ</sub></b> (s/m²): material dispersion coefficient defined here by
              <span class="muted">D<sub>λ</sub>=−(λ<sub>0</sub>/c<sub>0</sub>) d²n<sub>1</sub>/dλ²</span>.</li>
          </ul>

          <h3>Physical meaning (what these represent)</h3>
          <ul>
            <li><b>Modal dispersion</b>: different guided modes (or ray paths) arrive at different times → pulse spreads.</li>
            <li><b>Graded index (GI)</b>: refractive index decreases with radius, causing longer geometric paths to travel in lower index (faster) regions → <b>partial time equalization</b>.</li>
            <li><b>Material dispersion</b>: different wavelengths travel with different group velocities because n(λ) is curved (second derivative matters).</li>
          </ul>
        </div>

        <div>
          <h3>Key laws / principles (and validity)</h3>
          <ul>
            <li><b>Group delay</b> per unit length:
              <span class="muted">τ<sub>g</sub> = (1/v<sub>g</sub>) = dβ/dω</span>.
              Wavelength dependence of n changes v<sub>g</sub>.
            </li>
            <li><b>Broadening from independent mechanisms</b> (Gaussian approximation):
              if impulse responses are approximately Gaussian, their variances add → widths add in quadrature.</li>
            <li><b>Ray / mode picture equivalence</b> (multimode, weak guidance):
              can reason in terms of mode group delays or meridional ray transit times.</li>
          </ul>

          <h3>Common approximations &amp; why we use them</h3>
          <ul>
            <li><b>Weak guidance</b> (Δ ≪ 1): simplifies mode structure and delay expressions.</li>
            <li><b>Power-law profile</b>:
              <span class="muted">n(r) ≈ n<sub>1</sub>[1 − Δ (r/a)<sup>p</sup>]</span> (first-order in Δ).</li>
            <li><b>Launch condition averaged</b>:
              use a single “typical” modal delay spread scaling with p (good for parameter trends).</li>
          </ul>

          <h3>Mini intuition examples</h3>
          <ul>
            <li><b>Why p=2 is special:</b> a parabolic profile makes ray period independent of amplitude → transit time nearly mode-independent → minimal intermodal spreading.</li>
            <li><b>Why σ<sub>λ</sub> matters:</b> even if the fiber were single-mode, a wide spectrum means different colors walk off in time.</li>
          </ul>

          <div class="box pitfalls" style="margin-top:12px;">
            <div class="tag">What to watch for</div>
            <ul>
              <li>Confusing <b>D<sub>λ</sub></b> (s/m² here) with telecom’s <b>D</b> (ps/(nm·km)).</li>
              <li>Assuming λ<sub>0</sub> always increases dispersion—real glasses have a <b>zero-dispersion</b> region where |D| decreases.</li>
              <li>For GI fibers, “increasing p” is not always “better”: <b>best is near p=2</b>.</li>
            </ul>
          </div>
        </div>
      </div>
    </article>

    <!-- PART 1 -->
    <article id="part1">
      <div class="kicker">PART 1 — Problem Analysis (No Solving Yet)</div>
      <h2>Restating the problem and identifying the physics</h2>

      <h3>Problem restatement (in plain words)</h3>
      <p class="muted">
        A pulse of initial temporal width τ<sub>0</sub> travels through a length L of a graded-index fiber whose
        refractive-index profile follows a power law with exponent p. The peak index n<sub>1</sub> depends on wavelength,
        quantified via the coefficient D<sub>λ</sub> = −(λ<sub>0</sub>/c<sub>0</sub>) d²n<sub>1</sub>/dλ² evaluated at λ<sub>0</sub>.
        The relative index difference Δ is (approximately) independent of wavelength. The source has spectral width σ<sub>λ</sub>.
        Discuss how increasing each parameter (L, τ<sub>0</sub>, p, |D<sub>λ</sub>|, σ<sub>λ</sub>, λ<sub>0</sub>) affects the received pulse width.
      </p>

      <h3>Given quantities</h3>
      <ul>
        <li>L (km), τ<sub>0</sub>, p, Δ (≈ constant vs λ), σ<sub>λ</sub>, λ<sub>0</sub>, and D<sub>λ</sub>(λ<sub>0</sub>) from n<sub>1</sub>(λ).</li>
      </ul>

      <h3>Unknown</h3>
      <ul>
        <li>How τ<sub>out</sub> changes (increases/decreases/has optimum) when each parameter is increased.</li>
      </ul>

      <h3>Relevant physical principles (and why they apply)</h3>
      <ul>
        <li><b>Modal dispersion in multimode fibers:</b> GI profile changes the distribution of mode group delays; p controls how equalized they are.</li>
        <li><b>Material dispersion:</b> wavelength-dependent n<sub>1</sub>(λ) makes group delay wavelength-dependent; a finite σ<sub>λ</sub> produces temporal spread.</li>
        <li><b>Superposition of broadening:</b> if the pulse remains approximately Gaussian and broadening mechanisms are independent, widths add in quadrature.</li>
      </ul>

      <h3>Assumptions (explicit)</h3>
      <div class="box assumptions">
        <div class="tag">Assumptions used for trend analysis</div>
        <ul>
          <li>Weakly guiding GI multimode fiber (Δ ≪ 1).</li>
          <li>Δ is constant vs wavelength (so modal dispersion doesn’t change much with λ in this model).</li>
          <li>Waveguide dispersion and polarization-mode dispersion are neglected (not mentioned in the prompt).</li>
          <li>Launch excites many modes (so intermodal dispersion is relevant).</li>
          <li>Small-signal linear propagation (no nonlinear chirp or self-phase modulation).</li>
        </ul>
      </div>

      <h3>Possible approaches (2–3) and comparison</h3>
      <ul>
        <li><b>Approach A: Scaling/variance model</b> (best here): write τ<sub>out</sub> as quadrature sum of τ<sub>0</sub>, modal spread, chromatic spread. <span class="muted">Pros:</span> directly answers parameter trends. <span class="muted">Cons:</span> approximate prefactors.</li>
        <li><b>Approach B: Full mode theory</b>: compute β<sub>m</sub>(ω) for each mode and integrate over source spectrum. <span class="muted">Pros:</span> most rigorous. <span class="muted">Cons:</span> heavy algebra and not needed for qualitative trend question.</li>
        <li><b>Approach C: Ray optics transit-time distribution</b>: derive meridional ray delay vs launch angle for power-law n(r). <span class="muted">Pros:</span> intuitive. <span class="muted">Cons:</span> still more work than required.</li>
      </ul>

      <p class="smallNote">
        <b>Chosen approach:</b> A (scaling + quadrature) because the prompt asks “discuss the effect” of parameter increases,
        i.e., monotonicity/optimality rather than exact numerical widths.
      </p>
    </article>

    <!-- PART 2 -->
    <article id="part2">
      <div class="kicker">PART 2 — Strategy &amp; Tips (Roadmap Only)</div>
      <h2>Plan of attack (minimal but complete)</h2>
      <ol>
        <li>
          <b>Identify broadening mechanisms</b><br/>
          <span class="muted">Tool:</span> fiber dispersion concepts.<br/>
          <span class="muted">Meaning:</span> separate modal vs material contributions.
        </li>
        <li>
          <b>Write a received-width model</b><br/>
          <span class="muted">Tool:</span> Gaussian variance addition: τ<sub>out</sub> ≈ √(τ<sub>0</sub>² + …).<br/>
          <span class="muted">Meaning:</span> shows how each term contributes.
        </li>
        <li>
          <b>Express modal delay spread scaling for GI power-law</b><br/>
          <span class="muted">Tool:</span> weak-guidance GI scaling Δτ<sub>modal</sub> ∝ L(n<sub>1</sub>Δ/c)F(p).<br/>
          <span class="muted">Meaning:</span> p controls equalization; p=2 minimizes.
        </li>
        <li>
          <b>Express material (chromatic) broadening</b><br/>
          <span class="muted">Tool:</span> Δτ<sub>mat</sub> ≈ |D<sub>λ</sub>|Lσ<sub>λ</sub>, with given D<sub>λ</sub> definition.<br/>
          <span class="muted">Meaning:</span> larger curvature of n(λ) or broader spectrum increases spreading.
        </li>
        <li>
          <b>Take parameter derivatives qualitatively</b><br/>
          <span class="muted">Tool:</span> monotonicity and limiting cases (L→0, p→2, p→∞).<br/>
          <span class="muted">Meaning:</span> determine “increase/decrease/optimum”.
        </li>
        <li>
          <b>Sanity checks</b><br/>
          <span class="muted">Tool:</span> units; limiting cases; physical intuition (GI vs step-index; monochromatic vs broadband).<br/>
          <span class="muted">Meaning:</span> ensures trends are consistent.
        </li>
      </ol>

      <div class="box pitfalls">
        <div class="tag">Common mistakes &amp; quick tips</div>
        <ul>
          <li><b>Tip:</b> treat “increase λ<sub>0</sub>” carefully—its effect enters via <b>D<sub>λ</sub>(λ<sub>0</sub>)</b> and can change sign/size with wavelength.</li>
          <li><b>Mistake:</b> saying “increasing p always reduces modal dispersion.” Correct: <b>minimum near p=2</b>; moving away from 2 increases it.</li>
          <li><b>Mistake:</b> adding widths linearly; for Gaussian spreading, add <b>variances</b> (quadrature).</li>
        </ul>
      </div>
    </article>

    <!-- PART 3 -->
    <article id="part3">
      <div class="kicker">PART 3 — Full Solution (Detailed + Teaching)</div>
      <h2>Derivation and parameter-by-parameter conclusions</h2>

      <h3>Physical intuition first (before formulas)</h3>
      <ul>
        <li>Longer fiber gives more time for both <b>modal walk-off</b> and <b>color walk-off</b> → broader pulse.</li>
        <li>A more “perfect” GI profile (near <b>p=2</b>) makes modal arrival times more equal → narrower pulse.</li>
        <li>Broader source spectrum (large σ<sub>λ</sub>) samples more variation in group delay vs wavelength → broader pulse.</li>
      </ul>

      <h3>Step 1 — A received-width model (Gaussian variance addition)</h3>
      <p>
        If the input pulse envelope is approximately Gaussian in time, and each dispersion mechanism produces an approximately
        Gaussian impulse response, then the output temporal variance is the sum of variances. Converting back to a width measure,
        we use the standard quadrature form:
      </p>
      <div class="eq" id="eqQuad">
τ_out ≈ √( τ0^2 + (Δτ_modal)^2 + (Δτ_mat)^2 )
      </div>
      <div class="copyRow">
        <button class="copy" data-copy-target="eqQuad">Copy quadrature model</button>
      </div>
      <p class="smallNote">
        What we did: we separated the <b>initial width</b> and the <b>additional spreading</b> from independent mechanisms.
        Why: the question asks how each parameter affects the final width, and this model makes dependencies explicit.
      </p>

      <h3>Step 2 — Modal dispersion scaling in a power-law graded-index fiber</h3>
      <p>
        For a weakly guiding graded-index fiber with a power-law profile exponent <b>p</b>, the intermodal (modal) delay spread
        scales like
      </p>
      <div class="eq" id="eqModal">
Δτ_modal ≈ (n1 Δ / c0) · L · F(p)

with a convenient trend-capturing factor:
F(p) ≈ |(p − 2)/(p + 2)|

Key checkpoints:
F(2)=0  (parabolic index → minimal modal spread)
F(p→∞)→1  (approaches step-index-like behavior → maximal modal spread)
      </div>
      <div class="copyRow">
        <button class="copy" data-copy-target="eqModal">Copy modal dispersion scaling</button>
      </div>
      <p class="smallNote">
        What we did: we encoded how <b>p</b> controls the equalization of mode transit times into <b>F(p)</b>.
        Why it works for trends: the exact modal distribution depends on launch and mode set, but the existence of an optimum near <b>p=2</b> and the approach to step-index behavior as <b>p</b> grows are robust.
      </p>

      <h3>Step 3 — Material (chromatic) dispersion from n<sub>1</sub>(λ)</h3>
      <p>
        The prompt gives the material-dispersion coefficient:
        <span class="muted">D<sub>λ</sub>(λ<sub>0</sub>) = −(λ<sub>0</sub>/c<sub>0</sub>) d²n<sub>1</sub>/dλ²</span>.
        A source with spectral width σ<sub>λ</sub> experiences a spread in group delay across its spectrum, producing temporal broadening:
      </p>
      <div class="eq" id="eqMat">
Δτ_mat ≈ |Dλ(λ0)| · L · σλ
Dλ(λ0) = −(λ0/c0) · [ d²n1/dλ² ]_(λ0)
      </div>
      <div class="copyRow">
        <button class="copy" data-copy-target="eqMat">Copy material dispersion term</button>
      </div>
      <p class="smallNote">
        Interpretation: <b>d²n/dλ²</b> is the curvature of the index-vs-wavelength curve; larger curvature means larger group-delay variation with wavelength. The absolute value appears because broadening depends on magnitude, not sign.
      </p>

      <h3>Step 4 — Put it together and answer the “increase each parameter” question</h3>
      <p>
        Insert the two broadening terms into the quadrature model:
      </p>
      <div class="eq" id="eqTotal">
τ_out ≈ √( τ0^2 + [ (n1 Δ / c0) · L · F(p) ]^2 + [ |Dλ(λ0)| · L · σλ ]^2 )
      </div>
      <div class="copyRow">
        <button class="copy" data-copy-target="eqTotal">Copy total width model</button>
      </div>

      <div class="box final">
        <div class="tag">Final answer (parameter effects)</div>
        <div class="eq" id="finalAnswer">
Using τ_out ≈ √( τ0^2 + Δτ_modal^2 + Δτ_mat^2 ), with
Δτ_modal ∝ L · F(p) and Δτ_mat ∝ L · |Dλ(λ0)| · σλ:

• Increase L  → τ_out increases (both modal and material broadening scale ~ linearly with L).
• Increase τ0 → τ_out increases (baseline width larger; relative fractional broadening may decrease).
• Increase p  → modal broadening is minimized near p=2; moving p away from 2 increases τ_out.
              In common GI fibers (p≥2): increasing p above 2 increases Δτ_modal toward step-index behavior.
• Increase |Dλ| → τ_out increases (stronger material dispersion).
• Increase σλ   → τ_out increases (broader spectrum → more chromatic delay spread).
• Increase λ0   → affects τ_out through Dλ(λ0)=−(λ0/c0) d²n1/dλ²|λ0:
                 if d²n1/dλ² is roughly fixed, |Dλ| scales ~ λ0 so τ_out tends to increase.
                 In real glass, d²n/dλ² changes with λ and can pass through a zero-dispersion region,
                 so |Dλ(λ0)| (and thus τ_out) may either increase or decrease depending on where λ0 lies.
        </div>
        <div class="copyRow">
          <button class="copy" data-copy-target="finalAnswer">Copy final answer (plain text)</button>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><b>Units:</b> (n<sub>1</sub>Δ/c)·L has units (1/(m/s))·m = s. Also D<sub>λ</sub> (s/m²)·L (m)·σ<sub>λ</sub> (m) = s.</li>
        <li><b>Limiting case L→0:</b> τ<sub>out</sub>→τ<sub>0</sub>.</li>
        <li><b>Limiting case σ<sub>λ</sub>→0 (monochromatic):</b> Δτ<sub>mat</sub>→0 and only modal term remains.</li>
        <li><b>Limiting case p=2:</b> F(p)=0 → modal broadening minimized; only material dispersion broadens the pulse.</li>
        <li><b>Step-index tendency:</b> p→∞ gives F→1, recovering large intermodal spread behavior.</li>
      </ul>

      <p class="smallNote">
        Connection to the diagram/plots below: the diagram shows many ray paths (modes) and a spectrum of wavelengths.
        The plots quantify how each contribution grows with distance and how strongly the modal term depends on p.
      </p>
    </article>

    <!-- VISUALIZATION -->
    <section>
      <div class="kicker">Interactive Visualization</div>
      <h2>See pulse broadening vs distance and profile exponent <span class="muted">(example values for plotting)</span></h2>
      <p class="muted">
        The problem provides symbols but not numbers, so the plots use <b>example values</b> typical of multimode GI fibers.
        This does not change the qualitative parameter conclusions.
      </p>

      <div class="vizWrap">
        <figure>
          <canvas id="cDiagram" aria-label="Fiber diagram canvas"></canvas>
          <figcaption>
            <b>Diagram:</b> Graded-index core (index highest at center), multiple modes/rays, and spectral components. The exponent <b>p</b> controls how “parabolic” the profile is.
          </figcaption>
        </figure>

        <div class="vizRow">
          <figure>
            <canvas id="cMain" aria-label="Main plot canvas"></canvas>
            <figcaption>
              <b>Main quantitative plot:</b> τ<sub>out</sub>(L) and its components using
              τ<sub>out</sub> ≈ √(τ<sub>0</sub>² + Δτ<sub>modal</sub>² + Δτ<sub>mat</sub>²).
            </figcaption>
          </figure>
          <figure>
            <canvas id="cSecond" aria-label="Secondary plot canvas"></canvas>
            <figcaption>
              <b>Secondary plot:</b> Modal factor F(p) ≈ |(p−2)/(p+2)|. A marker shows your chosen p. Minimum at p=2.
            </figcaption>
          </figure>
        </div>

        <div class="controls" aria-label="Interactive controls">
          <div class="control">
            <label>
              Profile exponent <span class="muted">p</span>
              <span class="val" id="valP">2.00</span>
            </label>
            <input id="sliderP" type="range" min="2" max="20" step="0.1" value="2"/>
            <div class="smallNote">Try p=2 (best modal equalization) vs large p (step-index-like).</div>
          </div>
          <div class="control">
            <label>
              Fiber length <span class="muted">L</span> (km)
              <span class="val" id="valL">10.0</span>
            </label>
            <input id="sliderL" type="range" min="0" max="50" step="0.5" value="10"/>
            <div class="smallNote">The vertical marker on the main plot shows the selected L.</div>
          </div>
          <div class="control">
            <label>
              Source spectral width <span class="muted">σ<sub>λ</sub></span> (nm)
              <span class="val" id="valSig">1.00</span>
            </label>
            <input id="sliderSig" type="range" min="0" max="10" step="0.1" value="1"/>
            <div class="smallNote">Increases chromatic broadening linearly.</div>
          </div>
        </div>
      </div>
    </section>

    <!-- PART 4 -->
    <article id="part4">
      <div class="kicker">PART 4 — Deeper Understanding (Theory Around the Result)</div>
      <h2>What each term controls &amp; how parameter changes map to physics</h2>

      <h3>Re-interpreting the final formula</h3>
      <ul>
        <li><b>τ<sub>0</sub></b> sets the baseline: even with zero dispersion, you can’t get narrower than what you launched (in this linear model).</li>
        <li><b>Modal term</b> <span class="muted">[(n<sub>1</sub>Δ/c) L F(p)]</span> is a <b>geometry/profile</b> effect:
          <ul>
            <li><b>Δ</b> sets how “strongly guided” the rays/modes are → stronger differences in modal group delay.</li>
            <li><b>F(p)</b> captures how well the GI profile compensates those differences. Best at <b>p=2</b>.</li>
          </ul>
        </li>
        <li><b>Material term</b> <span class="muted">[|D<sub>λ</sub>(λ<sub>0</sub>)| L σ<sub>λ</sub>]</span> is a <b>spectral/material</b> effect:
          more bandwidth and more curvature in n(λ) increases delay spread across colors.</li>
      </ul>

      <h3>Parameter changes (connect to plots)</h3>
      <ul>
        <li><b>L ↑</b>: both Δτ<sub>modal</sub> and Δτ<sub>mat</sub> grow ~ linearly → τ<sub>out</sub> increases and eventually becomes dispersion-dominated.</li>
        <li><b>τ<sub>0</sub> ↑</b>: τ<sub>out</sub> increases, but the <i>fractional</i> dispersion penalty
          <span class="muted">(τ<sub>out</sub>−τ<sub>0</sub>)/τ<sub>0</sub></span> can decrease if τ<sub>0</sub> is very large.</li>
        <li><b>p ↑</b> (for p≥2): F(p) increases from 0 toward 1 → modal part rises, so τ<sub>out</sub> rises (see secondary plot).</li>
        <li><b>|D<sub>λ</sub>| ↑</b>: stronger material dispersion → τ<sub>out</sub> increases.</li>
        <li><b>σ<sub>λ</sub> ↑</b>: broader spectrum → τ<sub>out</sub> increases (main plot shows Δτ<sub>mat</sub> slope change).</li>
        <li><b>λ<sub>0</sub> ↑</b>: enters through D<sub>λ</sub>(λ<sub>0</sub>). If curvature is fixed, |D<sub>λ</sub>| ∝ λ<sub>0</sub>.
          In reality, curvature changes with λ and may cross a minimum (zero-dispersion region), so τ<sub>out</sub> can decrease near that region.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p class="muted">
        Instead of using a scaling factor F(p), one can compute the group delay τ<sub>g,m</sub> = dβ<sub>m</sub>/dω for each mode m,
        then approximate the modal spread as the rms of τ<sub>g,m</sub> across excited modes. For power-law GI fibers, ray theory can also
        compute transit time vs turning radius; p=2 makes that transit time nearly independent of ray amplitude.
      </p>

      <h3>Concept checks (quick self-test)</h3>
      <ul>
        <li><b>Q:</b> Why does p=2 minimize intermodal dispersion? <b>A:</b> A parabolic profile equalizes transit times: longer paths occur in lower index where speed is higher.</li>
        <li><b>Q:</b> If σ<sub>λ</sub>=0, can the pulse still broaden? <b>A:</b> Yes, via modal dispersion in multimode fibers (unless p≈2 and launch is ideal).</li>
        <li><b>Q:</b> Does the sign of D<sub>λ</sub> matter for width? <b>A:</b> Not for the magnitude of broadening; width depends on |D<sub>λ</sub>|.</li>
        <li><b>Q:</b> Can increasing τ<sub>0</sub> ever reduce τ<sub>out</sub>? <b>A:</b> No in this linear model; it increases τ<sub>out</sub>, though it may reduce <i>relative</i> broadening.</li>
      </ul>
    </article>

    <!-- PART 5 -->
    <article id="part5">
      <div class="kicker">PART 5 — Visualization Guide (How to Read the Plots)</div>
      <h2>What each canvas shows &amp; what the sliders do</h2>

      <h3>Diagram canvas</h3>
      <ul>
        <li>Shows a cross-section idea: index is highest at the center and decreases outward (graded index).</li>
        <li>Multiple rays/modes travel different paths; GI compensation depends on <b>p</b>.</li>
        <li>A “spectrum bar” indicates the source has finite σ<sub>λ</sub>, producing chromatic walk-off.</li>
      </ul>

      <h3>Main plot canvas</h3>
      <ul>
        <li>Plots τ<sub>out</sub>(L) along with the component contributions (baseline τ<sub>0</sub>, modal, material).</li>
        <li>A vertical marker indicates your selected <b>L</b> and displays τ<sub>out</sub> there.</li>
        <li>Change <b>p</b>: modal curve slope changes via F(p).</li>
        <li>Change <b>σ<sub>λ</sub></b>: material curve slope changes linearly.</li>
      </ul>

      <h3>Secondary plot canvas</h3>
      <ul>
        <li>Plots F(p) ≈ |(p−2)/(p+2)| across p; the marker shows your chosen p.</li>
        <li>Near p=2, F is near 0 (excellent equalization). For large p, F approaches 1 (step-index-like).</li>
      </ul>

      <h3>Interactive controls</h3>
      <ul>
        <li><b>p slider:</b> changes the GI profile exponent; updates diagram label, main plot modal contribution, and the F(p) curve marker.</li>
        <li><b>L slider:</b> selects a fiber length and moves the marker on the τ<sub>out</sub>(L) plot; also updates the diagram’s “propagation” annotation.</li>
        <li><b>σ<sub>λ</sub> slider:</b> changes chromatic broadening; updates main plot material contribution and diagram spectrum bar.</li>
      </ul>
    </article>

  </main>
</div>

<footer class="foot">
  <div class="hr"></div>
  <p>
    Built for learning: clean theory, explicit assumptions, and interactive plots. Use the copy buttons to paste equations into notes.
  </p>
</footer>

<script>
(function(){
  // ---------- Smooth TOC scrolling ----------
  document.querySelectorAll('[data-scroll]').forEach(a=>{
    a.addEventListener('click', (e)=>{
      e.preventDefault();
      const id = a.getAttribute('href');
      const el = document.querySelector(id);
      if(!el) return;
      el.scrollIntoView({behavior:'smooth', block:'start'});
      history.replaceState(null, '', id);
    });
  });

  // ---------- Copy buttons ----------
  async function copyTextFromElement(id){
    const el = document.getElementById(id);
    if(!el) return;
    const text = el.innerText.replace(/\n{3,}/g, "\n\n").trim();
    try{
      await navigator.clipboard.writeText(text);
      toast("Copied ✓");
    }catch(err){
      // fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      toast("Copied ✓");
    }
  }
  document.querySelectorAll('button.copy').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const id = btn.getAttribute('data-copy-target');
      copyTextFromElement(id);
    });
  });

  // Simple toast
  let toastTimer = null;
  function toast(msg){
    let t = document.getElementById('toast');
    if(!t){
      t = document.createElement('div');
      t.id='toast';
      t.style.position='fixed';
      t.style.left='50%';
      t.style.bottom='18px';
      t.style.transform='translateX(-50%)';
      t.style.padding='10px 14px';
      t.style.borderRadius='999px';
      t.style.border='1px solid rgba(255,255,255,.18)';
      t.style.background='rgba(10,14,30,.85)';
      t.style.color='white';
      t.style.fontWeight='800';
      t.style.letterSpacing='.2px';
      t.style.boxShadow='0 14px 40px rgba(0,0,0,.35)';
      t.style.backdropFilter='blur(10px)';
      t.style.zIndex='9999';
      t.style.opacity='0';
      t.style.transition='opacity .2s ease';
      document.body.appendChild(t);
    }
    t.textContent = msg;
    t.style.opacity='1';
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>{ t.style.opacity='0'; }, 900);
  }

  // ---------- Model + Example constants ----------
  const c0 = 299792458;            // m/s
  const n1 = 1.48;                 // example peak refractive index
  const Delta = 0.01;              // example relative index difference
  const tau0 = 2e-9;               // 2 ns example initial width
  // Material dispersion coefficient in s/m^2.
  // Typical telecom D ~ 17 ps/(nm·km) => 17e-6 s/m^2
  let DlambdaMag = 17e-6;          // example |Dλ(λ0)|

  // Trend factor for power-law GI fiber
  function Fp(p){
    return Math.abs((p - 2) / (p + 2));
  }

  function computeWidths(L_km, p, sig_nm){
    const L = L_km * 1e3;          // meters
    const sig = sig_nm * 1e-9;     // meters
    const modal = (n1 * Delta / c0) * L * Fp(p);
    const mat = Math.abs(DlambdaMag) * L * sig;
    const out = Math.sqrt(tau0*tau0 + modal*modal + mat*mat);
    return {modal, mat, out};
  }

  // ---------- Canvas helpers ----------
  function setupCanvas(canvas){
    const ctx = canvas.getContext('2d');
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(10, Math.floor(rect.width * dpr));
      const h = Math.max(10, Math.floor(rect.height * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    }
    return {ctx, resize};
  }

  function clear(ctx, w, h){
    ctx.clearRect(0,0,w,h);
  }

  function roundNice(x){
    if(x === 0) return 0;
    const p = Math.pow(10, Math.floor(Math.log10(Math.abs(x))));
    const f = Math.abs(x) / p;
    let nf = 1;
    if(f >= 7.5) nf = 10;
    else if(f >= 3.5) nf = 5;
    else if(f >= 1.5) nf = 2;
    return nf * p;
  }

  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
    const {x,y,w,h} = box;
    // background panel
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, 12);
    ctx.fill();
    ctx.stroke();

    const padL=54, padR=18, padT=42, padB=46;
    const px0 = x + padL, px1 = x + w - padR;
    const py0 = y + padT, py1 = y + h - padB;

    // gridlines & ticks
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillStyle = 'rgba(233,236,255,.92)';
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 1;

    const xRange = xMax - xMin;
    const yRange = yMax - yMin;
    const xStep = roundNice(xRange/6);
    const yStep = roundNice(yRange/6);

    // Title
    ctx.font = '700 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillStyle = 'rgba(233,236,255,.95)';
    ctx.fillText(title, x+14, y+24);

    // grid
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;

    // x grid & labels
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillStyle = 'rgba(185,192,255,.95)';
    for(let xv = Math.ceil(xMin/xStep)*xStep; xv <= xMax + 1e-12; xv += xStep){
      const t = (xv - xMin)/xRange;
      const X = px0 + t*(px1-px0);
      ctx.beginPath();
      ctx.moveTo(X, py0);
      ctx.lineTo(X, py1);
      ctx.stroke();
      ctx.fillText(formatNum(xv), X-10, py1+18);
      // tick
      ctx.strokeStyle = 'rgba(255,255,255,0.14)';
      ctx.beginPath();
      ctx.moveTo(X, py1);
      ctx.lineTo(X, py1+5);
      ctx.stroke();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    }

    // y grid & labels
    for(let yv = Math.ceil(yMin/yStep)*yStep; yv <= yMax + 1e-12; yv += yStep){
      const t = (yv - yMin)/yRange;
      const Y = py1 - t*(py1-py0);
      ctx.beginPath();
      ctx.moveTo(px0, Y);
      ctx.lineTo(px1, Y);
      ctx.stroke();
      ctx.fillText(formatNum(yv), x+10, Y+4);
      // tick
      ctx.strokeStyle = 'rgba(255,255,255,0.14)';
      ctx.beginPath();
      ctx.moveTo(px0-5, Y);
      ctx.lineTo(px0, Y);
      ctx.stroke();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    }

    // axes border
    ctx.strokeStyle = 'rgba(255,255,255,0.20)';
    ctx.lineWidth = 1;
    ctx.strokeRect(px0, py0, px1-px0, py1-py0);

    // labels
    ctx.font = '700 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillStyle = 'rgba(233,236,255,.95)';
    ctx.fillText(xLabel, (px0+px1)/2 - ctx.measureText(xLabel).width/2, y+h-14);

    // y label rotated
    ctx.save();
    ctx.translate(x+16, (py0+py1)/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
    ctx.restore();

    ctx.restore();
    return {px0, px1, py0, py1};
  }

  function formatNum(v){
    const av = Math.abs(v);
    if(av >= 1000) return v.toFixed(0);
    if(av >= 100) return v.toFixed(0);
    if(av >= 10) return v.toFixed(1);
    if(av >= 1) return v.toFixed(2);
    return v.toFixed(3);
  }

  function mapX(val, xMin, xMax, px0, px1){
    return px0 + (val-xMin)/(xMax-xMin) * (px1-px0);
  }
  function mapY(val, yMin, yMax, py0, py1){
    return py1 - (val-yMin)/(yMax-yMin) * (py1-py0);
  }

  function drawLine(ctx, pts, strokeStyle, lineWidth){
    ctx.save();
    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = lineWidth || 2;
    ctx.beginPath();
    for(let i=0;i<pts.length;i++){
      const p=pts[i];
      if(i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function legend(ctx, items, x, y){
    ctx.save();
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillStyle = 'rgba(233,236,255,.92)';
    const pad=10, lineH=18;
    // Measure width
    let w = 0;
    items.forEach(it=>{
      w = Math.max(w, 26 + ctx.measureText(it.label).width);
    });
    const h = pad*2 + items.length*lineH;
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath();
    ctx.roundRect(x, y, w+pad*2, h, 12);
    ctx.fill();
    ctx.stroke();

    items.forEach((it,i)=>{
      const yy = y + pad + i*lineH + 11;
      ctx.strokeStyle = it.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x+pad, yy-4);
      ctx.lineTo(x+pad+16, yy-4);
      ctx.stroke();
      ctx.fillStyle = 'rgba(233,236,255,.92)';
      ctx.fillText(it.label, x+pad+22, yy);
    });

    ctx.restore();
  }

  // ---------- Canvases ----------
  const cDiagram = document.getElementById('cDiagram');
  const cMain = document.getElementById('cMain');
  const cSecond = document.getElementById('cSecond');

  const D = setupCanvas(cDiagram);
  const M = setupCanvas(cMain);
  const S = setupCanvas(cSecond);

  // Controls
  const sliderP = document.getElementById('sliderP');
  const sliderL = document.getElementById('sliderL');
  const sliderSig = document.getElementById('sliderSig');
  const valP = document.getElementById('valP');
  const valL = document.getElementById('valL');
  const valSig = document.getElementById('valSig');

  function readState(){
    const p = parseFloat(sliderP.value);
    const L = parseFloat(sliderL.value);
    const sig = parseFloat(sliderSig.value);
    return {p, L, sig};
  }

  function updateLabels({p,L,sig}){
    valP.textContent = p.toFixed(2);
    valL.textContent = L.toFixed(1);
    valSig.textContent = sig.toFixed(2);
  }

  // ---------- Draw diagram ----------
  function drawDiagram(state){
    D.resize();
    const ctx = D.ctx;
    const w = cDiagram.clientWidth;
    const h = cDiagram.clientHeight;
    clear(ctx, w, h);

    // Title-like overlay
    ctx.save();
    ctx.fillStyle = 'rgba(233,236,255,.92)';
    ctx.font = '700 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText('Physical setup: graded-index fiber + pulse spectrum', 14, 22);
    ctx.restore();

    // Fiber cross-section
    const cx = w*0.30, cy = h*0.55;
    const rCore = Math.min(w,h)*0.22;
    const rClad = rCore*1.35;

    // Cladding
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, rClad, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    // Core gradient rings (to hint n(r))
    for(let i=0;i<18;i++){
      const t = i/17;
      const rr = rCore*(1 - t*0.98);
      const alpha = 0.02 + (1-t)*0.06;
      ctx.fillStyle = `rgba(124,240,214,${alpha})`;
      ctx.beginPath();
      ctx.arc(cx, cy, rr, 0, Math.PI*2);
      ctx.fill();
    }
    // Core boundary
    ctx.strokeStyle = 'rgba(124,240,214,0.45)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, rCore, 0, Math.PI*2);
    ctx.stroke();

    // Rays/modes
    ctx.strokeStyle = 'rgba(138,162,255,0.55)';
    ctx.lineWidth = 2;
    const rays = 5;
    for(let k=0;k<rays;k++){
      const ang = (-0.9 + k*(1.8/(rays-1))) * 0.55;
      ctx.beginPath();
      const x0 = cx - rCore*1.05, y0 = cy + ang*rCore*0.7;
      const x1 = cx + rCore*1.05, y1 = cy - ang*rCore*0.7;
      ctx.moveTo(x0, y0);
      // a slight curve: GI "bending"
      const mx = (x0+x1)/2, my = (y0+y1)/2 - ang*rCore*0.35;
      ctx.quadraticCurveTo(mx, my, x1, y1);
      ctx.stroke();
    }

    // Labels
    ctx.fillStyle = 'rgba(185,192,255,.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText('core', cx - 16, cy - rCore - 10);
    ctx.fillText('cladding', cx - 30, cy + rClad + 16);

    ctx.fillStyle = 'rgba(233,236,255,.92)';
    ctx.font = '700 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(`profile exponent p = ${state.p.toFixed(2)} (best modal equalization near p=2)`, 14, h-16);

    // Spectrum bar (right side)
    const bx = w*0.62, by = h*0.25, bw = w*0.34, bh = h*0.20;
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.roundRect(bx, by, bw, bh, 12);
    ctx.fill();
    ctx.stroke();

    // "Spectrum" stripe with width tied to sig
    const sig = state.sig; // nm
    const frac = Math.min(1, sig/10); // 0..1
    const mid = bx + bw*0.55;
    const half = bw*(0.08 + 0.36*frac);
    // gradient fill
    const grad = ctx.createLinearGradient(mid-half, 0, mid+half, 0);
    grad.addColorStop(0, 'rgba(138,162,255,0.10)');
    grad.addColorStop(0.5,'rgba(255,204,102,0.25)');
    grad.addColorStop(1, 'rgba(124,240,214,0.10)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.roundRect(mid-half, by+bh*0.35, 2*half, bh*0.30, 999);
    ctx.fill();

    ctx.fillStyle = 'rgba(185,192,255,.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText('source spectrum', bx+12, by+20);
    ctx.fillText(`σλ = ${sig.toFixed(2)} nm`, bx+12, by+38);

    // Propagation annotation (length)
    const L = state.L; // km
    const ax0 = w*0.62, ay0 = h*0.60, ax1 = w*0.92, ay1 = h*0.60;
    ctx.strokeStyle = 'rgba(124,240,214,0.55)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(ax0, ay0);
    ctx.lineTo(ax1, ay1);
    ctx.stroke();
    // arrow heads
    function arrow(x,y,dir){
      ctx.beginPath();
      ctx.moveTo(x,y);
      ctx.lineTo(x-8*dir, y-5);
      ctx.lineTo(x-8*dir, y+5);
      ctx.closePath();
      ctx.fillStyle='rgba(124,240,214,0.55)';
      ctx.fill();
    }
    arrow(ax0, ay0, -1);
    arrow(ax1, ay1, 1);
    ctx.fillStyle = 'rgba(233,236,255,.92)';
    ctx.font = '700 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(`fiber length L = ${L.toFixed(1)} km`, ax0, ay0-10);

    ctx.restore();
  }

  // ---------- Draw main plot: tau_out vs L ----------
  function drawMain(state){
    M.resize();
    const ctx = M.ctx;
    const w = cMain.clientWidth;
    const h = cMain.clientHeight;
    clear(ctx, w, h);

    // Compute curves
    const Lmax = 50;
    const N = 240;
    let maxTau = 0;
    const ptsOut = [];
    const ptsModal = [];
    const ptsMat = [];

    for(let i=0;i<=N;i++){
      const Lk = (i/N)*Lmax;
      const {modal, mat, out} = computeWidths(Lk, state.p, state.sig);
      maxTau = Math.max(maxTau, out, tau0 + modal + mat);
      ptsOut.push({Lk, tau: out});
      ptsModal.push({Lk, tau: Math.sqrt(tau0*tau0 + modal*modal)}); // baseline + modal
      ptsMat.push({Lk, tau: Math.sqrt(tau0*tau0 + mat*mat)});       // baseline + material
    }

    // Use ns for display
    const yMin = 0;
    const yMax = (maxTau*1e9) * 1.15; // ns
    const xMin = 0, xMax = Lmax;

    const box = {x:0, y:0, w:w, h:h};
    const ax = drawAxes(
      ctx, box,
      xMin, xMax,
      yMin, yMax,
      'L (km)',
      'Pulse width τ (ns)',
      'Received pulse width vs distance (example values)'
    );

    // Map points
    function mapCurve(arr){
      return arr.map(p=>{
        return {
          x: mapX(p.Lk, xMin, xMax, ax.px0, ax.px1),
          y: mapY(p.tau*1e9, yMin, yMax, ax.py0, ax.py1)
        };
      });
    }

    const cOut = mapCurve(ptsOut);
    const cModal = mapCurve(ptsModal);
    const cMat = mapCurve(ptsMat);

    // Draw curves
    drawLine(ctx, cModal, 'rgba(138,162,255,0.85)', 2.5);
    drawLine(ctx, cMat,   'rgba(255,204,102,0.85)', 2.5);
    drawLine(ctx, cOut,   'rgba(124,240,214,0.95)', 3);

    // Vertical marker at selected L
    const xMark = mapX(state.L, xMin, xMax, ax.px0, ax.px1);
    ctx.save();
    ctx.strokeStyle = 'rgba(233,236,255,0.35)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(xMark, ax.py0);
    ctx.lineTo(xMark, ax.py1);
    ctx.stroke();
    ctx.setLineDash([]);

    const wNow = computeWidths(state.L, state.p, state.sig);
    const yNow = mapY(wNow.out*1e9, yMin, yMax, ax.py0, ax.py1);

    // point
    ctx.fillStyle = 'rgba(124,240,214,0.95)';
    ctx.beginPath();
    ctx.arc(xMark, yNow, 4.5, 0, Math.PI*2);
    ctx.fill();

    // annotation
    ctx.fillStyle = 'rgba(233,236,255,.92)';
    ctx.font = '700 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    const txt = `τ_out(${state.L.toFixed(1)} km) ≈ ${(wNow.out*1e9).toFixed(2)} ns`;
    const tw = ctx.measureText(txt).width;
    const bx = Math.min(ax.px1 - tw - 12, xMark + 10);
    const by = Math.max(ax.py0 + 10, yNow - 26);
    ctx.fillStyle = 'rgba(0,0,0,0.30)';
    ctx.strokeStyle = 'rgba(255,255,255,0.14)';
    ctx.beginPath();
    ctx.roundRect(bx-8, by-14, tw+16, 26, 10);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = 'rgba(233,236,255,.92)';
    ctx.fillText(txt, bx, by+4);

    ctx.restore();

    // Legend
    legend(ctx, [
      {label:'τ_out (total)', color:'rgba(124,240,214,0.95)'},
      {label:'√(τ0² + Δτ_modal²)', color:'rgba(138,162,255,0.85)'},
      {label:'√(τ0² + Δτ_mat²)', color:'rgba(255,204,102,0.85)'}
    ], ax.px0 + 10, ax.py0 + 10);
  }

  // ---------- Draw secondary plot: F(p) vs p ----------
  function drawSecond(state){
    S.resize();
    const ctx = S.ctx;
    const w = cSecond.clientWidth;
    const h = cSecond.clientHeight;
    clear(ctx, w, h);

    const pMin = 2, pMax = 20;
    const N = 240;
    const pts = [];
    let yMax = 0;
    for(let i=0;i<=N;i++){
      const p = pMin + (i/N)*(pMax-pMin);
      const f = Fp(p);
      yMax = Math.max(yMax, f);
      pts.push({p, f});
    }
    yMax = Math.max(1.0, yMax*1.05);

    const box = {x:0, y:0, w:w, h:h};
    const ax = drawAxes(
      ctx, box,
      pMin, pMax,
      0, yMax,
      'p (profile exponent)',
      'F(p) (dimensionless)',
      'Modal equalization factor vs p'
    );

    const curve = pts.map(pt=>{
      return {
        x: mapX(pt.p, pMin, pMax, ax.px0, ax.px1),
        y: mapY(pt.f, 0, yMax, ax.py0, ax.py1)
      };
    });
    drawLine(ctx, curve, 'rgba(138,162,255,0.95)', 3);

    // marker at chosen p
    const fNow = Fp(state.p);
    const xNow = mapX(state.p, pMin, pMax, ax.px0, ax.px1);
    const yNow = mapY(fNow, 0, yMax, ax.py0, ax.py1);

    ctx.save();
    // guide lines
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(xNow, ax.py0);
    ctx.lineTo(xNow, ax.py1);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(ax.px0, yNow);
    ctx.lineTo(ax.px1, yNow);
    ctx.stroke();
    ctx.setLineDash([]);

    // point
    ctx.fillStyle = 'rgba(124,240,214,0.95)';
    ctx.beginPath();
    ctx.arc(xNow, yNow, 5, 0, Math.PI*2);
    ctx.fill();

    // annotate
    ctx.font = '700 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    const txt = `F(${state.p.toFixed(2)}) ≈ ${fNow.toFixed(3)}`;
    const tw = ctx.measureText(txt).width;
    const bx = Math.min(ax.px1 - tw - 12, xNow + 10);
    const by = Math.max(ax.py0 + 10, yNow - 26);

    ctx.fillStyle = 'rgba(0,0,0,0.30)';
    ctx.strokeStyle = 'rgba(255,255,255,0.14)';
    ctx.beginPath();
    ctx.roundRect(bx-8, by-14, tw+16, 26, 10);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = 'rgba(233,236,255,.92)';
    ctx.fillText(txt, bx, by+4);

    // show p=2 minimum marker
    const x2 = mapX(2, pMin, pMax, ax.px0, ax.px1);
    const y2 = mapY(0, 0, yMax, ax.py0, ax.py1);
    ctx.fillStyle = 'rgba(255,204,102,0.85)';
    ctx.beginPath();
    ctx.arc(x2, y2, 4.5, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(185,192,255,.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText('minimum at p=2', x2+10, y2-8);

    ctx.restore();

    legend(ctx, [
      {label:'F(p) ≈ |(p−2)/(p+2)|', color:'rgba(138,162,255,0.95)'},
      {label:'selected p', color:'rgba(124,240,214,0.95)'}
    ], ax.px0 + 10, ax.py0 + 10);
  }

  function render(){
    const state = readState();
    updateLabels(state);
    drawDiagram(state);
    drawMain(state);
    drawSecond(state);
  }

  // Resize listener
  window.addEventListener('resize', render, {passive:true});

  // Control listeners
  [sliderP, sliderL, sliderSig].forEach(s=>{
    s.addEventListener('input', render);
  });

  // Initial render
  render();

  // RoundRect polyfill for older browsers
  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    };
  }
})();
</script>
</body>
</html>
