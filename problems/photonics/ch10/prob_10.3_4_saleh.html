<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Modal Dispersion in Step-Index Fibers — Core Radius & Response Time</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:rgba(255,255,255,.06);
      --panel2:rgba(255,255,255,.09);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.68);
      --faint:rgba(255,255,255,.46);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#86efac;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 16px 50px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(900px 600px at 15% 10%, rgba(125,211,252,.18), transparent 55%),
        radial-gradient(900px 600px at 85% 0%, rgba(167,139,250,.14), transparent 55%),
        radial-gradient(1200px 900px at 60% 90%, rgba(134,239,172,.10), transparent 60%),
        linear-gradient(180deg, #070a14 0%, #0b1020 35%, #070a14 100%);
      line-height:1.55;
      overflow-x:hidden;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:28px 18px 14px;
      max-width:1180px;
      margin:0 auto;
    }
    .hero{
      background:linear-gradient(135deg, rgba(125,211,252,.12), rgba(167,139,250,.10));
      border:1px solid rgba(255,255,255,.10);
      border-radius:calc(var(--radius) + 6px);
      box-shadow:var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .hero::after{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(700px 280px at 20% 0%, rgba(125,211,252,.14), transparent 65%),
        radial-gradient(700px 280px at 80% 0%, rgba(167,139,250,.12), transparent 65%);
      pointer-events:none;
      filter:blur(2px);
      opacity:.9;
    }
    .hero-inner{
      position:relative;
      z-index:1;
      padding:22px 22px 18px;
      display:grid;
      grid-template-columns: 1.3fr .9fr;
      gap:16px;
      align-items:start;
    }
    h1{
      margin:0 0 8px;
      font-size: clamp(22px, 2.3vw, 34px);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size: clamp(14px, 1.2vw, 16px);
    }
    .meta{
      padding:14px 14px 12px;
      border-radius:14px;
      background:rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
    }
    .meta .row{
      display:flex; justify-content:space-between; gap:10px;
      padding:6px 0;
      border-bottom:1px dashed rgba(255,255,255,.12);
      font-size:13px;
      color:var(--muted);
    }
    .meta .row:last-child{border-bottom:none}
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      color:var(--muted);
      font-size:12px;
      margin-top:10px;
    }
    .dot{
      width:9px; height:9px; border-radius:50%;
      background:var(--accent);
      box-shadow:0 0 0 4px rgba(125,211,252,.12);
    }

    main{
      max-width:1180px;
      margin:0 auto;
      padding:14px 18px 60px;
      display:grid;
      grid-template-columns: 280px 1fr;
      gap:18px;
      align-items:start;
    }
    nav{
      position:sticky;
      top:14px;
      align-self:start;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .toc-head{
      padding:14px 14px 12px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.16);
    }
    .toc-head strong{display:block; font-size:13px; letter-spacing:.3px}
    .toc-head span{display:block; color:var(--muted); font-size:12px; margin-top:4px}
    .toc{
      list-style:none;
      margin:0;
      padding:10px 10px 12px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .toc a{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.04);
      color:var(--text);
      font-size:13px;
      transition:transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .toc a:hover{
      transform:translateY(-1px);
      background:rgba(255,255,255,.07);
      border-color:rgba(125,211,252,.22);
      text-decoration:none;
    }
    .toc small{color:var(--muted)}
    article{
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    section{
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:18px 18px 16px;
    }
    section h2{
      margin:0 0 10px;
      font-size: clamp(18px, 1.6vw, 24px);
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .tag{
      font-size:12px;
      color:var(--muted);
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.12);
      white-space:nowrap;
    }
    p{margin:10px 0; color:var(--text)}
    ul{margin:10px 0 0 20px; color:var(--text)}
    li{margin:6px 0}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .card{
      background:rgba(0,0,0,.16);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:12px 12px 10px;
    }
    .card h3{
      margin:0 0 8px;
      font-size:14px;
      color:var(--text);
      letter-spacing:.2px;
    }
    .muted{color:var(--muted)}
    .callout{
      border-radius:16px;
      padding:12px 12px 10px;
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(135deg, rgba(125,211,252,.10), rgba(167,139,250,.08));
    }
    .callout strong{display:block; margin-bottom:6px}
    .equation{
      font-family:var(--mono);
      font-size:13px;
      padding:10px 10px;
      border-radius:14px;
      background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
      color:rgba(255,255,255,.90);
      overflow:auto;
      position:relative;
    }
    .eqrow{
      display:flex; gap:10px; align-items:flex-start;
    }
    .copybtn{
      flex:0 0 auto;
      margin-left:auto;
      border:none;
      cursor:pointer;
      padding:9px 10px;
      border-radius:12px;
      background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.14);
      color:var(--text);
      font-size:12px;
      transition:transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      white-space:nowrap;
    }
    .copybtn:hover{
      transform:translateY(-1px);
      background:rgba(255,255,255,.13);
      border-color:rgba(125,211,252,.26);
    }
    .copybtn:active{transform:translateY(0px) scale(.99)}
    .kbd{
      font-family:var(--mono);
      font-size:12px;
      padding:3px 6px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.20);
      color:var(--muted);
    }
    figure{
      margin:0;
      padding:12px;
      border-radius:16px;
      background:rgba(0,0,0,.16);
      border:1px solid rgba(255,255,255,.10);
    }
    figcaption{
      color:var(--muted);
      font-size:12px;
      margin-top:10px;
      line-height:1.45;
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius:14px;
      background:rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    .control{
      background:rgba(0,0,0,.16);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:12px 12px 10px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:12px;
      color:var(--muted);
      margin-bottom:8px;
    }
    input[type="range"]{width:100%}
    .value{
      font-family:var(--mono);
      color:var(--text);
      font-size:12px;
    }
    .answerbox{
      border-radius:18px;
      padding:14px 14px 12px;
      border:1px solid rgba(134,239,172,.30);
      background:linear-gradient(135deg, rgba(134,239,172,.10), rgba(125,211,252,.08));
    }
    .answerbox h3{margin:0 0 8px; font-size:14px}
    .answergrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .ansline{
      font-family:var(--mono);
      font-size:13px;
      padding:10px 10px;
      border-radius:14px;
      background:rgba(0,0,0,.20);
      border:1px solid rgba(255,255,255,.10);
      overflow:auto;
    }
    footer{
      max-width:1180px;
      margin:0 auto;
      padding:16px 18px 36px;
      color:var(--muted);
      font-size:12px;
    }

    .fade-in{
      animation: fadeIn .5s ease both;
    }
    @keyframes fadeIn{
      from{opacity:0; transform:translateY(6px)}
      to{opacity:1; transform:translateY(0)}
    }

    @media (max-width: 980px){
      main{grid-template-columns:1fr}
      nav{position:relative; top:auto}
      .hero-inner{grid-template-columns:1fr}
      canvas{height:300px}
      .controls{grid-template-columns:1fr}
      .grid2{grid-template-columns:1fr}
      .answergrid{grid-template-columns:1fr}
    }

    @media print{
      body{background:#fff; color:#000}
      nav{display:none}
      section, .hero{box-shadow:none}
      canvas{border:1px solid #bbb; background:#fff}
      .copybtn{display:none}
      a{color:#000; text-decoration:underline}
      .equation,.ansline{border:1px solid #bbb; background:#fff; color:#000}
    }
  </style>
</head>
<body>
  <header class="fade-in">
    <div class="hero">
      <div class="hero-inner">
        <div>
          <h1>Modal Dispersion in Step-Index Fibers: Core Radius & Pulse Response Time</h1>
          <p class="subtitle">
            We connect three cornerstone ideas—normalized frequency <span class="kbd">V</span>, the multimode mode-count approximation,
            and intermodal delay—to compute (i) the <em>core radius</em> of a step-index fiber and (ii) its <em>modal-dispersion response time</em>
            for a given length.
          </p>
          <div class="pill"><span class="dot"></span><span>Interactive plots below update live when you vary NA and fiber length.</span></div>
        </div>
        <div class="meta" aria-label="Problem data summary">
          <div class="row"><span>Given wavelength</span><span><span class="kbd">&lambda;</span> = 0.87 &mu;m</span></div>
          <div class="row"><span>Numerical aperture</span><span><span class="kbd">NA</span> = 0.1</span></div>
          <div class="row"><span>Number of modes</span><span><span class="kbd">M</span> = 5000</span></div>
          <div class="row"><span>Core refractive index</span><span><span class="kbd">n<sub>1</sub></span> = 1.445</span></div>
          <div class="row"><span>Group index (core)</span><span><span class="kbd">N<sub>1</sub></span> = 1.456</span></div>
          <div class="row"><span>Fiber length</span><span><span class="kbd">L</span> = 2 km</span></div>
          <div class="row"><span>Note</span><span><span class="kbd">&Delta;</span> treated ~ independent of &lambda;</span></div>
        </div>
      </div>
    </div>
  </header>

  <main class="fade-in">
    <nav aria-label="Table of contents">
      <div class="toc-head">
        <strong>Table of Contents</strong>
        <span>Jump to each part (sticky)</span>
      </div>
      <ul class="toc">
        <li><a href="#quick"><span>Quick Summary</span><small>results</small></a></li>
        <li><a href="#part0"><span>PART 0 — Concept Primer</span><small>theory</small></a></li>
        <li><a href="#part1"><span>PART 1 — Problem Analysis</span><small>setup</small></a></li>
        <li><a href="#part2"><span>PART 2 — Strategy & Tips</span><small>roadmap</small></a></li>
        <li><a href="#part3"><span>PART 3 — Full Solution</span><small>derivation</small></a></li>
        <li><a href="#part4"><span>PART 4 — Deeper Understanding</span><small>insight</small></a></li>
        <li><a href="#part5"><span>PART 5 — Visualization Guide</span><small>how to read</small></a></li>
      </ul>
    </nav>

    <article>
      <!-- Quick Summary -->
      <section id="quick">
        <h2>Quick Summary <span class="tag">what you’ll get</span></h2>
        <ul>
          <li><strong>What this is about:</strong> a <em>multimode step-index fiber</em> where many guided modes arrive at different times (modal dispersion).</li>
          <li><strong>Key idea #1 (mode count):</strong> for large <span class="kbd">V</span>, the total number of guided modes is approximately
            <span class="kbd">M &asymp; V<sup>2</sup>/2</span> (step-index, weak guidance, counting polarizations).</li>
          <li><strong>Key idea #2 (geometry & NA):</strong> the normalized frequency is
            <span class="kbd">V = (2&pi;a/&lambda;)&nbsp;NA</span>, linking wavelength, NA, and core radius <span class="kbd">a</span>.</li>
          <li><strong>Key idea #3 (intermodal delay):</strong> step-index fibers have an approximate total modal delay spread
            <span class="kbd">&Delta;T &approx; (N<sub>1</sub>&Delta;L)/c</span>, where <span class="kbd">&Delta;</span> is the relative index difference.</li>
          <li><strong>How we estimate &Delta;:</strong> in weak guidance,
            <span class="kbd">NA &approx; n<sub>1</sub>&radic;(2&Delta;)</span> &rArr; <span class="kbd">&Delta; &approx; (NA/n<sub>1</sub>)<sup>2</sup>/2</span>.</li>
          <li><strong>Final results (numeric):</strong> core radius <span class="kbd">a</span> (in &mu;m) and modal-dispersion response time <span class="kbd">&sigma;<sub>t</sub></span> (in ns) for <span class="kbd">L = 2 km</span>.</li>
        </ul>

        <div class="answerbox" style="margin-top:14px">
          <h3>Final Answer (for the given problem data)</h3>
          <div class="answergrid">
            <div class="ansline" id="ansA">a ≈ 138.5 μm</div>
            <div class="ansline" id="ansSig">σ_t ≈ 6.71 ns (for L = 2 km)</div>
          </div>
          <div class="eqrow" style="margin-top:10px">
            <div class="equation" style="flex:1" id="finalCopyText">
              a = (λ/(2π NA)) √(2M) ;   Δ ≈ (NA/n1)^2 / 2 ;   ΔT ≈ (N1 Δ L)/c ;   σ_t ≈ ΔT/√12
            </div>
            <button class="copybtn" data-copy="#finalCopyText">Copy final formulas</button>
            <button class="copybtn" data-copy-text="a ≈ 138.5 μm;  σ_t ≈ 6.71 ns (L = 2 km)">Copy final numbers</button>
          </div>
        </div>
      </section>

      <!-- PART 0 -->
      <section id="part0">
        <h2>PART 0 — Concept Primer (Theory Before Solving) <span class="tag">build intuition</span></h2>

        <div class="grid2">
          <div class="card">
            <h3>Core definitions (symbols & units)</h3>
            <ul class="muted">
              <li><span class="kbd">a</span> — core radius (m).</li>
              <li><span class="kbd">n<sub>1</sub>, n<sub>2</sub></span> — core / cladding refractive indices (dimensionless), with <span class="kbd">n<sub>1</sub> &gt; n<sub>2</sub></span>.</li>
              <li><span class="kbd">NA</span> — numerical aperture (dimensionless). For launch from air: <span class="kbd">NA = sin θ<sub>0,max</sub></span>.</li>
              <li><span class="kbd">Δ</span> — relative index difference (dimensionless): <span class="kbd">Δ = (n<sub>1</sub> - n<sub>2</sub>)/n<sub>1</sub></span> (weak guidance).</li>
              <li><span class="kbd">λ</span> — vacuum wavelength (m).</li>
              <li><span class="kbd">V</span> — normalized frequency (dimensionless): <span class="kbd">V = (2πa/λ) NA</span>.</li>
              <li><span class="kbd">M</span> — total number of guided modes (dimensionless count).</li>
              <li><span class="kbd">N<sub>1</sub></span> — group index of core (dimensionless), sets group velocity: <span class="kbd">v<sub>g</sub> = c/N<sub>1</sub></span>.</li>
              <li><span class="kbd">L</span> — fiber length (m).</li>
              <li><span class="kbd">σ<sub>t</sub></span> — modal-dispersion response time (s), here treated as RMS width of an approximately rectangular impulse response.</li>
            </ul>
          </div>

          <div class="callout">
            <strong>Physical meaning (what these represent)</strong>
            <p class="muted" style="margin:0">
              <span class="kbd">V</span> measures “how many transverse oscillations” can fit across the core—larger <span class="kbd">V</span> means more modes.
              A step-index fiber guides rays/modes with different zig-zag angles; those with larger angles travel a longer geometric path,
              arriving later: that’s <em>modal dispersion</em>.
            </p>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <h3>Key laws / principles and validity</h3>
          <ul>
            <li><strong>Weak guidance (Δ ≪ 1):</strong> typical silica fibers have Δ ~ 10<sup>-3</sup>–10<sup>-2</sup>. Then
              <span class="kbd">NA ≈ n<sub>1</sub>√(2Δ)</span> and mode counting becomes simple.</li>
            <li><strong>Large-V multimode approximation:</strong> when <span class="kbd">V ≫ 1</span>, the mode density is high and
              <span class="kbd">M ≈ V²/2</span> is accurate to within a few percent for step-index fibers.</li>
            <li><strong>Intermodal delay (step-index):</strong> because the core index is uniform, different angles correspond to different
              path lengths; the maximal delay spread scales like <span class="kbd">ΔT ∝ Δ·L</span>.</li>
            <li><strong>Group index usage:</strong> pulse timing is governed by group velocity, hence using <span class="kbd">N<sub>1</sub></span>
              (not <span class="kbd">n<sub>1</sub></span>) in time-of-flight estimates is a better approximation.</li>
          </ul>
        </div>

        <div class="grid2" style="margin-top:12px">
          <div class="card">
            <h3>Common models/approximations (why we use them)</h3>
            <ul>
              <li><strong>Ray picture:</strong> useful for understanding modal dispersion in multimode step-index fibers (modes ↔ ray angles).</li>
              <li><strong>Uniform mode excitation:</strong> often assumed for an impulse response estimate; then the time spread is close to a rectangular distribution.</li>
              <li><strong>Rectangular impulse response:</strong> if arrival times fill a range fairly evenly, RMS width is <span class="kbd">ΔT/√12</span>.</li>
            </ul>
          </div>
          <div class="card">
            <h3>Mini intuition examples</h3>
            <ul>
              <li>If you double <span class="kbd">a</span> (same <span class="kbd">NA, λ</span>), then <span class="kbd">V</span> doubles, so <span class="kbd">M ~ V²</span> increases by <strong>4×</strong>.</li>
              <li>If you halve <span class="kbd">Δ</span> (e.g., smaller NA), then intermodal delay spread roughly halves: <span class="kbd">ΔT ∝ Δ</span>.</li>
            </ul>
          </div>
        </div>

        <div class="callout" style="margin-top:12px">
          <strong>What to watch for (pitfalls)</strong>
          <ul class="muted" style="margin:0 0 0 18px">
            <li>Mixing <span class="kbd">n</span> (phase index) with <span class="kbd">N</span> (group index) in time-delay formulas.</li>
            <li>Forgetting that <span class="kbd">M ≈ V²/2</span> is a <em>large-V</em> approximation (here it will be very large).</li>
            <li>Unit slips: &mu;m ↔ m, km ↔ m.</li>
            <li>Confusing total delay spread <span class="kbd">ΔT</span> with RMS response time <span class="kbd">σ<sub>t</sub></span>.</li>
          </ul>
        </div>
      </section>

      <!-- PART 1 -->
      <section id="part1">
        <h2>PART 1 — Problem Analysis (No Solving Yet) <span class="tag">translate & plan</span></h2>

        <p>
          <strong>Restatement:</strong> We have a <em>multimode step-index</em> optical fiber with numerical aperture <span class="kbd">NA = 0.1</span>.
          At wavelength <span class="kbd">λ = 0.87 μm</span>, it supports <span class="kbd">M = 5000</span> guided modes. Find the core radius <span class="kbd">a</span>.
          Then, using <span class="kbd">n<sub>1</sub> = 1.445</span>, <span class="kbd">N<sub>1</sub> = 1.456</span>, and treating <span class="kbd">Δ</span> as wavelength-independent,
          compute the modal-dispersion response time <span class="kbd">σ<sub>t</sub></span> for a <span class="kbd">L = 2 km</span> fiber.
        </p>

        <div class="grid2">
          <div class="card">
            <h3>Given</h3>
            <ul>
              <li><span class="kbd">NA = 0.1</span></li>
              <li><span class="kbd">M = 5000</span></li>
              <li><span class="kbd">λ = 0.87 μm</span></li>
              <li><span class="kbd">n<sub>1</sub> = 1.445</span></li>
              <li><span class="kbd">N<sub>1</sub> = 1.456</span></li>
              <li><span class="kbd">L = 2 km</span></li>
            </ul>
          </div>
          <div class="card">
            <h3>Unknowns</h3>
            <ul>
              <li>Core radius: <span class="kbd">a</span></li>
              <li>Relative index difference: <span class="kbd">Δ</span> (inferred from NA and <span class="kbd">n<sub>1</sub></span>)</li>
              <li>Modal-dispersion response time: <span class="kbd">σ<sub>t</sub></span></li>
            </ul>
          </div>
        </div>

        <div class="callout" style="margin-top:12px">
          <strong>Relevant physics (and why)</strong>
          <ul class="muted" style="margin:0 0 0 18px">
            <li><strong>Waveguide modal density:</strong> Step-index fibers have a mode count controlled primarily by the normalized frequency <span class="kbd">V</span>.</li>
            <li><strong>Weak-guidance relations:</strong> The given NA and <span class="kbd">n<sub>1</sub></span> let us estimate <span class="kbd">Δ</span>.</li>
            <li><strong>Modal dispersion:</strong> In a step-index profile, different modes travel different path lengths → pulse spreading scales with <span class="kbd">Δ</span> and <span class="kbd">L</span>.</li>
          </ul>
        </div>

        <div class="card" style="margin-top:12px">
          <h3>Assumptions (explicit)</h3>
          <ul>
            <li><strong>Step-index profile:</strong> uniform core index <span class="kbd">n<sub>1</sub></span>, uniform cladding index <span class="kbd">n<sub>2</sub></span>.</li>
            <li><strong>Weak guidance:</strong> <span class="kbd">Δ ≪ 1</span> so <span class="kbd">NA ≈ n<sub>1</sub>√(2Δ)</span> and <span class="kbd">M ≈ V²/2</span>.</li>
            <li><strong>Many modes:</strong> <span class="kbd">M = 5000</span> implies very large <span class="kbd">V</span>, so the approximation is well justified.</li>
            <li><strong>Modal impulse response:</strong> approximated as roughly rectangular in time → RMS width <span class="kbd">σ<sub>t</sub> ≈ ΔT/√12</span>.</li>
            <li><strong>Group-delay scaling:</strong> timing uses group index <span class="kbd">N<sub>1</sub></span> (given).</li>
          </ul>
        </div>

        <div class="grid2" style="margin-top:12px">
          <div class="card">
            <h3>Possible approaches</h3>
            <ol class="muted" style="margin:0 0 0 18px">
              <li><strong>Mode-count method (V-parameter):</strong> use <span class="kbd">M ≈ V²/2</span> and <span class="kbd">V = (2πa/λ)NA</span>. Fast and standard for multimode step-index.</li>
              <li><strong>Ray/acceptance-angle method:</strong> connect maximum internal angle to TIR and derive relationships, then estimate mode density. More steps, less direct.</li>
              <li><strong>Full vector mode solver:</strong> compute LP modes numerically. Accurate but overkill for given large-M data.</li>
            </ol>
          </div>
          <div class="card">
            <h3>Chosen approach (best here)</h3>
            <p class="muted" style="margin:0">
              We choose the <strong>mode-count (V-parameter) approach</strong> because the problem directly gives <span class="kbd">M</span> and <span class="kbd">NA</span>,
              and <span class="kbd">M = 5000</span> guarantees the large-<span class="kbd">V</span> approximation is excellent.
              Then we estimate <span class="kbd">Δ</span> from NA and compute modal spread using a standard step-index delay model.
            </p>
          </div>
        </div>
      </section>

      <!-- PART 2 -->
      <section id="part2">
        <h2>PART 2 — Strategy & Tips (Roadmap Only) <span class="tag">no heavy algebra</span></h2>

        <ol>
          <li>
            <strong>Convert units.</strong><br/>
            <span class="muted">Goal:</span> use SI for clean dimensional checks.<br/>
            <span class="muted">Tool:</span> <span class="kbd">λ</span> in meters; <span class="kbd">L</span> in meters.<br/>
            <span class="muted">Physical meaning:</span> prevents hidden factors of 10.
          </li>
          <li>
            <strong>Find V from the mode count.</strong><br/>
            <span class="muted">Goal:</span> infer how “multimode” the fiber is.<br/>
            <span class="muted">Equation:</span> <span class="kbd">M ≈ V²/2</span> → <span class="kbd">V ≈ √(2M)</span>.<br/>
            <span class="muted">Meaning:</span> sets the transverse confinement scale.
          </li>
          <li>
            <strong>Solve for core radius a.</strong><br/>
            <span class="muted">Equation:</span> <span class="kbd">V = (2πa/λ) NA</span> → <span class="kbd">a = (λV)/(2π NA)</span>.<br/>
            <span class="muted">Meaning:</span> larger core or NA increases the number of modes.
          </li>
          <li>
            <strong>Estimate Δ from NA and n<sub>1</sub>.</strong><br/>
            <span class="muted">Equation:</span> <span class="kbd">NA ≈ n1 √(2Δ)</span> → <span class="kbd">Δ ≈ (NA/n1)²/2</span>.<br/>
            <span class="muted">Meaning:</span> Δ quantifies index contrast; it also sets modal dispersion.
          </li>
          <li>
            <strong>Compute total intermodal delay spread ΔT.</strong><br/>
            <span class="muted">Equation:</span> <span class="kbd">ΔT ≈ (N1 Δ L)/c</span> (step-index scaling).<br/>
            <span class="muted">Meaning:</span> proportional to length and index contrast.
          </li>
          <li>
            <strong>Convert ΔT into a response time σ<sub>t</sub>.</strong><br/>
            <span class="muted">Model:</span> rectangular impulse response → RMS width <span class="kbd">σt ≈ ΔT/√12</span>.<br/>
            <span class="muted">Meaning:</span> typical pulse broadening metric for bandwidth estimates.
          </li>
          <li>
            <strong>Sanity checks.</strong><br/>
            <span class="muted">Check:</span> units, magnitude (μm-scale core, ns-scale spreading over km).<br/>
            <span class="muted">Pitfall:</span> confusing μm with mm or using <span class="kbd">n1</span> instead of <span class="kbd">N1</span> for group delay.
          </li>
        </ol>

        <div class="callout" style="margin-top:12px">
          <strong>Quick tips</strong>
          <ul class="muted" style="margin:0 0 0 18px">
            <li>If <span class="kbd">M</span> is huge, then <span class="kbd">V</span> will be huge too—expect a large core radius or a sizable NA.</li>
            <li>For silica, <span class="kbd">Δ ~ 10^{-3}</span> makes sense; if you get <span class="kbd">Δ ~ 0.1</span>, something went wrong.</li>
            <li>RMS width for a rectangle is <span class="kbd">width/√12</span>; it’s an easy place to slip a factor of 2.</li>
          </ul>
        </div>
      </section>

      <!-- PART 3 -->
      <section id="part3">
        <h2>PART 3 — Full Solution (Detailed + Teaching) <span class="tag">step-by-step</span></h2>

        <p>
          <strong>Physical intuition first:</strong> Supporting <span class="kbd">M = 5000</span> guided modes at <span class="kbd">λ = 0.87 μm</span> requires a
          large normalized frequency <span class="kbd">V</span>. Since <span class="kbd">V ∝ a·NA/λ</span>, we expect a relatively <em>large core radius</em>,
          likely on the order of <span class="kbd">10^2 μm</span>. For modal dispersion, a step-index profile is the “worst case” compared to graded-index:
          higher-angle modes take longer, giving a pulse spread that grows linearly with <span class="kbd">L</span>.
        </p>

        <div class="card">
          <h3>Step 1: Unit conversion</h3>
          <div class="equation" id="eq_units">λ = 0.87 μm = 0.87 × 10^-6 m ;   L = 2 km = 2000 m</div>
          <div class="eqrow" style="margin-top:10px">
            <button class="copybtn" data-copy="#eq_units">Copy</button>
          </div>
          <p class="muted">Why: putting everything in SI lets every intermediate quantity (especially time) come out directly in seconds.</p>
        </div>

        <div class="card" style="margin-top:12px">
          <h3>Step 2: Mode count ↔ normalized frequency</h3>
          <p class="muted" style="margin-top:0">
            For a step-index fiber in the weak-guidance, large-<span class="kbd">V</span> regime, the approximate total number of guided modes is:
          </p>
          <div class="eqrow">
            <div class="equation" style="flex:1" id="eq_MV">M ≈ V^2 / 2  ⇒  V ≈ √(2M)</div>
            <button class="copybtn" data-copy="#eq_MV">Copy</button>
          </div>

          <p>
            Insert <span class="kbd">M = 5000</span>:
          </p>
          <div class="equation" id="eq_Vnum">V ≈ √(2 × 5000) = √10000 = 100</div>
          <div class="eqrow" style="margin-top:10px">
            <button class="copybtn" data-copy="#eq_Vnum">Copy</button>
          </div>

          <p class="muted">
            Interpretation: <span class="kbd">V = 100</span> is extremely large (single-mode cutoff is near <span class="kbd">V ≈ 2.405</span>), so we are safely in the multimode regime.
          </p>
        </div>

        <div class="card" style="margin-top:12px">
          <h3>Step 3: Solve for the core radius a using V = (2πa/λ) NA</h3>
          <p class="muted" style="margin-top:0">
            The normalized frequency is defined by:
          </p>
          <div class="eqrow">
            <div class="equation" style="flex:1" id="eq_Vdef">V = (2π a / λ) NA</div>
            <button class="copybtn" data-copy="#eq_Vdef">Copy</button>
          </div>

          <p>Rearrange to solve for <span class="kbd">a</span>:</p>
          <div class="eqrow">
            <div class="equation" style="flex:1" id="eq_aform">a = (λ V) / (2π NA)</div>
            <button class="copybtn" data-copy="#eq_aform">Copy</button>
          </div>

          <p>Now substitute <span class="kbd">λ = 0.87×10^-6 m</span>, <span class="kbd">V = 100</span>, <span class="kbd">NA = 0.1</span>:</p>
          <div class="equation" id="eq_anum">
            a = (0.87×10^-6 × 100) / (2π × 0.1)
              = (87×10^-6) / (0.628318...)
              ≈ 1.385×10^-4 m
              = 138.5 μm
          </div>
          <div class="eqrow" style="margin-top:10px">
            <button class="copybtn" data-copy="#eq_anum">Copy</button>
          </div>

          <div class="callout" style="margin-top:12px">
            <strong>Core radius result</strong>
            <div class="equation" id="eq_aFinal">a ≈ 1.385×10^-4 m = 138.5 μm</div>
            <div class="eqrow" style="margin-top:10px">
              <button class="copybtn" data-copy-text="a ≈ 1.385×10^-4 m = 138.5 μm">Copy</button>
            </div>
          </div>

          <p class="muted">
            Sanity check: 138 μm is larger than common telecom single-mode cores (~4–5 μm radius), consistent with thousands of modes.
          </p>
        </div>

        <div class="card" style="margin-top:12px">
          <h3>Step 4: Estimate the relative index difference Δ from NA</h3>
          <p class="muted" style="margin-top:0">
            Under weak guidance (<span class="kbd">Δ ≪ 1</span>), the numerical aperture relates to Δ by:
          </p>
          <div class="eqrow">
            <div class="equation" style="flex:1" id="eq_NA_D">NA ≈ n1 √(2Δ)  ⇒  Δ ≈ (NA/n1)^2 / 2</div>
            <button class="copybtn" data-copy="#eq_NA_D">Copy</button>
          </div>

          <p>Insert <span class="kbd">NA = 0.1</span>, <span class="kbd">n1 = 1.445</span>:</p>
          <div class="equation" id="eq_Dnum">
            Δ ≈ (0.1/1.445)^2 / 2
              ≈ (0.0692...)^2 / 2
              ≈ 0.00479 / 2
              ≈ 2.39×10^-3
          </div>
          <div class="eqrow" style="margin-top:10px">
            <button class="copybtn" data-copy="#eq_Dnum">Copy</button>
          </div>

          <p class="muted">
            Sanity check: <span class="kbd">Δ ≈ 2.4×10^-3</span> is a realistic silica-fiber index contrast.
          </p>
        </div>

        <div class="card" style="margin-top:12px">
          <h3>Step 5: Modal dispersion in a step-index fiber — ΔT and σ<sub>t</sub></h3>

          <p class="muted" style="margin-top:0">
            In a step-index fiber, the fastest “mode” is close to the axial ray/mode (shortest path).
            The slowest guided modes correspond to rays near the maximum guided angle, taking a longer zig-zag path.
            The resulting <em>total intermodal delay spread</em> scales approximately as:
          </p>

          <div class="eqrow">
            <div class="equation" style="flex:1" id="eq_DT">ΔT ≈ (N1 Δ L) / c</div>
            <button class="copybtn" data-copy="#eq_DT">Copy</button>
          </div>

          <p class="muted">
            Here we use <span class="kbd">N1</span> (group index) because pulse arrival times follow group velocity.
          </p>

          <p>Compute <span class="kbd">ΔT</span> with <span class="kbd">N1 = 1.456</span>, <span class="kbd">Δ = 2.39×10^-3</span>, <span class="kbd">L = 2000 m</span>, <span class="kbd">c = 2.998×10^8 m/s</span>:</p>
          <div class="equation" id="eq_DTnum">
            ΔT ≈ (1.456 × 2.39×10^-3 × 2000) / (2.998×10^8)
               ≈ 2.33×10^-8 s
               ≈ 23.3 ns
          </div>
          <div class="eqrow" style="margin-top:10px">
            <button class="copybtn" data-copy="#eq_DTnum">Copy</button>
          </div>

          <p class="muted">
            Many texts define a “response time” as an RMS width. If the impulse response is approximately rectangular over a width <span class="kbd">ΔT</span>,
            then the RMS width is:
          </p>

          <div class="eqrow">
            <div class="equation" style="flex:1" id="eq_sig">σt ≈ ΔT / √12</div>
            <button class="copybtn" data-copy="#eq_sig">Copy</button>
          </div>

          <p>So:</p>
          <div class="equation" id="eq_signum">
            σt ≈ (23.3 ns)/√12 ≈ 6.71 ns
          </div>
          <div class="eqrow" style="margin-top:10px">
            <button class="copybtn" data-copy="#eq_signum">Copy</button>
          </div>

          <div class="callout" style="margin-top:12px">
            <strong>Modal-dispersion response time (2 km)</strong>
            <div class="equation" id="eq_sigFinal">σt ≈ 6.71 ns  (with ΔT ≈ 23.3 ns)</div>
            <div class="eqrow" style="margin-top:10px">
              <button class="copybtn" data-copy-text="σ_t ≈ 6.71 ns (ΔT ≈ 23.3 ns, L = 2 km)">Copy</button>
            </div>
          </div>

          <div class="card" style="margin-top:12px">
            <h3>Sanity checks</h3>
            <ul>
              <li><strong>Units:</strong> <span class="kbd">(dimensionless × dimensionless × m)/(m/s) = s</span> ✓</li>
              <li><strong>Limiting cases:</strong> if <span class="kbd">Δ → 0</span> or <span class="kbd">L → 0</span>, then <span class="kbd">ΔT → 0</span> and <span class="kbd">σt → 0</span> ✓</li>
              <li><strong>Magnitude:</strong> tens of ns total spread over a few km for a step-index multimode fiber is plausible ✓</li>
              <li><strong>Interpretation:</strong> a short input pulse will broaden by a few ns RMS after 2 km due purely to different modal path lengths.</li>
            </ul>
          </div>

          <p class="muted">
            Connection to the diagram/plots: the diagram shows rays at different angles; the plots quantify how <span class="kbd">M</span> depends on <span class="kbd">a</span>
            and how <span class="kbd">σt</span> grows with <span class="kbd">L</span> and <span class="kbd">Δ</span> (hence with NA).
          </p>
        </div>
      </section>

      <!-- Visualizations (embedded within article for continuity) -->
      <section aria-label="Interactive visualizations">
        <h2>Interactive Visualizations <span class="tag">canvas + live controls</span></h2>

        <figure>
          <canvas id="diagram" aria-label="Fiber geometry diagram"></canvas>
          <figcaption>
            <strong>Diagram:</strong> Step-index fiber cross-section and representative guided rays. The core radius is <span class="kbd">a</span>,
            with core index <span class="kbd">n1</span> and cladding index <span class="kbd">n2</span>. Larger internal angles imply longer paths → larger delay.
          </figcaption>
        </figure>

        <div class="grid2" style="margin-top:12px">
          <figure>
            <canvas id="plot1" aria-label="Modes versus core radius plot"></canvas>
            <figcaption>
              <strong>Main plot:</strong> Mode count <span class="kbd">M(a) ≈ V(a)^2/2</span> versus core radius <span class="kbd">a</span>. The highlighted point is the radius that yields the target <span class="kbd">M = 5000</span>.
            </figcaption>
          </figure>
          <figure>
            <canvas id="plot2" aria-label="Modal response time versus length plot"></canvas>
            <figcaption>
              <strong>Secondary plot:</strong> RMS response time <span class="kbd">σt(L) ≈ (N1 Δ L)/(c√12)</span> versus length. The marker indicates the current <span class="kbd">L</span> (default 2 km).
            </figcaption>
          </figure>
        </div>

        <div class="controls" aria-label="Interactive controls">
          <div class="control">
            <label>
              <span>Numerical aperture <span class="kbd">NA</span></span>
              <span class="value" id="naVal">0.100</span>
            </label>
            <input id="na" type="range" min="0.05" max="0.30" step="0.001" value="0.10" />
            <div class="muted" style="font-size:12px;margin-top:8px">
              Changes <span class="kbd">Δ</span> and thus modal dispersion; also changes the <span class="kbd">a</span> required to keep <span class="kbd">M</span> fixed.
            </div>
          </div>

          <div class="control">
            <label>
              <span>Fiber length <span class="kbd">L</span> (km)</span>
              <span class="value" id="lVal">2.00</span>
            </label>
            <input id="len" type="range" min="0.1" max="5.0" step="0.01" value="2.0" />
            <div class="muted" style="font-size:12px;margin-top:8px">
              Spreading grows roughly linearly with <span class="kbd">L</span> in step-index fibers.
            </div>
          </div>

          <div class="control">
            <label>
              <span>Target modes <span class="kbd">M</span></span>
              <span class="value" id="mVal">5000</span>
            </label>
            <input id="modes" type="range" min="200" max="12000" step="50" value="5000" />
            <div class="muted" style="font-size:12px;margin-top:8px">
              Shows how required core radius scales as <span class="kbd">a ∝ √M</span> (for fixed <span class="kbd">NA</span>, <span class="kbd">λ</span>).
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <h3>Live computed values (matching the symbols used above)</h3>
          <div class="grid2">
            <div class="equation" id="live1">a = — ; V = — ; Δ = —</div>
            <div class="equation" id="live2">ΔT = — ; σt = —</div>
          </div>
        </div>
      </section>

      <!-- PART 4 -->
      <section id="part4">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result) <span class="tag">what controls what</span></h2>

        <div class="card">
          <h3>Re-interpreting the final formulas</h3>
          <ul>
            <li><strong>Mode count:</strong> <span class="kbd">M ≈ V²/2</span> says mode capacity grows with the <em>area</em> in “V-space.” Since <span class="kbd">V ∝ a·NA/λ</span>, we get:
              <span class="kbd">M ∝ (a·NA/λ)²</span>.</li>
            <li><strong>Core radius scaling:</strong> <span class="kbd">a = (λ/(2π NA)) √(2M)</span> implies:
              increasing NA reduces the needed radius to support the same M; increasing wavelength increases the needed radius.</li>
            <li><strong>Modal spreading:</strong> <span class="kbd">σt ∝ Δ·L</span> and <span class="kbd">Δ ∝ NA²</span> (for fixed <span class="kbd">n1</span>), so roughly:
              <span class="kbd">σt ∝ NA² · L</span>.</li>
          </ul>
        </div>

        <div class="grid2" style="margin-top:12px">
          <div class="callout">
            <strong>Parameter effects (connect to the plots)</strong>
            <ul class="muted" style="margin:0 0 0 18px">
              <li>Increase <span class="kbd">NA</span>: <span class="kbd">a</span> needed for fixed <span class="kbd">M</span> decreases, but <span class="kbd">Δ</span> increases → <span class="kbd">σt</span> increases.</li>
              <li>Increase <span class="kbd">M</span>: required <span class="kbd">a</span> increases like <span class="kbd">√M</span>.</li>
              <li>Increase <span class="kbd">L</span>: modal spread increases linearly.</li>
            </ul>
          </div>

          <div class="card">
            <h3>Alternative derivation idea (brief)</h3>
            <p class="muted" style="margin:0">
              You can derive the intermodal delay by a <strong>ray</strong> argument: the travel time for a meridional ray at internal angle <span class="kbd">θ</span> is
              <span class="kbd">T(θ) = (N1 L)/(c cosθ)</span>. The maximum guided angle follows from TIR at the core–cladding boundary,
              giving <span class="kbd">cosθ_max ≈ n2/n1 ≈ 1 - Δ</span>, and hence <span class="kbd">ΔT ≈ (N1 Δ L)/c</span> for small <span class="kbd">Δ</span>.
            </p>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <h3>Concept checks (quick self-test)</h3>
          <ul>
            <li><strong>Q:</strong> If <span class="kbd">λ</span> increases while <span class="kbd">a</span> and <span class="kbd">NA</span> are fixed, what happens to <span class="kbd">M</span>?<br/>
              <strong>A:</strong> <span class="kbd">V ∝ 1/λ</span> decreases, so <span class="kbd">M ∝ V²</span> decreases.</li>
            <li><strong>Q:</strong> Why is step-index modal dispersion larger than graded-index?<br/>
              <strong>A:</strong> Step-index has equal material speed but different path lengths; graded-index can compensate by making high-angle rays travel faster through lower index regions.</li>
            <li><strong>Q:</strong> If <span class="kbd">NA</span> doubles (keeping <span class="kbd">n1</span> fixed), how does <span class="kbd">Δ</span> change?<br/>
              <strong>A:</strong> <span class="kbd">Δ ∝ NA²</span>, so it increases by ~4×.</li>
            <li><strong>Q:</strong> Why use <span class="kbd">N1</span> for timing?<br/>
              <strong>A:</strong> pulse envelopes propagate at group velocity <span class="kbd">v_g = c/N1</span>, not phase velocity.</li>
          </ul>
        </div>
      </section>

      <!-- PART 5 -->
      <section id="part5">
        <h2>PART 5 — Visualization Guide (How to Read the Plots) <span class="tag">make sense of the canvases</span></h2>

        <div class="grid2">
          <div class="card">
            <h3>Diagram canvas</h3>
            <ul class="muted">
              <li>Shows a core (radius <span class="kbd">a</span>) and cladding.</li>
              <li>Illustrates two rays/modes: a near-axial path (fast) and a high-angle zig-zag (slow).</li>
              <li>Labels update to reflect the current <span class="kbd">NA</span>, computed <span class="kbd">Δ</span>, and computed <span class="kbd">a</span> (for the selected <span class="kbd">M</span>).</li>
            </ul>
          </div>

          <div class="card">
            <h3>Main plot: M vs a</h3>
            <ul class="muted">
              <li>Curve uses <span class="kbd">M(a) = ½[(2πa NA)/λ]²</span> with <span class="kbd">λ</span> fixed at 0.87 μm.</li>
              <li>A horizontal guide at target <span class="kbd">M</span> and a highlighted point show the solved radius.</li>
              <li>As you change <span class="kbd">NA</span>, the curve steepness changes (because <span class="kbd">M ∝ NA²</span>).</li>
            </ul>
          </div>
        </div>

        <div class="grid2" style="margin-top:12px">
          <div class="card">
            <h3>Secondary plot: σt vs L</h3>
            <ul class="muted">
              <li>Line uses <span class="kbd">σt(L) = (N1 Δ L)/(c√12)</span> with current <span class="kbd">Δ</span> inferred from <span class="kbd">NA</span>.</li>
              <li>Marker shows your selected length <span class="kbd">L</span>; default is 2 km (the problem length).</li>
              <li>Increase <span class="kbd">NA</span> → larger <span class="kbd">Δ</span> → steeper slope (more dispersion per km).</li>
            </ul>
          </div>

          <div class="callout">
            <strong>Interactive controls (what should change and why)</strong>
            <ul class="muted" style="margin:0 0 0 18px">
              <li><strong>NA slider:</strong> updates <span class="kbd">Δ</span> (≈ NA² dependence), changes required <span class="kbd">a</span> for fixed <span class="kbd">M</span>, and changes the dispersion curve slope.</li>
              <li><strong>L slider:</strong> moves the marker along the <span class="kbd">σt(L)</span> line and updates the numeric <span class="kbd">ΔT</span>, <span class="kbd">σt</span>.</li>
              <li><strong>M slider:</strong> shifts the target mode count, moving the solved <span class="kbd">a</span> point (since <span class="kbd">a ∝ √M</span>).</li>
            </ul>
          </div>
        </div>
      </section>
    </article>
  </main>

  <footer>
    <div class="muted">
      Notes: This solution uses standard weak-guidance, large-<span class="kbd">V</span> approximations for step-index fibers.
      The “response time” <span class="kbd">σt</span> is treated as the RMS width of an approximately rectangular intermodal impulse response (width <span class="kbd">ΔT</span>).
    </div>
  </footer>

  <script>
    // ---------- Helpers ----------
    const $ = (sel) => document.querySelector(sel);

    function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

    function formatSI(x, unit){
      // compact formatter for typical magnitudes in this page
      if (!isFinite(x)) return `—`;
      const abs = Math.abs(x);
      if (unit === "m"){
        if (abs >= 1e-3) return `${x.toFixed(4)} m`;
        if (abs >= 1e-6) return `${(x*1e6).toFixed(2)} μm`;
        return `${(x*1e9).toFixed(2)} nm`;
      }
      if (unit === "s"){
        if (abs >= 1e-3) return `${(x*1e3).toFixed(3)} ms`;
        if (abs >= 1e-6) return `${(x*1e6).toFixed(3)} μs`;
        if (abs >= 1e-9) return `${(x*1e9).toFixed(3)} ns`;
        return `${(x*1e12).toFixed(3)} ps`;
      }
      return `${x.toFixed(6)} ${unit}`;
    }

    function setCanvasHiDPI(canvas){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect.width * dpr));
      const h = Math.max(2, Math.floor(rect.height * dpr));
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {ctx, dpr, cssW: rect.width, cssH: rect.height};
    }

    function drawGrid(ctx, x0, y0, w, h, xTicks, yTicks){
      ctx.save();
      ctx.globalAlpha = 0.9;
      // grid
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;
      for (let i=0;i<=xTicks;i++){
        const x = x0 + w*(i/xTicks);
        ctx.beginPath(); ctx.moveTo(x, y0); ctx.lineTo(x, y0+h); ctx.stroke();
      }
      for (let j=0;j<=yTicks;j++){
        const y = y0 + h*(j/yTicks);
        ctx.beginPath(); ctx.moveTo(x0, y); ctx.lineTo(x0+w, y); ctx.stroke();
      }
      // frame
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.strokeRect(x0, y0, w, h);
      ctx.restore();
    }

    function drawAxesLabels(ctx, title, xLabel, yLabel, x0, y0, w, h){
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.90)";
      ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(title, x0, y0 - 10);
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(xLabel, x0 + w - ctx.measureText(xLabel).width, y0 + h + 28);
      ctx.save();
      ctx.translate(x0 - 34, y0 + 4);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();
      ctx.restore();
    }

    function drawTicks(ctx, x0, y0, w, h, xTicks, yTicks, xMin, xMax, yMin, yMax, fmtX, fmtY){
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.62)";
      ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      // x ticks
      for (let i=0;i<=xTicks;i++){
        const t = i/xTicks;
        const x = x0 + w*t;
        const val = xMin + (xMax-xMin)*t;
        const lab = fmtX(val, i);
        ctx.fillText(lab, x - ctx.measureText(lab).width/2, y0 + h + 16);
        ctx.strokeStyle = "rgba(255,255,255,0.25)";
        ctx.beginPath(); ctx.moveTo(x, y0+h); ctx.lineTo(x, y0+h+5); ctx.stroke();
      }
      // y ticks
      for (let j=0;j<=yTicks;j++){
        const t = 1 - j/yTicks;
        const y = y0 + h*(j/yTicks);
        const val = yMin + (yMax-yMin)*t;
        const lab = fmtY(val, j);
        ctx.fillText(lab, x0 - 8 - ctx.measureText(lab).width, y + 4);
        ctx.strokeStyle = "rgba(255,255,255,0.25)";
        ctx.beginPath(); ctx.moveTo(x0-5, y); ctx.lineTo(x0, y); ctx.stroke();
      }
      ctx.restore();
    }

    function mapX(x, xMin, xMax, x0, w){
      return x0 + (x - xMin) / (xMax - xMin) * w;
    }
    function mapY(y, yMin, yMax, y0, h){
      return y0 + (1 - (y - yMin) / (yMax - yMin)) * h;
    }

    // ---------- Physics model ----------
    const constants = {
      c: 299792458,        // m/s
      lambda: 0.87e-6,     // m
      n1: 1.445,
      N1: 1.456
    };

    function computeFromInputs(NA, M, L_km){
      const lambda = constants.lambda;
      const n1 = constants.n1;
      const N1 = constants.N1;
      const c = constants.c;

      // Large-V step-index multimode approximation:
      const V = Math.sqrt(2*M);

      // Core radius:
      const a = (lambda * V) / (2*Math.PI*NA);

      // Weak guidance relation for delta:
      const Delta = (NA/n1)*(NA/n1)/2;

      // Total delay spread and RMS response time:
      const L = L_km*1000;
      const DeltaT = (N1 * Delta * L) / c;
      const sigmaT = DeltaT / Math.sqrt(12);

      // For diagram: estimate n2 from Delta definition (weak guidance): n2 ≈ n1(1-Δ)
      const n2 = n1*(1-Delta);

      return {V, a, Delta, DeltaT, sigmaT, n2, L};
    }

    // ---------- Drawing: Diagram ----------
    function drawDiagram(canvas, model, NA){
      const {ctx, cssW:w, cssH:h} = setCanvasHiDPI(canvas);
      ctx.clearRect(0,0,w,h);

      // Background vignette
      const grad = ctx.createRadialGradient(w*0.25,h*0.25,10,w*0.5,h*0.55,Math.max(w,h));
      grad.addColorStop(0,"rgba(125,211,252,0.10)");
      grad.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,w,h);

      // Layout
      const pad = 18;
      const cx = w*0.32;
      const cy = h*0.55;
      const R = Math.min(w,h)*0.23;

      // Draw cladding region
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,255,255,0.20)";
      ctx.fillStyle = "rgba(255,255,255,0.05)";
      ctx.beginPath();
      ctx.arc(cx, cy, R*1.45, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // Draw core region
      ctx.strokeStyle = "rgba(125,211,252,0.70)";
      ctx.fillStyle = "rgba(125,211,252,0.10)";
      ctx.beginPath();
      ctx.arc(cx, cy, R, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // Core radius arrow
      ctx.strokeStyle = "rgba(255,255,255,0.70)";
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + R, cy);
      ctx.stroke();

      // arrow head
      ctx.beginPath();
      ctx.moveTo(cx + R, cy);
      ctx.lineTo(cx + R - 8, cy - 5);
      ctx.lineTo(cx + R - 8, cy + 5);
      ctx.closePath();
      ctx.fill();

      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillText("a", cx + R/2 - 4, cy - 10);

      // Rays (meridional paths)
      function ray(angleDeg, color){
        const ang = angleDeg*Math.PI/180;
        const x0 = cx - R*0.96, y0 = cy;
        const steps = 6;
        const seg = (R*1.9)/steps;
        let x=x0, y=y0;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x,y);
        let sgn = 1;
        for (let i=0;i<steps;i++){
          x += seg;
          y += sgn*seg*Math.tan(ang)*0.35;
          // reflect off core boundary (simple clamp)
          const dy = y - cy;
          const maxDy = R*0.85;
          if (Math.abs(dy) > maxDy){
            y = cy + Math.sign(dy)*maxDy;
            sgn *= -1;
          }
          ctx.lineTo(x,y);
        }
        ctx.stroke();
      }

      ray(6, "rgba(134,239,172,0.85)");    // near axial (fast)
      ray(18, "rgba(251,191,36,0.85)");    // high angle (slow)

      // Labels & info block on right
      ctx.restore();
      const infoX = w*0.55;
      const infoY = h*0.18;
      const boxW = w*0.40 - pad;
      const boxH = h*0.70;

      // info box
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.lineWidth = 1;
      roundRect(ctx, infoX, infoY, boxW, boxH, 14);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,0.90)";
      ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Step-index fiber (conceptual)", infoX+12, infoY+22);

      ctx.fillStyle = "rgba(255,255,255,0.72)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      const lines = [
        `λ = ${(constants.lambda*1e6).toFixed(2)} μm`,
        `NA = ${NA.toFixed(3)}`,
        `n1 = ${constants.n1.toFixed(3)}   n2 ≈ ${model.n2.toFixed(3)}`,
        `Δ ≈ ${model.Delta.toExponential(3)}`,
        `V = ${model.V.toFixed(2)}   M = ${Math.round(parseFloat($("#modes").value))}`,
        `a ≈ ${(model.a*1e6).toFixed(1)} μm`
      ];
      let yy = infoY+46;
      for (const s of lines){
        ctx.fillText(s, infoX+12, yy);
        yy += 18;
      }

      // Legend swatches
      yy += 10;
      ctx.fillStyle = "rgba(134,239,172,0.90)";
      ctx.fillRect(infoX+12, yy-10, 18, 3);
      ctx.fillStyle = "rgba(255,255,255,0.72)";
      ctx.fillText("fast (near-axial) mode", infoX+36, yy-6);

      yy += 18;
      ctx.fillStyle = "rgba(251,191,36,0.90)";
      ctx.fillRect(infoX+12, yy-10, 18, 3);
      ctx.fillStyle = "rgba(255,255,255,0.72)";
      ctx.fillText("slow (high-angle) mode", infoX+36, yy-6);

      ctx.restore();

      // Title
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Diagram — core/cladding and example ray paths", 18, 22);
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    // ---------- Drawing: Plot 1 (M vs a) ----------
    function drawPlot1(canvas, NA, Mtarget){
      const {ctx, cssW:w, cssH:h} = setCanvasHiDPI(canvas);
      ctx.clearRect(0,0,w,h);

      const padL = 62, padR = 18, padT = 42, padB = 48;
      const x0 = padL, y0 = padT, pw = w-padL-padR, ph = h-padT-padB;

      // Determine x-range: show up to aMax where M(aMax) hits ~1.2*Mtarget (with a minimum range)
      const lambda = constants.lambda;
      const aSolve = (lambda * Math.sqrt(2*Mtarget)) / (2*Math.PI*NA);
      const aMax = Math.max(aSolve*1.5, 220e-6);
      const aMin = 0;

      // y-range based on M(aMax)
      const Mof = (a) => 0.5 * Math.pow((2*Math.PI*a*NA)/lambda, 2);
      const yMax = Math.max(Mof(aMax)*1.05, Mtarget*1.2);
      const yMin = 0;

      // Grid and labels
      drawGrid(ctx, x0, y0, pw, ph, 6, 6);
      drawAxesLabels(ctx, "Main Plot — Mode count vs core radius", "core radius a (μm)", "modes M (count)", x0, y0, pw, ph);

      drawTicks(
        ctx, x0, y0, pw, ph, 6, 6,
        aMin, aMax, yMin, yMax,
        (val)=> (val*1e6).toFixed(0),
        (val)=> (val>=1000 ? (val/1000).toFixed(1)+"k" : val.toFixed(0))
      );

      // Curve
      ctx.save();
      ctx.strokeStyle = "rgba(125,211,252,0.90)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      const N = 240;
      for (let i=0;i<=N;i++){
        const a = aMin + (aMax-aMin)*(i/N);
        const M = Mof(a);
        const X = mapX(a, aMin, aMax, x0, pw);
        const Y = mapY(M, yMin, yMax, y0, ph);
        if (i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
      }
      ctx.stroke();
      ctx.restore();

      // Target horizontal line
      ctx.save();
      ctx.strokeStyle = "rgba(167,139,250,0.70)";
      ctx.setLineDash([6,6]);
      ctx.lineWidth = 2;
      const Yt = mapY(Mtarget, yMin, yMax, y0, ph);
      ctx.beginPath(); ctx.moveTo(x0, Yt); ctx.lineTo(x0+pw, Yt); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(167,139,250,0.85)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillText(`target M = ${Math.round(Mtarget)}`, x0+10, clamp(Yt-8, y0+14, y0+ph-6));
      ctx.restore();

      // Solution point
      ctx.save();
      const Xs = mapX(aSolve, aMin, aMax, x0, pw);
      const Ys = mapY(Mtarget, yMin, yMax, y0, ph);
      ctx.fillStyle = "rgba(134,239,172,0.95)";
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(Xs, Ys, 6, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // Annotate
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      const label = `a ≈ ${(aSolve*1e6).toFixed(1)} μm`;
      ctx.fillText(label, clamp(Xs+10, x0+10, x0+pw-ctx.measureText(label).width-6), clamp(Ys-10, y0+16, y0+ph-6));
      ctx.restore();

      // Legend
      ctx.save();
      const lx = x0+12, ly = y0+12;
      ctx.fillStyle = "rgba(0,0,0,0.22)";
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      roundRect(ctx, lx, ly, 220, 50, 12);
      ctx.fill(); ctx.stroke();

      ctx.strokeStyle = "rgba(125,211,252,0.90)";
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(lx+10, ly+18); ctx.lineTo(lx+36, ly+18); ctx.stroke();
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("M(a) ≈ ½[(2πa NA)/λ]²", lx+44, ly+22);

      ctx.strokeStyle = "rgba(167,139,250,0.70)";
      ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(lx+10, ly+36); ctx.lineTo(lx+36, ly+36); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillText("target M", lx+44, ly+40);
      ctx.restore();
    }

    // ---------- Drawing: Plot 2 (sigma_t vs L) ----------
    function drawPlot2(canvas, NA, L_km, Mtarget){
      const {ctx, cssW:w, cssH:h} = setCanvasHiDPI(canvas);
      ctx.clearRect(0,0,w,h);

      const padL = 62, padR = 18, padT = 42, padB = 48;
      const x0 = padL, y0 = padT, pw = w-padL-padR, ph = h-padT-padB;

      const modelNow = computeFromInputs(NA, Mtarget, L_km);

      // x-range: 0..5 km
      const xMin = 0, xMax = 5.0;
      // y-range: based on sigma at 5 km
      const sigmaAt = (Lkm) => computeFromInputs(NA, Mtarget, Lkm).sigmaT;
      const yMin = 0;
      const yMax = Math.max(sigmaAt(5.0)*1.15, modelNow.sigmaT*1.25, 1e-9);

      drawGrid(ctx, x0, y0, pw, ph, 5, 6);
      drawAxesLabels(ctx, "Secondary Plot — Modal response time vs fiber length", "length L (km)", "σt (ns)", x0, y0, pw, ph);

      drawTicks(
        ctx, x0, y0, pw, ph, 5, 6,
        xMin, xMax, yMin, yMax,
        (val)=> val.toFixed(1),
        (val)=> (val*1e9).toFixed(1)
      );

      // line
      ctx.save();
      ctx.strokeStyle = "rgba(125,211,252,0.90)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      const N = 220;
      for (let i=0;i<=N;i++){
        const Lkm = xMin + (xMax-xMin)*(i/N);
        const sig = sigmaAt(Lkm);
        const X = mapX(Lkm, xMin, xMax, x0, pw);
        const Y = mapY(sig, yMin, yMax, y0, ph);
        if (i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
      }
      ctx.stroke();
      ctx.restore();

      // marker at current L
      const Lc = clamp(L_km, xMin, xMax);
      const sigC = sigmaAt(Lc);
      ctx.save();
      const Xc = mapX(Lc, xMin, xMax, x0, pw);
      const Yc = mapY(sigC, yMin, yMax, y0, ph);
      ctx.fillStyle = "rgba(134,239,172,0.95)";
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(Xc, Yc, 6, 0, Math.PI*2); ctx.fill(); ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      const label = `σt ≈ ${(sigC*1e9).toFixed(2)} ns`;
      ctx.fillText(label, clamp(Xc+10, x0+10, x0+pw-ctx.measureText(label).width-6), clamp(Yc-10, y0+16, y0+ph-6));
      ctx.restore();

      // info/legend
      ctx.save();
      const lx = x0+12, ly = y0+12;
      ctx.fillStyle = "rgba(0,0,0,0.22)";
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      roundRect(ctx, lx, ly, 250, 62, 12);
      ctx.fill(); ctx.stroke();

      ctx.strokeStyle = "rgba(125,211,252,0.90)";
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(lx+10, ly+20); ctx.lineTo(lx+36, ly+20); ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("σt(L) = (N1 Δ L)/(c√12)", lx+44, ly+24);

      ctx.fillStyle = "rgba(255,255,255,0.70)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillText(`Δ ≈ ${(modelNow.Delta).toExponential(2)}  (from NA)`, lx+10, ly+46);
      ctx.restore();
    }

    // ---------- Copy buttons ----------
    function setupCopyButtons(){
      document.querySelectorAll(".copybtn").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          try{
            const sel = btn.getAttribute("data-copy");
            const direct = btn.getAttribute("data-copy-text");
            let text = "";
            if (direct){
              text = direct;
            }else if (sel){
              const el = document.querySelector(sel);
              text = el ? el.textContent.trim().replace(/\s+/g," ") : "";
            }
            if (!text) return;

            await navigator.clipboard.writeText(text);
            const old = btn.textContent;
            btn.textContent = "Copied!";
            btn.style.borderColor = "rgba(134,239,172,0.45)";
            btn.style.background = "rgba(134,239,172,0.10)";
            setTimeout(()=>{
              btn.textContent = old;
              btn.style.borderColor = "rgba(255,255,255,0.14)";
              btn.style.background = "rgba(255,255,255,0.10)";
            }, 900);
          }catch(e){
            // fallback: select text in a prompt-like way
            alert("Copy failed in this browser. You can manually select and copy the text.");
          }
        });
      });
    }

    // ---------- Smooth TOC scroll ----------
    function setupSmoothScroll(){
      document.querySelectorAll('a[href^="#"]').forEach(a=>{
        a.addEventListener("click", (ev)=>{
          const id = a.getAttribute("href");
          if (!id || id === "#") return;
          const target = document.querySelector(id);
          if (!target) return;
          ev.preventDefault();
          target.scrollIntoView({behavior:"smooth", block:"start"});
          history.pushState(null, "", id);
        });
      });
    }

    // ---------- Live update ----------
    function updateAll(){
      const NA = parseFloat($("#na").value);
      const L_km = parseFloat($("#len").value);
      const M = parseFloat($("#modes").value);

      $("#naVal").textContent = NA.toFixed(3);
      $("#lVal").textContent = L_km.toFixed(2);
      $("#mVal").textContent = `${Math.round(M)}`;

      const model = computeFromInputs(NA, M, L_km);

      // Update live boxes
      $("#live1").textContent = `a = ${(model.a*1e6).toFixed(2)} μm ;  V = ${model.V.toFixed(2)} ;  Δ = ${model.Delta.toExponential(3)}`;
      $("#live2").textContent = `ΔT = ${(model.DeltaT*1e9).toFixed(2)} ns ;  σt = ${(model.sigmaT*1e9).toFixed(2)} ns`;

      // Update top "final answer" numbers only when the sliders match the problem defaults
      // (We still keep the original Quick Summary computed for the problem statement.)
      // However, we can also show the live computed in those boxes by updating them always:
      $("#ansA").textContent = `a ≈ ${(model.a*1e6).toFixed(1)} μm`;
      $("#ansSig").textContent = `σ_t ≈ ${(model.sigmaT*1e9).toFixed(2)} ns (for L = ${L_km.toFixed(2)} km)`;

      // Redraw canvases
      drawDiagram($("#diagram"), model, NA);
      drawPlot1($("#plot1"), NA, M);
      drawPlot2($("#plot2"), NA, L_km, M);
    }

    function setupResizeRedraw(){
      let t=null;
      window.addEventListener("resize", ()=>{
        clearTimeout(t);
        t = setTimeout(updateAll, 80);
      });
    }

    // ---------- Init ----------
    setupCopyButtons();
    setupSmoothScroll();

    ["na","len","modes"].forEach(id=>{
      $("#"+id).addEventListener("input", updateAll);
    });

    setupResizeRedraw();
    updateAll();
  </script>
</body>
</html>
