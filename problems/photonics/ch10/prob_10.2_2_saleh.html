<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Modal Dispersion in a Step-Index Fiber: Ray Optics vs Wave Optics (Meridional Only)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#101a33;
      --card2:#0f1730;
      --text:#e9eefc;
      --muted:#b9c3e6;
      --faint:#7f8bb8;
      --line:rgba(255,255,255,0.10);
      --line2:rgba(255,255,255,0.16);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{ box-sizing:border-box; }
    html{ scroll-behavior:smooth; }
    body{
      margin:0;
      background: radial-gradient(1200px 800px at 20% 10%, rgba(125,211,252,0.18), transparent 55%),
                  radial-gradient(1100px 700px at 80% 25%, rgba(167,139,250,0.16), transparent 60%),
                  radial-gradient(900px 700px at 50% 90%, rgba(52,211,153,0.10), transparent 60%),
                  var(--bg);
      color:var(--text);
      font-family:var(--sans);
      line-height:1.55;
    }
    header{
      padding: 28px 18px 12px;
      max-width: 1180px;
      margin:0 auto;
    }
    header .top{
      display:flex;
      gap:16px;
      align-items:flex-end;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-weight:800;
      letter-spacing:-0.02em;
      font-size: clamp(1.6rem, 2.2vw, 2.35rem);
    }
    .subtitle{
      margin:10px 0 0;
      color:var(--muted);
      max-width: 78ch;
    }

    main{
      max-width:1180px;
      margin:0 auto;
      padding: 12px 18px 70px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 18px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
    }

    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(16,26,51,0.92), rgba(16,26,51,0.74));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px 12px;
      backdrop-filter: blur(10px);
    }
    nav.toc h2{
      font-size:0.98rem;
      margin:0 0 8px;
      letter-spacing:0.02em;
      color: var(--muted);
      font-weight:750;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .dot{
      width:10px; height:10px; border-radius:50%;
      background: conic-gradient(from 90deg, var(--accent), var(--accent2), var(--good), var(--accent));
      box-shadow: 0 0 16px rgba(125,211,252,0.35);
      flex:0 0 auto;
    }
    nav.toc a{
      display:block;
      padding: 7px 10px;
      margin: 4px 0;
      border-radius: 12px;
      text-decoration:none;
      color: var(--text);
      font-size: 0.95rem;
      border: 1px solid transparent;
    }
    nav.toc a:hover{
      background: rgba(255,255,255,0.06);
      border-color: var(--line);
    }
    nav.toc .small{
      color: var(--faint);
      font-size: 0.86rem;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--line);
    }

    article{
      background: linear-gradient(180deg, rgba(16,26,51,0.86), rgba(15,23,48,0.74));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    .section{
      padding: 18px 18px 6px;
      border-top: 1px solid var(--line);
    }
    .section:first-child{ border-top:none; }
    h2{
      margin:0 0 10px;
      font-size: 1.28rem;
      letter-spacing:-0.01em;
    }
    h3{
      margin: 14px 0 8px;
      font-size: 1.05rem;
      color: var(--muted);
    }
    p{ margin: 10px 0; color: var(--text); }
    ul{ margin: 10px 0 12px 22px; }
    li{ margin: 6px 0; color: var(--text); }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 860px){
      .grid2{ grid-template-columns: 1fr; }
    }
    .callout{
      border:1px solid var(--line);
      background: rgba(255,255,255,0.04);
      border-radius: 16px;
      padding: 12px 12px 10px;
    }
    .callout strong{ color: var(--muted); }
    .callout.good{ border-color: rgba(52,211,153,0.26); }
    .callout.warn{ border-color: rgba(251,191,36,0.26); }
    .callout.bad{ border-color: rgba(251,113,133,0.28); }
    .kicker{
      display:flex;
      gap:10px;
      align-items:center;
      color: var(--muted);
      font-weight: 700;
      font-size: 0.92rem;
      letter-spacing:0.02em;
      text-transform:uppercase;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.05);
      color: var(--muted);
      font-size: 0.92rem;
      white-space:nowrap;
    }
    .eq{
      font-family: var(--mono);
      font-size: 0.98rem;
      background: rgba(0,0,0,0.18);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 8px 10px;
      overflow-x:auto;
    }
    .eqRow{
      display:flex;
      gap:10px;
      align-items:stretch;
      flex-wrap:wrap;
      margin: 10px 0;
    }
    .copyBtn{
      cursor:pointer;
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.05);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      font-weight:700;
      font-size: 0.9rem;
      transition: transform 0.08s ease, background 0.15s ease, border-color 0.15s ease;
      user-select:none;
    }
    .copyBtn:hover{
      background: rgba(255,255,255,0.08);
      border-color: var(--line2);
    }
    .copyBtn:active{ transform: translateY(1px) scale(0.99); }
    .copyBtn.small{ padding: 7px 10px; font-size: 0.86rem; }
    .note{
      color: var(--faint);
      font-size: 0.95rem;
    }

    figure{
      margin: 10px 0 14px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,0.15);
      border-radius: 16px;
      padding: 10px;
      overflow:hidden;
    }
    figure figcaption{
      margin-top: 8px;
      color: var(--muted);
      font-size: 0.92rem;
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
      border-radius: 14px;
      background: rgba(10,14,28,0.55);
    }
    .row3{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    @media (min-width: 900px){
      .row3{ grid-template-columns: 1fr 1fr; }
      .row3 figure.main{ grid-column: 1 / -1; }
      .row3 figure.main canvas{ height: 360px; }
    }

    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      margin: 10px 0 6px;
    }
    .ctrl{
      flex: 1 1 220px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.04);
      border-radius: 16px;
      padding: 10px 12px;
      min-width: 220px;
    }
    .ctrl label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      color: var(--muted);
      font-weight: 750;
      font-size: 0.92rem;
      margin-bottom: 6px;
    }
    .ctrl input[type="range"]{ width:100%; }
    .ctrl select{
      width:100%;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,0.18);
      color: var(--text);
      font-weight: 700;
      outline:none;
    }
    .mini{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin: 10px 0 0;
    }
    .stat{
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.04);
      border-radius: 16px;
      padding: 10px 12px;
      flex: 1 1 170px;
      min-width: 170px;
    }
    .stat .k{ color: var(--muted); font-weight:800; font-size: 0.9rem; }
    .stat .v{ font-family: var(--mono); font-size: 0.98rem; margin-top: 6px; }

    footer{
      max-width:1180px;
      margin: 0 auto;
      padding: 18px 18px 50px;
      color: var(--faint);
      font-size: 0.95rem;
    }

    @media print{
      body{ background: #fff; color:#000; }
      nav.toc{ display:none; }
      article, figure, .callout, .stat, .ctrl{ box-shadow:none; background:#fff; border-color:#bbb; }
      canvas{ background:#fff; }
      .copyBtn{ display:none; }
      .eq{ background:#f5f5f5; border-color:#bbb; }
    }
  </style>
</head>

<body>
<header>
  <div class="top">
    <div>
      <h1>Modal Dispersion in a Step-Index Fiber (Meridional Only): Ray Picture vs Wave Picture</h1>
      <p class="subtitle">
        A very short optical pulse enters a step-index fiber and propagates 1 km. With negligible material dispersion,
        the output pulse shape is governed by <em>modal dispersion</em>—different rays/modes arrive at different times.
        We compare (a) ray optics with meridional rays and (b) wave optics with meridional (<span class="eq" style="padding:2px 6px">l=0</span>) modes.
      </p>
    </div>
    <div class="pill" title="Given parameters used throughout (and in plots)">NA = 0.16 • a = 45 μm • n1 = 1.45 • λ0 = 1.3 μm • L = 1 km</div>
  </div>
</header>

<main>
  <nav class="toc" aria-label="Table of Contents">
    <h2><span class="dot"></span>Table of Contents</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
    <div class="small">
      Tip: Use the sliders to change fiber length and NA. All plots update live.
    </div>
  </nav>

  <article>
    <!-- Quick Summary -->
    <section id="quick" class="section">
      <div class="kicker">Quick Summary</div>
      <ul>
        <li><strong>What this is:</strong> Predict how an ultrashort input pulse spreads after <span class="eq" style="padding:2px 6px">L = 1 km</span> in a step-index fiber when <strong>material dispersion is negligible</strong>.</li>
        <li><strong>Key physics idea:</strong> Different guided paths (rays) or guided solutions (modes) have different <em>group delays</em> → the output is a <em>distribution of arrival times</em>.</li>
        <li><strong>Ray-optics governing relation (meridional rays):</strong> group delay for a ray at internal axial angle <span class="eq" style="padding:2px 6px">θ</span> is
          <span class="eq">t(θ) = (n1 L / c) · (1 / cosθ)</span> with <span class="eq">cosθ ≥ n2/n1</span>.</li>
        <li><strong>Wave-optics governing relation (meridional modes, l=0):</strong> approximate group index
          <span class="eq">n_g,m ≈ n1 + (n1−n2) (u_m/V)^2</span> (weak guidance, large V), giving <span class="eq">t_m = (n_g,m L)/c</span>.</li>
        <li><strong>Computed fiber contrast from NA:</strong> <span class="eq">n2 = √(n1² − NA²)</span>, <span class="eq">Δ = (n1−n2)/n1</span>.</li>
        <li><strong>Final result type:</strong> A <em>sketch</em> (impulse response) plus key numeric spread: output spans about <strong>≈ 30 ns</strong> around a baseline flight time of <strong>≈ 4.83 μs</strong> for the given parameters.</li>
      </ul>
    </section>

    <!-- PART 0 -->
    <section id="part0" class="section">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="grid2">
        <div class="callout">
          <strong>Core definitions (symbols & units)</strong>
          <ul>
            <li><span class="eq">n1</span>, <span class="eq">n2</span>: core and cladding refractive indices (dimensionless).</li>
            <li><span class="eq">a</span>: core radius (m).</li>
            <li><span class="eq">NA</span>: numerical aperture (dimensionless), <span class="eq">NA = √(n1² − n2²)</span> (for launch from air).</li>
            <li><span class="eq">L</span>: propagation distance (m).</li>
            <li><span class="eq">t</span>: propagation time / group delay (s).</li>
            <li><span class="eq">V</span>: normalized frequency, <span class="eq">V = (2πa/λ)·NA</span> (dimensionless).</li>
          </ul>
        </div>

        <div class="callout">
          <strong>Physical meaning of key quantities</strong>
          <ul>
            <li><strong>Modal dispersion</strong>: pulse broadening because different guided “channels” (rays or modes) arrive at different times.</li>
            <li><span class="eq">NA</span> sets the <strong>largest guided angle</strong> (ray picture) and the <strong>number of modes</strong> (wave picture via <span class="eq">V</span>).</li>
            <li><strong>Group delay</strong> is what matters for pulses: <span class="eq">t = L / v_g</span>, not phase velocity.</li>
            <li>“Material dispersion negligible” means <span class="eq">dn/dλ ≈ 0</span>, so broadening is dominated by geometry/waveguide effects.</li>
          </ul>
        </div>
      </div>

      <h3>Key laws/principles and validity</h3>
      <ul>
        <li><strong>Ray optics (geometric optics):</strong> valid when the core size is much larger than wavelength (<span class="eq">a ≫ λ</span>) and we can treat light as rays reflecting at the core–cladding boundary.</li>
        <li><strong>Wave optics (modal picture):</strong> solve Maxwell’s equations in cylindrical geometry. Under <strong>weak guidance</strong> (<span class="eq">Δ ≪ 1</span>), modes resemble linearly polarized (LP) modes with discrete propagation constants.</li>
        <li><strong>Meridional restriction:</strong> only rays (or modes) that pass through the fiber axis (no skew component). This removes some families but keeps the essential dispersion mechanism.</li>
      </ul>

      <div class="callout warn">
        <strong>Common models/approximations (and why)</strong>
        <ul>
          <li><strong>Step-index + weak guidance:</strong> simplifies modal formulas by using <span class="eq">Δ=(n1−n2)/n1</span> and LP-mode approximations.</li>
          <li><strong>Large V:</strong> many modes; eigenvalues become approximately the zeros of Bessel functions, enabling quick estimates and clean sketches.</li>
          <li><strong>Negligible material dispersion:</strong> lets us isolate <em>modal</em> dispersion without tracking <span class="eq">dn/dω</span>.</li>
        </ul>
      </div>

      <h3>Mini intuition examples</h3>
      <ul>
        <li><strong>Ray intuition:</strong> In the core, all rays move at ~<span class="eq">c/n1</span>, but a tilted ray travels a longer zig-zag path → arrives later.</li>
        <li><strong>Mode intuition:</strong> Higher-order modes “hug” the boundary more; their field structure makes them effectively “slower” in group delay (a waveguide dispersion effect even when <span class="eq">n</span> is constant).</li>
      </ul>

      <div class="callout bad">
        <strong>What to watch for (pitfalls)</strong>
        <ul>
          <li>Confusing <strong>phase index</strong> (<span class="eq">n_eff</span>) with <strong>group index</strong> (<span class="eq">n_g</span>). Pulses care about <span class="eq">n_g</span>.</li>
          <li>Using acceptance angle in air directly as the internal propagation angle—inside the core you must use the TIR condition at the core–cladding interface.</li>
          <li>Assuming a single “output delay”: a short input pulse becomes a <em>spread</em> or a <em>set of discrete arrivals</em> depending on the model.</li>
        </ul>
      </div>
    </section>

    <!-- PART 1 -->
    <section id="part1" class="section">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Problem restatement (in plain words)</h3>
      <p>
        A step-index fiber has NA = 0.16, core radius <span class="eq" style="padding:2px 6px">a=45 μm</span>,
        and core index <span class="eq" style="padding:2px 6px">n1=1.45</span> at wavelength <span class="eq" style="padding:2px 6px">λ0=1.3 μm</span>.
        A very short pulse enters at <span class="eq" style="padding:2px 6px">t=0</span> and propagates <span class="eq" style="padding:2px 6px">L=1 km</span>.
        With negligible material dispersion, sketch the <strong>received pulse shape</strong> for:
        (a) ray optics with meridional rays,
        (b) wave optics with only meridional modes (<span class="eq" style="padding:2px 6px">l=0</span>).
      </p>

      <div class="grid2">
        <div class="callout">
          <strong>Given</strong>
          <ul>
            <li><span class="eq">NA = 0.16</span></li>
            <li><span class="eq">a = 45 μm</span></li>
            <li><span class="eq">n1 = 1.45</span></li>
            <li><span class="eq">λ0 = 1.3 μm</span></li>
            <li><span class="eq">L = 1 km</span></li>
            <li>Material dispersion negligible</li>
          </ul>
        </div>
        <div class="callout">
          <strong>Unknowns / what to produce</strong>
          <ul>
            <li>Output pulse <em>shape</em> (qualitative sketch) after 1 km for each model.</li>
            <li>Key time scales: earliest arrival, latest arrival, and total spread <span class="eq">ΔT</span>.</li>
            <li>Interpretation: continuous spread (rays) vs discrete arrivals (modes).</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li><strong>Geometric path-length differences</strong> dominate in (a): all meridional rays travel in the core with speed ~<span class="eq">c/n1</span> but different axial angles give different effective path lengths.</li>
        <li><strong>Mode-dependent group delay</strong> dominates in (b): each allowed guided mode has its own <span class="eq">β(ω)</span>, hence its own <span class="eq">v_g = (dβ/dω)^{-1}</span>.</li>
        <li><strong>Material dispersion neglected</strong> → we ignore <span class="eq">dn/dω</span> terms; waveguide/mode geometry sets the delay spread.</li>
      </ul>
      <p class="note">
        What we do <em>not</em> need: chromatic dispersion formulas (since material dispersion is negligible) and nonlinear effects (pulse is “very short” but the problem does not invoke high power).
      </p>

      <div class="callout warn">
        <strong>Assumptions (explicit)</strong>
        <ul>
          <li>Step-index profile, uniform <span class="eq">n1</span> in core and <span class="eq">n2</span> in cladding.</li>
          <li>Meridional-only: no skew rays, and for modes only azimuthal order <span class="eq">l=0</span>.</li>
          <li>Weak guidance (we will check <span class="eq">Δ ≪ 1</span>) to use LP-style approximations for wave optics.</li>
          <li>Input pulse is sufficiently short to approximate as an impulse (so output ≈ impulse response).</li>
          <li>Launch excites a range of allowed rays/modes (for sketching we assume roughly comparable excitation across the allowed set).</li>
        </ul>
      </div>

      <h3>Possible approaches (pros/cons)</h3>
      <ul>
        <li><strong>Approach A (ray delay mapping):</strong> compute <span class="eq">t(θ)</span>, find <span class="eq">θ_max</span> from TIR, then map angles to arrival times. <em>Pros:</em> simple, gives continuous spread. <em>Cons:</em> ignores discreteness of modes.</li>
        <li><strong>Approach B (mode group delay from weak guidance):</strong> estimate <span class="eq">n_g,m</span> using <span class="eq">V</span> and approximate eigenvalues <span class="eq">u_m</span>. <em>Pros:</em> shows discrete pulse “comb”. <em>Cons:</em> approximate, requires modal estimates.</li>
        <li><strong>Approach C (full vector eigenproblem):</strong> solve exact characteristic equations and compute <span class="eq">β(ω)</span>. <em>Pros:</em> most accurate. <em>Cons:</em> overkill for “sketch”.</li>
      </ul>

      <p><strong>Chosen approach:</strong> Use Approach A for (a) and Approach B for (b), because the problem asks for sketches and key time scales, not full numerical mode solving.</p>
    </section>

    <!-- PART 2 -->
    <section id="part2" class="section">
      <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

      <ol>
        <li><strong>Goal:</strong> find cladding index. <br>
          <strong>Tool:</strong> <span class="eq">NA = √(n1² − n2²)</span>. <br>
          <strong>Meaning:</strong> sets guidance strength and max ray angle.
        </li>
        <li><strong>Goal:</strong> determine max internal meridional ray angle. <br>
          <strong>Tool:</strong> TIR at core–cladding: <span class="eq">cosθ_max = n2/n1</span>. <br>
          <strong>Meaning:</strong> the “slowest” ray is the most tilted allowed.
        </li>
        <li><strong>Goal:</strong> compute ray group delay span. <br>
          <strong>Tool:</strong> <span class="eq">t(θ) = (n1 L/c)(1/cosθ)</span>. <br>
          <strong>Meaning:</strong> maps launch angle to arrival time → continuous broadening.
        </li>
        <li><strong>Goal:</strong> compute normalized frequency and count meridional modes. <br>
          <strong>Tool:</strong> <span class="eq">V = (2πa/λ)·NA</span>, and for <span class="eq">l=0</span> roughly the number of radial orders with <span class="eq">u_m &lt; V</span>. <br>
          <strong>Meaning:</strong> decides how many discrete arrivals you’ll see.
        </li>
        <li><strong>Goal:</strong> estimate group delay per mode. <br>
          <strong>Tool:</strong> weak-guidance/large-V estimate <span class="eq">n_g,m ≈ n1 + (n1−n2)(u_m/V)^2</span>, then <span class="eq">t_m = (n_g,m L)/c</span>. <br>
          <strong>Meaning:</strong> discrete “pulselets” at different times.
        </li>
        <li><strong>Goal:</strong> sketch output pulse shapes. <br>
          <strong>Tool:</strong> interpret as impulse responses: continuous distribution (rays) vs discrete lines (modes). <br>
          <strong>Meaning:</strong> what your detector sees after 1 km.
        </li>
      </ol>

      <div class="callout warn">
        <strong>Common mistakes + quick tips</strong>
        <ul>
          <li><strong>Tip:</strong> Always compute <span class="eq">n2</span> from the given NA—don’t guess it.</li>
          <li><strong>Mistake:</strong> using <span class="eq">sinθ_max = NA/n1</span> blindly. For internal guided rays, use the TIR condition at the boundary; it leads to <span class="eq">cosθ_max = n2/n1</span>.</li>
          <li><strong>Mistake:</strong> treating modal delays as continuous in the wave picture—modes are discrete, so the impulse response is “spiky”.</li>
        </ul>
      </div>
    </section>

    <!-- PART 3 -->
    <section id="part3" class="section">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Qualitative expectation (before calculating)</h3>
      <p>
        In a step-index fiber, meridional rays that travel nearly straight down the axis have the shortest path length and arrive first.
        Rays that zig-zag at larger angles take a longer geometric path and arrive later. Therefore, an ultrashort input pulse will
        spread into a time window. In the wave picture, the energy travels in discrete guided modes, so the output resembles a sum of
        delayed components rather than a smooth continuum.
      </p>

      <div class="callout good">
        <strong>Key equations (copyable)</strong>
        <div class="eqRow">
          <div class="eq" id="eq1">n2 = sqrt(n1^2 - NA^2)</div>
          <button class="copyBtn small" data-copy="#eq1">Copy</button>
        </div>
        <div class="eqRow">
          <div class="eq" id="eq2">Ray delay: t(θ) = (n1*L/c) * (1/cosθ), with cosθ ≥ n2/n1</div>
          <button class="copyBtn small" data-copy="#eq2">Copy</button>
        </div>
        <div class="eqRow">
          <div class="eq" id="eq3">V = (2πa/λ) * NA</div>
          <button class="copyBtn small" data-copy="#eq3">Copy</button>
        </div>
        <div class="eqRow">
          <div class="eq" id="eq4">Mode (l=0) group index (approx): n_g,m ≈ n1 + (n1-n2) * (u_m/V)^2;  t_m = (n_g,m*L)/c</div>
          <button class="copyBtn small" data-copy="#eq4">Copy</button>
        </div>
      </div>

      <h3>Step 1 — Compute cladding index and index contrast</h3>
      <p>
        For launch from air, the step-index numerical aperture is
        <span class="eq">NA = √(n1² − n2²)</span>, so
      </p>
      <div class="eqRow">
        <div class="eq" id="calc_n2">n2 = √(n1² − NA²)</div>
        <button class="copyBtn" data-copy="#calc_n2">Copy</button>
      </div>
      <p>
        With <span class="eq">n1 = 1.45</span> and <span class="eq">NA = 0.16</span>:
      </p>
      <div class="callout">
        <div class="eq" id="num_n2">n2 ≈ 1.44115</div>
        <div class="eq" id="num_Delta">Δ = (n1−n2)/n1 ≈ 0.00611</div>
      </div>
      <p class="note">
        Explanation: <span class="eq">Δ ≈ 0.6%</span> is small → weak-guidance approximations are reasonable.
      </p>

      <h3>(a) Ray optics with meridional rays only</h3>

      <h4>Step 2 — Relate ray angle to allowed guidance (TIR condition)</h4>
      <p>
        Let <span class="eq">θ</span> be the ray’s angle relative to the fiber axis (inside the core).
        At the cylindrical core–cladding boundary, the angle of incidence (from the normal) is <span class="eq">90° − θ</span>,
        so the TIR condition is:
      </p>
      <div class="eqRow">
        <div class="eq" id="tir">sin(90° − θ) = cosθ ≥ n2/n1</div>
        <button class="copyBtn" data-copy="#tir">Copy</button>
      </div>
      <p>
        Therefore the maximum guided meridional angle is set by
        <span class="eq">cosθ_max = n2/n1</span>.
      </p>

      <h4>Step 3 — Compute ray travel time vs angle</h4>
      <p>
        In the core, the ray speed is approximately <span class="eq">v ≈ c/n1</span>. If the axial distance traveled is <span class="eq">L</span>,
        the actual ray path length is <span class="eq">L / cosθ</span>, hence the travel time is
      </p>
      <div class="eqRow">
        <div class="eq" id="tray">t(θ) = (n1/c)·(L/cosθ) = (n1 L / c)·(1/cosθ)</div>
        <button class="copyBtn" data-copy="#tray">Copy</button>
      </div>

      <h4>Step 4 — Earliest and latest arrival times (and pulse spread)</h4>
      <p>
        The earliest ray is the axial ray (<span class="eq">θ=0</span>):
        <span class="eq">t_min = n1 L / c</span>.
        The latest guided meridional ray uses <span class="eq">cosθ_max = n2/n1</span>:
      </p>
      <div class="eqRow">
        <div class="eq" id="tmax_ray">t_max = (n1 L/c)·(1/cosθ_max) = (n1 L/c)·(n1/n2)</div>
        <button class="copyBtn" data-copy="#tmax_ray">Copy</button>
      </div>
      <p>
        So the intermodal (ray) spread is
      </p>
      <div class="eqRow">
        <div class="eq" id="dtray">ΔT_ray = t_max − t_min = (n1 L/c)·(n1/n2 − 1) ≈ (n1ΔL)/c  (for Δ≪1)</div>
        <button class="copyBtn" data-copy="#dtray">Copy</button>
      </div>

      <div class="callout good">
        <strong>Numerical values for L = 1 km</strong>
        <ul>
          <li><span class="eq">t_min ≈ (1.45)(1000)/(3×10^8) ≈ 4.83 μs</span></li>
          <li><span class="eq">ΔT_ray ≈ (n1ΔL)/c ≈ (1.45)(0.00611)(1000)/(3×10^8) ≈ 29.5 ns</span></li>
          <li><span class="eq">t_max ≈ 4.83 μs + 29.5 ns ≈ 4.863 μs</span></li>
        </ul>
      </div>

      <p>
        <strong>Sketch for (a):</strong> If many meridional ray angles are excited, the received pulse becomes a
        <strong>continuous broadened waveform</strong> spanning the interval <span class="eq">[t_min, t_max]</span>.
        A common “first sketch” is a roughly <strong>filled</strong> window (often drawn near-rectangular or gently sloped depending on launch weighting).
      </p>

      <h3>(b) Wave optics with meridional modes only (l = 0)</h3>

      <h4>Step 5 — Compute normalized frequency V and estimate how many l=0 modes exist</h4>
      <p>
        The normalized frequency is
        <span class="eq">V = (2πa/λ)·NA</span>.
        Large <span class="eq">V</span> means many guided modes.
      </p>
      <div class="callout">
        <div class="eq" id="num_V">With a=45 μm, λ=1.3 μm, NA=0.16: V ≈ 34.8</div>
        <p class="note">
          For meridional (<span class="eq">l=0</span>) modes, the radial eigenvalues are roughly Bessel zeros <span class="eq">u_m</span>.
          The number of allowed radial orders is approximately how many zeros satisfy <span class="eq">u_m &lt; V</span>, which here is about <strong>~11</strong>.
        </p>
      </div>

      <h4>Step 6 — Mode-dependent group delay (why modes broaden pulses)</h4>
      <p>
        Each guided mode has propagation constant <span class="eq">β(ω)</span>, and group velocity
        <span class="eq">v_g = (dβ/dω)^{-1}</span>. The pulse arrival time is
        <span class="eq">t = L/v_g</span> or equivalently <span class="eq">t = (n_g L)/c</span>,
        where the <strong>group index</strong> is <span class="eq">n_g = c/v_g</span>.
      </p>
      <p>
        In weak guidance and for large <span class="eq">V</span>, a useful estimate for meridional (<span class="eq">l=0</span>) modes is:
      </p>
      <div class="eqRow">
        <div class="eq" id="ngapprox">n_g,m ≈ n1 + (n1−n2)·(u_m/V)^2</div>
        <button class="copyBtn" data-copy="#ngapprox">Copy</button>
      </div>
      <p class="note">
        Interpretation: larger <span class="eq">u_m</span> (higher radial order) → larger <span class="eq">n_g</span> → slower arrival.
        Even with negligible material dispersion, <span class="eq">V ∝ ω</span> makes <span class="eq">β(ω)</span> differ among modes, producing different group delays.
      </p>

      <h4>Step 7 — Arrival time window and sketch</h4>
      <p>
        The smallest <span class="eq">u_m</span> (fundamental meridional mode) gives <span class="eq">n_g ≈ n1</span>:
        <span class="eq">t_min ≈ n1 L/c</span> (same earliest time scale as the axial ray).
        The largest allowed <span class="eq">u_m</span> is near <span class="eq">V</span>, giving
        <span class="eq">n_g,max ≈ n1 + (n1−n2)</span>.
        Hence the total modal delay spread is approximately:
      </p>
      <div class="eqRow">
        <div class="eq" id="dtmode">ΔT_mode ≈ (n1−n2)·L/c = (n1ΔL)/c</div>
        <button class="copyBtn" data-copy="#dtmode">Copy</button>
      </div>

      <div class="callout good">
        <strong>Numerical values (same L = 1 km)</strong>
        <ul>
          <li><span class="eq">t_min ≈ 4.83 μs</span></li>
          <li><span class="eq">ΔT_mode ≈ 29.5 ns</span></li>
        </ul>
        <p class="note">
          The difference from the ray picture is not primarily the window width (it’s comparable), but the <strong>shape</strong>:
          the wave picture predicts a <strong>discrete set of arrivals</strong> (a comb/spike train) corresponding to the allowed <span class="eq">l=0</span> modes.
        </p>
      </div>

      <div class="callout bad">
        <strong>Final Answer (copyable)</strong>
        <div class="eqRow">
          <div class="eq" id="finalAns">
(a) Ray (meridional): output is a continuous broadened pulse over t ∈ [t_min, t_max], where t_min = n1 L/c and t_max = (n1 L/c)(n1/n2). For given values: t_min ≈ 4.83 μs and ΔT ≈ 29.5 ns.

(b) Wave (l=0 modes): output is a sum of discrete delayed components (spiky/comb-like impulse response) spanning approximately the same window width ΔT ≈ (n1−n2)L/c ≈ 29.5 ns around ~4.83 μs, with individual peaks at t_m = (n_g,m L)/c and n_g,m ≈ n1 + (n1−n2)(u_m/V)^2.
          </div>
          <button class="copyBtn" data-copy="#finalAns">Copy</button>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><strong>Units:</strong> <span class="eq">nL/c</span> has units (dimensionless·m)/(m/s) = s ✅</li>
        <li><strong>Limiting case:</strong> if <span class="eq">NA → 0</span> then <span class="eq">n2 → n1</span>, so <span class="eq">ΔT → 0</span> (no modal dispersion) ✅</li>
        <li><strong>Physical sign:</strong> larger angle (ray) or higher order (mode) → longer delay; plots show increasing delay with angle/mode order ✅</li>
      </ul>

      <p class="note">
        Connection to the diagram/plots below: the geometry canvas shows the zig-zag path length increase with angle,
        while the pulse-response plot shows the resulting time spread (continuous vs discrete).
      </p>

      <!-- Visualizations -->
      <h3>Interactive Visualizations</h3>

      <div class="controls" aria-label="Interactive controls">
        <div class="ctrl">
          <label for="lenKm">Fiber length L (km) <span id="lenKmVal" class="pill">1.00 km</span></label>
          <input id="lenKm" type="range" min="0.1" max="5" step="0.05" value="1.00"/>
          <div class="note">Longer L stretches the time axis and increases delay spread linearly.</div>
        </div>
        <div class="ctrl">
          <label for="naVal">Numerical aperture NA <span id="naValTxt" class="pill">0.160</span></label>
          <input id="naVal" type="range" min="0.05" max="0.30" step="0.005" value="0.160"/>
          <div class="note">Higher NA → larger contrast (smaller n2), larger spread, and more l=0 modes.</div>
        </div>
        <div class="ctrl">
          <label for="launch">Launch weighting (for sketches)</label>
          <select id="launch">
            <option value="uniformAngle">Ray weighting: uniform in angle θ</option>
            <option value="sinTheta" selected>Ray weighting: proportional to sinθ</option>
            <option value="modeEqual">Mode weighting: equal amplitude per mode</option>
            <option value="modeDecay">Mode weighting: decays with order (more fundamental)</option>
          </select>
          <div class="note">This changes how “flat” or “peaky” the impulse responses look.</div>
        </div>
      </div>

      <div class="mini" aria-label="Computed statistics">
        <div class="stat">
          <div class="k">Computed n2</div>
          <div class="v" id="stat_n2">—</div>
        </div>
        <div class="stat">
          <div class="k">Δ = (n1−n2)/n1</div>
          <div class="v" id="stat_Delta">—</div>
        </div>
        <div class="stat">
          <div class="k">V = (2πa/λ)NA</div>
          <div class="v" id="stat_V">—</div>
        </div>
        <div class="stat">
          <div class="k">Meridional l=0 modes (≈ count u_m&lt;V)</div>
          <div class="v" id="stat_M0">—</div>
        </div>
        <div class="stat">
          <div class="k">ΔT (ns) (ray window ≈ mode window)</div>
          <div class="v" id="stat_dT">—</div>
        </div>
      </div>

      <div class="row3">
        <figure>
          <canvas id="cDiagram" aria-label="Fiber geometry diagram"></canvas>
          <figcaption><strong>Diagram:</strong> Step-index fiber cross-section & a meridional ray zig-zagging in the core (angle θ).</figcaption>
        </figure>

        <figure class="main">
          <canvas id="cMain" aria-label="Main plot: output impulse responses"></canvas>
          <figcaption><strong>Main plot:</strong> Received pulse shape (impulse response) after L km: (a) ray continuum vs (b) discrete l=0 modes.</figcaption>
        </figure>

        <figure>
          <canvas id="cSecondary" aria-label="Secondary plot: delay vs angle or mode index"></canvas>
          <figcaption><strong>Secondary plot:</strong> (a) Ray delay t(θ) vs θ and (b) Mode delay t_m vs mode order (l=0).</figcaption>
        </figure>
      </div>
    </section>

    <!-- PART 4 -->
    <section id="part4" class="section">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the final formulas</h3>
      <ul>
        <li><span class="eq">ΔT ≈ (n1−n2)L/c</span>: the spread scales linearly with distance and with index contrast.</li>
        <li><span class="eq">n2 = √(n1² − NA²)</span>: larger NA implies smaller <span class="eq">n2</span> → bigger contrast → bigger delay spread.</li>
        <li><span class="eq">V = (2πa/λ)NA</span>: bigger core radius or NA (or smaller wavelength) increases V → more modes → more “spikes” in the wave picture.</li>
      </ul>

      <div class="callout good">
        <strong>How parameter changes affect the outcome (connect to the plots)</strong>
        <ul>
          <li><strong>Increase L:</strong> the whole pulse shifts later and stretches wider proportionally (both ray and mode windows widen linearly).</li>
          <li><strong>Increase NA:</strong> the slowest components get even slower (bigger <span class="eq">ΔT</span>) and the number of <span class="eq">l=0</span> modes increases (more discrete peaks).</li>
          <li><strong>Change launch weighting:</strong> the time window endpoints stay the same, but the intensity distribution across that window changes.</li>
        </ul>
      </div>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        Instead of using the approximate <span class="eq">n_g,m</span> formula, one can start from the exact scalar waveguide dispersion relation for LP modes,
        solve for <span class="eq">β(V)</span>, then compute <span class="eq">n_g = c(dβ/dω)</span> numerically for each mode.
        That would refine the exact peak locations and relative weights, but the “comb-like within a ~tens of ns window” picture remains.
      </p>

      <h3>Concept check (quick self-test)</h3>
      <ul>
        <li><strong>Q:</strong> If <span class="eq">NA</span> decreases while everything else stays fixed, what happens to <span class="eq">ΔT</span>? <br>
            <strong>A:</strong> It decreases because <span class="eq">n2</span> approaches <span class="eq">n1</span>, reducing index contrast.</li>
        <li><strong>Q:</strong> Why does the wave picture produce spikes rather than a smooth blob? <br>
            <strong>A:</strong> Only discrete modes are allowed; each has its own group delay.</li>
        <li><strong>Q:</strong> Why can there still be pulse broadening when material dispersion is negligible? <br>
            <strong>A:</strong> Because different modes have different <span class="eq">β(ω)</span> slopes (waveguide dispersion), and rays have different path lengths.</li>
        <li><strong>Q:</strong> Does “meridional only” eliminate modal dispersion? <br>
            <strong>A:</strong> No—different meridional angles/modes still have different delays; it just removes skew families.</li>
      </ul>
    </section>

    <!-- PART 5 -->
    <section id="part5" class="section">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <h3>What each canvas shows</h3>
      <ul>
        <li><strong>Diagram canvas:</strong> core/cladding step-index structure and a meridional ray at angle <span class="eq">θ</span> that zig-zags, illustrating increased path length <span class="eq">L/cosθ</span>.</li>
        <li><strong>Main plot:</strong> received pulse shape (impulse response):
          <ul>
            <li><em>Ray model:</em> a continuous distribution spanning <span class="eq">t ∈ [t_min, t_max]</span>.</li>
            <li><em>Wave model:</em> discrete peaks at <span class="eq">t_m</span> for allowed <span class="eq">l=0</span> modes.</li>
          </ul>
        </li>
        <li><strong>Secondary plot:</strong> delay maps:
          <ul>
            <li><em>Ray:</em> <span class="eq">t(θ)</span> vs <span class="eq">θ</span> (shows monotonic delay increase with angle).</li>
            <li><em>Modes:</em> <span class="eq">t_m</span> vs mode order m (shows later arrival for higher radial order).</li>
          </ul>
        </li>
      </ul>

      <h3>Interactive controls (what changes and why)</h3>
      <ul>
        <li><strong>Fiber length L:</strong> multiplies all delays by L → both the main pulse window and the delay curves scale linearly.</li>
        <li><strong>NA:</strong> changes <span class="eq">n2</span> and <span class="eq">V</span>. Larger NA increases both the delay spread and the number of meridional modes (more peaks).</li>
        <li><strong>Launch weighting:</strong> changes the relative intensity across times (distribution over θ or over modes), without changing the physical endpoints <span class="eq">t_min</span> and <span class="eq">t_max</span>.</li>
      </ul>
    </section>
  </article>
</main>

<footer>
  <p>
    Built as a self-contained learning article (no external libraries). The plotted mode delays use a standard weak-guidance,
    large-V approximation to illustrate the difference between ray-continuum broadening and discrete modal arrivals.
  </p>
</footer>

<script>
(function(){
  // -------------------------
  // Constants and parameters
  // -------------------------
  const C = 299792458; // m/s
  const n1 = 1.45;
  const a = 45e-6;     // m
  const lambda0 = 1.3e-6; // m

  // Approx Bessel J0 zeros (first ~20). We'll use those < V as l=0 radial eigenvalues u_m.
  const j0Zeros = [
    2.4048255577, 5.5200781103, 8.6537279129, 11.7915344391, 14.9309177086,
    18.0710639679, 21.2116366299, 24.3524715308, 27.4934791320, 30.6346064684,
    33.7758202136, 36.9170983537, 40.0584257646, 43.1997917132, 46.3411883717,
    49.4826098974, 52.6240518411, 55.7655107550, 58.9069839261, 62.0484691902
  ];

  // -------------------------
  // DOM elements
  // -------------------------
  const elLen = document.getElementById('lenKm');
  const elLenVal = document.getElementById('lenKmVal');
  const elNA = document.getElementById('naVal');
  const elNATxt = document.getElementById('naValTxt');
  const elLaunch = document.getElementById('launch');

  const stat_n2 = document.getElementById('stat_n2');
  const stat_Delta = document.getElementById('stat_Delta');
  const stat_V = document.getElementById('stat_V');
  const stat_M0 = document.getElementById('stat_M0');
  const stat_dT = document.getElementById('stat_dT');

  const cDiagram = document.getElementById('cDiagram');
  const cMain = document.getElementById('cMain');
  const cSecondary = document.getElementById('cSecondary');

  // -------------------------
  // HiDPI canvas helper
  // -------------------------
  function setupCanvas(canvas){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(2, Math.floor(rect.width * dpr));
    const h = Math.max(2, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
    }
    const ctx = canvas.getContext('2d');
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
    return {ctx, w: rect.width, h: rect.height, dpr};
  }

  // -------------------------
  // Plot utilities
  // -------------------------
  function drawAxes(ctx, W, H, opts){
    const pad = opts.pad || {l:54, r:18, t:34, b:44};
    const x0 = pad.l, y0 = H - pad.b;
    const x1 = W - pad.r, y1 = pad.t;

    // background subtle
    ctx.clearRect(0,0,W,H);

    // Title
    ctx.save();
    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.font = '700 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(opts.title || '', pad.l, 20);
    ctx.restore();

    // Frame
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.16)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.rect(x0, y1, x1-x0, y0-y1);
    ctx.stroke();
    ctx.restore();

    // Grid + ticks
    const xticks = opts.xticks || 6;
    const yticks = opts.yticks || 5;

    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;

    for(let i=0;i<=xticks;i++){
      const x = x0 + (x1-x0)*(i/xticks);
      ctx.beginPath();
      ctx.moveTo(x, y1);
      ctx.lineTo(x, y0);
      ctx.stroke();
    }
    for(let j=0;j<=yticks;j++){
      const y = y0 - (y0-y1)*(j/yticks);
      ctx.beginPath();
      ctx.moveTo(x0, y);
      ctx.lineTo(x1, y);
      ctx.stroke();
    }
    ctx.restore();

    // Labels
    ctx.save();
    ctx.fillStyle = 'rgba(185,195,230,0.95)';
    ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    if(opts.xlabel) ctx.fillText(opts.xlabel, (x0+x1)/2 - 40, H-12);
    if(opts.ylabel){
      ctx.translate(14, (y0+y1)/2 + 40);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(opts.ylabel, 0, 0);
      ctx.setTransform(1,0,0,1,0,0);
    }
    ctx.restore();

    // Tick labels
    ctx.save();
    ctx.fillStyle = 'rgba(185,195,230,0.90)';
    ctx.font = '500 11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

    const xmin = opts.xmin, xmax = opts.xmax;
    const ymin = opts.ymin, ymax = opts.ymax;
    const fmtX = opts.fmtX || (v=>v.toFixed(2));
    const fmtY = opts.fmtY || (v=>v.toFixed(2));

    for(let i=0;i<=xticks;i++){
      const x = x0 + (x1-x0)*(i/xticks);
      const v = xmin + (xmax-xmin)*(i/xticks);
      ctx.fillText(fmtX(v), x-12, y0+16);
    }
    for(let j=0;j<=yticks;j++){
      const y = y0 - (y0-y1)*(j/yticks);
      const v = ymin + (ymax-ymin)*(j/yticks);
      ctx.fillText(fmtY(v), 6, y+4);
    }
    ctx.restore();

    return {pad, x0, x1, y0, y1};
  }

  function xMap(x, ax){ return ax.x0 + (ax.x1-ax.x0) * ((x-ax.xmin)/(ax.xmax-ax.xmin)); }
  function yMap(y, ax){ return ax.y0 - (ax.y0-ax.y1) * ((y-ax.ymin)/(ax.ymax-ax.ymin)); }

  function legend(ctx, W, items){
    const x = 16, y = 34;
    ctx.save();
    ctx.font = '700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    let yy = y;
    for(const it of items){
      ctx.fillStyle = it.color;
      ctx.fillRect(x, yy-9, 14, 8);
      ctx.fillStyle = 'rgba(233,238,252,0.92)';
      ctx.fillText(it.label, x+20, yy);
      yy += 16;
    }
    ctx.restore();
  }

  // -------------------------
  // Physics computations
  // -------------------------
  function computeParams(){
    const Lkm = parseFloat(elLen.value);
    const L = Lkm * 1000;
    const NA = parseFloat(elNA.value);

    const n2 = Math.sqrt(Math.max(0, n1*n1 - NA*NA));
    const Delta = (n1 - n2)/n1;
    const V = (2*Math.PI*a/lambda0) * NA;

    // Ray endpoints
    const tMin = (n1 * L) / C;
    const tMax = (n1 * L / C) * (n1 / n2);
    const dT = tMax - tMin;

    // Mode list (l=0 approx)
    const uList = j0Zeros.filter(u => u < V);
    const M0 = uList.length;

    // Mode group index (approx) and times
    const modeTimes = uList.map((u, idx) => {
      const ng = n1 + (n1 - n2) * (u*u)/(V*V);
      const tm = (ng * L)/C;
      return {m: idx+1, u, ng, t: tm};
    });

    return {Lkm, L, NA, n2, Delta, V, tMin, tMax, dT, uList, M0, modeTimes};
  }

  // Weighting choices
  function rayWeight(theta, choice){
    if(choice === 'uniformAngle') return 1;
    // sinTheta: rough "uniform in solid angle" style weighting for meridional slice
    return Math.max(0, Math.sin(theta));
  }
  function modeWeight(mIndex, M0, choice){
    if(choice === 'modeEqual') return 1;
    if(choice === 'modeDecay'){
      // favor low-order modes
      const x = (mIndex-1)/Math.max(1, M0-1);
      return Math.exp(-3.2*x);
    }
    // default
    return 1;
  }

  // Build ray impulse response histogram
  function rayImpulse(params, choice){
    const {n2, tMin, tMax} = params;
    const cosMin = n2/n1;
    const thetaMax = Math.acos(Math.min(1, Math.max(0, cosMin)));

    const N = 8000;
    const bins = 240;
    const hist = new Array(bins).fill(0);
    const dt = (tMax - tMin) / bins;

    // sample theta uniformly and weight accordingly
    for(let i=0;i<N;i++){
      const theta = thetaMax * (i/(N-1));
      const t = (params.tMin) * (1/Math.cos(Math.max(1e-9, theta))); // using t(θ)=tMin/cosθ since tMin = n1 L/c
      const w = rayWeight(theta, choice);
      const k = Math.min(bins-1, Math.max(0, Math.floor((t - tMin)/dt)));
      hist[k] += w;
    }

    // normalize
    const maxv = Math.max(...hist, 1e-12);
    for(let k=0;k<bins;k++) hist[k] /= maxv;

    // x-axis: time array
    const tAxis = new Array(bins).fill(0).map((_,k)=> tMin + (k+0.5)*dt);
    return {tAxis, hist};
  }

  // Build mode impulse response as spikes (with small Gaussian kernel for display)
  function modeImpulse(params, choice){
    const {modeTimes, tMin, tMax, M0} = params;
    const bins = 240;
    const hist = new Array(bins).fill(0);
    const dt = (tMax - tMin) / bins;

    // gaussian smoothing (in bins)
    const sigmaBins = 0.8;
    const half = 6;

    function addGaussian(centerBin, amp){
      for(let j=-half;j<=half;j++){
        const k = centerBin + j;
        if(k<0 || k>=bins) continue;
        const g = Math.exp(-0.5*(j*j)/(sigmaBins*sigmaBins));
        hist[k] += amp*g;
      }
    }

    for(let i=0;i<modeTimes.length;i++){
      const tm = modeTimes[i].t;
      const k0 = Math.min(bins-1, Math.max(0, Math.round((tm - tMin)/dt)));
      const amp = modeWeight(i+1, M0, choice === 'modeEqual' || choice === 'modeDecay' ? choice : 'modeEqual');
      addGaussian(k0, amp);
    }

    const maxv = Math.max(...hist, 1e-12);
    for(let k=0;k<bins;k++) hist[k] /= maxv;
    const tAxis = new Array(bins).fill(0).map((_,k)=> tMin + (k+0.5)*dt);
    return {tAxis, hist};
  }

  // -------------------------
  // Drawing routines
  // -------------------------
  function drawDiagram(params){
    const {ctx, w:W, h:H} = setupCanvas(cDiagram);

    // scene
    ctx.clearRect(0,0,W,H);

    const pad = 16;
    const cx = W*0.30, cy = H*0.55;
    const Rcore = Math.min(W,H)*0.24;
    const Rclad = Rcore*1.55;

    // labels style
    const txt = 'rgba(233,238,252,0.92)';
    const mut = 'rgba(185,195,230,0.92)';
    const faint = 'rgba(185,195,230,0.75)';
    const line = 'rgba(255,255,255,0.18)';
    const coreFill = 'rgba(125,211,252,0.10)';
    const cladFill = 'rgba(167,139,250,0.06)';

    // cladding
    ctx.save();
    ctx.fillStyle = cladFill;
    ctx.strokeStyle = 'rgba(167,139,250,0.35)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, Rclad, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // core
    ctx.save();
    ctx.fillStyle = coreFill;
    ctx.strokeStyle = 'rgba(125,211,252,0.45)';
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    ctx.arc(cx, cy, Rcore, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // Axis line (fiber axis, z direction)
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.setLineDash([6,5]);
    ctx.beginPath();
    ctx.moveTo(cx, cy - Rclad - 16);
    ctx.lineTo(cx, cy + Rclad + 16);
    ctx.stroke();
    ctx.restore();

    // Meridional ray zig-zag (projected)
    const thetaMax = Math.acos(Math.min(1, Math.max(0, params.n2/n1)));
    const theta = thetaMax * 0.72;

    // draw "unwrapped" zig-zag along z to the right
    const xStart = W*0.52, yMid = H*0.35;
    const segs = 7;
    const segL = (W*0.42 - 10) / segs;
    const amp = Math.tan(theta) * segL * 0.45; // visual only
    ctx.save();
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(52,211,153,0.80)';
    ctx.beginPath();
    ctx.moveTo(xStart, yMid);
    for(let i=1;i<=segs;i++){
      const x = xStart + segL*i;
      const y = yMid + (i%2===0 ? -amp : amp);
      ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.restore();

    // angle marker
    const x0 = xStart, y0 = yMid;
    const r = 40;
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x0 + r, y0);
    ctx.stroke();

    ctx.strokeStyle = 'rgba(52,211,153,0.75)';
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x0 + r*Math.cos(theta), y0 + r*Math.sin(theta));
    ctx.stroke();

    // small arc
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.beginPath();
    ctx.arc(x0, y0, 26, 0, theta);
    ctx.stroke();
    ctx.restore();

    // Text labels
    ctx.save();
    ctx.fillStyle = txt;
    ctx.font = '800 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText('Step-index fiber', pad, 20);

    ctx.fillStyle = mut;
    ctx.font = '700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText('core (n₁)', cx - 24, cy - 6);
    ctx.fillStyle = faint;
    ctx.fillText('cladding (n₂)', cx - 36, cy + Rcore + 18);

    ctx.fillStyle = 'rgba(52,211,153,0.92)';
    ctx.fillText('meridional ray', xStart, yMid - 14);

    ctx.fillStyle = mut;
    ctx.fillText('θ', xStart + 18, yMid + 10);
    ctx.fillStyle = faint;
    ctx.fillText('z (fiber axis)', cx + 8, cy - Rclad - 10);
    ctx.restore();
  }

  function drawMain(params){
    const {ctx, w:W, h:H} = setupCanvas(cMain);

    const choice = elLaunch.value;
    const ray = rayImpulse(params, choice === 'modeEqual' || choice === 'modeDecay' ? 'sinTheta' : choice);
    const mode = modeImpulse(params, choice);

    // time axis in microseconds, centered around tMin
    const xmin = params.tMin*1e6;
    const xmax = params.tMax*1e6;

    const ax = drawAxes(ctx, W, H, {
      title: 'Received pulse shape after propagation (impulse response)',
      xlabel: 'Arrival time t (µs)',
      ylabel: 'Normalized intensity (a.u.)',
      xmin, xmax,
      ymin: 0, ymax: 1.05,
      xticks: 6, yticks: 5,
      fmtX: v => v.toFixed(3),
      fmtY: v => v.toFixed(2)
    });
    ax.xmin = xmin; ax.xmax = xmax; ax.ymin = 0; ax.ymax = 1.05;

    // draw curves
    function drawCurve(series, color){
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2.6;
      ctx.beginPath();
      for(let i=0;i<series.tAxis.length;i++){
        const x = series.tAxis[i]*1e6;
        const y = series.hist[i];
        const X = xMap(x, ax);
        const Y = yMap(y, ax);
        if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
      }
      ctx.stroke();
      ctx.restore();
    }

    drawCurve(ray, 'rgba(125,211,252,0.95)');  // ray continuum
    drawCurve(mode, 'rgba(167,139,250,0.95)'); // mode spikes

    // vertical lines for tMin and tMax
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.setLineDash([6,5]);
    ctx.lineWidth = 1.6;
    const Xmin = xMap(xmin, ax);
    const Xmax = xMap(xmax, ax);
    ctx.beginPath();
    ctx.moveTo(Xmin, ax.y1);
    ctx.lineTo(Xmin, ax.y0);
    ctx.moveTo(Xmax, ax.y1);
    ctx.lineTo(Xmax, ax.y0);
    ctx.stroke();
    ctx.restore();

    // annotate
    ctx.save();
    ctx.fillStyle = 'rgba(185,195,230,0.95)';
    ctx.font = '700 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText('t_min', Xmin+4, ax.y1+14);
    ctx.fillText('t_max', Xmax-40, ax.y1+14);
    ctx.restore();

    legend(ctx, W, [
      {label:'Ray optics (meridional continuum)', color:'rgba(125,211,252,0.95)'},
      {label:'Wave optics (l=0 discrete modes)', color:'rgba(167,139,250,0.95)'}
    ]);
  }

  function drawSecondary(params){
    const {ctx, w:W, h:H} = setupCanvas(cSecondary);

    const thetaMax = Math.acos(Math.min(1, Math.max(0, params.n2/n1)));
    const degMax = thetaMax * 180/Math.PI;

    // We'll show two series on one axes: ray delay vs theta, and mode delay vs normalized order index.
    // Map x as "normalized parameter": left half uses theta(deg), right half uses mode index.
    // To keep it clear, we plot on two panels within one canvas.
    ctx.clearRect(0,0,W,H);

    const pad = {l:54, r:18, t:34, b:44};
    const gap = 10;
    const panelW = (W - pad.l - pad.r - gap) / 2;
    const panelH = (H - pad.t - pad.b);

    // helper to draw one panel
    function drawPanel(xLeft, title, xlabel, xmin, xmax, ymin, ymax, xticks, yticks, fmtX, fmtY){
      const ax = {
        x0: xLeft, x1: xLeft + panelW,
        y0: H - pad.b, y1: pad.t,
        xmin, xmax, ymin, ymax
      };

      // frame
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.16)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.rect(ax.x0, ax.y1, ax.x1-ax.x0, ax.y0-ax.y1);
      ctx.stroke();
      ctx.restore();

      // title
      ctx.save();
      ctx.fillStyle = 'rgba(233,238,252,0.92)';
      ctx.font = '700 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(title, ax.x0, 20);
      ctx.restore();

      // grid
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      for(let i=0;i<=xticks;i++){
        const x = ax.x0 + (ax.x1-ax.x0)*(i/xticks);
        ctx.beginPath();
        ctx.moveTo(x, ax.y1);
        ctx.lineTo(x, ax.y0);
        ctx.stroke();
      }
      for(let j=0;j<=yticks;j++){
        const y = ax.y0 - (ax.y0-ax.y1)*(j/yticks);
        ctx.beginPath();
        ctx.moveTo(ax.x0, y);
        ctx.lineTo(ax.x1, y);
        ctx.stroke();
      }
      ctx.restore();

      // labels
      ctx.save();
      ctx.fillStyle = 'rgba(185,195,230,0.95)';
      ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(xlabel, ax.x0 + panelW/2 - 55, H-12);
      // y label (shared, draw only on left panel)
      ctx.restore();

      // ticks
      ctx.save();
      ctx.fillStyle = 'rgba(185,195,230,0.90)';
      ctx.font = '500 11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      for(let i=0;i<=xticks;i++){
        const x = ax.x0 + (ax.x1-ax.x0)*(i/xticks);
        const v = xmin + (xmax-xmin)*(i/xticks);
        ctx.fillText(fmtX(v), x-12, ax.y0+16);
      }
      for(let j=0;j<=yticks;j++){
        const y = ax.y0 - (ax.y0-ax.y1)*(j/yticks);
        const v = ymin + (ymax-ymin)*(j/yticks);
        // only label y on left-most panel for cleanliness
        if(xLeft === pad.l) ctx.fillText(fmtY(v), 6, y+4);
      }
      ctx.restore();

      return ax;
    }

    const tMinUs = params.tMin*1e6;
    const tMaxUs = params.tMax*1e6;

    // Left panel: rays
    const axR = drawPanel(pad.l, 'Ray delay vs meridional angle', 'θ (deg)', 0, degMax, tMinUs, tMaxUs, 5, 5,
      v=>v.toFixed(0), v=>v.toFixed(3)
    );

    // y label (shared)
    ctx.save();
    ctx.fillStyle = 'rgba(185,195,230,0.95)';
    ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.translate(14, pad.t + panelH/2 + 40);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('Arrival time t (µs)', 0, 0);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.restore();

    // plot ray curve
    ctx.save();
    ctx.strokeStyle = 'rgba(125,211,252,0.95)';
    ctx.lineWidth = 2.6;
    ctx.beginPath();
    const N = 400;
    for(let i=0;i<N;i++){
      const theta = thetaMax * (i/(N-1));
      const deg = theta*180/Math.PI;
      const t = (params.tMin)*(1/Math.cos(Math.max(1e-9, theta))) * 1e6;
      const X = axR.x0 + (axR.x1-axR.x0)*((deg-axR.xmin)/(axR.xmax-axR.xmin));
      const Y = axR.y0 - (axR.y0-axR.y1)*((t-axR.ymin)/(axR.ymax-axR.ymin));
      if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
    }
    ctx.stroke();
    ctx.restore();

    // Right panel: modes
    const M0 = Math.max(1, params.M0);
    const axM = drawPanel(pad.l + panelW + gap, 'Mode delay vs l=0 order', 'Mode index m', 1, M0, tMinUs, tMaxUs, 5, 5,
      v=>Math.round(v).toString(), v=>v.toFixed(3)
    );

    // plot mode points
    ctx.save();
    ctx.fillStyle = 'rgba(167,139,250,0.95)';
    for(const mt of params.modeTimes){
      const x = mt.m;
      const t = mt.t*1e6;
      const X = axM.x0 + (axM.x1-axM.x0)*((x-axM.xmin)/(axM.xmax-axM.xmin));
      const Y = axM.y0 - (axM.y0-axM.y1)*((t-axM.ymin)/(axM.ymax-axM.ymin));
      ctx.beginPath();
      ctx.arc(X, Y, 3.4, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // small legend
    ctx.save();
    ctx.font = '700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.fillText('Series:', pad.l, 34);
    ctx.fillStyle = 'rgba(125,211,252,0.95)';
    ctx.fillRect(pad.l+58, 25, 14, 8);
    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.fillText('rays', pad.l+78, 34);

    ctx.fillStyle = 'rgba(167,139,250,0.95)';
    ctx.fillRect(pad.l+122, 25, 14, 8);
    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.fillText('modes', pad.l+142, 34);
    ctx.restore();
  }

  // -------------------------
  // Update stats text
  // -------------------------
  function updateStats(params){
    elLenVal.textContent = params.Lkm.toFixed(2) + ' km';
    elNATxt.textContent = params.NA.toFixed(3);

    stat_n2.textContent = params.n2.toFixed(5);
    stat_Delta.textContent = params.Delta.toFixed(6);
    stat_V.textContent = params.V.toFixed(2);
    stat_M0.textContent = params.M0.toString();

    stat_dT.textContent = (params.dT*1e9).toFixed(2) + ' ns';

    // Also update the displayed numbers in the solution boxes once (for the default).
    // (We keep the solution text static; these stats give the live values.)
  }

  // -------------------------
  // Copy buttons
  // -------------------------
  function installCopyButtons(){
    function textFromSelector(sel){
      const el = document.querySelector(sel);
      return el ? el.textContent.trim() : '';
    }
    document.querySelectorAll('.copyBtn[data-copy]').forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        const sel = btn.getAttribute('data-copy');
        const txt = textFromSelector(sel);
        try{
          await navigator.clipboard.writeText(txt);
          const old = btn.textContent;
          btn.textContent = 'Copied ✓';
          setTimeout(()=>btn.textContent = old, 900);
        }catch(e){
          // fallback
          const ta = document.createElement('textarea');
          ta.value = txt;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
          const old = btn.textContent;
          btn.textContent = 'Copied ✓';
          setTimeout(()=>btn.textContent = old, 900);
        }
      });
    });
  }

  // -------------------------
  // Render loop
  // -------------------------
  function render(){
    const params = computeParams();
    updateStats(params);
    drawDiagram(params);
    drawMain(params);
    drawSecondary(params);
  }

  // Events
  elLen.addEventListener('input', render);
  elNA.addEventListener('input', render);
  elLaunch.addEventListener('change', render);
  window.addEventListener('resize', render);

  // Initialize
  installCopyButtons();

  // Fill in the static numerical values shown in PART 3 for the default parameters
  // (These are not re-written continuously to keep the article readable; live values appear in the stats panel.)
  (function fillDefaults(){
    const params = computeParams();
    const num_n2 = document.getElementById('num_n2');
    const num_Delta = document.getElementById('num_Delta');
    const num_V = document.getElementById('num_V');
    if(num_n2) num_n2.textContent = 'n2 ≈ ' + params.n2.toFixed(5);
    if(num_Delta) num_Delta.textContent = 'Δ = (n1−n2)/n1 ≈ ' + params.Delta.toFixed(5);
    if(num_V) num_V.textContent = 'With a=45 μm, λ=1.3 μm, NA=0.16: V ≈ ' + params.V.toFixed(1);
  })();

  render();
})();
</script>
</body>
</html>
