<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Single-Mode Cutoff of a Step-Index Fiber (V-number) + Guided Modes at λc/2</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --card2:#0f1730;
      --ink:#e9eefc;
      --muted:#b9c4ea;
      --faint:#7f8bb8;
      --accent:#7aa2ff;
      --accent2:#7dffcc;
      --warn:#ffcf6f;
      --danger:#ff6b7a;
      --ok:#6dff7d;
      --line:rgba(255,255,255,.10);
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1200px 700px at 20% 0%, rgba(122,162,255,.22), transparent 60%),
        radial-gradient(900px 600px at 100% 10%, rgba(125,255,204,.14), transparent 55%),
        radial-gradient(900px 700px at 60% 100%, rgba(255,207,111,.10), transparent 60%),
        var(--bg);
      line-height:1.6;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding: 28px 18px 10px;
    }
    .wrap{
      max-width: 1180px;
      margin: 0 auto;
      padding: 0 18px 50px;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap:18px;
      align-items:stretch;
    }
    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 18px 16px;
      position:relative;
      overflow:hidden;
    }
    .titleCard:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(600px 200px at 20% 0%, rgba(122,162,255,.20), transparent 60%);
      pointer-events:none;
      filter: blur(0px);
      opacity:.9;
    }
    .titleCard > *{position:relative}
    h1{
      margin:0 0 6px;
      font-size: clamp(1.45rem, 2.2vw, 2.05rem);
      letter-spacing: .2px;
    }
    .subtitle{
      margin: 0 0 10px;
      color: var(--muted);
      max-width: 70ch;
    }
    .pillRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:10px;
    }
    .pill{
      font-size:.85rem;
      color: var(--muted);
      background: rgba(255,255,255,.06);
      border:1px solid var(--line);
      padding: 6px 10px;
      border-radius: 999px;
      backdrop-filter: blur(6px);
    }
    .sideCard{
      background: rgba(17,26,51,.72);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px;
    }
    .sideCard h2{
      margin:0 0 8px;
      font-size: 1.05rem;
      color: var(--muted);
      letter-spacing:.2px;
    }
    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 6px 10px;
      font-size: .95rem;
      align-items:baseline;
    }
    .kv .k{color: var(--faint)}
    .kv .v{font-family: var(--mono); color: var(--ink)}
    main{
      display:grid;
      grid-template-columns: 310px 1fr;
      gap: 18px;
      margin-top: 16px;
      align-items:start;
    }
    nav.toc{
      position:sticky;
      top: 14px;
      align-self:start;
      background: rgba(17,26,51,.66);
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding: 12px 12px 10px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .toc h3{
      margin:0 0 8px;
      font-size: .98rem;
      color: var(--muted);
      letter-spacing:.2px;
    }
    .toc a{
      display:block;
      padding: 7px 10px;
      border-radius: 12px;
      color: var(--muted);
      border: 1px solid transparent;
      margin: 4px 0;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .toc a:hover{
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.10);
      transform: translateX(2px);
      text-decoration:none;
    }
    .content{
      display:flex;
      flex-direction:column;
      gap:18px;
    }
    section, article{
      background: rgba(17,26,51,.62);
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding: 16px 16px 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    section h2, article h2{
      margin: 2px 0 10px;
      font-size: 1.25rem;
      letter-spacing:.2px;
    }
    section h3{
      margin: 12px 0 8px;
      font-size: 1.05rem;
      color: var(--muted);
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .callout{
      border-radius: 16px;
      padding: 12px 12px 10px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
    }
    .callout strong{color: var(--ink)}
    .callout.warn{border-color: rgba(255,207,111,.35); background: rgba(255,207,111,.07)}
    .callout.ok{border-color: rgba(125,255,204,.35); background: rgba(125,255,204,.07)}
    .callout.bad{border-color: rgba(255,107,122,.35); background: rgba(255,107,122,.07)}
    .eqBox{
      position:relative;
      border-radius: 16px;
      padding: 12px 12px 10px;
      background: rgba(11,16,32,.55);
      border: 1px solid rgba(122,162,255,.26);
      overflow:hidden;
    }
    .eqBox:before{
      content:"";
      position:absolute; inset:-1px;
      background: radial-gradient(500px 120px at 20% 0%, rgba(122,162,255,.20), transparent 70%);
      pointer-events:none;
    }
    .eqBox > *{position:relative}
    .equation{
      font-family: var(--mono);
      font-size: .98rem;
      white-space: pre-wrap;
      margin: 0;
      color: var(--ink);
    }
    .copyBtn{
      position:absolute;
      top:10px; right:10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--muted);
      padding: 6px 10px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease;
      font-size: .86rem;
    }
    .copyBtn:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .copyBtn:active{transform: translateY(0px)}
    ul{margin: 8px 0 0 20px}
    li{margin: 6px 0}
    .mathInline{
      font-family: var(--mono);
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      padding: 2px 6px;
      border-radius: 10px;
      white-space: nowrap;
    }
    .vizGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    figure{
      margin:0;
      background: rgba(11,16,32,.45);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      overflow:hidden;
    }
    figcaption{
      padding: 10px 12px;
      color: var(--muted);
      font-size: .92rem;
      border-top: 1px solid rgba(255,255,255,.08);
    }
    canvas{
      width: 100%;
      height: 320px;
      display:block;
    }
    .controls{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 10px;
      align-items:end;
      margin-top: 10px;
    }
    .ctrl{
      grid-column: span 6;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 10px 12px 10px;
    }
    .ctrl label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      color: var(--muted);
      font-size: .92rem;
      margin-bottom: 8px;
    }
    .ctrl .val{
      font-family: var(--mono);
      color: var(--ink);
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .readoutRow{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .readout{
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 10px 12px;
    }
    .readout .k{color: var(--faint); font-size:.9rem}
    .readout .v{font-family: var(--mono); font-size: 1.02rem; margin-top:4px}
    .modeList{
      margin-top: 8px;
      padding: 10px 12px;
      border-radius: 16px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
    }
    .modeList .hdr{
      display:flex;
      justify-content:space-between;
      color: var(--muted);
      font-size:.92rem;
      margin-bottom:6px;
      gap:10px;
    }
    .chips{display:flex; flex-wrap:wrap; gap:8px}
    .chip{
      font-family: var(--mono);
      font-size: .9rem;
      padding: 5px 9px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--ink);
    }
    .chip.off{
      color: var(--faint);
      border-color: rgba(255,255,255,.08);
      background: rgba(255,255,255,.04);
    }
    footer{
      color: var(--faint);
      padding: 18px;
      text-align:center;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns: 1fr}
      main{grid-template-columns: 1fr}
      nav.toc{position:relative; top:auto}
      .grid2{grid-template-columns:1fr}
      .controls .ctrl{grid-column: span 12}
      canvas{height: 300px}
      .readoutRow{grid-template-columns:1fr}
    }
    @media print{
      body{background:#fff; color:#000}
      header, nav.toc, .controls, .copyBtn{display:none !important}
      section, article, .titleCard, .sideCard, figure{box-shadow:none; backdrop-filter:none}
      section, article, .titleCard, .sideCard{border:1px solid #ddd}
      .mathInline{border:1px solid #ddd}
    }
  </style>
</head>

<body>
<header class="wrap">
  <div class="hero">
    <div class="titleCard">
      <h1>Step-Index Fiber Modes via the V-number: single-mode cutoff wavelength and guided modes at λ<sub>c</sub>/2</h1>
      <p class="subtitle">
        We use the weakly-guiding step-index fiber model to connect geometry and refractive indices to the normalized frequency
        <span class="mathInline">V</span>. The fiber is single-mode when <span class="mathInline">V &lt; 2.405</span>.
        Then we use mode cutoffs (Bessel-function zeros) to list all guided <span class="mathInline">LP<sub>l m</sub></span> modes at a shorter wavelength.
      </p>
      <div class="pillRow">
        <span class="pill">Model: weak guidance (Δ ≪ 1)</span>
        <span class="pill">Key parameter: V-number</span>
        <span class="pill">Single-mode when V &lt; 2.405</span>
        <span class="pill">Mode cutoffs: Bessel zeros</span>
      </div>
    </div>

    <aside class="sideCard" aria-label="Given parameters and headline results">
      <h2>Given (problem data)</h2>
      <div class="kv">
        <div class="k">Core radius</div><div class="v">a = 5 μm</div>
        <div class="k">Core index</div><div class="v">n₁ = 1.45</div>
        <div class="k">Fractional index change</div><div class="v">Δ = 0.002</div>
      </div>
      <hr style="border:none;border-top:1px solid rgba(255,255,255,.10); margin:12px 0;">
      <h2>Headline answers</h2>
      <div class="kv" id="headline">
        <div class="k">NA ≈</div><div class="v" id="naHeadline">—</div>
        <div class="k">Single-mode cutoff λc ≈</div><div class="v" id="lcHeadline">—</div>
        <div class="k">At λ = λc/2, V ≈</div><div class="v" id="vHalfHeadline">—</div>
      </div>
    </aside>
  </div>
</header>

<main class="wrap">
  <nav class="toc" aria-label="Table of contents">
    <h3>Table of Contents</h3>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
  </nav>

  <div class="content">
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li>This problem is about <strong>mode guidance</strong> in a <strong>step-index optical fiber</strong> with given radius and indices.</li>
        <li>The key physics idea is that the number of guided modes is controlled by the <span class="mathInline">V</span>-number (normalized frequency).</li>
        <li>For a step-index fiber (weak guidance), <span class="mathInline">V = (2πa/λ)·NA</span>, where <span class="mathInline">NA ≈ n₁√(2Δ)</span> for small Δ.</li>
        <li>The fiber is <strong>single-mode</strong> (only <span class="mathInline">LP₀₁</span>) when <span class="mathInline">V &lt; 2.405</span> (first zero of <span class="mathInline">J₀</span>).</li>
        <li>The shortest wavelength for single-mode is the <strong>cutoff wavelength</strong> <span class="mathInline">λc = 2πa·NA / 2.405</span> (numeric here).</li>
        <li>If wavelength is halved to <span class="mathInline">λc/2</span>, then <span class="mathInline">V</span> doubles, and additional <span class="mathInline">LP<sub>l m</sub></span> modes whose cutoffs satisfy <span class="mathInline">V &gt; Vc</span> become guided.</li>
        <li>Final results are primarily <strong>numeric</strong> for <span class="mathInline">λc</span> and a <strong>mode index list</strong> at <span class="mathInline">λc/2</span>.</li>
      </ul>
    </section>

    <article id="part0">
      <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

      <div class="grid2">
        <div class="callout">
          <h3 style="margin-top:0">Core definitions (symbols & units)</h3>
          <ul>
            <li><span class="mathInline">a</span> — core radius (m).</li>
            <li><span class="mathInline">n₁</span>, <span class="mathInline">n₂</span> — refractive indices of core and cladding (dimensionless), with <span class="mathInline">n₁ &gt; n₂</span>.</li>
            <li><span class="mathInline">Δ</span> — fractional index difference (dimensionless). In fiber optics a common definition is
              <span class="mathInline">Δ = (n₁² − n₂²)/(2 n₁²)</span> (≈ <span class="mathInline">(n₁ − n₂)/n₁</span> when Δ ≪ 1).</li>
            <li><span class="mathInline">NA</span> — numerical aperture (dimensionless): <span class="mathInline">NA = √(n₁² − n₂²)</span> (in air).</li>
            <li><span class="mathInline">λ</span> — vacuum wavelength (m).</li>
            <li><span class="mathInline">V</span> — normalized frequency (dimensionless): <span class="mathInline">V = (2π a/λ)·NA</span>.</li>
            <li><span class="mathInline">LP<sub>l m</sub></span> — linearly polarized mode indices: azimuthal index <span class="mathInline">l</span> and radial index <span class="mathInline">m</span>.</li>
          </ul>
        </div>

        <div class="callout ok">
          <h3 style="margin-top:0">Physical meaning (why these quantities matter)</h3>
          <ul>
            <li><span class="mathInline">NA</span> measures how strongly the fiber confines light: larger index contrast → larger NA → more modes.</li>
            <li><span class="mathInline">V</span> is essentially “core size measured in wavelengths,” weighted by confinement. Increasing <span class="mathInline">a</span>, <span class="mathInline">NA</span>, or decreasing <span class="mathInline">λ</span> increases <span class="mathInline">V</span>.</li>
            <li>Each guided mode has a cutoff condition <span class="mathInline">V &gt; Vc</span>. As <span class="mathInline">V</span> increases, more modes appear.</li>
            <li>The single-mode condition is a practical design rule: keep <span class="mathInline">V</span> below the first higher-order cutoff.</li>
          </ul>
        </div>
      </div>

      <h3>Key laws/principles & validity</h3>
      <ul>
        <li><strong>Maxwell → wave equation</strong> in dielectric media leads to guided modes in a cylindrical waveguide.</li>
        <li><strong>Step-index fiber + weak guidance</strong>: when <span class="mathInline">Δ ≪ 1</span>, vector modes group into nearly linearly polarized families <span class="mathInline">LP<sub>l m</sub></span>.</li>
        <li><strong>Cutoff physics</strong>: a mode reaches cutoff when its cladding decay constant goes to zero (field stops being evanescent in the cladding). In the scalar model this connects to zeros of Bessel functions.</li>
      </ul>

      <h3>Common models/approximations (and why we use them)</h3>
      <ul>
        <li><strong>Weakly guiding approximation</strong> (<span class="mathInline">Δ ≪ 1</span>): simplifies full vector eigenvalue equations into scalar-like conditions and gives simple, accurate design rules (especially for silica fibers).</li>
        <li><strong>LP mode labeling</strong>: replaces the exact hybrid modes (HE/EH/TE/TM) by <span class="mathInline">LP<sub>l m</sub></span> families with nearly the same cutoff values. Great for counting modes and estimating single-mode operation.</li>
      </ul>

      <div class="grid2">
        <div class="callout">
          <h3 style="margin-top:0">Mini intuition examples</h3>
          <ul>
            <li>If you double the radius <span class="mathInline">a</span>, you double <span class="mathInline">V</span> at fixed <span class="mathInline">λ</span> → roughly twice “room” for transverse standing-wave patterns → more modes.</li>
            <li>If you halve the wavelength <span class="mathInline">λ</span>, you double <span class="mathInline">V</span> → higher-order modes that were previously cut off can become guided.</li>
          </ul>
        </div>
        <div class="callout warn">
          <h3 style="margin-top:0">What to watch for (pitfalls)</h3>
          <ul>
            <li>Confusing the different definitions of <span class="mathInline">Δ</span>. Here we use the common fiber definition <span class="mathInline">Δ=(n₁²−n₂²)/(2n₁²)</span>, which yields <span class="mathInline">NA ≈ n₁√(2Δ)</span>.</li>
            <li>For single-mode, the cutoff is <span class="mathInline">V=2.405</span> (first zero of <span class="mathInline">J₀</span>), not <span class="mathInline">π</span> or some ray-optics angle.</li>
            <li>Remember: <span class="mathInline">LP₀₁</span> has no cutoff (it exists for any <span class="mathInline">V &gt; 0</span>), but single-mode requires no other modes be allowed.</li>
          </ul>
        </div>
      </div>
    </article>

    <article id="part1">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>Restate the problem</h3>
      <p>
        A step-index optical fiber has core radius <span class="mathInline">a = 5 μm</span>, core index
        <span class="mathInline">n₁ = 1.45</span>, and fractional index change <span class="mathInline">Δ = 0.002</span>.
        (1) Find the <strong>shortest wavelength</strong> <span class="mathInline">λc</span> for which the fiber remains <strong>single-mode</strong>.
        (2) If the wavelength becomes <span class="mathInline">λc/2</span>, list the indices <span class="mathInline">(l,m)</span> of <strong>all guided modes</strong>.
      </p>

      <div class="grid2">
        <div class="callout">
          <h3 style="margin-top:0">Given quantities</h3>
          <ul>
            <li><span class="mathInline">a = 5×10⁻⁶ m</span></li>
            <li><span class="mathInline">n₁ = 1.45</span></li>
            <li><span class="mathInline">Δ = 0.002</span> (weak guidance: small)</li>
          </ul>
        </div>
        <div class="callout">
          <h3 style="margin-top:0">Unknowns / tasks</h3>
          <ul>
            <li>Compute <span class="mathInline">NA</span> and then the single-mode cutoff wavelength <span class="mathInline">λc</span>.</li>
            <li>At <span class="mathInline">λ=λc/2</span>, compute the new <span class="mathInline">V</span> and list all <span class="mathInline">LP<sub>l m</sub></span> modes with <span class="mathInline">Vc &lt; V</span>.</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles and why they apply</h3>
      <ul>
        <li><strong>Normalized frequency (V-number)</strong> governs modal content in step-index fibers. It directly uses the given geometry (<span class="mathInline">a</span>) and indices (<span class="mathInline">n₁</span>, via <span class="mathInline">NA</span>).</li>
        <li><strong>Single-mode condition</strong> uses the cutoff of the first higher-order LP mode:
          <span class="mathInline">V &lt; 2.405</span>, where <span class="mathInline">2.405</span> is the first zero of <span class="mathInline">J₀</span>.</li>
        <li>We do <em>not</em> need full vector mode solving because Δ is small, and the problem asks for mode indices (counting), not detailed field profiles.</li>
      </ul>

      <div class="callout warn">
        <strong>Assumptions (explicit):</strong>
        <ul>
          <li>Step-index cylindrical fiber with uniform core index <span class="mathInline">n₁</span> and uniform cladding index <span class="mathInline">n₂</span>.</li>
          <li>Weakly guiding: <span class="mathInline">Δ ≪ 1</span>, so LP mode approximation and standard cutoff values apply.</li>
          <li>Surrounding medium is air (so <span class="mathInline">NA = √(n₁² − n₂²)</span> in the usual fiber sense).</li>
        </ul>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ul>
        <li><strong>Approach A: V-number design rule (best here)</strong> —
          compute <span class="mathInline">NA</span>, form <span class="mathInline">V</span>, enforce <span class="mathInline">V=2.405</span> to get <span class="mathInline">λc</span>, then use known LP cutoffs to list modes. <em>Fast, accurate, standard.</em></li>
        <li><strong>Approach B: Full eigenvalue equations (vector HE/EH/TE/TM)</strong> —
          solve transcendental boundary conditions numerically. <em>More exact, but overkill for this problem.</em></li>
        <li><strong>Approach C: Ray optics / acceptance angle reasoning</strong> —
          useful for NA intuition, but insufficient to get correct single-mode cutoffs. <em>Not recommended for mode counting.</em></li>
      </ul>

      <p><strong>Chosen approach:</strong> Approach A (V-number + LP cutoffs), because Δ is small and the question is explicitly about single-mode cutoff and guided-mode indices.</p>
    </article>

    <article id="part2">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>
      <ol>
        <li><strong>Goal:</strong> Convert Δ to <span class="mathInline">NA</span>. <strong>Tool:</strong> weak-guidance relation <span class="mathInline">NA ≈ n₁√(2Δ)</span>. <strong>Meaning:</strong> confinement strength.</li>
        <li><strong>Goal:</strong> Write <span class="mathInline">V(λ)</span>. <strong>Tool:</strong> <span class="mathInline">V=(2πa/λ)·NA</span>. <strong>Meaning:</strong> “how many transverse oscillations fit.”</li>
        <li><strong>Goal:</strong> Find <span class="mathInline">λc</span> for single-mode. <strong>Tool:</strong> set <span class="mathInline">V(λc)=2.405</span>. <strong>Meaning:</strong> first higher-order LP mode is just at cutoff.</li>
        <li><strong>Goal:</strong> Evaluate <span class="mathInline">V</span> at <span class="mathInline">λ=λc/2</span>. <strong>Tool:</strong> scaling <span class="mathInline">V ∝ 1/λ</span>. <strong>Meaning:</strong> halving wavelength doubles V.</li>
        <li><strong>Goal:</strong> List guided modes. <strong>Tool:</strong> include all <span class="mathInline">LP<sub>l m</sub></span> with cutoff <span class="mathInline">Vc</span> less than the new V, using Bessel zeros.</li>
      </ol>

      <div class="grid2">
        <div class="callout warn">
          <strong>Common mistakes</strong>
          <ul>
            <li>Using <span class="mathInline">NA = √(2Δ)</span> without the factor <span class="mathInline">n₁</span>.</li>
            <li>Forgetting units: use meters in <span class="mathInline">λ</span> and <span class="mathInline">a</span>.</li>
            <li>Listing too many modes at <span class="mathInline">λc/2</span> by using the wrong cutoff sequence (wrong Bessel order).</li>
          </ul>
        </div>
        <div class="callout ok">
          <strong>Quick tips</strong>
          <ul>
            <li>At cutoff, the cladding decay constant goes to zero ⇒ the cutoff V equals a Bessel zero.</li>
            <li>Single-mode cutoff is tied to <span class="mathInline">LP₁₁</span> (first higher-order), with <span class="mathInline">Vc≈2.405</span>.</li>
            <li>At <span class="mathInline">λc/2</span>, just remember: <span class="mathInline">V</span> doubles — then compare against known cutoff values.</li>
          </ul>
        </div>
      </div>
    </article>

    <article id="part3">
      <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

      <h3>Physical intuition first (before numbers)</h3>
      <p>
        A fiber supports more modes when the core is “electrically larger” (larger <span class="mathInline">a/λ</span>) and when confinement is stronger (larger <span class="mathInline">NA</span>).
        Therefore, the <strong>shortest</strong> wavelength that is still single-mode will occur when <span class="mathInline">V</span> is as large as allowed for single-mode:
        right at the cutoff of the first higher-order mode, <span class="mathInline">V=2.405</span>.
        If we then halve the wavelength, <span class="mathInline">V</span> doubles and several higher-order modes will become guided.
      </p>

      <div class="eqBox" style="margin-top:10px;">
        <button class="copyBtn" data-copy="Definitions (step-index, weak guidance):
Delta = (n1^2 - n2^2)/(2 n1^2)
NA = sqrt(n1^2 - n2^2) ≈ n1*sqrt(2*Delta)
V = (2*pi*a/λ)*NA
Single-mode condition: V < 2.405">Copy</button>
        <p class="equation">
Definitions (step-index, weak guidance):
Δ = (n₁² − n₂²) / (2 n₁²)
NA = √(n₁² − n₂²) ≈ n₁ √(2Δ)
V = (2π a / λ) · NA
Single-mode condition: V &lt; 2.405
        </p>
      </div>

      <h3>Step 1 — Compute the cladding index and NA from Δ</h3>
      <p>
        Using the standard fiber definition <span class="mathInline">Δ = (n₁² − n₂²)/(2 n₁²)</span>, solve for <span class="mathInline">n₂</span>:
      </p>
      <div class="eqBox">
        <button class="copyBtn" data-copy="n2 = n1*sqrt(1 - 2*Delta)
NA = sqrt(n1^2 - n2^2) = n1*sqrt(2*Delta)">Copy</button>
        <p class="equation">
n₂² = n₁² (1 − 2Δ)  ⇒  n₂ = n₁ √(1 − 2Δ)
NA = √(n₁² − n₂²) = n₁ √(2Δ)
        </p>
      </div>
      <p>
        Plug in <span class="mathInline">n₁=1.45</span> and <span class="mathInline">Δ=0.002</span>:
      </p>
      <div class="eqBox">
        <button class="copyBtn" data-copy="NA = n1*sqrt(2*Delta) = 1.45*sqrt(0.004) ≈ 0.0917">Copy</button>
        <p class="equation">
NA = 1.45 √(2×0.002) = 1.45 √(0.004) ≈ 1.45×0.0632456 ≈ 0.0917
        </p>
      </div>
      <p>
        <strong>Meaning:</strong> the fiber has a modest numerical aperture (~0.092), typical of weakly guiding silica fibers.
      </p>

      <h3>Step 2 — Single-mode cutoff wavelength λc</h3>
      <p>
        The normalized frequency is <span class="mathInline">V=(2πa/λ)·NA</span>. Single-mode operation requires the first higher-order mode to be cut off:
        <span class="mathInline">V(λc)=2.405</span>. Solve for <span class="mathInline">λc</span>:
      </p>

      <div class="eqBox">
        <button class="copyBtn" data-copy="λc = (2*pi*a*NA)/2.405">Copy</button>
        <p class="equation">
V(λc)=2.405 = (2π a / λc)·NA
⇒  λc = (2π a NA) / 2.405
        </p>
      </div>

      <p>
        Substitute <span class="mathInline">a=5 μm = 5×10⁻⁶ m</span> and <span class="mathInline">NA≈0.0917</span>:
      </p>

      <div class="eqBox">
        <button class="copyBtn" data-copy="λc ≈ (2*pi*(5e-6)*0.091706)/2.405 ≈ 1.20e-6 m = 1.20 μm">Copy</button>
        <p class="equation">
λc ≈ (2π)(5×10⁻⁶ m)(0.0917) / 2.405
   ≈ 1.198×10⁻⁶ m
   ≈ 1.20 μm
        </p>
      </div>

      <div class="callout ok" id="finalAnswerBox" style="margin-top:12px;">
        <strong>Final (part 1):</strong> The shortest single-mode wavelength is
        <span class="mathInline">λc ≈ 1.20 μm</span>.
        <button class="copyBtn" style="position:relative; top:auto; right:auto; margin-left:10px;"
          data-copy="Shortest single-mode wavelength:
λc = (2π a NA)/2.405, with NA ≈ n1√(2Δ).
For a=5 μm, n1=1.45, Δ=0.002:
NA ≈ 0.0917 and λc ≈ 1.20 μm.">Copy final</button>
      </div>

      <h3>Step 3 — At λ = λc/2, find V</h3>
      <p>
        Because <span class="mathInline">V ∝ 1/λ</span>, halving the wavelength doubles <span class="mathInline">V</span>:
      </p>
      <div class="eqBox">
        <button class="copyBtn" data-copy="V(λc/2) = 2*V(λc) = 2*2.405 = 4.810">Copy</button>
        <p class="equation">
V(λc/2) = (2π a / (λc/2))·NA = 2(2π a / λc)·NA = 2 V(λc)
⇒ V(λc/2) = 2×2.405 = 4.810
        </p>
      </div>

      <h3>Step 4 — Guided mode indices (l, m) at V = 4.810</h3>
      <p>
        In the weakly guiding step-index model, LP modes appear when <span class="mathInline">V</span> exceeds a cutoff value <span class="mathInline">Vc</span>.
        At cutoff, the cladding field stops decaying (the decay parameter goes to zero), and the scalar boundary condition reduces to a Bessel-zero rule.
      </p>

      <div class="eqBox">
        <button class="copyBtn" data-copy="LP mode cutoffs (weak guidance, step-index):
For l >= 1: Vc(LP_lm) = j_(l-1,m)  (m-th zero of J_{l-1})
For l = 0, m >= 2: Vc(LP_0m) = j_(1,m-1)  (zeros of J1)
LP_01: Vc = 0 (always guided for any V>0)">Copy</button>
        <p class="equation">
LP mode cutoffs (weak guidance, step-index):
• LP₀₁ has no cutoff: Vc = 0.
• For l ≥ 1:    Vc(LP_lm) = j_{l−1,m}   (m-th zero of J_{l−1})
• For l = 0, m ≥ 2: Vc(LP_0m) = j_{1,m−1} (zeros of J₁)
        </p>
      </div>

      <p>
        We compare <span class="mathInline">V=4.810</span> to the first few Bessel zeros:
      </p>
      <ul>
        <li><span class="mathInline">j_{0,1} ≈ 2.405</span> ⇒ <span class="mathInline">LP₁₁</span> turns on at 2.405.</li>
        <li><span class="mathInline">j_{1,1} ≈ 3.832</span> ⇒ modes tied to <span class="mathInline">J₁</span> zeros turn on at 3.832 (e.g., <span class="mathInline">LP₂₁</span> and <span class="mathInline">LP₀₂</span>).</li>
        <li>The next relevant zeros are <span class="mathInline">j_{2,1}≈5.136</span> and <span class="mathInline">j_{0,2}≈5.520</span>, both &gt; 4.810, so their modes are still cut off.</li>
      </ul>

      <div class="callout" style="border-color: rgba(122,162,255,.30); background: rgba(122,162,255,.07)">
        <strong>Therefore, at λ = λc/2 (so V = 4.810), the guided LP modes are:</strong>
        <div style="margin-top:8px; font-family:var(--mono); font-size:1.02rem">
          (l,m) = (0,1), (1,1), (2,1), (0,2)
        </div>
        <div style="color:var(--muted); margin-top:6px">
          i.e. <span class="mathInline">LP₀₁</span>, <span class="mathInline">LP₁₁</span>, <span class="mathInline">LP₂₁</span>, and <span class="mathInline">LP₀₂</span>.
        </div>
      </div>

      <h3>Sanity checks</h3>
      <div class="grid2">
        <div class="callout ok">
          <strong>Units/dimensions:</strong>
          <ul>
            <li><span class="mathInline">NA</span> and <span class="mathInline">V</span> are dimensionless.</li>
            <li><span class="mathInline">λc</span> computed from <span class="mathInline">2π a NA / 2.405</span> has units of length (since only <span class="mathInline">a</span> carries meters).</li>
          </ul>
        </div>
        <div class="callout">
          <strong>Limiting-case reasoning:</strong>
          <ul>
            <li>If <span class="mathInline">Δ → 0</span> then <span class="mathInline">NA → 0</span> and <span class="mathInline">λc → 0</span>: with no index contrast, you cannot guide (consistent).</li>
            <li>If <span class="mathInline">a</span> increases, <span class="mathInline">λc</span> increases: bigger core needs longer wavelength to stay single-mode (standard design intuition).</li>
          </ul>
        </div>
      </div>

      <p>
        Connection to the figures below: the diagram shows the step-index geometry (core radius <span class="mathInline">a</span>, indices <span class="mathInline">n₁,n₂</span>).
        The main plot shows <span class="mathInline">V(λ)</span> crossing the single-mode boundary at <span class="mathInline">λc</span>.
        The cutoff chart shows which <span class="mathInline">LP<sub>l m</sub></span> modes are allowed at the current <span class="mathInline">V</span> set by the slider.
      </p>
    </article>

    <article id="part4">
      <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

      <h3>Re-interpreting the final formula</h3>
      <p>
        The cutoff wavelength
        <span class="mathInline">λc = (2π a NA)/2.405</span>
        makes the design knobs explicit:
      </p>
      <ul>
        <li><span class="mathInline">a</span> (core radius): larger core → larger <span class="mathInline">V</span> at a given <span class="mathInline">λ</span> → must use longer <span class="mathInline">λ</span> to stay single-mode.</li>
        <li><span class="mathInline">NA</span> (index contrast): larger NA → stronger confinement → more modes → single-mode requires longer <span class="mathInline">λ</span>.</li>
        <li><span class="mathInline">2.405</span> is not arbitrary; it is the first zero of <span class="mathInline">J₀</span> and corresponds to the cutoff of <span class="mathInline">LP₁₁</span> in the weak-guidance scalar picture.</li>
      </ul>

      <h3>How parameter changes affect outcomes (connect to interactive plots)</h3>
      <ul>
        <li>Decrease <span class="mathInline">λ</span> (move the wavelength slider left): <span class="mathInline">V</span> increases, and the cutoff chart will “activate” more modes.</li>
        <li>Increase <span class="mathInline">Δ</span>: NA increases as <span class="mathInline">√Δ</span>, so the entire <span class="mathInline">V(λ)</span> curve shifts upward, increasing mode count at fixed <span class="mathInline">λ</span>.</li>
        <li>Increase <span class="mathInline">a</span>: linear increase in <span class="mathInline">V</span>, also shifting the curve upward.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        Instead of using the LP cutoff rule directly, you can start from the full step-index fiber eigenvalue equations
        (vector boundary conditions for HE/EH/TE/TM modes), then take the <span class="mathInline">Δ≪1</span> limit.
        In that limit, the first higher-order cutoff collapses to the same numerical value <span class="mathInline">2.405</span>,
        recovering the single-mode V-number criterion.
      </p>

      <h3>Concept check (quick self-test)</h3>
      <ul>
        <li><strong>Q:</strong> If you keep <span class="mathInline">a</span> and NA fixed, how does <span class="mathInline">λc</span> scale? <strong>A:</strong> Linearly: <span class="mathInline">λc ∝ a·NA</span>.</li>
        <li><strong>Q:</strong> Why is <span class="mathInline">LP₀₁</span> always guided? <strong>A:</strong> It has no cutoff (fundamental mode exists for any <span class="mathInline">V&gt;0</span>).</li>
        <li><strong>Q:</strong> What happens to mode count if you halve <span class="mathInline">λ</span>? <strong>A:</strong> <span class="mathInline">V</span> doubles, so more modes exceed their cutoff.</li>
        <li><strong>Q:</strong> What does “weakly guiding” buy you? <strong>A:</strong> Simple LP labeling and near-universal cutoff values from Bessel zeros.</li>
      </ul>
    </article>

    <article id="part5">
      <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

      <div class="vizGrid">
        <figure>
          <canvas id="cDiagram" aria-label="Fiber diagram canvas"></canvas>
          <figcaption>
            <strong>Diagram:</strong> Cross-section of a step-index fiber. The core (radius <span class="mathInline">a</span>) has index <span class="mathInline">n₁</span>,
            surrounded by cladding with index <span class="mathInline">n₂</span>. Guidance occurs when modes remain evanescent in the cladding.
          </figcaption>
        </figure>

        <figure>
          <canvas id="cMain" aria-label="Main plot canvas"></canvas>
          <figcaption>
            <strong>Main plot:</strong> <span class="mathInline">V(λ)</span> versus wavelength. The horizontal line at <span class="mathInline">V=2.405</span>
            is the single-mode boundary. The vertical line marks <span class="mathInline">λc</span> for the current parameters.
          </figcaption>
        </figure>

        <figure>
          <canvas id="cModes" aria-label="Mode cutoff plot canvas"></canvas>
          <figcaption>
            <strong>Secondary plot:</strong> Cutoff chart. Each bar shows a mode’s cutoff <span class="mathInline">Vc</span>. The vertical marker is the current <span class="mathInline">V</span>:
            modes with <span class="mathInline">Vc &lt; V</span> are guided (highlighted).
          </figcaption>
        </figure>
      </div>

      <div class="controls" aria-label="Interactive controls">
        <div class="ctrl">
          <label>
            <span>Wavelength λ (μm)</span>
            <span class="val" id="lamVal">—</span>
          </label>
          <input id="lam" type="range" min="0.6" max="2.2" step="0.001" value="1.2" />
        </div>
        <div class="ctrl">
          <label>
            <span>Core radius a (μm)</span>
            <span class="val" id="aVal">—</span>
          </label>
          <input id="a" type="range" min="2" max="12" step="0.05" value="5" />
        </div>
        <div class="ctrl">
          <label>
            <span>Index difference Δ</span>
            <span class="val" id="dVal">—</span>
          </label>
          <input id="d" type="range" min="0.0005" max="0.01" step="0.0001" value="0.002" />
        </div>
        <div class="ctrl">
          <label>
            <span>Core index n₁</span>
            <span class="val" id="n1Val">—</span>
          </label>
          <input id="n1" type="range" min="1.35" max="1.60" step="0.001" value="1.45" />
        </div>
      </div>

      <div class="readoutRow">
        <div class="readout">
          <div class="k">Numerical aperture</div>
          <div class="v" id="naOut">—</div>
        </div>
        <div class="readout">
          <div class="k">Current V-number</div>
          <div class="v" id="vOut">—</div>
        </div>
        <div class="readout">
          <div class="k">Single-mode cutoff λc</div>
          <div class="v" id="lcOut">—</div>
        </div>
      </div>

      <div class="modeList" aria-live="polite">
        <div class="hdr">
          <div><strong>Guided modes</strong> at current λ (LP indices)</div>
          <div style="color:var(--faint)">rule: guided if V &gt; Vc</div>
        </div>
        <div class="chips" id="modeChips"></div>
      </div>
    </article>

    <footer>
      Built with vanilla HTML/CSS/JS. Interactive plots are computed from the same equations used in the solution.
    </footer>
  </div>
</main>

<script>
/* ---------------------------
   Utilities: DPI crisp canvas
---------------------------- */
function setupCanvas(canvas){
  const ctx = canvas.getContext('2d');
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(2, Math.floor(rect.width * dpr));
    const h = Math.max(2, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
    }
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  }
  return {ctx, resize};
}

function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

function niceTicks(min, max, approxCount){
  const span = max - min;
  if(span <= 0) return [min];
  const raw = span / Math.max(1, approxCount);
  const pow10 = Math.pow(10, Math.floor(Math.log10(raw)));
  const candidates = [1,2,5,10].map(m=>m*pow10);
  let step = candidates[0];
  let best = Infinity;
  for(const c of candidates){
    const count = span / c;
    const score = Math.abs(count - approxCount);
    if(score < best){ best = score; step = c; }
  }
  const start = Math.ceil(min/step)*step;
  const ticks = [];
  for(let v=start; v<=max+1e-12; v+=step) ticks.push(+v.toFixed(12));
  return ticks;
}

function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
  const {x,y,w,h, padL, padR, padT, padB} = box;
  const plotX = x + padL, plotY = y + padT;
  const plotW = w - padL - padR, plotH = h - padT - padB;

  // background
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(x,y,w,h);

  // title
  ctx.fillStyle = 'rgba(233,238,252,0.95)';
  ctx.font = '600 14px ui-sans-serif, system-ui';
  ctx.fillText(title, x + padL, y + 18);

  // grid & ticks
  const xTicks = niceTicks(xMin, xMax, 6);
  const yTicks = niceTicks(yMin, yMax, 6);

  ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  ctx.lineWidth = 1;

  // vertical grid
  for(const xt of xTicks){
    const px = plotX + (xt - xMin) / (xMax - xMin) * plotW;
    ctx.beginPath();
    ctx.moveTo(px, plotY);
    ctx.lineTo(px, plotY + plotH);
    ctx.stroke();
  }
  // horizontal grid
  for(const yt of yTicks){
    const py = plotY + plotH - (yt - yMin) / (yMax - yMin) * plotH;
    ctx.beginPath();
    ctx.moveTo(plotX, py);
    ctx.lineTo(plotX + plotW, py);
    ctx.stroke();
  }

  // axes
  ctx.strokeStyle = 'rgba(255,255,255,0.20)';
  ctx.beginPath();
  ctx.moveTo(plotX, plotY + plotH);
  ctx.lineTo(plotX + plotW, plotY + plotH);
  ctx.lineTo(plotX + plotW, plotY);
  ctx.stroke();

  // tick labels
  ctx.fillStyle = 'rgba(185,196,234,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas';

  for(const xt of xTicks){
    const px = plotX + (xt - xMin) / (xMax - xMin) * plotW;
    const s = formatTick(xt);
    ctx.fillText(s, px - ctx.measureText(s).width/2, plotY + plotH + 16);
  }
  for(const yt of yTicks){
    const py = plotY + plotH - (yt - yMin) / (yMax - yMin) * plotH;
    const s = formatTick(yt);
    ctx.fillText(s, plotX - ctx.measureText(s).width - 8, py + 4);
  }

  // axis labels
  ctx.fillStyle = 'rgba(233,238,252,0.95)';
  ctx.font = '600 12px ui-sans-serif, system-ui';
  ctx.fillText(xLabel, plotX + plotW - ctx.measureText(xLabel).width, plotY + plotH + 34);

  // yLabel rotated
  ctx.save();
  ctx.translate(x + 12, plotY + plotH/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  ctx.restore();

  function toPixX(v){ return plotX + (v - xMin) / (xMax - xMin) * plotW; }
  function toPixY(v){ return plotY + plotH - (v - yMin) / (yMax - yMin) * plotH; }

  return {plotX, plotY, plotW, plotH, toPixX, toPixY};
}

function formatTick(v){
  const av = Math.abs(v);
  if(av >= 100) return v.toFixed(0);
  if(av >= 10) return v.toFixed(1);
  if(av >= 1) return v.toFixed(2);
  if(av >= 0.1) return v.toFixed(3);
  return v.toFixed(4);
}

/* ---------------------------
   Fiber physics model
---------------------------- */
// Bessel zeros (first few), enough for typical V up to ~10–12.
const besselZeros = {
  J0: [2.4048255577, 5.5200781103, 8.6537279129],
  J1: [3.8317059702, 7.0155866698, 10.1734681351],
  J2: [5.1356223018, 8.4172441404, 11.6198411721]
};

// Build LP mode list with cutoffs (weak guidance rule).
// LP01 cutoff 0; for l>=1: Vc = j_{l-1,m}; for l=0, m>=2: Vc = j_{1,m-1}.
function buildModes(){
  const modes = [];
  modes.push({l:0, m:1, name:'LP01', Vc:0});

  // l=1 (uses J0 zeros)
  for(let m=1; m<=besselZeros.J0.length; m++){
    modes.push({l:1, m, name:`LP${1}${m}`, Vc:besselZeros.J0[m-1]});
  }
  // l=2 (uses J1 zeros)
  for(let m=1; m<=besselZeros.J1.length; m++){
    modes.push({l:2, m, name:`LP${2}${m}`, Vc:besselZeros.J1[m-1]});
  }
  // l=3 (uses J2 zeros)
  for(let m=1; m<=besselZeros.J2.length; m++){
    modes.push({l:3, m, name:`LP${3}${m}`, Vc:besselZeros.J2[m-1]});
  }
  // l=0, m>=2 (uses J1 zeros with shifted index)
  for(let m=2; m<=besselZeros.J1.length+1; m++){
    modes.push({l:0, m, name:`LP0${m}`, Vc:besselZeros.J1[m-2]});
  }

  // sort by cutoff then by l,m
  modes.sort((a,b)=> (a.Vc-b.Vc) || (a.l-b.l) || (a.m-b.m));
  // deduplicate by (l,m) (names already unique)
  return modes;
}

function fiberNA(n1, Delta){
  // Using Δ = (n1^2 - n2^2)/(2 n1^2) -> n2 = n1*sqrt(1-2Δ)
  // NA = sqrt(n1^2 - n2^2) = n1*sqrt(2Δ)
  return n1 * Math.sqrt(Math.max(0, 2*Delta));
}
function fiberLc(a_m, n1, Delta){
  const NA = fiberNA(n1, Delta);
  return (2*Math.PI*a_m*NA)/2.405; // meters
}
function fiberV(a_m, n1, Delta, lam_m){
  const NA = fiberNA(n1, Delta);
  return (2*Math.PI*a_m/lam_m)*NA;
}

/* ---------------------------
   DOM + State
---------------------------- */
const els = {
  lam: document.getElementById('lam'),
  a: document.getElementById('a'),
  d: document.getElementById('d'),
  n1: document.getElementById('n1'),
  lamVal: document.getElementById('lamVal'),
  aVal: document.getElementById('aVal'),
  dVal: document.getElementById('dVal'),
  n1Val: document.getElementById('n1Val'),
  naOut: document.getElementById('naOut'),
  vOut: document.getElementById('vOut'),
  lcOut: document.getElementById('lcOut'),
  modeChips: document.getElementById('modeChips'),
  naHeadline: document.getElementById('naHeadline'),
  lcHeadline: document.getElementById('lcHeadline'),
  vHalfHeadline: document.getElementById('vHalfHeadline')
};

const modes = buildModes();

const canv = {
  diagram: setupCanvas(document.getElementById('cDiagram')),
  main: setupCanvas(document.getElementById('cMain')),
  mode: setupCanvas(document.getElementById('cModes'))
};

function fmt(x, digits=3){ return (+x).toFixed(digits); }
function fmtUm(m){ return (m*1e6); }
function fmtSci(m){
  if(m === 0) return "0";
  const um = m*1e6;
  if(um >= 0.1 && um < 1000) return `${um.toFixed(3)} μm`;
  return `${m.toExponential(3)} m`;
}

function updateUI(){
  const lam_um = parseFloat(els.lam.value);
  const a_um = parseFloat(els.a.value);
  const Delta = parseFloat(els.d.value);
  const n1 = parseFloat(els.n1.value);

  const lam_m = lam_um*1e-6;
  const a_m = a_um*1e-6;

  const NA = fiberNA(n1, Delta);
  const lc_m = fiberLc(a_m, n1, Delta);
  const V = fiberV(a_m, n1, Delta, lam_m);

  els.lamVal.textContent = `${lam_um.toFixed(3)} μm`;
  els.aVal.textContent = `${a_um.toFixed(2)} μm`;
  els.dVal.textContent = `${Delta.toFixed(4)}`;
  els.n1Val.textContent = `${n1.toFixed(3)}`;

  els.naOut.textContent = `${NA.toFixed(5)}`;
  els.vOut.textContent = `${V.toFixed(3)}`;
  els.lcOut.textContent = `${(lc_m*1e6).toFixed(3)} μm`;

  // headline (use problem default values when those sliders match; still compute live)
  els.naHeadline.textContent = `${NA.toFixed(5)}`;
  els.lcHeadline.textContent = `${(lc_m*1e6).toFixed(3)} μm`;
  els.vHalfHeadline.textContent = `${(2*2.405).toFixed(3)}`;

  // guided modes chips
  els.modeChips.innerHTML = '';
  const Vcur = V;
  const guided = modes.filter(mm => mm.Vc < Vcur + 1e-12); // include equality comfortably
  for(const mm of modes.slice(0, 10)){ // show first chunk, plus guided status; if more, still show but faded
    const isGuided = (mm.Vc < Vcur + 1e-12);
    const chip = document.createElement('span');
    chip.className = 'chip' + (isGuided ? '' : ' off');
    chip.textContent = `(${mm.l},${mm.m})`;
    chip.title = `${mm.name} cutoff Vc=${mm.Vc.toFixed(3)}`;
    els.modeChips.appendChild(chip);
  }
  // If there are guided modes beyond the first 10 in list, append them too (rare here).
  if(guided.length > 10){
    for(const mm of guided.slice(10)){
      const chip = document.createElement('span');
      chip.className = 'chip';
      chip.textContent = `(${mm.l},${mm.m})`;
      chip.title = `${mm.name} cutoff Vc=${mm.Vc.toFixed(3)}`;
      els.modeChips.appendChild(chip);
    }
  }

  drawAll({lam_um, a_um, Delta, n1, NA, lc_m, V});
}

function drawAll(state){
  drawDiagram(state);
  drawMain(state);
  drawModes(state);
}

/* ---------------------------
   Diagram canvas
---------------------------- */
function drawDiagram(s){
  const {ctx, resize} = canv.diagram;
  resize();
  const canvas = ctx.canvas;
  const W = canvas.getBoundingClientRect().width;
  const H = canvas.getBoundingClientRect().height;

  ctx.clearRect(0,0,W,H);

  // panel
  const pad = 16;
  const cx = W*0.35, cy = H*0.55;
  const R = Math.min(W,H)*0.27;
  const ring = R*1.55;

  // soft bg
  ctx.fillStyle = 'rgba(255,255,255,0.03)';
  ctx.fillRect(0,0,W,H);

  // cladding
  ctx.beginPath();
  ctx.arc(cx, cy, ring, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(122,162,255,0.10)';
  ctx.fill();

  // core
  ctx.beginPath();
  ctx.arc(cx, cy, R, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(125,255,204,0.14)';
  ctx.fill();

  // outlines
  ctx.strokeStyle = 'rgba(255,255,255,0.22)';
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(cx, cy, ring, 0, Math.PI*2); ctx.stroke();
  ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2); ctx.stroke();

  // radius arrow
  ctx.strokeStyle = 'rgba(233,238,252,0.9)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx + R, cy);
  ctx.stroke();

  // arrow head
  ctx.beginPath();
  ctx.moveTo(cx + R, cy);
  ctx.lineTo(cx + R - 10, cy - 5);
  ctx.lineTo(cx + R - 10, cy + 5);
  ctx.closePath();
  ctx.fillStyle = 'rgba(233,238,252,0.9)';
  ctx.fill();

  // labels
  ctx.fillStyle = 'rgba(233,238,252,0.95)';
  ctx.font = '600 14px ui-sans-serif, system-ui';
  ctx.fillText('Step-index fiber cross-section', pad, pad+14);

  ctx.fillStyle = 'rgba(185,196,234,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas';
  const aTxt = `a = ${s.a_um.toFixed(2)} μm`;
  ctx.fillText(aTxt, cx + R*0.25, cy - 10);

  // index labels
  ctx.fillStyle = 'rgba(185,196,234,0.95)';
  ctx.font = '12px ui-sans-serif, system-ui';

  ctx.fillText(`core: n₁ = ${s.n1.toFixed(3)}`, cx - R*0.45, cy - 6);
  const n2 = s.n1*Math.sqrt(Math.max(0, 1 - 2*s.Delta));
  ctx.fillText(`clad: n₂ = ${n2.toFixed(3)}`, cx - ring*0.55, cy + ring*0.65);

  // NA callout
  ctx.fillStyle = 'rgba(255,255,255,0.05)';
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 1;
  const bx = W*0.62, by = H*0.22, bw = W*0.34, bh = H*0.38;
  roundRect(ctx, bx, by, bw, bh, 16, true, true);

  ctx.fillStyle = 'rgba(233,238,252,0.95)';
  ctx.font = '600 13px ui-sans-serif, system-ui';
  ctx.fillText('Key quantities', bx+12, by+22);

  ctx.fillStyle = 'rgba(185,196,234,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas';
  const lines = [
    `Δ = ${s.Delta.toFixed(4)}`,
    `NA ≈ n₁√(2Δ) = ${s.NA.toFixed(5)}`,
    `λ = ${s.lam_um.toFixed(3)} μm`,
    `V = (2πa/λ)·NA = ${s.V.toFixed(3)}`
  ];
  lines.forEach((t,i)=> ctx.fillText(t, bx+12, by+46 + i*18));
}

function roundRect(ctx, x, y, w, h, r, fill, stroke){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/* ---------------------------
   Main plot: V vs λ
---------------------------- */
function drawMain(s){
  const {ctx, resize} = canv.main;
  resize();
  const W = ctx.canvas.getBoundingClientRect().width;
  const H = ctx.canvas.getBoundingClientRect().height;
  ctx.clearRect(0,0,W,H);

  // define plot bounds
  const lamMin = 0.6, lamMax = 2.2; // μm
  const a_m = s.a_um*1e-6;
  const NA = s.NA;
  // y range from curve endpoints
  const Vmax = (2*Math.PI*a_m/(lamMin*1e-6))*NA;
  const Vmin = (2*Math.PI*a_m/(lamMax*1e-6))*NA;
  const yMin = 0;
  const yMax = Math.max(3.2, Vmax*1.08);

  const box = {x:0,y:0,w:W,h:H, padL:54, padR:18, padT:28, padB:48};
  const ax = drawAxes(ctx, box, lamMin, lamMax, yMin, yMax,
                      'λ (μm)', 'V (dimensionless)',
                      'Normalized frequency V(λ) and single-mode boundary');

  // curve
  ctx.strokeStyle = 'rgba(125,255,204,0.85)';
  ctx.lineWidth = 2.2;
  ctx.beginPath();
  const N = 300;
  for(let i=0;i<=N;i++){
    const lam = lamMin + (lamMax-lamMin)*i/N; // μm
    const V = (2*Math.PI*a_m/(lam*1e-6))*NA;
    const px = ax.toPixX(lam);
    const py = ax.toPixY(V);
    if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
  }
  ctx.stroke();

  // boundary line V=2.405
  const Vc = 2.405;
  const yVc = ax.toPixY(Vc);
  ctx.strokeStyle = 'rgba(255,207,111,0.85)';
  ctx.lineWidth = 1.8;
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.moveTo(ax.plotX, yVc);
  ctx.lineTo(ax.plotX + ax.plotW, yVc);
  ctx.stroke();
  ctx.setLineDash([]);

  // label boundary
  ctx.fillStyle = 'rgba(255,207,111,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas';
  ctx.fillText('V = 2.405 (single-mode boundary)', ax.plotX + 8, yVc - 8);

  // vertical line at λc
  const lc_um = s.lc_m*1e6;
  const xLc = ax.toPixX(clamp(lc_um, lamMin, lamMax));
  ctx.strokeStyle = 'rgba(122,162,255,0.85)';
  ctx.lineWidth = 1.8;
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.moveTo(xLc, ax.plotY);
  ctx.lineTo(xLc, ax.plotY + ax.plotH);
  ctx.stroke();
  ctx.setLineDash([]);

  ctx.fillStyle = 'rgba(122,162,255,0.95)';
  ctx.fillText(`λc ≈ ${lc_um.toFixed(3)} μm`, xLc + 6, ax.plotY + 16);

  // current point
  const xP = ax.toPixX(s.lam_um);
  const yP = ax.toPixY(s.V);
  ctx.fillStyle = 'rgba(233,238,252,0.95)';
  ctx.beginPath();
  ctx.arc(xP, yP, 4.5, 0, Math.PI*2);
  ctx.fill();

  // legend
  const lx = ax.plotX + ax.plotW - 210;
  const ly = ax.plotY + 12;
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 1;
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  roundRect(ctx, lx, ly, 198, 56, 14, true, true);

  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillStyle = 'rgba(185,196,234,0.95)';
  ctx.fillText('Legend', lx+12, ly+18);

  // line samples
  ctx.strokeStyle = 'rgba(125,255,204,0.85)'; ctx.lineWidth = 2.2;
  ctx.beginPath(); ctx.moveTo(lx+12, ly+30); ctx.lineTo(lx+44, ly+30); ctx.stroke();
  ctx.fillStyle = 'rgba(185,196,234,0.95)';
  ctx.fillText('V(λ)', lx+54, ly+34);

  ctx.strokeStyle = 'rgba(255,207,111,0.85)'; ctx.lineWidth = 1.8; ctx.setLineDash([6,6]);
  ctx.beginPath(); ctx.moveTo(lx+12, ly+46); ctx.lineTo(lx+44, ly+46); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = 'rgba(185,196,234,0.95)';
  ctx.fillText('V=2.405', lx+54, ly+50);
}

/* ---------------------------
   Secondary plot: mode cutoffs
---------------------------- */
function drawModes(s){
  const {ctx, resize} = canv.mode;
  resize();
  const W = ctx.canvas.getBoundingClientRect().width;
  const H = ctx.canvas.getBoundingClientRect().height;
  ctx.clearRect(0,0,W,H);

  const Vmax = 10.5;
  const Vmin = 0;

  // pick a subset of modes up to Vmax for plotting
  const plotModes = modes.filter(m => m.Vc <= Vmax + 1e-9).slice(0, 10); // show first 10 by cutoff

  const yMin = -0.5;
  const yMax = plotModes.length - 0.5;

  const box = {x:0,y:0,w:W,h:H, padL:74, padR:18, padT:28, padB:46};
  const ax = drawAxes(ctx, box, Vmin, Vmax, yMin, yMax,
                      'V (dimensionless)', 'Mode index',
                      'LP mode cutoffs (Vc) and guided status');

  // y labels (categorical)
  ctx.fillStyle = 'rgba(185,196,234,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas';
  for(let i=0;i<plotModes.length;i++){
    const m = plotModes[i];
    const y = ax.toPixY(i);
    const label = `(${m.l},${m.m})`;
    ctx.fillText(label, ax.plotX - ctx.measureText(label).width - 10, y + 4);
  }

  // bars: from Vc to Vmax
  const barH = Math.max(10, ax.plotH/(plotModes.length*1.6));
  for(let i=0;i<plotModes.length;i++){
    const m = plotModes[i];
    const y = ax.toPixY(i);
    const x0 = ax.toPixX(m.Vc);
    const x1 = ax.toPixX(Vmax);
    const guided = (m.Vc < s.V + 1e-12);

    ctx.fillStyle = guided ? 'rgba(125,255,204,0.22)' : 'rgba(255,255,255,0.06)';
    ctx.strokeStyle = guided ? 'rgba(125,255,204,0.65)' : 'rgba(255,255,255,0.16)';
    ctx.lineWidth = 1.2;
    roundRect(ctx, x0, y - barH/2, Math.max(2, x1-x0), barH, 10, true, true);

    // cutoff marker
    ctx.strokeStyle = guided ? 'rgba(125,255,204,0.95)' : 'rgba(255,207,111,0.75)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x0, y - barH/2 - 2);
    ctx.lineTo(x0, y + barH/2 + 2);
    ctx.stroke();

    ctx.fillStyle = 'rgba(185,196,234,0.95)';
    const t = `Vc=${m.Vc.toFixed(3)}`;
    ctx.fillText(t, x0 + 8, y + 4);
  }

  // current V vertical line
  const xV = ax.toPixX(clamp(s.V, Vmin, Vmax));
  ctx.strokeStyle = 'rgba(122,162,255,0.9)';
  ctx.lineWidth = 2;
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.moveTo(xV, ax.plotY);
  ctx.lineTo(xV, ax.plotY + ax.plotH);
  ctx.stroke();
  ctx.setLineDash([]);

  ctx.fillStyle = 'rgba(122,162,255,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas';
  ctx.fillText(`V = ${s.V.toFixed(3)}`, xV + 6, ax.plotY + 16);

  // legend
  const lx = ax.plotX + ax.plotW - 230;
  const ly = ax.plotY + 12;
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 1;
  roundRect(ctx, lx, ly, 216, 64, 14, true, true);

  ctx.fillStyle = 'rgba(185,196,234,0.95)';
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillText('Legend', lx+12, ly+18);

  // guided sample
  ctx.fillStyle = 'rgba(125,255,204,0.22)';
  ctx.strokeStyle = 'rgba(125,255,204,0.65)';
  roundRect(ctx, lx+12, ly+28, 26, 12, 6, true, true);
  ctx.fillStyle = 'rgba(185,196,234,0.95)';
  ctx.fillText('guided (Vc < V)', lx+46, ly+39);

  // cutoff marker sample
  ctx.strokeStyle = 'rgba(255,207,111,0.85)';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(lx+12, ly+52); ctx.lineTo(lx+38, ly+52); ctx.stroke();
  ctx.fillStyle = 'rgba(185,196,234,0.95)';
  ctx.fillText('cutoff location', lx+46, ly+56);
}

/* ---------------------------
   Copy buttons
---------------------------- */
function hookCopy(){
  document.addEventListener('click', (e)=>{
    const btn = e.target.closest('.copyBtn');
    if(!btn) return;
    const text = btn.getAttribute('data-copy') || '';
    if(!text) return;
    navigator.clipboard.writeText(text).then(()=>{
      const old = btn.textContent;
      btn.textContent = 'Copied!';
      setTimeout(()=>btn.textContent = old, 900);
    }).catch(()=>{
      // fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      try{ document.execCommand('copy'); }catch(_){}
      document.body.removeChild(ta);
      const old = btn.textContent;
      btn.textContent = 'Copied!';
      setTimeout(()=>btn.textContent = old, 900);
    });
  });
}

/* ---------------------------
   Init + Resize observers
---------------------------- */
function init(){
  // set sliders to match problem baseline as initial
  // (already set in HTML, but we compute headline outputs now)
  hookCopy();

  // resize observers for responsiveness
  const ro = new ResizeObserver(()=> updateUI());
  ro.observe(document.getElementById('cDiagram'));
  ro.observe(document.getElementById('cMain'));
  ro.observe(document.getElementById('cModes'));

  // inputs
  ['lam','a','d','n1'].forEach(id=>{
    els[id].addEventListener('input', updateUI);
  });

  // initialize λ to λc for the starting parameters (problem baseline),
  // so the first view naturally shows the cutoff point.
  const a_um = parseFloat(els.a.value);
  const Delta = parseFloat(els.d.value);
  const n1 = parseFloat(els.n1.value);
  const lc = fiberLc(a_um*1e-6, n1, Delta)*1e6; // μm
  els.lam.value = clamp(lc, parseFloat(els.lam.min), parseFloat(els.lam.max)).toFixed(3);

  updateUI();
}

init();

/* ---------------------------
   Populate headline V at λc/2 (problem-specific)
   Using the known boundary value: V(λc) = 2.405 always, hence V(λc/2)=4.810.
   (We already set this in UI; keep consistent.)
---------------------------- */
</script>

<script>
/* Update headline using exact problem numbers once at load, for clarity */
(function(){
  const a = 5e-6, n1 = 1.45, Delta = 0.002;
  const NA = fiberNA(n1, Delta);
  const lc = fiberLc(a, n1, Delta);
  document.getElementById('naHeadline').textContent = NA.toFixed(5);
  document.getElementById('lcHeadline').textContent = (lc*1e6).toFixed(3) + ' μm';
  document.getElementById('vHalfHeadline').textContent = (2*2.405).toFixed(3);
})();
</script>

</body>
</html>
