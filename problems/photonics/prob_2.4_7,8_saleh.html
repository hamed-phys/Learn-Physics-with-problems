<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <title>Reflection of a Spherical Wave from a Planar Mirror & Optical Pathlength (Multilayer Plate)</title>
  <style>
    :root{
      --bg: #0b0d12;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.09);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.72);
      --faint: rgba(255,255,255,.55);
      --accent: #8be9fd;
      --accent2:#a8ff60;
      --warn:#ffd166;
      --ok:#7CFFB2;
      --bad:#ff6b6b;
      --border: rgba(255,255,255,.14);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --radius: 18px;
      --radius2: 22px;
      --maxw: 1200px;
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg:#f7f8fb;
        --panel: rgba(10,20,40,.05);
        --panel2: rgba(10,20,40,.08);
        --text: rgba(10,16,28,.92);
        --muted: rgba(10,16,28,.72);
        --faint: rgba(10,16,28,.56);
        --border: rgba(10,20,40,.14);
        --shadow: 0 10px 30px rgba(10,20,40,.12);
        --accent: #0ea5e9;
        --accent2:#22c55e;
        --warn:#b45309;
        --ok:#059669;
        --bad:#dc2626;
      }
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 20% 0%, rgba(139,233,253,.12), transparent 55%),
        radial-gradient(1000px 700px at 80% 10%, rgba(168,255,96,.10), transparent 60%),
        linear-gradient(180deg, var(--bg), var(--bg));
      line-height:1.55;
    }
    a{color:inherit}
    .wrap{
      max-width:var(--maxw);
      margin:0 auto;
      padding:28px 18px 80px;
    }

    header.hero{
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap:18px;
      align-items:stretch;
      margin-bottom:18px;
    }
    @media (max-width: 980px){
      header.hero{grid-template-columns:1fr}
    }
    .card{
      background:linear-gradient(180deg, var(--panel), transparent);
      border:1px solid var(--border);
      border-radius:var(--radius2);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .hero .title{
      padding:20px 20px 16px;
    }
    .kicker{
      font-weight:700;
      letter-spacing:.08em;
      text-transform:uppercase;
      font-size:.78rem;
      color:var(--muted);
    }
    h1{
      margin:10px 0 6px;
      line-height:1.12;
      font-size:clamp(1.55rem, 2.2vw + 1rem, 2.3rem);
    }
    .subtitle{
      color:var(--muted);
      margin:0;
      font-size:1rem;
      max-width:70ch;
    }
    .meta{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:14px;
      color:var(--faint);
      font-size:.92rem;
    }
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:7px 10px;
      border-radius:999px;
      background:var(--panel2);
      border:1px solid var(--border);
      backdrop-filter: blur(6px);
    }
    .pill b{color:var(--text); font-weight:700}
    .hero .summary{
      padding:16px 18px 16px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .summary h2{
      font-size:1.03rem;
      margin:0;
      letter-spacing:.01em;
    }
    ul.bullets{
      margin:0;
      padding-left:18px;
      color:var(--muted);
    }
    ul.bullets li{margin:7px 0}
    .accent{color:var(--accent)}
    .accent2{color:var(--accent2)}
    .grid{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
      margin-top:18px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }

    aside.toc{
      position:sticky;
      top:14px;
      align-self:start;
      padding:14px;
      border-radius:var(--radius);
      background:linear-gradient(180deg, var(--panel2), transparent);
      border:1px solid var(--border);
      box-shadow: var(--shadow);
    }
    .toc h3{
      margin:0 0 10px;
      font-size:.95rem;
      color:var(--muted);
    }
    .toc nav a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      color:var(--muted);
      text-decoration:none;
      border:1px solid transparent;
      transition:transform .14s ease, background .14s ease, border-color .14s ease;
      font-size:.95rem;
    }
    .toc nav a:hover{
      background:var(--panel2);
      border-color:var(--border);
      transform: translateY(-1px);
      color:var(--text);
    }
    .toc nav a.active{
      background:rgba(139,233,253,.12);
      border-color:rgba(139,233,253,.35);
      color:var(--text);
    }

    main{
      min-width:0;
    }
    section{
      margin-bottom:18px;
    }
    section .sec{
      padding:18px;
    }
    h2{
      margin:0 0 10px;
      font-size:1.35rem;
      letter-spacing:.01em;
    }
    h3{
      margin:14px 0 8px;
      font-size:1.08rem;
      color:var(--text);
    }
    p{margin:10px 0; color:var(--muted)}
    .two{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 880px){
      .two{grid-template-columns:1fr}
    }
    .callout{
      padding:14px 14px 12px;
      border-radius:var(--radius);
      background:var(--panel2);
      border:1px solid var(--border);
    }
    .callout strong{color:var(--text)}
    .callout .tag{
      display:inline-block;
      font-size:.78rem;
      letter-spacing:.08em;
      text-transform:uppercase;
      color:var(--faint);
      margin-bottom:6px;
    }

    .eq{
      background:rgba(0,0,0,.25);
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px 12px;
      overflow:auto;
      font-family:var(--mono);
      color:var(--text);
      position:relative;
    }
    @media (prefers-color-scheme: light){
      .eq{background:rgba(10,20,40,.06)}
    }
    .eq .label{
      font-family:var(--sans);
      font-size:.84rem;
      color:var(--faint);
      margin-bottom:8px;
    }
    .eq code{
      font-family:var(--mono);
      font-size:.98rem;
      white-space:pre;
      display:block;
    }
    .copybar{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    button.copy{
      border:1px solid var(--border);
      background:linear-gradient(180deg, var(--panel2), transparent);
      color:var(--text);
      padding:8px 10px;
      border-radius:12px;
      cursor:pointer;
      font-weight:650;
      letter-spacing:.01em;
      transition:transform .12s ease, border-color .12s ease;
    }
    button.copy:hover{transform: translateY(-1px); border-color: rgba(139,233,253,.35)}
    button.copy:active{transform: translateY(0px)}
    .small{font-size:.92rem;color:var(--faint)}
    .hr{
      height:1px;
      background:var(--border);
      margin:14px 0;
    }

    figure.viz{
      margin:0;
      padding:14px;
      border-radius:var(--radius2);
      border:1px solid var(--border);
      background:linear-gradient(180deg, var(--panel2), transparent);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    figure.viz figcaption{
      color:var(--muted);
      margin-top:10px;
      font-size:.95rem;
    }
    .vizhead{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .vizhead .ttl{
      margin:0;
      font-size:1.05rem;
      color:var(--text);
      font-weight:800;
      letter-spacing:.01em;
    }
    .controls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
      margin-top:-2px;
    }
    .ctrl{
      display:flex;
      gap:8px;
      align-items:center;
      padding:8px 10px;
      border-radius:14px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
    }
    .ctrl label{
      color:var(--muted);
      font-size:.9rem;
      white-space:nowrap;
    }
    input[type="range"]{
      width:220px;
      accent-color: var(--accent);
    }
    select{
      background:rgba(255,255,255,.04);
      border:1px solid var(--border);
      color:var(--text);
      border-radius:10px;
      padding:6px 8px;
      font-weight:650;
    }
    .readout{
      font-family:var(--mono);
      font-size:.92rem;
      color:var(--text);
      padding:4px 8px;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.18);
    }
    @media (prefers-color-scheme: light){
      .readout{background:rgba(10,20,40,.06)}
      .ctrl{background:rgba(10,20,40,.05)}
      select{background:rgba(10,20,40,.05)}
    }

    .boxed-final{
      border:1px solid rgba(168,255,96,.35);
      background:linear-gradient(180deg, rgba(168,255,96,.10), transparent);
      border-radius:var(--radius2);
      padding:14px;
    }
    .boxed-final h3{margin-top:0}
    .boxed-final .eq{border-color: rgba(168,255,96,.30)}
    .note{
      font-size:.95rem;
      color:var(--muted);
    }

    footer{
      margin-top:22px;
      padding:18px;
      border-radius:var(--radius2);
      border:1px solid var(--border);
      background:linear-gradient(180deg, var(--panel), transparent);
      color:var(--faint);
      text-align:center;
    }

    /* subtle entrance */
    @keyframes up {
      from{opacity:0; transform: translateY(8px)}
      to{opacity:1; transform: translateY(0)}
    }
    .card, figure.viz{animation: up .35s ease both}
    @media (prefers-reduced-motion: reduce){
      .card, figure.viz{animation:none}
      .toc nav a, button.copy{transition:none}
    }

    /* print-friendly */
    @media print{
      body{background:#fff}
      aside.toc{display:none}
      .wrap{max-width:100%; padding:0}
      .card, figure.viz{box-shadow:none}
      figure.viz canvas{max-height:320px}
      button.copy{display:none}
      .controls{display:none}
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header class="hero">
      <div class="card title">
        <div class="kicker">Optics • Fresnel approximation • multilayer phase</div>
        <h1>2-4-7 Reflection of a Spherical Wave from a Planar Mirror<br/>and 2-4-8 Optical Pathlength of a Multilayer Plate</h1>
        <p class="subtitle">
          We treat a spherical wave as a locally plane wave (slowly varying direction) and apply the plane-wave law of reflection.
          Then we compute the <span class="accent">complex amplitude transmittance</span> of a multilayer plate when reflections are ignored,
          and show the equivalent free-space distance is the <span class="accent2">optical pathlength</span>.
        </p>
        <div class="meta">
          <span class="pill">Key idea: <b>virtual image source</b> for the mirror</span>
          <span class="pill">Key result: <b>t = exp(i k0 Σ nqdq)</b></span>
          <span class="pill">Demo plots use <b>example values</b></span>
        </div>
      </div>

      <div class="card summary">
        <h2>Quick Summary</h2>
        <ul class="bullets">
          <li>A spherical wave reflected by a plane mirror becomes a spherical wave that appears to come from the <b>mirror image of the source</b>.</li>
          <li>Locally the incident wave is plane, so each local ray obeys <b>θ<sub>r</sub>=θ<sub>i</sub></b>; the global wavefront is the envelope of these reflected planes.</li>
          <li>Ignoring reflections in a multilayer, the field only accumulates phase (and possibly attenuation): <b>t = exp(i k0 Σ nqdq)</b>.</li>
          <li>The free-space thickness giving the same transmittance is <b>d = Σ nqdq</b>, which is exactly the <b>optical pathlength</b>.</li>
          <li>Slider below changes wavelength λ and updates: mirror wavefront phase, multilayer phase & magnitude curves.</li>
        </ul>
        <div class="small">Copy buttons appear next to the key equations and final boxed answers.</div>
      </div>
    </header>

    <div class="grid">
      <aside class="toc" aria-label="Table of contents">
        <h3>Table of Contents</h3>
        <nav>
          <a href="#viz" data-toc>Interactive Visualizations</a>
          <a href="#part1" data-toc>PART 1 — Problem Analysis</a>
          <a href="#part2" data-toc>PART 2 — Strategy & Tips</a>
          <a href="#part3" data-toc>PART 3 — Full Solution</a>
          <a href="#final" data-toc>Final Results</a>
        </nav>
      </aside>

      <main>
        <section id="viz" class="card">
          <div class="sec">
            <h2>Interactive Visualizations</h2>
            <p class="note">
              All plots use the <b>same wavelength λ</b> (slider). Example geometry/stack values are stated in the captions.
              The math derivations below remain symbolic.
            </p>

            <figure class="viz" aria-label="Diagram canvas figure">
              <div class="vizhead">
                <div>
                  <p class="ttl">Diagram: Mirror image source & multilayer plate (example geometry)</p>
                  <div class="small">Mirror plane z=0, real source at z=−s, virtual image at z=+s. Multilayer: N layers with (n<sub>q</sub>, d<sub>q</sub>).</div>
                </div>
                <div class="controls" aria-label="Controls">
                  <div class="ctrl">
                    <label for="lambda">Wavelength λ (nm)</label>
                    <input id="lambda" type="range" min="400" max="1600" value="850" step="1" />
                    <span class="readout" id="lambdaOut">850 nm</span>
                  </div>
                  <div class="ctrl">
                    <label for="mainMode">Main plot</label>
                    <select id="mainMode">
                      <option value="phase" selected>Mirror: wrapped phase Δφ(x)</option>
                      <option value="fresnel">Mirror: Fresnel parabola fit</option>
                    </select>
                  </div>
                </div>
              </div>
              <canvas id="cDiagram" style="width:100%; height:320px; display:block;"></canvas>
              <figcaption>
                Example values for visualization: source distance s = 0.30 m, observation screen at z = −0.10 m,
                lateral coordinate x ∈ [−2.5, 2.5] cm. Multilayer example: three layers (n,d) = (1.45, 0.8 mm), (2.0, 0.3 mm), (1.6, 0.5 mm),
                with a small optional absorption Im(n)=0.002 (for showing |t| &lt; 1).
              </figcaption>
            </figure>

            <div class="two" style="margin-top:14px;">
              <figure class="viz" aria-label="Main plot figure">
                <div class="vizhead">
                  <div>
                    <p class="ttl">Main plot: Reflected spherical wave on a screen</p>
                    <div class="small">We plot the phase relative to the on-axis point: Δφ(x)=k·(r(x)−r(0)) (wrapped to [−π,π]).</div>
                  </div>
                </div>
                <canvas id="cMain" style="width:100%; height:320px; display:block;"></canvas>
                <figcaption>
                  In the Fresnel (paraxial) regime, r(x)−r(0) ≈ x²/(2R) so Δφ(x) is approximately quadratic in x with curvature controlled by R.
                </figcaption>
              </figure>

              <figure class="viz" aria-label="Secondary plot figure">
                <div class="vizhead">
                  <div>
                    <p class="ttl">Secondary plot: Multilayer transmittance vs wavelength</p>
                    <div class="small">Ignoring reflections: t(λ)=exp(i·k0(λ)·OPL). We show phase (wrapped) and magnitude. Vertical marker = current λ.</div>
                  </div>
                </div>
                <canvas id="cSecond" style="width:100%; height:320px; display:block;"></canvas>
                <figcaption>
                  Optical pathlength OPL = Σ n<sub>q</sub>d<sub>q</sub>. If n is complex, |t|=exp(−k0·Σ Im(n<sub>q</sub>)d<sub>q</sub>).
                </figcaption>
              </figure>
            </div>
          </div>
        </section>

        <section id="part1" class="card">
          <div class="sec">
            <h2>PART 1 — Problem Analysis (no solving yet)</h2>

            <h3>2-4-7 (Mirror): Restate the problem</h3>
            <p>
              A point source produces a spherical wave that hits a planar mirror. The mirror is far enough from the source that
              the <b>Fresnel approximation</b> (slowly varying direction across the wavefront) is valid. Treat the spherical wave locally
              as a plane wave whose direction changes slowly with position, apply the <b>law of reflection</b> for plane waves, and determine
              the <b>nature</b> of the reflected wave (i.e., what kind of wavefront it is and where it appears to originate).
            </p>

            <div class="two">
              <div class="callout">
                <div class="tag">Given</div>
                <p>
                  Planar mirror; incident <b>spherical wave</b>; Fresnel/paraxial condition so locally the wave is approximately plane.
                </p>
              </div>
              <div class="callout">
                <div class="tag">Unknown</div>
                <p>
                  The <b>shape and origin</b> of the reflected wave (plane? spherical? from where?).
                </p>
              </div>
            </div>

            <h3>2-4-8 (Optical pathlength): Restate the problem</h3>
            <p>
              A plane wave propagates <b>normally</b> through a thin plate made of <b>N parallel layers</b>. Layer q has thickness d<sub>q</sub>
              and refractive index n<sub>q</sub> (possibly complex). <b>Ignore all reflections</b>. Find the <b>complex amplitude transmittance</b>
              of the plate. Then replace the plate by a free-space distance d and choose d so the same transmittance is obtained. Show that
              this d equals the <b>optical pathlength</b> defined as Σ n<sub>q</sub>d<sub>q</sub>.
            </p>

            <div class="two">
              <div class="callout">
                <div class="tag">Given</div>
                <p>
                  N layers; (n<sub>q</sub>, d<sub>q</sub>); normal incidence; reflections neglected.
                </p>
              </div>
              <div class="callout">
                <div class="tag">Must find / prove</div>
                <p>
                  Complex amplitude transmittance t; equivalent free-space thickness d that yields identical t; show d = Σ n<sub>q</sub>d<sub>q</sub>.
                </p>
              </div>
            </div>

            <h3>Relevant principles and why they apply</h3>
            <ul class="bullets">
              <li><b>Local plane-wave approximation (Fresnel/paraxial):</b> a spherical wavefront has slowly varying normal direction over small patches, so locally it behaves like a plane wave with a local wavevector.</li>
              <li><b>Plane-wave reflection law:</b> for a plane interface, tangential components of the wavevector are conserved, giving θ<sub>r</sub>=θ<sub>i</sub> and mirror symmetry of k about the surface normal.</li>
              <li><b>Phase accumulation in uniform media:</b> for normal incidence through thickness d, a plane wave gains phase k·d, where k = n k<sub>0</sub> and k<sub>0</sub>=2π/λ.</li>
              <li><b>Neglecting reflections:</b> removes multiple-beam interference; the transmitted field is just the incident field multiplied by the product of propagation factors through each layer.</li>
            </ul>

            <h3>Possible approaches (compare 2–3)</h3>
            <div class="two">
              <div class="callout">
                <strong>Approach A (mirror): Method of images / wavefront normals</strong>
                <p class="note">Use local k reflection + geometric reconstruction: reflected wavefronts match those of a spherical wave from the mirror image point. Fast and physically transparent.</p>
              </div>
              <div class="callout">
                <strong>Approach B (mirror): Boundary condition on phase (equal optical path)</strong>
                <p class="note">Impose that the mirror is an equiphase reflector; construct reflected phase so that total field satisfies reflection symmetry. Also works, but less direct.</p>
              </div>
            </div>
            <div class="two">
              <div class="callout">
                <strong>Approach C (multilayer): Multiply propagation factors</strong>
                <p class="note">Each layer contributes exp(i n<sub>q</sub>k<sub>0</sub>d<sub>q</sub>). Product gives exp(i k<sub>0</sub>Σ n<sub>q</sub>d<sub>q</sub>). Clean and minimal.</p>
              </div>
              <div class="callout">
                <strong>Approach D (multilayer): Transfer matrices</strong>
                <p class="note">General, includes reflections. Here it is overkill because the problem explicitly says to ignore reflections.</p>
              </div>
            </div>

            <h3>Chosen best approach</h3>
            <p>
              For <b>2-4-7</b>, we use <b>local plane-wave reflection</b> plus geometric reconstruction; it directly converts the spherical wave into an
              equivalent <b>virtual image source</b>. For <b>2-4-8</b>, we use <b>phase accumulation</b> and multiply the propagation factors of layers; it matches the “ignore reflections” assumption exactly.
            </p>
          </div>
        </section>

        <section id="part2" class="card">
          <div class="sec">
            <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

            <h3>Step-by-step plan (no algebra yet)</h3>
            <ol class="bullets">
              <li><b>Define geometry (mirror problem):</b> set mirror plane and place the point source. <span class="small">Tool: coordinates and wavefront normals.</span></li>
              <li><b>Write local wavevector of spherical wave:</b> direction is radial from the source. <span class="small">Tool: k points along ∇(phase).</span></li>
              <li><b>Apply plane-wave reflection law to k:</b> reflect k across the mirror normal. <span class="small">Tool: k<sub>r</sub> = k<sub>i</sub> − 2(k<sub>i</sub>·n̂)n̂.</span></li>
              <li><b>Reconstruct the reflected wavefront:</b> show the reflected rays/phase normals point as if from the mirror image point. <span class="small">Tool: geometric symmetry.</span></li>
              <li><b>Define the multilayer propagation factor:</b> normal incidence gives phase advance per layer. <span class="small">Tool: exp(i k d).</span></li>
              <li><b>Multiply layer factors to get total t:</b> product collapses to an exponential of a sum. <span class="small">Tool: exp(a)exp(b)=exp(a+b).</span></li>
              <li><b>Set equivalent free-space distance:</b> equate exponents to solve for d. <span class="small">Tool: compare complex phases.</span></li>
              <li><b>Sanity checks:</b> units, limiting cases (N=1, n→1), physical meaning (phase delay, attenuation if Im(n)>0).</li>
            </ol>

            <h3>Common mistakes & quick tips</h3>
            <ul class="bullets">
              <li><b>Mirror problem:</b> Don’t confuse the “image source” (virtual) with a real source behind the mirror; it’s a mathematical equivalent in the region of interest.</li>
              <li><b>Local plane-wave:</b> The Fresnel assumption is about <b>slow variation</b> of direction across the wavefront patch; it does not mean the wave is globally plane.</li>
              <li><b>Multilayer transmittance:</b> “Ignore reflections” means no Fresnel transmission coefficients or multiple reflections—only propagation phase (and absorption if n is complex).</li>
              <li><b>Optical pathlength:</b> Keep track that n can be complex: Re(n) controls phase, Im(n) controls attenuation.</li>
            </ul>
          </div>
        </section>

        <section id="part3" class="card">
          <div class="sec">
            <h2>PART 3 — Full Solution</h2>

            <article>
              <h3>2-4-7 Reflection of a Spherical Wave from a Planar Mirror</h3>

              <p>
                <b>Physical intuition.</b> A plane mirror reflects rays as if they came from the mirror image of the source.
                A spherical wave is just a continuous bundle of rays (normals to the wavefront). If each local ray reflects by the usual law,
                the reflected bundle should look like it originates from a point symmetric to the real source across the mirror plane.
                That would mean the reflected wavefront is again <b>spherical</b>.
              </p>

              <div class="callout">
                <div class="tag">Setup</div>
                <p class="note">
                  Choose coordinates so the mirror is the plane z=0 with unit normal n̂ = +ẑ (pointing toward z&gt;0).
                  Put a point source at S = (0,0,−s), with s&gt;0.
                  The incident field (up to a constant) is a spherical wave:
                </p>
                <div class="eq">
                  <div class="label">Incident spherical wave (monochromatic)</div>
                  <code id="eq_incident">E_i(r) ∝ (1/|r−S|) · exp(i k0 |r−S|),   k0 = 2π/λ</code>
                </div>
                <div class="copybar">
                  <button class="copy" data-copy="E_i(r) ∝ (1/|r−S|) · exp(i k0 |r−S|),   k0 = 2π/λ">Copy equation</button>
                </div>
              </div>

              <p>
                <b>Step 1: Local plane-wave description.</b>
                The phase of E<sub>i</sub> is φ<sub>i</sub>(r)=k<sub>0</sub>|r−S|.
                The local wavevector is proportional to the gradient of phase:
              </p>

              <div class="eq">
                <div class="label">Local wavevector direction of a spherical wave</div>
                <code id="eq_ki">k_i(r) = ∇φ_i(r) = k0 · (r−S)/|r−S|</code>
              </div>
              <div class="copybar">
                <button class="copy" data-copy="k_i(r) = ∇φ_i(r) = k0 · (r−S)/|r−S|">Copy equation</button>
              </div>

              <p>
                This means that at each point on the mirror, the incident field looks like a plane wave whose propagation direction is
                along the radial unit vector from the source to that point.
              </p>

              <p>
                <b>Step 2: Reflect the local plane wavevector at the plane z=0.</b>
                For a planar mirror/interface, the reflected wavevector is obtained by reflecting k about the surface normal n̂:
              </p>

              <div class="eq">
                <div class="label">Plane-wave reflection of a wavevector</div>
                <code id="eq_reflect_k">k_r = k_i − 2 (k_i · n̂) n̂</code>
              </div>
              <div class="copybar">
                <button class="copy" data-copy="k_r = k_i − 2 (k_i · n̂) n̂">Copy equation</button>
              </div>

              <p>
                With n̂=ẑ, this operation flips the z-component: (k<sub>x</sub>,k<sub>y</sub>,k<sub>z</sub>) → (k<sub>x</sub>,k<sub>y</sub>,−k<sub>z</sub>).
                So at a mirror point P=(x,y,0), the incident direction is along (P−S)=(x,y,s). The reflected direction is therefore along (x,y,−s).
              </p>

              <p>
                <b>Step 3: Identify a source that produces those reflected directions.</b>
                Consider the point S′=(0,0,+s), i.e., the mirror image of S across z=0.
                The vector from S′ to the same point P is:
              </p>

              <div class="eq">
                <div class="label">Vector from image point to mirror point</div>
                <code id="eq_sp">P − S′ = (x, y, 0) − (0,0,s) = (x, y, −s)</code>
              </div>
              <div class="copybar">
                <button class="copy" data-copy="P − S′ = (x, y, −s)">Copy equation</button>
              </div>

              <p>
                That direction (x,y,−s) matches exactly the reflected direction we obtained from the plane-wave reflection law.
                Therefore, the reflected rays (normals to the reflected wavefront) point as if they originated from S′.
                This identifies the reflected wave as a <b>spherical wave centered at the image point</b>.
              </p>

              <div class="boxed-final">
                <h3>Result for 2-4-7 (Nature of the reflected wave)</h3>
                <div class="eq">
                  <div class="label">Reflected field in the region of the source (up to an overall reflection phase)</div>
                  <code id="eq_mirror_final">E_r(r) ∝ (1/|r−S′|) · exp(i k0 |r−S′|),   where S′ is the mirror image of S across the plane.</code>
                </div>
                <div class="copybar">
                  <button class="copy" data-copy="E_r(r) ∝ (1/|r−S′|) · exp(i k0 |r−S′|),   where S′ is the mirror image of S across the plane.">Copy final</button>
                </div>
                <p class="note">
                  Depending on convention, an additional constant phase factor (often −1 for a perfect electric conductor for the electric field)
                  may multiply the field; it does not change the <b>spherical</b> nature of the reflected wavefront.
                </p>
              </div>

              <h3>Sanity checks (2-4-7)</h3>
              <ul class="bullets">
                <li><b>Units:</b> k<sub>0</sub>|r−S′| is dimensionless (rad), so exp(i·) is consistent.</li>
                <li><b>Limiting case:</b> If the source is very far (s → ∞), the spherical wave locally becomes plane; reflection reduces to the standard plane-wave reflection with constant direction.</li>
                <li><b>Physical meaning:</b> The mirror does not “flatten” the wave; it re-centers it to the image point so the wavefront curvature is preserved (with mirrored origin).</li>
              </ul>
            </article>

            <div class="hr"></div>

            <article>
              <h3>2-4-8 Optical Pathlength and Complex Amplitude Transmittance</h3>

              <p>
                <b>Physical intuition.</b> If reflections are ignored, nothing “bounces” inside the plate.
                The wave simply propagates forward through each layer, accumulating phase (and attenuation if the index is complex).
                The total effect is the product of each layer’s propagation factor.
              </p>

              <div class="callout">
                <div class="tag">Definitions</div>
                <p class="note">
                  Let λ be the free-space wavelength and k<sub>0</sub>=2π/λ.
                  In layer q, the (possibly complex) wavenumber is k<sub>q</sub> = n<sub>q</sub>k<sub>0</sub>.
                </p>
                <div class="eq">
                  <div class="label">Propagation in one uniform layer (normal incidence)</div>
                  <code id="eq_one_layer">E_out = E_in · exp(i k_q d_q) = E_in · exp(i n_q k0 d_q)</code>
                </div>
                <div class="copybar">
                  <button class="copy" data-copy="E_out = E_in · exp(i k_q d_q) = E_in · exp(i n_q k0 d_q)">Copy equation</button>
                </div>
              </div>

              <p>
                <b>Step 1: Multiply the layer factors.</b>
                Since reflections are ignored, the transmitted field after N layers is:
              </p>

              <div class="eq">
                <div class="label">Total complex amplitude transmittance (no reflections)</div>
                <code id="eq_t_product">t = E_trans/E_inc = Π_{q=1..N} exp(i n_q k0 d_q)</code>
              </div>
              <div class="copybar">
                <button class="copy" data-copy="t = E_trans/E_inc = Π_{q=1..N} exp(i n_q k0 d_q)">Copy equation</button>
              </div>

              <p>
                Using exp(a)exp(b)=exp(a+b), the product collapses to a single exponential:
              </p>

              <div class="eq">
                <div class="label">Collapsed form</div>
                <code id="eq_t_sum">t = exp(i k0 · Σ_{q=1..N} n_q d_q)</code>
              </div>
              <div class="copybar">
                <button class="copy" data-copy="t = exp(i k0 · Σ_{q=1..N} n_q d_q)">Copy equation</button>
              </div>

              <p>
                If n<sub>q</sub>=n′<sub>q</sub>+i n″<sub>q</sub> (with n″&gt;0 meaning loss), then:
              </p>

              <div class="eq">
                <div class="label">Phase + attenuation separated</div>
                <code id="eq_t_sep">t = exp(i k0 Σ n′_q d_q) · exp(− k0 Σ n″_q d_q)</code>
              </div>
              <div class="copybar">
                <button class="copy" data-copy="t = exp(i k0 Σ n′_q d_q) · exp(− k0 Σ n″_q d_q)">Copy equation</button>
              </div>

              <p>
                <b>Step 2: Equivalent free-space distance.</b>
                Replacing the plate by free space of thickness d means the propagation factor would be:
              </p>

              <div class="eq">
                <div class="label">Free-space propagation factor</div>
                <code id="eq_free">t_free = exp(i k0 d)</code>
              </div>
              <div class="copybar">
                <button class="copy" data-copy="t_free = exp(i k0 d)">Copy equation</button>
              </div>

              <p>
                To obtain the same complex amplitude transmittance, set t<sub>free</sub>=t. Comparing exponents:
              </p>

              <div class="boxed-final" id="final">
                <h3>Result for 2-4-8 (Optical pathlength)</h3>
                <div class="eq">
                  <div class="label">Equivalent free-space thickness (optical pathlength)</div>
                  <code id="eq_opl_final">d = Σ_{q=1..N} n_q d_q  ≡  OPL</code>
                </div>
                <div class="copybar">
                  <button class="copy" data-copy="d = Σ_{q=1..N} n_q d_q  ≡  OPL">Copy final</button>
                </div>
                <p class="note">
                  Thus the plate’s effect (without reflections) is identical to free-space propagation through a distance equal to the sum of
                  refractive index times physical thickness — the <b>optical pathlength</b>.
                </p>
              </div>

              <h3>Sanity checks (2-4-8)</h3>
              <ul class="bullets">
                <li><b>Units:</b> n is dimensionless and d<sub>q</sub> has length, so OPL has length and k<sub>0</sub>·OPL is dimensionless.</li>
                <li><b>Limiting cases:</b> If N=1, t=exp(i n k<sub>0</sub>d). If all n<sub>q</sub>=1, then OPL=Σ d<sub>q</sub>, i.e., just the physical thickness in free space.</li>
                <li><b>Physical meaning:</b> Re(n) increases phase delay; Im(n) causes exponential attenuation of amplitude.</li>
              </ul>
            </article>
          </div>
        </section>

        <footer>
          Built with vanilla HTML/CSS/JS. Canvases are high-DPI aware and resize responsively. Use the copy buttons to grab key equations.
        </footer>
      </main>
    </div>
  </div>

  <script>
    // ---------- Utilities ----------
    const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
    const TAU = Math.PI*2;

    function wrapToPi(x){
      // wrap to [-pi, pi]
      let y = ((x + Math.PI) % (TAU));
      if (y < 0) y += TAU;
      return y - Math.PI;
    }

    function niceTicks(min, max, target=6){
      // simple "nice" ticks
      const span = max - min;
      if (!(span > 0)) return {step:1, start:min, end:max, ticks:[min,max]};
      const raw = span / target;
      const pow = Math.pow(10, Math.floor(Math.log10(raw)));
      const candidates = [1,2,5,10].map(m=>m*pow);
      let step = candidates[0];
      for (const c of candidates){
        if (Math.abs(raw - c) < Math.abs(raw - step)) step = c;
      }
      const start = Math.ceil(min/step)*step;
      const end = Math.floor(max/step)*step;
      const ticks = [];
      for (let v=start; v<=end+1e-12; v+=step) ticks.push(v);
      return {step, start, end, ticks};
    }

    function setupHiDPICanvas(canvas){
      const ctx = canvas.getContext('2d');
      function resize(){
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        const w = Math.max(2, Math.floor(rect.width));
        const h = Math.max(2, Math.floor(rect.height));
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
        return {w,h,dpr};
      }
      return {ctx, resize};
    }

    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, opts){
      const {
        title="", xLabel="", yLabel="", grid=true,
        xUnit="", yUnit="", legend=null,
        yRight=null // {yMin,yMax,label}
      } = opts || {};
      const {x,y,w,h} = box;

      // background
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.strokeStyle = 'rgba(255,255,255,0.10)';
      ctx.lineWidth = 1;
      roundRect(ctx, x, y, w, h, 14);
      ctx.fill();
      ctx.stroke();

      // plot region
      const padL = 56, padR = yRight ? 56 : 18, padT = 34, padB = 46;
      const px = x + padL, py = y + padT, pw = w - padL - padR, ph = h - padT - padB;

      // title
      ctx.fillStyle = 'rgba(255,255,255,0.90)';
      ctx.font = '700 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(title, x+12, y+10);

      // ticks
      const xt = niceTicks(xMin, xMax, 6);
      const yt = niceTicks(yMin, yMax, 6);
      const xMap = (X)=> px + (X - xMin) / (xMax - xMin) * pw;
      const yMap = (Y)=> py + (1 - (Y - yMin) / (yMax - yMin)) * ph;

      if (grid){
        ctx.strokeStyle = 'rgba(255,255,255,0.10)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (const t of xt.ticks){
          const X = xMap(t);
          ctx.moveTo(X, py);
          ctx.lineTo(X, py+ph);
        }
        for (const t of yt.ticks){
          const Y = yMap(t);
          ctx.moveTo(px, Y);
          ctx.lineTo(px+pw, Y);
        }
        ctx.stroke();
      }

      // axes lines
      ctx.strokeStyle = 'rgba(255,255,255,0.22)';
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(px, py+ph);
      ctx.lineTo(px+pw, py+ph);
      ctx.moveTo(px, py);
      ctx.lineTo(px, py+ph);
      if (yRight){
        ctx.moveTo(px+pw, py);
        ctx.lineTo(px+pw, py+ph);
      }
      ctx.stroke();

      // tick labels
      ctx.fillStyle = 'rgba(255,255,255,0.72)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      for (const t of xt.ticks){
        const X = xMap(t);
        ctx.fillText(formatTick(t), X, py+ph+6);
      }
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      for (const t of yt.ticks){
        const Y = yMap(t);
        ctx.fillText(formatTick(t), px-8, Y);
      }

      if (yRight){
        const y2t = niceTicks(yRight.yMin, yRight.yMax, 6);
        const y2Map = (Y)=> py + (1 - (Y - yRight.yMin) / (yRight.yMax - yRight.yMin)) * ph;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        for (const t of y2t.ticks){
          const Y = y2Map(t);
          ctx.fillText(formatTick(t), px+pw+8, Y);
        }
      }

      // labels
      ctx.fillStyle = 'rgba(255,255,255,0.78)';
      ctx.font = '650 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText(xLabel + (xUnit ? ` (${xUnit})` : ''), px+pw/2, y+h-10);

      ctx.save();
      ctx.translate(x+14, py+ph/2);
      ctx.rotate(-Math.PI/2);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText(yLabel + (yUnit ? ` (${yUnit})` : ''), 0, 0);
      ctx.restore();

      if (yRight){
        ctx.save();
        ctx.translate(x+w-14, py+ph/2);
        ctx.rotate(Math.PI/2);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText(yRight.label, 0, 0);
        ctx.restore();
      }

      // legend (simple)
      if (legend && legend.length){
        const lx = px + 8;
        let ly = py + 8;
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        for (const item of legend){
          ctx.fillStyle = item.color;
          ctx.fillRect(lx, ly+3, 10, 3);
          ctx.fillStyle = 'rgba(255,255,255,0.78)';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          ctx.fillText(item.label, lx+14, ly);
          ly += 16;
        }
      }

      ctx.restore();
      return {plot:{x:px,y:py,w:pw,h:ph}, xMap, yMap, yRightMap: yRight ? ((Y)=> py + (1 - (Y - yRight.yMin) / (yRight.yMax - yRight.yMin)) * ph) : null};
    }

    function formatTick(v){
      const av = Math.abs(v);
      if (av >= 1000 || (av > 0 && av < 0.01)) return v.toExponential(1);
      if (av >= 100) return v.toFixed(0);
      if (av >= 10) return v.toFixed(1);
      if (av >= 1) return v.toFixed(2);
      return v.toFixed(3);
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function strokePath(ctx, pts, color='rgba(139,233,253,0.85)', width=2){
      if (pts.length < 2) return;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();
      ctx.restore();
    }

    // ---------- Problem-specific math for plots ----------
    // Mirror example geometry:
    const geom = {
      s: 0.30,      // source distance from mirror (m), source at z = -s
      zScr: 0.10,   // screen at z = -zScr (m), in front of mirror
      xMax: 0.025   // +/- range on screen in meters
    };

    // Reflected wave equivalent to spherical from image S' at z=+s, evaluated on screen z=-zScr.
    function mirrorDeltaPhase(x, lambda){
      const k0 = TAU / lambda; // lambda in meters
      const a = (geom.zScr + geom.s); // distance from screen plane to image along z
      const r = Math.sqrt(x*x + a*a);
      const r0 = a;
      const d = r - r0;
      return k0 * d; // radians
    }

    // Fresnel (paraxial) approximation for d = r - r0 ≈ x^2/(2a)
    function mirrorDeltaPhaseFresnel(x, lambda){
      const k0 = TAU / lambda;
      const a = (geom.zScr + geom.s);
      const d = x*x/(2*a);
      return k0*d;
    }

    // Multilayer example: (n,d) with d in meters
    const layers = [
      {nRe:1.45, nIm:0.002, d:0.0008},
      {nRe:2.00, nIm:0.002, d:0.0003},
      {nRe:1.60, nIm:0.002, d:0.0005}
    ];

    function OPL_complex(){
      let re=0, im=0;
      for (const L of layers){
        re += L.nRe * L.d;
        im += L.nIm * L.d;
      }
      return {re, im}; // meters (re) and meters (im) as effective lengths in exponent
    }

    function multilayer_t(lambda){
      // lambda in meters
      const k0 = TAU / lambda;
      const opl = OPL_complex();
      const phase = k0 * opl.re;         // radians
      const mag = Math.exp(-k0 * opl.im); // amplitude magnitude
      return {phase, mag};
    }

    // ---------- Canvases ----------
    const elLambda = document.getElementById('lambda');
    const elLambdaOut = document.getElementById('lambdaOut');
    const elMainMode = document.getElementById('mainMode');

    const cDiagram = document.getElementById('cDiagram');
    const cMain = document.getElementById('cMain');
    const cSecond = document.getElementById('cSecond');

    const diag = setupHiDPICanvas(cDiagram);
    const main = setupHiDPICanvas(cMain);
    const sec = setupHiDPICanvas(cSecond);

    function currentLambdaMeters(){
      return Number(elLambda.value) * 1e-9;
    }

    function renderAll(){
      const lam = currentLambdaMeters();
      elLambdaOut.textContent = `${Number(elLambda.value)} nm`;
      drawDiagram(lam);
      drawMain(lam);
      drawSecondary(lam);
    }

    // ---------- Diagram drawing ----------
    function drawDiagram(lambda){
      const {ctx, resize} = diag;
      const {w,h} = resize();

      ctx.clearRect(0,0,w,h);

      // Split into two panels: left mirror setup, right multilayer.
      const pad = 12;
      const mid = Math.floor(w*0.58);
      const left = {x:pad,y:pad,w:mid-pad*1.5,h:h-pad*2};
      const right = {x:mid+pad*0.5,y:pad,w:w-mid-pad*1.5,h:h-pad*2};

      // Panel backgrounds
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 1;
      roundRect(ctx,left.x,left.y,left.w,left.h,16); ctx.fill(); ctx.stroke();
      roundRect(ctx,right.x,right.y,right.w,right.h,16); ctx.fill(); ctx.stroke();

      // Title
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.font = '800 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign='left'; ctx.textBaseline='top';
      ctx.fillText('Mirror (2-4-7): real source S and image S′', left.x+12, left.y+10);
      ctx.fillText('Multilayer plate (2-4-8): phase accumulation', right.x+12, right.y+10);

      // Left: mirror geometry
      const lx0 = left.x + 18;
      const ly0 = left.y + 40;
      const lw0 = left.w - 36;
      const lh0 = left.h - 58;

      // Coordinate mapping in left panel: z vertical axis, x horizontal axis
      // We'll draw mirror as vertical line in the panel (z axis vertical), with z=0 in middle.
      const xMin = -0.035, xMax = 0.035; // meters
      const zMin = -0.40, zMax = 0.40;
      const mapX = (xm)=> lx0 + (xm - xMin)/(xMax-xMin)*lw0;
      const mapZ = (zm)=> ly0 + (1-(zm - zMin)/(zMax-zMin))*lh0;

      // Mirror plane z=0 (horizontal line)
      ctx.strokeStyle = 'rgba(139,233,253,0.55)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(lx0, mapZ(0));
      ctx.lineTo(lx0+lw0, mapZ(0));
      ctx.stroke();

      // Label mirror
      ctx.fillStyle = 'rgba(139,233,253,0.9)';
      ctx.font = '650 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Mirror plane z=0', lx0+8, mapZ(0)-18);

      // Draw real source S at z=-s
      const S = {x:0, z:-geom.s};
      const Sp = {x:0, z:+geom.s};
      drawPoint(ctx, mapX(S.x), mapZ(S.z), 'S', 'rgba(255,255,255,0.9)');
      drawPoint(ctx, mapX(Sp.x), mapZ(Sp.z), "S′", 'rgba(168,255,96,0.95)');

      // Draw a few incident rays to mirror and reflected rays from mirror consistent with image
      const rayXs = [-0.02, -0.01, 0, 0.01, 0.02];
      for (const xr of rayXs){
        const P = {x:xr, z:0};
        // Incident segment S -> P
        line(ctx, mapX(S.x), mapZ(S.z), mapX(P.x), mapZ(P.z), 'rgba(255,255,255,0.25)', 1.5);
        // Reflected segment P -> screen point (approx) in z<0 direction along reflected ray
        // Use direction from image S′ to P, then extend into z<0
        const dir = {x: P.x - Sp.x, z: P.z - Sp.z}; // points downward
        const norm = Math.hypot(dir.x, dir.z) || 1;
        const u = {x: dir.x/norm, z: dir.z/norm};
        const Q = {x: P.x + u.x*0.25, z: P.z + u.z*0.25};
        line(ctx, mapX(P.x), mapZ(P.z), mapX(Q.x), mapZ(Q.z), 'rgba(168,255,96,0.25)', 1.5);
      }

      // Screen line at z = -zScr
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(lx0, mapZ(-geom.zScr));
      ctx.lineTo(lx0+lw0, mapZ(-geom.zScr));
      ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText(`Screen z=−${geom.zScr.toFixed(2)} m`, lx0+8, mapZ(-geom.zScr)+6);

      // Draw wavefront arcs (schematic): circles centered at S and S′ crossing near mirror.
      drawArcWavefront(ctx, mapX, mapZ, S, 0.18, 'rgba(255,255,255,0.18)');
      drawArcWavefront(ctx, mapX, mapZ, Sp, 0.18, 'rgba(168,255,96,0.18)');

      // Add wavelength annotation
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.font = '12px ' + getMonoFont();
      ctx.fillText(`λ = ${(lambda*1e9).toFixed(0)} nm`, lx0+lw0-120, ly0-18);

      // Right: multilayer stack
      const rx0 = right.x + 18;
      const ry0 = right.y + 40;
      const rw0 = right.w - 36;
      const rh0 = right.h - 58;

      // Draw incoming plane wave arrows from left
      const waveY0 = ry0 + rh0*0.5;
      for (let i=0;i<5;i++){
        const x = rx0 + 6 + i*22;
        arrow(ctx, x, waveY0, x+14, waveY0, 'rgba(255,255,255,0.35)', 2);
      }
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Incident plane wave →', rx0+8, waveY0-26);

      // Stack rectangle
      const stackX = rx0 + rw0*0.35;
      const stackW = rw0*0.45;
      const stackY = ry0 + 22;
      const stackH = rh0 - 44;

      // Draw layers as vertical slices
      const totalD = layers.reduce((s,L)=>s+L.d,0);
      let xCursor = stackX;
      for (let i=0;i<layers.length;i++){
        const L = layers[i];
        const frac = L.d / totalD;
        const wLayer = stackW * frac;
        ctx.fillStyle = i%2===0 ? 'rgba(139,233,253,0.10)' : 'rgba(168,255,96,0.10)';
        ctx.strokeStyle = 'rgba(255,255,255,0.16)';
        ctx.lineWidth = 1;
        ctx.fillRect(xCursor, stackY, wLayer, stackH);
        ctx.strokeRect(xCursor, stackY, wLayer, stackH);

        ctx.fillStyle = 'rgba(255,255,255,0.78)';
        ctx.font = '12px ' + getMonoFont();
        ctx.textAlign='center';
        ctx.textBaseline='middle';
        const label = `n${i+1}=${layers[i].nRe.toFixed(2)}` + (layers[i].nIm>0?`+i${layers[i].nIm.toFixed(3)}`:'');
        ctx.fillText(label, xCursor + wLayer/2, stackY + stackH*0.35);
        ctx.fillText(`d${i+1}=${(layers[i].d*1e3).toFixed(1)} mm`, xCursor + wLayer/2, stackY + stackH*0.55);

        xCursor += wLayer;
      }

      // Outgoing arrows to right
      const outX = stackX + stackW + 10;
      for (let i=0;i<5;i++){
        const x = outX + i*22;
        arrow(ctx, x, waveY0, x+14, waveY0, 'rgba(168,255,96,0.35)', 2);
      }
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign='left';
      ctx.fillText('Transmitted field', outX, waveY0-26);

      // Annotate OPL
      const opl = OPL_complex();
      ctx.fillStyle = 'rgba(255,255,255,0.80)';
      ctx.font = '650 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText(`OPL = Σ n_q d_q ≈ ${ (opl.re*1e3).toFixed(2) } mm (Re)`, rx0+8, ry0+rh0-22);

      ctx.restore();
    }

    function getMonoFont(){
      return 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    }

    function drawPoint(ctx, x, y, label, color){
      ctx.save();
      ctx.fillStyle = color;
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x,y,5,0,TAU);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,0.80)';
      ctx.font = '700 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign='left';
      ctx.textBaseline='middle';
      ctx.fillText(label, x+8, y);
      ctx.restore();
    }

    function line(ctx, x1,y1,x2,y2,color,w){
      ctx.save();
      ctx.strokeStyle=color;
      ctx.lineWidth=w;
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
      ctx.restore();
    }

    function arrow(ctx, x1,y1,x2,y2,color,w){
      const dx=x2-x1, dy=y2-y1;
      const L=Math.hypot(dx,dy)||1;
      const ux=dx/L, uy=dy/L;
      const ah=6;
      ctx.save();
      ctx.strokeStyle=color;
      ctx.fillStyle=color;
      ctx.lineWidth=w;
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x2,y2);
      ctx.lineTo(x2-ux*ah-uy*(ah*0.6), y2-uy*ah+ux*(ah*0.6));
      ctx.lineTo(x2-ux*ah+uy*(ah*0.6), y2-uy*ah-ux*(ah*0.6));
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawArcWavefront(ctx, mapX, mapZ, center, radius, color){
      // draw a partial circle arc near the mirror region (schematic)
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.setLineDash([6,6]);
      const cx = mapX(center.x);
      const cy = mapZ(center.z);
      const rpx = Math.abs(mapX(center.x + radius) - mapX(center.x));
      // arc from about -60 to +60 degrees around direction toward mirror
      ctx.beginPath();
      ctx.arc(cx, cy, rpx, -Math.PI*0.10, Math.PI*0.10, false);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    // ---------- Main plot ----------
    function drawMain(lambda){
      const {ctx, resize} = main;
      const {w,h} = resize();
      ctx.clearRect(0,0,w,h);

      const mode = elMainMode.value;

      // sample x across screen
      const N = 401;
      const xMin = -geom.xMax;
      const xMax = geom.xMax;

      // y = wrapped phase in [-pi,pi]
      const xs = new Array(N);
      const ys = new Array(N);
      const ysF = new Array(N);

      for (let i=0;i<N;i++){
        const x = xMin + (xMax-xMin)*i/(N-1);
        xs[i]=x;
        const dphi = mirrorDeltaPhase(x, lambda);
        ys[i]=wrapToPi(dphi);
        ysF[i]=wrapToPi(mirrorDeltaPhaseFresnel(x, lambda));
      }

      const yMin = -Math.PI, yMax = Math.PI;

      const axes = drawAxes(ctx, {x:10,y:10,w:w-20,h:h-20}, xMin*1e2, xMax*1e2, yMin, yMax, {
        title: (mode==='phase') ? 'Mirror-reflected spherical wave: wrapped phase on screen' : 'Mirror: wrapped phase and Fresnel (paraxial) prediction',
        xLabel: 'x on screen', xUnit:'cm',
        yLabel: 'Δφ wrapped', yUnit:'rad',
        legend: (mode==='phase') ? [
          {label:'Exact Δφ(x) from image source', color:'rgba(139,233,253,0.85)'}
        ] : [
          {label:'Exact Δφ(x)', color:'rgba(139,233,253,0.85)'},
          {label:'Fresnel approx Δφ≈k x²/(2R)', color:'rgba(168,255,96,0.80)'}
        ]
      });

      const {plot, xMap, yMap} = axes;

      // draw curve(s)
      const ptsExact = [];
      const ptsF = [];
      for (let i=0;i<N;i++){
        const xcm = xs[i]*1e2;
        ptsExact.push({x:xMap(xcm), y:yMap(ys[i])});
        ptsF.push({x:xMap(xcm), y:yMap(ysF[i])});
      }
      strokePath(ctx, ptsExact, 'rgba(139,233,253,0.85)', 2.2);
      if (mode !== 'phase'){
        strokePath(ctx, ptsF, 'rgba(168,255,96,0.80)', 2.0);
      }

      // annotate key parameter R ~ a (distance to image along z)
      const R = (geom.zScr + geom.s);
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.70)';
      ctx.font = '12px ' + getMonoFont();
      ctx.textAlign='left';
      ctx.textBaseline='bottom';
      ctx.fillText(`Example: R ≈ zScr + s = ${R.toFixed(2)} m`, plot.x+8, plot.y+plot.h-8);
      ctx.restore();
    }

    // ---------- Secondary plot ----------
    function drawSecondary(lambda){
      const {ctx, resize} = sec;
      const {w,h} = resize();
      ctx.clearRect(0,0,w,h);

      // sweep wavelength range for display
      const lamMin = 0.4e-6, lamMax = 1.6e-6;
      const N = 420;
      const lams = new Array(N);
      const phases = new Array(N);
      const mags = new Array(N);

      for (let i=0;i<N;i++){
        const lam = lamMin + (lamMax-lamMin)*i/(N-1);
        lams[i]=lam;
        const t = multilayer_t(lam);
        phases[i]=wrapToPi(t.phase); // show wrapped
        mags[i]=t.mag;
      }

      const xMin = lamMin*1e9, xMax = lamMax*1e9;
      const yMin = -Math.PI, yMax = Math.PI;
      const y2Min = 0, y2Max = 1;

      const axes = drawAxes(ctx, {x:10,y:10,w:w-20,h:h-20}, xMin, xMax, yMin, yMax, {
        title: 'Multilayer transmittance (no reflections): phase (wrapped) and magnitude',
        xLabel: 'wavelength λ', xUnit:'nm',
        yLabel: 'arg(t) wrapped', yUnit:'rad',
        yRight: {yMin:y2Min, yMax:y2Max, label:'|t| (amplitude)'},
        legend: [
          {label:'Phase of t (wrapped)', color:'rgba(139,233,253,0.85)'},
          {label:'Magnitude |t|', color:'rgba(168,255,96,0.80)'},
          {label:'Current λ marker', color:'rgba(255,209,102,0.95)'}
        ]
      });

      const {plot, xMap, yMap, yRightMap} = axes;

      // curves
      const ptsPhase = [];
      const ptsMag = [];
      for (let i=0;i<N;i++){
        const xnm = lams[i]*1e9;
        ptsPhase.push({x:xMap(xnm), y:yMap(phases[i])});
        ptsMag.push({x:xMap(xnm), y:yRightMap(mags[i])});
      }
      strokePath(ctx, ptsPhase, 'rgba(139,233,253,0.85)', 2.2);
      strokePath(ctx, ptsMag, 'rgba(168,255,96,0.80)', 2.2);

      // current lambda marker
      const lamNm = lambda*1e9;
      const xM = xMap(lamNm);
      ctx.save();
      ctx.strokeStyle = 'rgba(255,209,102,0.95)';
      ctx.lineWidth = 2;
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(xM, plot.y);
      ctx.lineTo(xM, plot.y+plot.h);
      ctx.stroke();
      ctx.setLineDash([]);

      // display current t values
      const tNow = multilayer_t(lambda);
      const phaseNow = wrapToPi(tNow.phase);
      ctx.fillStyle = 'rgba(255,255,255,0.78)';
      ctx.font = '12px ' + getMonoFont();
      ctx.textAlign='left';
      ctx.textBaseline='top';
      const boxX = clamp(xM+8, plot.x+8, plot.x+plot.w-190);
      const boxY = plot.y+10;
      // small info box
      ctx.fillStyle = 'rgba(0,0,0,0.22)';
      ctx.strokeStyle = 'rgba(255,255,255,0.14)';
      roundRect(ctx, boxX, boxY, 182, 58, 12);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,0.82)';
      ctx.fillText(`λ = ${lamNm.toFixed(0)} nm`, boxX+10, boxY+10);
      ctx.fillText(`|t| = ${tNow.mag.toFixed(3)}`, boxX+10, boxY+28);
      ctx.fillText(`arg(t) = ${phaseNow.toFixed(2)} rad`, boxX+10, boxY+44);

      // show equivalent d = OPL (Re part) in text
      const opl = OPL_complex();
      ctx.fillStyle = 'rgba(255,255,255,0.70)';
      ctx.textAlign='left';
      ctx.textBaseline='bottom';
      ctx.fillText(`OPL(Re) = Σ n_q d_q = ${(opl.re*1e3).toFixed(2)} mm`, plot.x+8, plot.y+plot.h-8);
      ctx.restore();
    }

    // ---------- TOC highlighting ----------
    const tocLinks = Array.from(document.querySelectorAll('[data-toc]'));
    const sections = tocLinks.map(a => document.querySelector(a.getAttribute('href'))).filter(Boolean);

    function updateTOC(){
      const y = window.scrollY || document.documentElement.scrollTop;
      let best = 0;
      for (let i=0;i<sections.length;i++){
        const r = sections[i].getBoundingClientRect();
        const top = r.top + y;
        if (top <= y + 120) best = i;
      }
      tocLinks.forEach((a,i)=>a.classList.toggle('active', i===best));
    }

    // smooth scroll
    tocLinks.forEach(a=>{
      a.addEventListener('click', (e)=>{
        e.preventDefault();
        const target = document.querySelector(a.getAttribute('href'));
        if (!target) return;
        target.scrollIntoView({behavior:'smooth', block:'start'});
      });
    });

    // ---------- Copy buttons ----------
    async function copyText(txt){
      try{
        await navigator.clipboard.writeText(txt);
        return true;
      }catch(e){
        // fallback
        const ta = document.createElement('textarea');
        ta.value = txt;
        ta.style.position='fixed';
        ta.style.left='-9999px';
        ta.style.top='-9999px';
        document.body.appendChild(ta);
        ta.select();
        let ok=false;
        try{ ok = document.execCommand('copy'); }catch(err){ ok=false; }
        document.body.removeChild(ta);
        return ok;
      }
    }

    document.querySelectorAll('button.copy').forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        const txt = btn.getAttribute('data-copy') || '';
        const ok = await copyText(txt);
        const old = btn.textContent;
        btn.textContent = ok ? 'Copied!' : 'Copy failed';
        btn.style.borderColor = ok ? 'rgba(168,255,96,0.45)' : 'rgba(255,107,107,0.55)';
        setTimeout(()=>{
          btn.textContent = old;
          btn.style.borderColor = 'rgba(255,255,255,0.14)';
        }, 900);
      });
    });

    // ---------- Events ----------
    elLambda.addEventListener('input', renderAll);
    elMainMode.addEventListener('change', renderAll);

    // Resize redraw
    const ro = new ResizeObserver(()=>renderAll());
    [cDiagram,cMain,cSecond].forEach(c=>ro.observe(c));

    window.addEventListener('scroll', updateTOC, {passive:true});
    window.addEventListener('load', ()=>{ renderAll(); updateTOC(); });

  </script>
</body>
</html>
