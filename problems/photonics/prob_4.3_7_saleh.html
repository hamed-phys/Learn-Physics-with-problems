<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Relation Between Fresnel and Fraunhofer Diffraction (Quadratic Phase Trick)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --card2:#0f1730;
      --text:#e9ecff;
      --muted:#b8c0ffcc;
      --accent:#7cf6ff;
      --accent2:#a78bfa;
      --line:#ffffff1a;
      --good:#75f0a3;
      --warn:#ffd36a;
      --bad:#ff6b9b;
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 900px at 15% 15%, rgba(124,246,255,.18), transparent 55%),
        radial-gradient(1100px 800px at 85% 20%, rgba(167,139,250,.16), transparent 55%),
        radial-gradient(900px 700px at 50% 100%, rgba(117,240,163,.10), transparent 60%),
        var(--bg);
      line-height:1.55;
    }
    header{
      padding:42px 18px 18px;
      max-width:1180px;
      margin:0 auto;
    }
    .title{
      display:flex;
      gap:14px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .badge{
      padding:8px 12px;
      border:1px solid var(--line);
      background:linear-gradient(135deg, rgba(124,246,255,.12), rgba(167,139,250,.10));
      border-radius:999px;
      font-size:13px;
      color:var(--muted);
      letter-spacing:.3px;
    }
    h1{
      font-size: clamp(26px, 3.2vw, 42px);
      line-height:1.15;
      margin:10px 0 10px;
      letter-spacing:-.02em;
    }
    .subtitle{
      color:var(--muted);
      max-width:78ch;
      margin:0 0 14px;
      font-size:15.5px;
    }

    main{
      max-width:1180px;
      margin:0 auto;
      padding:0 18px 64px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
    }

    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background:linear-gradient(180deg, rgba(17,26,51,.82), rgba(15,23,48,.72));
      border:1px solid var(--line);
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      padding:14px 14px 12px;
      backdrop-filter: blur(10px);
    }
    nav.toc h2{
      margin:0 0 10px;
      font-size:14px;
      letter-spacing:.06em;
      text-transform:uppercase;
      color:var(--muted);
    }
    .toc a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      text-decoration:none;
      color:var(--text);
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border .12s ease;
      font-size:14px;
    }
    .toc a:hover{
      background: rgba(124,246,255,.08);
      border-color: rgba(124,246,255,.25);
      transform: translateY(-1px);
    }
    .toc small{
      color:var(--muted);
      display:block;
      margin-top:10px;
      font-size:12.5px;
    }

    article{
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    .card{
      background: linear-gradient(180deg, rgba(17,26,51,.92), rgba(15,23,48,.86));
      border:1px solid var(--line);
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      padding:18px;
      overflow:hidden;
      position:relative;
    }
    .card::before{
      content:"";
      position:absolute;
      inset:-2px -2px auto -2px;
      height:52px;
      background:linear-gradient(90deg, rgba(124,246,255,.18), rgba(167,139,250,.16), rgba(117,240,163,.14));
      filter: blur(10px);
      opacity:.65;
      pointer-events:none;
    }
    .card > *{position:relative}
    h2{
      margin:0 0 10px;
      font-size:20px;
      letter-spacing:-.01em;
    }
    h3{
      margin:14px 0 8px;
      font-size:16px;
      color:var(--text);
    }
    p{margin:8px 0}
    ul{margin:8px 0 8px 18px}
    li{margin:6px 0}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 980px){
      .grid2{grid-template-columns:1fr}
    }

    .callout{
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(124,246,255,.08), rgba(167,139,250,.06));
      border-radius: 16px;
      padding:12px 12px;
    }
    .callout strong{color:var(--accent)}
    .mini{
      font-size:13.5px;
      color:var(--muted);
    }

    .eq{
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding:12px;
      overflow:auto;
      font-family:var(--mono);
      font-size:13.2px;
      line-height:1.45;
      position:relative;
    }
    .copyRow{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-top:10px;
      flex-wrap:wrap;
    }
    .btn{
      border:1px solid rgba(255,255,255,.18);
      background: rgba(124,246,255,.10);
      color:var(--text);
      padding:9px 12px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border .12s ease;
      font-size:13.5px;
      user-select:none;
    }
    .btn:hover{
      transform: translateY(-1px);
      background: rgba(124,246,255,.16);
      border-color: rgba(124,246,255,.28);
    }
    .btn:active{transform: translateY(0px) scale(.99)}
    .btn.secondary{background: rgba(167,139,250,.10)}
    .btn.secondary:hover{background: rgba(167,139,250,.16); border-color: rgba(167,139,250,.28)}
    .status{
      font-size:12.5px;
      color:var(--muted);
    }

    .vizGrid{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .vizGrid{grid-template-columns:1fr}
    }
    .canvasWrap{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      border-radius: 16px;
      padding:10px;
    }
    .canvasTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
      flex-wrap:wrap;
    }
    .canvasTitle strong{font-size:14px}
    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius: 12px;
      background: rgba(10,14,28,.55);
    }
    .small canvas{height:260px}
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    @media (max-width: 600px){
      .controls{grid-template-columns:1fr}
    }
    .control{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      border-radius: 14px;
      padding:12px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:13.5px;
      color:var(--muted);
      margin-bottom:8px;
    }
    input[type="range"]{width:100%}
    select{
      width:100%;
      padding:9px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.25);
      color:var(--text);
      outline:none;
    }

    .boxed{
      border-left:4px solid var(--accent);
      background: rgba(124,246,255,.06);
      padding:12px 12px;
      border-radius: 14px;
    }
    .boxed .eq{margin-top:8px}
    .pill{
      display:inline-block;
      padding:4px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(117,240,163,.10);
      font-size:12px;
      color:var(--muted);
      margin-right:8px;
      vertical-align:middle;
    }

    footer{
      max-width:1180px;
      margin:0 auto;
      padding:18px;
      color:var(--muted);
      font-size:13px;
    }

    /* Subtle motion (reduced motion friendly) */
    @media (prefers-reduced-motion: no-preference){
      .card{animation: rise .35s ease both}
      @keyframes rise{
        from{transform:translateY(6px); opacity:.0}
        to{transform:translateY(0px); opacity:1}
      }
    }

    /* Print */
    @media print{
      body{background:white; color:black}
      nav.toc{display:none}
      main{grid-template-columns:1fr}
      .card{box-shadow:none; background:white; border:1px solid #ddd}
      .eq{background:#f6f6f6; border:1px solid #ddd}
      canvas{background:white; border:1px solid #ddd}
      .btn{display:none}
    }
  </style>
</head>
<body>
<header>
  <div class="title">
    <div class="badge">Fourier Optics ‚Ä¢ Fresnel ‚Üî Fraunhofer</div>
    <div class="badge">Quadratic phase factor</div>
  </div>
  <h1>Relation Between Fresnel and Fraunhofer Diffraction</h1>
  <p class="subtitle">
    We prove that a Fresnel diffraction pattern can be obtained as a Fraunhofer pattern of a <em>modified</em> aperture:
    multiply the aperture by a quadratic phase <span class="mini">(a ‚Äúchirp‚Äù)</span>, then take a far-field Fourier transform.
  </p>
</header>

<main>
  <nav class="toc" aria-label="Table of Contents">
    <h2>Contents</h2>
    <a href="#quick" data-scroll>Quick Summary</a>
    <a href="#part1" data-scroll>Part 1 ‚Äî Problem Analysis</a>
    <a href="#part2" data-scroll>Part 2 ‚Äî Strategy & Tips</a>
    <a href="#part3" data-scroll>Part 3 ‚Äî Full Solution</a>
    <a href="#viz" data-scroll>Interactive Visualizations</a>
    <small>Tip: use the distance slider to see the Fresnel pattern morph and verify the equivalence numerically.</small>
  </nav>

  <article>
    <section class="card" id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li>Fresnel diffraction at distance <span class="pill">d</span> is a convolution with a quadratic-phase kernel.</li>
        <li>Expanding <code>(x-x')¬≤+(y-y')¬≤</code> separates the kernel into: output chirp √ó input chirp √ó a Fourier kernel.</li>
        <li>Therefore, the Fresnel field equals a Fraunhofer (Fourier) transform of <code>p(x,y)¬∑exp(‚àíjœÄ(x¬≤+y¬≤)/(Œªd))</code> (up to known prefactors and a harmless output phase).</li>
        <li>The spatial-frequency mapping is <code>f_x = x'/(Œªd)</code>, <code>f_y = y'/(Œªd)</code>.</li>
        <li>Numerically (example aperture), the intensity profiles from ‚Äúdirect Fresnel‚Äù and ‚ÄúFraunhofer of modified aperture‚Äù match.</li>
      </ul>
    </section>

    <section class="card" id="part1">
      <h2>PART 1 ‚Äî Problem Analysis (no solving yet)</h2>

      <h3>1) Restate the problem</h3>
      <p>
        We are given an aperture (pupil) function <code>p(x,y)</code> in a plane. The task is to show that the
        <strong>Fresnel diffraction pattern</strong> observed a distance <code>d</code> away can be obtained by taking the
        <strong>Fraunhofer diffraction pattern</strong> (i.e., Fourier transform / far-field pattern) of a
        <em>modified</em> aperture:
      </p>
      <div class="boxed">
        <div class="eq" id="eqTarget">
Goal:  Fresnel pattern of p(x,y)  =  Fraunhofer pattern of  p(x,y)¬∑exp( ‚àíjœÄ(x¬≤+y¬≤)/(Œª d) )
(up to known multiplicative constants and an output quadratic phase).
        </div>
        <div class="copyRow">
          <button class="btn" data-copy="#eqTarget">Copy goal (plain text)</button>
          <span class="status" id="stGoal"></span>
        </div>
      </div>

      <h3>2) Given quantities</h3>
      <ul>
        <li><code>p(x,y)</code>: complex aperture function (can encode amplitude and phase).</li>
        <li><code>Œª</code>: wavelength.</li>
        <li><code>d</code>: propagation distance from aperture plane to observation plane.</li>
        <li>Observation-plane coordinates: <code>(x', y')</code>.</li>
      </ul>

      <h3>3) Unknowns / what must be proved</h3>
      <ul>
        <li>Show an <strong>identity</strong> between two diffraction integrals: Fresnel propagation of <code>p</code> and Fraunhofer diffraction of a quadratically phase-modulated version of <code>p</code>.</li>
        <li>Make clear what differences are merely <em>prefactors</em> (global phase, scaling, output quadratic phase) that do not change intensity patterns.</li>
      </ul>

      <h3>4) Relevant physical principles and why they apply</h3>
      <div class="grid2">
        <div class="callout">
          <strong>Scalar diffraction (paraxial) theory</strong>
          <p class="mini">
            Under paraxial conditions (small angles, slowly varying envelope), the field after propagation is described by the Fresnel diffraction integral.
          </p>
        </div>
        <div class="callout">
          <strong>Fourier transform nature of far-field diffraction</strong>
          <p class="mini">
            In the Fraunhofer (far-field) limit, the observation-plane field is proportional to the Fourier transform of the aperture function.
          </p>
        </div>
      </div>
      <p class="mini">
        The ‚Äúbridge‚Äù between them comes from rewriting the Fresnel kernel into a product of chirps and a Fourier kernel.
      </p>

      <h3>5) Possible approaches</h3>
      <ul>
        <li><strong>Kernel expansion approach (best):</strong> start from the Fresnel integral, expand <code>(x-x')¬≤+(y-y')¬≤</code>, and identify a Fourier transform.</li>
        <li><strong>Convolution + Fourier theorem:</strong> express Fresnel propagation as convolution with a quadratic-phase function, then apply the convolution theorem (more abstract).</li>
        <li><strong>Angular spectrum / transfer function:</strong> use the paraxial transfer function <code>H(fx,fy)</code> and show it equals multiplication by a quadratic phase in the spatial domain (more frequency-domain heavy).</li>
      </ul>
      <p>
        We‚Äôll use the <strong>kernel expansion approach</strong> because it is direct, transparent, and matches the problem statement exactly.
      </p>
    </section>

    <section class="card" id="part2">
      <h2>PART 2 ‚Äî Strategy & Tips (roadmap only)</h2>

      <h3>Step-by-step plan (no algebra yet)</h3>
      <ol>
        <li><strong>Write the Fresnel diffraction integral</strong> for the field at <code>(x',y')</code> a distance <code>d</code> away. <span class="mini">Tool: Fresnel approximation.</span></li>
        <li><strong>Expand the quadratic term</strong> <code>(x-x')¬≤+(y-y')¬≤</code> to separate input-only, output-only, and cross terms. <span class="mini">Tool: algebraic expansion.</span></li>
        <li><strong>Factor out the output-only phase</strong> (it multiplies the whole field and does not affect intensity). <span class="mini">Tool: common factor.</span></li>
        <li><strong>Recognize the cross-term</strong> as a Fourier kernel with spatial frequencies <code>f_x=x'/(Œªd)</code>, <code>f_y=y'/(Œªd)</code>. <span class="mini">Tool: identify FT form.</span></li>
        <li><strong>Define a modified aperture</strong> by multiplying <code>p(x,y)</code> with the input chirp <code>exp(‚àíjœÄ(x¬≤+y¬≤)/(Œªd))</code>. <span class="mini">Tool: substitution.</span></li>
        <li><strong>Conclude equivalence</strong>: Fresnel field equals (prefactor √ó output phase) √ó Fraunhofer field of modified aperture. <span class="mini">Tool: compare integrals.</span></li>
        <li><strong>Sanity checks</strong>: unit consistency, limiting cases (large <code>d</code>), physical meaning. <span class="mini">Tool: scaling arguments.</span></li>
      </ol>

      <h3>Common mistakes & quick tips</h3>
      <ul>
        <li><strong>Sign conventions:</strong> optics texts differ by time dependence <code>e^{¬±jœât}</code> and FT sign. A sign flip in the quadratic phase may appear; intensity equivalence remains.</li>
        <li><strong>Forgetting the scaling:</strong> Fraunhofer uses spatial frequency; Fresnel maps <code>x'‚Üîf_x</code> via <code>f_x=x'/(Œªd)</code>.</li>
        <li><strong>Mixing global phase with pattern:</strong> the factor <code>exp(‚àíjœÄ(x'¬≤+y'¬≤)/(Œªd))</code> changes phase, not intensity.</li>
        <li><strong>Paraxial validity:</strong> Fresnel approximation assumes small angles; extremely wide apertures or very short distances may violate it.</li>
      </ul>
    </section>

    <section class="card" id="part3">
      <h2>PART 3 ‚Äî Full Solution</h2>

      <h3>Physical intuition first</h3>
      <p>
        Fresnel diffraction is ‚Äúnear-field‚Äù propagation: every point of the aperture contributes with a phase
        that depends on the squared distance to the observation point. If you expand that squared distance,
        you find:
      </p>
      <ul>
        <li>a term depending only on the observation point (an <em>output chirp</em>),</li>
        <li>a term depending only on the aperture coordinate (an <em>input chirp</em>),</li>
        <li>and a cross term proportional to <code>x x' + y y'</code>, which is exactly what appears in a Fourier transform kernel.</li>
      </ul>
      <p>
        So: Fresnel diffraction is basically a Fourier transform of the aperture, but after you ‚Äúpre-chirp‚Äù the aperture,
        plus an ‚Äúafter-chirp‚Äù on the output.
      </p>

      <h3>Define symbols</h3>
      <ul>
        <li><code>(x,y)</code>: coordinates in the aperture plane (input plane).</li>
        <li><code>(x',y')</code>: coordinates in the observation plane (output plane), distance <code>d</code> away.</li>
        <li><code>Œª</code>: wavelength, <code>k = 2œÄ/Œª</code>.</li>
        <li><code>p(x,y)</code>: complex aperture function.</li>
      </ul>

      <h3>1) Start from the Fresnel diffraction integral</h3>
      <p class="mini">
        Using a common scalar, paraxial Fresnel form (consistent with the problem‚Äôs sign choice), the propagated field can be written as:
      </p>
      <div class="eq" id="eqFresnel">
U_F(x',y') = C(d) ‚à¨ p(x,y) ¬∑ exp{ -j (œÄ/(Œª d)) [ (x-x')¬≤ + (y-y')¬≤ ] } dx dy
where C(d) is a distance-dependent prefactor (global amplitude/phase).
      </div>
      <div class="copyRow">
        <button class="btn" data-copy="#eqFresnel">Copy Fresnel integral</button>
        <span class="status" id="stFresnel"></span>
      </div>

      <h3>2) Expand the quadratic distance term</h3>
      <p>
        Expand:
      </p>
      <div class="eq" id="eqExpand">
(x-x')¬≤ + (y-y')¬≤
= (x¬≤+y¬≤) + (x'¬≤+y'¬≤) - 2(xx' + yy')
      </div>
      <div class="copyRow">
        <button class="btn secondary" data-copy="#eqExpand">Copy expansion</button>
        <span class="status" id="stExpand"></span>
      </div>

      <h3>3) Substitute and factor terms</h3>
      <p>
        Substitute the expansion into the Fresnel kernel:
      </p>
      <div class="eq" id="eqFactor">
exp{ -j (œÄ/(Œª d)) [ (x-x')¬≤ + (y-y')¬≤ ] }
= exp{ -j (œÄ/(Œª d)) (x¬≤+y¬≤) }
  ¬∑ exp{ -j (œÄ/(Œª d)) (x'¬≤+y'¬≤) }
  ¬∑ exp{ +j (2œÄ/(Œª d)) (x x' + y y') }
      </div>
      <p class="mini">
        Notice the separation: an input-only chirp, an output-only chirp, and a Fourier-like cross term.
      </p>
      <div class="copyRow">
        <button class="btn" data-copy="#eqFactor">Copy factored kernel</button>
        <span class="status" id="stFactor"></span>
      </div>

      <h3>4) Pull out the output-only phase</h3>
      <p>
        Put the factored kernel back into the Fresnel integral:
      </p>
      <div class="eq" id="eqAfterPull">
U_F(x',y') = C(d) ¬∑ exp{ -j (œÄ/(Œª d)) (x'¬≤+y'¬≤) }
             ‚à¨ [ p(x,y) ¬∑ exp{ -j (œÄ/(Œª d)) (x¬≤+y¬≤) } ]
                ¬∑ exp{ +j (2œÄ/(Œª d)) (x x' + y y') } dx dy
      </div>

      <h3>5) Identify the Fraunhofer (Fourier) diffraction integral</h3>
      <p>
        Define spatial frequencies:
      </p>
      <div class="eq" id="eqFreqMap">
f_x = x'/(Œª d),   f_y = y'/(Œª d)
      </div>
      <p>
        Then the cross term becomes <code>exp{+j2œÄ(x f_x + y f_y)}</code>.
        If we use the Fraunhofer/Fourier transform convention
      </p>
      <div class="eq" id="eqFTConv">
P(f_x,f_y) = ‚à¨ A(x,y) ¬∑ exp{ +j 2œÄ (x f_x + y f_y) } dx dy
      </div>
      <p class="mini">
        (Some texts use a minus sign in the exponential; that only changes a coordinate flip. The core equivalence is the same.)
      </p>

      <h3>6) Choose the modified aperture and conclude the result</h3>
      <p>
        Let the modified aperture be
      </p>
      <div class="eq" id="eqModified">
A(x,y) = p(x,y) ¬∑ exp{ -j œÄ (x¬≤+y¬≤)/(Œª d) }.
      </div>
      <p>
        Then the bracketed integral in <code>U_F</code> is exactly the Fraunhofer (Fourier) diffraction pattern of <code>A(x,y)</code>,
        evaluated at <code>(f_x,f_y)=(x'/(Œªd), y'/(Œªd))</code>.
      </p>

      <div class="boxed">
        <div><span class="pill">Final result</span> (field-level equivalence)</div>
        <div class="eq" id="eqFinal">
U_F(x',y') = C(d) ¬∑ exp{ -j œÄ (x'¬≤+y'¬≤)/(Œª d) } ¬∑ ùìï{ p(x,y) ¬∑ exp[ -j œÄ (x¬≤+y¬≤)/(Œª d) ] } evaluated at
(f_x,f_y) = ( x'/(Œª d),  y'/(Œª d) )

Therefore, the Fresnel diffraction pattern of p(x,y) equals the Fraunhofer diffraction pattern of
p(x,y)¬∑exp[ -j œÄ (x¬≤+y¬≤)/(Œª d) ], up to known prefactors and an output quadratic phase.
        </div>
        <div class="copyRow">
          <button class="btn" data-copy="#eqFinal">Copy final answer (plain text)</button>
          <span class="status" id="stFinal"></span>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <div class="grid2">
        <div class="callout">
          <strong>Units</strong>
          <p class="mini">
            The phase arguments are dimensionless:
            <code>œÄ(x¬≤)/(Œª d)</code> has units <code>m¬≤/(m¬∑m)=1</code>.
            Spatial frequency mapping <code>f_x=x'/(Œªd)</code> has units <code>m/(m¬∑m)=1/m</code>, as required.
          </p>
        </div>
        <div class="callout">
          <strong>Limiting case (large d)</strong>
          <p class="mini">
            For very large <code>d</code>, the quadratic phase across the aperture varies slowly, so
            <code>exp[-jœÄ(x¬≤+y¬≤)/(Œªd)] ‚âà 1</code>.
            Then Fresnel reduces toward the Fraunhofer (far-field) transform of <code>p(x,y)</code>.
          </p>
        </div>
      </div>
      <div class="callout" style="margin-top:12px;">
        <strong>Physical interpretation</strong>
        <p class="mini">
          The input quadratic phase is like placing a weak ‚Äúlens-like‚Äù chirp on the aperture so that near-field propagation
          can be computed using a far-field Fourier transform. The output quadratic phase is a known curvature of the propagated wavefront.
        </p>
      </div>
    </section>

    <section class="card" id="viz">
      <h2>Interactive Visualizations</h2>
      <p class="mini">
        Below we numerically compare (example values) a 1D Fresnel diffraction integral against the corresponding
        Fraunhofer transform of the quadratically phase-modified aperture. We plot intensity vs output coordinate <code>x'</code>.
        The proof above is 2D; the 1D slice here illustrates the same identity.
      </p>

      <div class="vizGrid">
        <div class="canvasWrap">
          <div class="canvasTitle">
            <strong>Diagram: aperture ‚Üí observation plane</strong>
            <span class="mini">Geometry & mapping <code>f_x = x'/(Œªd)</code></span>
          </div>
          <canvas id="cDiagram" aria-label="diffraction setup diagram"></canvas>

          <div class="controls">
            <div class="control">
              <label for="dSlider">
                <span>Propagation distance <code>d</code> (m)</span>
                <span id="dVal" class="mini"></span>
              </label>
              <input id="dSlider" type="range" min="0.10" max="2.50" step="0.01" value="0.60" />
              <div class="mini" style="margin-top:6px;">
                Changing <code>d</code> updates the quadratic phase term <code>exp[-jœÄx¬≤/(Œªd)]</code> and the frequency mapping.
              </div>
            </div>

            <div class="control">
              <label for="apSelect">
                <span>Example aperture <code>p(x)</code></span>
                <span class="mini">1D demo</span>
              </label>
              <select id="apSelect">
                <option value="rect" selected>Rectangular slit (width a)</option>
                <option value="double">Double slit (2 slits)</option>
                <option value="gauss">Gaussian aperture</option>
              </select>
              <div class="mini" style="margin-top:6px;">
                The theorem holds for any <code>p(x,y)</code>; we use representative examples for visualization.
              </div>
            </div>
          </div>
        </div>

        <div class="canvasWrap small">
          <div class="canvasTitle">
            <strong>Main plot: intensity comparison</strong>
            <span class="mini">Fresnel vs ‚ÄúFraunhofer of modified aperture‚Äù</span>
          </div>
          <canvas id="cMain" aria-label="main intensity plot"></canvas>
          <div class="mini" style="margin-top:8px;">
            The two curves should overlap (numerical errors aside). We plot normalized intensity.
          </div>
        </div>
      </div>

      <div style="height:14px"></div>

      <div class="vizGrid">
        <div class="canvasWrap small">
          <div class="canvasTitle">
            <strong>Secondary plot: absolute intensity error</strong>
            <span class="mini">|I<sub>Fresnel</sub> ‚àí I<sub>Modified-Fraunhofer</sub>|</span>
          </div>
          <canvas id="cErr" aria-label="error plot"></canvas>
          <div class="mini" style="margin-top:8px;">
            Errors mainly come from finite sampling and finite integration window.
          </div>
        </div>

        <div class="canvasWrap small">
          <div class="canvasTitle">
            <strong>Parameter sweep: max relative error vs distance</strong>
            <span class="mini">quick consistency check</span>
          </div>
          <canvas id="cSweep" aria-label="parameter sweep plot"></canvas>
          <div class="copyRow" style="margin-top:10px;">
            <button class="btn secondary" id="btnRecomputeSweep">Recompute sweep</button>
            <span class="status" id="stSweep"></span>
          </div>
        </div>
      </div>

      <div class="callout" style="margin-top:14px;">
        <strong>Example values used in plots</strong>
        <ul class="mini">
          <li>Wavelength: <code>Œª = 633 nm</code> (HeNe-like).</li>
          <li>1D coordinate window: <code>x ‚àà [‚àí2.5 mm, +2.5 mm]</code>, output window <code>x' ‚àà [‚àí3.0 mm, +3.0 mm]</code>.</li>
          <li>Rectangular slit width (if selected): <code>a = 0.60 mm</code>.</li>
        </ul>
      </div>
    </section>

  </article>
</main>

<footer>
  <div>
    Notes: The field-level equality includes a known output quadratic phase and a distance-dependent prefactor; intensity patterns are therefore the same up to scaling.
    Different optics conventions (FT sign, time dependence) may swap <code>¬±j</code> signs; the core identity is unchanged.
  </div>
</footer>

<script>
/* ---------------------------
   Smooth scroll for TOC
---------------------------- */
document.querySelectorAll('[data-scroll]').forEach(a=>{
  a.addEventListener('click', (e)=>{
    e.preventDefault();
    const id = a.getAttribute('href');
    const el = document.querySelector(id);
    if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
  });
});

/* ---------------------------
   Copy buttons
---------------------------- */
function copyTextFromSelector(sel, statusEl){
  const el = document.querySelector(sel);
  if(!el) return;
  const text = el.textContent.replace(/\n\s+\n/g,"\n\n").trim();
  navigator.clipboard.writeText(text).then(()=>{
    if(statusEl){
      statusEl.textContent = "Copied ‚úì";
      setTimeout(()=>statusEl.textContent="", 1200);
    }
  }).catch(()=>{
    if(statusEl){
      statusEl.textContent = "Copy failed (browser blocked)";
      setTimeout(()=>statusEl.textContent="", 1600);
    }
  });
}
document.querySelectorAll('[data-copy]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const sel = btn.getAttribute('data-copy');
    const stId = {
      "#eqTarget":"stGoal",
      "#eqFresnel":"stFresnel",
      "#eqExpand":"stExpand",
      "#eqFactor":"stFactor",
      "#eqFinal":"stFinal"
    }[sel];
    copyTextFromSelector(sel, document.getElementById(stId));
  });
});

/* ---------------------------
   Math helpers: complex numbers
---------------------------- */
function c(re, im){ return {re, im}; }
function cAdd(a,b){ return {re:a.re+b.re, im:a.im+b.im}; }
function cMul(a,b){ return {re:a.re*b.re - a.im*b.im, im:a.re*b.im + a.im*b.re}; }
function cAbs2(a){ return a.re*a.re + a.im*a.im; }
function cExpj(phi){ return {re: Math.cos(phi), im: Math.sin(phi)}; }

/* ---------------------------
   Canvas utilities (HiDPI + resize)
---------------------------- */
function setupCanvas(canvas){
  const ctx = canvas.getContext('2d');
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return {w: rect.width, h: rect.height, dpr};
  }
  return {ctx, resize};
}
function clear(ctx,w,h){
  ctx.clearRect(0,0,w,h);
}
function roundNice(x){
  const pow = Math.pow(10, Math.floor(Math.log10(Math.abs(x)+1e-12)));
  const n = x / pow;
  const nice = (n<1.5)?1:(n<3)?2:(n<7)?5:10;
  return nice*pow;
}

/* ---------------------------
   Plotting primitives
---------------------------- */
function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
  const {x,y,w,h} = box;
  // background
  ctx.save();
  ctx.fillStyle = 'rgba(10,14,28,0.35)';
  ctx.fillRect(x,y,w,h);
  // title
  ctx.fillStyle = 'rgba(233,236,255,0.92)';
  ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(title, x+10, y+18);

  // plot region
  const padL=54, padR=18, padT=30, padB=44;
  const px = x+padL, py=y+padT, pw=w-padL-padR, ph=h-padT-padB;

  // grid
  ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  ctx.lineWidth = 1;

  // ticks
  const xSpan = xMax-xMin;
  const ySpan = yMax-yMin;
  const xStep = roundNice(xSpan/5);
  const yStep = roundNice(ySpan/5);

  function xToPix(xv){ return px + (xv-xMin)/xSpan*pw; }
  function yToPix(yv){ return py + (1-(yv-yMin)/ySpan)*ph; }

  // vertical grid lines + x ticks
  ctx.fillStyle = 'rgba(184,192,255,0.85)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace';
  for(let xv = Math.ceil(xMin/xStep)*xStep; xv<=xMax+1e-12; xv+=xStep){
    const X = xToPix(xv);
    ctx.beginPath();
    ctx.moveTo(X, py);
    ctx.lineTo(X, py+ph);
    ctx.stroke();
    const lab = (Math.abs(xv) < 1e-12 ? "0" : xv.toFixed(3));
    ctx.fillText(lab, X-14, py+ph+18);
  }

  // horizontal grid lines + y ticks
  for(let yv = Math.ceil(yMin/yStep)*yStep; yv<=yMax+1e-12; yv+=yStep){
    const Y = yToPix(yv);
    ctx.beginPath();
    ctx.moveTo(px, Y);
    ctx.lineTo(px+pw, Y);
    ctx.stroke();
    const lab = (Math.abs(yv) < 1e-12 ? "0" : yv.toFixed(3));
    ctx.fillText(lab, x+10, Y+4);
  }

  // axes border
  ctx.strokeStyle = 'rgba(255,255,255,0.22)';
  ctx.strokeRect(px, py, pw, ph);

  // labels
  ctx.fillStyle = 'rgba(233,236,255,0.85)';
  ctx.font = '600 12.5px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(xLabel, px+pw/2 - ctx.measureText(xLabel).width/2, y+h-12);

  // y label rotated
  ctx.save();
  ctx.translate(x+14, py+ph/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
  ctx.restore();

  ctx.restore();

  return {px,py,pw,ph, xToPix, yToPix};
}

function drawLine(ctx, map, xs, ys, style){
  ctx.save();
  ctx.strokeStyle = style.stroke || 'rgba(124,246,255,0.95)';
  ctx.lineWidth = style.width || 2;
  ctx.beginPath();
  let started=false;
  for(let i=0;i<xs.length;i++){
    const X = map.xToPix(xs[i]);
    const Y = map.yToPix(ys[i]);
    if(!started){ ctx.moveTo(X,Y); started=true; }
    else ctx.lineTo(X,Y);
  }
  ctx.stroke();
  ctx.restore();
}

function drawLegend(ctx, box, entries){
  const {x,y,w} = box;
  ctx.save();
  const baseX = x + 12, baseY = y + 26;
  ctx.font = '12.5px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  let offset=0;
  entries.forEach(ent=>{
    const xx = baseX + offset;
    ctx.strokeStyle = ent.color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(xx, baseY);
    ctx.lineTo(xx+18, baseY);
    ctx.stroke();
    ctx.fillStyle = 'rgba(233,236,255,0.88)';
    ctx.fillText(ent.label, xx+24, baseY+4);
    offset += 24 + ctx.measureText(ent.label).width + 18;
  });
  ctx.restore();
}

/* ---------------------------
   Physics demo: 1D Fresnel vs Modified-Fraunhofer
---------------------------- */
const params = {
  lambda: 633e-9,
  // numerical window
  xMin: -2.5e-3,
  xMax: +2.5e-3,
  xpMin: -3.0e-3,
  xpMax: +3.0e-3,
  Nx: 520,     // aperture samples
  Nxp: 460,    // output samples
  a: 0.60e-3   // slit width (for rect)
};

function linspace(a,b,n){
  const arr = new Array(n);
  const step = (b-a)/(n-1);
  for(let i=0;i<n;i++) arr[i] = a + step*i;
  return arr;
}

function apertureValue(type, x){
  if(type==="rect"){
    return (Math.abs(x) <= params.a/2) ? 1 : 0;
  }
  if(type==="double"){
    // two slits: width a/4 separated by a/2
    const w = params.a/4;
    const sep = params.a/2;
    const s1 = (Math.abs(x - sep/2) <= w/2) ? 1 : 0;
    const s2 = (Math.abs(x + sep/2) <= w/2) ? 1 : 0;
    return (s1+s2);
  }
  if(type==="gauss"){
    const sigma = params.a/3;
    return Math.exp(-(x*x)/(2*sigma*sigma));
  }
  return 0;
}

/*
We use a Fresnel kernel consistent with the problem statement:
U_F(x') ‚àù ‚à´ p(x) exp( -jœÄ (x-x')¬≤/(Œª d) ) dx

Then:
U_F(x') ‚àù exp( -jœÄ x'¬≤/(Œª d) ) ¬∑ ‚à´ [p(x) exp(-jœÄ x¬≤/(Œª d))] ¬∑ exp(+j2œÄ x x'/(Œª d)) dx

So the integral is a Fourier-like transform (with +j sign) of the modified aperture.
We compare intensities after normalization.
*/
function computeFields(d, apType){
  const x = linspace(params.xMin, params.xMax, params.Nx);
  const xp = linspace(params.xpMin, params.xpMax, params.Nxp);
  const dx = (params.xMax-params.xMin)/(params.Nx-1);

  const k = Math.PI/(params.lambda * d);         // œÄ/(Œª d)
  const twoPiOverLamD = (2*Math.PI)/(params.lambda * d);

  // precompute p(x) and modified p(x)*exp(-jœÄ x^2/(Œª d))
  const p = new Array(params.Nx);
  const pmod = new Array(params.Nx);
  for(let i=0;i<x.length;i++){
    const pv = apertureValue(apType, x[i]);
    p[i] = pv;
    const chirp = cExpj(-k * x[i]*x[i]);         // exp(-j œÄ x^2/(Œª d))
    pmod[i] = cMul(c(pv,0), chirp);
  }

  const UF = new Array(params.Nxp);
  const Uff = new Array(params.Nxp);

  // Direct Fresnel integral (O(Nx*Nxp)) ‚Äî kept moderate sizes for smooth interaction
  for(let j=0;j<xp.length;j++){
    let sumF = c(0,0);
    let sumFF = c(0,0);
    const xpj = xp[j];

    for(let i=0;i<x.length;i++){
      const xi = x[i];

      // Fresnel kernel exp(-jœÄ (x-x')^2/(Œª d))
      const phaseF = -k * (xi - xpj)*(xi - xpj);
      const kerF = cExpj(phaseF);
      sumF = cAdd(sumF, cMul(c(p[i]*dx,0), kerF));

      // Modified Fraunhofer kernel exp(+j 2œÄ x x'/(Œª d)) acting on pmod
      const phaseFF = + twoPiOverLamD * (xi * xpj); // 2œÄ x x'/(Œª d)
      const kerFF = cExpj(phaseFF);
      sumFF = cAdd(sumFF, cMul(cMul(pmod[i], kerFF), c(dx,0)));
    }

    // include the output chirp factor for field-level match (doesn't affect intensity)
    const outChirp = cExpj(-k * xpj*xpj); // exp(-jœÄ x'^2/(Œª d))
    UF[j] = sumF;
    Uff[j] = cMul(outChirp, sumFF);
  }

  // intensities and normalization
  const IF = UF.map(z=>cAbs2(z));
  const IFF = Uff.map(z=>cAbs2(z));

  // normalize to max=1 for comparison
  const maxF = Math.max(...IF);
  const maxFF = Math.max(...IFF);
  const IFn = IF.map(v=> v/(maxF || 1));
  const IFFn = IFF.map(v=> v/(maxFF || 1));

  // error
  const err = IFn.map((v,i)=> Math.abs(v - IFFn[i]));
  const maxErr = Math.max(...err);
  const relErr = maxErr / (Math.max(1e-12, Math.max(...IFn)));

  return {x, xp, IFn, IFFn, err, maxErr, relErr};
}

/* ---------------------------
   Diagram drawing
---------------------------- */
const diagram = setupCanvas(document.getElementById('cDiagram'));
const mainPlot = setupCanvas(document.getElementById('cMain'));
const errPlot  = setupCanvas(document.getElementById('cErr'));
const sweepPlot= setupCanvas(document.getElementById('cSweep'));

function drawDiagram(d){
  const {ctx, resize} = diagram;
  const {w,h} = resize();
  clear(ctx,w,h);

  // layout
  const margin = 14;
  const leftX = margin + 10;
  const rightX = w - margin - 10;
  const midY = h/2;

  // aperture plane and screen plane
  ctx.save();
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(124,246,255,0.8)';
  ctx.fillStyle = 'rgba(124,246,255,0.10)';

  // aperture plane (vertical line)
  ctx.beginPath();
  ctx.moveTo(leftX, margin+20);
  ctx.lineTo(leftX, h-margin-20);
  ctx.stroke();
  ctx.fillRect(leftX-6, margin+20, 12, h-2*(margin+20));

  // observation plane
  ctx.strokeStyle = 'rgba(167,139,250,0.85)';
  ctx.fillStyle = 'rgba(167,139,250,0.10)';
  ctx.beginPath();
  ctx.moveTo(rightX, margin+20);
  ctx.lineTo(rightX, h-margin-20);
  ctx.stroke();
  ctx.fillRect(rightX-6, margin+20, 12, h-2*(margin+20));

  // rays
  ctx.strokeStyle = 'rgba(233,236,255,0.35)';
  ctx.lineWidth = 1.5;
  for(let k=0;k<5;k++){
    const y0 = midY + (k-2)*32;
    const y1 = midY + (k-2)*18;
    ctx.beginPath();
    ctx.moveTo(leftX, y0);
    ctx.lineTo(rightX, y1);
    ctx.stroke();
  }

  // distance arrow
  ctx.strokeStyle = 'rgba(233,236,255,0.55)';
  ctx.fillStyle = 'rgba(233,236,255,0.70)';
  ctx.lineWidth = 2;
  const yArrow = h - margin - 24;
  ctx.beginPath();
  ctx.moveTo(leftX+10, yArrow);
  ctx.lineTo(rightX-10, yArrow);
  ctx.stroke();
  // arrow heads
  function arrowHead(x,y,dir){
    ctx.beginPath();
    ctx.moveTo(x,y);
    ctx.lineTo(x+dir*10,y-6);
    ctx.lineTo(x+dir*10,y+6);
    ctx.closePath();
    ctx.fill();
  }
  arrowHead(leftX+10, yArrow, +1);
  arrowHead(rightX-10, yArrow, -1);

  // labels
  ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillStyle = 'rgba(233,236,255,0.92)';
  ctx.fillText("Aperture plane (p(x,y))", leftX-2, margin+16);
  ctx.fillText("Observation plane (U(x',y'))", rightX-165, margin+16);

  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace';
  ctx.fillStyle = 'rgba(184,192,255,0.9)';
  const dTxt = `d = ${d.toFixed(2)} m`;
  ctx.fillText(dTxt, w/2 - ctx.measureText(dTxt).width/2, yArrow-10);

  // mapping box
  const boxW = Math.min(320, w-2*margin);
  const boxH = 78;
  const bx = w/2 - boxW/2;
  const by = margin+34;
  ctx.fillStyle = 'rgba(0,0,0,0.28)';
  ctx.strokeStyle = 'rgba(255,255,255,0.14)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(bx, by, boxW, boxH, 14);
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = 'rgba(233,236,255,0.90)';
  ctx.font = '600 12.5px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText("Fresnel ‚Üî Fraunhofer mapping", bx+12, by+22);
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace';
  ctx.fillStyle = 'rgba(124,246,255,0.95)';
  ctx.fillText("f_x = x'/(Œª d),   f_y = y'/(Œª d)", bx+12, by+44);
  ctx.fillStyle = 'rgba(167,139,250,0.95)';
  ctx.fillText("Modify aperture: p(x,y)¬∑exp(‚àíjœÄ(x¬≤+y¬≤)/(Œª d))", bx+12, by+64);

  ctx.restore();
}

/* ---------------------------
   Plot rendering
---------------------------- */
function renderMainPlot(data, d, apType){
  const {ctx, resize} = mainPlot;
  const {w,h} = resize();
  clear(ctx,w,h);

  // x-axis in mm for display
  const xs = data.xp.map(v=> v*1e3);
  const ys1 = data.IFn;
  const ys2 = data.IFFn;

  const xMin = Math.min(...xs), xMax = Math.max(...xs);
  const yMin = 0, yMax = 1.05;

  const map = drawAxes(
    ctx,
    {x:0,y:0,w,h},
    xMin, xMax, yMin, yMax,
    "x' (mm)",
    "Normalized intensity (a.u.)",
    `Intensity at distance d = ${d.toFixed(2)} m  ‚Ä¢  aperture: ${apType}`
  );

  drawLegend(ctx, {x:0,y:0,w,h}, [
    {label:"Fresnel (direct)", color:"rgba(124,246,255,0.95)"},
    {label:"Modified-Fraunhofer", color:"rgba(167,139,250,0.95)"}
  ]);

  drawLine(ctx, map, xs, ys1, {stroke:"rgba(124,246,255,0.95)", width:2.2});
  drawLine(ctx, map, xs, ys2, {stroke:"rgba(167,139,250,0.95)", width:2.0});

  // small annotation
  ctx.save();
  ctx.fillStyle = 'rgba(184,192,255,0.85)';
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  const msg = "Overlay should match (same pattern).";
  ctx.fillText(msg, map.px+10, map.py+map.ph-10);
  ctx.restore();
}

function renderErrPlot(data){
  const {ctx, resize} = errPlot;
  const {w,h} = resize();
  clear(ctx,w,h);

  const xs = data.xp.map(v=> v*1e3);
  const ys = data.err;

  const xMin = Math.min(...xs), xMax = Math.max(...xs);
  const yMin = 0, yMax = Math.max(1e-5, Math.max(...ys)*1.15);

  const map = drawAxes(
    ctx,
    {x:0,y:0,w,h},
    xMin, xMax, yMin, yMax,
    "x' (mm)",
    "Absolute error (a.u.)",
    "Absolute difference in normalized intensity"
  );
  drawLine(ctx, map, xs, ys, {stroke:"rgba(255,211,106,0.95)", width:2.2});

  // show max error
  ctx.save();
  ctx.fillStyle = 'rgba(233,236,255,0.88)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace';
  const t = `max |ŒîI| = ${data.maxErr.toExponential(2)}`;
  ctx.fillText(t, map.px+10, map.py+16);
  ctx.restore();
}

function renderSweepPlot(points, apType){
  const {ctx, resize} = sweepPlot;
  const {w,h} = resize();
  clear(ctx,w,h);

  const xs = points.map(p=> p.d);
  const ys = points.map(p=> p.maxRel);

  const xMin = Math.min(...xs), xMax = Math.max(...xs);
  const yMin = 0;
  const yMax = Math.max(1e-4, Math.max(...ys)*1.2);

  const map = drawAxes(
    ctx,
    {x:0,y:0,w,h},
    xMin, xMax, yMin, yMax,
    "d (m)",
    "Max relative error (a.u.)",
    `Sweep check (aperture: ${apType})`
  );

  drawLine(ctx, map, xs, ys, {stroke:"rgba(117,240,163,0.95)", width:2.2});

  // markers
  ctx.save();
  ctx.fillStyle = 'rgba(117,240,163,0.95)';
  for(let i=0;i<xs.length;i++){
    const X = map.xToPix(xs[i]);
    const Y = map.yToPix(ys[i]);
    ctx.beginPath();
    ctx.arc(X,Y,2.6,0,Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

/* ---------------------------
   UI wiring
---------------------------- */
const dSlider = document.getElementById('dSlider');
const dVal = document.getElementById('dVal');
const apSelect = document.getElementById('apSelect');
const btnRecomputeSweep = document.getElementById('btnRecomputeSweep');
const stSweep = document.getElementById('stSweep');

let lastSweep = null;

function updateAll(){
  const d = parseFloat(dSlider.value);
  const apType = apSelect.value;
  dVal.textContent = d.toFixed(2);

  drawDiagram(d);

  const data = computeFields(d, apType);
  renderMainPlot(data, d, apType);
  renderErrPlot(data);

  // if sweep exists, redraw with current aperture label (sweep depends on aperture type, so invalidate)
  lastSweep = null;
  renderSweepPlot(buildQuickSweepPlaceholder(d), apType);
}

function buildQuickSweepPlaceholder(d){
  // lightweight placeholder line around current d (visual continuity)
  const ds = [0.10, 0.60, 1.10, 1.60, 2.10, 2.50];
  return ds.map(dd=>({d:dd, maxRel: 0.0}));
}

function recomputeSweep(){
  const apType = apSelect.value;
  stSweep.textContent = "Computing‚Ä¶";
  // compute with modest number of points to keep it fast
  const ds = [];
  const dMin = 0.10, dMax = 2.50, n=12;
  for(let i=0;i<n;i++){
    ds.push(dMin + (dMax-dMin)*i/(n-1));
  }
  // run incrementally to keep UI responsive
  const points = [];
  let idx=0;

  function step(){
    const d = ds[idx];
    const data = computeFields(d, apType);
    // max relative error (normalize by max intensity ~ 1)
    const maxRel = data.maxErr; // since normalized intensity max ~1
    points.push({d: parseFloat(d.toFixed(3)), maxRel});
    idx++;
    renderSweepPlot(points, apType);
    if(idx < ds.length){
      requestAnimationFrame(step);
    }else{
      lastSweep = points;
      stSweep.textContent = "Done ‚úì";
      setTimeout(()=>stSweep.textContent="", 1200);
    }
  }
  requestAnimationFrame(step);
}

dSlider.addEventListener('input', updateAll);
apSelect.addEventListener('change', updateAll);
btnRecomputeSweep.addEventListener('click', recomputeSweep);

// initial render
updateAll();
recomputeSweep();

// keep responsive
window.addEventListener('resize', ()=>{
  // redraw using current state
  const d = parseFloat(dSlider.value);
  const apType = apSelect.value;
  drawDiagram(d);
  const data = computeFields(d, apType);
  renderMainPlot(data, d, apType);
  renderErrPlot(data);
  if(lastSweep) renderSweepPlot(lastSweep, apType);
  else renderSweepPlot(buildQuickSweepPlaceholder(d), apType);
});

/* ---------------------------
   Canvas roundRect polyfill for older browsers
---------------------------- */
if(!CanvasRenderingContext2D.prototype.roundRect){
  CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    this.beginPath();
    this.moveTo(x+rr, y);
    this.arcTo(x+w, y, x+w, y+h, rr);
    this.arcTo(x+w, y+h, x, y+h, rr);
    this.arcTo(x, y+h, x, y, rr);
    this.arcTo(x, y, x+w, y, rr);
    this.closePath();
    return this;
  };
}
</script>
</body>
</html>
