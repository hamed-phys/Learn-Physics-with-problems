<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="color-scheme" content="dark light"/>
  <title>Transmission Through Planar Plates (Snell’s Law, Lateral Shift, and Multi-Layer Stacks)</title>
  <style>
    :root{
      --bg: #07090d;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.085);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --faint: rgba(255,255,255,0.45);
      --line: rgba(255,255,255,0.14);
      --accent: #6ee7ff;
      --accent2:#a78bfa;
      --good:#86efac;
      --warn:#fbbf24;
      --bad:#fb7185;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --radius: 18px;
      --shadow: 0 18px 55px rgba(0,0,0,0.35);
    }

    @media (prefers-color-scheme: light){
      :root{
        --bg:#f6f7fb;
        --panel: rgba(0,0,0,0.05);
        --panel2: rgba(0,0,0,0.075);
        --text: rgba(0,0,0,0.88);
        --muted: rgba(0,0,0,0.68);
        --faint: rgba(0,0,0,0.45);
        --line: rgba(0,0,0,0.12);
        --shadow: 0 18px 45px rgba(0,0,0,0.12);
      }
    }

    *{ box-sizing:border-box; }
    html, body { height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background: radial-gradient(1200px 700px at 15% 0%, rgba(110,231,255,0.10), transparent 55%),
                  radial-gradient(900px 650px at 85% 10%, rgba(167,139,250,0.12), transparent 60%),
                  linear-gradient(180deg, var(--bg), var(--bg));
      line-height:1.55;
    }

    header{
      padding: 28px 18px 10px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .hero{
      display:grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 14px;
      align-items: stretch;
    }
    @media (max-width: 900px){
      .hero{ grid-template-columns: 1fr; }
    }

    .card{
      background: linear-gradient(180deg, var(--panel2), var(--panel));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }

    .card::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(650px 240px at 20% 0%, rgba(110,231,255,0.10), transparent 60%),
                  radial-gradient(650px 240px at 80% 0%, rgba(167,139,250,0.11), transparent 60%);
      pointer-events:none;
      opacity:0.7;
    }

    .card > *{ position:relative; }

    .titleWrap{
      padding: 18px 18px 14px;
    }

    h1{
      margin: 0 0 8px;
      font-size: clamp(1.35rem, 2.5vw, 2.05rem);
      letter-spacing: 0.2px;
    }
    .subtitle{
      margin:0;
      color: var(--muted);
      font-size: 0.98rem;
    }

    .pillRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:12px;
    }
    .pill{
      font-size: 0.82rem;
      color: var(--muted);
      border:1px solid var(--line);
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.03);
    }

    main{
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px 18px 44px;
      display:grid;
      grid-template-columns: 280px 1fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
    }

    nav.toc{
      position: sticky;
      top: 12px;
      align-self:start;
      padding: 14px;
    }
    @media (max-width: 980px){
      nav.toc{ position:relative; top:auto; }
    }

    .toc h2{
      margin: 0 0 10px;
      font-size: 1.02rem;
      letter-spacing: 0.2px;
    }
    .toc a{
      display:block;
      padding: 8px 10px;
      margin: 4px 0;
      border-radius: 12px;
      color: var(--muted);
      text-decoration:none;
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .toc a:hover{
      background: rgba(255,255,255,0.05);
      border-color: var(--line);
      transform: translateY(-1px);
      color: var(--text);
    }

    section.article{
      padding: 16px;
    }

    h2{
      margin: 8px 0 10px;
      font-size: 1.22rem;
    }
    h3{
      margin: 16px 0 8px;
      font-size: 1.05rem;
      color: var(--text);
    }
    p{ margin: 8px 0; color: var(--text); }
    ul{ margin: 8px 0 8px 18px; color: var(--text); }
    li{ margin: 5px 0; color: var(--text); }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 840px){
      .grid2{ grid-template-columns: 1fr; }
    }

    .callout{
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding: 12px 12px;
      background: rgba(255,255,255,0.03);
    }
    .callout strong{ color: var(--accent); }
    .callout.good strong{ color: var(--good); }
    .callout.warn strong{ color: var(--warn); }
    .callout.bad strong{ color: var(--bad); }

    .eqBox{
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 10px 10px;
      background: rgba(0,0,0,0.12);
      overflow:auto;
    }
    @media (prefers-color-scheme: light){
      .eqBox{ background: rgba(255,255,255,0.65); }
    }

    pre, code{
      font-family: var(--mono);
      font-size: 0.94rem;
      white-space: pre-wrap;
      word-break: break-word;
      margin:0;
      color: var(--text);
    }

    .rowBetween{
      display:flex;
      gap:10px;
      justify-content:space-between;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom: 8px;
    }

    .btn{
      appearance:none;
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      padding: 7px 10px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size: 0.86rem;
    }
    .btn:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,0.07);
      border-color: rgba(255,255,255,0.22);
    }

    .mini{
      color: var(--muted);
      font-size: 0.92rem;
    }

    figure{
      margin: 0;
      padding: 12px;
    }
    .canvasWrap{
      border:1px solid var(--line);
      border-radius: var(--radius);
      overflow:hidden;
      background: rgba(0,0,0,0.12);
    }
    @media (prefers-color-scheme: light){
      .canvasWrap{ background: rgba(255,255,255,0.7); }
    }

    canvas{ display:block; width:100%; height: 330px; }
    .canvasTall canvas{ height: 360px; }

    .controls{
      padding: 12px 12px 14px;
      border-top: 1px solid var(--line);
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 700px){
      .controls{ grid-template-columns: 1fr; }
    }

    .ctrl{
      border:1px solid var(--line);
      border-radius: 14px;
      padding: 10px 10px;
      background: rgba(255,255,255,0.03);
    }
    .ctrl label{
      display:flex;
      justify-content:space-between;
      gap: 10px;
      align-items:baseline;
      font-size: 0.90rem;
      color: var(--text);
      margin-bottom: 8px;
    }
    .ctrl .val{
      font-family: var(--mono);
      color: var(--accent);
      font-size: 0.90rem;
    }
    input[type="range"]{ width:100%; }

    .badge{
      display:inline-block;
      font-family: var(--mono);
      padding: 2px 8px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
      font-size: 0.85rem;
    }

    .final{
      border: 1px solid rgba(110,231,255,0.35);
      background: linear-gradient(180deg, rgba(110,231,255,0.11), rgba(255,255,255,0.03));
      border-radius: var(--radius);
      padding: 12px;
    }
    .final h3{ margin-top: 4px; }
    .boxTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }

    .hr{
      height:1px;
      background: var(--line);
      margin: 14px 0;
    }

    footer{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 18px 34px;
      color: var(--muted);
      font-size: 0.92rem;
    }

    /* Subtle motion, respectful of reduced motion */
    @media (prefers-reduced-motion: no-preference){
      .fadeIn{
        animation: fadeInUp .55s ease both;
      }
      @keyframes fadeInUp{
        from{ opacity:0; transform: translateY(6px); }
        to{ opacity:1; transform: translateY(0); }
      }
    }

    /* Print-friendly */
    @media print{
      body{ background:#fff !important; color:#000 !important; }
      .card, .callout, .eqBox, .canvasWrap, .ctrl, .final{ box-shadow:none !important; }
      nav.toc{ display:none; }
      .btn{ display:none; }
      canvas{ height: 240px !important; }
    }
  </style>
</head>

<body>
<header class="fadeIn">
  <div class="hero">
    <div class="card">
      <div class="titleWrap">
        <h1>Transmission through Planar Plates</h1>
        <p class="subtitle">
          Show the transmitted ray emerges parallel (nonparaxial), derive the lateral displacement vs. incidence angle,
          and extend to a stack of parallel layers.
        </p>
        <div class="pillRow">
          <span class="pill">Snell’s law</span>
          <span class="pill">Nonparaxial geometry</span>
          <span class="pill">Fermat’s principle (stationary optical path)</span>
          <span class="pill">Layer stacks: invariant <span class="badge">n&nbsp;sin&nbsp;θ</span></span>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="titleWrap">
        <h2 style="margin:0 0 8px;">Quick Summary</h2>
        <ul style="margin:0 0 0 18px;">
          <li>For a planar plate (parallel faces), the exit angle equals the incident angle: the emergent ray is parallel.</li>
          <li>Inside the plate: <span class="badge">sin&nbsp;θ = n₁&nbsp;sin&nbsp;θ₁</span> (air index ≈ 1).</li>
          <li>Lateral shift (standard definition): <span class="badge">Δ = d·sin(θ−θ₁)/cosθ₁</span>.</li>
          <li>As θ→0, Δ→0; as n₁→1, Δ→0; increasing d increases Δ linearly.</li>
          <li>For N parallel layers: <span class="badge">nₘ sinθₘ = sinθ</span> for each layer m, so the final ray is parallel.</li>
        </ul>
      </div>
    </div>
  </div>
</header>

<main>
  <nav class="toc card fadeIn" aria-label="Table of contents">
    <h2>Table of Contents</h2>
    <a href="#viz" data-jump>Interactive Visuals</a>
    <a href="#part1" data-jump>PART 1 — Problem Analysis</a>
    <a href="#part2" data-jump>PART 2 — Strategy &amp; Tips</a>
    <a href="#part3" data-jump>PART 3 — Full Solution</a>
    <a href="#checks" data-jump>Sanity Checks</a>
  </nav>

  <section class="article card fadeIn">
    <article>
      <section id="viz">
        <h2>Interactive Visuals (Same symbols as the derivation)</h2>
        <p class="mini">
          Controls below change the geometry live. We assume air index <span class="badge">n₀ ≈ 1</span>, plate index <span class="badge">n₁</span>,
          thickness <span class="badge">d</span>, incidence angle <span class="badge">θ</span>, and refracted angle in the plate <span class="badge">θ₁</span>.
        </p>

        <div class="grid2">
          <figure class="canvasWrap">
            <div class="rowBetween" style="padding:12px 12px 0;">
              <div>
                <strong>Diagram:</strong> Ray through a planar plate
                <span class="badge" id="diagBadge"></span>
              </div>
              <button class="btn" id="btnReset">Reset demo values</button>
            </div>
            <canvas id="cDiagram" aria-label="Ray diagram canvas"></canvas>
            <figcaption class="mini" style="padding:0 12px 12px;">
              Two refractions at parallel faces cancel the angular deviation, but a lateral shift <span class="badge">Δ</span> remains.
            </figcaption>
          </figure>

          <figure class="canvasWrap canvasTall">
            <div class="rowBetween" style="padding:12px 12px 0;">
              <div><strong>Main plot:</strong> Lateral displacement Δ vs. incidence angle θ</div>
              <span class="mini">Example values unless you change them</span>
            </div>
            <canvas id="cMain" aria-label="Main plot canvas"></canvas>
            <figcaption class="mini" style="padding:0 12px 12px;">
              Curve: <span class="badge">Δ(θ) = d·sin(θ−θ₁)/cosθ₁</span> with <span class="badge">sinθ = n₁ sinθ₁</span>.
              Highlight shows current θ.
            </figcaption>
          </figure>
        </div>

        <div class="grid2" style="margin-top:12px;">
          <figure class="canvasWrap">
            <div class="rowBetween" style="padding:12px 12px 0;">
              <div><strong>Secondary plot:</strong> Δ vs. refractive index n₁ (at fixed θ)</div>
              <span class="mini">Shows material dependence</span>
            </div>
            <canvas id="cSecondary" aria-label="Secondary plot canvas"></canvas>
            <figcaption class="mini" style="padding:0 12px 12px;">
              For fixed θ, higher n₁ bends more (smaller θ₁), changing the shift Δ.
            </figcaption>
          </figure>

          <div class="callout" style="padding:12px;">
            <h3 style="margin-top:0;">Interactive Controls</h3>
            <div class="controls" style="border:0; padding:0;">
              <div class="ctrl">
                <label for="sTheta">Incidence angle θ (deg) <span class="val" id="vTheta"></span></label>
                <input id="sTheta" type="range" min="0" max="80" step="0.1" value="45">
                <div class="mini">Angle in air measured from the normal.</div>
              </div>
              <div class="ctrl">
                <label for="sN1">Plate index n₁ <span class="val" id="vN1"></span></label>
                <input id="sN1" type="range" min="1.00" max="2.50" step="0.01" value="1.50">
                <div class="mini">n₀ is held at 1 (air).</div>
              </div>
              <div class="ctrl">
                <label for="sD">Thickness d (mm) <span class="val" id="vD"></span></label>
                <input id="sD" type="range" min="0.5" max="12" step="0.1" value="5">
                <div class="mini">Δ scales linearly with d.</div>
              </div>
              <div class="ctrl">
                <label>Computed θ₁ (deg) <span class="val" id="vTheta1"></span></label>
                <div class="eqBox">
                  <pre id="readout"></pre>
                </div>
                <div class="mini">From Snell: sinθ = n₁ sinθ₁.</div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <div class="hr"></div>

      <section id="part1">
        <h2>PART 1 — Problem Analysis (no solving yet)</h2>

        <h3>Restate the problem (in my own words)</h3>
        <p>
          A light ray in air (index approximately 1) hits a flat plate of thickness <span class="badge">d</span> and refractive index
          <span class="badge">n₁</span>. You must:
        </p>
        <ul>
          <li><strong>(a)</strong> Use Snell’s law to prove the exiting ray is <em>parallel</em> to the incident ray (no paraxial approximation),
              and derive the <em>lateral displacement</em> Δ as a function of incidence angle θ.</li>
          <li><strong>(b)</strong> Replace the plate by <em>N</em> parallel layers with thicknesses <span class="badge">d₁,…,d_N</span> and indices
              <span class="badge">n₁,…,n_N</span>. Show the transmitted ray is still parallel, and prove that in layer m:
              <span class="badge">nₘ sinθₘ = sinθ</span>.</li>
        </ul>

        <div class="grid2">
          <div class="callout">
            <h3 style="margin-top:0;">Given quantities</h3>
            <ul>
              <li>Air refractive index: <span class="badge">n₀ ≈ 1</span></li>
              <li>Plate thickness: <span class="badge">d</span></li>
              <li>Plate refractive index: <span class="badge">n₁</span></li>
              <li>Incidence angle in air: <span class="badge">θ</span> (from normal)</li>
              <li>(b) Layer stack: <span class="badge">d₁,…,d_N</span> and <span class="badge">n₁,…,n_N</span></li>
            </ul>
          </div>

          <div class="callout good">
            <h3 style="margin-top:0;">Unknowns / what to find</h3>
            <ul>
              <li>Angle inside plate: <span class="badge">θ₁</span> (and <span class="badge">θₘ</span> in each layer)</li>
              <li>Proof: emergent ray direction is parallel to incident ray</li>
              <li>Lateral displacement: <span class="badge">Δ(θ)</span></li>
              <li>Stack invariant: <span class="badge">nₘ sinθₘ = sinθ</span></li>
            </ul>
          </div>
        </div>

        <h3>Relevant physical principles (and why they apply)</h3>
        <ul>
          <li><strong>Snell’s law:</strong> At each planar interface, the tangential component of the wavevector is conserved, giving
            <span class="badge">n_a sinθ_a = n_b sinθ_b</span>. This governs refraction at both faces (and at every layer boundary).</li>
          <li><strong>Geometric optics:</strong> Plate thickness is macroscopic compared to wavelength, so rays and angles describe propagation.</li>
          <li><strong>Fermat’s principle:</strong> The optical path between two wavefronts is stationary; for parallel faces this symmetry forces the
            outgoing direction to match the incoming direction (parallel), even if the ray is not paraxial.</li>
        </ul>

        <h3>Possible approaches (compare and choose)</h3>
        <ul>
          <li><strong>Approach 1: Two-step Snell + geometry</strong> — Apply Snell at entry and exit; use parallel-face geometry to compute Δ.
              <em>Best for explicit Δ(θ)</em>.</li>
          <li><strong>Approach 2: Wavevector/tangential component invariance</strong> — Show <span class="badge">n sinθ</span> is invariant across layers,
              immediately proving parallel output. <em>Best for part (b)</em>.</li>
          <li><strong>Approach 3: Fermat’s principle symmetry argument</strong> — Elegant physical explanation of “parallel out”, complements math.</li>
        </ul>
        <p>
          We’ll use <strong>Approach 1</strong> for (a) because it naturally produces the lateral shift formula, and
          <strong>Approach 2</strong> for (b) because it gives the layer invariant in one clean line.
        </p>
      </section>

      <div class="hr"></div>

      <section id="part2">
        <h2>PART 2 — Strategy &amp; Tips (roadmap only)</h2>

        <h3>Step-by-step plan (no algebra yet)</h3>
        <ol style="margin:8px 0 8px 18px;">
          <li><strong>Set geometry:</strong> define θ in air, θ₁ inside plate, thickness d (measured normal to faces).</li>
          <li><strong>Entry refraction:</strong> apply Snell at air→plate to relate θ and θ₁.</li>
          <li><strong>Exit refraction:</strong> apply Snell at plate→air to relate θ₁ to the exit angle; use “same outer medium” to show the exit angle equals θ.</li>
          <li><strong>Parallel-ray conclusion:</strong> conclude emergent ray is parallel to incident ray (no small-angle assumption used).</li>
          <li><strong>Lateral shift Δ:</strong> use right-triangle geometry inside the plate to express Δ in terms of θ and θ₁.</li>
          <li><strong>Fermat explanation:</strong> interpret why direction is unchanged: stationary optical path between parallel wavefronts.</li>
          <li><strong>Layer stack:</strong> apply Snell across each interface to show <span class="badge">nₘ sinθₘ</span> is constant, hence parallel output.</li>
        </ol>

        <div class="grid2">
          <div class="callout warn">
            <h3 style="margin-top:0;">Common mistakes</h3>
            <ul>
              <li>Mixing angles measured from the normal vs from the surface.</li>
              <li>Forgetting that the exit medium is the same as entry medium (air), which is crucial for “parallel out”.</li>
              <li>Using paraxial approximations (sinθ≈θ) even though the problem explicitly allows nonparaxial rays.</li>
              <li>Using a nonstandard definition of “lateral displacement”. Here we use the standard: distance between the emergent ray and the straight continuation of the incident ray at the exit face.</li>
            </ul>
          </div>
          <div class="callout">
            <h3 style="margin-top:0;">Quick tips</h3>
            <ul>
              <li>Keep one consistent symbol set: θ (air), θ₁ (plate), d (thickness), n₁ (index).</li>
              <li>Compute θ₁ from Snell before substituting into Δ(θ).</li>
              <li>Check limits: θ→0 gives Δ→0; n₁→1 gives Δ→0; Δ scales with d.</li>
              <li>For many layers, focus on the invariant tangential component: <span class="badge">n sinθ = constant</span>.</li>
            </ul>
          </div>
        </div>
      </section>

      <div class="hr"></div>

      <section id="part3">
        <h2>PART 3 — Full Solution</h2>

        <h3>Physical intuition</h3>
        <p>
          A parallel-sided plate bends the ray <em>toward</em> the normal at the first face (if n₁&gt;1), then bends it
          <em>away</em> from the normal by the same amount at the second face because the faces are parallel and the outside
          medium is again air. So the direction change cancels, leaving the outgoing ray <em>parallel</em> to the incoming ray.
          The only “memory” of the plate is a sideways (lateral) shift Δ.
        </p>

        <h3>(a) Parallel emergence using Snell’s law (nonparaxial)</h3>
        <p>
          Let the incident angle in air be <span class="badge">θ</span> (measured from the normal). Inside the plate the angle is
          <span class="badge">θ₁</span>. Take air index <span class="badge">n₀ = 1</span>.
        </p>

        <div class="eqBox">
          <div class="rowBetween">
            <div class="mini"><strong>Key equation (entry interface):</strong></div>
            <button class="btn" data-copy="#eqSnellEntry">Copy</button>
          </div>
          <pre id="eqSnellEntry">Snell (air → plate):  n₀ sinθ = n₁ sinθ₁  with n₀ = 1  ⇒  sinθ = n₁ sinθ₁.</pre>
        </div>

        <p>
          At the second face (plate → air), the incident angle inside the plate is again <span class="badge">θ₁</span> because the faces are parallel
          (the internal ray meets the exit face at the same angle to its normal).
          Let the exit angle in air be <span class="badge">θ_out</span>.
        </p>

        <div class="eqBox">
          <div class="rowBetween">
            <div class="mini"><strong>Key equation (exit interface):</strong></div>
            <button class="btn" data-copy="#eqSnellExit">Copy</button>
          </div>
          <pre id="eqSnellExit">Snell (plate → air):  n₁ sinθ₁ = n₀ sinθ_out  with n₀ = 1  ⇒  n₁ sinθ₁ = sinθ_out.</pre>
        </div>

        <p>
          Combine entry and exit Snell relations:
        </p>
        <div class="eqBox">
          <pre>
From entry:  n₁ sinθ₁ = sinθ.
From exit:   sinθ_out = n₁ sinθ₁.
Therefore:   sinθ_out = sinθ  ⇒  θ_out = θ  (for 0 ≤ θ ≤ 90°).
          </pre>
        </div>

        <div class="callout good">
          <strong>Conclusion:</strong> The transmitted (emergent) ray leaves the plate at the same angle as it entered. Hence it is
          <em>parallel</em> to the incident ray. No paraxial approximation was used.
        </div>

        <h3>(a) Lateral displacement Δ(θ)</h3>
        <p>
          Define the plate thickness <span class="badge">d</span> as the distance between the two faces measured along the normal.
          The ray travels inside the plate at angle <span class="badge">θ₁</span>, so the internal path length between faces is
          <span class="badge">ℓ = d / cosθ₁</span>.
        </p>

        <p>
          The standard lateral shift Δ is the perpendicular distance between the emergent ray and the straight-line continuation
          of the incident ray (since the two rays are parallel). From the geometry of the “thin prism-like” triangle formed by
          the internal segment and the two parallel rays, one obtains:
        </p>

        <div class="eqBox">
          <div class="rowBetween">
            <div class="mini"><strong>Lateral shift (standard result):</strong></div>
            <button class="btn" data-copy="#eqDelta">Copy</button>
          </div>
          <pre id="eqDelta">Δ(θ) = d · sin(θ − θ₁) / cosθ₁,   with  sinθ = n₁ sinθ₁  (air index ≈ 1).</pre>
        </div>

        <p>
          To make the dependence purely on θ and n₁, solve Snell for θ₁:
          <span class="badge">θ₁ = arcsin( sinθ / n₁ )</span> (provided sinθ ≤ n₁, which is always true here because n₁ ≥ 1).
          Then substitute into Δ(θ).
        </p>

        <div class="final" id="finalAnswer">
          <div class="boxTitle">
            <h3 style="margin:0;">Final Results (Part a)</h3>
            <button class="btn" data-copy="#finalText">Copy final (plain text)</button>
          </div>
          <div class="eqBox" style="margin-top:10px;">
            <pre id="finalText">Parallel emergence:  θ_out = θ  (incident and emergent rays are parallel).

Refraction inside plate:  sinθ = n₁ sinθ₁  ⇒  θ₁ = arcsin( sinθ / n₁ ).

Lateral displacement (standard):  Δ(θ) = d · sin(θ − θ₁) / cosθ₁.</pre>
          </div>
        </div>

        <h3>Fermat’s principle explanation (why “parallel out” must happen)</h3>
        <p>
          Consider two plane wavefronts in air: one before the plate and one after it. The plate has parallel faces, so the system
          is translationally invariant along the faces. Fermat’s principle says the actual ray connecting those wavefronts makes the
          optical path length stationary against small variations. If the outgoing direction differed from the incoming direction, you could
          slide the ray laterally and change the exit point to reduce optical path without changing boundary conditions—contradicting stationarity.
          The only consistent stationary solution is that the output direction matches the input direction (parallel rays), while the exit point shifts
          laterally (Δ).
        </p>

        <h3>(b) Stack of N parallel layers: transmitted ray remains parallel</h3>
        <p>
          Now the plate is replaced by N layers, each planar and all faces mutually parallel. Let the angle in layer m be
          <span class="badge">θₘ</span>, and its index be <span class="badge">nₘ</span>. The incident angle in air is still <span class="badge">θ</span>.
        </p>

        <p>
          Apply Snell’s law at the first interface (air → layer 1):
          <span class="badge">sinθ = n₁ sinθ₁</span>.
          At the next interface (layer 1 → layer 2):
          <span class="badge">n₁ sinθ₁ = n₂ sinθ₂</span>.
          Continue through the stack; each interface enforces equality of <span class="badge">n sinθ</span>.
        </p>

        <div class="eqBox">
          <div class="rowBetween">
            <div class="mini"><strong>Invariant through the stack:</strong></div>
            <button class="btn" data-copy="#eqInvariant">Copy</button>
          </div>
          <pre id="eqInvariant">n₀ sinθ = n₁ sinθ₁ = n₂ sinθ₂ = ... = nₘ sinθₘ = ... = n_N sinθ_N.

With n₀ = 1 (air):  nₘ sinθₘ = sinθ  for m = 1,2,...,N.</pre>
        </div>

        <p>
          At the final interface (layer N → air), Snell gives:
          <span class="badge">n_N sinθ_N = sinθ_out</span>.
          But from the invariant, <span class="badge">n_N sinθ_N = sinθ</span>, so
          <span class="badge">sinθ_out = sinθ</span> and therefore <span class="badge">θ_out = θ</span>.
        </p>

        <div class="callout good">
          <strong>Conclusion (Part b):</strong> For any stack of parallel layers, the transmitted ray is parallel to the incident ray, and
          <span class="badge">nₘ sinθₘ = sinθ</span> holds in every layer m.
        </div>

      </section>

      <div class="hr"></div>

      <section id="checks">
        <h2>Sanity Checks</h2>

        <div class="grid2">
          <div class="callout">
            <h3 style="margin-top:0;">Units</h3>
            <ul>
              <li>Δ has units of length because it is <span class="badge">d × (dimensionless trig ratio)</span>.</li>
              <li>Angles appear only inside trig functions (dimensionless), consistent.</li>
            </ul>
          </div>
          <div class="callout">
            <h3 style="margin-top:0;">Limiting cases</h3>
            <ul>
              <li><strong>θ → 0:</strong> θ₁ → 0, so <span class="badge">Δ → 0</span> (normal incidence gives no sideways shift).</li>
              <li><strong>n₁ → 1:</strong> θ₁ → θ, so <span class="badge">Δ → 0</span> (no refractive contrast).</li>
              <li><strong>d scales:</strong> Doubling d doubles Δ (linear dependence).</li>
            </ul>
          </div>
        </div>

        <div class="callout good" style="margin-top:12px;">
          <strong>Physical interpretation:</strong> The plate changes where the ray emerges (Δ), but not the direction (parallel out).
          In multi-layer stacks, the tangential component condition makes <span class="badge">n sinθ</span> the conserved “signature” of the incident ray,
          so the final direction must match the incident direction when the outer medium is the same on both sides.
        </div>
      </section>
    </article>
  </section>
</main>

<footer>
  <div class="hr"></div>
  <p>
    Built as a self-contained HTML article with interactive canvases (no external libraries). Angles are measured from the surface normal.
  </p>
</footer>

<script>
/* =========================
   Smooth TOC scrolling
   ========================= */
document.querySelectorAll('[data-jump]').forEach(a=>{
  a.addEventListener('click', (e)=>{
    e.preventDefault();
    const id = a.getAttribute('href');
    const el = document.querySelector(id);
    if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
  });
});

/* =========================
   Copy buttons
   ========================= */
function copyFromSelector(sel){
  const el = document.querySelector(sel);
  if(!el) return;
  const text = el.innerText.replace(/\u00A0/g,' ');
  navigator.clipboard.writeText(text).catch(()=>{});
}
document.querySelectorAll('[data-copy]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    copyFromSelector(btn.getAttribute('data-copy'));
    btn.textContent = 'Copied ✓';
    setTimeout(()=>btn.textContent='Copy', 900);
  });
});

/* =========================
   Math helpers (degrees)
   ========================= */
const DEG = Math.PI/180;
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function rad2deg(r){ return r/DEG; }
function deg2rad(d){ return d*DEG; }

/* =========================
   Core physics
   n0 = 1 (air)
   Snell: sinθ = n1 sinθ1
   θ1 = asin(sinθ / n1)
   Δ = d * sin(θ - θ1) / cosθ1
   ========================= */
function theta1From(thetaRad, n1){
  const s = Math.sin(thetaRad)/n1;
  const ss = clamp(s, -1, 1);
  return Math.asin(ss);
}
function deltaShift(d_mm, thetaRad, n1){
  const th1 = theta1From(thetaRad, n1);
  const denom = Math.cos(th1);
  if(Math.abs(denom) < 1e-9) return NaN;
  return d_mm * Math.sin(thetaRad - th1) / denom;
}

/* =========================
   Canvas utilities
   ========================= */
function setupHiDPI(canvas){
  const ctx = canvas.getContext('2d');
  function resize(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(2, Math.floor(rect.width * dpr));
    const h = Math.max(2, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w;
      canvas.height = h;
    }
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return {cssW: rect.width, cssH: rect.height, dpr};
  }
  return {ctx, resize};
}

function getTheme(){
  const styles = getComputedStyle(document.documentElement);
  return {
    text: styles.getPropertyValue('--text').trim(),
    muted: styles.getPropertyValue('--muted').trim(),
    faint: styles.getPropertyValue('--faint').trim(),
    line: styles.getPropertyValue('--line').trim(),
    accent: styles.getPropertyValue('--accent').trim(),
    accent2: styles.getPropertyValue('--accent2').trim(),
    good: styles.getPropertyValue('--good').trim(),
    warn: styles.getPropertyValue('--warn').trim(),
    bad: styles.getPropertyValue('--bad').trim(),
  };
}

/* =========================
   Simple plotting primitives
   ========================= */
function drawAxes(ctx, box, opts){
  const {x0,y0,w,h} = box;
  const t = getTheme();
  ctx.save();
  ctx.lineWidth = 1;
  ctx.strokeStyle = t.line;
  ctx.fillStyle = t.muted;
  ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;

  // Title
  if(opts.title){
    ctx.fillStyle = t.text;
    ctx.font = '13px ' + getComputedStyle(document.body).fontFamily;
    ctx.fillText(opts.title, x0, y0 - 10);
    ctx.fillStyle = t.muted;
    ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;
  }

  // Border
  ctx.strokeRect(x0, y0, w, h);

  // Grid + ticks
  const nx = opts.nx || 6;
  const ny = opts.ny || 5;
  ctx.beginPath();
  for(let i=1;i<nx;i++){
    const x = x0 + (w*i)/nx;
    ctx.moveTo(x, y0);
    ctx.lineTo(x, y0+h);
  }
  for(let j=1;j<ny;j++){
    const y = y0 + (h*j)/ny;
    ctx.moveTo(x0, y);
    ctx.lineTo(x0+w, y);
  }
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  // keep grid subtle in light mode too:
  const isLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
  ctx.strokeStyle = isLight ? 'rgba(0,0,0,0.08)' : 'rgba(255,255,255,0.08)';
  ctx.stroke();

  // Axes labels
  ctx.fillStyle = t.muted;
  if(opts.xLabel){
    ctx.fillText(opts.xLabel, x0 + w - ctx.measureText(opts.xLabel).width, y0 + h + 26);
  }
  if(opts.yLabel){
    ctx.save();
    ctx.translate(x0 - 36, y0 + 8);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(opts.yLabel, 0, 0);
    ctx.restore();
  }

  // Tick labels
  ctx.fillStyle = t.faint;
  const xMin=opts.xMin, xMax=opts.xMax, yMin=opts.yMin, yMax=opts.yMax;
  for(let i=0;i<=nx;i++){
    const x = x0 + (w*i)/nx;
    const v = xMin + (xMax-xMin)*i/nx;
    const label = (opts.xTickFmt? opts.xTickFmt(v) : v.toFixed(0));
    ctx.fillText(label, x - ctx.measureText(label).width/2, y0 + h + 14);
  }
  for(let j=0;j<=ny;j++){
    const y = y0 + h - (h*j)/ny;
    const v = yMin + (yMax-yMin)*j/ny;
    const label = (opts.yTickFmt? opts.yTickFmt(v) : v.toFixed(2));
    ctx.fillText(label, x0 - ctx.measureText(label).width - 6, y + 4);
  }

  ctx.restore();
}

function mapToPlot(box, x, y, xMin, xMax, yMin, yMax){
  const {x0,y0,w,h} = box;
  const X = x0 + (x - xMin) * w / (xMax - xMin);
  const Y = y0 + h - (y - yMin) * h / (yMax - yMin);
  return {X,Y};
}

function niceMax(x){
  if(!isFinite(x) || x<=0) return 1;
  const p = Math.pow(10, Math.floor(Math.log10(x)));
  const m = x/p;
  let s = 1;
  if(m<=1) s=1;
  else if(m<=2) s=2;
  else if(m<=5) s=5;
  else s=10;
  return s*p;
}

/* =========================
   Diagram drawing
   ========================= */
const cDiagram = document.getElementById('cDiagram');
const cMain = document.getElementById('cMain');
const cSecondary = document.getElementById('cSecondary');
const diag = setupHiDPI(cDiagram);
const mainP = setupHiDPI(cMain);
const secP = setupHiDPI(cSecondary);

function drawDiagram(state){
  const {ctx} = diag;
  const {cssW:W, cssH:H} = diag.resize();
  ctx.clearRect(0,0,W,H);

  const t = getTheme();
  const isLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;

  // Layout
  const pad = 18;
  const plateW = W*0.46;
  const plateH = H*0.62;
  const plateX = W*0.30;
  const plateY = (H-plateH)/2;

  // Background gradient
  const g = ctx.createLinearGradient(0,0,W,H);
  if(isLight){
    g.addColorStop(0,'rgba(0,0,0,0.03)');
    g.addColorStop(1,'rgba(0,0,0,0.00)');
  }else{
    g.addColorStop(0,'rgba(255,255,255,0.04)');
    g.addColorStop(1,'rgba(255,255,255,0.00)');
  }
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // Plate
  ctx.fillStyle = isLight ? 'rgba(110,231,255,0.12)' : 'rgba(110,231,255,0.10)';
  ctx.strokeStyle = isLight ? 'rgba(0,0,0,0.18)' : 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.roundRect(plateX, plateY, plateW, plateH, 14);
  ctx.fill();
  ctx.stroke();

  // Normals (entry & exit)
  const nX1 = plateX;
  const nX2 = plateX + plateW;
  const midY = H/2;
  ctx.strokeStyle = isLight ? 'rgba(0,0,0,0.25)' : 'rgba(255,255,255,0.22)';
  ctx.setLineDash([5,5]);
  ctx.beginPath();
  ctx.moveTo(nX1, plateY-12);
  ctx.lineTo(nX1, plateY+plateH+12);
  ctx.moveTo(nX2, plateY-12);
  ctx.lineTo(nX2, plateY+plateH+12);
  ctx.stroke();
  ctx.setLineDash([]);

  // Ray geometry:
  // Incident ray in air approaching left face at (nX1, yEnter)
  const theta = deg2rad(state.thetaDeg);
  const n1 = state.n1;
  const th1 = theta1From(theta, n1);

  const yEnter = midY - 0.20*plateH; // choose visually nice entrance point
  // define a long segment for incident ray before plate
  const Lair = W*0.35;
  const xStart = nX1 - Lair;
  const yStart = yEnter + Math.tan(theta)*(nX1 - xStart); // line with angle theta w.r.t normal => slope w.r.t x is tan(theta)
  // Inside plate to exit face
  const xExit = nX2;
  const yExitInside = yEnter + Math.tan(th1)*(xExit - nX1);

  // Emergent ray parallel to incident, leaving from (xExit, yExitInside)
  const Lout = W*0.27;
  const xOutEnd = xExit + Lout;
  const yOutEnd = yExitInside - Math.tan(theta)*(xOutEnd - xExit);

  // Reference (straight continuation of incident ray, if no plate)
  const yRefAtExit = yEnter + Math.tan(theta)*(xExit - nX1);
  const deltaPx = (yRefAtExit - yExitInside); // perpendicular distance for parallel lines isn't vertical unless small angles;
  // We'll show "Δ" as shortest distance between lines via offset along normal to ray.
  // For drawing, show a segment approximately perpendicular to ray at exit face.
  const nxRay = Math.cos(theta); // direction cos along normal (z)
  const txRay = Math.sin(theta); // tangential component along x? (careful); in our drawing x is horizontal, y vertical.
  // In this drawing, the ray direction vector in (x,y) is (1, -tan(theta)) up to scale.
  // A perpendicular unit vector is proportional to (tan(theta), 1). We'll use that.
  const perp = {x: Math.tan(theta), y: 1};
  const perpLen = Math.hypot(perp.x, perp.y);
  perp.x/=perpLen; perp.y/=perpLen;

  // True Δ in mm (from formula). Convert to pixels for a nice visual: scale by plateH/(d_mm*something)
  // We'll just compute Δ in same "pixel units" by mapping mm to pixels with a chosen scale.
  const deltaMM = deltaShift(state.d_mm, theta, n1);
  const mmToPx = (plateH*0.55)/Math.max(0.1, state.d_mm); // purely visual scale
  const deltaDraw = deltaMM * mmToPx;

  const p1 = {x: xExit, y: yExitInside};
  const p2 = {x: xExit + perp.x*deltaDraw, y: yExitInside + perp.y*deltaDraw};

  // Draw rays
  ctx.lineWidth = 2.2;
  ctx.strokeStyle = t.accent;
  ctx.beginPath();
  ctx.moveTo(xStart, yStart);
  ctx.lineTo(nX1, yEnter);
  ctx.stroke();

  ctx.strokeStyle = t.accent2;
  ctx.beginPath();
  ctx.moveTo(nX1, yEnter);
  ctx.lineTo(xExit, yExitInside);
  ctx.stroke();

  ctx.strokeStyle = t.accent;
  ctx.beginPath();
  ctx.moveTo(xExit, yExitInside);
  ctx.lineTo(xOutEnd, yOutEnd);
  ctx.stroke();

  // Draw reference line (incident continuation)
  ctx.strokeStyle = isLight ? 'rgba(0,0,0,0.30)' : 'rgba(255,255,255,0.26)';
  ctx.lineWidth = 1.3;
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.moveTo(nX1, yEnter);
  ctx.lineTo(xExit, yRefAtExit);
  ctx.stroke();
  ctx.setLineDash([]);

  // Draw angle arcs
  function arcAt(x0,y0, ang, r, label){
    ctx.save();
    ctx.strokeStyle = isLight ? 'rgba(0,0,0,0.35)' : 'rgba(255,255,255,0.32)';
    ctx.lineWidth = 1.2;
    // normal points to +x direction
    ctx.beginPath();
    ctx.arc(x0, y0, r, -ang, 0, false);
    ctx.stroke();
    ctx.fillStyle = t.muted;
    ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;
    ctx.fillText(label, x0 + r*0.55, y0 - r*0.25);
    ctx.restore();
  }
  arcAt(nX1, yEnter, theta, 28, 'θ');
  arcAt(nX1+32, yEnter+20, th1, 24, 'θ₁');

  // Draw Δ marker
  ctx.strokeStyle = t.good;
  ctx.lineWidth = 2.0;
  ctx.beginPath();
  ctx.moveTo(p1.x, p1.y);
  ctx.lineTo(p2.x, p2.y);
  ctx.stroke();

  // End caps
  ctx.fillStyle = t.good;
  ctx.beginPath(); ctx.arc(p1.x, p1.y, 3.2, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(p2.x, p2.y, 3.2, 0, Math.PI*2); ctx.fill();

  // Labels
  ctx.fillStyle = t.text;
  ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;
  ctx.fillText('air (n₀≈1)', pad, pad+6);
  ctx.fillText('plate (n₁)', plateX + 10, plateY + 18);
  ctx.fillText('air', xExit + 12, pad+6);

  ctx.fillStyle = t.good;
  ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;
  ctx.fillText('Δ', (p1.x+p2.x)/2 + 6, (p1.y+p2.y)/2 + 2);

  // Thickness indicator
  ctx.strokeStyle = t.muted;
  ctx.lineWidth = 1.2;
  const yDim = plateY + plateH + 22;
  ctx.beginPath();
  ctx.moveTo(plateX, yDim);
  ctx.lineTo(plateX+plateW, yDim);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(plateX, yDim-6); ctx.lineTo(plateX, yDim+6);
  ctx.moveTo(plateX+plateW, yDim-6); ctx.lineTo(plateX+plateW, yDim+6);
  ctx.stroke();
  ctx.fillStyle = t.muted;
  ctx.fillText('d', plateX + plateW/2 - 4, yDim - 8);
}

CanvasRenderingContext2D.prototype.roundRect = CanvasRenderingContext2D.prototype.roundRect || function(x,y,w,h,r){
  r = Math.min(r, w/2, h/2);
  this.beginPath();
  this.moveTo(x+r, y);
  this.arcTo(x+w, y, x+w, y+h, r);
  this.arcTo(x+w, y+h, x, y+h, r);
  this.arcTo(x, y+h, x, y, r);
  this.arcTo(x, y, x+w, y, r);
  this.closePath();
  return this;
};

/* =========================
   Main plot: Δ vs θ
   ========================= */
function drawMainPlot(state){
  const {ctx} = mainP;
  const {cssW:W, cssH:H} = mainP.resize();
  ctx.clearRect(0,0,W,H);

  const padL = 54, padR = 18, padT = 38, padB = 46;
  const box = {x0: padL, y0: padT, w: W-padL-padR, h: H-padT-padB};

  // Data
  const thetaMaxDeg = 80;
  const N = 320;
  const xs = [];
  const ys = [];
  let yMax = 0;
  for(let i=0;i<=N;i++){
    const thDeg = thetaMaxDeg * i/N;
    const th = deg2rad(thDeg);
    const y = deltaShift(state.d_mm, th, state.n1);
    xs.push(thDeg);
    ys.push(y);
    if(isFinite(y)) yMax = Math.max(yMax, y);
  }
  yMax = niceMax(yMax * 1.06);

  drawAxes(ctx, box, {
    title: 'Δ vs θ (plate thickness d, index n₁)',
    xMin: 0, xMax: thetaMaxDeg,
    yMin: 0, yMax: yMax,
    xLabel: 'θ (deg)',
    yLabel: 'Δ (mm)',
    nx: 8, ny: 5,
    xTickFmt: v => v.toFixed(0),
    yTickFmt: v => (yMax>=10 ? v.toFixed(0) : v.toFixed(2))
  });

  // Curve
  const t = getTheme();
  ctx.save();
  ctx.lineWidth = 2.2;
  ctx.strokeStyle = t.accent;
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const p = mapToPlot(box, xs[i], ys[i], 0, thetaMaxDeg, 0, yMax);
    if(i===0) ctx.moveTo(p.X, p.Y);
    else ctx.lineTo(p.X, p.Y);
  }
  ctx.stroke();

  // Highlight current theta point
  const thDeg = state.thetaDeg;
  const th = deg2rad(thDeg);
  const y = deltaShift(state.d_mm, th, state.n1);
  const p = mapToPlot(box, thDeg, y, 0, thetaMaxDeg, 0, yMax);
  ctx.fillStyle = t.good;
  ctx.beginPath(); ctx.arc(p.X, p.Y, 4.2, 0, Math.PI*2); ctx.fill();

  // Legend
  ctx.fillStyle = t.muted;
  ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;
  const legend = `d = ${state.d_mm.toFixed(2)} mm,  n₁ = ${state.n1.toFixed(2)}`;
  ctx.fillText(legend, box.x0, box.y0 - 12);

  ctx.restore();
}

/* =========================
   Secondary plot: Δ vs n₁ at fixed θ
   ========================= */
function drawSecondaryPlot(state){
  const {ctx} = secP;
  const {cssW:W, cssH:H} = secP.resize();
  ctx.clearRect(0,0,W,H);

  const padL = 54, padR = 18, padT = 38, padB = 46;
  const box = {x0: padL, y0: padT, w: W-padL-padR, h: H-padT-padB};

  const nMin = 1.0, nMax = 2.5;
  const N = 300;
  const xs=[], ys=[];
  let yMax=0;
  const th = deg2rad(state.thetaDeg);
  for(let i=0;i<=N;i++){
    const n1 = nMin + (nMax-nMin)*i/N;
    const y = deltaShift(state.d_mm, th, n1);
    xs.push(n1);
    ys.push(y);
    if(isFinite(y)) yMax = Math.max(yMax, y);
  }
  yMax = niceMax(yMax*1.06);

  drawAxes(ctx, box, {
    title: 'Δ vs n₁ (fixed θ)',
    xMin: nMin, xMax: nMax,
    yMin: 0, yMax: yMax,
    xLabel: 'n₁ (dimensionless)',
    yLabel: 'Δ (mm)',
    nx: 6, ny: 5,
    xTickFmt: v => v.toFixed(2),
    yTickFmt: v => (yMax>=10 ? v.toFixed(0) : v.toFixed(2))
  });

  const t = getTheme();
  ctx.save();
  ctx.lineWidth = 2.2;
  ctx.strokeStyle = t.accent2;
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const p = mapToPlot(box, xs[i], ys[i], nMin, nMax, 0, yMax);
    if(i===0) ctx.moveTo(p.X, p.Y);
    else ctx.lineTo(p.X, p.Y);
  }
  ctx.stroke();

  // Highlight current n1
  const y = deltaShift(state.d_mm, th, state.n1);
  const p = mapToPlot(box, state.n1, y, nMin, nMax, 0, yMax);
  ctx.fillStyle = t.good;
  ctx.beginPath(); ctx.arc(p.X, p.Y, 4.2, 0, Math.PI*2); ctx.fill();

  // Legend
  ctx.fillStyle = t.muted;
  ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;
  ctx.fillText(`θ = ${state.thetaDeg.toFixed(1)}° , d = ${state.d_mm.toFixed(2)} mm`, box.x0, box.y0 - 12);

  ctx.restore();
}

/* =========================
   State + UI wiring
   ========================= */
const sTheta = document.getElementById('sTheta');
const sN1 = document.getElementById('sN1');
const sD = document.getElementById('sD');
const vTheta = document.getElementById('vTheta');
const vN1 = document.getElementById('vN1');
const vD = document.getElementById('vD');
const vTheta1 = document.getElementById('vTheta1');
const readout = document.getElementById('readout');
const diagBadge = document.getElementById('diagBadge');

const state = {
  thetaDeg: parseFloat(sTheta.value),
  n1: parseFloat(sN1.value),
  d_mm: parseFloat(sD.value),
};

function updateReadouts(){
  vTheta.textContent = state.thetaDeg.toFixed(1) + '°';
  vN1.textContent = state.n1.toFixed(2);
  vD.textContent = state.d_mm.toFixed(2) + ' mm';

  const th = deg2rad(state.thetaDeg);
  const th1 = theta1From(th, state.n1);
  vTheta1.textContent = rad2deg(th1).toFixed(2) + '°';

  const delta = deltaShift(state.d_mm, th, state.n1);
  const line1 = `Snell: sinθ = n₁ sinθ₁`;
  const line2 = `θ₁ = asin( sin(${state.thetaDeg.toFixed(1)}°) / ${state.n1.toFixed(2)} ) = ${rad2deg(th1).toFixed(2)}°`;
  const line3 = `Δ = d·sin(θ−θ₁)/cosθ₁ = ${state.d_mm.toFixed(2)}·sin(${state.thetaDeg.toFixed(1)}°−${rad2deg(th1).toFixed(2)}°)/cos(${rad2deg(th1).toFixed(2)}°)`;
  const line4 = `Δ = ${delta.toFixed(3)} mm`;
  readout.textContent = [line1,line2,line3,line4].join('\n');

  diagBadge.textContent = `θ = ${state.thetaDeg.toFixed(1)}°, n₁ = ${state.n1.toFixed(2)}, d = ${state.d_mm.toFixed(2)} mm`;
}

function renderAll(){
  updateReadouts();
  drawDiagram(state);
  drawMainPlot(state);
  drawSecondaryPlot(state);
}

function attach(){
  const onInput = ()=>{
    state.thetaDeg = parseFloat(sTheta.value);
    state.n1 = parseFloat(sN1.value);
    state.d_mm = parseFloat(sD.value);
    renderAll();
  };
  sTheta.addEventListener('input', onInput);
  sN1.addEventListener('input', onInput);
  sD.addEventListener('input', onInput);

  document.getElementById('btnReset').addEventListener('click', ()=>{
    sTheta.value = 45;
    sN1.value = 1.50;
    sD.value = 5.0;
    state.thetaDeg = 45;
    state.n1 = 1.50;
    state.d_mm = 5.0;
    renderAll();
  });

  // Responsive redraw
  const ro = new ResizeObserver(()=>renderAll());
  ro.observe(cDiagram);
  ro.observe(cMain);
  ro.observe(cSecondary);

  // Redraw on theme changes / DPR changes
  window.addEventListener('resize', ()=>renderAll(), {passive:true});
  if(window.matchMedia){
    const mq = window.matchMedia('(prefers-color-scheme: light)');
    mq.addEventListener ? mq.addEventListener('change', ()=>renderAll()) : mq.addListener(()=>renderAll());
  }
}

attach();
renderAll();
</script>
</body>
</html>
