<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Self-Reproducing Rays in a Symmetric Two-Mirror Resonator</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#121a33;
      --ink:#e8ecff;
      --muted:#b8c0ffcc;
      --line:#ffffff1a;
      --accent:#7aa7ff;
      --accent2:#7dffb2;
      --warn:#ffd37a;
      --bad:#ff7a9e;
      --good:#7dffb2;
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1200px 700px at 15% 10%, rgba(122,167,255,.22), transparent 55%),
        radial-gradient(900px 600px at 85% 30%, rgba(125,255,178,.14), transparent 55%),
        radial-gradient(900px 600px at 55% 90%, rgba(255,211,122,.10), transparent 55%),
        var(--bg);
      line-height:1.55;
    }

    header{
      padding: 34px 18px 18px;
      max-width: 1100px;
      margin: 0 auto;
    }
    header .hero{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 18px;
      align-items:stretch;
    }
    @media (max-width: 920px){
      header .hero{grid-template-columns:1fr}
    }
    h1{
      margin:0 0 8px;
      font-weight: 800;
      letter-spacing: .2px;
      font-size: clamp(1.6rem, 2.6vw, 2.3rem);
    }
    .subtitle{
      color: var(--muted);
      margin: 0 0 12px;
      font-size: 1.02rem;
    }
    .meta{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 12px;
    }
    .pill{
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      padding: 7px 10px;
      border-radius: 999px;
      font-size: .92rem;
      color: var(--muted);
    }

    main{
      max-width: 1100px;
      margin: 0 auto;
      padding: 12px 18px 70px;
    }

    .layout{
      display:grid;
      grid-template-columns: 290px 1fr;
      gap: 18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns:1fr}
    }

    nav.toc{
      position: sticky;
      top: 12px;
      align-self:start;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      backdrop-filter: blur(10px);
      border-radius: var(--radius);
      padding: 14px 14px 10px;
      box-shadow: var(--shadow);
    }
    nav.toc h2{
      font-size: 1.02rem;
      margin: 0 0 10px;
      letter-spacing: .2px;
    }
    nav.toc a{
      display:block;
      color: var(--muted);
      text-decoration:none;
      padding: 7px 8px;
      border-radius: 10px;
      border: 1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      font-size: .95rem;
    }
    nav.toc a:hover{
      background: rgba(122,167,255,.10);
      border-color: rgba(122,167,255,.25);
      transform: translateX(2px);
      color: var(--ink);
    }

    article{
      display:flex;
      flex-direction:column;
      gap: 14px;
    }

    section.card{
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    section.card h2{
      margin: 0 0 10px;
      font-size: 1.25rem;
      letter-spacing: .2px;
    }
    section.card h3{
      margin: 16px 0 8px;
      font-size: 1.08rem;
      color: var(--ink);
    }
    p{margin: 8px 0}
    ul{margin: 8px 0 8px 20px}
    li{margin: 6px 0}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 840px){
      .grid2{grid-template-columns:1fr}
    }

    .callout{
      border: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border-radius: 16px;
      padding: 14px;
      margin: 10px 0;
      position:relative;
      overflow:hidden;
    }
    .callout::before{
      content:"";
      position:absolute;
      inset:0;
      background: radial-gradient(650px 120px at 0% 0%, rgba(122,167,255,.18), transparent 55%);
      pointer-events:none;
    }
    .callout h4{
      margin: 0 0 6px;
      font-size: 1rem;
      letter-spacing:.2px;
    }
    .callout .tag{
      display:inline-block;
      font-size: .82rem;
      padding: 3px 8px;
      border-radius: 999px;
      margin-right: 8px;
      border:1px solid var(--line);
      color: var(--muted);
      background: rgba(255,255,255,.03);
    }
    .callout.good{border-color: rgba(125,255,178,.28)}
    .callout.good::before{background: radial-gradient(650px 120px at 0% 0%, rgba(125,255,178,.16), transparent 55%)}
    .callout.warn{border-color: rgba(255,211,122,.28)}
    .callout.warn::before{background: radial-gradient(650px 120px at 0% 0%, rgba(255,211,122,.14), transparent 55%)}
    .callout.bad{border-color: rgba(255,122,158,.28)}
    .callout.bad::before{background: radial-gradient(650px 120px at 0% 0%, rgba(255,122,158,.14), transparent 55%)}

    .eq{
      font-family: var(--mono);
      font-size: .98rem;
      line-height: 1.45;
      padding: 12px 12px;
      border: 1px solid var(--line);
      border-radius: 14px;
      background: rgba(0,0,0,.18);
      overflow:auto;
      position:relative;
      margin: 10px 0;
      white-space: pre;
    }
    .eq .copyBtn{
      position:absolute;
      top: 10px;
      right: 10px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--ink);
      border-radius: 10px;
      padding: 6px 9px;
      font-size: .85rem;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease;
    }
    .eq .copyBtn:hover{background: rgba(122,167,255,.14); transform: translateY(-1px)}
    .eq .copied{
      display:none;
      position:absolute;
      right: 10px;
      top: 44px;
      font-size: .82rem;
      color: var(--accent2);
    }

    .vizWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    .vizCard{
      border: 1px solid var(--line);
      background: rgba(0,0,0,.15);
      border-radius: 16px;
      padding: 12px;
    }
    .vizHeader{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 8px;
    }
    .vizHeader h3{
      margin: 0;
      font-size: 1.05rem;
    }
    canvas{
      width:100%;
      height: 280px;
      display:block;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(10,14,28,.55);
    }
    .smallCanvas{height: 240px}
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap: 12px;
      align-items:center;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--line);
    }
    .control{
      flex: 1 1 220px;
      min-width: 220px;
    }
    label{
      display:block;
      font-size: .9rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    input[type="range"]{width:100%}
    select{
      width:100%;
      padding: 9px 10px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--ink);
      outline:none;
    }
    .readout{
      font-family: var(--mono);
      font-size: .95rem;
      color: var(--ink);
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      min-width: 220px;
    }

    .finalBox{
      border: 1px solid rgba(125,255,178,.35);
      background: linear-gradient(180deg, rgba(125,255,178,.10), rgba(255,255,255,.03));
      border-radius: 18px;
      padding: 16px;
      position:relative;
      overflow:hidden;
      margin-top: 12px;
    }
    .finalBox::before{
      content:"";
      position:absolute;
      inset:0;
      background: radial-gradient(850px 160px at 0% 0%, rgba(125,255,178,.18), transparent 55%);
      pointer-events:none;
    }
    .finalBox h3{margin:0 0 8px}
    .finalAnswer{
      font-family: var(--mono);
      font-size: 1.03rem;
      white-space: pre-wrap;
      margin: 0;
      padding-right: 90px;
    }
    .finalCopy{
      position:absolute;
      top: 14px;
      right: 14px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.08);
      color: var(--ink);
      border-radius: 12px;
      padding: 8px 10px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease;
      font-size:.9rem;
    }
    .finalCopy:hover{background: rgba(125,255,178,.16); transform: translateY(-1px)}
    footer{
      max-width:1100px;
      margin: 0 auto;
      padding: 18px 18px 40px;
      color: var(--muted);
      font-size: .95rem;
    }

    /* Print-friendly */
    @media print{
      body{background:white;color:black}
      nav.toc{display:none}
      section.card{box-shadow:none;background:white;border-color:#ddd}
      canvas{border-color:#ddd;background:white}
      .eq{background:#f7f7f7;border-color:#ddd;color:black}
      .finalBox{background:#f3fff7;border-color:#8ad3a8}
      .pill{border-color:#ddd;background:#f7f7f7;color:#333}
      .callout{background:#fafafa;border-color:#ddd}
      .eq .copyBtn, .finalCopy{display:none}
    }
  </style>
</head>

<body>
<header>
  <div class="hero">
    <div>
      <h1>Self-Reproducing Rays in a Symmetric Optical Resonator</h1>
      <p class="subtitle">
        Two identical concave mirrors (radius <span style="font-family:var(--mono)">R</span>) separated by
        <span style="font-family:var(--mono)">d = 3|R|/2</span>.
        How many <em>round trips</em> does a paraxial ray need before it retraces its path?
      </p>
      <div class="meta">
        <span class="pill">Topic: geometric optics (paraxial)</span>
        <span class="pill">Tool: ABCD (ray-transfer) matrices</span>
        <span class="pill">Key idea: round-trip phase-space rotation</span>
      </div>
    </div>

    <div class="callout good">
      <h4><span class="tag">Result preview</span>What you will find</h4>
      <p style="margin:0">
        The round-trip ray map is a rotation by angle <span style="font-family:var(--mono)">2ψ</span> in
        ray phase space. For <span style="font-family:var(--mono)">d/R = 3/2</span>,
        <span style="font-family:var(--mono)">2ψ = 2π/3</span>, so the ray repeats after
        <span style="font-family:var(--mono)">N = 3</span> round trips.
      </p>
    </div>
  </div>
</header>

<main>
  <div class="layout">
    <nav class="toc" aria-label="Table of contents">
      <h2>Table of Contents</h2>
      <a href="#quick">Quick Summary</a>
      <a href="#part0">PART 0 — Concept Primer</a>
      <a href="#part1">PART 1 — Problem Analysis</a>
      <a href="#part2">PART 2 — Strategy & Tips</a>
      <a href="#part3">PART 3 — Full Solution</a>
      <a href="#part4">PART 4 — Deeper Understanding</a>
      <a href="#part5">PART 5 — Visualization Guide</a>
      <a href="#viz">Interactive Visualizations</a>
    </nav>

    <article>
      <section id="quick" class="card">
        <h2>Quick Summary</h2>
        <ul>
          <li><strong>What this is about:</strong> periodic (self-reproducing) ray paths in a two-mirror resonator.</li>
          <li><strong>Key physics idea:</strong> in the paraxial limit, a round trip maps a ray vector
            <span style="font-family:var(--mono)">[y, θ]</span> via an <span style="font-family:var(--mono)">ABCD</span> matrix.</li>
          <li><strong>Governing tool:</strong> round-trip matrix <span style="font-family:var(--mono)">M</span>;
            stability gives complex eigenvalues <span style="font-family:var(--mono)">e^{±i2ψ}</span>.</li>
          <li><strong>Rotation relation:</strong> <span style="font-family:var(--mono)">cos(2ψ) = (A + D)/2</span>
            (for a lossless, stable cavity).</li>
          <li><strong>Self-reproduction condition:</strong> the ray retraces when <span style="font-family:var(--mono)">M^N = I</span>,
            equivalently <span style="font-family:var(--mono)">N·2ψ = 2π m</span> for integers <span style="font-family:var(--mono)">N,m</span>.</li>
          <li><strong>For this cavity:</strong> with <span style="font-family:var(--mono)">d = 3R/2</span>,
            <span style="font-family:var(--mono)">cos(2ψ) = −1/2</span> ⇒ <span style="font-family:var(--mono)">2ψ = 2π/3</span>.</li>
          <li><strong>Final result (numeric count):</strong> the smallest <span style="font-family:var(--mono)">N</span> is <strong>3 round trips</strong>.</li>
        </ul>
      </section>

      <section id="part0" class="card">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <h3>Core definitions (symbols & units)</h3>
        <ul>
          <li><span style="font-family:var(--mono)">R</span> — mirror radius of curvature (m). For concave mirrors, take <span style="font-family:var(--mono)">R &gt; 0</span>.</li>
          <li><span style="font-family:var(--mono)">d</span> — mirror separation along the optical axis (m).</li>
          <li><span style="font-family:var(--mono)">y</span> — transverse displacement of a ray from the optical axis (m).</li>
          <li><span style="font-family:var(--mono)">θ</span> — small ray angle relative to the optical axis (rad), with paraxial assumption <span style="font-family:var(--mono)">|θ| ≪ 1</span>.</li>
          <li><span style="font-family:var(--mono)">[y, θ]^T</span> — ray state vector at some reference plane.</li>
        </ul>

        <h3>Physical meaning of the key quantities</h3>
        <ul>
          <li><strong>ABCD matrix</strong> tells you how a ray’s position and slope change through optical elements.</li>
          <li><strong>Round-trip map</strong> describes what happens after the ray hits both mirrors and returns to the starting reference plane.</li>
          <li><strong>Eigenvalues</strong> of the round-trip map encode whether rays stay bounded (stable) and how they “rotate” in phase space.</li>
        </ul>

        <div class="callout">
          <h4><span class="tag">Key law</span>Ray-transfer (ABCD) formalism</h4>
          <p style="margin:0">
            In paraxial optics, each element is linear in <span style="font-family:var(--mono)">y</span> and <span style="font-family:var(--mono)">θ</span>:
            <span style="font-family:var(--mono)">[y_out, θ_out]^T = [[A,B],[C,D]] [y_in, θ_in]^T</span>.
            Composition is ordinary matrix multiplication.
          </p>
        </div>

        <h3>When the model is valid (assumptions/conditions)</h3>
        <ul>
          <li><strong>Paraxial/small-angle:</strong> <span style="font-family:var(--mono)">sin θ ≈ θ</span>, <span style="font-family:var(--mono)">tan θ ≈ θ</span>.</li>
          <li><strong>Ideal mirrors:</strong> perfect reflection, no aberrations, no aperture clipping.</li>
          <li><strong>Geometrical optics regime:</strong> wavelength effects ignored (we track rays, not fields).</li>
        </ul>

        <h3>Common models/approximations used here (and why)</h3>
        <ul>
          <li><strong>Propagation in free space over distance d:</strong>
            <span style="font-family:var(--mono)">P(d) = [[1, d],[0,1]]</span> (because position changes as <span style="font-family:var(--mono)">y → y + dθ</span>).</li>
          <li><strong>Reflection at a spherical mirror of radius R:</strong> acts like a thin lens of focal length <span style="font-family:var(--mono)">f = R/2</span>
            in paraxial form:
            <span style="font-family:var(--mono)">M_m = [[1,0],[-2/R,1]]</span>.</li>
        </ul>

        <h3>Mini intuition examples</h3>
        <ul>
          <li><strong>Flat-flat cavity:</strong> mirror power is zero ⇒ rays drift away; no stable bounded orbits.</li>
          <li><strong>Stable cavity:</strong> the ray state doesn’t blow up; instead it cycles around the axis—mathematically a rotation in <span style="font-family:var(--mono)">(y, θ)</span> space.</li>
        </ul>

        <div class="callout warn">
          <h4><span class="tag">What to watch for</span>Typical pitfalls</h4>
          <ul style="margin: 8px 0 0 20px">
            <li>Mixing up <strong>one pass</strong> vs <strong>round trip</strong> matrices.</li>
            <li>For mirrors: using <span style="font-family:var(--mono)">-1/R</span> instead of <span style="font-family:var(--mono)">-2/R</span> in the paraxial reflection matrix.</li>
            <li>Thinking “retrace” means “back to the same point only.” It means the <em>entire ray state</em> (position and direction) repeats.</li>
            <li>For stable cavities, the trace gives a cosine; for unstable cavities it gives a hyperbolic cosine (no bounded rotation).</li>
          </ul>
        </div>
      </section>

      <section id="part1" class="card">
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

        <h3>Problem restated</h3>
        <p>
          We have a symmetric optical resonator made of two identical concave spherical mirrors,
          each with radius of curvature <span style="font-family:var(--mono)">R</span>.
          The mirrors are separated by <span style="font-family:var(--mono)">d = 3|R|/2</span>.
          A paraxial ray bounces between the mirrors. We want the smallest number of <strong>round trips</strong>
          after which the ray retraces its path exactly (same position and direction at the same reference plane).
        </p>

        <h3>Given</h3>
        <ul>
          <li><span style="font-family:var(--mono)">R</span> (mirror radius of curvature; concave so we take <span style="font-family:var(--mono)">R &gt; 0</span>)</li>
          <li><span style="font-family:var(--mono)">d = 3R/2</span></li>
        </ul>

        <h3>Unknown</h3>
        <ul>
          <li>Smallest integer <span style="font-family:var(--mono)">N</span> such that after <span style="font-family:var(--mono)">N</span> round trips the ray retraces its path.</li>
        </ul>

        <h3>Relevant principles (and why they apply)</h3>
        <ul>
          <li><strong>ABCD matrices:</strong> the cavity is a sequence of paraxial elements (propagation + mirror reflections), so the ray dynamics is linear.</li>
          <li><strong>Periodic orbit condition:</strong> retracing means the round-trip map returns the ray vector to itself:
            <span style="font-family:var(--mono)">M^N v = v</span> for all rays on that orbit; for a full retrace (generic ray), we use
            <span style="font-family:var(--mono)">M^N = I</span>.</li>
        </ul>

        <div class="callout">
          <h4><span class="tag">Assumptions</span>Idealizations we will use</h4>
          <ul style="margin: 8px 0 0 20px">
            <li>Paraxial rays: <span style="font-family:var(--mono)">|θ| ≪ 1</span>.</li>
            <li>Perfect spherical mirrors with radius <span style="font-family:var(--mono)">R</span>.</li>
            <li>No diffraction, no losses, no misalignment.</li>
          </ul>
        </div>

        <h3>Possible approaches (compare)</h3>
        <ul>
          <li><strong>(A) ABCD eigenvalue/trace method:</strong> compute the round-trip matrix, extract rotation angle from the trace, enforce <span style="font-family:var(--mono)">N·2ψ = 2πm</span>.
            <br><span style="color:var(--muted)">Pros: fast, clean, general. Cons: requires comfort with matrices/eigenvalues.</span></li>
          <li><strong>(B) Geometric imaging interpretation:</strong> use mirror imaging and periodic re-imaging conditions.
            <br><span style="color:var(--muted)">Pros: intuitive. Cons: can get messy; easy to lose the angle information.</span></li>
          <li><strong>(C) Direct iteration of a ray:</strong> pick a ray, iterate bounces numerically until it repeats.
            <br><span style="color:var(--muted)">Pros: easy to code. Cons: doesn’t guarantee minimal exact period unless you analyze rationality.</span></li>
        </ul>

        <p><strong>Choice:</strong> We’ll use <strong>(A)</strong> because it yields an exact, symbolic condition and a small integer period.</p>
      </section>

      <section id="part2" class="card">
        <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

        <ol>
          <li><strong>Model one free-space pass:</strong> write <span style="font-family:var(--mono)">P(d)</span>.
            <br><span style="color:var(--muted)">Meaning: how <span style="font-family:var(--mono)">y</span> changes due to slope <span style="font-family:var(--mono)">θ</span>.</span></li>
          <li><strong>Model one mirror reflection:</strong> write <span style="font-family:var(--mono)">M_m</span>.
            <br><span style="color:var(--muted)">Meaning: mirror curvature changes angle depending on height.</span></li>
          <li><strong>Build the round-trip matrix:</strong> multiply in the correct order to go from a reference plane back to itself.</li>
          <li><strong>Use the trace to get the rotation angle:</strong> for stable motion,
            <span style="font-family:var(--mono)">cos(2ψ) = (A + D)/2</span>.</li>
          <li><strong>Impose periodicity:</strong> smallest <span style="font-family:var(--mono)">N</span> with <span style="font-family:var(--mono)">N·2ψ = 2πm</span>.</li>
          <li><strong>Plug in</strong> <span style="font-family:var(--mono)">d/R = 3/2</span> and simplify.</li>
          <li><strong>Sanity check:</strong> verify stability and confirm the period is an integer.</li>
        </ol>

        <div class="callout warn">
          <h4><span class="tag">Quick tips</span>Common mistakes to avoid</h4>
          <ul style="margin: 8px 0 0 20px">
            <li>Round trip is <em>two</em> propagations and <em>two</em> reflections.</li>
            <li>Matrix order matters: last element applied is leftmost in the product.</li>
            <li>Use the principal angle <span style="font-family:var(--mono)">2ψ ∈ (0,π)</span> for stable cavities.</li>
          </ul>
        </div>
      </section>

      <section id="part3" class="card">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Physical intuition first</h3>
        <p>
          In a stable resonator, a generic paraxial ray does not escape; instead, its state
          <span style="font-family:var(--mono)">(y, θ)</span> evolves like a <em>rotation</em> in phase space each round trip.
          If that rotation angle is a rational fraction of <span style="font-family:var(--mono)">2π</span>, then after some integer number of
          round trips the ray returns to its initial state and therefore retraces the same bounce pattern.
        </p>

        <h3>Step 1 — Define the ray vector and element matrices</h3>
        <p>
          Let the ray at a reference plane (just after reflecting from mirror 1, for instance) be
          <span style="font-family:var(--mono)">v = [y, θ]^T</span>, where:
        </p>
        <ul>
          <li><span style="font-family:var(--mono)">y</span> is transverse displacement (m).</li>
          <li><span style="font-family:var(--mono)">θ</span> is slope/angle (rad), paraxial.</li>
        </ul>

        <div class="eq" data-copy="P(d) = [[1, d],[0, 1]]
M_m(R) = [[1, 0],[-2/R, 1]]">
          <button class="copyBtn" type="button">Copy</button>
          <span class="copied">Copied ✓</span>
P(d) = [[1, d],
        [0, 1]]

M_m(R) = [[1, 0],
          [-2/R, 1]]
        </div>

        <p>
          <strong>Why these forms?</strong>
          Over distance <span style="font-family:var(--mono)">d</span>, the ray height changes by <span style="font-family:var(--mono)">dθ</span>.
          A spherical mirror changes the ray angle by an amount proportional to height:
          <span style="font-family:var(--mono)">θ → θ − (2/R) y</span>.
        </p>

        <h3>Step 2 — Build the round-trip matrix</h3>
        <p>
          A round trip (starting just after mirror 1 reflection) is:
          propagate to mirror 2 → reflect → propagate back → reflect at mirror 1.
          Therefore:
        </p>

        <div class="eq" data-copy="M = M_m · P(d) · M_m · P(d)">
          <button class="copyBtn" type="button">Copy</button>
          <span class="copied">Copied ✓</span>
M = M_m · P(d) · M_m · P(d)
        </div>

        <p>
          Multiplying (and writing <span style="font-family:var(--mono)">x = d/R</span> for compactness) gives:
        </p>

        <div class="eq" data-copy="Let x = d/R.
A = 1 - 2x
B = 2d(1 - x)
C = 4(d - R)/R^2 = 4(x - 1)/R
D = 1 - 6x + 4x^2
Trace: (A + D)/2 = 1 - 4x + 2x^2">
          <button class="copyBtn" type="button">Copy</button>
          <span class="copied">Copied ✓</span>
Let x = d/R.

A = (R - 2d)/R = 1 - 2x
B = 2d(R - d)/R = 2d(1 - x)
C = 4(d - R)/R^2 = 4(x - 1)/R
D = 1 - 6(d/R) + 4(d/R)^2 = 1 - 6x + 4x^2

Half-trace (A + D)/2 = 1 - 4x + 2x^2
        </div>

        <p>
          <strong>What did we do?</strong> We encoded the entire round trip as one linear map.
          The half-trace will immediately tell us the “rotation angle” of this map when the cavity is stable.
        </p>

        <h3>Step 3 — Connect the trace to a rotation angle</h3>
        <p>
          For a stable, lossless resonator, the round-trip matrix has eigenvalues
          <span style="font-family:var(--mono)">e^{±i2ψ}</span>, where <span style="font-family:var(--mono)">ψ</span> is the phase-space rotation per half round trip.
          The trace relation is:
        </p>

        <div class="eq" data-copy="Stable cavity: cos(2ψ) = (A + D)/2">
          <button class="copyBtn" type="button">Copy</button>
          <span class="copied">Copied ✓</span>
Stable cavity:  cos(2ψ) = (A + D)/2
        </div>

        <p>
          <strong>Why true?</strong> If eigenvalues are <span style="font-family:var(--mono)">e^{±i2ψ}</span>, then their sum is
          <span style="font-family:var(--mono)">2 cos(2ψ)</span>, and the trace equals the sum of eigenvalues.
        </p>

        <h3>Step 4 — Impose “self-reproducing / retracing” condition</h3>
        <p>
          After <span style="font-family:var(--mono)">N</span> round trips, the phase-space rotation is
          <span style="font-family:var(--mono)">N·2ψ</span>.
          The ray retraces when the map returns to identity (same <span style="font-family:var(--mono)">y</span> and <span style="font-family:var(--mono)">θ</span>):
        </p>

        <div class="eq" data-copy="Retrace condition: M^N = I  ⇔  N·2ψ = 2π m,  with integers N,m.
Smallest positive N gives the first retrace.">
          <button class="copyBtn" type="button">Copy</button>
          <span class="copied">Copied ✓</span>
Retrace condition:  M^N = I
⇔ N·2ψ = 2π m,  with integers N, m.

The smallest positive N gives the first retrace.
        </div>

        <h3>Step 5 — Apply the given geometry d = 3R/2</h3>
        <p>
          Here <span style="font-family:var(--mono)">x = d/R = 3/2</span>. Plug into the half-trace:
        </p>
        <div class="eq" data-copy="x = 3/2
(A + D)/2 = 1 - 4x + 2x^2
          = 1 - 4(3/2) + 2(3/2)^2
          = 1 - 6 + 2(9/4)
          = 1 - 6 + 9/2
          = -1/2

So cos(2ψ) = -1/2 ⇒ 2ψ = 2π/3 (principal stable angle).">
          <button class="copyBtn" type="button">Copy</button>
          <span class="copied">Copied ✓</span>
x = 3/2

(A + D)/2 = 1 - 4x + 2x^2
          = 1 - 4(3/2) + 2(3/2)^2
          = 1 - 6 + 2(9/4)
          = 1 - 6 + 9/2
          = -1/2

So:  cos(2ψ) = -1/2
⇒ 2ψ = 2π/3  (choose the principal angle 0 < 2ψ < π for a stable cavity)
        </div>

        <p>
          <strong>Interpretation:</strong> Each round trip rotates the ray state by
          <span style="font-family:var(--mono)">2π/3</span> in phase space.
          Three such rotations return you to the starting point.
        </p>

        <div class="finalBox" id="final">
          <button class="finalCopy" type="button" id="finalCopy">Copy</button>
          <h3>Final Answer (boxed)</h3>
          <p class="finalAnswer" id="finalText">For d = 3R/2, the round-trip map has cos(2ψ) = −1/2 ⇒ 2ψ = 2π/3.
Retrace condition: N·2ψ = 2πm ⇒ N·(2π/3) = 2πm ⇒ N = 3m.
Smallest N = 3 round trips.</p>
        </div>

        <h3>Sanity checks</h3>
        <div class="grid2">
          <div class="callout good">
            <h4><span class="tag">Units</span>Dimensional consistency</h4>
            <p style="margin:0">
              <span style="font-family:var(--mono)">(A + D)/2</span> is dimensionless, so it can equal <span style="font-family:var(--mono)">cos(2ψ)</span>.
              Also <span style="font-family:var(--mono)">2ψ</span> is an angle (dimensionless), consistent.
            </p>
          </div>
          <div class="callout">
            <h4><span class="tag">Limiting idea</span>Rational angle ⇒ finite period</h4>
            <p style="margin:0">
              If <span style="font-family:var(--mono)">2ψ</span> were an irrational multiple of <span style="font-family:var(--mono)">2π</span>,
              the ray would never exactly repeat (though it could come arbitrarily close).
              Here it is exactly <span style="font-family:var(--mono)">2π/3</span>, so period is finite and small.
            </p>
          </div>
        </div>

        <p>
          <strong>Connection to the diagram/plots:</strong> The cavity geometry fixes <span style="font-family:var(--mono)">d/R</span>,
          which fixes the half-trace and thus the rotation angle per round trip. The plots below show how
          <span style="font-family:var(--mono)">2ψ</span> varies with <span style="font-family:var(--mono)">d/R</span> and how the predicted period changes.
        </p>
      </section>

      <section id="part4" class="card">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpreting the final condition</h3>
        <p>
          The key quantity is the dimensionless separation <span style="font-family:var(--mono)">x = d/R</span>.
          It controls the round-trip half-trace:
          <span style="font-family:var(--mono)">(A + D)/2 = 1 − 4x + 2x²</span>.
          Once you know this number, you immediately know:
        </p>
        <ul>
          <li><strong>Stability:</strong> stable if <span style="font-family:var(--mono)">|(A + D)/2| ≤ 1</span> (bounded rotation).</li>
          <li><strong>Rotation per round trip:</strong> <span style="font-family:var(--mono)">2ψ = arccos((A + D)/2)</span> (in the stable region).</li>
          <li><strong>Period:</strong> finite only when <span style="font-family:var(--mono)">2ψ / (2π)</span> is a rational number.</li>
        </ul>

        <h3>How changing parameters affects the outcome (connect to plots)</h3>
        <ul>
          <li>As you move <span style="font-family:var(--mono)">d/R</span>, the round-trip rotation angle changes smoothly in the stable band.</li>
          <li>At special values (like <span style="font-family:var(--mono)">d/R = 3/2</span>), the angle becomes a simple rational fraction of <span style="font-family:var(--mono)">2π</span>, giving a short retrace period.</li>
          <li>Most values produce “aperiodic” behavior (no exact retrace), even though rays remain bounded if stable.</li>
        </ul>

        <h3>Alternative derivation idea (brief)</h3>
        <p>
          You can relate the round-trip phase <span style="font-family:var(--mono)">2ψ</span> to the resonator’s
          <strong>g-parameters</strong>:
          <span style="font-family:var(--mono)">g = 1 − d/R</span> (symmetric cavity).
          For many resonators, the ray stability and Gouy phase per pass are linked, and one finds
          a rotation angle determined by combinations of <span style="font-family:var(--mono)">g</span>.
          With <span style="font-family:var(--mono)">g = 1 − 3/2 = −1/2</span>, the same cosine result emerges.
        </p>

        <h3>Concept checks (self-test)</h3>
        <ul>
          <li><strong>Q:</strong> If <span style="font-family:var(--mono)">2ψ = π</span>, how many round trips to retrace?
            <strong>A:</strong> <span style="font-family:var(--mono)">N = 2</span> (a 180° rotation needs two turns).</li>
          <li><strong>Q:</strong> Does a stable cavity always have a finite retrace period?
            <strong>A:</strong> No. Stability means bounded motion; exact repetition needs a rational rotation angle.</li>
          <li><strong>Q:</strong> What does it mean physically if <span style="font-family:var(--mono)">|(A+D)/2| &gt; 1</span>?
            <strong>A:</strong> Unstable: rays grow without bound (exponentially in the linear model).</li>
          <li><strong>Q:</strong> Why do we insist on both <span style="font-family:var(--mono)">y</span> and <span style="font-family:var(--mono)">θ</span> repeating?
            <strong>A:</strong> Because direction matters: same point but different angle is a different ray path.</li>
        </ul>
      </section>

      <section id="part5" class="card">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

        <h3>What each canvas shows</h3>
        <ul>
          <li><strong>Diagram canvas:</strong> two concave mirrors separated by <span style="font-family:var(--mono)">d</span>, with a representative ray.
            It’s a geometric reminder of the resonator and the definition of <span style="font-family:var(--mono)">R</span> and <span style="font-family:var(--mono)">d</span>.</li>
          <li><strong>Main plot:</strong> the round-trip rotation angle <span style="font-family:var(--mono)">2ψ</span> (in radians) versus <span style="font-family:var(--mono)">d/R</span>.
            Stable regions (where <span style="font-family:var(--mono)">|(A+D)/2| ≤ 1</span>) produce real angles.</li>
          <li><strong>Secondary plot:</strong> an estimated “retrace period” <span style="font-family:var(--mono)">N</span> versus <span style="font-family:var(--mono)">d/R</span>,
            found by rationally approximating <span style="font-family:var(--mono)">2ψ/(2π)</span> (small denominators show up as low periods).</li>
        </ul>

        <h3>Interactive control</h3>
        <ul>
          <li>The slider changes <span style="font-family:var(--mono)">x = d/R</span>.</li>
          <li>All canvases update live: the diagram updates the spacing, the main plot highlights the chosen <span style="font-family:var(--mono)">x</span>, and the secondary plot updates the predicted period.</li>
          <li>Set <span style="font-family:var(--mono)">d/R = 1.5</span> to match the problem; the readout should show <span style="font-family:var(--mono)">N = 3</span>.</li>
        </ul>
      </section>

      <section id="viz" class="card">
        <h2>Interactive Visualizations</h2>
        <p style="color:var(--muted); margin-top:-4px">
          These plots use <em>example scaling</em> for drawing (e.g., take <span style="font-family:var(--mono)">R = 1</span> unit in the diagram),
          but the physics depends only on <span style="font-family:var(--mono)">d/R</span>.
        </p>

        <div class="vizWrap">
          <div class="vizCard">
            <div class="vizHeader">
              <h3>Diagram: Symmetric Two-Mirror Resonator</h3>
              <div class="readout" id="readout1">x = d/R = 1.5000<br>cos(2ψ) = -0.5000<br>2ψ = 2.0944 rad</div>
            </div>
            <canvas id="cDiagram" aria-label="Resonator diagram"></canvas>
            <div class="controls">
              <div class="control">
                <label for="xSlider">Mirror separation ratio: x = d/R</label>
                <input id="xSlider" type="range" min="0.05" max="1.95" step="0.001" value="1.5" />
              </div>
              <div class="control">
                <label for="modeSelect">Ray style (for illustration)</label>
                <select id="modeSelect">
                  <option value="single" selected>Single bouncing ray</option>
                  <option value="fan">Fan of rays (stability feel)</option>
                </select>
              </div>
              <div class="readout" id="readout2">Estimated retrace N: 3<br>Fraction ≈ 1/3<br>Stable: yes</div>
            </div>
          </div>

          <div class="vizCard">
            <div class="vizHeader">
              <h3>Main Plot: Round-Trip Rotation Angle 2ψ vs d/R</h3>
              <div class="readout" id="readout3">Stable band shown where |cos(2ψ)| ≤ 1</div>
            </div>
            <canvas id="cMain" aria-label="Main plot of rotation angle"></canvas>
          </div>

          <div class="vizCard">
            <div class="vizHeader">
              <h3>Secondary Plot: Predicted Retrace Period N vs d/R (small denominators)</h3>
              <div class="readout" id="readout4">N found by rational approximation of 2ψ/(2π)</div>
            </div>
            <canvas id="cSecond" class="smallCanvas" aria-label="Secondary plot of period"></canvas>
          </div>
        </div>
      </section>
    </article>
  </div>
</main>

<footer>
  <p>
    Built with vanilla HTML/CSS/JS. Mathematics displayed as plain text (no MathJax).
    Tip: use the slider to explore which cavity geometries produce short periodic ray orbits.
  </p>
</footer>

<script>
/* --------------------------
   Utility: smooth scrolling
-------------------------- */
(function(){
  document.querySelectorAll('nav.toc a').forEach(a=>{
    a.addEventListener('click', (e)=>{
      const href = a.getAttribute('href');
      if(!href || !href.startsWith('#')) return;
      const el = document.querySelector(href);
      if(!el) return;
      e.preventDefault();
      el.scrollIntoView({behavior:'smooth', block:'start'});
      history.replaceState(null, "", href);
    });
  });
})();

/* --------------------------
   Copy buttons for equations
-------------------------- */
(function(){
  function flashCopied(container){
    const tag = container.querySelector('.copied');
    if(!tag) return;
    tag.style.display = 'block';
    setTimeout(()=>tag.style.display='none', 900);
  }
  document.querySelectorAll('.eq').forEach(eq=>{
    const btn = eq.querySelector('.copyBtn');
    if(!btn) return;
    btn.addEventListener('click', async ()=>{
      const text = eq.getAttribute('data-copy') || eq.innerText;
      try{
        await navigator.clipboard.writeText(text.trim());
        flashCopied(eq);
      }catch(err){
        // fallback
        const ta = document.createElement('textarea');
        ta.value = text.trim();
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        flashCopied(eq);
      }
    });
  });

  const finalCopy = document.getElementById('finalCopy');
  const finalText = document.getElementById('finalText');
  if(finalCopy && finalText){
    finalCopy.addEventListener('click', async ()=>{
      const text = finalText.textContent.trim();
      try{ await navigator.clipboard.writeText(text); }
      catch(e){
        const ta=document.createElement('textarea');
        ta.value=text; document.body.appendChild(ta);
        ta.select(); document.execCommand('copy');
        document.body.removeChild(ta);
      }
      finalCopy.textContent = 'Copied ✓';
      setTimeout(()=>finalCopy.textContent='Copy', 900);
    });
  }
})();

/* --------------------------
   Physics functions
-------------------------- */
function halfTraceFromX(x){
  // (A + D)/2 for symmetric cavity with two identical concave mirrors
  // derived: (A + D)/2 = 1 - 4x + 2x^2, where x = d/R
  return 1 - 4*x + 2*x*x;
}
function rotationAngle2psi(x){
  // returns object: {stable, cosv, twoPsi}
  const cosv = halfTraceFromX(x);
  const stable = Math.abs(cosv) <= 1;
  const twoPsi = stable ? Math.acos(cosv) : NaN;
  return {stable, cosv, twoPsi};
}

// Continued fraction rational approximation
function rationalApprox(value, maxDen=30){
  // value is a real number; return best p/q with q<=maxDen
  // using continued fractions
  let x = value;
  let a = Math.floor(x);
  let h1=1, k1=0;
  let h=a, k=1;
  for(let i=0; i<50; i++){
    const frac = x - a;
    if(Math.abs(frac) < 1e-14) break;
    x = 1/frac;
    a = Math.floor(x);
    const h2 = h1; const k2 = k1;
    h1 = h; k1 = k;
    h = a*h1 + h2;
    k = a*k1 + k2;
    if(k > maxDen) break;
  }
  // If we overshot maxDen, search nearby by scanning denominators
  let bestP=0, bestQ=1, bestErr=Infinity;
  for(let q=1; q<=maxDen; q++){
    const p = Math.round(value*q);
    const err = Math.abs(value - p/q);
    if(err < bestErr){
      bestErr = err; bestP = p; bestQ = q;
    }
  }
  return {p:bestP, q:bestQ, err:bestErr};
}

function estimatePeriodN(x){
  const r = rotationAngle2psi(x);
  if(!r.stable) return {N: null, stable:false, frac:null, approx:null, note:"unstable"};
  const frac = r.twoPsi / (2*Math.PI); // 2ψ/(2π)
  const approx = rationalApprox(frac, 30);
  const tol = 1e-3;
  if(approx.err < tol){
    // N is denominator q (smallest period in rotations)
    // Ensure reduced fraction:
    const g = (a,b)=> b?g(b,a%b):Math.abs(a);
    const gg = g(approx.p, approx.q) || 1;
    const p = approx.p/gg, q = approx.q/gg;
    return {N:q, stable:true, frac, approx:{p,q,err:approx.err}, note:"rational within tol"};
  }
  return {N:null, stable:true, frac, approx:{p:approx.p,q:approx.q,err:approx.err}, note:"no small rational"};
}

/* --------------------------
   Canvas plotting helpers
-------------------------- */
function setupHiDpiCanvas(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(2, Math.floor(rect.width * dpr));
  const h = Math.max(2, Math.floor(rect.height * dpr));
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w;
    canvas.height = h;
  }
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return {ctx, wCSS:rect.width, hCSS:rect.height, dpr};
}

function drawAxes(ctx, box, xLabel, yLabel, xTicks, yTicks, title){
  // box: {x,y,w,h} in CSS pixels
  const {x,y,w,h} = box;

  // background
  ctx.save();
  ctx.clearRect(x,y,w,h);

  // title
  ctx.fillStyle = "rgba(232,236,255,0.92)";
  ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(title, x + 10, y + 18);

  // plot area
  const padL = 52, padR = 18, padT = 30, padB = 42;
  const px = x + padL, py = y + padT, pw = w - padL - padR, ph = h - padT - padB;

  // gridlines + axes box
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth = 1;

  // grid
  ctx.beginPath();
  for(const t of xTicks){
    const gx = px + t * pw;
    ctx.moveTo(gx, py);
    ctx.lineTo(gx, py + ph);
  }
  for(const t of yTicks){
    const gy = py + (1 - t) * ph;
    ctx.moveTo(px, gy);
    ctx.lineTo(px + pw, gy);
  }
  ctx.stroke();

  // frame
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.strokeRect(px, py, pw, ph);

  // tick labels
  ctx.fillStyle = "rgba(184,192,255,0.92)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";

  // x axis labels
  for(const t of xTicks){
    const gx = px + t * pw;
    const label = t.toFixed(1);
    ctx.fillText(label, gx - 10, py + ph + 18);
  }
  // y axis labels
  for(const t of yTicks){
    const gy = py + (1 - t) * ph;
    const label = t.toFixed(1);
    ctx.fillText(label, x + 10, gy + 4);
  }

  // axis labels
  ctx.fillStyle = "rgba(232,236,255,0.90)";
  ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(xLabel, px + pw/2 - ctx.measureText(xLabel).width/2, y + h - 12);

  // y label (rotated)
  ctx.save();
  ctx.translate(x + 14, py + ph/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
  ctx.restore();

  ctx.restore();
  return {plot:{x:px,y:py,w:pw,h:ph}, pad:{padL,padR,padT,padB}};
}

function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

/* --------------------------
   Draw: Diagram
-------------------------- */
function drawDiagram(canvas, xRatio, mode){
  const {ctx, wCSS:W, hCSS:H} = setupHiDpiCanvas(canvas);
  ctx.clearRect(0,0,W,H);

  // coordinate system for diagram (CSS pixels)
  const margin = 18;
  const axisY = H*0.55;
  const left = margin, right = W - margin;
  const span = right - left;

  // Use R=1 as drawing scale; then d = xRatio*R
  // Fit d in the available span with some breathing room:
  const dNorm = xRatio; // in units of R
  const scale = span / (dNorm + 1.4); // extra for mirror bulge
  const Rpx = scale * 1.0;
  const dpx = scale * dNorm;

  const x1 = left + 0.7*scale;
  const x2 = x1 + dpx;

  // draw axis
  ctx.strokeStyle = "rgba(255,255,255,0.22)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(left, axisY);
  ctx.lineTo(right, axisY);
  ctx.stroke();

  // labels
  ctx.fillStyle = "rgba(184,192,255,0.92)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  ctx.fillText("optical axis", left + 6, axisY - 8);

  // mirrors: concave facing inward
  function drawConcaveMirror(x, facing){
    // facing: +1 means faces right (center of curvature to right), -1 faces left
    const y0 = axisY;
    const aperture = H*0.28;
    const arcRadius = Rpx;
    const bulge = 0.7*scale;

    ctx.strokeStyle = "rgba(232,236,255,0.85)";
    ctx.lineWidth = 2;

    ctx.beginPath();
    if(facing === +1){
      // mirror on left, concave to the right (arc bows right)
      // draw an arc segment of a circle whose center is to the right
      const cx = x + arcRadius;
      const cy = y0;
      const a1 = Math.asin(clamp((aperture/2)/arcRadius, -1, 1));
      ctx.arc(cx, cy, arcRadius, Math.PI + a1, Math.PI - a1, true);
    }else{
      // mirror on right, concave to the left (center to left)
      const cx = x - arcRadius;
      const cy = y0;
      const a1 = Math.asin(clamp((aperture/2)/arcRadius, -1, 1));
      ctx.arc(cx, cy, arcRadius, -a1, a1, false);
    }
    ctx.stroke();

    // mirror label
    ctx.fillStyle = "rgba(184,192,255,0.95)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("concave mirror", x - 42, y0 - aperture/2 - 10);
  }

  drawConcaveMirror(x1, +1);
  drawConcaveMirror(x2, -1);

  // distance label d
  ctx.strokeStyle = "rgba(122,167,255,0.55)";
  ctx.lineWidth = 1.5;
  const yDim = axisY + H*0.22;
  ctx.beginPath();
  ctx.moveTo(x1, yDim);
  ctx.lineTo(x2, yDim);
  ctx.stroke();
  // ticks
  ctx.beginPath();
  ctx.moveTo(x1, yDim-6); ctx.lineTo(x1, yDim+6);
  ctx.moveTo(x2, yDim-6); ctx.lineTo(x2, yDim+6);
  ctx.stroke();
  ctx.fillStyle = "rgba(232,236,255,0.92)";
  ctx.font = "600 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  const dLabel = `d = ${xRatio.toFixed(3)} R`;
  ctx.fillText(dLabel, (x1+x2)/2 - ctx.measureText(dLabel).width/2, yDim + 20);

  // draw a representative ray
  function drawRay(yStart, theta){
    // propagate bounce between mirrors a few times
    const nBounces = 6;
    let x = x1 + 8;
    let y = axisY + yStart;
    let th = theta;

    ctx.strokeStyle = "rgba(125,255,178,0.70)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, y);

    for(let i=0;i<nBounces;i++){
      // hit opposite mirror plane at x2 or x1
      const targetX = (i%2===0) ? (x2-8) : (x1+8);
      const dx = targetX - x;
      y = y + dx * th;
      x = targetX;
      ctx.lineTo(x, y);

      // reflect from spherical mirror (paraxial): theta -> theta - (2/R)*(y - axis)/? in normalized units.
      // In drawing units, take R=1 and convert y-offset in units of R.
      const yOffUnits = (y - axisY) / Rpx; // y in units of R
      th = th - 2 * yOffUnits; // dimensionless slope change; illustrative
    }
    ctx.stroke();
  }

  if(mode === "fan"){
    for(let i=-3;i<=3;i++){
      const y0 = i*H*0.03;
      const th0 = -0.03 + i*0.01;
      drawRay(y0, th0);
    }
    ctx.fillStyle = "rgba(184,192,255,0.85)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("illustrative ray fan", left + 10, margin + 22);
  }else{
    drawRay(-H*0.08, -0.035);
    ctx.fillStyle = "rgba(184,192,255,0.85)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("illustrative ray", left + 10, margin + 22);
  }

  // small annotation for R
  ctx.fillStyle = "rgba(184,192,255,0.92)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  ctx.fillText("R = mirror radius of curvature", left + 10, H - 14);
}

/* --------------------------
   Draw: Main plot (2ψ vs x)
-------------------------- */
function drawMainPlot(canvas, xNow){
  const {ctx, wCSS:W, hCSS:H} = setupHiDpiCanvas(canvas);

  const box = {x:0,y:0,w:W,h:H};
  const xTicks = [0,0.2,0.4,0.6,0.8,1.0].map(v=>v); // normalized positions for grid only
  const yTicks = [0,0.25,0.5,0.75,1.0];

  // We'll map x in [0,2] to normalized [0,1] for plotting; ticks show 0..2 via label logic below.
  const axis = drawAxes(
    ctx, box,
    "x = d/R (dimensionless)",
    "2ψ (rad)",
    [0,0.25,0.5,0.75,1.0],
    yTicks,
    "Round-trip rotation in ray phase space"
  );
  const P = axis.plot;

  // custom tick labels for x and y
  ctx.save();
  ctx.fillStyle = "rgba(184,192,255,0.92)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  const padL = 52, padT = 30, padB = 42;
  const px = P.x, py = P.y, pw = P.w, ph = P.h;

  // overwrite x labels with 0..2
  const xVals = [0,0.5,1.0,1.5,2.0];
  xVals.forEach(v=>{
    const t = v/2;
    const gx = px + t*pw;
    const lab = v.toFixed(1);
    ctx.fillText(lab, gx - 10, py + ph + 18);
  });

  // overwrite y labels with 0..π
  const yVals = [0, Math.PI/4, Math.PI/2, 3*Math.PI/4, Math.PI];
  yVals.forEach((v,i)=>{
    const t = v/Math.PI;
    const gy = py + (1 - t)*ph;
    const lab = v.toFixed(2);
    ctx.fillText(lab, 10, gy + 4);
  });
  ctx.restore();

  // plot curve where stable
  ctx.save();
  ctx.beginPath();
  let started = false;
  for(let i=0;i<=600;i++){
    const x = 2 * i/600;
    const r = rotationAngle2psi(x);
    if(!r.stable){
      started = false;
      continue;
    }
    const xn = x/2;
    const yn = r.twoPsi/Math.PI; // 0..1 since stable gives 2ψ in [0,π]
    const X = px + xn*pw;
    const Y = py + (1-yn)*ph;
    if(!started){ ctx.moveTo(X,Y); started=true; }
    else ctx.lineTo(X,Y);
  }
  ctx.strokeStyle = "rgba(122,167,255,0.85)";
  ctx.lineWidth = 2.2;
  ctx.stroke();

  // legend
  ctx.fillStyle = "rgba(122,167,255,0.85)";
  ctx.fillRect(px + 12, py + 10, 14, 6);
  ctx.fillStyle = "rgba(232,236,255,0.86)";
  ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("stable 2ψ(x) curve", px + 34, py + 16);

  // current point
  const rr = rotationAngle2psi(xNow);
  const stable = rr.stable;
  const xN = xNow/2;
  const Xc = px + xN*pw;
  let Yc = py + ph/2;
  if(stable){
    const yN = rr.twoPsi/Math.PI;
    Yc = py + (1-yN)*ph;
    ctx.fillStyle = "rgba(125,255,178,0.95)";
  }else{
    ctx.fillStyle = "rgba(255,122,158,0.95)";
  }
  ctx.beginPath();
  ctx.arc(Xc, Yc, 5.2, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle = "rgba(232,236,255,0.88)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  const label = stable ? `x=${xNow.toFixed(3)}, 2ψ=${rr.twoPsi.toFixed(3)} rad` : `x=${xNow.toFixed(3)} unstable`;
  ctx.fillText(label, Xc + 10, Yc - 10);

  ctx.restore();
}

/* --------------------------
   Draw: Secondary plot (N vs x)
-------------------------- */
function drawSecondPlot(canvas, xNow){
  const {ctx, wCSS:W, hCSS:H} = setupHiDpiCanvas(canvas);

  const box = {x:0,y:0,w:W,h:H};
  const axis = drawAxes(
    ctx, box,
    "x = d/R (dimensionless)",
    "Estimated N (round trips)",
    [0,0.25,0.5,0.75,1.0],
    [0,0.25,0.5,0.75,1.0],
    "Small-denominator retrace periods (heuristic)"
  );
  const P = axis.plot;
  const px = P.x, py = P.y, pw = P.w, ph = P.h;

  // Custom labels: x 0..2; y 0..30
  ctx.save();
  ctx.fillStyle = "rgba(184,192,255,0.92)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  const xVals = [0,0.5,1.0,1.5,2.0];
  xVals.forEach(v=>{
    const t=v/2;
    const gx=px+t*pw;
    ctx.fillText(v.toFixed(1), gx-10, py+ph+18);
  });
  const yVals = [0,10,20,30];
  yVals.forEach(v=>{
    const t = v/30;
    const gy = py + (1-t)*ph;
    ctx.fillText(String(v), 12, gy+4);
  });
  ctx.restore();

  // plot points for N (only where stable, and only small N<=30 via approximation)
  ctx.save();
  ctx.fillStyle = "rgba(122,167,255,0.65)";
  for(let i=0;i<=400;i++){
    const x = 2 * i/400;
    const est = estimatePeriodN(x);
    if(!est.stable || est.N === null) continue;
    const N = est.N;
    if(N > 30) continue;
    const X = px + (x/2)*pw;
    const Y = py + (1 - (N/30))*ph;
    ctx.beginPath();
    ctx.arc(X, Y, 2.6, 0, Math.PI*2);
    ctx.fill();
  }

  // highlight current x
  const estNow = estimatePeriodN(xNow);
  const Xc = px + (xNow/2)*pw;
  let Yc = py + ph*0.5;
  if(estNow.stable && estNow.N !== null){
    Yc = py + (1 - (estNow.N/30))*ph;
    ctx.fillStyle = "rgba(125,255,178,0.95)";
  }else if(!estNow.stable){
    ctx.fillStyle = "rgba(255,122,158,0.95)";
  }else{
    ctx.fillStyle = "rgba(255,211,122,0.95)";
  }
  ctx.beginPath();
  ctx.arc(Xc, Yc, 5.2, 0, Math.PI*2);
  ctx.fill();

  // legend
  ctx.fillStyle = "rgba(122,167,255,0.65)";
  ctx.fillRect(px + 12, py + 10, 14, 6);
  ctx.fillStyle = "rgba(232,236,255,0.86)";
  ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("x values with small N (≤30)", px + 34, py + 16);

  // label for highlight
  ctx.fillStyle = "rgba(232,236,255,0.88)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  let lab;
  if(!estNow.stable) lab = `x=${xNow.toFixed(3)} unstable`;
  else if(estNow.N === null) lab = `x=${xNow.toFixed(3)} no small-N repeat`;
  else lab = `x=${xNow.toFixed(3)} ⇒ N=${estNow.N}`;
  ctx.fillText(lab, Xc + 10, Yc - 10);

  ctx.restore();
}

/* --------------------------
   Wiring: Controls + updates
-------------------------- */
const cDiagram = document.getElementById('cDiagram');
const cMain = document.getElementById('cMain');
const cSecond = document.getElementById('cSecond');
const xSlider = document.getElementById('xSlider');
const modeSelect = document.getElementById('modeSelect');
const readout1 = document.getElementById('readout1');
const readout2 = document.getElementById('readout2');

function updateAll(){
  const x = parseFloat(xSlider.value);
  const mode = modeSelect.value;

  const rot = rotationAngle2psi(x);
  const est = estimatePeriodN(x);

  // readouts
  const cosv = rot.cosv;
  const twoPsiTxt = rot.stable ? rot.twoPsi.toFixed(4) + " rad" : "— (unstable)";
  readout1.innerHTML =
    `x = d/R = ${x.toFixed(4)}<br>` +
    `cos(2ψ) = ${cosv.toFixed(4)}<br>` +
    `2ψ = ${twoPsiTxt}`;

  let fracTxt = "—";
  if(est.stable && est.frac != null){
    fracTxt = est.frac.toFixed(6);
  }
  let fracBest = "—";
  if(est.stable && est.approx){
    fracBest = `${est.approx.p}/${est.approx.q} (err ${est.approx.err.toExponential(1)})`;
  }

  const stableTxt = est.stable ? "yes" : "no";
  const Ntxt = (!est.stable) ? "—" : (est.N === null ? "none (small-denom)" : String(est.N));

  readout2.innerHTML =
    `Estimated retrace N: ${Ntxt}<br>` +
    `Fraction 2ψ/(2π) ≈ ${fracBest}<br>` +
    `Stable: ${stableTxt}`;

  // draw
  drawDiagram(cDiagram, x, mode);
  drawMainPlot(cMain, x);
  drawSecondPlot(cSecond, x);

  // additional readouts near plots
  const r3 = document.getElementById('readout3');
  const r4 = document.getElementById('readout4');
  if(r3){
    r3.textContent = rot.stable
      ? `Current: x=${x.toFixed(3)}, 2ψ=${rot.twoPsi.toFixed(3)} rad`
      : `Current: x=${x.toFixed(3)} is unstable (|cos(2ψ)| > 1)`;
  }
  if(r4){
    r4.textContent = est.stable
      ? (est.N === null
        ? `Current: no exact repeat with denominator ≤ 30 (heuristic)`
        : `Current: N=${est.N} (since 2ψ/(2π) ≈ ${est.approx.p}/${est.approx.q})`)
      : `Current: unstable → no bounded periodic ray`;
  }
}

xSlider.addEventListener('input', updateAll);
modeSelect.addEventListener('change', updateAll);

// responsive: redraw on resize
let resizeTimer = null;
window.addEventListener('resize', ()=>{
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(updateAll, 80);
});

// initialize
updateAll();
</script>
</body>
</html>
