<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Resonance Frequencies of a Resonator with an Etalon (Tilted Plate)</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1a2f;
      --card:#101f3a;
      --card2:#0e1a33;
      --text:#e9eefc;
      --muted:#aeb9da;
      --faint:#7f8ab0;
      --accent:#8dd0ff;
      --accent2:#a6ffcb;
      --warn:#ffd38d;
      --ok:#b5ff8d;
      --bad:#ff9aa6;
      --border:rgba(255,255,255,.10);
      --shadow: 0 18px 60px rgba(0,0,0,.35);
      --radius:18px;
      --radius2:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 800px at 20% 10%, rgba(141,208,255,.14), transparent 60%),
                  radial-gradient(1000px 700px at 90% 0%, rgba(166,255,203,.10), transparent 60%),
                  radial-gradient(900px 700px at 60% 100%, rgba(255,211,141,.10), transparent 65%),
                  var(--bg);
      color:var(--text);
      line-height:1.55;
    }

    header{
      padding:34px 18px 20px;
      max-width:1200px;
      margin:0 auto;
    }
    .titleWrap{
      display:grid;
      gap:10px;
      padding:20px 22px;
      border:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .titleWrap:before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(700px 220px at 10% 10%, rgba(141,208,255,.18), transparent 55%),
                  radial-gradient(600px 200px at 85% 35%, rgba(166,255,203,.14), transparent 60%);
      filter:blur(0px);
      pointer-events:none;
    }
    .titleWrap > *{position:relative}
    h1{
      margin:0;
      font-size:clamp(1.35rem, 2.5vw, 2.0rem);
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      max-width:78ch;
      font-size:0.98rem;
      margin:0;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding:0 18px 80px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }

    nav{
      position:sticky;
      top:14px;
      align-self:start;
      padding:14px 14px;
      border:1px solid var(--border);
      border-radius:var(--radius);
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      box-shadow: 0 10px 40px rgba(0,0,0,.25);
      max-height: calc(100vh - 28px);
      overflow:auto;
    }
    nav h2{
      margin:6px 6px 10px;
      font-size:1.02rem;
      color:var(--text);
      letter-spacing:.2px;
    }
    nav a{
      display:block;
      padding:8px 10px;
      margin:4px 4px;
      border-radius:12px;
      text-decoration:none;
      color:var(--muted);
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:0.95rem;
    }
    nav a:hover{
      background:rgba(141,208,255,.10);
      border-color:rgba(141,208,255,.18);
      transform: translateY(-1px);
      color:var(--text);
    }
    .content{
      display:grid;
      gap:18px;
      min-width:0;
    }

    section{
      border:1px solid var(--border);
      border-radius:var(--radius);
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.015));
      box-shadow: 0 14px 48px rgba(0,0,0,.25);
      overflow:hidden;
    }
    section .inner{
      padding:18px 18px;
    }
    section h2{
      margin:0 0 10px;
      font-size:1.22rem;
      letter-spacing:.2px;
    }
    section h3{
      margin:16px 0 8px;
      font-size:1.05rem;
      color:var(--accent);
      letter-spacing:.2px;
    }
    p{margin:10px 0;color:var(--text)}
    .muted{color:var(--muted)}
    ul{margin:8px 0 8px 20px;color:var(--text)}
    li{margin:6px 0}
    .grid2{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:14px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1.2fr 1fr 1fr;
      gap:14px;
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.045), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius:var(--radius2);
      padding:14px 14px;
      min-width:0;
    }
    .callout{
      border-left:4px solid var(--accent);
      padding:12px 12px 12px 12px;
      background:linear-gradient(90deg, rgba(141,208,255,.11), rgba(255,255,255,.02));
      border-radius:14px;
      border:1px solid rgba(141,208,255,.18);
    }
    .callout.warn{
      border-left-color: var(--warn);
      background:linear-gradient(90deg, rgba(255,211,141,.12), rgba(255,255,255,.02));
      border-color: rgba(255,211,141,.20);
    }
    .callout.ok{
      border-left-color: var(--ok);
      background:linear-gradient(90deg, rgba(181,255,141,.10), rgba(255,255,255,.02));
      border-color: rgba(181,255,141,.18);
    }
    .callout.bad{
      border-left-color: var(--bad);
      background:linear-gradient(90deg, rgba(255,154,166,.10), rgba(255,255,255,.02));
      border-color: rgba(255,154,166,.18);
    }

    .eq{
      background: rgba(0,0,0,.28);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:12px;
      overflow:auto;
      position:relative;
    }
    .eq pre{
      margin:0;
      font-family:var(--mono);
      color:#eaf2ff;
      font-size:0.95rem;
      line-height:1.45;
      white-space:pre;
    }
    .copyBtn{
      position:absolute;
      top:10px;
      right:10px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:7px 10px;
      border-radius:12px;
      cursor:pointer;
      font-size:0.85rem;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
    }
    .copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(141,208,255,.10);
      border-color: rgba(141,208,255,.22);
    }
    .copyToast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform:translateX(-50%);
      padding:10px 12px;
      border-radius:14px;
      background:rgba(10,18,32,.92);
      border:1px solid rgba(255,255,255,.16);
      color:var(--text);
      box-shadow:0 16px 60px rgba(0,0,0,.35);
      opacity:0;
      pointer-events:none;
      transition:opacity .18s ease, transform .18s ease;
      z-index:9999;
      max-width:min(680px, calc(100vw - 36px));
      text-align:center;
      font-size:0.95rem;
    }
    .copyToast.show{
      opacity:1;
      transform:translateX(-50%) translateY(-3px);
    }

    figure{
      margin:0;
      padding:0;
    }
    .canvasCard{
      padding:0;
      overflow:hidden;
    }
    .canvasHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:14px 14px 10px;
      border-bottom:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.015));
    }
    .canvasHeader .title{
      margin:0;
      font-size:1.05rem;
      letter-spacing:.2px;
      color:var(--text);
    }
    .canvasHeader .hint{
      margin:0;
      color:var(--muted);
      font-size:0.9rem;
    }
    canvas{
      width:100%;
      height:340px;
      display:block;
      background: radial-gradient(900px 380px at 30% 10%, rgba(141,208,255,.08), transparent 55%),
                  radial-gradient(800px 380px at 85% 55%, rgba(166,255,203,.06), transparent 60%),
                  rgba(0,0,0,.10);
    }
    .canvasFooter{
      padding:12px 14px 14px;
      border-top:1px solid var(--border);
      color:var(--muted);
      font-size:0.9rem;
      background:linear-gradient(180deg, rgba(255,255,255,.015), rgba(255,255,255,.03));
    }

    .controls{
      display:grid;
      gap:10px;
    }
    .controlRow{
      display:grid;
      grid-template-columns: 140px 1fr 82px;
      gap:10px;
      align-items:center;
      padding:10px 10px;
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      background:rgba(255,255,255,.03);
    }
    .controlRow label{
      color:var(--text);
      font-size:0.95rem;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    select{
      width:100%;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(0,0,0,.22);
      color:var(--text);
    }
    .valBadge{
      text-align:right;
      font-family:var(--mono);
      color:var(--accent2);
      font-size:0.92rem;
      white-space:nowrap;
    }

    .kpi{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .kpi .box{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      border-radius:16px;
      padding:12px 12px;
    }
    .kpi .box .label{color:var(--muted);font-size:0.9rem}
    .kpi .box .value{font-family:var(--mono);font-size:1.06rem;color:var(--text);margin-top:6px}

    .fine{
      color:var(--faint);
      font-size:0.92rem;
    }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding:18px 18px 34px;
      color:var(--muted);
      font-size:0.92rem;
    }

    @media (max-width: 980px){
      main{grid-template-columns:1fr}
      nav{position:relative; top:auto; max-height:none}
    }

    @media print{
      body{background:#fff;color:#000}
      nav{display:none}
      section{box-shadow:none}
      .copyBtn, .copyToast{display:none !important}
      canvas{background:#fff}
    }
  </style>
</head>
<body>
<header>
  <div class="titleWrap">
    <h1>Resonance Frequencies of a Two-Mirror Resonator with a Tilted Plate (“Etalon” Insert)</h1>
    <p class="subtitle">
      We compute the <em>free spectral range</em> (spacing between adjacent cavity resonances) for a planar Fabry–Pérot resonator,
      first in air, then with a transparent plate inside that is tilted so its reflections do not form a second resonator.
    </p>
  </div>
</header>

<main>
  <nav aria-label="Table of Contents">
    <h2>Table of Contents</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#primer">PART 0 — Concept Primer</a>
    <a href="#analysis">PART 1 — Problem Analysis</a>
    <a href="#strategy">PART 2 — Strategy & Tips</a>
    <a href="#solution">PART 3 — Full Solution</a>
    <a href="#deeper">PART 4 — Deeper Understanding</a>
    <a href="#vizguide">PART 5 — Visualization Guide</a>
  </nav>

  <div class="content">

    <section id="quick">
      <div class="inner">
        <h2>Quick Summary</h2>
        <ul>
          <li><strong>What this is about:</strong> spacing between adjacent resonance frequencies (the <em>free spectral range</em>, FSR) of a planar Fabry–Pérot cavity.</li>
          <li><strong>Key physics idea:</strong> resonances occur when the <em>round-trip phase</em> is an integer multiple of <span class="muted">2π</span>.</li>
          <li><strong>Governing condition:</strong> round-trip optical path length <span class="muted">(OPL)</span> sets the mode spacing: <span class="muted">FSR = c / (2 L<sub>eff</sub>)</span>.</li>
          <li><strong>Effective length:</strong> with media pieces in series, <span class="muted">L<sub>eff</sub> = Σ n<sub>i</sub> ℓ<sub>i</sub></span> (one-way). For a plate inside: <span class="muted">L<sub>eff</sub> = (d − d₁)·1 + n·d₁ = d + (n−1)d₁</span>.</li>
          <li><strong>Part (a) numeric:</strong> for <span class="muted">d = 15 cm</span> in air, <span class="muted">FSR ≈ 1.00 GHz</span>.</li>
          <li><strong>Part (b) numeric:</strong> for <span class="muted">d₁ = 2.5 cm</span>, <span class="muted">n = 1.5</span>, <span class="muted">FSR ≈ 0.922 GHz</span> (smaller spacing because optical length increases).</li>
          <li><strong>Result type:</strong> symbolic formulas + numerical evaluation; interactive plots show how FSR changes with <span class="muted">d</span>, <span class="muted">d₁</span>, and <span class="muted">n</span>.</li>
        </ul>
      </div>
    </section>

    <section id="primer">
      <div class="inner">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <div class="grid2">
          <div class="card">
            <h3>Core definitions</h3>
            <ul>
              <li><strong>Fabry–Pérot resonator:</strong> two parallel mirrors separated by distance <span class="muted">d</span> (units: m).</li>
              <li><strong>Refractive index</strong> <span class="muted">n</span> (dimensionless): phase velocity is <span class="muted">c/n</span> in the medium.</li>
              <li><strong>Optical path length (OPL):</strong> <span class="muted">OPL = ∫ n(s) ds</span> (units: m). For uniform sections: <span class="muted">OPL = Σ n<sub>i</sub>ℓ<sub>i</sub></span>.</li>
              <li><strong>Resonant mode index</strong> <span class="muted">m</span> (integer): counts half-wavelengths “fitting” into the cavity.</li>
              <li><strong>Free spectral range (FSR):</strong> <span class="muted">Δf</span> = spacing between adjacent resonance frequencies (units: Hz).</li>
            </ul>
          </div>

          <div class="card">
            <h3>Physical meaning</h3>
            <ul>
              <li>Inside a resonator, multiple round trips interfere. If the round-trip phase equals <span class="muted">2πm</span>, the field reproduces itself after each round trip → <strong>constructive interference</strong>.</li>
              <li>The FSR is the “comb tooth spacing” of cavity resonances: a shorter cavity gives wider spacing; adding higher-index material increases phase per pass and thus <strong>reduces</strong> spacing.</li>
              <li>A <strong>tilted plate</strong> can be inserted without creating a second high-finesse etalon (its reflections walk off and don’t couple back), but it still increases OPL and changes resonance spacing.</li>
            </ul>
          </div>
        </div>

        <h3>Key laws / principles (and validity)</h3>
        <div class="callout">
          <strong>Resonance condition (plane-parallel, normal incidence):</strong><br/>
          A cavity resonates when the <em>round-trip</em> phase is an integer multiple of <span class="muted">2π</span>.
        </div>

        <div class="eq" id="eq1">
          <button class="copyBtn" data-copy-target="eq1txt">Copy</button>
          <pre id="eq1txt">Round-trip phase:   Φ_rt = 2 k0 ( Σ n_i ℓ_i )  = 2 k0 L_eff
Resonance:          Φ_rt = 2π m
where k0 = 2π/λ0 = 2π f / c, and L_eff = Σ n_i ℓ_i (one-way optical length)</pre>
        </div>

        <p class="muted">
          Assumptions behind this simple form: (i) planar mirrors, (ii) near-normal incidence (or we explicitly account for angle),
          (iii) linear, lossless media for phase accumulation, and (iv) we ignore small mirror phase shifts or treat them as constant offsets (they do not change the spacing for adjacent modes in the same band).
        </p>

        <h3>Common models / approximations (why we use them)</h3>
        <ul>
          <li><strong>Piecewise-uniform OPL:</strong> replace the integral by <span class="muted">Σ nℓ</span>. This is accurate when the cavity consists of uniform slabs (air + a plate).</li>
          <li><strong>Ignore plate reflections (tilted plate):</strong> the problem states the plate is tilted so reflections don’t reach the mirrors. That means the cavity “sees” only a changed propagation phase, not extra resonances from the plate acting as an etalon.</li>
          <li><strong>FSR from derivative:</strong> because <span class="muted">f_m</span> is (nearly) linear in <span class="muted">m</span>, spacing <span class="muted">Δf</span> is constant and easy to compute.</li>
        </ul>

        <h3>Mini intuition examples</h3>
        <ul>
          <li><strong>Shorten the cavity:</strong> if <span class="muted">d</span> halves, round-trip time halves, so resonances must be twice as far apart in frequency → FSR doubles.</li>
          <li><strong>Insert glass:</strong> replacing a segment of air by index <span class="muted">n&gt;1</span> slows phase velocity, increasing phase per pass → you need a smaller frequency increment to add <span class="muted">2π</span> phase → FSR decreases.</li>
        </ul>

        <div class="callout warn">
          <strong>What to watch for (pitfalls)</strong>
          <ul>
            <li><strong>One-way vs round-trip:</strong> FSR uses <span class="muted">2 L_eff</span> in the denominator because the phase condition is for a <em>round trip</em>.</li>
            <li><strong>“Etalon” confusion:</strong> a plate can create its own fringes if its reflections return and interfere. Here it is tilted to suppress that, so it only changes OPL.</li>
            <li><strong>Units:</strong> centimeters must be converted to meters when using <span class="muted">c</span> in m/s.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="analysis">
      <div class="inner">
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

        <h3>Restate the problem</h3>
        <p>
          We have a resonator made from two parallel planar mirrors separated by <span class="muted">d = 15 cm</span> in air.
          (a) Find the spacing between adjacent resonance frequencies (FSR).
          (b) Insert a transparent plate of thickness <span class="muted">d₁ = 2.5 cm</span> with refractive index <span class="muted">n = 1.5</span>.
          The plate is slightly tilted so light reflected from the plate does not reach the mirrors (so the plate does not act like a separate etalon).
          Find the new spacing between resonance frequencies of the resonator.
        </p>

        <div class="grid2">
          <div class="card">
            <h3>Given</h3>
            <ul>
              <li>Mirror separation: <span class="muted">d = 15 cm = 0.15 m</span></li>
              <li>Air index: <span class="muted">n_air = 1</span></li>
              <li>Plate thickness: <span class="muted">d₁ = 2.5 cm = 0.025 m</span></li>
              <li>Plate index: <span class="muted">n = 1.5</span></li>
              <li>Speed of light: <span class="muted">c = 2.99792458×10⁸ m/s</span></li>
            </ul>
          </div>
          <div class="card">
            <h3>Unknowns</h3>
            <ul>
              <li>(a) <span class="muted">Δf</span> = spacing between adjacent resonance frequencies</li>
              <li>(b) <span class="muted">Δf'</span> after inserting the tilted plate</li>
            </ul>
          </div>
        </div>

        <h3>Relevant principles (and why)</h3>
        <ul>
          <li><strong>Round-trip phase resonance:</strong> The cavity supports modes where the field reproduces after a round trip, i.e. <span class="muted">Φ_rt = 2πm</span>.</li>
          <li><strong>Optical path length additivity:</strong> In a stack of uniform segments, phases add as <span class="muted">k0 n ℓ</span>, so one-way effective optical length is <span class="muted">L_eff = Σ nℓ</span>.</li>
          <li><strong>Why not a full interference/transfer-matrix etalon analysis?</strong> Because the plate is tilted to prevent its reflections from coupling back into the cavity path; it does not create an additional resonant condition with the mirrors. We only keep its phase delay.</li>
        </ul>

        <div class="callout ok">
          <strong>Assumptions</strong>
          <ul>
            <li>Normal incidence (or near-normal): geometric length along the axis is <span class="muted">d</span>, and the plate thickness along the ray is effectively <span class="muted">d₁</span> (small tilt).</li>
            <li>Mirrors introduce no rapidly varying phase with frequency over one FSR (constant offsets do not change adjacent spacing).</li>
            <li>Dispersion neglected: <span class="muted">n</span> treated constant over the frequency interval of one FSR.</li>
          </ul>
        </div>

        <h3>Possible approaches (compare)</h3>
        <ol>
          <li><strong>Round-trip time approach:</strong> FSR equals inverse of round-trip time: <span class="muted">Δf = 1/T_rt</span>. Fast and intuitive.</li>
          <li><strong>Phase condition approach:</strong> Use <span class="muted">2k0 L_eff = 2πm</span> → solve for <span class="muted">f_m</span> and subtract adjacent modes. Most direct for piecewise media.</li>
          <li><strong>Transfer-matrix (full cavity):</strong> handles mirror phase, dispersion, and internal reflections. Overkill here because plate reflections are intentionally removed.</li>
        </ol>
        <p><strong>We choose</strong> the phase-condition approach because it cleanly incorporates the plate via the additive optical length and immediately yields the spacing.</p>
      </div>
    </section>

    <section id="strategy">
      <div class="inner">
        <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

        <ol>
          <li>
            <strong>Define the resonance condition.</strong><br/>
            <span class="muted">Tool:</span> <span class="muted">Φ_rt = 2k0 L_eff = 2πm</span>.<br/>
            <span class="muted">Meaning:</span> after one round trip, the wave returns in phase.
          </li>
          <li>
            <strong>Express the one-way effective optical length.</strong><br/>
            <span class="muted">Tool:</span> <span class="muted">L_eff = Σ n_i ℓ_i</span>.<br/>
            <span class="muted">Meaning:</span> how much phase the cavity accumulates per pass.
          </li>
          <li>
            <strong>Relate wavenumber to frequency.</strong><br/>
            <span class="muted">Tool:</span> <span class="muted">k0 = 2π f / c</span>.<br/>
            <span class="muted">Meaning:</span> frequency changes the phase linearly.
          </li>
          <li>
            <strong>Solve for the mode frequencies <span class="muted">f_m</span>.</strong><br/>
            <span class="muted">Tool:</span> rearrange resonance equation.<br/>
            <span class="muted">Meaning:</span> the cavity supports a “frequency comb”.
          </li>
          <li>
            <strong>Compute the spacing: <span class="muted">Δf = f_{m+1}-f_m</span>.</strong><br/>
            <span class="muted">Tool:</span> subtraction (should cancel <span class="muted">m</span>).<br/>
            <span class="muted">Meaning:</span> constant FSR set by optical length.
          </li>
          <li>
            <strong>Evaluate numerically for parts (a) and (b).</strong><br/>
            <span class="muted">Tool:</span> careful unit conversion, use <span class="muted">c</span> in m/s.<br/>
            <span class="muted">Meaning:</span> compare how the plate changes spacing.
          </li>
          <li>
            <strong>Sanity checks.</strong><br/>
            <span class="muted">Tool:</span> units, limiting cases (<span class="muted">d₁→0</span>, <span class="muted">n→1</span>).<br/>
            <span class="muted">Meaning:</span> verify physics and arithmetic.
          </li>
        </ol>

        <div class="callout warn">
          <strong>Common mistakes & quick tips</strong>
          <ul>
            <li><strong>Forgetting the factor 2:</strong> use <span class="muted">2L_eff</span> for a round trip → <span class="muted">FSR = c/(2L_eff)</span>.</li>
            <li><strong>Mixing lengths:</strong> <span class="muted">d</span> is the mirror separation; the plate replaces some air length, so the air segment becomes <span class="muted">d - d₁</span>.</li>
            <li><strong>Not converting cm → m:</strong> 15 cm = 0.15 m, 2.5 cm = 0.025 m.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="solution">
      <div class="inner">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Physical intuition first</h3>
        <p>
          A planar Fabry–Pérot cavity resonates when the wave returns in phase after a round trip.
          If the cavity is longer (or optically “slower” because we insert glass), the wave accumulates more phase for a given frequency,
          so it takes a <em>smaller</em> frequency change to add an extra <span class="muted">2π</span> phase. Therefore, adding a glass plate should
          <strong>decrease</strong> the spacing between resonances.
        </p>

        <h3>Step-by-step derivation</h3>

        <p><strong>Step 1: Write the resonance condition.</strong></p>
        <div class="eq" id="eq2">
          <button class="copyBtn" data-copy-target="eq2txt">Copy</button>
          <pre id="eq2txt">Resonance when round-trip phase is 2πm:
Φ_rt = 2 k0 L_eff = 2π m
k0 = 2π f / c
L_eff = one-way optical length (meters)</pre>
        </div>
        <p class="muted">
          We use <span class="muted">2 k0 L_eff</span> because the wave travels the one-way length twice in a round trip.
        </p>

        <p><strong>Step 2: Solve for the mode frequency <span class="muted">f_m</span>.</strong></p>
        <p>
          Substitute <span class="muted">k0 = 2π f / c</span> into <span class="muted">2 k0 L_eff = 2π m</span>:
        </p>
        <div class="eq" id="eq3">
          <button class="copyBtn" data-copy-target="eq3txt">Copy</button>
          <pre id="eq3txt">2 (2π f / c) L_eff = 2π m
⇒ (4π f L_eff)/c = 2π m
Divide by 2π:
⇒ (2 f L_eff)/c = m
⇒ f_m = m * (c / (2 L_eff))</pre>
        </div>
        <p class="muted">
          So the resonant frequencies form a uniformly spaced comb: each increment in <span class="muted">m</span> increases frequency by the same amount.
        </p>

        <p><strong>Step 3: Extract the free spectral range (FSR).</strong></p>
        <p>
          The spacing between adjacent modes is
          <span class="muted">Δf = f_{m+1} - f_m</span>.
        </p>
        <div class="eq" id="eq4">
          <button class="copyBtn" data-copy-target="eq4txt">Copy</button>
          <pre id="eq4txt">Δf = f_{m+1} - f_m
= (m+1) (c/(2L_eff)) - m (c/(2L_eff))
= c/(2L_eff)</pre>
        </div>

        <div class="callout ok">
          <strong>Key equation (FSR):</strong> <span class="muted">Δf = c / (2 L_eff)</span>, where <span class="muted">L_eff</span> is the one-way optical length.
        </div>

        <h3>Part (a): Cavity in air only</h3>
        <p>
          In air (index 1), the one-way optical length equals the physical separation:
          <span class="muted">L_eff = d</span>.
        </p>
        <div class="eq" id="eq5">
          <button class="copyBtn" data-copy-target="eq5txt">Copy</button>
          <pre id="eq5txt">Part (a):
L_eff = d
FSR: Δf_a = c / (2d)</pre>
        </div>

        <p>
          Insert <span class="muted">d = 0.15 m</span>:
        </p>
        <div class="eq" id="eq6">
          <button class="copyBtn" data-copy-target="eq6txt">Copy</button>
          <pre id="eq6txt">Δf_a = c / (2d) = 2.99792458e8 / (2*0.15)
     = 2.99792458e8 / 0.30
     ≈ 9.993081933e8 Hz
     ≈ 0.999 GHz  (≈ 1.00 GHz to 3 sig figs)</pre>
        </div>

        <h3>Part (b): Insert a tilted plate (no plate reflections returning)</h3>
        <p>
          The plate replaces a portion of air path. One-way, the wave travels:
        </p>
        <ul>
          <li>Air length: <span class="muted">d - d₁</span> with index <span class="muted">1</span></li>
          <li>Plate length: <span class="muted">d₁</span> with index <span class="muted">n</span></li>
        </ul>

        <p><strong>Compute the one-way effective optical length:</strong></p>
        <div class="eq" id="eq7">
          <button class="copyBtn" data-copy-target="eq7txt">Copy</button>
          <pre id="eq7txt">L_eff = (d - d1)*1 + (n)*d1
      = d + (n - 1) d1</pre>
        </div>

        <p class="muted">
          This is the cleanest way to see the effect: only the “extra” index above air, <span class="muted">(n−1)</span>, adds extra optical length.
        </p>

        <p><strong>Then the FSR becomes:</strong></p>
        <div class="eq" id="eq8">
          <button class="copyBtn" data-copy-target="eq8txt">Copy</button>
          <pre id="eq8txt">Part (b):
Δf_b = c / (2 L_eff) = c / (2 [ d + (n - 1) d1 ])</pre>
        </div>

        <p>Now insert numbers: <span class="muted">d = 0.15 m</span>, <span class="muted">d₁ = 0.025 m</span>, <span class="muted">n = 1.5</span>.</p>
        <div class="eq" id="eq9">
          <button class="copyBtn" data-copy-target="eq9txt">Copy</button>
          <pre id="eq9txt">L_eff = d + (n - 1) d1
      = 0.15 + (0.5)(0.025)
      = 0.15 + 0.0125
      = 0.1625 m

Δf_b = c / (2 L_eff) = 2.99792458e8 / (2*0.1625)
     = 2.99792458e8 / 0.325
     ≈ 9.224383323e8 Hz
     ≈ 0.922 GHz</pre>
        </div>

        <div class="callout ok" id="finalBox">
          <strong>Final answers</strong>
          <div class="eq" id="finalEq" style="margin-top:10px;">
            <button class="copyBtn" data-copy-target="finalTxt">Copy</button>
            <pre id="finalTxt">FSR (adjacent resonance spacing)

(a) Air cavity (d = 0.15 m):
Δf_a = c/(2d) ≈ 9.993×10^8 Hz ≈ 0.999 GHz ≈ 1.00 GHz

(b) With tilted plate (d1 = 0.025 m, n = 1.5):
L_eff = d + (n−1)d1 = 0.1625 m
Δf_b = c/(2L_eff) ≈ 9.224×10^8 Hz ≈ 0.922 GHz</pre>
          </div>
        </div>

        <h3>Sanity checks</h3>
        <div class="grid2">
          <div class="card">
            <h3>Units / dimensions</h3>
            <ul>
              <li><span class="muted">c</span> has units m/s and <span class="muted">L_eff</span> has units m → <span class="muted">c/(2L_eff)</span> has units 1/s = Hz ✅</li>
              <li>Both answers are ~GHz, reasonable for a ~10–20 cm cavity ✅</li>
            </ul>
          </div>
          <div class="card">
            <h3>Limiting cases</h3>
            <ul>
              <li>If <span class="muted">d₁ → 0</span> or <span class="muted">n → 1</span>, then <span class="muted">L_eff → d</span> and <span class="muted">Δf_b → Δf_a</span> ✅</li>
              <li>If <span class="muted">n</span> increases, <span class="muted">L_eff</span> increases → <span class="muted">Δf</span> decreases ✅</li>
            </ul>
          </div>
        </div>

        <p class="muted">
          Connection to the diagram and plots: the cavity resonance spacing is set by how long it takes (in optical phase terms) to complete
          a round trip between mirrors. The plate increases that phase delay, which the plots show as a smaller slope in the resonance-frequency-vs-mode line and a lower FSR curve.
        </p>
      </div>
    </section>

    <section id="deeper">
      <div class="inner">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpreting the formula</h3>
        <div class="callout">
          <strong>FSR as “inverse round-trip time”</strong><br/>
          The round-trip time is <span class="muted">T_rt = 2(d-d₁)/c + 2(n d₁)/c = 2L_eff/c</span>.
          Therefore <span class="muted">Δf = 1/T_rt = c/(2L_eff)</span>.
        </div>

        <p>
          In the plate-inserted case,
          <span class="muted">L_eff = d + (n−1)d₁</span> makes the parameter roles transparent:
        </p>
        <ul>
          <li><strong><span class="muted">d</span> controls the base spacing:</strong> larger mirror spacing → smaller FSR.</li>
          <li><strong><span class="muted">d₁</span> matters only through <span class="muted">(n−1)d₁</span>:</strong> the plate adds extra OPL compared to air.</li>
          <li><strong><span class="muted">n</span> is a multiplier of plate effect:</strong> higher index makes the cavity optically longer.</li>
        </ul>

        <h3>How changing parameters affects outcomes (connect to plots)</h3>
        <ul>
          <li>Increase <span class="muted">d</span> → the resonance line <span class="muted">f_m = m·FSR</span> gets a smaller slope; the FSR curve shifts down.</li>
          <li>Increase <span class="muted">d₁</span> (with <span class="muted">n&gt;1</span>) → <span class="muted">L_eff</span> increases linearly → FSR decreases smoothly.</li>
          <li>Increase <span class="muted">n</span> → the plate contributes more strongly; again FSR decreases.</li>
        </ul>

        <h3>Alternative derivation idea</h3>
        <p>
          Instead of phase quantization, you can derive FSR from time-domain intuition:
          a short pulse in the cavity repeats every round-trip time <span class="muted">T_rt</span>. A periodic time signal has a frequency comb with tooth spacing <span class="muted">1/T_rt</span>.
          That gives the same result immediately.
        </p>

        <h3>Concept check (quick self-test)</h3>
        <ul>
          <li><strong>Q:</strong> If you double the cavity length <span class="muted">d</span>, what happens to the FSR? <strong>A:</strong> It halves, since <span class="muted">Δf ∝ 1/d</span>.</li>
          <li><strong>Q:</strong> Why does tilting the plate matter? <strong>A:</strong> It prevents plate reflections from re-entering the cavity path, so the plate doesn’t form a second resonator; only its propagation phase remains.</li>
          <li><strong>Q:</strong> If <span class="muted">n = 1</span>, does the plate change the FSR? <strong>A:</strong> No: <span class="muted">L_eff = d + (n−1)d₁ = d</span>.</li>
          <li><strong>Q:</strong> Is FSR the same as finesse? <strong>A:</strong> No. FSR is the spacing between resonances; finesse compares FSR to linewidth.</li>
        </ul>
      </div>
    </section>

    <section id="vizguide">
      <div class="inner">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

        <div class="grid2">
          <div class="card">
            <h3>What each canvas shows</h3>
            <ul>
              <li><strong>Diagram:</strong> two planar mirrors separated by <span class="muted">d</span>, with an internal plate of thickness <span class="muted">d₁</span> and index <span class="muted">n</span>. Labels show air and glass segments and the “one-way optical length” idea.</li>
              <li><strong>Main plot:</strong> resonant frequencies <span class="muted">f_m</span> (GHz) versus mode number <span class="muted">m</span>. The slope of the line is the FSR.</li>
              <li><strong>Secondary plot:</strong> FSR (GHz) versus plate thickness <span class="muted">d₁</span> (cm) for the current <span class="muted">d</span> and <span class="muted">n</span>. A marker shows your current setting.</li>
            </ul>
          </div>

          <div class="card">
            <h3>Interactive controls</h3>
            <ul>
              <li><strong>Mirror separation <span class="muted">d</span> slider:</strong> changes the base cavity length; all plots update.</li>
              <li><strong>Plate thickness <span class="muted">d₁</span> slider:</strong> changes the added optical path; FSR decreases as <span class="muted">d₁</span> increases (for <span class="muted">n&gt;1</span>).</li>
              <li><strong>Plate index <span class="muted">n</span> selector:</strong> changes how strongly the plate affects optical length; higher <span class="muted">n</span> lowers FSR.</li>
            </ul>
            <p class="fine">
              These controls update the computed one-way optical length <span class="muted">L_eff = d + (n−1)d₁</span> and therefore update
              <span class="muted">FSR = c/(2L_eff)</span> everywhere.
            </p>
          </div>
        </div>

        <div class="card canvasCard" style="margin-top:14px;">
          <div class="canvasHeader">
            <div>
              <p class="title">Interactive Diagram: Resonator + Tilted Plate</p>
              <p class="hint">Geometry and optical-length bookkeeping (not to scale).</p>
            </div>
          </div>
          <canvas id="cDiag" aria-label="Resonator diagram canvas"></canvas>
          <div class="canvasFooter">
            The plate is shown slightly tilted to indicate its reflections do not re-couple into the cavity axis; only its propagation phase contributes to resonance spacing.
          </div>
        </div>

        <div class="grid2" style="margin-top:14px;">
          <div class="card canvasCard">
            <div class="canvasHeader">
              <div>
                <p class="title">Main Plot: Resonant Frequencies vs Mode Number</p>
                <p class="hint">Slope = FSR (GHz per mode).</p>
              </div>
            </div>
            <canvas id="cMain" aria-label="Main plot canvas"></canvas>
            <div class="canvasFooter">
              We plot <span class="muted">f_m = m·FSR</span> for modes <span class="muted">m = 0…M</span>. The line steepens when the cavity gets optically shorter.
            </div>
          </div>

          <div class="card canvasCard">
            <div class="canvasHeader">
              <div>
                <p class="title">Secondary Plot: FSR vs Plate Thickness</p>
                <p class="hint">Curve: Δf(d₁) for current d and n.</p>
              </div>
            </div>
            <canvas id="cSec" aria-label="Secondary plot canvas"></canvas>
            <div class="canvasFooter">
              The marker shows your current <span class="muted">d₁</span>. Increasing <span class="muted">d₁</span> increases <span class="muted">L_eff</span> and lowers FSR.
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:14px;">
          <h3>Controls (updates all canvases live)</h3>
          <div class="controls">
            <div class="controlRow">
              <label for="dSlider">Mirror separation d</label>
              <input id="dSlider" type="range" min="5" max="40" value="15" step="0.1" />
              <div class="valBadge" id="dVal">15.0 cm</div>
            </div>

            <div class="controlRow">
              <label for="d1Slider">Plate thickness d₁</label>
              <input id="d1Slider" type="range" min="0" max="10" value="2.5" step="0.1" />
              <div class="valBadge" id="d1Val">2.5 cm</div>
            </div>

            <div class="controlRow" style="grid-template-columns:140px 1fr 82px;">
              <label for="nSelect">Plate index n</label>
              <select id="nSelect">
                <option value="1.00">1.00</option>
                <option value="1.20">1.20</option>
                <option value="1.33">1.33</option>
                <option value="1.50" selected>1.50</option>
                <option value="1.70">1.70</option>
                <option value="2.00">2.00</option>
              </select>
              <div class="valBadge" id="nVal">1.50</div>
            </div>
          </div>

          <div class="kpi" style="margin-top:12px;">
            <div class="box">
              <div class="label">One-way optical length L<sub>eff</sub></div>
              <div class="value" id="kpiLeff">0.1625 m</div>
            </div>
            <div class="box">
              <div class="label">FSR = Δf = c / (2 L<sub>eff</sub>)</div>
              <div class="value" id="kpiFSR">0.922 GHz</div>
            </div>
          </div>
          <p class="fine" style="margin-top:10px;">
            Note: This visualization assumes the plate is thinly tilted (small angle) so the axial thickness remains approximately <span class="muted">d₁</span>
            while reflections are suppressed. Dispersion is neglected.
          </p>
        </div>

      </div>
    </section>

  </div>
</main>

<footer>
  <p>
    Built as a self-contained learning article: no external libraries, no MathJax. Copy buttons copy plain text equations and final answers.
  </p>
</footer>

<div class="copyToast" id="toast" role="status" aria-live="polite"></div>

<script>
(() => {
  // ---------------------------
  // Utilities
  // ---------------------------
  const C = 299792458; // m/s

  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

  function niceTicks(min, max, targetCount=6){
    // simple nice ticks for linear axes
    const span = max - min;
    if(span <= 0) return {min, max, step: 1};
    const rawStep = span / targetCount;
    const pow10 = Math.pow(10, Math.floor(Math.log10(rawStep)));
    const candidates = [1,2,5,10].map(k => k*pow10);
    let step = candidates[0];
    for(const s of candidates){
      if(rawStep <= s){ step = s; break; }
    }
    const niceMin = Math.floor(min/step)*step;
    const niceMax = Math.ceil(max/step)*step;
    return {min: niceMin, max: niceMax, step};
  }

  function setupHiDPI(canvas){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(2, Math.floor(rect.width));
    const h = Math.max(2, Math.floor(rect.height));
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return {ctx, w, h, dpr};
  }

  function drawGridAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title, legendLines){
    const {x, y, w, h, padL, padR, padT, padB} = box;
    ctx.save();
    ctx.clearRect(0,0, box.canvasW, box.canvasH);

    // panel background overlay (subtle)
    ctx.fillStyle = 'rgba(0,0,0,0.00)';
    ctx.fillRect(0,0, box.canvasW, box.canvasH);

    // Title
    ctx.fillStyle = 'rgba(233,238,252,0.95)';
    ctx.font = '600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(title, x + padL, y + 18);

    // plot area
    const px = x + padL;
    const py = y + padT;
    const pw = w - padL - padR;
    const ph = h - padT - padB;

    // border
    ctx.strokeStyle = 'rgba(255,255,255,0.14)';
    ctx.lineWidth = 1;
    ctx.strokeRect(px, py, pw, ph);

    // ticks
    const xt = niceTicks(xMin, xMax, 6);
    const yt = niceTicks(yMin, yMax, 6);

    // gridlines
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.fillStyle = 'rgba(174,185,218,0.9)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';

    // x grid + labels
    for(let xv = xt.min; xv <= xt.max + 1e-12; xv += xt.step){
      const tx = px + (xv - xMin) * pw / (xMax - xMin);
      ctx.beginPath();
      ctx.moveTo(tx, py);
      ctx.lineTo(tx, py + ph);
      ctx.stroke();
      // tick
      ctx.strokeStyle = 'rgba(255,255,255,0.14)';
      ctx.beginPath();
      ctx.moveTo(tx, py + ph);
      ctx.lineTo(tx, py + ph + 6);
      ctx.stroke();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';

      const label = formatTick(xv);
      ctx.fillText(label, tx - ctx.measureText(label).width/2, py + ph + 18);
    }

    // y grid + labels
    for(let yv = yt.min; yv <= yt.max + 1e-12; yv += yt.step){
      const ty = py + ph - (yv - yMin) * ph / (yMax - yMin);
      ctx.beginPath();
      ctx.moveTo(px, ty);
      ctx.lineTo(px + pw, ty);
      ctx.stroke();
      // tick
      ctx.strokeStyle = 'rgba(255,255,255,0.14)';
      ctx.beginPath();
      ctx.moveTo(px - 6, ty);
      ctx.lineTo(px, ty);
      ctx.stroke();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';

      const label = formatTick(yv);
      ctx.fillText(label, px - 10 - ctx.measureText(label).width, ty + 4);
    }

    // axis labels
    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(xLabel, px + pw - ctx.measureText(xLabel).width, py + ph + 36);

    // y label rotated
    ctx.save();
    ctx.translate(px - 46, py + 10);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    // legend (if provided)
    if(legendLines && legendLines.length){
      const lx = px + 12;
      const ly = py + 10;
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      let yy = ly;
      for(const item of legendLines){
        // swatch line
        ctx.strokeStyle = item.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(lx, yy);
        ctx.lineTo(lx + 18, yy);
        ctx.stroke();
        // label
        ctx.fillStyle = 'rgba(233,238,252,0.92)';
        ctx.fillText(item.text, lx + 24, yy + 4);
        yy += 18;
      }
    }

    ctx.restore();

    // return coordinate transforms
    return {
      px, py, pw, ph,
      xToPx: (xv) => px + (xv - xMin) * pw / (xMax - xMin),
      yToPx: (yv) => py + ph - (yv - yMin) * ph / (yMax - yMin),
      xMin, xMax, yMin, yMax
    };
  }

  function formatTick(v){
    const av = Math.abs(v);
    if(av >= 1000) return v.toFixed(0);
    if(av >= 100) return v.toFixed(0);
    if(av >= 10) return v.toFixed(1);
    if(av >= 1) return v.toFixed(2);
    return v.toFixed(3);
  }

  function showToast(msg){
    const el = document.getElementById('toast');
    el.textContent = msg;
    el.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => el.classList.remove('show'), 1200);
  }

  // Copy buttons
  document.querySelectorAll('.copyBtn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const id = btn.getAttribute('data-copy-target');
      const node = document.getElementById(id);
      const text = node ? node.textContent : '';
      try{
        await navigator.clipboard.writeText(text.trim());
        showToast('Copied to clipboard ✓');
      }catch(e){
        // fallback
        const ta = document.createElement('textarea');
        ta.value = text.trim();
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        ta.remove();
        showToast('Copied (fallback) ✓');
      }
    });
  });

  // ---------------------------
  // Model
  // ---------------------------
  function computeLeff(d_cm, d1_cm, n){
    const d = d_cm / 100;
    const d1 = d1_cm / 100;
    // ensure plate thickness doesn't exceed cavity length (physically)
    const d1c = clamp(d1, 0, d);
    return d + (n - 1) * d1c;
  }

  function computeFSR_GHz(d_cm, d1_cm, n){
    const Leff = computeLeff(d_cm, d1_cm, n);
    const fsr = C / (2 * Leff); // Hz
    return fsr / 1e9;
  }

  // ---------------------------
  // Drawing: Diagram
  // ---------------------------
  function drawDiagram(canvas, state){
    const {ctx, w, h} = setupHiDPI(canvas);

    // layout
    const margin = 18;
    const x0 = margin;
    const x1 = w - margin;
    const yMid = Math.round(h * 0.55);

    // mirror positions
    const mirrorW = 10;
    const gap = x1 - x0 - 2*mirrorW;

    // plate position and thickness (not to scale, but proportional)
    const fracPlate = state.d1_cm / Math.max(1e-6, state.d_cm);
    const plateW = clamp(gap * fracPlate, 18, gap * 0.65);
    const plateX = x0 + mirrorW + gap*0.52 - plateW*0.5;

    // background guide
    ctx.clearRect(0,0,w,h);

    // title inside canvas
    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.font = '600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Two-mirror cavity with a tilted plate insert', 18, 22);

    // optical axis line
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x0, yMid);
    ctx.lineTo(x1, yMid);
    ctx.stroke();

    // mirrors
    function drawMirror(x, label){
      ctx.fillStyle = 'rgba(141,208,255,0.16)';
      ctx.strokeStyle = 'rgba(141,208,255,0.55)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.rect(x, yMid - 90, mirrorW, 180);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = 'rgba(233,238,252,0.92)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText(label, x - 4, yMid - 100);
    }
    drawMirror(x0, 'Mirror 1');
    drawMirror(x1 - mirrorW, 'Mirror 2');

    // plate (tilted)
    const tilt = 0.20; // radians-ish for drawing
    const plateH = 160;
    const plateY = yMid - plateH/2;

    ctx.save();
    ctx.translate(plateX + plateW/2, yMid);
    ctx.rotate(-tilt);
    ctx.translate(-(plateX + plateW/2), -yMid);

    ctx.fillStyle = 'rgba(166,255,203,0.12)';
    ctx.strokeStyle = 'rgba(166,255,203,0.60)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(plateX, plateY, plateW, plateH);
    ctx.fill();
    ctx.stroke();

    ctx.restore();

    // ray arrows
    function arrow(xa, ya, xb, yb){
      const dx = xb-xa, dy = yb-ya;
      const L = Math.hypot(dx,dy) || 1;
      const ux = dx/L, uy = dy/L;
      const head = 10;
      ctx.strokeStyle = 'rgba(233,238,252,0.75)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(xa, ya);
      ctx.lineTo(xb, yb);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(xb, yb);
      ctx.lineTo(xb - head*ux + head*0.45*(-uy), yb - head*uy + head*0.45*(ux));
      ctx.lineTo(xb - head*ux - head*0.45*(-uy), yb - head*uy - head*0.45*(ux));
      ctx.closePath();
      ctx.fillStyle = 'rgba(233,238,252,0.75)';
      ctx.fill();
    }

    arrow(x0 + mirrorW + 10, yMid - 30, x1 - mirrorW - 12, yMid - 30);
    arrow(x1 - mirrorW - 12, yMid + 30, x0 + mirrorW + 10, yMid + 30);

    // segment labels
    ctx.fillStyle = 'rgba(174,185,218,0.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';

    // draw braces for air / plate / air
    const leftAirX0 = x0 + mirrorW;
    const leftAirX1 = plateX;
    const rightAirX0 = plateX + plateW;
    const rightAirX1 = x1 - mirrorW;

    function brace(xa, xb, y, text){
      const mid = (xa+xb)/2;
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(xa, y);
      ctx.lineTo(xb, y);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(xa, y);
      ctx.lineTo(xa+10, y-8);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(xb, y);
      ctx.lineTo(xb-10, y-8);
      ctx.stroke();
      ctx.fillStyle = 'rgba(174,185,218,0.95)';
      const tw = ctx.measureText(text).width;
      ctx.fillText(text, mid - tw/2, y - 12);
    }

    brace(leftAirX0, leftAirX1, yMid + 105, 'Air: (d − d₁), n=1');
    brace(plateX, plateX + plateW, yMid + 75, 'Plate: d₁, index n');
    brace(rightAirX0, rightAirX1, yMid + 105, 'Air: remaining');

    // formula box
    const boxX = 18, boxY = 46, boxW = w - 36, boxH = 72;
    ctx.fillStyle = 'rgba(0,0,0,0.22)';
    ctx.strokeStyle = 'rgba(255,255,255,0.14)';
    ctx.lineWidth = 1;
    roundRect(ctx, boxX, boxY, boxW, boxH, 14);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('One-way optical length:', boxX + 12, boxY + 22);

    ctx.fillStyle = 'rgba(166,255,203,0.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    const txt1 = 'L_eff = (d − d₁)·1 + n·d₁ = d + (n − 1)d₁';
    const txt2 = 'FSR:  Δf = c / (2 L_eff)';
    ctx.fillText(txt1, boxX + 12, boxY + 44);
    ctx.fillStyle = 'rgba(141,208,255,0.95)';
    ctx.fillText(txt2, boxX + 12, boxY + 62);

    // note about tilt
    ctx.fillStyle = 'rgba(255,211,141,0.92)';
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Tilt ⇒ plate reflections walk off (no extra etalon resonances)', 18, h - 18);

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
  }

  // ---------------------------
  // Drawing: Main plot (f_m vs m)
  // ---------------------------
  function drawMainPlot(canvas, state){
    const {ctx, w, h} = setupHiDPI(canvas);

    const M = 24;
    const fsr = computeFSR_GHz(state.d_cm, state.d1_cm, state.n);
    const xs = [];
    const ys = [];
    for(let m=0;m<=M;m++){
      xs.push(m);
      ys.push(m * fsr);
    }

    const yMax = Math.max(...ys);
    const pad = { padL: 62, padR: 16, padT: 34, padB: 54 };

    const box = { x:0, y:0, w, h, ...pad, canvasW:w, canvasH:h };
    const axis = drawGridAxes(
      ctx, box,
      0, M,
      0, yMax*1.08 + 1e-9,
      'Mode index m (dimensionless)',
      'Resonant frequency f_m (GHz)',
      'Resonant frequencies:  f_m = m · FSR',
      [{color:'rgba(141,208,255,0.85)', text:`Current FSR = ${fsr.toFixed(3)} GHz`}]
    );

    // plot line
    ctx.save();
    ctx.strokeStyle = 'rgba(141,208,255,0.85)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    xs.forEach((xv, i) => {
      const X = axis.xToPx(xv);
      const Y = axis.yToPx(ys[i]);
      if(i===0) ctx.moveTo(X,Y);
      else ctx.lineTo(X,Y);
    });
    ctx.stroke();

    // points
    ctx.fillStyle = 'rgba(233,238,252,0.85)';
    xs.forEach((xv, i) => {
      const X = axis.xToPx(xv);
      const Y = axis.yToPx(ys[i]);
      ctx.beginPath();
      ctx.arc(X, Y, 2.4, 0, Math.PI*2);
      ctx.fill();
    });

    // annotate slope idea
    const ax = axis.xToPx(M*0.58);
    const ay = axis.yToPx((M*0.58)*fsr);
    ctx.fillStyle = 'rgba(166,255,203,0.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    ctx.fillText(`Δf = ${fsr.toFixed(3)} GHz per mode`, ax + 10, ay - 12);

    ctx.restore();
  }

  // ---------------------------
  // Drawing: Secondary plot (FSR vs d1)
  // ---------------------------
  function drawSecondaryPlot(canvas, state){
    const {ctx, w, h} = setupHiDPI(canvas);

    const d1Max = 10; // cm sweep for display
    const N = 200;
    const xs = [];
    const ys = [];
    for(let i=0;i<=N;i++){
      const d1 = d1Max * i / N;
      xs.push(d1);
      ys.push(computeFSR_GHz(state.d_cm, d1, state.n));
    }

    const yMin = Math.min(...ys);
    const yMax = Math.max(...ys);

    const pad = { padL: 62, padR: 16, padT: 34, padB: 54 };
    const box = { x:0, y:0, w, h, ...pad, canvasW:w, canvasH:h };
    const axis = drawGridAxes(
      ctx, box,
      0, d1Max,
      yMin*0.96, yMax*1.04,
      'Plate thickness d₁ (cm)',
      'FSR Δf (GHz)',
      'How the plate reduces FSR:  Δf(d₁) = c / (2[d + (n−1)d₁])',
      [{color:'rgba(166,255,203,0.85)', text:`n = ${state.n.toFixed(2)}, d = ${state.d_cm.toFixed(1)} cm`}]
    );

    // curve
    ctx.save();
    ctx.strokeStyle = 'rgba(166,255,203,0.85)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    xs.forEach((xv, i) => {
      const X = axis.xToPx(xv);
      const Y = axis.yToPx(ys[i]);
      if(i===0) ctx.moveTo(X,Y);
      else ctx.lineTo(X,Y);
    });
    ctx.stroke();

    // current marker
    const curX = clamp(state.d1_cm, 0, Math.min(d1Max, state.d_cm));
    const curY = computeFSR_GHz(state.d_cm, curX, state.n);
    const Xc = axis.xToPx(curX);
    const Yc = axis.yToPx(curY);

    ctx.fillStyle = 'rgba(233,238,252,0.95)';
    ctx.beginPath();
    ctx.arc(Xc, Yc, 5.0, 0, Math.PI*2);
    ctx.fill();

    ctx.strokeStyle = 'rgba(255,211,141,0.85)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(Xc, axis.py);
    ctx.lineTo(Xc, axis.py + axis.ph);
    ctx.stroke();

    ctx.fillStyle = 'rgba(255,211,141,0.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    ctx.fillText(`d₁=${curX.toFixed(1)} cm → Δf=${curY.toFixed(3)} GHz`, Xc + 8, Yc - 10);

    ctx.restore();
  }

  // ---------------------------
  // State + UI wiring
  // ---------------------------
  const els = {
    dSlider: document.getElementById('dSlider'),
    d1Slider: document.getElementById('d1Slider'),
    nSelect: document.getElementById('nSelect'),
    dVal: document.getElementById('dVal'),
    d1Val: document.getElementById('d1Val'),
    nVal: document.getElementById('nVal'),
    kpiLeff: document.getElementById('kpiLeff'),
    kpiFSR: document.getElementById('kpiFSR'),
    cDiag: document.getElementById('cDiag'),
    cMain: document.getElementById('cMain'),
    cSec: document.getElementById('cSec')
  };

  const state = {
    d_cm: parseFloat(els.dSlider.value),
    d1_cm: parseFloat(els.d1Slider.value),
    n: parseFloat(els.nSelect.value)
  };

  function updateUI(){
    // keep d1 <= d
    state.d_cm = parseFloat(els.dSlider.value);
    state.d1_cm = parseFloat(els.d1Slider.value);
    state.n = parseFloat(els.nSelect.value);

    const d1Clamped = clamp(state.d1_cm, 0, state.d_cm);
    if(d1Clamped !== state.d1_cm){
      state.d1_cm = d1Clamped;
      els.d1Slider.value = d1Clamped.toFixed(1);
    }

    els.dVal.textContent = `${state.d_cm.toFixed(1)} cm`;
    els.d1Val.textContent = `${state.d1_cm.toFixed(1)} cm`;
    els.nVal.textContent = `${state.n.toFixed(2)}`;

    const Leff = computeLeff(state.d_cm, state.d1_cm, state.n);
    const fsrGHz = computeFSR_GHz(state.d_cm, state.d1_cm, state.n);

    els.kpiLeff.textContent = `${Leff.toFixed(4)} m`;
    els.kpiFSR.textContent = `${fsrGHz.toFixed(3)} GHz`;

    // redraw canvases
    drawDiagram(els.cDiag, state);
    drawMainPlot(els.cMain, state);
    drawSecondaryPlot(els.cSec, state);
  }

  ['input','change'].forEach(ev => {
    els.dSlider.addEventListener(ev, updateUI);
    els.d1Slider.addEventListener(ev, updateUI);
    els.nSelect.addEventListener(ev, updateUI);
  });

  // handle responsive resizing
  let resizeTimer = null;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(updateUI, 60);
  });

  // initialize
  updateUI();

})();
</script>
</body>
</html>
