<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Diffraction Loss in a Symmetric Confocal Resonator — Mirror Aperture for 1% Loss (1,0) Mode</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#101a33;
      --card2:#0f1730;
      --text:#e9eefc;
      --muted:#b9c3e6;
      --faint:#7f8ab8;
      --accent:#7ee6ff;
      --accent2:#a7ff9f;
      --warn:#ffd37e;
      --danger:#ff8a8a;
      --line:rgba(255,255,255,.12);
      --shadow: 0 18px 50px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1100px 700px at 15% 10%, rgba(126,230,255,.18), transparent 55%),
        radial-gradient(900px 600px at 75% 15%, rgba(167,255,159,.12), transparent 58%),
        radial-gradient(900px 650px at 55% 85%, rgba(255,211,126,.10), transparent 60%),
        linear-gradient(180deg, #070a14, var(--bg));
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:42px 20px 26px;
      position:relative;
      overflow:hidden;
    }
    header .wrap{max-width:1120px;margin:0 auto;display:grid;gap:16px}
    .kicker{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:8px 12px;
      border:1px solid var(--line);
      border-radius:999px;
      width:fit-content;
      background:rgba(255,255,255,.04);
      color:var(--muted);
      font-size:13px;
    }
    .kdot{width:8px;height:8px;border-radius:50%;background:var(--accent); box-shadow:0 0 18px rgba(126,230,255,.65)}
    h1{
      margin:0;
      font-weight:800;
      letter-spacing:-.02em;
      line-height:1.1;
      font-size: clamp(28px, 3.5vw, 44px);
    }
    .sub{
      color:var(--muted);
      max-width:80ch;
      font-size: 15.5px;
    }

    main{max-width:1120px;margin:0 auto;padding:0 20px 80px}
    .layout{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns:1fr}
    }

    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: rgba(16,26,51,.72);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      padding:14px 14px 12px;
    }
    nav.toc h2{
      margin: 4px 0 10px;
      font-size: 14px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color: var(--muted);
    }
    .toc a{
      display:block;
      padding:8px 10px;
      border-radius: 12px;
      color: var(--text);
      font-size: 14px;
      border:1px solid transparent;
    }
    .toc a:hover{
      background: rgba(255,255,255,.05);
      border-color: rgba(255,255,255,.10);
      text-decoration:none;
    }
    .toc small{color:var(--faint); display:block; margin-top:10px; padding: 0 10px 6px}

    section.card{
      background: rgba(16,26,51,.70);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      padding:18px 18px 14px;
      margin-bottom:18px;
      transform: translateY(0);
      animation: floatIn .55s ease both;
    }
    @keyframes floatIn{
      from{opacity:0; transform: translateY(10px)}
      to{opacity:1; transform: translateY(0)}
    }
    section.card h2{
      margin: 0 0 10px;
      font-size: 18px;
      letter-spacing:-.01em;
    }
    section.card h3{
      margin:16px 0 8px;
      font-size: 16px;
      color: var(--text);
    }

    .grid2{display:grid; grid-template-columns: 1fr 1fr; gap:14px}
    @media (max-width: 860px){.grid2{grid-template-columns:1fr}}
    .callout{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      border-radius: 16px;
      padding:12px 12px 10px;
    }
    .callout .title{
      font-weight:700;
      display:flex;
      align-items:center;
      gap:10px;
      margin-bottom:6px;
    }
    .pill{
      font-size: 12px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      color: var(--muted);
      background: rgba(0,0,0,.18);
    }
    .icon{
      width:10px;height:10px;border-radius:50%;
      background: var(--accent2);
      box-shadow:0 0 18px rgba(167,255,159,.55);
    }
    .icon.warn{background: var(--warn); box-shadow:0 0 18px rgba(255,211,126,.50)}
    .icon.danger{background: var(--danger); box-shadow:0 0 18px rgba(255,138,138,.55)}
    ul{margin:10px 0 0 18px; padding:0}
    li{margin:6px 0}
    .eq{
      font-family: var(--mono);
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 14px;
      padding: 10px 10px;
      position:relative;
      overflow:hidden;
      margin: 10px 0;
    }
    .eq .row{display:flex; gap:10px; align-items:flex-start; justify-content:space-between}
    .eq code{white-space:pre-wrap}
    .copyBtn{
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.05);
      color: var(--text);
      border-radius: 12px;
      padding:7px 10px;
      cursor:pointer;
      font-size: 12px;
      transition: transform .05s ease, background .2s ease;
      user-select:none;
    }
    .copyBtn:hover{background: rgba(255,255,255,.09)}
    .copyBtn:active{transform: scale(.98)}
    .note{color: var(--muted); font-size: 14px}

    .vizWrap{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
      align-items:stretch;
      margin-top: 10px;
    }
    @media (max-width: 980px){.vizWrap{grid-template-columns:1fr}}
    .vizCard{
      background: rgba(15,23,48,.70);
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:12px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .vizTitle{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      padding: 6px 6px 10px;
    }
    .vizTitle h3{margin:0; font-size: 15px}
    canvas{
      width:100%;
      height:340px;
      display:block;
      border-radius: 14px;
      background: rgba(0,0,0,.20);
      border:1px solid rgba(255,255,255,.10);
    }
    .small canvas{height:280px}
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin: 10px 6px 4px;
    }
    @media (max-width: 720px){.controls{grid-template-columns:1fr}}
    .ctrl{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      border-radius: 14px;
      padding: 10px 10px 8px;
    }
    .ctrl label{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      font-size: 13px;
      color: var(--muted);
      margin-bottom:6px;
    }
    .ctrl input[type="range"]{width:100%}
    .ctrl input[type="number"], .ctrl select{
      width: 100%;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.22);
      color: var(--text);
      font-family: var(--mono);
      font-size: 13px;
      outline:none;
    }
    .readout{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin:10px 6px 2px;
    }
    @media (max-width: 720px){.readout{grid-template-columns:1fr}}
    .metric{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      border-radius: 16px;
      padding: 10px 10px 8px;
    }
    .metric .k{color:var(--muted); font-size:12px; letter-spacing:.06em; text-transform:uppercase}
    .metric .v{
      font-family: var(--mono);
      font-size: 16px;
      margin-top: 6px;
    }

    footer{
      margin-top: 20px;
      color: var(--faint);
      font-size: 13px;
      padding: 14px 2px 0;
      border-top: 1px solid rgba(255,255,255,.10);
    }

    /* Print-friendly */
    @media print{
      body{background:#fff;color:#000}
      header, nav.toc{display:none}
      section.card, .vizCard{box-shadow:none; background:#fff; border:1px solid #ddd}
      canvas{border:1px solid #ddd; background:#fff}
      .copyBtn{display:none}
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="kicker"><span class="kdot"></span><span>Resonators • Diffraction Loss • Fresnel Number</span></div>
      <h1>Diffraction Loss in a Symmetric Confocal Resonator: Mirror Aperture for 1% Loss of the (1,0) Mode</h1>
      <div class="sub">
        We use the Fresnel number <span style="font-family:var(--mono)">N<sub>F</sub>=a²/(λ d)</span> and the loss-vs-<span style="font-family:var(--mono)">N<sub>F</sub></span>
        chart (Fig. 11.2-11) to determine the mirror aperture radius that yields a specified diffraction loss per pass.
        The interactive plots below let you plug in the <span style="font-family:var(--mono)">λ</span> and <span style="font-family:var(--mono)">d</span> values from Prob. 11.2-11 and read off the required mirror radius <span style="font-family:var(--mono)">a</span>.
      </div>
    </div>
  </header>

  <main>
    <div class="layout">
      <nav class="toc" aria-label="Table of contents">
        <h2>Contents</h2>
        <a href="#quick" data-scroll>Quick Summary</a>
        <a href="#part0" data-scroll>PART 0 — Concept Primer</a>
        <a href="#part1" data-scroll>PART 1 — Problem Analysis</a>
        <a href="#part2" data-scroll>PART 2 — Strategy &amp; Tips</a>
        <a href="#part3" data-scroll>PART 3 — Full Solution</a>
        <a href="#part4" data-scroll>PART 4 — Deeper Understanding</a>
        <a href="#part5" data-scroll>PART 5 — Visualization Guide</a>
        <small>Tip: click a section to jump smoothly.</small>
      </nav>

      <article>
        <!-- Quick Summary -->
        <section class="card" id="quick">
          <h2>Quick Summary</h2>
          <ul>
            <li><b>What this is about:</b> estimating <b>diffraction (aperture) loss</b> in a <b>symmetric confocal</b> optical resonator for low-order transverse modes.</li>
            <li><b>Key physics idea:</b> finite mirror aperture clips the Gaussian mode tails, causing a per-pass power loss that depends mainly on the <b>Fresnel number</b> <span style="font-family:var(--mono)">N<sub>F</sub></span>.</li>
            <li><b>Governing parameter:</b> <span style="font-family:var(--mono)">N<sub>F</sub> = a²/(λ d)</span> (dimensionless), where <span style="font-family:var(--mono)">a</span> is mirror aperture radius, <span style="font-family:var(--mono)">d</span> mirror spacing, <span style="font-family:var(--mono)">λ</span> wavelength.</li>
            <li><b>Chart usage:</b> Fig. 11.2-11 gives <b>loss per pass (%)</b> vs <span style="font-family:var(--mono)">N<sub>F</sub></span> for modes (0,0), (1,0), (2,0).</li>
            <li><b>For the (1,0) mode at 1% loss:</b> the chart intersection is at approximately <span style="font-family:var(--mono)">N<sub>F</sub> ≈ 1.0</span> (about 0.97–1.05 depending on how you read the plot).</li>
            <li><b>Final result type:</b> a <b>numeric mirror radius</b> once you insert <span style="font-family:var(--mono)">λ</span> and <span style="font-family:var(--mono)">d</span> from Prob. 11.2-11: <span style="font-family:var(--mono)">a = √(N<sub>F</sub> λ d)</span>.</li>
          </ul>
        </section>

        <!-- PART 0 -->
        <section class="card" id="part0">
          <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

          <div class="grid2">
            <div class="callout">
              <div class="title"><span class="icon"></span>Core definitions <span class="pill">symbols &amp; units</span></div>
              <ul>
                <li><span style="font-family:var(--mono)">a</span> — mirror <b>aperture radius</b> (m).</li>
                <li><span style="font-family:var(--mono)">d</span> — mirror <b>spacing</b> (m).</li>
                <li><span style="font-family:var(--mono)">λ</span> — vacuum <b>wavelength</b> (m).</li>
                <li><span style="font-family:var(--mono)">N<sub>F</sub> = a²/(λ d)</span> — <b>Fresnel number</b> (dimensionless).</li>
                <li><span style="font-family:var(--mono)">L</span> — diffraction <b>loss per pass</b> (fraction or %), here “per pass” = one mirror-to-mirror traversal (half round trip).</li>
              </ul>
            </div>

            <div class="callout">
              <div class="title"><span class="icon warn"></span>Physical meaning</div>
              <ul>
                <li><b>Diffraction loss</b> happens because the field extends beyond the finite mirror aperture and is “clipped.” That clipped power does not return to build up in the resonator.</li>
                <li><b>Fresnel number</b> compares aperture size to diffraction spreading over distance <span style="font-family:var(--mono)">d</span>. Larger <span style="font-family:var(--mono)">N<sub>F</sub></span> → larger aperture (relative to diffraction) → smaller loss.</li>
                <li>Higher-order transverse modes (like (1,0), (2,0)) are <b>broader / have stronger tails</b> → typically need larger apertures for the same loss.</li>
              </ul>
            </div>
          </div>

          <h3>Key principles and validity</h3>
          <ul>
            <li><b>Paraxial Gaussian optics:</b> transverse modes are Hermite–Gaussian (or Laguerre–Gaussian) solutions of the paraxial wave equation.</li>
            <li><b>Confocal resonator:</b> symmetric cavity with mirror radii of curvature equal to the spacing (<span style="font-family:var(--mono)">R = d</span>). This geometry sets a specific mode size on the mirrors and makes diffraction-loss curves largely a function of <span style="font-family:var(--mono)">N<sub>F</sub></span>.</li>
            <li><b>Chart-based modeling:</b> the provided figure is effectively a precomputed numerical result (integral diffraction + aperture truncation). We treat it as authoritative for this cavity class.</li>
          </ul>

          <h3>Common models/approximations (and why)</h3>
          <ul>
            <li><b>“Loss depends on Fresnel number”</b>: for a given cavity type and mode, the loss collapses onto a single curve vs <span style="font-family:var(--mono)">N<sub>F</sub></span>. This avoids re-solving diffraction integrals every time.</li>
            <li><b>Straight lines on semi-log plots</b>: in many aperture-loss problems, loss decreases roughly exponentially with aperture size, giving near-linear behavior on a log-loss vs linear-<span style="font-family:var(--mono)">N<sub>F</sub></span> plot.</li>
          </ul>

          <div class="grid2">
            <div class="callout">
              <div class="title"><span class="icon"></span>Mini intuition example 1</div>
              <p class="note">
                If you double the aperture radius <span style="font-family:var(--mono)">a</span> while keeping <span style="font-family:var(--mono)">λ</span> and <span style="font-family:var(--mono)">d</span> fixed, then <span style="font-family:var(--mono)">N<sub>F</sub></span> increases by a factor of 4.
                On the chart, moving right by that amount can drop loss by orders of magnitude.
              </p>
            </div>
            <div class="callout">
              <div class="title"><span class="icon"></span>Mini intuition example 2</div>
              <p class="note">
                If you increase spacing <span style="font-family:var(--mono)">d</span> (longer cavity) with fixed <span style="font-family:var(--mono)">a</span> and <span style="font-family:var(--mono)">λ</span>, then <span style="font-family:var(--mono)">N<sub>F</sub></span> decreases. The beam diffracts “more” over the longer distance, so a fixed aperture clips more power → higher loss.
              </p>
            </div>
          </div>

          <div class="callout" style="margin-top:14px">
            <div class="title"><span class="icon danger"></span>What to watch for (pitfalls)</div>
            <ul>
              <li><b>Per pass vs per round trip:</b> the figure is “per pass” (half round trip). Do not double it unless asked for round-trip loss.</li>
              <li><b>Radius vs diameter:</b> the Fresnel number uses <span style="font-family:var(--mono)">a</span> (radius). The drawing often labels aperture diameter as <span style="font-family:var(--mono)">2a</span>.</li>
              <li><b>Confocal assumption:</b> these curves are for a <b>symmetric confocal</b> resonator; other geometries have different losses for the same <span style="font-family:var(--mono)">N<sub>F</sub></span>.</li>
              <li><b>Reading semi-log charts:</b> small visual errors can shift <span style="font-family:var(--mono)">N<sub>F</sub></span> by ~5–10%; propagate that into <span style="font-family:var(--mono)">a</span> via a square root.</li>
            </ul>
          </div>
        </section>

        <!-- PART 1 -->
        <section class="card" id="part1">
          <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

          <h3>Problem restatement (in plain words)</h3>
          <p>
            A symmetric confocal optical resonator has mirror spacing <span style="font-family:var(--mono)">d</span> and mirror aperture radius <span style="font-family:var(--mono)">a</span>.
            A provided chart gives diffraction loss per pass for several transverse modes versus Fresnel number
            <span style="font-family:var(--mono)">N<sub>F</sub> = a²/(λ d)</span>.
            Using the parameters from Prob. 11.2-11 (which specify <span style="font-family:var(--mono)">λ</span> and <span style="font-family:var(--mono)">d</span>), find the mirror radius <span style="font-family:var(--mono)">a</span> such that the (1,0) mode has <b>1% loss per pass</b>.
          </p>

          <div class="grid2">
            <div class="callout">
              <div class="title"><span class="icon"></span>Given quantities</div>
              <ul>
                <li><span style="font-family:var(--mono)">λ</span> — wavelength (from Prob. 11.2-11).</li>
                <li><span style="font-family:var(--mono)">d</span> — mirror spacing (from Prob. 11.2-11).</li>
                <li>Mode: (1,0).</li>
                <li>Target loss per pass: <span style="font-family:var(--mono)">L = 1%</span>.</li>
                <li>Chart: loss (%) vs <span style="font-family:var(--mono)">N<sub>F</sub></span> for a symmetric confocal resonator.</li>
              </ul>
            </div>
            <div class="callout">
              <div class="title"><span class="icon"></span>Unknowns</div>
              <ul>
                <li><span style="font-family:var(--mono)">a</span> — mirror aperture radius that achieves the target loss.</li>
                <li>Intermediate: <span style="font-family:var(--mono)">N<sub>F</sub></span> at which the (1,0) curve equals 1% loss.</li>
              </ul>
            </div>
          </div>

          <h3>Relevant principles (and why they apply)</h3>
          <ul>
            <li><b>Fresnel number definition</b> directly links the geometry (<span style="font-family:var(--mono)">a,d</span>) and wavelength (<span style="font-family:var(--mono)">λ</span>) to diffraction behavior.</li>
            <li><b>Chart-based diffraction loss</b> is appropriate because the problem explicitly provides Fig. 11.2-11 for this cavity type and mode.</li>
            <li>We <b>do not</b> need to solve the full diffraction integral; the figure already encodes that physics.</li>
          </ul>

          <div class="callout">
            <div class="title"><span class="icon warn"></span>Assumptions</div>
            <ul>
              <li>Symmetric confocal resonator (mirror ROC equals spacing).</li>
              <li>Paraxial, steady-state resonator modes (Hermite–Gaussian family).</li>
              <li>Loss dominated by finite aperture diffraction/clipping (other losses neglected).</li>
              <li>The figure’s “loss per pass” is taken at face value for this cavity class.</li>
            </ul>
          </div>

          <h3>Possible approaches (pros/cons)</h3>
          <ul>
            <li><b>Approach A — Use the figure directly (best here):</b> read <span style="font-family:var(--mono)">N<sub>F</sub></span> at 1% for (1,0), then compute <span style="font-family:var(--mono)">a</span> via <span style="font-family:var(--mono)">a=√(N<sub>F</sub>λd)</span>. <b>Fast</b>, matches problem intent.</li>
            <li><b>Approach B — Numerical diffraction integral:</b> compute round-trip eigenmodes with finite aperture and extract clipping loss. <b>Accurate</b> but heavy; unnecessary because the figure already provides results.</li>
            <li><b>Approach C — Rough Gaussian tail estimate:</b> approximate power outside radius <span style="font-family:var(--mono)">a</span> using Gaussian integrals. <b>Quick intuition</b> but not as reliable for higher modes and confocal boundary conditions.</li>
          </ul>
          <p><b>We choose Approach A</b> because the problem explicitly supplies the loss-vs-<span style="font-family:var(--mono)">N<sub>F</sub></span> graph for this resonator and mode.</p>
        </section>

        <!-- PART 2 -->
        <section class="card" id="part2">
          <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>

          <ol style="margin:10px 0 0 18px">
            <li><b>Goal:</b> interpret the chart.<br>
              <span class="note"><b>Tool:</b> Fig. 11.2-11, select the (1,0) curve.</span></li>
            <li><b>Goal:</b> locate the horizontal level <span style="font-family:var(--mono)">L = 1%</span>.<br>
              <span class="note"><b>Tool:</b> semi-log y-axis; 1% is the decade tick at 1.</span></li>
            <li><b>Goal:</b> read the corresponding <span style="font-family:var(--mono)">N<sub>F</sub></span> where the (1,0) curve crosses 1%.<br>
              <span class="note"><b>Meaning:</b> this is the “required Fresnel number” for that mode at that loss.</span></li>
            <li><b>Goal:</b> compute mirror radius from the Fresnel number definition.<br>
              <span class="note"><b>Equation:</b> <span style="font-family:var(--mono)">a = √(N<sub>F</sub> λ d)</span>.</span></li>
            <li><b>Goal:</b> sanity-check units and scaling.<br>
              <span class="note"><b>Meaning:</b> radius must scale as √d and √λ for fixed loss (fixed <span style="font-family:var(--mono)">N<sub>F</sub></span>).</span></li>
          </ol>

          <div class="grid2" style="margin-top:14px">
            <div class="callout">
              <div class="title"><span class="icon warn"></span>Common mistakes</div>
              <ul>
                <li>Using aperture diameter <span style="font-family:var(--mono)">2a</span> instead of radius <span style="font-family:var(--mono)">a</span>.</li>
                <li>Mixing units (nm, cm) without converting to SI before computing <span style="font-family:var(--mono)">a</span>.</li>
                <li>Reading the wrong mode curve (0,0) instead of (1,0).</li>
                <li>Interpreting “per pass” as “per round trip.”</li>
              </ul>
            </div>
            <div class="callout">
              <div class="title"><span class="icon"></span>Quick tips</div>
              <ul>
                <li>Because <span style="font-family:var(--mono)">a = √(N<sub>F</sub> λ d)</span>, a 10% error in <span style="font-family:var(--mono)">N<sub>F</sub></span> only causes about a 5% error in <span style="font-family:var(--mono)">a</span>.</li>
                <li>Use the interactive plots below to avoid arithmetic slips and to visualize parameter sensitivity.</li>
              </ul>
            </div>
          </div>
        </section>

        <!-- Visualizations -->
        <section class="card" id="viz">
          <h2>Interactive Visualization</h2>
          <p class="note">
            The original textbook figure is a chart; here we build a smooth, editable model that matches its key readings and lets you plug in your <span style="font-family:var(--mono)">λ</span> and <span style="font-family:var(--mono)">d</span>.
            The default calibration uses the chart reading that the (1,0) mode reaches ~1% loss at <span style="font-family:var(--mono)">N<sub>F</sub>≈1.0</span>.
          </p>

          <div class="vizWrap">
            <div class="vizCard">
              <div class="vizTitle">
                <h3>Geometry diagram (confocal cavity)</h3>
                <span class="pill">canvas</span>
              </div>
              <canvas id="cavCanvas" aria-label="Confocal resonator diagram"></canvas>

              <div class="controls">
                <div class="ctrl">
                  <label>
                    <span>Mirror spacing <span style="font-family:var(--mono)">d</span> (cm)</span>
                    <span class="pill" id="dLbl">50.0</span>
                  </label>
                  <input id="dRange" type="range" min="5" max="200" step="0.5" value="50" />
                </div>
                <div class="ctrl">
                  <label>
                    <span>Wavelength <span style="font-family:var(--mono)">λ</span> (nm)</span>
                    <span class="pill" id="lamLbl">1064</span>
                  </label>
                  <input id="lamRange" type="range" min="400" max="2000" step="1" value="1064" />
                </div>

                <div class="ctrl">
                  <label>
                    <span>Mode (m,n)</span>
                    <span class="pill" id="modeLbl">(1,0)</span>
                  </label>
                  <select id="modeSel">
                    <option value="00">(0,0)</option>
                    <option value="10" selected>(1,0)</option>
                    <option value="20">(2,0)</option>
                  </select>
                </div>

                <div class="ctrl">
                  <label>
                    <span>Target loss per pass <span style="font-family:var(--mono)">L</span> (%)</span>
                    <span class="pill" id="lossLbl">1.00</span>
                  </label>
                  <input id="lossRange" type="range" min="0.1" max="30" step="0.1" value="1.0" />
                </div>
              </div>

              <div class="readout">
                <div class="metric">
                  <div class="k">Required Fresnel number</div>
                  <div class="v" id="nfOut">N_F = 1.00</div>
                </div>
                <div class="metric">
                  <div class="k">Mirror radius</div>
                  <div class="v" id="aOut">a = 0.00 mm</div>
                </div>
              </div>

              <div class="eq" id="eqBox">
                <div class="row">
                  <code id="eqText">N_F = a^2/(λ d)  ⇒  a = √(N_F λ d)</code>
                  <button class="copyBtn" data-copy-target="eqText">Copy equation</button>
                </div>
              </div>

              <div class="eq">
                <div class="row">
                  <code id="ansText">Answer (plug in λ and d from Prob. 11.2-11):  a = √(N_F(1%, mode) · λ · d)</code>
                  <button class="copyBtn" data-copy-target="ansText">Copy final form</button>
                </div>
              </div>
            </div>

            <div class="vizCard small">
              <div class="vizTitle">
                <h3>Main plot: Diffraction loss vs Fresnel number</h3>
                <span class="pill">semi-log style</span>
              </div>
              <canvas id="lossCanvas" aria-label="Loss versus Fresnel number plot"></canvas>

              <div class="vizTitle" style="margin-top:10px">
                <h3>Secondary plot: Required mirror radius vs cavity spacing</h3>
                <span class="pill">parameter sweep</span>
              </div>
              <canvas id="sweepCanvas" aria-label="Mirror radius versus spacing plot"></canvas>
            </div>
          </div>
        </section>

        <!-- PART 3 -->
        <section class="card" id="part3">
          <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

          <h3>Qualitative expectation (before calculating)</h3>
          <p>
            Diffraction loss decreases when the aperture is “large compared to diffraction spreading,” i.e., when <span style="font-family:var(--mono)">N<sub>F</sub></span> is larger.
            Therefore, to enforce a small loss like 1% for a higher-order mode (1,0), we expect to need a Fresnel number near unity (and thus an aperture radius on the order of √(λ d)).
          </p>

          <div class="callout">
            <div class="title"><span class="icon"></span>Step 1 — Read the Fresnel number from the chart</div>
            <p class="note">
              From Fig. 11.2-11, locate the (1,0) curve and find where it intersects the horizontal line at <b>Loss = 1%</b>.
              Reading the x-axis at that intersection gives approximately:
            </p>
            <div class="eq">
              <div class="row">
                <code id="nfEq">For mode (1,0) at 1% loss:  N_F ≈ 1.0  (about 0.97–1.05 depending on reading)</code>
                <button class="copyBtn" data-copy-target="nfEq">Copy</button>
              </div>
            </div>
            <p class="note">
              The interactive plot above uses a smooth model calibrated so that the (1,0) curve hits 1% at a default <span style="font-family:var(--mono)">N<sub>F</sub></span> close to 1.0.
            </p>
          </div>

          <div class="callout" style="margin-top:14px">
            <div class="title"><span class="icon"></span>Step 2 — Use the Fresnel number definition to solve for mirror radius</div>
            <p class="note">
              By definition (given in the problem statement):
            </p>
            <div class="eq">
              <div class="row">
                <code id="defEq">N_F = a^2/(λ d)</code>
                <button class="copyBtn" data-copy-target="defEq">Copy</button>
              </div>
            </div>
            <p class="note">Solve for <span style="font-family:var(--mono)">a</span> step-by-step:</p>
            <div class="eq">
              <div class="row">
                <code id="solveEq">a^2 = N_F λ d  ⇒  a = √(N_F λ d)</code>
                <button class="copyBtn" data-copy-target="solveEq">Copy</button>
              </div>
            </div>

            <p class="note">
              This is the key result: once you have <span style="font-family:var(--mono)">N<sub>F</sub></span> from the chart, the aperture radius follows immediately.
            </p>
          </div>

          <div class="callout" style="margin-top:14px">
            <div class="title"><span class="icon"></span>Step 3 — Insert the (1,0) 1% Fresnel number</div>
            <p class="note">
              Using <span style="font-family:var(--mono)">N<sub>F</sub> ≈ 1.0</span> for the (1,0) mode at 1% loss:
            </p>
            <div class="eq">
              <div class="row">
                <code id="finalEq">a ≈ √(λ d)</code>
                <button class="copyBtn" data-copy-target="finalEq">Copy</button>
              </div>
            </div>
            <p class="note">
              More precisely, if your chart reading is <span style="font-family:var(--mono)">N<sub>F</sub>=0.97</span>, then <span style="font-family:var(--mono)">a=√(0.97 λ d)</span>;
              if you read <span style="font-family:var(--mono)">N<sub>F</sub>=1.05</span>, then <span style="font-family:var(--mono)">a=√(1.05 λ d)</span>.
            </p>
          </div>

          <div class="callout" style="margin-top:14px">
            <div class="title"><span class="icon warn"></span>Sanity checks</div>
            <ul>
              <li><b>Units:</b> <span style="font-family:var(--mono)">λ d</span> has units m², so √(λ d) has units m → correct for a radius.</li>
              <li><b>Scaling:</b> if <span style="font-family:var(--mono)">d</span> increases by 4×, required <span style="font-family:var(--mono)">a</span> increases by √4 = 2× for the same loss and mode.</li>
              <li><b>Physical interpretation:</b> keeping <span style="font-family:var(--mono)">N<sub>F</sub></span> fixed means keeping aperture size comparable to diffraction spreading; that preserves the clipping fraction and thus the loss.</li>
            </ul>
          </div>

          <div class="callout" style="margin-top:14px">
            <div class="title"><span class="icon"></span>Connection to the diagram and plots</div>
            <p class="note">
              In the diagram, <span style="font-family:var(--mono)">d</span> is the mirror-to-mirror distance and <span style="font-family:var(--mono)">a</span> is the radius of the circular aperture.
              The main plot shows how the loss drops rapidly as <span style="font-family:var(--mono)">N<sub>F</sub></span> increases (larger aperture or shorter cavity).
              The secondary plot converts that requirement into a tangible design curve: required <span style="font-family:var(--mono)">a</span> versus <span style="font-family:var(--mono)">d</span>.
            </p>
          </div>

          <div class="callout" style="margin-top:14px">
            <div class="title"><span class="icon danger"></span>Final answer (boxed)</div>
            <div class="eq">
              <div class="row">
                <code id="boxedAns">For the (1,0) mode with 1% diffraction loss per pass:
Read N_F from Fig. 11.2-11 (≈1.0), then

a = √(N_F λ d)  ≈ √(λ d).</code>
                <button class="copyBtn" data-copy-target="boxedAns">Copy answer</button>
              </div>
            </div>
            <p class="note">
              Use your <span style="font-family:var(--mono)">λ</span> and <span style="font-family:var(--mono)">d</span> from Prob. 11.2-11. If you enter them into the interactive controls above, the computed <span style="font-family:var(--mono)">a</span> updates instantly.
            </p>
          </div>
        </section>

        <!-- PART 4 -->
        <section class="card" id="part4">
          <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

          <h3>Re-interpreting the final formula</h3>
          <p>
            The result
            <span style="font-family:var(--mono)">a = √(N<sub>F</sub> λ d)</span>
            says that the aperture radius required for a given loss level is controlled by three knobs:
          </p>
          <ul>
            <li><span style="font-family:var(--mono)">N<sub>F</sub></span>: set by the <b>mode</b> and the <b>allowed loss</b> (read from the chart).</li>
            <li><span style="font-family:var(--mono)">λ</span>: longer wavelength diffracts more → needs larger aperture (scales as √λ).</li>
            <li><span style="font-family:var(--mono)">d</span>: longer propagation distance allows more diffraction spreading → needs larger aperture (scales as √d).</li>
          </ul>

          <h3>How parameter changes affect the outcome (connect to the plots)</h3>
          <ul>
            <li>If you decrease the allowed loss (e.g., from 1% to 0.3%), the main plot forces you to a larger <span style="font-family:var(--mono)">N<sub>F</sub></span>, so <span style="font-family:var(--mono)">a</span> increases.</li>
            <li>Switching from (0,0) to (1,0) at the same loss increases the required <span style="font-family:var(--mono)">N<sub>F</sub></span> (higher-order modes are “harder to confine” in a finite aperture), so <span style="font-family:var(--mono)">a</span> increases.</li>
            <li>At fixed <span style="font-family:var(--mono)">N<sub>F</sub></span>, the secondary plot shows <span style="font-family:var(--mono)">a ∝ √d</span>, i.e., concave-down growth with spacing.</li>
          </ul>

          <h3>An alternative derivation idea (brief)</h3>
          <p class="note">
            Instead of using the chart, one can approximate diffraction loss by integrating the intensity of the mode outside the aperture:
            for a Gaussian-like profile, the fractional power outside radius <span style="font-family:var(--mono)">a</span> decays roughly like <span style="font-family:var(--mono)">exp(-2a²/w²)</span>.
            In a confocal cavity, the spot size <span style="font-family:var(--mono)">w</span> on the mirrors is tied to <span style="font-family:var(--mono)">λ</span> and <span style="font-family:var(--mono)">d</span>, so the loss naturally becomes a function of <span style="font-family:var(--mono)">a²/(λ d)</span>, i.e., the Fresnel number.
            The figure effectively provides the accurate constants for each mode.
          </p>

          <h3>Concept checks (quick self-test)</h3>
          <ul>
            <li><b>Q:</b> If you halve <span style="font-family:var(--mono)">λ</span> (same <span style="font-family:var(--mono)">d</span>, same loss target), what happens to required <span style="font-family:var(--mono)">a</span>?<br>
              <b>A:</b> It decreases by √(1/2) ≈ 0.707.</li>
            <li><b>Q:</b> Why do higher-order modes need larger apertures for the same loss?<br>
              <b>A:</b> They have broader transverse extent / more energy in the wings, so a finite aperture clips a larger fraction.</li>
            <li><b>Q:</b> What does “per pass” mean in this context?<br>
              <b>A:</b> One traversal between mirrors (half a round trip). A full round trip would pass the aperture twice (in a symmetric view).</li>
            <li><b>Q:</b> If you mistakenly used diameter <span style="font-family:var(--mono)">2a</span> in <span style="font-family:var(--mono)">N<sub>F</sub></span>, how wrong would <span style="font-family:var(--mono)">a</span> be?<br>
              <b>A:</b> You would overestimate <span style="font-family:var(--mono)">N<sub>F</sub></span> by 4× and thus overestimate <span style="font-family:var(--mono)">a</span> by 2×.</li>
          </ul>
        </section>

        <!-- PART 5 -->
        <section class="card" id="part5">
          <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

          <h3>What each canvas shows</h3>
          <ul>
            <li><b>Diagram (left):</b> two concave mirrors separated by <span style="font-family:var(--mono)">d</span>, with circular aperture radius <span style="font-family:var(--mono)">a</span>. This is the geometry used in <span style="font-family:var(--mono)">N<sub>F</sub>=a²/(λd)</span>.</li>
            <li><b>Main plot (top-right):</b> modeled diffraction loss per pass (%) vs Fresnel number for modes (0,0), (1,0), (2,0). A marker shows your chosen mode and target loss, and the corresponding required <span style="font-family:var(--mono)">N<sub>F</sub></span>.</li>
            <li><b>Secondary plot (bottom-right):</b> parameter sweep of required mirror radius <span style="font-family:var(--mono)">a</span> (mm) versus cavity spacing <span style="font-family:var(--mono)">d</span> (cm) for the current <span style="font-family:var(--mono)">λ</span>, mode, and loss target. A marker shows your current <span style="font-family:var(--mono)">d</span>.</li>
          </ul>

          <h3>Interactive controls</h3>
          <ul>
            <li><b><span style="font-family:var(--mono)">d</span> slider:</b> changes cavity length. Expect required <span style="font-family:var(--mono)">a</span> to grow like √d at fixed loss target (watch the sweep curve).</li>
            <li><b><span style="font-family:var(--mono)">λ</span> slider:</b> changes wavelength. Longer <span style="font-family:var(--mono)">λ</span> increases required <span style="font-family:var(--mono)">a</span> like √λ.</li>
            <li><b>Mode selector:</b> switches between (0,0), (1,0), (2,0). Higher order → higher required <span style="font-family:var(--mono)">N<sub>F</sub></span> and larger <span style="font-family:var(--mono)">a</span> for the same loss.</li>
            <li><b>Loss slider:</b> sets the target loss per pass. Smaller loss → larger required <span style="font-family:var(--mono)">N<sub>F</sub></span> → larger <span style="font-family:var(--mono)">a</span>.</li>
          </ul>

          <p class="note">
            Important: the plot curves are a smooth “teaching model” calibrated to the chart’s key reading around 1% for each mode. For design-grade work, read <span style="font-family:var(--mono)">N<sub>F</sub></span> directly from the textbook figure as precisely as you can.
          </p>

          <footer>
            Built as a self-contained learning page (vanilla HTML/CSS/JS). The interactive model is designed to mirror the qualitative behavior of Fig. 11.2-11 and to automate the final step <span style="font-family:var(--mono)">a = √(N<sub>F</sub>λd)</span>.
          </footer>
        </section>
      </article>
    </div>
  </main>

  <script>
    // -------------------------
    // Smooth scrolling for TOC
    // -------------------------
    document.querySelectorAll('[data-scroll]').forEach(a=>{
      a.addEventListener('click', (e)=>{
        e.preventDefault();
        const id = a.getAttribute('href');
        const el = document.querySelector(id);
        if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
      });
    });

    // -------------------------
    // Copy buttons
    // -------------------------
    function copyText(txt){
      navigator.clipboard.writeText(txt).then(()=>{
        // tiny feedback
      }).catch(()=>{
        // fallback
        const ta = document.createElement('textarea');
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        try{document.execCommand('copy');}catch(_){}
        ta.remove();
      });
    }
    document.querySelectorAll('.copyBtn').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const id = btn.getAttribute('data-copy-target');
        const el = document.getElementById(id);
        if(el) copyText(el.textContent.trim());
      });
    });

    // -------------------------
    // Numeric helpers
    // -------------------------
    const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
    const lerp = (a,b,t)=>a+(b-a)*t;

    // -------------------------
    // "Teaching model" for loss curves
    // We approximate each mode curve as:
    //   log10(L%) = A - B * N_F
    // Calibrated so that:
    //   L%(N_F = N1) = 1%
    //   L%(N_F = 0.5) = 100%
    // This matches the visual that curves approach ~100% near N_F ~0.5.
    // Then invert:
    //   N_F(L%) = (A - log10(L%))/B
    // -------------------------
    const modes = {
      "00": { label:"(0,0)", N1: 0.76 },
      "10": { label:"(1,0)", N1: 0.97 }, // approx chart read for 1% loss
      "20": { label:"(2,0)", N1: 1.20 }
    };

    function modelParamsForMode(modeKey){
      const N1 = modes[modeKey].N1;
      // Ensure N1 > 0.5 for positive slope
      const B = 2.0 / (N1 - 0.5);          // from 100% at 0.5 and 1% at N1
      const A = B * N1;                    // because log10(1%) = 0
      return {A,B};
    }
    function lossPct(modeKey, NF){
      const {A,B} = modelParamsForMode(modeKey);
      const logL = A - B*NF;
      const L = Math.pow(10, logL);
      return clamp(L, 0.03, 120); // keep in a visible range
    }
    function nfForLoss(modeKey, Lpct){
      const {A,B} = modelParamsForMode(modeKey);
      const logL = Math.log10(Lpct);
      return (A - logL)/B;
    }

    // -------------------------
    // Controls state
    // -------------------------
    const dRange = document.getElementById('dRange');
    const lamRange = document.getElementById('lamRange');
    const lossRange = document.getElementById('lossRange');
    const modeSel = document.getElementById('modeSel');
    const dLbl = document.getElementById('dLbl');
    const lamLbl = document.getElementById('lamLbl');
    const lossLbl = document.getElementById('lossLbl');
    const modeLbl = document.getElementById('modeLbl');

    const nfOut = document.getElementById('nfOut');
    const aOut = document.getElementById('aOut');

    function getState(){
      const d_cm = parseFloat(dRange.value);
      const lam_nm = parseFloat(lamRange.value);
      const Lpct = parseFloat(lossRange.value);
      const modeKey = modeSel.value;
      return { d_cm, lam_nm, Lpct, modeKey };
    }

    function computeOutputs(st){
      // Convert to SI
      const d = st.d_cm / 100.0;          // m
      const lam = st.lam_nm * 1e-9;       // m
      const NF = nfForLoss(st.modeKey, st.Lpct);
      const a = Math.sqrt(Math.max(0, NF) * lam * d); // m
      return { d, lam, NF, a };
    }

    // -------------------------
    // Canvas utilities (HiDPI)
    // -------------------------
    function setupCanvas(canvas){
      const ctx = canvas.getContext('2d');
      function resize(){
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.max(2, Math.floor(rect.width * dpr));
        canvas.height = Math.max(2, Math.floor(rect.height * dpr));
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
      return {ctx, resize};
    }

    const cav = setupCanvas(document.getElementById('cavCanvas'));
    const lossC = setupCanvas(document.getElementById('lossCanvas'));
    const sweepC = setupCanvas(document.getElementById('sweepCanvas'));

    // -------------------------
    // Drawing primitives
    // -------------------------
    function clear(ctx, w, h){
      ctx.clearRect(0,0,w,h);
    }

    function roundRect(ctx,x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    function drawGrid(ctx, plot, xTicks, yTicks){
      const {x0,y0,w,h} = plot;
      // gridlines
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,.10)';
      ctx.lineWidth = 1;
      // vertical
      xTicks.forEach(t=>{
        const x = x0 + t*w;
        ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+h); ctx.stroke();
      });
      // horizontal
      yTicks.forEach(t=>{
        const y = y0 + (1-t)*h;
        ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+w,y); ctx.stroke();
      });
      ctx.restore();
    }

    function axes(ctx, plot, xlabel, ylabel){
      const {x0,y0,w,h} = plot;
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,.35)';
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(x0,y0); ctx.lineTo(x0,y0+h);
      ctx.lineTo(x0+w,y0+h);
      ctx.stroke();

      ctx.fillStyle = 'rgba(233,238,252,.92)';
      ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;
      ctx.textAlign='center';
      ctx.fillText(xlabel, x0+w/2, y0+h+34);
      ctx.save();
      ctx.translate(x0-34, y0+h/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(ylabel, 0, 0);
      ctx.restore();
      ctx.restore();
    }

    function tickText(ctx, x, y, text, align='center'){
      ctx.save();
      ctx.fillStyle = 'rgba(185,195,230,.95)';
      ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;
      ctx.textAlign = align;
      ctx.textBaseline = 'middle';
      ctx.fillText(text, x, y);
      ctx.restore();
    }

    // -------------------------
    // Diagram canvas: confocal cavity
    // -------------------------
    function drawCavityDiagram(st, out){
      const canvas = document.getElementById('cavCanvas');
      const ctx = cav.ctx;
      const rect = canvas.getBoundingClientRect();
      const W = rect.width, H = rect.height;

      clear(ctx, W, H);

      // panel background
      ctx.save();
      roundRect(ctx, 10, 10, W-20, H-20, 16);
      ctx.fillStyle = 'rgba(0,0,0,.18)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.10)';
      ctx.stroke();
      ctx.restore();

      // draw mirrors and beam envelope
      const cx = W*0.52, cy = H*0.52;
      const L = W*0.62;
      const xL = cx - L/2, xR = cx + L/2;

      // beam envelope
      ctx.save();
      ctx.strokeStyle = 'rgba(126,230,255,.75)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      // hourglass envelope
      const waist = H*0.10;
      const edge = H*0.25;
      for(let i=0;i<=80;i++){
        const t = i/80;
        const x = lerp(xL+18, xR-18, t);
        // symmetric quadratic widening away from center
        const u = (t-0.5);
        const yTop = cy - (waist + (edge-waist)*(u*u*4));
        if(i===0) ctx.moveTo(x,yTop);
        else ctx.lineTo(x,yTop);
      }
      ctx.stroke();
      ctx.beginPath();
      for(let i=0;i<=80;i++){
        const t = i/80;
        const x = lerp(xL+18, xR-18, t);
        const u = (t-0.5);
        const yBot = cy + (waist + (edge-waist)*(u*u*4));
        if(i===0) ctx.moveTo(x,yBot);
        else ctx.lineTo(x,yBot);
      }
      ctx.stroke();
      ctx.restore();

      // mirrors (concave)
      function mirror(x, flip){
        ctx.save();
        ctx.strokeStyle = 'rgba(255,211,126,.85)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        const h = H*0.60;
        const y1 = cy - h/2, y2 = cy + h/2;
        // arc-like mirror
        const rx = 34;
        ctx.moveTo(x, y1);
        const cpx = x + (flip? -rx: rx);
        ctx.quadraticCurveTo(cpx, cy, x, y2);
        ctx.stroke();

        // aperture opening indicator (radius a)
        ctx.strokeStyle = 'rgba(255,255,255,.35)';
        ctx.lineWidth = 1.2;
        const aPix = clamp(out.a / (Math.sqrt(out.lam*out.d) + 1e-30), 0.3, 2.2) * (H*0.10); // visual scaling
        // vertical bracket representing 2a
        const bx = x + (flip? -20: 20);
        ctx.beginPath();
        ctx.moveTo(bx, cy - aPix);
        ctx.lineTo(bx, cy + aPix);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(bx-6, cy - aPix); ctx.lineTo(bx+6, cy - aPix);
        ctx.moveTo(bx-6, cy + aPix); ctx.lineTo(bx+6, cy + aPix);
        ctx.stroke();
        ctx.fillStyle='rgba(233,238,252,.92)';
        ctx.font='12px ' + getComputedStyle(document.body).fontFamily;
        ctx.textAlign='center';
        ctx.fillText('2a', bx, cy + aPix + 14);
        ctx.restore();
      }
      mirror(xL, true);
      mirror(xR, false);

      // distance d arrow
      ctx.save();
      const yArrow = cy + H*0.30;
      ctx.strokeStyle='rgba(255,255,255,.45)';
      ctx.lineWidth=1.3;
      ctx.beginPath();
      ctx.moveTo(xL+18, yArrow);
      ctx.lineTo(xR-18, yArrow);
      ctx.stroke();
      // arrowheads
      function head(x, dir){
        ctx.beginPath();
        ctx.moveTo(x, yArrow);
        ctx.lineTo(x + dir*10, yArrow-6);
        ctx.lineTo(x + dir*10, yArrow+6);
        ctx.closePath();
        ctx.fillStyle='rgba(255,255,255,.45)';
        ctx.fill();
      }
      head(xL+18, +1);
      head(xR-18, -1);

      ctx.fillStyle='rgba(233,238,252,.92)';
      ctx.font='13px ' + getComputedStyle(document.body).fontFamily;
      ctx.textAlign='center';
      ctx.fillText('d', (xL+xR)/2, yArrow-10);
      ctx.restore();

      // title tag
      ctx.save();
      ctx.fillStyle='rgba(185,195,230,.95)';
      ctx.font='12px ' + getComputedStyle(document.body).fontFamily;
      ctx.textAlign='left';
      ctx.fillText('Symmetric confocal resonator (R = d), finite mirror aperture radius a', 18, 30);
      ctx.restore();
    }

    // -------------------------
    // Main plot: loss vs Fresnel number
    // (y-axis is log scale in %)
    // -------------------------
    function drawLossPlot(st, out){
      const canvas = document.getElementById('lossCanvas');
      const ctx = lossC.ctx;
      const rect = canvas.getBoundingClientRect();
      const W = rect.width, H = rect.height;
      clear(ctx, W, H);

      // plot area
      const plot = {x0:54, y0:18, w: W-72, h: H-70};

      // background card
      ctx.save();
      roundRect(ctx, 10, 10, W-20, H-20, 16);
      ctx.fillStyle = 'rgba(0,0,0,.16)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.10)';
      ctx.stroke();
      ctx.restore();

      // grid
      // x ticks at 0.5..1.4 every 0.1 => draw major at 0.5,0.7,0.9,1.1,1.3,1.4
      const xMin = 0.5, xMax = 1.4;
      function xToT(x){ return (x-xMin)/(xMax-xMin); }
      // y log: 0.1 to 100 (%)
      const yMin = 0.1, yMax = 100;
      function yToT(y){
        const ly = Math.log10(y);
        const lmin = Math.log10(yMin), lmax = Math.log10(yMax);
        return (ly - lmin)/(lmax - lmin);
      }
      // grid ticks
      const xTicksVals = [0.5,0.7,0.9,1.1,1.3,1.4];
      const xTicks = xTicksVals.map(v=>xToT(v));
      const yTicksVals = [0.1,0.3,1,3,10,30,100];
      const yTicks = yTicksVals.map(v=>yToT(v));
      drawGrid(ctx, plot, xTicks, yTicks);

      // axes labels
      axes(ctx, plot, 'Fresnel number  N_F = a²/(λ d)  (dimensionless)', 'Loss per pass  L  (%)  [log scale]');

      // tick labels
      xTicksVals.forEach(v=>{
        const x = plot.x0 + xToT(v)*plot.w;
        tickText(ctx, x, plot.y0+plot.h+16, v.toFixed(v===1.4?1:1), 'center');
      });
      yTicksVals.forEach(v=>{
        const y = plot.y0 + (1-yToT(v))*plot.h;
        tickText(ctx, plot.x0-10, y, String(v), 'right');
      });

      // draw curves (monochrome for clarity; legend uses text)
      const modeKeys = ["00","10","20"];
      ctx.save();
      ctx.lineWidth = 2.2;

      function drawCurve(modeKey, dash=false){
        ctx.setLineDash(dash?[6,4]:[]);
        ctx.strokeStyle = 'rgba(233,238,252,' + (modeKey===st.modeKey?0.95:0.55) + ')';
        ctx.beginPath();
        let started=false;
        const Nsteps=220;
        for(let i=0;i<=Nsteps;i++){
          const NF = lerp(xMin, xMax, i/Nsteps);
          const L = lossPct(modeKey, NF);
          const xt = xToT(NF);
          const yt = yToT(L);
          const x = plot.x0 + xt*plot.w;
          const y = plot.y0 + (1-yt)*plot.h;
          if(!started){ ctx.moveTo(x,y); started=true; }
          else ctx.lineTo(x,y);
        }
        ctx.stroke();
      }

      drawCurve("00", true);
      drawCurve("10", false);
      drawCurve("20", true);
      ctx.restore();

      // legend
      ctx.save();
      ctx.fillStyle='rgba(233,238,252,.92)';
      ctx.font='12px ' + getComputedStyle(document.body).fontFamily;
      ctx.textAlign='left';
      const lx = plot.x0 + 8, ly = plot.y0 + 14;
      ctx.fillText('Mode curves (teaching model):', lx, ly);
      ctx.fillStyle='rgba(185,195,230,.95)';
      ctx.fillText('—  (1,0) highlighted when selected; dashed = (0,0) and (2,0)', lx, ly+16);
      ctx.restore();

      // target markers
      const NFreq = out.NF;
      const Ltarget = st.Lpct;
      const xM = plot.x0 + xToT(clamp(NFreq, xMin, xMax))*plot.w;
      const yM = plot.y0 + (1-yToT(clamp(Ltarget,yMin,yMax)))*plot.h;

      // horizontal & vertical guide lines
      ctx.save();
      ctx.strokeStyle='rgba(126,230,255,.35)';
      ctx.lineWidth=1.2;
      ctx.setLineDash([5,5]);
      ctx.beginPath();
      ctx.moveTo(plot.x0, yM); ctx.lineTo(plot.x0+plot.w, yM);
      ctx.moveTo(xM, plot.y0); ctx.lineTo(xM, plot.y0+plot.h);
      ctx.stroke();
      ctx.setLineDash([]);

      // marker
      ctx.fillStyle='rgba(126,230,255,.95)';
      ctx.beginPath();
      ctx.arc(xM, yM, 4.5, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,.55)';
      ctx.lineWidth=1;
      ctx.stroke();

      // label box
      const txt = `target: L=${Ltarget.toFixed(2)}%  →  N_F=${NFreq.toFixed(3)}`;
      ctx.font='12px ' + getComputedStyle(document.body).fontFamily;
      const tw = ctx.measureText(txt).width;
      const bx = clamp(xM + 10, plot.x0+6, plot.x0+plot.w - tw - 18);
      const by = clamp(yM - 22, plot.y0+16, plot.y0+plot.h - 18);
      roundRect(ctx, bx-6, by-14, tw+12, 22, 10);
      ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,.14)'; ctx.stroke();
      ctx.fillStyle='rgba(233,238,252,.92)';
      ctx.textAlign='left';
      ctx.textBaseline='middle';
      ctx.fillText(txt, bx, by-3);
      ctx.restore();

      // title
      ctx.save();
      ctx.fillStyle='rgba(185,195,230,.95)';
      ctx.font='12px ' + getComputedStyle(document.body).fontFamily;
      ctx.textAlign='left';
      ctx.fillText('Mode-dependent diffraction loss per pass vs Fresnel number (modeled from Fig. 11.2-11)', 16, 18);
      ctx.restore();
    }

    // -------------------------
    // Secondary plot: required a vs d sweep
    // -------------------------
    function drawSweep(st, out){
      const canvas = document.getElementById('sweepCanvas');
      const ctx = sweepC.ctx;
      const rect = canvas.getBoundingClientRect();
      const W = rect.width, H = rect.height;
      clear(ctx, W, H);

      const plot = {x0:54, y0:18, w: W-72, h: H-70};

      // background
      ctx.save();
      roundRect(ctx, 10, 10, W-20, H-20, 16);
      ctx.fillStyle = 'rgba(0,0,0,.16)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.10)';
      ctx.stroke();
      ctx.restore();

      // sweep ranges
      const dMin = 5, dMax = 200; // cm
      const lam = out.lam;        // m
      const NF = out.NF;

      // y range auto: compute a(mm) over range
      function aForDcm(dcm){
        const d = dcm/100.0;
        return Math.sqrt(Math.max(0,NF)*lam*d) * 1e3; // mm
      }
      const yVals = [aForDcm(dMin), aForDcm(dMax)];
      const yMin = 0, yMax = Math.max(0.1, Math.max(...yVals))*1.15;

      function xToT(dcm){ return (dcm-dMin)/(dMax-dMin); }
      function yToT(amm){ return (amm-yMin)/(yMax-yMin); }

      // grid
      const xTicksVals = [5,25,50,100,150,200];
      const yTicksVals = [];
      const nY=5;
      for(let i=0;i<=nY;i++) yTicksVals.push(yMin + (yMax-yMin)*i/nY);

      drawGrid(ctx, plot, xTicksVals.map(v=>xToT(v)), yTicksVals.map(v=>yToT(v)));

      // axes
      axes(ctx, plot, 'Mirror spacing d (cm)', 'Required mirror radius a (mm)');

      // tick labels
      xTicksVals.forEach(v=>{
        const x = plot.x0 + xToT(v)*plot.w;
        tickText(ctx, x, plot.y0+plot.h+16, String(v), 'center');
      });
      yTicksVals.forEach(v=>{
        const y = plot.y0 + (1-yToT(v))*plot.h;
        tickText(ctx, plot.x0-10, y, v.toFixed(2), 'right');
      });

      // curve
      ctx.save();
      ctx.strokeStyle='rgba(233,238,252,.78)';
      ctx.lineWidth=2.2;
      ctx.beginPath();
      let started=false;
      const N=240;
      for(let i=0;i<=N;i++){
        const dcm = lerp(dMin, dMax, i/N);
        const amm = aForDcm(dcm);
        const x = plot.x0 + xToT(dcm)*plot.w;
        const y = plot.y0 + (1-yToT(amm))*plot.h;
        if(!started){ ctx.moveTo(x,y); started=true; }
        else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();

      // marker at current d
      const xM = plot.x0 + xToT(st.d_cm)*plot.w;
      const aMm = out.a*1e3;
      const yM = plot.y0 + (1-yToT(aMm))*plot.h;

      ctx.save();
      ctx.strokeStyle='rgba(167,255,159,.35)';
      ctx.lineWidth=1.2;
      ctx.setLineDash([5,5]);
      ctx.beginPath();
      ctx.moveTo(xM, plot.y0); ctx.lineTo(xM, plot.y0+plot.h);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle='rgba(167,255,159,.95)';
      ctx.beginPath();
      ctx.arc(xM, yM, 4.5, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,.55)';
      ctx.stroke();

      // label
      const txt = `d=${st.d_cm.toFixed(1)} cm  →  a=${aMm.toFixed(3)} mm`;
      ctx.font='12px ' + getComputedStyle(document.body).fontFamily;
      const tw = ctx.measureText(txt).width;
      const bx = clamp(xM + 10, plot.x0+6, plot.x0+plot.w - tw - 18);
      const by = clamp(yM - 22, plot.y0+16, plot.y0+plot.h - 18);
      roundRect(ctx, bx-6, by-14, tw+12, 22, 10);
      ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,.14)'; ctx.stroke();
      ctx.fillStyle='rgba(233,238,252,.92)';
      ctx.textAlign='left';
      ctx.textBaseline='middle';
      ctx.fillText(txt, bx, by-3);
      ctx.restore();

      // title
      ctx.save();
      ctx.fillStyle='rgba(185,195,230,.95)';
      ctx.font='12px ' + getComputedStyle(document.body).fontFamily;
      ctx.textAlign='left';
      ctx.fillText('Parameter sweep: required a vs d for current λ, mode, and loss target', 16, 18);
      ctx.restore();
    }

    // -------------------------
    // Update loop
    // -------------------------
    function update(){
      const st = getState();
      const out = computeOutputs(st);

      // labels
      dLbl.textContent = st.d_cm.toFixed(1);
      lamLbl.textContent = String(Math.round(st.lam_nm));
      lossLbl.textContent = st.Lpct.toFixed(2);
      modeLbl.textContent = modes[st.modeKey].label;

      nfOut.textContent = `N_F = ${out.NF.toFixed(3)}`;
      aOut.textContent = `a = ${(out.a*1e3).toFixed(3)} mm   (${(out.a*1e3*2).toFixed(3)} mm diameter)`;

      // redraw
      drawCavityDiagram(st, out);
      drawLossPlot(st, out);
      drawSweep(st, out);
    }

    function resizeAll(){
      cav.resize(); lossC.resize(); sweepC.resize();
      update();
    }

    // Events
    [dRange, lamRange, lossRange, modeSel].forEach(el=>{
      el.addEventListener('input', update);
      el.addEventListener('change', update);
    });
    window.addEventListener('resize', resizeAll);

    // Init
    resizeAll();
  </script>
</body>
</html>
