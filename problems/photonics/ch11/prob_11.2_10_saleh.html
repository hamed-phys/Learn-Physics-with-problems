<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Gaussian-Beam Standing Waves & Resonance Frequencies (Gouy Phase)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --ink:#eaf0ff;
      --muted:#b9c6ffcc;
      --line:#2a3a77;
      --accent:#7cf0ff;
      --accent2:#a7ff9e;
      --warn:#ffd27c;
      --danger:#ff7ca8;
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius: 18px;
      --radius2: 24px;
      --max: 1100px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1200px 800px at 18% 10%, rgba(124,240,255,.18), transparent 55%),
        radial-gradient(1000px 700px at 80% 20%, rgba(167,255,158,.10), transparent 60%),
        radial-gradient(900px 600px at 55% 85%, rgba(255,124,168,.10), transparent 60%),
        linear-gradient(180deg, #070a14 0%, #0b1020 35%, #070a14 100%);
      line-height:1.55;
    }

    header{
      padding: 34px 18px 22px;
    }
    .wrap{max-width:var(--max); margin:0 auto;}
    .hero{
      background: linear-gradient(135deg, rgba(17,26,51,.85), rgba(10,14,30,.6));
      border:1px solid rgba(124,240,255,.18);
      border-radius: var(--radius2);
      padding: 22px 20px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .hero:before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(700px 220px at 20% 0%, rgba(124,240,255,.18), transparent 60%),
        radial-gradient(700px 220px at 80% 0%, rgba(167,255,158,.12), transparent 60%);
      pointer-events:none;
      filter: blur(0px);
    }
    .hero > *{position:relative}
    h1{
      margin:0 0 6px;
      font-size: clamp(1.45rem, 2.3vw, 2.05rem);
      letter-spacing:.2px;
    }
    .sub{
      margin:0;
      color:var(--muted);
      max-width: 75ch;
      font-size: 1.02rem;
    }

    main{
      padding: 10px 18px 50px;
    }

    .grid{
      display:grid;
      grid-template-columns: 290px 1fr;
      gap: 16px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr;}
    }

    nav.toc{
      position: sticky;
      top: 14px;
      background: rgba(17,26,51,.74);
      border:1px solid rgba(124,240,255,.16);
      border-radius: var(--radius);
      padding: 14px 14px 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      backdrop-filter: blur(10px);
    }
    nav.toc h2{
      font-size:.98rem;
      margin:0 0 8px;
      letter-spacing:.3px;
      color:#dfe8ff;
    }
    nav.toc a{
      display:block;
      padding: 7px 10px;
      margin: 4px 0;
      border-radius: 12px;
      text-decoration:none;
      color: var(--muted);
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:.95rem;
    }
    nav.toc a:hover{
      background: rgba(124,240,255,.10);
      border-color: rgba(124,240,255,.22);
      transform: translateY(-1px);
      color:#eef5ff;
    }

    section{
      background: rgba(17,26,51,.70);
      border:1px solid rgba(124,240,255,.14);
      border-radius: var(--radius2);
      padding: 18px 18px 16px;
      box-shadow: 0 10px 28px rgba(0,0,0,.22);
      backdrop-filter: blur(10px);
      margin-bottom: 16px;
    }

    h2{
      margin: 0 0 8px;
      font-size: 1.25rem;
    }
    h3{
      margin: 14px 0 8px;
      font-size: 1.08rem;
      color:#e9f3ff;
    }
    p{margin:8px 0; color:#eaf0ff;}
    ul{margin:8px 0 8px 22px;}
    li{margin:6px 0; color:#eaf0ff;}
    .muted{color:var(--muted)}
    .small{font-size:.95rem}
    .kicker{
      display:inline-flex;
      align-items:center;
      gap:10px;
      color: #d6e3ff;
      font-weight:600;
      letter-spacing:.2px;
      margin-bottom: 8px;
    }
    .badge{
      font-family: var(--mono);
      font-size:.82rem;
      color:#051022;
      background: linear-gradient(135deg, rgba(124,240,255,1), rgba(167,255,158,1));
      padding: 3px 8px;
      border-radius: 999px;
      box-shadow: 0 10px 22px rgba(0,0,0,.28);
    }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    @media (max-width: 820px){
      .callouts{grid-template-columns: 1fr;}
    }
    .box{
      border-radius: 18px;
      padding: 12px 12px 10px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(8,12,26,.35);
    }
    .box h4{
      margin:0 0 6px;
      font-size: .98rem;
      letter-spacing:.2px;
    }
    .box.assumptions{border-color: rgba(167,255,158,.26)}
    .box.keyeq{border-color: rgba(124,240,255,.28)}
    .box.mistakes{border-color: rgba(255,210,124,.28)}
    .box.final{border-color: rgba(255,124,168,.28)}
    .box .eqline{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      margin: 8px 0 0;
      padding-top: 8px;
      border-top:1px dashed rgba(255,255,255,.12);
    }

    .eq{
      font-family: var(--mono);
      font-size: .95rem;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 10px 10px;
      overflow:auto;
      white-space: nowrap;
    }
    .eq b{color: var(--accent)}
    .copyBtn{
      flex:0 0 auto;
      border:none;
      border-radius: 12px;
      padding: 8px 10px;
      cursor:pointer;
      background: rgba(124,240,255,.18);
      color:#eef7ff;
      border:1px solid rgba(124,240,255,.28);
      transition: transform .12s ease, background .12s ease;
      font-size:.9rem;
      user-select:none;
    }
    .copyBtn:hover{transform: translateY(-1px); background: rgba(124,240,255,.24)}
    .copyBtn:active{transform: translateY(0px)}
    .copyNote{
      font-size:.88rem;
      color: var(--muted);
      margin-left: 6px;
      opacity:0;
      transform: translateY(2px);
      transition: opacity .18s ease, transform .18s ease;
    }
    .copyNote.show{opacity:1; transform: translateY(0px)}
    .hr{
      height:1px; background: rgba(255,255,255,.10);
      margin: 12px 0;
    }

    figure{
      margin: 10px 0 0;
      border-radius: 18px;
      padding: 12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(8,12,26,.35);
    }
    figcaption{
      margin-top: 10px;
      color: var(--muted);
      font-size: .92rem;
    }

    .vizGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    @media (max-width: 980px){
      .vizGrid{grid-template-columns: 1fr;}
    }
    canvas{
      width: 100%;
      height: 320px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(4,6,14,.55);
      display:block;
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px 12px;
      margin-top: 10px;
    }
    @media (max-width: 820px){
      .controls{grid-template-columns: 1fr;}
    }
    .control{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(8,12,26,.35);
      padding: 10px 12px;
    }
    .control label{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap: 10px;
      color:#dfe8ff;
      font-size: .95rem;
      margin-bottom: 6px;
    }
    .control .val{
      font-family: var(--mono);
      color: var(--accent2);
      font-size: .92rem;
      white-space:nowrap;
    }
    input[type="range"]{
      width: 100%;
    }
    select{
      width:100%;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      color: #eaf0ff;
      outline:none;
    }
    .pillRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top: 8px;
    }
    .pill{
      font-family: var(--mono);
      font-size: .88rem;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      color: #dce7ff;
    }
    .pulse{
      animation: pulse 2.6s ease-in-out infinite;
    }
    @keyframes pulse{
      0%,100%{filter: drop-shadow(0 0 0 rgba(124,240,255,0))}
      50%{filter: drop-shadow(0 0 10px rgba(124,240,255,.25))}
    }

    footer{
      padding: 18px 18px 30px;
      color: var(--muted);
    }
    .printHint{
      margin-top: 8px;
      font-size:.9rem;
      color: var(--muted);
    }
    @media print{
      body{background:#fff; color:#000}
      nav.toc{display:none}
      section, .hero{box-shadow:none; backdrop-filter:none}
      canvas{border:1px solid #999; background:#fff}
      .copyBtn, .copyNote{display:none}
      .pill{border-color:#bbb; color:#111; background:#fff}
    }
  </style>
</head>

<body>
<header>
  <div class="wrap">
    <div class="hero">
      <div class="kicker"><span class="badge">11.2–10</span><span>Gaussian-Beam Standing Waves in a Resonator</span></div>
      <h1>Two Counterpropagating Gaussian Beams → Standing Wave, and the Resonance Frequencies (with Gouy Phase)</h1>
      <p class="sub">
        We add two identical paraxial Gaussian beams traveling in +z and −z, show the sum becomes a standing wave,
        then enforce ideal-mirror boundary conditions placed on Gaussian wavefronts to derive the allowed resonant frequencies.
      </p>
    </div>
  </div>
</header>

<main>
  <div class="wrap grid">
    <nav class="toc" aria-label="Table of contents">
      <h2>On this page</h2>
      <a href="#quick">Quick Summary</a>
      <a href="#part0">PART 0 — Concept Primer</a>
      <a href="#part1">PART 1 — Problem Analysis</a>
      <a href="#part2">PART 2 — Strategy & Tips</a>
      <a href="#part3">PART 3 — Full Solution</a>
      <a href="#part4">PART 4 — Deeper Understanding</a>
      <a href="#part5">PART 5 — Visualization Guide</a>
      <a href="#viz">Interactive Visualizations</a>
    </nav>

    <article>
      <!-- Quick Summary -->
      <section id="quick">
        <h2>Quick Summary</h2>
        <ul>
          <li><b>What this is:</b> Add two identical Gaussian beams propagating in opposite directions inside a cavity.</li>
          <li><b>Key physics idea:</b> Counterpropagating waves of the same frequency interfere to form a <b>standing wave</b> in z; for Gaussian beams the axial phase includes the <b>Gouy phase</b> ζ(z).</li>
          <li><b>Governing field form (paraxial Gaussian):</b> complex field ∝ exp[i(kz + k r²/(2R(z)) − ζ(z))].</li>
          <li><b>Standing-wave result:</b> the sum becomes ∝ cos(kz − ζ(z)) (times the transverse Gaussian envelope).</li>
          <li><b>Boundary condition used:</b> perfect mirrors placed on Gaussian <b>wavefronts</b> ⇒ phase is uniform across each mirror, so a <b>1D axial phase condition</b> suffices.</li>
          <li><b>Resonance condition:</b> <span class="eq">k d − Δζ = qπ</span>, where <span class="eq">d</span> is mirror separation and <span class="eq">Δζ = ζ(z₂) − ζ(z₁)</span>.</li>
          <li><b>Final frequency formula (fundamental Gaussian mode):</b> <span class="eq"><b>ν<sub>q</sub> = (c/2d) ( q + Δζ/π )</b></span> (symbolic).</li>
          <li><b>Mode spacing:</b> adjacent longitudinal modes are separated by <span class="eq">ν<sub>F</sub> = c/(2d)</span> (same as a planar Fabry–Perot), but with a Gouy-phase offset.</li>
        </ul>

        <div class="callouts">
          <div class="box keyeq">
            <h4>Key Equation (copy-ready)</h4>
            <div class="eqline">
              <div class="eq" data-copy="k d − Δζ = q π&#10;with k = 2πν/c, Δζ = ζ(z2) − ζ(z1)">
                <b>k d − Δζ = q π</b><br/>
                with k = 2πν/c, Δζ = ζ(z₂) − ζ(z₁)
              </div>
              <div>
                <button class="copyBtn" data-copy-target="prev">Copy</button>
                <span class="copyNote">Copied!</span>
              </div>
            </div>
          </div>

          <div class="box final">
            <h4>Final Result (copy-ready)</h4>
            <div class="eqline">
              <div class="eq" data-copy="ν_q = (c/(2d)) * ( q + Δζ/π ) = q ν_F + (Δζ/π) ν_F&#10;where ν_F = c/(2d)">
                <b>ν<sub>q</sub> = (c/2d)( q + Δζ/π )</b><br/>
                = q ν<sub>F</sub> + (Δζ/π) ν<sub>F</sub>, &nbsp;ν<sub>F</sub>=c/(2d)
              </div>
              <div>
                <button class="copyBtn" data-copy-target="prev">Copy</button>
                <span class="copyNote">Copied!</span>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- PART 0 -->
      <section id="part0">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <h3>Core definitions (symbols, meaning, units)</h3>
        <ul>
          <li><b>Gaussian beam</b> (paraxial solution of the Helmholtz equation): a beam whose transverse intensity is Gaussian and whose wavefront curvature evolves with z.</li>
          <li><b>Wavenumber</b> <span class="eq">k = 2π/λ = 2πν/c</span> (units: rad/m).</li>
          <li><b>Beam radius</b> <span class="eq">w(z)</span> (units: m): radius where intensity drops to 1/e² of on-axis value.</li>
          <li><b>Radius of curvature</b> <span class="eq">R(z)</span> (units: m): curvature of the phase front.</li>
          <li><b>Rayleigh range</b> <span class="eq">z<sub>R</sub> = π w<sub>0</sub><sup>2</sup>/λ</span> (units: m): distance over which beam area roughly doubles.</li>
          <li><b>Gouy phase</b> <span class="eq">ζ(z) = arctan((z − z₀)/z<sub>R</sub>)</span> (units: rad): extra phase shift of focused beams relative to plane waves.</li>
          <li><b>Free spectral range</b> <span class="eq">ν<sub>F</sub> = c/(2d)</span> (units: Hz): longitudinal mode spacing for a length-d two-mirror cavity.</li>
        </ul>

        <h3>Physical meaning (what these quantities represent)</h3>
        <ul>
          <li><span class="eq">w(z)</span> tells you how the beam spreads; focusing (small <span class="eq">w₀</span>) implies a short <span class="eq">z<sub>R</sub></span>.</li>
          <li><span class="eq">R(z)</span> tells you the wavefront shape: near the waist the wavefront is nearly flat (large <span class="eq">R</span>), far away it becomes spherical.</li>
          <li><span class="eq">ζ(z)</span> is the “phase anomaly” acquired as the beam passes through focus; it matters in resonators because resonance requires the field to reproduce itself after a round trip.</li>
        </ul>

        <h3>Key principles and validity conditions</h3>
        <div class="box assumptions">
          <h4>When this theory is valid</h4>
          <ul class="small">
            <li><b>Paraxial approximation:</b> beam angles are small, transverse variation is slow compared with λ.</li>
            <li><b>Linear optics:</b> superposition applies (fields add).</li>
            <li><b>Ideal mirrors:</b> reflection introduces a fixed phase (often π for E at a perfect conductor), and here mirrors are assumed to coincide with Gaussian wavefronts (so phase is constant across the mirror).</li>
            <li><b>Single-frequency steady state:</b> we look for stationary cavity eigenfrequencies.</li>
          </ul>
        </div>

        <h3>Common models/approximations and why we use them</h3>
        <ul>
          <li><b>Complex field representation:</b> write <span class="eq">E(r,z,t) = Re{U(r,z) e^{-iωt}}</span>. It simplifies interference: a standing wave comes from adding complex exponentials.</li>
          <li><b>On-axis phase accounting:</b> if mirrors match wavefronts, transverse phase is automatically satisfied; resonance reduces to an axial phase condition involving <span class="eq">k</span> and <span class="eq">ζ</span>.</li>
        </ul>

        <h3>Mini intuition examples</h3>
        <ul>
          <li><b>Plane waves:</b> <span class="eq">e^{ikz}+e^{-ikz}=2cos(kz)</span> → pure standing wave, nodes fixed in space.</li>
          <li><b>Focused beams:</b> the axial phase is <i>not</i> just <span class="eq">kz</span>; a Gouy shift <span class="eq">ζ(z)</span> effectively “slides” the standing-wave phase relative to a plane-wave cavity, shifting resonance frequencies.</li>
        </ul>

        <h3>What to watch for (pitfalls)</h3>
        <div class="box mistakes">
          <h4>Typical pitfalls</h4>
          <ul class="small">
            <li>Forgetting the Gouy phase and concluding the cavity behaves exactly like a plane-wave Fabry–Perot.</li>
            <li>Mixing sign conventions for the backward beam (use a consistent complex representation).</li>
            <li>Imposing a 1D boundary condition on a curved mirror without ensuring the mirror is on a wavefront (otherwise transverse phase mismatch matters).</li>
            <li>Confusing <span class="eq">d</span> (mirror separation) with the round-trip length (which is <span class="eq">2d</span>).</li>
          </ul>
        </div>
      </section>

      <!-- PART 1 -->
      <section id="part1">
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

        <h3>Restate the problem in clear words</h3>
        <p>
          Two identical Gaussian beams propagate in opposite directions (+z and −z). You must:
          (1) show their sum forms a standing wave (spatially stationary interference along z), and
          (2) place two ideal mirrors so each lies on a Gaussian wavefront, then use boundary conditions to find
          the resonant frequencies (the frequencies that “fit” the cavity).
        </p>

        <h3>Given quantities</h3>
        <ul>
          <li>Two <b>identical</b> Gaussian beams (same ω, same waist parameters, same amplitude).</li>
          <li>Propagation directions: one along +z, one along −z.</li>
          <li>Two ideal mirrors at axial positions <span class="eq">z=z₁</span> and <span class="eq">z=z₂</span> that coincide with the beam wavefronts.</li>
        </ul>

        <h3>Unknowns</h3>
        <ul>
          <li>Show explicitly the total field is a <b>standing wave</b>.</li>
          <li>Find the <b>allowed resonance frequencies</b> <span class="eq">ν_q</span> (longitudinal index q).</li>
        </ul>

        <h3>What must be proved/found</h3>
        <ul>
          <li>Interference result: total field can be written with a cos(…) dependence in z (time-harmonic standing wave).</li>
          <li>Resonance condition including Gouy phase:
            <span class="eq">ν_q = (c/2d)(q + Δζ/π)</span>, matching the stated form.</li>
        </ul>

        <h3>Relevant physical principles (and why they apply)</h3>
        <ul>
          <li><b>Superposition:</b> fields add linearly in free space/linear media → total field is sum of the two beams.</li>
          <li><b>Paraxial Gaussian beam phase structure:</b> includes plane-wave phase ±kz, curvature term k r²/(2R), and Gouy phase ζ(z).</li>
          <li><b>Ideal-mirror boundary condition:</b> on a perfect conductor, the tangential electric field must vanish at the surface; if the mirror is on a wavefront, enforcing the condition on the on-axis phase is sufficient for resonance.</li>
        </ul>

        <h3>Assumptions</h3>
        <div class="box assumptions">
          <ul class="small">
            <li>Paraxial Gaussian beam description is valid (small divergence angles).</li>
            <li>Mirrors are placed exactly on wavefronts so the transverse phase is constant across each mirror.</li>
            <li>Lossless, ideal reflections; steady-state resonator modes exist.</li>
            <li>We derive the longitudinal resonance for the <b>fundamental Gaussian mode</b>; we’ll note the higher-order extension later.</li>
          </ul>
        </div>

        <h3>Possible approaches (compare)</h3>
        <ul>
          <li><b>Approach A: Add the two complex fields directly</b> and use the identity
            <span class="eq">e^{iθ}+e^{-iθ}=2cosθ</span> to show a standing wave. Then apply phase quantization between mirrors.
            <span class="muted">(Fast, transparent, best here.)</span>
          </li>
          <li><b>Approach B: Round-trip self-consistency</b> for one traveling wave: require the field reproduce after 2d including Gouy phase accumulation.
            <span class="muted">(Very common in resonator theory; equivalent to A.)</span>
          </li>
          <li><b>Approach C: Start from cavity eigenmodes</b> (Hermite–Gaussian/Laguerre–Gaussian) and apply boundary conditions.
            <span class="muted">(More general, but heavier than needed for this prompt.)</span>
          </li>
        </ul>

        <p><b>We choose Approach A</b> because it simultaneously shows the standing-wave nature and produces the resonance condition with minimal overhead.</p>
      </section>

      <!-- PART 2 -->
      <section id="part2">
        <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

        <ol>
          <li>
            <b>Write the forward Gaussian beam complex field</b>
            <span class="muted">(goal: expose the phase terms kz, curvature, and Gouy ζ)</span>.
            Tool: standard paraxial Gaussian solution.
            Physical meaning: separates “carrier phase” from “envelope”.
          </li>
          <li>
            <b>Write the backward-propagating identical beam</b>
            by reversing the propagation direction consistently.
            Tool: replace kz → −kz while keeping the same transverse profile at the same z.
            Physical meaning: same beam shape, opposite axial phase progression.
          </li>
          <li>
            <b>Add the two fields</b> and factor common terms.
            Tool: Euler identity → convert sum of exponentials into cosine.
            Physical meaning: standing-wave interference along z.
          </li>
          <li>
            <b>Impose boundary conditions at the mirrors</b> placed on wavefronts.
            Tool: mirror surfaces have constant phase across aperture → enforce a 1D phase condition.
            Physical meaning: cavity “fits” an integer number of half-wavelengths, corrected by Gouy phase.
          </li>
          <li>
            <b>Extract the resonance condition</b> in terms of k, d, and Δζ.
            Tool: difference of phase arguments at z₂ and z₁.
            Physical meaning: quantization of axial phase advance between mirrors.
          </li>
          <li>
            <b>Convert k to frequency ν</b> using k = 2πν/c.
            Physical meaning: discrete resonant frequencies and the free spectral range.
          </li>
          <li>
            <b>Sanity-check</b> dimensions and limiting cases (Δζ→0 plane wave).
          </li>
        </ol>

        <div class="box mistakes">
          <h4>Common mistakes & quick tips</h4>
          <ul class="small">
            <li><b>Tip:</b> keep the time factor <span class="eq">e^{-iωt}</span> common to both beams; “standing wave” refers to spatial dependence, not absence of time oscillation.</li>
            <li><b>Mistake:</b> using round-trip phase = 2πq but forgetting that the standing-wave boundary between two mirrors gives a πq condition over one pass (equivalently 2πq over a round trip).</li>
            <li><b>Tip:</b> define <span class="eq">Δζ = ζ(z₂) − ζ(z₁)</span> early; it keeps the algebra clean.</li>
          </ul>
        </div>
      </section>

      <!-- PART 3 -->
      <section id="part3">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Physical intuition first</h3>
        <p>
          If two waves of the same frequency travel in opposite directions, they interfere to produce a standing pattern:
          nodes and antinodes fixed in space. For Gaussian beams, the transverse shape is a Gaussian envelope, but the
          key new feature is that the axial phase is not exactly kz; it is kz <i>minus</i> the Gouy phase ζ(z).
          That small-looking correction shifts where nodes occur and therefore shifts the resonance frequencies.
        </p>

        <div class="hr"></div>

        <h3>Step 1 — Write the forward (+z) Gaussian beam field</h3>
        <p>
          We use the standard paraxial (scalar) Gaussian beam complex amplitude for the fundamental mode.
          Let <span class="eq">r</span> be the transverse radius from the axis, and assume time dependence <span class="eq">e^{-iωt}</span>.
        </p>

        <div class="box keyeq">
          <h4>Forward beam (fundamental Gaussian)</h4>
          <div class="eqline">
            <div class="eq" data-copy="E_+(r,z,t)=Re{ E0 * (w0/w(z)) * exp(-r^2/w(z)^2) * exp[i(kz + k r^2/(2R(z)) - ζ(z))] * exp(-iωt) }">
              <b>E</b><sub>+</sub>(r,z,t)=Re{ E<sub>0</sub> (w<sub>0</sub>/w(z)) exp(−r²/w(z)²)
              exp[i(kz + k r²/(2R(z)) − ζ(z))] e<sup>−iωt</sup> }
            </div>
            <div>
              <button class="copyBtn" data-copy-target="prev">Copy</button>
              <span class="copyNote">Copied!</span>
            </div>
          </div>
          <p class="muted small">
            Here <span class="eq">w(z)</span> is the spot size, <span class="eq">R(z)</span> the wavefront curvature, and <span class="eq">ζ(z)</span> the Gouy phase.
            The exact forms of w and R won’t be needed to derive the resonance condition—only that ζ depends on z.
          </p>
        </div>

        <h3>Step 2 — Write the backward (−z) beam field</h3>
        <p>
          The backward-propagating beam has the <i>same envelope</i> at each z (identical beam), but the axial phase progresses as −kz.
          A consistent way is to write:
        </p>

        <div class="box keyeq">
          <h4>Backward beam (same envelope, opposite axial propagation)</h4>
          <div class="eqline">
            <div class="eq" data-copy="E_-(r,z,t)=Re{ E0 * (w0/w(z)) * exp(-r^2/w(z)^2) * exp[-i(kz - ζ(z))] * exp[i k r^2/(2R(z))] * exp(-iωt) }">
              <b>E</b><sub>−</sub>(r,z,t)=Re{ E<sub>0</sub> (w<sub>0</sub>/w(z)) exp(−r²/w(z)²)
              exp[i(−kz + k r²/(2R(z)) + ζ(z))] e<sup>−iωt</sup> }
            </div>
            <div>
              <button class="copyBtn" data-copy-target="prev">Copy</button>
              <span class="copyNote">Copied!</span>
            </div>
          </div>
          <p class="muted small">
            Equivalent forms differ by an overall constant phase; what matters is that the two beams have opposite kz dependence
            and the same transverse curvature term at a given z.
          </p>
        </div>

        <h3>Step 3 — Add the beams and expose the standing-wave factor</h3>
        <p>
          Add the complex fields (before taking the real part). Factor out the common envelope:
          <span class="eq">A(r,z) = E<sub>0</sub> (w<sub>0</sub>/w(z)) exp(−r²/w(z)²) exp[i k r²/(2R(z))]</span>.
        </p>

        <p>
          Then the total complex field is
          <span class="eq">Ẽ = A(r,z) e^{-iωt} [ e^{i(kz − ζ(z))} + e^{-i(kz − ζ(z))} ]</span>.
          Use <span class="eq">e^{iθ} + e^{-iθ} = 2 cos θ</span> with <span class="eq">θ = kz − ζ(z)</span>.
        </p>

        <div class="box keyeq">
          <h4>Standing-wave form (result)</h4>
          <div class="eqline">
            <div class="eq" data-copy="E_total(r,z,t)=Re{ 2 A(r,z) cos(kz − ζ(z)) * exp(-iωt) }&#10;A(r,z)=E0*(w0/w(z))*exp(-r^2/w(z)^2)*exp[i k r^2/(2R(z))]">
              <b>E</b><sub>total</sub>(r,z,t)=Re{ <b>2 A(r,z) cos(kz − ζ(z))</b> e<sup>−iωt</sup> }<br/>
              A(r,z)=E<sub>0</sub>(w<sub>0</sub>/w(z))e<sup>−r²/w(z)²</sup> e<sup>i k r²/(2R(z))</sup>
            </div>
            <div>
              <button class="copyBtn" data-copy-target="prev">Copy</button>
              <span class="copyNote">Copied!</span>
            </div>
          </div>
          <p class="muted small">
            The spatial dependence is through <span class="eq">cos(kz − ζ(z))</span>: nodes/antinodes are fixed in z (standing wave),
            while the whole field oscillates in time at frequency ν.
          </p>
        </div>

        <h3>Step 4 — Apply boundary conditions at ideal mirrors on wavefronts</h3>
        <p>
          Place ideal mirrors at <span class="eq">z=z₁</span> and <span class="eq">z=z₂</span>.
          The key phrase “mirrors coincide with the wavefronts” means each mirror surface is a surface of constant optical phase for the Gaussian beam.
          Therefore, the phase is uniform across the mirror aperture, and we can enforce the boundary condition using the axial standing-wave factor alone.
        </p>

        <p>
          For an ideal conductor, the tangential electric field must vanish at the surface. In this standing-wave representation, that corresponds to
          choosing the standing-wave phase so that the cosine has zeros at both mirrors (you could equally choose sine depending on reference phase;
          only the <i>difference</i> between the two mirror conditions matters).
        </p>

        <p>
          Thus we require:
          <span class="eq">cos(k z₁ − ζ(z₁)) = 0</span> and <span class="eq">cos(k z₂ − ζ(z₂)) = 0</span>.
          That means the arguments differ by an integer multiple of π:
        </p>

        <div class="box keyeq">
          <h4>Quantization between mirrors</h4>
          <div class="eqline">
            <div class="eq" data-copy="[k z2 − ζ(z2)] − [k z1 − ζ(z1)] = q π&#10;⇒ k(z2−z1) − (ζ2−ζ1) = q π">
              [k z₂ − ζ(z₂)] − [k z₁ − ζ(z₁)] = q π<br/>
              ⇒ k(z₂−z₁) − (ζ₂−ζ₁) = q π
            </div>
            <div>
              <button class="copyBtn" data-copy-target="prev">Copy</button>
              <span class="copyNote">Copied!</span>
            </div>
          </div>
        </div>

        <p>
          Define the cavity length (mirror separation) and Gouy phase difference:
          <span class="eq">d = z₂ − z₁</span>, <span class="eq">Δζ = ζ(z₂) − ζ(z₁)</span>.
          Then the resonance condition is:
        </p>

        <div class="box final">
          <h4>Resonance condition (axial phase)</h4>
          <div class="eqline">
            <div class="eq" data-copy="k d − Δζ = q π&#10;where d = z2 − z1 and Δζ = ζ(z2) − ζ(z1)">
              <b>k d − Δζ = q π</b><br/>
              d = z₂ − z₁, &nbsp;Δζ = ζ(z₂) − ζ(z₁)
            </div>
            <div>
              <button class="copyBtn" data-copy-target="prev">Copy</button>
              <span class="copyNote">Copied!</span>
            </div>
          </div>
        </div>

        <h3>Step 5 — Convert to resonance frequencies</h3>
        <p>
          Use <span class="eq">k = 2πν/c</span>. Substitute into <span class="eq">k d − Δζ = qπ</span>:
        </p>

        <p class="eq">
          (2πν/c) d − Δζ = qπ
          &nbsp;⇒&nbsp;
          2πν d / c = qπ + Δζ
          &nbsp;⇒&nbsp;
          ν = (c/(2d)) ( q + Δζ/π )
        </p>

        <div class="box final">
          <h4>Resonance frequencies (matches the requested form)</h4>
          <div class="eqline">
            <div class="eq" data-copy="ν_q = (c/(2d)) ( q + Δζ/π )&#10;= q ν_F + (Δζ/π) ν_F,   ν_F = c/(2d)">
              <b>ν<sub>q</sub> = (c/2d) ( q + Δζ/π )</b><br/>
              = q ν<sub>F</sub> + (Δζ/π) ν<sub>F</sub>, &nbsp;ν<sub>F</sub>=c/(2d)
            </div>
            <div>
              <button class="copyBtn" data-copy-target="prev">Copy</button>
              <span class="copyNote">Copied!</span>
            </div>
          </div>
        </div>

        <h3>Sanity checks</h3>
        <ul>
          <li><b>Units:</b> c/(2d) has units m/s ÷ m = 1/s = Hz. Δζ/π is dimensionless. Good.</li>
          <li><b>Limiting case (plane-wave cavity):</b> if the beam is very weakly focused, ζ(z) changes very little across the cavity,
            so <span class="eq">Δζ → 0</span> and <span class="eq">ν_q → q c/(2d)</span>, the standard Fabry–Perot result.</li>
          <li><b>Mode spacing:</b> increasing q by 1 increases ν by exactly <span class="eq">c/(2d)=ν_F</span>, independent of Δζ.</li>
          <li><b>Physical interpretation:</b> focusing adds an extra phase (Gouy) that effectively reduces the “available” propagation phase k d,
            shifting the set of frequencies that satisfy the boundary conditions.</li>
        </ul>

        <p class="muted small">
          Connection to the diagram/plots: the mirrors are drawn on curved wavefronts; this ensures the k r²/(2R) term is constant over each mirror.
          The plots show (i) the linear frequency ladder with spacing ν<sub>F</sub> and Gouy offset, and (ii) the standing-wave intensity pattern
          along z using a model ζ(z)=arctan(z/z<sub>R</sub>) for a cavity centered at the waist.
        </p>
      </section>

      <!-- PART 4 -->
      <section id="part4">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpreting the final formula</h3>
        <p>
          <span class="eq">ν_q = (c/2d)(q + Δζ/π)</span> has two pieces:
        </p>
        <ul>
          <li><b>(c/2d) q:</b> the usual longitudinal quantization—q half-wavelengths fit between mirrors.</li>
          <li><b>(c/2d)(Δζ/π):</b> an <i>offset</i> due to the Gouy phase accumulated between the mirror wavefronts.</li>
        </ul>

        <h3>How parameters change the outcome (connect to interactive plots)</h3>
        <ul>
          <li><b>Increase cavity length d:</b> ν<sub>F</sub>=c/(2d) decreases → resonance lines pack closer together; intensity pattern has more oscillations for fixed q.</li>
          <li><b>Change focusing (Rayleigh range z<sub>R</sub>):</b> smaller z<sub>R</sub> (tighter focus) increases Gouy variation → larger Δζ → the entire frequency ladder shifts by a larger offset.</li>
          <li><b>Higher transverse order (optional extension):</b> for Hermite–Gaussian modes HG<sub>mn</sub>, the Gouy contribution scales with (m+n+1).
            In many textbooks the general result is
            <span class="eq">ν<sub>qmn</sub> = (c/2d)[ q + (m+n+1)(Δζ/π) ]</span>
            (same physics: extra phase per pass).</li>
        </ul>

        <h3>Alternative derivation idea (brief)</h3>
        <p>
          Instead of adding two beams, you can impose a <b>round-trip self-consistency</b> condition on a single traveling Gaussian mode:
          after propagation from mirror 1 to mirror 2 and back, the field must reproduce itself (up to 2πq). The round-trip phase includes
          <span class="eq">2kd</span> and <span class="eq">−2Δζ</span>. Setting <span class="eq">2kd − 2Δζ = 2πq</span> yields the same resonance condition.
        </p>

        <h3>Concept check (quick self-test)</h3>
        <ul>
          <li><b>Q:</b> Why does mirror-on-wavefront matter? <b>A:</b> It makes the transverse phase constant over the mirror, so the boundary reduces to a 1D axial phase condition.</li>
          <li><b>Q:</b> Does Gouy phase change the mode spacing ν<sub>F</sub>? <b>A:</b> No—adjacent q are still separated by c/(2d); Gouy shifts the ladder by an offset.</li>
          <li><b>Q:</b> What happens as focusing becomes negligible? <b>A:</b> Δζ→0 and the cavity behaves like a plane-wave Fabry–Perot.</li>
          <li><b>Q:</b> Is a standing wave “time-independent”? <b>A:</b> The spatial pattern is stationary, but the field still oscillates in time as cos(ωt) (or e<sup>−iωt</sup> in complex form).</li>
        </ul>
      </section>

      <!-- PART 5 -->
      <section id="part5">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

        <h3>What each canvas shows</h3>
        <ul>
          <li><b>Diagram:</b> Two curved mirrors separated by d, a Gaussian beam waist near the center, and curved wavefronts matching the mirrors.</li>
          <li><b>Main plot (Resonance ladder):</b> ν versus longitudinal index q. The slope is ν<sub>F</sub>=c/(2d). The vertical intercept is the Gouy offset (Δζ/π)ν<sub>F</sub>.</li>
          <li><b>Secondary plot (Standing-wave intensity):</b> normalized on-axis intensity ∝ cos²(kz − ζ(z)) between z=−d/2 and z=+d/2 (example model), showing node/antinode structure with Gouy-induced phase warp.</li>
        </ul>

        <h3>Interactive controls</h3>
        <ul>
          <li><b>Cavity length d (m):</b> updates ν<sub>F</sub> and the frequency ladder spacing, and updates the z-range of the intensity plot.</li>
          <li><b>Rayleigh range z<sub>R</sub> (m):</b> controls focusing strength; smaller z<sub>R</sub> → larger Δζ across the cavity → larger frequency offset and a more distorted phase in the standing-wave intensity.</li>
          <li><b>Mode index q (integer):</b> selects which resonance frequency is used to compute the standing-wave intensity pattern.</li>
          <li><b>Transverse order N=m+n (optional):</b> shows how higher-order modes shift more strongly via an (N+1) Gouy factor (educational extension).</li>
        </ul>

        <p class="muted small">
          Note: The problem statement may not provide numbers; the visualization uses <b>example values</b> for plotting while keeping the derivation symbolic.
        </p>
      </section>

      <!-- Visualizations -->
      <section id="viz">
        <h2>Interactive Visualizations</h2>
        <p class="muted">
          Live-updating diagram + two plots. Use the sliders/selectors; all canvases update together.
        </p>

        <div class="controls">
          <div class="control">
            <label for="dRange">
              Cavity length <span class="eq">d</span> (m)
              <span class="val" id="dVal"></span>
            </label>
            <input id="dRange" type="range" min="0.10" max="2.00" step="0.01" value="0.60"/>
            <div class="pillRow">
              <span class="pill">ν<sub>F</sub> = c/(2d)</span>
              <span class="pill">Example: mirrors at z=±d/2</span>
            </div>
          </div>

          <div class="control">
            <label for="zRRange">
              Rayleigh range <span class="eq">z<sub>R</sub></span> (m)
              <span class="val" id="zRVal"></span>
            </label>
            <input id="zRRange" type="range" min="0.05" max="1.20" step="0.01" value="0.25"/>
            <div class="pillRow">
              <span class="pill">ζ(z)=arctan(z/z<sub>R</sub>)</span>
              <span class="pill pulse">Δζ updates live</span>
            </div>
          </div>

          <div class="control">
            <label for="qSel">
              Longitudinal index <span class="eq">q</span> (int)
              <span class="val" id="qVal"></span>
            </label>
            <input id="qSel" type="range" min="1" max="25" step="1" value="8"/>
            <div class="pillRow">
              <span class="pill">Uses ν<sub>q</sub> in intensity plot</span>
              <span class="pill">k=2πν/c</span>
            </div>
          </div>

          <div class="control">
            <label for="nMode">
              Transverse order <span class="eq">N=m+n</span> (optional)
              <span class="val" id="nVal"></span>
            </label>
            <select id="nMode">
              <option value="0" selected>0 (fundamental)</option>
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="4">4</option>
              <option value="8">8</option>
            </select>
            <div class="pillRow">
              <span class="pill">Extension: factor (N+1)</span>
              <span class="pill">ν<sub>qN</sub>=(c/2d)(q+(N+1)Δζ/π)</span>
            </div>
          </div>
        </div>

        <div class="vizGrid">
          <figure>
            <canvas id="cDiagram" aria-label="Cavity diagram"></canvas>
            <figcaption>
              <b>Diagram:</b> Gaussian beam between two ideal mirrors placed on matching wavefronts (example geometry).
            </figcaption>
          </figure>

          <figure>
            <canvas id="cMain" aria-label="Resonance frequencies plot"></canvas>
            <figcaption>
              <b>Main plot:</b> Resonance frequencies ν versus q. Slope = ν<sub>F</sub>, intercept = Gouy offset.
            </figcaption>
          </figure>

          <figure>
            <canvas id="cSecondary" aria-label="Standing-wave intensity plot"></canvas>
            <figcaption>
              <b>Secondary plot:</b> On-axis standing-wave intensity ∝ cos²(kz − ζ(z)) between the mirrors (example ζ model).
            </figcaption>
          </figure>

          <figure>
            <canvas id="cSweep" aria-label="Parameter sweep plot"></canvas>
            <figcaption>
              <b>Parameter sweep:</b> Offset fraction (Δζ/π) and the frequency shift (Δζ/π)ν<sub>F</sub> versus z<sub>R</sub> at current d.
            </figcaption>
          </figure>
        </div>
      </section>
    </article>
  </div>
</main>

<footer>
  <div class="wrap">
    <div class="printHint">
      Tip: Print view hides the sticky ToC and copy buttons for clean notes.
    </div>
  </div>
</footer>

<script>
(function(){
  // ---------------- Utilities ----------------
  const c = 299792458; // m/s

  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

  function fmt(x, digits=3){
    if (!isFinite(x)) return "—";
    const abs = Math.abs(x);
    if (abs === 0) return "0";
    // Friendly engineering-ish format for common ranges
    if (abs >= 1e9) return (x/1e9).toFixed(digits) + "e9";
    if (abs >= 1e6) return (x/1e6).toFixed(digits) + "e6";
    if (abs >= 1e3) return (x/1e3).toFixed(digits) + "e3";
    if (abs < 1e-3) return x.toExponential(digits);
    return x.toFixed(digits);
  }

  function setupCanvas(canvas){
    const ctx = canvas.getContext('2d');
    const resize = () => {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.max(1, Math.floor(rect.width * dpr));
      canvas.height = Math.max(1, Math.floor(rect.height * dpr));
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    };
    resize();
    return {ctx, resize};
  }

  function clear(ctx, w, h){
    ctx.clearRect(0,0,w,h);
  }

  function drawPanelTitle(ctx, title, x, y){
    ctx.save();
    ctx.font = "600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "rgba(234,240,255,0.95)";
    ctx.fillText(title, x, y);
    ctx.restore();
  }

  function drawText(ctx, text, x, y, color="rgba(185,198,255,0.9)", font="12px ui-sans-serif, system-ui"){
    ctx.save();
    ctx.font = font;
    ctx.fillStyle = color;
    ctx.fillText(text, x, y);
    ctx.restore();
  }

  // Axes + grid for plots in a given frame
  function makePlotFrame(ctx, rect, xLabel, yLabel, title){
    const {x,y,w,h} = rect;
    const padL = 56, padR = 18, padT = 36, padB = 46;
    const px = x + padL, py = y + padT;
    const pw = w - padL - padR, ph = h - padT - padB;

    // Background
    ctx.save();
    ctx.fillStyle = "rgba(4,6,14,0.45)";
    ctx.fillRect(x,y,w,h);
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;
    ctx.strokeRect(x+0.5,y+0.5,w-1,h-1);
    ctx.restore();

    // Title
    drawPanelTitle(ctx, title, x + 12, y + 20);

    // Grid
    const nx = 8, ny = 6;
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.lineWidth = 1;
    for(let i=0;i<=nx;i++){
      const gx = px + (pw*i/nx);
      ctx.beginPath();
      ctx.moveTo(gx, py);
      ctx.lineTo(gx, py+ph);
      ctx.stroke();
    }
    for(let j=0;j<=ny;j++){
      const gy = py + (ph*j/ny);
      ctx.beginPath();
      ctx.moveTo(px, gy);
      ctx.lineTo(px+pw, gy);
      ctx.stroke();
    }
    ctx.restore();

    // Axes
    ctx.save();
    ctx.strokeStyle = "rgba(234,240,255,0.35)";
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(px, py+ph);
    ctx.lineTo(px+pw, py+ph);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(px, py+ph);
    ctx.stroke();
    ctx.restore();

    // Labels
    ctx.save();
    ctx.fillStyle = "rgba(234,240,255,0.8)";
    ctx.font = "12px ui-sans-serif, system-ui";
    // x label
    ctx.textAlign = "center";
    ctx.fillText(xLabel, px + pw/2, py + ph + 34);
    // y label
    ctx.save();
    ctx.translate(px - 40, py + ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = "center";
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();
    ctx.restore();

    return {px, py, pw, ph};
  }

  function ticks(ctx, frame, xMin, xMax, yMin, yMax, fmtX, fmtY){
    const {px,py,pw,ph} = frame;
    const nx = 8, ny = 6;

    ctx.save();
    ctx.fillStyle = "rgba(185,198,255,0.9)";
    ctx.font = "11px ui-sans-serif, system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    for(let i=0;i<=nx;i++){
      const t = i/nx;
      const val = xMin + (xMax-xMin)*t;
      const x = px + pw*t;
      ctx.fillText(fmtX(val), x, py+ph+6);
    }
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    for(let j=0;j<=ny;j++){
      const t = j/ny;
      const val = yMax - (yMax-yMin)*t;
      const y = py + ph*t;
      ctx.fillText(fmtY(val), px-8, y);
    }
    ctx.restore();
  }

  function mapX(frame, x, xMin, xMax){
    return frame.px + frame.pw * ((x - xMin)/(xMax - xMin));
  }
  function mapY(frame, y, yMin, yMax){
    return frame.py + frame.ph * (1 - (y - yMin)/(yMax - yMin));
  }

  function drawLegend(ctx, x, y, items){
    ctx.save();
    ctx.font = "12px ui-sans-serif, system-ui";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    const pad = 10;
    const lineH = 18;
    const w = Math.max(...items.map(it => ctx.measureText(it.label).width)) + 38;
    const h = items.length*lineH + pad*2;
    ctx.fillStyle = "rgba(0,0,0,0.28)";
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, 12);
    ctx.fill();
    ctx.stroke();
    for(let i=0;i<items.length;i++){
      const yy = y + pad + i*lineH + lineH/2;
      ctx.strokeStyle = items[i].stroke;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(x+12, yy);
      ctx.lineTo(x+28, yy);
      ctx.stroke();
      ctx.fillStyle = "rgba(234,240,255,0.9)";
      ctx.fillText(items[i].label, x+34, yy);
    }
    ctx.restore();
  }

  // Polyfill roundRect for older browsers
  if (!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    };
  }

  // ---------------- Copy buttons ----------------
  function showCopied(noteEl){
    noteEl.classList.add('show');
    clearTimeout(noteEl._t);
    noteEl._t = setTimeout(()=>noteEl.classList.remove('show'), 900);
  }

  document.querySelectorAll('.copyBtn').forEach(btn=>{
    btn.addEventListener('click', async () => {
      let target = null;
      if (btn.dataset.copyTarget === "prev"){
        // find nearest .eq in previous siblings within the same eqline
        const line = btn.closest('.eqline');
        if (line) target = line.querySelector('.eq');
      } else {
        const id = btn.dataset.copyTarget;
        target = document.getElementById(id);
      }
      if (!target) return;
      const txt = target.getAttribute('data-copy') || target.textContent;
      try{
        await navigator.clipboard.writeText(txt.replace(/\u00a0/g,' ').trim());
        const note = btn.parentElement.querySelector('.copyNote');
        if (note) showCopied(note);
      }catch(e){
        // fallback
        const ta = document.createElement('textarea');
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        const note = btn.parentElement.querySelector('.copyNote');
        if (note) showCopied(note);
      }
    });
  });

  // ---------------- State ----------------
  const state = {
    d: 0.60,       // m
    zR: 0.25,      // m
    q: 8,          // integer
    N: 0,          // transverse order m+n (educational extension)
    // Example: cavity centered on waist at z0=0, mirrors at ±d/2
    z0: 0
  };

  // Derived
  function zeta(z){
    return Math.atan((z - state.z0)/state.zR);
  }
  function deltaZeta(){
    const z1 = -state.d/2;
    const z2 =  state.d/2;
    return zeta(z2) - zeta(z1); // = 2 arctan((d/2)/zR)
  }
  function nuF(){ return c/(2*state.d); }
  function nu_qN(q, N){
    const Dz = deltaZeta();
    return nuF() * ( q + (N+1)*Dz/Math.PI );
  }

  // ---------------- Canvases ----------------
  const cd = setupCanvas(document.getElementById('cDiagram'));
  const cm = setupCanvas(document.getElementById('cMain'));
  const cs = setupCanvas(document.getElementById('cSecondary'));
  const cw = setupCanvas(document.getElementById('cSweep'));

  function resizeAll(){
    cd.resize(); cm.resize(); cs.resize(); cw.resize();
    renderAll();
  }
  window.addEventListener('resize', resizeAll);

  // ---------------- Drawing: Diagram ----------------
  function drawDiagram(){
    const canvas = document.getElementById('cDiagram');
    const ctx = cd.ctx;
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    clear(ctx, W, H);

    // Panel background and title
    ctx.save();
    ctx.fillStyle = "rgba(4,6,14,0.45)";
    ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.strokeRect(0.5,0.5,W-1,H-1);
    ctx.restore();
    drawPanelTitle(ctx, "Cavity geometry (example): mirrors on Gaussian wavefronts", 12, 20);

    // Coordinate mapping
    const pad = 22;
    const x0 = pad, x1 = W - pad;
    const yMid = H*0.58;
    const zMin = -state.d/2, zMax = state.d/2;

    const zToX = (z)=> x0 + (x1-x0)*((z - zMin)/(zMax - zMin));

    // Draw axis
    ctx.save();
    ctx.strokeStyle = "rgba(234,240,255,0.28)";
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(x0, yMid);
    ctx.lineTo(x1, yMid);
    ctx.stroke();
    ctx.restore();
    drawText(ctx, "z (m)", (x0+x1)/2, yMid+28, "rgba(185,198,255,0.85)", "12px ui-sans-serif, system-ui");

    // Mirrors (curved)
    const mirrorW = 10;
    const mirrorH = 120;
    const m1x = zToX(zMin), m2x = zToX(zMax);
    ctx.save();
    ctx.strokeStyle = "rgba(124,240,255,0.85)";
    ctx.lineWidth = 2;
    // left mirror curve
    ctx.beginPath();
    ctx.moveTo(m1x+mirrorW, yMid-mirrorH/2);
    ctx.quadraticCurveTo(m1x-18, yMid, m1x+mirrorW, yMid+mirrorH/2);
    ctx.stroke();
    // right mirror curve
    ctx.beginPath();
    ctx.moveTo(m2x-mirrorW, yMid-mirrorH/2);
    ctx.quadraticCurveTo(m2x+18, yMid, m2x-mirrorW, yMid+mirrorH/2);
    ctx.stroke();
    ctx.restore();

    drawText(ctx, "Mirror 1 (z=-d/2)", m1x+10, yMid-mirrorH/2-10, "rgba(185,198,255,0.85)");
    drawText(ctx, "Mirror 2 (z=+d/2)", m2x-130, yMid-mirrorH/2-10, "rgba(185,198,255,0.85)");

    // Beam envelope w(z) (schematic)
    const envTop = [];
    const envBot = [];
    const n = 220;

    // Choose an arbitrary waist radius for the drawing (not used in formulas)
    const w0_draw = 16; // pixels at waist
    const zR = state.zR;
    const zR_drawScale = (x1-x0)/(zMax - zMin); // pixels per meter
    // Envelope width in pixels: w(z) = w0 sqrt(1+(z/zR)^2)
    for(let i=0;i<=n;i++){
      const z = zMin + (zMax-zMin)*(i/n);
      const x = zToX(z);
      const wz = w0_draw * Math.sqrt(1 + (z/zR)*(z/zR));
      envTop.push([x, yMid - wz]);
      envBot.push([x, yMid + wz]);
    }

    ctx.save();
    ctx.strokeStyle = "rgba(167,255,158,0.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    envTop.forEach((p, idx)=>{ if(idx===0) ctx.moveTo(p[0],p[1]); else ctx.lineTo(p[0],p[1]); });
    ctx.stroke();
    ctx.beginPath();
    envBot.forEach((p, idx)=>{ if(idx===0) ctx.moveTo(p[0],p[1]); else ctx.lineTo(p[0],p[1]); });
    ctx.stroke();
    ctx.restore();

    // Waist marker
    const wx = zToX(0);
    ctx.save();
    ctx.strokeStyle = "rgba(255,210,124,0.9)";
    ctx.lineWidth = 1.8;
    ctx.beginPath();
    ctx.moveTo(wx, yMid-40);
    ctx.lineTo(wx, yMid+40);
    ctx.stroke();
    ctx.restore();
    drawText(ctx, "Waist (z=0)", wx-32, yMid+54, "rgba(255,210,124,0.95)");

    // Wavefront arcs (schematic) at a few z
    const waveZs = [-0.22*state.d, 0, 0.22*state.d];
    ctx.save();
    ctx.strokeStyle = "rgba(234,240,255,0.22)";
    ctx.lineWidth = 1.2;
    waveZs.forEach(z=>{
      const x = zToX(z);
      const s = 40;
      ctx.beginPath();
      // If z>0, wavefront concave left; if z<0 concave right (schematic)
      const dir = z>=0 ? -1 : 1;
      ctx.moveTo(x, yMid - 60);
      ctx.quadraticCurveTo(x + dir*s, yMid, x, yMid + 60);
      ctx.stroke();
    });
    ctx.restore();
    drawText(ctx, "Gaussian wavefronts", x0+8, yMid-86, "rgba(185,198,255,0.80)");

    // Counterprop arrows
    ctx.save();
    ctx.strokeStyle = "rgba(124,240,255,0.70)";
    ctx.lineWidth = 2;
    // +z arrow
    ctx.beginPath();
    ctx.moveTo(wx-70, yMid-110);
    ctx.lineTo(wx+70, yMid-110);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(wx+70, yMid-110);
    ctx.lineTo(wx+58, yMid-116);
    ctx.lineTo(wx+58, yMid-104);
    ctx.closePath();
    ctx.fillStyle = "rgba(124,240,255,0.70)";
    ctx.fill();
    drawText(ctx, "+z beam", wx-20, yMid-125, "rgba(185,198,255,0.85)");

    // -z arrow
    ctx.beginPath();
    ctx.moveTo(wx+70, yMid-140);
    ctx.lineTo(wx-70, yMid-140);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(wx-70, yMid-140);
    ctx.lineTo(wx-58, yMid-146);
    ctx.lineTo(wx-58, yMid-134);
    ctx.closePath();
    ctx.fillStyle = "rgba(167,255,158,0.65)";
    ctx.fill();
    drawText(ctx, "−z beam", wx-20, yMid-156, "rgba(185,198,255,0.85)");
    ctx.restore();

    // Annotation with current Δζ
    const Dz = deltaZeta();
    const off = (Dz/Math.PI);
    const nuf = nuF();
    drawText(ctx, `Δζ = ${Dz.toFixed(3)} rad  (Δζ/π = ${off.toFixed(3)})`, 12, H-28, "rgba(185,198,255,0.9)", "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace");
    drawText(ctx, `νF = c/(2d) = ${fmt(nuf,3)} Hz`, 12, H-12, "rgba(185,198,255,0.9)", "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace");
  }

  // ---------------- Drawing: Main Plot (ν vs q) ----------------
  function drawMainPlot(){
    const canvas = document.getElementById('cMain');
    const ctx = cm.ctx;
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;
    clear(ctx, W, H);

    const frame = makePlotFrame(ctx, {x:0,y:0,w:W,h:H}, "q (longitudinal index)", "ν (Hz)", "Resonance ladder: ν versus q");

    const qMax = 25;
    const qMin = 0;
    const Dz = deltaZeta();
    const nuf = nuF();
    const N = state.N;

    // We'll plot two ladders: fundamental (N=0) and current N (if N !=0)
    const nu0 = (q)=> nu_qN(q, 0);
    const nuN = (q)=> nu_qN(q, N);

    // y-range
    let yMin = Math.min(nu0(qMin), nu0(qMax), nuN(qMin), nuN(qMax));
    let yMax = Math.max(nu0(qMin), nu0(qMax), nuN(qMin), nuN(qMax));
    const pad = 0.06*(yMax-yMin || 1);
    yMin -= pad; yMax += pad;

    ticks(ctx, frame, qMin, qMax, yMin, yMax,
      (v)=> (Math.round(v)).toString(),
      (v)=> {
        // show in GHz if large
        const abs = Math.abs(v);
        if (abs >= 1e9) return (v/1e9).toFixed(2)+"G";
        if (abs >= 1e6) return (v/1e6).toFixed(2)+"M";
        if (abs >= 1e3) return (v/1e3).toFixed(2)+"k";
        return v.toFixed(0);
      }
    );

    function drawLine(f, stroke){
      ctx.save();
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2.4;
      ctx.beginPath();
      for(let q=qMin; q<=qMax; q++){
        const x = mapX(frame, q, qMin, qMax);
        const y = mapY(frame, f(q), yMin, yMax);
        if(q===qMin) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();

      // markers
      ctx.save();
      ctx.fillStyle = stroke;
      for(let q=qMin; q<=qMax; q+=1){
        const x = mapX(frame, q, qMin, qMax);
        const y = mapY(frame, f(q), yMin, yMax);
        ctx.beginPath();
        ctx.arc(x,y,2.8,0,Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    drawLine(nu0, "rgba(124,240,255,0.85)");
    if (N !== 0){
      drawLine(nuN, "rgba(167,255,158,0.80)");
    }

    // Highlight selected q for current N
    const qSel = state.q;
    const nuSel = nu_qN(qSel, N);
    const xSel = mapX(frame, qSel, qMin, qMax);
    const ySel = mapY(frame, nuSel, yMin, yMax);

    ctx.save();
    ctx.strokeStyle = "rgba(255,210,124,0.9)";
    ctx.lineWidth = 1.6;
    ctx.setLineDash([6,5]);
    ctx.beginPath();
    ctx.moveTo(xSel, frame.py);
    ctx.lineTo(xSel, frame.py+frame.ph);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = "rgba(255,210,124,0.95)";
    ctx.beginPath();
    ctx.arc(xSel, ySel, 5.5, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Annotate formula pieces
    const off = (N+1)*Dz/Math.PI;
    drawText(ctx, `νF = ${fmt(nuf,3)} Hz`, frame.px+6, frame.py+10, "rgba(185,198,255,0.92)", "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace");
    drawText(ctx, `Δζ = ${Dz.toFixed(3)} rad → offset = (N+1)Δζ/π = ${off.toFixed(3)}`, frame.px+6, frame.py+26, "rgba(185,198,255,0.92)", "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace");

    drawLegend(ctx, frame.px + frame.pw - 210, frame.py + 8, [
      {stroke:"rgba(124,240,255,0.85)", label:"N=0 (fundamental)"},
      {stroke: (N!==0 ? "rgba(167,255,158,0.80)" : "rgba(167,255,158,0.22)"), label: (N!==0 ? `N=${N} (extension)` : "N=0 only")}
    ]);
  }

  // ---------------- Drawing: Secondary Plot (Intensity vs z) ----------------
  function drawSecondaryPlot(){
    const canvas = document.getElementById('cSecondary');
    const ctx = cs.ctx;
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;
    clear(ctx, W, H);

    const frame = makePlotFrame(ctx, {x:0,y:0,w:W,h:H}, "z (m)", "Normalized intensity (arb.)", "Standing wave on-axis: I(z) ∝ cos²(kz − ζ(z))");

    const zMin = -state.d/2;
    const zMax =  state.d/2;
    const N = state.N;
    const nu = nu_qN(state.q, N);
    const k = 2*Math.PI*nu/c;

    // compute I(z)
    const n = 900;
    let yMin = 0, yMax = 1.08;
    ticks(ctx, frame, zMin, zMax, yMin, yMax,
      (v)=> v.toFixed(2),
      (v)=> v.toFixed(1)
    );

    // plot
    ctx.save();
    ctx.strokeStyle = "rgba(124,240,255,0.90)";
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    for(let i=0;i<=n;i++){
      const z = zMin + (zMax-zMin)*(i/n);
      const theta = k*z - zeta(z);
      const I = Math.cos(theta)**2;
      const x = mapX(frame, z, zMin, zMax);
      const y = mapY(frame, I, yMin, yMax);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();

    // mark mirrors
    function vLine(z, label){
      const x = mapX(frame, z, zMin, zMax);
      ctx.save();
      ctx.strokeStyle = "rgba(255,210,124,0.75)";
      ctx.lineWidth = 1.4;
      ctx.setLineDash([5,5]);
      ctx.beginPath();
      ctx.moveTo(x, frame.py);
      ctx.lineTo(x, frame.py+frame.ph);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      drawText(ctx, label, x-36, frame.py+frame.ph+18, "rgba(255,210,124,0.9)", "12px ui-sans-serif, system-ui");
    }
    vLine(zMin, "mirror");
    vLine(zMax, "mirror");

    // annotate parameters
    const Dz = deltaZeta();
    drawText(ctx, `q=${state.q}, N=${N}, ν=${fmt(nu,4)} Hz`, frame.px+6, frame.py+10, "rgba(185,198,255,0.92)", "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace");
    drawText(ctx, `d=${state.d.toFixed(2)} m, zR=${state.zR.toFixed(2)} m, Δζ=${Dz.toFixed(3)} rad`, frame.px+6, frame.py+26, "rgba(185,198,255,0.92)", "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace");

    drawLegend(ctx, frame.px + frame.pw - 230, frame.py + 8, [
      {stroke:"rgba(124,240,255,0.90)", label:"I(z) = cos²(kz − ζ(z))"},
      {stroke:"rgba(255,210,124,0.75)", label:"mirrors at ±d/2"}
    ]);
  }

  // ---------------- Drawing: Sweep Plot (offset vs zR) ----------------
  function drawSweepPlot(){
    const canvas = document.getElementById('cSweep');
    const ctx = cw.ctx;
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;
    clear(ctx, W, H);

    const frame = makePlotFrame(ctx, {x:0,y:0,w:W,h:H}, "zR (m)", "Offset & shift", "Parameter sweep: Gouy offset vs Rayleigh range");

    // Sweep zR around slider range at current d
    const zRmin = 0.05, zRmax = 1.20;
    const n = 260;

    // We'll plot:
    //   f1 = Δζ/π (dimensionless) for N=0
    //   f2 = (Δζ/π)*νF (Hz) but scaled to GHz for readability in labels
    const nuf = nuF();

    let y1min=0, y1max=1; // Δζ/π lies between 0 and 1 for symmetric ±d/2
    // For shift, max is nuf*(1) (Hz)
    // We'll plot both on same axes by normalizing the shift to νF as well.
    // So y-axis will be "fraction of νF": yA = Δζ/π, yB = (Δζ/π) also (same),
    // but we annotate the actual Hz shift at the end. To make this a true "sweep", we add N+1 scaling.
    const N = state.N;
    let yMin = 0;
    let yMax = Math.min(2.0, (N+1)*1.05); // show up to 2 for larger N
    yMax = Math.max(1.05, yMax);

    ticks(ctx, frame, zRmin, zRmax, yMin, yMax,
      (v)=> v.toFixed(2),
      (v)=> v.toFixed(2)
    );

    // compute curve y = (N+1)Δζ/π
    ctx.save();
    ctx.strokeStyle = "rgba(167,255,158,0.85)";
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    for(let i=0;i<=n;i++){
      const zR = zRmin + (zRmax-zRmin)*(i/n);
      const Dz = 2*Math.atan((state.d/2)/zR);
      const y = (N+1)*Dz/Math.PI;
      const x = mapX(frame, zR, zRmin, zRmax);
      const yy = mapY(frame, y, yMin, yMax);
      if(i===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
    }
    ctx.stroke();
    ctx.restore();

    // vertical line at current zR
    const xNow = mapX(frame, state.zR, zRmin, zRmax);
    ctx.save();
    ctx.strokeStyle = "rgba(255,210,124,0.85)";
    ctx.lineWidth = 1.6;
    ctx.setLineDash([6,5]);
    ctx.beginPath();
    ctx.moveTo(xNow, frame.py);
    ctx.lineTo(xNow, frame.py+frame.ph);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();

    const DzNow = deltaZeta();
    const offNow = (N+1)*DzNow/Math.PI;
    const shiftHz = offNow * nuf;

    // annotate
    drawText(ctx, `At zR=${state.zR.toFixed(2)} m: (N+1)Δζ/π = ${offNow.toFixed(3)}`, frame.px+6, frame.py+10, "rgba(185,198,255,0.92)", "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace");
    // show shift in MHz/GHz
    let shiftStr = "";
    if (Math.abs(shiftHz) >= 1e9) shiftStr = (shiftHz/1e9).toFixed(3)+" GHz";
    else if (Math.abs(shiftHz) >= 1e6) shiftStr = (shiftHz/1e6).toFixed(3)+" MHz";
    else if (Math.abs(shiftHz) >= 1e3) shiftStr = (shiftHz/1e3).toFixed(3)+" kHz";
    else shiftStr = shiftHz.toFixed(1)+" Hz";
    drawText(ctx, `Frequency offset = ((N+1)Δζ/π) νF = ${shiftStr}`, frame.px+6, frame.py+26, "rgba(185,198,255,0.92)", "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace");

    drawLegend(ctx, frame.px + frame.pw - 250, frame.py + 8, [
      {stroke:"rgba(167,255,158,0.85)", label:"(N+1)Δζ/π vs zR"},
      {stroke:"rgba(255,210,124,0.85)", label:"current zR"}
    ]);
  }

  // ---------------- Render all ----------------
  function renderAll(){
    // Update readouts
    document.getElementById('dVal').textContent  = state.d.toFixed(2);
    document.getElementById('zRVal').textContent = state.zR.toFixed(2);
    document.getElementById('qVal').textContent  = String(state.q);
    document.getElementById('nVal').textContent  = String(state.N);

    drawDiagram();
    drawMainPlot();
    drawSecondaryPlot();
    drawSweepPlot();
  }

  // ---------------- Controls wiring ----------------
  const dRange = document.getElementById('dRange');
  const zRRange = document.getElementById('zRRange');
  const qSel = document.getElementById('qSel');
  const nMode = document.getElementById('nMode');

  dRange.addEventListener('input', ()=>{
    state.d = parseFloat(dRange.value);
    renderAll();
  });
  zRRange.addEventListener('input', ()=>{
    state.zR = parseFloat(zRRange.value);
    renderAll();
  });
  qSel.addEventListener('input', ()=>{
    state.q = parseInt(qSel.value, 10);
    renderAll();
  });
  nMode.addEventListener('change', ()=>{
    state.N = parseInt(nMode.value, 10);
    renderAll();
  });

  // Initial render
  renderAll();
})();
</script>
</body>
</html>
