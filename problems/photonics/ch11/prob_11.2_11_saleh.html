<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Gaussian Beam in a Symmetric Confocal Resonator (Worked Tutorial)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --card2:#0f1730;
      --ink:#eaf0ff;
      --muted:#b8c3e6;
      --muted2:#94a3d6;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#86efac;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1200px 700px at 20% -10%, rgba(125,211,252,.15), transparent 60%),
        radial-gradient(900px 600px at 95% 5%, rgba(167,139,250,.14), transparent 55%),
        radial-gradient(900px 700px at 30% 120%, rgba(134,239,172,.10), transparent 55%),
        linear-gradient(180deg, var(--bg), #070b16 60%, #050814);
      line-height:1.55;
    }
    header{
      padding:28px 18px 10px;
      max-width:1200px;
      margin:0 auto;
    }
    .titlebar{
      display:flex;
      gap:14px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-size:clamp(1.55rem, 2.7vw, 2.35rem);
      letter-spacing:.2px;
      line-height:1.18;
    }
    .subtitle{
      color:var(--muted);
      margin-top:6px;
      max-width:78ch;
      font-size:1rem;
    }
    .grid{
      max-width:1200px;
      margin:0 auto 34px;
      padding:0 18px 34px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }
    aside{
      position:sticky;
      top:14px;
      align-self:start;
      background:linear-gradient(180deg, rgba(17,26,51,.92), rgba(15,23,48,.92));
      border:1px solid var(--line);
      border-radius:18px;
      box-shadow:var(--shadow);
      padding:14px;
      backdrop-filter: blur(8px);
    }
    @media (max-width:980px){
      aside{position:relative; top:auto}
    }
    .toc h2{
      margin:0 0 10px;
      font-size:1.05rem;
      color:var(--ink);
    }
    .toc a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      color:var(--muted);
      text-decoration:none;
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:.96rem;
    }
    .toc a:hover{
      background:rgba(255,255,255,.06);
      border-color:rgba(255,255,255,.12);
      transform: translateY(-1px);
      color:var(--ink);
    }
    .toc .mini{
      margin-top:10px;
      padding-top:12px;
      border-top:1px solid var(--line);
      color:var(--muted2);
      font-size:.9rem;
    }

    main{
      background:linear-gradient(180deg, rgba(17,26,51,.72), rgba(15,23,48,.62));
      border:1px solid var(--line);
      border-radius:18px;
      box-shadow:var(--shadow);
      overflow:hidden;
      backdrop-filter: blur(8px);
    }
    section{
      padding:18px 18px;
      border-top:1px solid var(--line);
    }
    section:first-child{border-top:none}
    h2{
      margin:0 0 10px;
      font-size:1.35rem;
      letter-spacing:.2px;
    }
    h3{
      margin:16px 0 8px;
      font-size:1.08rem;
      color:var(--ink);
    }
    p{margin:8px 0; color:var(--muted)}
    ul{margin:10px 0 0 18px; color:var(--muted)}
    li{margin:6px 0}
    .callouts{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:12px;
      margin-top:12px;
    }
    .card{
      grid-column: span 12;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:16px;
      padding:14px;
    }
    .card strong{color:var(--ink)}
    .card small{color:var(--muted2)}
    .span6{grid-column: span 6}
    .span5{grid-column: span 5}
    .span7{grid-column: span 7}
    .span4{grid-column: span 4}
    @media (max-width: 860px){
      .span6,.span5,.span7,.span4{grid-column: span 12}
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.05);
      color:var(--muted);
      font-size:.9rem;
      margin:6px 6px 0 0;
      white-space:nowrap;
    }
    .eqwrap{
      position:relative;
      margin:10px 0 8px;
      padding:12px 12px 12px 12px;
      border-radius:14px;
      border:1px solid rgba(125,211,252,.25);
      background:rgba(125,211,252,.06);
      overflow:hidden;
    }
    .eq{
      font-family:var(--mono);
      color:var(--ink);
      font-size:.95rem;
      white-space:pre-wrap;
      line-height:1.4;
      margin:0;
    }
    .copybtn{
      position:absolute;
      top:10px;
      right:10px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(0,0,0,.25);
      color:var(--ink);
      padding:7px 10px;
      border-radius:12px;
      cursor:pointer;
      font-size:.85rem;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .copybtn:hover{
      transform: translateY(-1px);
      background:rgba(0,0,0,.35);
      border-color:rgba(255,255,255,.25);
    }
    .copyhint{
      color:var(--muted2);
      font-size:.85rem;
      margin:6px 0 0;
    }
    .results{
      border:1px solid rgba(134,239,172,.28);
      background:rgba(134,239,172,.06);
      border-radius:16px;
      padding:14px;
    }
    .results h3{margin-top:0}
    .kpi{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:10px;
      margin-top:10px;
    }
    .k{
      grid-column: span 4;
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      background:rgba(255,255,255,.04);
    }
    @media (max-width:860px){ .k{grid-column: span 12} }
    .k .label{color:var(--muted2); font-size:.85rem}
    .k .val{font-family:var(--mono); font-size:1.02rem; color:var(--ink); margin-top:6px}
    .k .note{color:var(--muted2); font-size:.82rem; margin-top:6px}
    .canvasRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:12px;
    }
    @media (max-width:860px){ .canvasRow{grid-template-columns:1fr} }
    figure{
      margin:0;
      border:1px solid var(--line);
      border-radius:16px;
      background:rgba(255,255,255,.03);
      overflow:hidden;
    }
    figcaption{
      padding:10px 12px;
      border-top:1px solid var(--line);
      color:var(--muted2);
      font-size:.9rem;
    }
    canvas{
      width:100%;
      height:340px;
      display:block;
      background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.12));
    }
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      margin-top:10px;
      padding:12px;
      border:1px solid var(--line);
      border-radius:16px;
      background:rgba(255,255,255,.03);
    }
    .control{
      flex: 1 1 230px;
      min-width:220px;
    }
    label{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      color:var(--muted);
      font-size:.95rem;
      margin-bottom:6px;
    }
    input[type="range"]{width:100%}
    .readout{
      font-family:var(--mono);
      color:var(--ink);
      font-size:.9rem;
      padding:4px 8px;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.22);
      white-space:nowrap;
    }
    footer{
      max-width:1200px;
      margin:0 auto;
      padding:14px 18px 28px;
      color:var(--muted2);
      font-size:.92rem;
    }
    .printNote{display:none}
    @media print{
      body{background:#fff; color:#000}
      header, footer{color:#000}
      aside{display:none}
      main{box-shadow:none; border:1px solid #ddd; background:#fff}
      section{border-color:#ddd}
      .eqwrap{background:#f6fbff; border-color:#bcdff2}
      .results{background:#f6fff9; border-color:#bfead0}
      canvas{background:#fff}
      .copybtn{display:none}
      .printNote{display:block; color:#000}
    }
  </style>
</head>
<body>
<header>
  <div class="titlebar">
    <div>
      <h1>Gaussian Beam in a Symmetric Confocal Resonator</h1>
      <div class="subtitle">
        A guided mini-lecture + full worked solution for a two-mirror symmetric confocal optical cavity.
        We connect Gaussian beam propagation, cavity stability (g-parameters), Gouy phase, and transverse mode structure.
      </div>
      <div style="margin-top:10px">
        <span class="badge">Given: d = 16 cm</span>
        <span class="badge">Mirror reflectance: 0.995 (each)</span>
        <span class="badge">Index: n = 1</span>
        <span class="badge">Laser: λ₀ = 1 μm</span>
      </div>
    </div>
  </div>
</header>

<div class="grid">
  <aside>
    <nav class="toc">
      <h2>Table of Contents</h2>
      <a href="#quick">Quick Summary</a>
      <a href="#part0">PART 0 — Concept Primer</a>
      <a href="#part1">PART 1 — Problem Analysis</a>
      <a href="#part2">PART 2 — Strategy &amp; Tips</a>
      <a href="#part3">PART 3 — Full Solution</a>
      <a href="#part4">PART 4 — Deeper Understanding</a>
      <a href="#part5">PART 5 — Visualization Guide</a>
      <div class="mini">
        <div><strong>Interactive:</strong> slide the wavelength to see how the beam size, HG(1,0) peaks, and resonance frequencies shift.</div>
      </div>
    </nav>
  </aside>

  <main>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><strong>What this is:</strong> a symmetric <em>confocal</em> two-mirror resonator (identical mirrors, spacing <span class="eq">d</span>).</li>
        <li><strong>Key physics idea:</strong> the cavity eigenmodes are Gaussian/Hermite–Gaussian beams whose wavefront curvature must match the mirrors at the mirror planes.</li>
        <li><strong>Stability &amp; geometry:</strong> use <span class="eq">g = 1 - d/R</span> (symmetric) and the confocal condition (<span class="eq">g=0</span>) to get the mirror radius <span class="eq">R</span>.</li>
        <li><strong>Beam sizing equation:</strong> <span class="eq">w(z)=w0·sqrt(1+(z/zR)^2)</span> with <span class="eq">w0^2=(λ/π) zR</span>.</li>
        <li><strong>Transverse mode structure:</strong> HG(1,0) intensity at a mirror is <span class="eq">I(x) ∝ x^2 exp(-2x^2/wm^2)</span>, giving two symmetric peaks.</li>
        <li><strong>Resonance condition:</strong> <span class="eq">νqmn = (c/2d)[ q + (m+n+1)(arccos√(g1g2))/π ]</span>; for confocal, <span class="eq">arccos(0)=π/2</span>.</li>
        <li><strong>Loss model:</strong> if loss is only imperfect reflectance, distributed loss satisfies <span class="eq">exp(-αr·2d)=R1R2</span>.</li>
        <li><strong>Final results:</strong> mostly closed-form with clean numerics for the given <span class="eq">d=16 cm</span>, <span class="eq">λ0=1 μm</span>.</li>
      </ul>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="callouts">
        <div class="card span6">
          <h3>Core definitions (symbols &amp; units)</h3>
          <ul>
            <li><span class="eq">d</span> — mirror separation (m).</li>
            <li><span class="eq">R</span> — mirror radius of curvature (m). Positive for concave mirrors facing inward.</li>
            <li><span class="eq">λ</span> — vacuum wavelength (m). Here <span class="eq">n=1</span>, so wavelength in medium is also <span class="eq">λ</span>.</li>
            <li><span class="eq">w(z)</span> — Gaussian beam radius (m): where intensity drops to <span class="eq">1/e^2</span> of on-axis value.</li>
            <li><span class="eq">w0</span> — beam waist radius (m), the minimum <span class="eq">w(z)</span>.</li>
            <li><span class="eq">zR</span> — Rayleigh range (m): <span class="eq">zR = π w0^2 / λ</span>.</li>
            <li><span class="eq">ν</span> — optical frequency (Hz), <span class="eq">ν = c/λ</span>.</li>
            <li><span class="eq">FSR</span> — free spectral range (Hz): <span class="eq">FSR = c/(2d)</span>.</li>
          </ul>
        </div>

        <div class="card span6">
          <h3>Physical meaning (what these quantities represent)</h3>
          <ul>
            <li><strong>Mirror curvature matching:</strong> at each mirror, the Gaussian wavefront has a curvature radius <span class="eq">Rbeam(z)</span>. A stable resonator mode exists when <span class="eq">Rbeam</span> matches the mirror <span class="eq">R</span> at the mirror plane(s).</li>
            <li><strong>Waist &amp; Rayleigh range:</strong> <span class="eq">w0</span> sets how tightly the mode is confined at the center; <span class="eq">zR</span> sets how quickly it diverges.</li>
            <li><strong>Gouy phase:</strong> transverse modes accumulate an extra phase (Gouy phase) that shifts resonance frequencies. That is why <span class="eq">(m,n)</span> modes are not generally degenerate.</li>
          </ul>
        </div>

        <div class="card span7">
          <h3>Key laws/principles and validity</h3>
          <ul>
            <li><strong>Paraxial wave equation:</strong> Gaussian beams solve the paraxial approximation of the Helmholtz equation (small divergence angles, slowly varying envelope).</li>
            <li><strong>ABCD matrix / stability:</strong> a two-mirror cavity is stable when <span class="eq">0 &lt; g1 g2 &lt; 1</span>, where <span class="eq">g_i = 1 - d/R_i</span>. For symmetric cavities: <span class="eq">g1=g2=g</span>.</li>
            <li><strong>Hermite–Gaussian modes:</strong> in Cartesian coordinates, transverse modes are labeled by nonnegative integers <span class="eq">m,n</span>.</li>
          </ul>
          <div class="eqwrap" style="margin-top:10px">
            <button class="copybtn" data-copy="g_i = 1 - d/R_i;  stability: 0 < g1*g2 < 1">Copy</button>
            <pre class="eq">g_i = 1 - d/R_i
Stability condition: 0 &lt; g1·g2 &lt; 1</pre>
            <div class="copyhint">These are the quickest “sanity checks” for whether a cavity supports bound Gaussian modes.</div>
          </div>
        </div>

        <div class="card span5">
          <h3>Common models/approximations (why we use them)</h3>
          <ul>
            <li><strong>Ideal mirrors</strong> except reflectance: no scattering, no clipping, no absorption, no diffraction loss.</li>
            <li><strong>Perfect alignment</strong> and symmetry: waist at the cavity center.</li>
            <li><strong>n = 1</strong>: vacuum/air, so <span class="eq">λ</span> is the relevant wavelength in propagation formulas.</li>
          </ul>
        </div>

        <div class="card span6">
          <h3>Mini intuition examples (quick, conceptual)</h3>
          <ul>
            <li><strong>Near-planar cavity:</strong> if <span class="eq">R</span> is very large compared to <span class="eq">d</span>, the cavity barely focuses, so the mode is large and weakly confined.</li>
            <li><strong>Near-concentric cavity:</strong> if mirrors nearly face each other’s centers of curvature, the cavity strongly focuses, so the waist becomes small (but alignment becomes sensitive).</li>
          </ul>
        </div>

        <div class="card span6">
          <h3>What to watch for (pitfalls)</h3>
          <ul>
            <li>Confusing <span class="eq">w</span> (beam radius) with mirror radius of curvature <span class="eq">R</span>.</li>
            <li>For HG(1,0), the <em>field</em> is odd in <span class="eq">x</span>, but the <em>intensity</em> has two symmetric lobes.</li>
            <li>Resonance frequencies depend on both longitudinal index <span class="eq">q</span> and transverse indices <span class="eq">(m,n)</span> through Gouy phase.</li>
            <li>Loss per round trip vs distributed loss: keep track of whether you use amplitude or power reflectance.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Restate the problem (in plain language)</h3>
      <p>
        We have a symmetric two-mirror optical resonator (mirrors identical) that is <strong>confocal</strong>.
        The mirror spacing is <span class="eq">d = 16 cm</span>, each mirror power reflectance is <span class="eq">ℛ = 0.995</span>,
        the medium is air/vacuum (<span class="eq">n=1</span>), and the laser wavelength is <span class="eq">λ0 = 1 μm</span>.
        We want:
        (a) mirror curvature radii,
        (b) the Gaussian fundamental waist,
        (c) the HG(1,0) intensity pattern at a mirror and the separation of its two maxima,
        (d) resonance frequencies of (0,0) and (1,0),
        (e) the distributed loss coefficient from mirror reflectance only.
      </p>

      <div class="callouts">
        <div class="card span6">
          <h3>Given quantities</h3>
          <ul>
            <li><span class="eq">d = 16 cm = 0.16 m</span></li>
            <li><span class="eq">ℛ = 0.995</span> (each mirror, power reflectance)</li>
            <li><span class="eq">n = 1</span></li>
            <li><span class="eq">λ0 = 1 μm = 1×10⁻⁶ m</span></li>
            <li><span class="eq">c ≈ 2.99792458×10⁸ m/s</span></li>
          </ul>
        </div>

        <div class="card span6">
          <h3>Unknowns (what we must find)</h3>
          <ul>
            <li>(a) Mirror radii of curvature <span class="eq">R1=R2=R</span></li>
            <li>(b) Fundamental waist <span class="eq">w0</span> (and often spot size at mirrors <span class="eq">wm</span>)</li>
            <li>(c) HG(1,0) intensity at mirror, peak-to-peak separation <span class="eq">Δx</span></li>
            <li>(d) Mode resonance frequencies <span class="eq">νq00</span> and <span class="eq">νq10</span></li>
            <li>(e) Distributed loss coefficient <span class="eq">αr</span> (1/m)</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li><strong>Confocal geometry:</strong> for a symmetric cavity, “confocal” means the cavity length equals the mirror radius of curvature, making each mirror located one focal length from the waist reference in a symmetric way.</li>
        <li><strong>Gaussian beam self-consistency:</strong> the resonator eigenmode must reproduce itself after a round trip; this reduces to matching wavefront curvature and beam size via Gaussian optics.</li>
        <li><strong>Gouy phase and resonance:</strong> transverse modes shift resonance frequencies by an amount proportional to <span class="eq">m+n+1</span>.</li>
        <li><strong>Loss model:</strong> with only mirror reflectance loss, the round-trip power is multiplied by <span class="eq">ℛ^2</span>; representing that as an equivalent distributed loss gives <span class="eq">αr</span>.</li>
      </ul>

      <div class="card">
        <h3>Assumptions (explicit)</h3>
        <ul>
          <li>Paraxial approximation (Gaussian beam optics valid).</li>
          <li>Perfect alignment and symmetry: waist at cavity center; mirrors identical.</li>
          <li>Neglect diffraction/clipping/scattering/absorption; only reflectance loss.</li>
          <li>Mirrors are ideal spherical surfaces with radius <span class="eq">R</span>.</li>
          <li>Refractive index <span class="eq">n=1</span>, so use vacuum wavelength <span class="eq">λ</span>.</li>
        </ul>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ul>
        <li><strong>Approach A — Confocal definition + standard Gaussian cavity formulas:</strong> fastest; gives <span class="eq">R</span>, <span class="eq">zR</span>, <span class="eq">w0</span>, and mode frequencies in compact form.</li>
        <li><strong>Approach B — ABCD matrix + complex beam parameter q:</strong> more general; good for non-symmetric cavities, but slightly heavier algebra.</li>
        <li><strong>Approach C — Geometric optics “ray-bounce” intuition:</strong> helps build understanding, but less direct for quantitative waist/frequency formulas.</li>
      </ul>
      <p><strong>Chosen approach:</strong> Approach A (with small ABCD “sanity checks”) because the cavity is explicitly symmetric and confocal, making the formulas especially clean.</p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>
      <ol style="color:var(--muted); margin:10px 0 0 18px">
        <li>
          <strong>Use the confocal condition</strong> to relate mirror curvature to spacing.
          <div class="copyhint">Goal: get <span class="eq">R</span>. Tool: confocal definition for symmetric cavity.</div>
        </li>
        <li>
          <strong>Write the Gaussian beam relations</strong>: <span class="eq">w0</span>, <span class="eq">zR</span>, and <span class="eq">w(z)</span>.
          <div class="copyhint">Goal: compute <span class="eq">w0</span>. Tool: <span class="eq">w0^2=(λ/π)zR</span>.</div>
        </li>
        <li>
          <strong>Find the spot size at the mirror</strong> using <span class="eq">z = d/2</span>.
          <div class="copyhint">Goal: get <span class="eq">wm</span> to describe transverse intensity at the mirror.</div>
        </li>
        <li>
          <strong>Write HG(1,0) intensity at the mirror plane</strong> and maximize it to locate peak positions.
          <div class="copyhint">Goal: get peak-to-peak separation <span class="eq">Δx</span>.</div>
        </li>
        <li>
          <strong>Use the general cavity frequency formula</strong> involving Gouy phase <span class="eq">arccos√(g1g2)</span>.
          <div class="copyhint">Goal: compute <span class="eq">νq00</span> and <span class="eq">νq10</span>; note confocal makes a half-FSR spacing.</div>
        </li>
        <li>
          <strong>Convert mirror reflectance to distributed loss</strong> via <span class="eq">exp(-αr·2d)=ℛ^2</span>.
          <div class="copyhint">Goal: compute <span class="eq">αr</span> in 1/m.</div>
        </li>
      </ol>

      <div class="callouts">
        <div class="card span6">
          <h3>Common mistakes</h3>
          <ul>
            <li>Using amplitude reflectivity <span class="eq">r</span> when the given value is power reflectance <span class="eq">ℛ</span>.</li>
            <li>Forgetting the factor of <span class="eq">2d</span> in a round trip.</li>
            <li>Maximizing the HG(1,0) <em>field</em> rather than the <em>intensity</em>.</li>
          </ul>
        </div>
        <div class="card span6">
          <h3>Quick tips</h3>
          <ul>
            <li>For a confocal symmetric cavity: <span class="eq">g=0</span>, <span class="eq">zR = d/2</span>, and <span class="eq">wm = w0√2</span> — big simplifications.</li>
            <li>HG(1,0) intensity peaks at <span class="eq">x = ±wm/√2</span> → separation <span class="eq">Δx = √2·wm</span>.</li>
            <li>Confocal frequency spacing between adjacent transverse orders is <span class="eq">FSR/2</span>.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Physical intuition first (what we expect)</h3>
      <p>
        A confocal cavity is “moderately focusing”: not as weak as a near-planar cavity, not as tight as a near-concentric cavity.
        So we expect a waist at the center and the spot size at the mirrors to be larger by a factor of order unity.
        Also, confocal cavities are famous for partial transverse-mode degeneracy: the Gouy phase per round trip is exactly <span class="eq">π</span>,
        which makes transverse modes shift by half a free-spectral-range steps.
      </p>

      <div class="eqwrap">
        <button class="copybtn" data-copy="FSR = c/(2d);  nu_qmn = (c/(2d)) * [ q + (m+n+1) * arccos(sqrt(g1*g2))/pi ]">Copy</button>
        <pre class="eq">FSR = c/(2d)
ν_qmn = (c/(2d)) · [ q + (m+n+1) · arccos(√(g1 g2))/π ]</pre>
        <div class="copyhint">These are the workhorse formulas for frequency structure of stable optical cavities.</div>
      </div>

      <article class="results" id="finalBlock">
        <h3>Final numeric answers (for d = 16 cm, λ₀ = 1 μm, ℛ = 0.995)</h3>
        <div class="kpi">
          <div class="k">
            <div class="label">(a) Mirror curvature (confocal)</div>
            <div class="val" id="ansR">R = 0.160 m</div>
            <div class="note">Symmetric confocal ⇒ R = d.</div>
          </div>
          <div class="k">
            <div class="label">(b) Waist of (0,0)</div>
            <div class="val" id="ansW0">w0 ≈ …</div>
            <div class="note">For confocal: zR = d/2.</div>
          </div>
          <div class="k">
            <div class="label">(c) HG(1,0) peak separation at mirror</div>
            <div class="val" id="ansDx">Δx ≈ …</div>
            <div class="note">Δx = 2 w0 (confocal symmetric).</div>
          </div>
          <div class="k">
            <div class="label">FSR</div>
            <div class="val" id="ansFSR">FSR ≈ …</div>
            <div class="note">FSR = c/(2d).</div>
          </div>
          <div class="k">
            <div class="label">(d) Resonances near ν₀=c/λ₀</div>
            <div class="val" id="ansNu">ν00 ≈ …<br/>ν10 ≈ …</div>
            <div class="note">Confocal: ν10 − ν00 ≈ FSR/2.</div>
          </div>
          <div class="k">
            <div class="label">(e) Distributed resonator loss</div>
            <div class="val" id="ansAlpha">αr ≈ …</div>
            <div class="note">Only mirror loss: exp(-αr·2d)=ℛ².</div>
          </div>
        </div>

        <div class="eqwrap" style="margin-top:12px; border-color:rgba(167,139,250,.28); background:rgba(167,139,250,.07)">
          <button class="copybtn" data-copy="" id="copyFinalBtn">Copy final results (plain text)</button>
          <pre class="eq" id="finalText">Loading…</pre>
          <div class="copyhint">Copies a clean, plain-text summary you can paste into notes or a report.</div>
        </div>
      </article>

      <h3>(a) Find the radii of curvature of the mirrors</h3>
      <p>
        A <strong>confocal</strong> resonator is one where each mirror is located at the other mirror’s focal plane (for spherical mirrors).
        For a <strong>symmetric confocal</strong> cavity (two identical mirrors), the standard condition is:
        the mirror separation equals the mirror radius of curvature:
      </p>
      <div class="eqwrap">
        <button class="copybtn" data-copy="Confocal symmetric cavity: R1 = R2 = R = d">Copy</button>
        <pre class="eq">Confocal (symmetric):   R1 = R2 = R = d</pre>
      </div>
      <p>
        With <span class="eq">d = 0.16 m</span>, we have
        <strong><span class="eq">R = 0.16 m = 16 cm</span></strong>.
        <br/>
        <em>Sanity check:</em> Stability requires <span class="eq">0 &lt; g1 g2 &lt; 1</span>.
        Here <span class="eq">g = 1 - d/R = 1 - 1 = 0</span>, so <span class="eq">g1 g2 = 0</span>, right at the confocal edge; it is still a standard stable boundary case for Gaussian eigenmodes (often treated as stable in practical optics).
      </p>

      <h3>(b) Find the waist of the (0,0) Gaussian mode</h3>
      <p>
        For a symmetric two-mirror cavity, the waist lies at the center. Let the waist be at <span class="eq">z=0</span>.
        Mirrors are at <span class="eq">z = ±d/2</span>. For a Gaussian beam:
      </p>
      <div class="eqwrap">
        <button class="copybtn" data-copy="w(z) = w0*sqrt(1 + (z/zR)^2);  zR = pi*w0^2/lambda">Copy</button>
        <pre class="eq">w(z) = w0 · √( 1 + (z/zR)^2 )
zR = π w0^2 / λ</pre>
      </div>
      <p>
        For a symmetric cavity with parameter <span class="eq">g = 1 - d/R</span>, the Rayleigh range is:
      </p>
      <div class="eqwrap">
        <button class="copybtn" data-copy="Symmetric cavity: zR = (d/2)*sqrt((1+g)/(1-g))">Copy</button>
        <pre class="eq">Symmetric cavity:   zR = (d/2) · √( (1+g)/(1-g) )</pre>
      </div>
      <p>
        In our confocal case, <span class="eq">R=d ⇒ g=0</span>, so
        <strong><span class="eq">zR = d/2</span></strong>.
        Therefore the waist satisfies <span class="eq">w0^2=(λ/π)zR</span>, giving:
      </p>
      <div class="eqwrap">
        <button class="copybtn" data-copy="Confocal symmetric: zR = d/2;  w0 = sqrt((lambda/pi)*(d/2))">Copy</button>
        <pre class="eq">Confocal symmetric:
zR = d/2
w0 = √( (λ/π) · (d/2) )</pre>
      </div>
      <p>
        Plugging in <span class="eq">λ0 = 1×10⁻⁶ m</span> and <span class="eq">d=0.16 m</span>:
        <span class="eq">zR = 0.08 m</span>, so
        <span class="eq">w0 = √( (1×10⁻⁶/π)·0.08 )</span>.
        Numerically this is shown in the Final Answers box (and updates with the slider).
      </p>

      <h3>(c) Sketch the (1,0) intensity distribution at a mirror and find peak separation</h3>
      <p>
        At a fixed longitudinal position (here, at the mirror plane), the Hermite–Gaussian field for mode (1,0) (in <span class="eq">x</span>) has the form
        <span class="eq">E(x) ∝ H1(√2 x/w) exp(-x^2/w^2)</span>,
        where <span class="eq">H1(u)=2u</span> and <span class="eq">w</span> is the beam radius at that plane.
        Thus, at the mirror where the beam radius is <span class="eq">wm = w(d/2)</span>,
      </p>
      <div class="eqwrap">
        <button class="copybtn" data-copy="At mirror: E_10(x) ∝ x * exp(-x^2/wm^2);  I_10(x) ∝ x^2 * exp(-2x^2/wm^2)">Copy</button>
        <pre class="eq">At a mirror (z = ±d/2):
E_10(x) ∝ x · exp( -x^2 / wm^2 )
I_10(x) ∝ x^2 · exp( -2x^2 / wm^2 )</pre>
      </div>
      <p>
        To locate the peaks, maximize <span class="eq">I(x) = x^2 exp(-2x^2/wm^2)</span>.
        Differentiate:
      </p>
      <div class="eqwrap">
        <button class="copybtn" data-copy="d/dx [ x^2 e^{-2x^2/wm^2} ] = 0  =>  x^2 = wm^2/2  =>  x_peak = ±wm/√2">Copy</button>
        <pre class="eq">Set dI/dx = 0:
I(x) = x^2 e^{-2x^2/wm^2}
⇒ dI/dx = 0 ⇒ x^2 = wm^2/2
⇒ x_peak = ± wm/√2</pre>
      </div>
      <p>
        So the distance between the two intensity maxima is
        <strong><span class="eq">Δx = 2(wm/√2) = √2·wm</span></strong>.
        For a confocal symmetric cavity, <span class="eq">zR = d/2</span>, so at the mirrors (<span class="eq">z=d/2</span>):
        <span class="eq">wm = w0 √(1+(z/zR)^2)=w0√(1+1)=w0√2</span>.
        Therefore,
      </p>
      <div class="eqwrap">
        <button class="copybtn" data-copy="Confocal: wm = w0*sqrt(2)  =>  Δx = sqrt(2)*wm = 2*w0">Copy</button>
        <pre class="eq">Confocal:   wm = w0 √2
⇒ Δx = √2·wm = √2·(w0 √2) = 2 w0</pre>
      </div>
      <p>
        This is a pleasantly simple result: <strong>the two HG(1,0) lobes at a mirror are separated by exactly <span class="eq">2 w0</span></strong> for a symmetric confocal cavity.
      </p>

      <h3>(d) Determine resonance frequencies of the (0,0) and (1,0) modes</h3>
      <p>
        The resonant frequencies for a stable two-mirror cavity are:
      </p>
      <div class="eqwrap">
        <button class="copybtn" data-copy="nu_qmn = (c/(2d)) * ( q + (m+n+1)*arccos(sqrt(g1*g2))/pi )">Copy</button>
        <pre class="eq">ν_qmn = (c/(2d)) · [ q + (m+n+1) · arccos(√(g1 g2))/π ]</pre>
      </div>
      <p>
        For a symmetric cavity, <span class="eq">g1=g2=g</span>. In the confocal case <span class="eq">g=0</span>, so
        <span class="eq">√(g1 g2)=0</span> and <span class="eq">arccos(0)=π/2</span>. Therefore:
      </p>
      <div class="eqwrap">
        <button class="copybtn" data-copy="Confocal: arccos(0)=pi/2 => nu_qmn = (c/(2d))*( q + (m+n+1)/2 )">Copy</button>
        <pre class="eq">Confocal: arccos(0)=π/2
⇒ ν_qmn = (c/(2d)) · [ q + (m+n+1)/2 ]</pre>
      </div>
      <p>
        For (0,0): <span class="eq">m+n+1=1</span>, so
        <span class="eq">ν_q00 = FSR·(q + 1/2)</span>.
        For (1,0): <span class="eq">m+n+1=2</span>, so
        <span class="eq">ν_q10 = FSR·(q + 1)</span>.
      </p>
      <p>
        A key takeaway is the transverse frequency shift:
        <strong><span class="eq">ν_q10 − ν_q00 = FSR/2</span></strong>
        (if you compare the same longitudinal index <span class="eq">q</span>).
        Numerically, with <span class="eq">d=0.16 m</span>, <span class="eq">FSR ≈ 9.3685×10⁸ Hz</span>, so <span class="eq">FSR/2 ≈ 4.6843×10⁸ Hz</span>.
      </p>
      <p>
        If you want the resonances closest to the laser frequency <span class="eq">ν0=c/λ0</span>, pick integers <span class="eq">q</span> that make each expression as close as possible to <span class="eq">ν0</span>.
        For <span class="eq">λ0=1 μm</span>, <span class="eq">ν0/FSR = 320000</span> exactly, so:
        (1,0) can hit <span class="eq">ν0</span> exactly with <span class="eq">q=319999</span>, while (0,0) sits half an FSR away.
        The live calculator below displays these nearest resonances.
      </p>

      <h3>(e) Distributed resonator loss coefficient α<sub>r</sub> from mirror reflectance only</h3>
      <p>
        If the only power loss comes from imperfect mirror reflectance, then after one <em>round trip</em> (distance <span class="eq">2d</span>)
        the intracavity power is multiplied by <span class="eq">ℛ1 ℛ2</span>. Here <span class="eq">ℛ1=ℛ2=ℛ</span>, so it is <span class="eq">ℛ^2</span>.
        A distributed (exponential) loss model says:
      </p>
      <div class="eqwrap">
        <button class="copybtn" data-copy="exp(-alpha_r * 2d) = R_power^2  =>  alpha_r = -(1/(2d)) ln(R_power^2) = -(1/d) ln(R_power)">Copy</button>
        <pre class="eq">exp( -αr · 2d ) = ℛ^2
⇒ αr = -(1/(2d)) ln(ℛ^2) = -(1/d) ln(ℛ)</pre>
      </div>
      <p>
        With <span class="eq">ℛ=0.995</span> and <span class="eq">d=0.16 m</span>, this yields <span class="eq">αr ≈ 3.13×10⁻² m⁻¹</span>
        (shown precisely in the Final Answers box).
      </p>

      <div class="card">
        <h3>Sanity checks</h3>
        <ul>
          <li><strong>Units:</strong> <span class="eq">w0</span> comes from <span class="eq">√(λ·d)</span> → meters. <span class="eq">αr</span> from <span class="eq">ln(·)/d</span> → 1/m.</li>
          <li><strong>Limiting behavior:</strong> If <span class="eq">ℛ→1</span>, then <span class="eq">ln(ℛ)→0</span> so <span class="eq">αr→0</span> (lossless cavity). Good.</li>
          <li><strong>Mode spacing:</strong> Confocal gives <span class="eq">FSR/2</span> transverse shift—consistent with the classic confocal degeneracy structure.</li>
          <li><strong>Geometry check:</strong> confocal implies <span class="eq">zR=d/2</span>, so beam expands by √2 from waist to mirror—reasonable for “moderate focusing.”</li>
        </ul>
      </div>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the final formulas</h3>
      <ul>
        <li><strong>Waist scaling:</strong> <span class="eq">w0 = √((λ/π)(d/2))</span> shows the waist grows like <span class="eq">√λ</span> and <span class="eq">√d</span>. Longer cavities or longer wavelengths make larger modes.</li>
        <li><strong>HG(1,0) lobe spacing:</strong> <span class="eq">Δx=2w0</span> (confocal) means the transverse pattern at the mirror is set directly by the central waist.</li>
        <li><strong>Frequency structure:</strong> <span class="eq">ν_qmn = FSR·(q + (m+n+1)/2)</span> (confocal) means changing <span class="eq">m+n</span> by 1 shifts resonances by <span class="eq">FSR/2</span>.</li>
        <li><strong>Loss coefficient:</strong> <span class="eq">αr = -(1/d)ln(ℛ)</span> shows that for a fixed reflectance, shorter cavities correspond to larger effective distributed loss (same fractional loss crammed into less length).</li>
      </ul>

      <h3>How changing parameters affects outcomes (connect to interactive plots)</h3>
      <ul>
        <li>Increase <strong>wavelength</strong> → <span class="eq">w0</span> increases → beam envelope plot expands and the HG(1,0) peaks move farther apart.</li>
        <li>Increase <strong>wavelength</strong> → optical frequency <span class="eq">ν0=c/λ</span> decreases → nearest cavity resonances shift downward accordingly.</li>
        <li>Mirror reflectance (fixed here) sets <span class="eq">αr</span>; in this simplified model it does not depend on wavelength.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        You can derive the same results using the <strong>ABCD matrix</strong> for a round trip and the complex beam parameter
        <span class="eq">q(z)=z + i zR</span>.
        The self-consistency condition is <span class="eq">q = (Aq+B)/(Cq+D)</span>.
        Solving for <span class="eq">q</span> gives <span class="eq">zR</span>, hence <span class="eq">w0</span>. The Gouy phase then emerges from the round-trip eigenvalue phase.
      </p>

      <div class="card">
        <h3>Concept check (quick self-test)</h3>
        <ul>
          <li><strong>Q:</strong> Why does the (1,0) intensity have two peaks even though the (1,0) field is odd? <br/><strong>A:</strong> Intensity is proportional to |field|², so it becomes even and forms two symmetric lobes.</li>
          <li><strong>Q:</strong> What sets the FSR? <br/><strong>A:</strong> The round-trip time: <span class="eq">FSR=c/(2d)</span>.</li>
          <li><strong>Q:</strong> What role does Gouy phase play in resonance frequencies? <br/><strong>A:</strong> It adds a transverse-mode-dependent phase per round trip, shifting resonant frequencies by an amount proportional to <span class="eq">m+n+1</span>.</li>
          <li><strong>Q:</strong> If reflectance increases from 0.995 to 0.999, what happens to <span class="eq">αr</span>? <br/><strong>A:</strong> It decreases because <span class="eq">ln(ℛ)</span> becomes closer to 0.</li>
        </ul>
      </div>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="controls">
        <div class="control">
          <label for="lambdaSlider">
            Wavelength λ (μm)
            <span class="readout" id="lambdaReadout">1.000 μm</span>
          </label>
          <input id="lambdaSlider" type="range" min="0.50" max="2.00" step="0.005" value="1.000"/>
          <div class="copyhint">This single control updates the diagram, both plots, and all computed numbers live.</div>
        </div>
      </div>

      <div class="canvasRow">
        <figure>
          <canvas id="diagram"></canvas>
          <figcaption>
            <strong>Diagram:</strong> symmetric confocal cavity (mirrors at z = ±d/2) with Gaussian envelope.
            Labels show <span class="eq">d</span>, <span class="eq">R</span>, <span class="eq">w0</span> at center, and <span class="eq">wm</span> at mirrors.
          </figcaption>
        </figure>

        <figure>
          <canvas id="plotBeam"></canvas>
          <figcaption>
            <strong>Main plot:</strong> beam radius <span class="eq">w(z)</span> along the cavity axis from −d/2 to +d/2 (units: cm on z, mm on w).
            Vertical lines mark the mirror planes.
          </figcaption>
        </figure>
      </div>

      <div class="canvasRow">
        <figure>
          <canvas id="plotIntensity"></canvas>
          <figcaption>
            <strong>Secondary plot:</strong> HG(1,0) intensity profile at a mirror, <span class="eq">I(x) ∝ x² exp(-2x²/wm²)</span>.
            The two maxima are marked; their separation is <span class="eq">Δx</span>.
          </figcaption>
        </figure>

        <div class="card" style="height:100%">
          <h3>What changes when you move the slider?</h3>
          <ul>
            <li><strong>Beam sizes:</strong> <span class="eq">w0 ∝ √λ</span> and <span class="eq">wm = √2 w0</span> expand/contract, so the envelope and HG peaks shift.</li>
            <li><strong>Resonance frequencies:</strong> the target laser frequency <span class="eq">ν0=c/λ</span> changes, so the nearest cavity resonances for (0,0) and (1,0) move.</li>
            <li><strong>Mirror geometry:</strong> remains confocal with <span class="eq">R=d</span> (fixed), so only the optical mode changes, not the hardware.</li>
          </ul>
          <div class="printNote" style="margin-top:12px">
            Note: interactivity is disabled on paper; numbers shown correspond to the last on-screen value.
          </div>
        </div>
      </div>
    </section>
  </main>
</div>

<footer>
  <div>
    <strong>Notes:</strong> This solution uses standard Gaussian resonator theory (paraxial optics). Mirror reflectance is treated as a power reflectance ℛ.
    The interactive slider varies wavelength for learning; the problem’s requested numeric answers correspond to λ₀ = 1 μm.
  </div>
</footer>

<script>
(function(){
  // ---------- Utilities ----------
  const c = 299792458;               // m/s
  const d = 0.16;                    // m (fixed by the problem)
  const RmirrorPower = 0.995;        // ℛ (power reflectance per mirror)
  const Rcurv = d;                   // confocal symmetric: R = d

  function fmtSI(x, unit, digits=4){
    // small helper: choose scientific for very big/small
    const ax = Math.abs(x);
    if((ax !== 0 && (ax < 1e-3 || ax >= 1e6))) return x.toExponential(digits) + " " + unit;
    // else fixed-ish
    const s = (ax >= 1000) ? x.toFixed(0) : (ax >= 10 ? x.toFixed(2) : x.toFixed(4));
    return s + " " + unit;
  }
  function fmtHz(x){
    const ax = Math.abs(x);
    if(ax >= 1e12) return (x/1e12).toFixed(6) + " THz";
    if(ax >= 1e9)  return (x/1e9).toFixed(6)  + " GHz";
    if(ax >= 1e6)  return (x/1e6).toFixed(6)  + " MHz";
    if(ax >= 1e3)  return (x/1e3).toFixed(6)  + " kHz";
    return x.toFixed(3) + " Hz";
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  // Canvas setup with DPR for crisp rendering
  function setupCanvas(canvas){
    const ctx = canvas.getContext("2d");
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(320, rect.width);
      const h = Math.max(260, rect.height);
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {w, h, dpr};
    }
    return {ctx, resize};
  }

  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
    // box: {x,y,w,h} in CSS pixels
    const {x,y,w,h} = box;
    ctx.save();
    // background
    ctx.fillStyle = "rgba(0,0,0,0)";
    ctx.fillRect(x,y,w,h);

    // plot area margins
    const mL = 52, mR = 18, mT = 34, mB = 44;
    const px = x + mL, py = y + mT, pw = w - mL - mR, ph = h - mT - mB;

    // helpers
    const X = t => px + (t - xMin) * (pw/(xMax-xMin));
    const Y = t => py + ph - (t - yMin) * (ph/(yMax-yMin));

    // grid & ticks
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;

    function niceTicks(min,max,count){
      const span = max-min;
      const raw = span / count;
      const pow = Math.pow(10, Math.floor(Math.log10(raw)));
      const n = raw/pow;
      let step;
      if(n<1.5) step=1*pow;
      else if(n<3) step=2*pow;
      else if(n<7) step=5*pow;
      else step=10*pow;
      const start = Math.ceil(min/step)*step;
      const ticks=[];
      for(let v=start; v<=max+1e-12; v+=step) ticks.push(v);
      return {step, ticks};
    }

    const xt = niceTicks(xMin,xMax,6);
    const yt = niceTicks(yMin,yMax,6);

    // vertical grid
    for(const t of xt.ticks){
      const xx = X(t);
      ctx.beginPath();
      ctx.moveTo(xx, py);
      ctx.lineTo(xx, py+ph);
      ctx.stroke();
    }
    // horizontal grid
    for(const t of yt.ticks){
      const yy = Y(t);
      ctx.beginPath();
      ctx.moveTo(px, yy);
      ctx.lineTo(px+pw, yy);
      ctx.stroke();
    }

    // axes lines
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 1.2;
    ctx.beginPath(); ctx.moveTo(px, py+ph); ctx.lineTo(px+pw, py+ph); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px, py+ph); ctx.stroke();

    // tick labels
    ctx.fillStyle = "rgba(234,240,255,0.85)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

    for(const t of xt.ticks){
      const xx = X(t);
      ctx.fillText((Math.abs(t) < 1e-12 ? "0" : t.toFixed(1)), xx-10, py+ph+18);
    }
    for(const t of yt.ticks){
      const yy = Y(t);
      ctx.fillText(t.toFixed(2), px-44, yy+4);
    }

    // labels & title
    ctx.fillStyle = "rgba(234,240,255,0.92)";
    ctx.font = "13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(title, x+12, y+20);

    ctx.fillStyle = "rgba(184,195,230,0.95)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(xLabel, px+pw/2-18, py+ph+36);

    // y label rotated
    ctx.save();
    ctx.translate(x+14, py+ph/2+18);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    ctx.restore();
    return {px,py,pw,ph,X,Y};
  }

  function drawLegend(ctx, items, x, y){
    ctx.save();
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textBaseline = "middle";
    let yy = y;
    for(const it of items){
      ctx.strokeStyle = it.stroke;
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(x, yy); ctx.lineTo(x+18, yy); ctx.stroke();
      if(it.dash){
        ctx.setLineDash(it.dash);
        ctx.beginPath(); ctx.moveTo(x, yy); ctx.lineTo(x+18, yy); ctx.stroke();
        ctx.setLineDash([]);
      }
      ctx.fillStyle = "rgba(234,240,255,0.88)";
      ctx.fillText(it.label, x+24, yy);
      yy += 16;
    }
    ctx.restore();
  }

  // ---------- Physics (confocal symmetric) ----------
  function compute(lambda){
    // lambda in meters
    const g = 1 - d/Rcurv;        // 0 for confocal
    const zR = (d/2) * Math.sqrt((1+g)/(1-g));  // confocal -> d/2
    const w0 = Math.sqrt((lambda/Math.PI) * zR);
    const wm = w0 * Math.sqrt(1 + Math.pow((d/2)/zR, 2)); // = w0*sqrt(2)
    const dxPeaks = Math.SQRT2 * wm; // general HG10 at mirror
    const FSR = c/(2*d);
    const nu0 = c/lambda;

    // nearest integer q for each mode, near nu0
    // confocal: nu_q00 = FSR*(q+1/2), nu_q10 = FSR*(q+1)
    const q00 = Math.round(nu0/FSR - 0.5);
    const q10 = Math.round(nu0/FSR - 1.0);

    const nu00 = FSR*(q00 + 0.5);
    const nu10 = FSR*(q10 + 1.0);

    const alpha = -(1/d)*Math.log(RmirrorPower); // 1/m

    return {lambda, g, zR, w0, wm, dxPeaks, FSR, nu0, q00, q10, nu00, nu10, alpha};
  }

  // ---------- DOM ----------
  const lambdaSlider = document.getElementById("lambdaSlider");
  const lambdaReadout = document.getElementById("lambdaReadout");

  const ansR = document.getElementById("ansR");
  const ansW0 = document.getElementById("ansW0");
  const ansDx = document.getElementById("ansDx");
  const ansFSR = document.getElementById("ansFSR");
  const ansNu = document.getElementById("ansNu");
  const ansAlpha = document.getElementById("ansAlpha");
  const finalText = document.getElementById("finalText");
  const copyFinalBtn = document.getElementById("copyFinalBtn");

  // canvases
  const diagram = setupCanvas(document.getElementById("diagram"));
  const plotBeam = setupCanvas(document.getElementById("plotBeam"));
  const plotIntensity = setupCanvas(document.getElementById("plotIntensity"));

  // Observe resizes
  const ro = new ResizeObserver(() => render());
  ro.observe(document.getElementById("diagram"));
  ro.observe(document.getElementById("plotBeam"));
  ro.observe(document.getElementById("plotIntensity"));

  // Copy buttons (equations)
  function wireCopyButtons(){
    document.querySelectorAll(".copybtn[data-copy]").forEach(btn=>{
      btn.addEventListener("click", async ()=>{
        const text = btn.getAttribute("data-copy") || "";
        try{
          await navigator.clipboard.writeText(text);
          const old = btn.textContent;
          btn.textContent = "Copied ✓";
          setTimeout(()=>btn.textContent=old, 900);
        }catch(e){
          const old = btn.textContent;
          btn.textContent = "Copy failed";
          setTimeout(()=>btn.textContent=old, 900);
        }
      });
    });
  }
  wireCopyButtons();

  copyFinalBtn.addEventListener("click", async ()=>{
    try{
      await navigator.clipboard.writeText(finalText.textContent);
      const old = copyFinalBtn.textContent;
      copyFinalBtn.textContent = "Copied ✓";
      setTimeout(()=>copyFinalBtn.textContent=old, 900);
    }catch(e){
      const old = copyFinalBtn.textContent;
      copyFinalBtn.textContent = "Copy failed";
      setTimeout(()=>copyFinalBtn.textContent=old, 900);
    }
  });

  // ---------- Drawing ----------
  function renderDiagram(ctx, W, H, data){
    ctx.clearRect(0,0,W,H);

    // layout
    const pad = 18;
    const x0 = pad, x1 = W - pad;
    const yMid = H*0.52;

    const cavityLeft = x0 + 32;
    const cavityRight = x1 - 32;

    // mirror positions
    const mW = 22;
    const leftMirrorX = cavityLeft;
    const rightMirrorX = cavityRight;

    // beam envelope scaling
    // show z from -d/2 to +d/2 mapped to [leftMirrorX, rightMirrorX]
    function xFromZ(z){
      return leftMirrorX + (z + d/2) * ( (rightMirrorX-leftMirrorX)/d );
    }

    // scale beam radius (meters) to pixels
    const wMax = data.wm * 1.25;
    const yScale = (H*0.28) / (wMax || 1e-9);

    // draw mirrors (curved)
    ctx.save();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(234,240,255,0.70)";
    ctx.fillStyle = "rgba(255,255,255,0.04)";

    function drawMirror(x, side){
      const r = 120;
      const h = H*0.55;
      const top = yMid - h/2;
      const bottom = yMid + h/2;

      ctx.beginPath();
      if(side === "L"){
        ctx.arc(x + r, yMid, r, Math.PI*0.72, Math.PI*1.28);
      }else{
        ctx.arc(x - r, yMid, r, -Math.PI*0.28, Math.PI*0.28);
      }
      ctx.stroke();

      // small thickness indication
      ctx.beginPath();
      ctx.moveTo(x + (side==="L"? -mW: mW), top);
      ctx.lineTo(x + (side==="L"? -mW: mW), bottom);
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.stroke();
    }
    drawMirror(leftMirrorX, "L");
    drawMirror(rightMirrorX, "R");
    ctx.restore();

    // beam envelope
    ctx.save();
    ctx.strokeStyle = "rgba(125,211,252,0.95)";
    ctx.lineWidth = 2.2;

    // top envelope
    ctx.beginPath();
    for(let i=0;i<=180;i++){
      const z = -d/2 + (d*i/180);
      const x = xFromZ(z);
      const w = data.w0*Math.sqrt(1+(z/data.zR)*(z/data.zR));
      const y = yMid - w*yScale;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // bottom envelope
    ctx.beginPath();
    for(let i=0;i<=180;i++){
      const z = -d/2 + (d*i/180);
      const x = xFromZ(z);
      const w = data.w0*Math.sqrt(1+(z/data.zR)*(z/data.zR));
      const y = yMid + w*yScale;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // waist marker
    const xWaist = xFromZ(0);
    ctx.strokeStyle = "rgba(167,139,250,0.85)";
    ctx.lineWidth = 1.6;
    ctx.beginPath();
    ctx.moveTo(xWaist, yMid - data.w0*yScale);
    ctx.lineTo(xWaist, yMid + data.w0*yScale);
    ctx.stroke();

    // mirror spot marker (right)
    ctx.strokeStyle = "rgba(134,239,172,0.85)";
    ctx.beginPath();
    ctx.moveTo(rightMirrorX, yMid - data.wm*yScale);
    ctx.lineTo(rightMirrorX, yMid + data.wm*yScale);
    ctx.stroke();

    ctx.restore();

    // dimension labels: d and R
    ctx.save();
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "rgba(234,240,255,0.90)";
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 1.2;

    // d arrow
    const yDim = H*0.20;
    ctx.beginPath();
    ctx.moveTo(leftMirrorX, yDim);
    ctx.lineTo(rightMirrorX, yDim);
    ctx.stroke();
    // arrowheads
    function arrow(x,y,dir){
      ctx.beginPath();
      ctx.moveTo(x,y);
      ctx.lineTo(x+dir*10,y-5);
      ctx.lineTo(x+dir*10,y+5);
      ctx.closePath();
      ctx.fillStyle = "rgba(255,255,255,0.35)";
      ctx.fill();
    }
    arrow(leftMirrorX, yDim, +1);
    arrow(rightMirrorX, yDim, -1);

    const dcm = (d*100).toFixed(1);
    ctx.fillStyle = "rgba(184,195,230,0.95)";
    ctx.fillText("d = " + dcm + " cm", (leftMirrorX+rightMirrorX)/2 - 34, yDim - 8);

    // R label
    ctx.fillStyle = "rgba(184,195,230,0.95)";
    ctx.fillText("R = d (confocal)", leftMirrorX + 6, H*0.86);

    // w0 and wm labels
    ctx.fillStyle = "rgba(167,139,250,0.95)";
    ctx.fillText("w0", xWaist + 6, yMid - data.w0*yScale - 6);
    ctx.fillStyle = "rgba(134,239,172,0.95)";
    ctx.fillText("wm", rightMirrorX - 26, yMid - data.wm*yScale - 6);

    // title
    ctx.fillStyle = "rgba(234,240,255,0.92)";
    ctx.font = "13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Symmetric Confocal Resonator (geometry + Gaussian envelope)", 14, 22);
    ctx.restore();
  }

  function renderBeamPlot(ctx, W, H, data){
    ctx.clearRect(0,0,W,H);
    const box = {x:0,y:0,w:W,h:H};

    // z axis in cm, w axis in mm
    const zMin = -d/2*100, zMax = d/2*100; // cm
    const wMaxMm = data.wm*1000*1.35;
    const yMin = 0, yMax = wMaxMm;

    const ax = drawAxes(ctx, box, zMin, zMax, yMin, yMax,
                        "z (cm)", "w(z) (mm)",
                        "Beam Radius Along Cavity Axis");

    // draw mirrors as vertical dashed lines at z=±d/2
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.45)";
    ctx.lineWidth = 1.2;
    ctx.setLineDash([6,6]);
    [zMin, zMax].forEach(zc=>{
      const x = ax.X(zc);
      ctx.beginPath();
      ctx.moveTo(x, ax.py);
      ctx.lineTo(x, ax.py+ax.ph);
      ctx.stroke();
    });
    ctx.setLineDash([]);
    ctx.restore();

    // w(z)
    ctx.save();
    ctx.strokeStyle = "rgba(125,211,252,0.95)";
    ctx.lineWidth = 2.4;
    ctx.beginPath();
    const N = 220;
    for(let i=0;i<=N;i++){
      const z = -d/2 + d*i/N;        // m
      const zc = z*100;             // cm
      const w = data.w0*Math.sqrt(1+(z/data.zR)*(z/data.zR)); // m
      const wmm = w*1000;
      const x = ax.X(zc), y = ax.Y(wmm);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // waist marker at z=0
    ctx.strokeStyle = "rgba(167,139,250,0.85)";
    ctx.lineWidth = 1.8;
    const x0 = ax.X(0);
    ctx.beginPath(); ctx.moveTo(x0, ax.py); ctx.lineTo(x0, ax.py+ax.ph); ctx.stroke();
    ctx.restore();

    // legend
    drawLegend(ctx, [
      {stroke:"rgba(125,211,252,0.95)", label:"w(z) envelope"},
      {stroke:"rgba(255,255,255,0.45)", label:"mirror planes (z=±d/2)", dash:[6,6]},
      {stroke:"rgba(167,139,250,0.85)", label:"waist plane (z=0)"}
    ], ax.px+10, ax.py+16);

    // annotate w0 and wm
    ctx.save();
    ctx.fillStyle = "rgba(184,195,230,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    ctx.fillText("w0 = " + (data.w0*1000).toFixed(3) + " mm", ax.px+10, ax.py+ax.ph-26);
    ctx.fillText("wm = " + (data.wm*1000).toFixed(3) + " mm", ax.px+10, ax.py+ax.ph-10);
    ctx.restore();
  }

  function renderIntensityPlot(ctx, W, H, data){
    ctx.clearRect(0,0,W,H);
    const box = {x:0,y:0,w:W,h:H};

    // x in mm, normalized intensity
    const xMax = data.wm*1000*3.0;
    const xMin = -xMax;
    const yMin = 0;
    // compute peak intensity for scaling
    const xPeak = (data.wm/Math.SQRT2);
    const Ipeak = (xPeak*xPeak) * Math.exp(-2*(xPeak*xPeak)/(data.wm*data.wm));
    const yMax = 1.15;

    const ax = drawAxes(ctx, box, xMin, xMax, yMin, yMax,
                        "x at mirror (mm)", "normalized I₁₀(x)",
                        "HG(1,0) Intensity at a Mirror");

    // compute and draw
    ctx.save();
    ctx.strokeStyle = "rgba(134,239,172,0.95)";
    ctx.lineWidth = 2.4;
    ctx.beginPath();
    const N = 320;
    for(let i=0;i<=N;i++){
      const xmm = xMin + (xMax-xMin)*i/N;
      const x = xmm/1000; // m
      const I = (x*x) * Math.exp(-2*(x*x)/(data.wm*data.wm));
      const In = I / Ipeak; // normalize
      const xx = ax.X(xmm);
      const yy = ax.Y(In);
      if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
    }
    ctx.stroke();

    // mark peaks at ±wm/√2
    const peakMm = (data.wm/Math.SQRT2)*1000;
    ctx.fillStyle = "rgba(255,255,255,0.88)";
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 1.2;

    function mark(xmm){
      const xx = ax.X(xmm);
      const yy = ax.Y(1.0);
      ctx.beginPath();
      ctx.arc(xx, yy, 4.5, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(xx, ax.py);
      ctx.lineTo(xx, ax.py+ax.ph);
      ctx.setLineDash([5,5]);
      ctx.stroke();
      ctx.setLineDash([]);
    }
    mark(-peakMm);
    mark(+peakMm);

    // separation arrow
    const yArrow = ax.py + ax.ph*0.18;
    const xL = ax.X(-peakMm);
    const xR = ax.X(+peakMm);
    ctx.strokeStyle = "rgba(125,211,252,0.80)";
    ctx.fillStyle = "rgba(125,211,252,0.25)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(xL, yArrow);
    ctx.lineTo(xR, yArrow);
    ctx.stroke();
    // arrowheads
    function tri(x,y,dir){
      ctx.beginPath();
      ctx.moveTo(x,y);
      ctx.lineTo(x+dir*10,y-5);
      ctx.lineTo(x+dir*10,y+5);
      ctx.closePath();
      ctx.fill();
    }
    tri(xL, yArrow, +1);
    tri(xR, yArrow, -1);

    ctx.fillStyle = "rgba(184,195,230,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    ctx.fillText("Δx = " + (data.dxPeaks*1000).toFixed(3) + " mm", (xL+xR)/2 - 52, yArrow - 8);

    // legend
    drawLegend(ctx, [
      {stroke:"rgba(134,239,172,0.95)", label:"I10(x) at mirror (normalized)"},
      {stroke:"rgba(255,255,255,0.35)", label:"peaks at x=±wm/√2", dash:[5,5]}
    ], ax.px+10, ax.py+16);

    ctx.restore();
  }

  function updateNumbers(data){
    // Fixed (a)
    ansR.textContent = "R = " + Rcurv.toFixed(3) + " m (16 cm)";

    // w0
    ansW0.innerHTML = "w0 = " + (data.w0*1000).toFixed(3) + " mm";
    // Δx
    ansDx.innerHTML = "Δx = " + (data.dxPeaks*1000).toFixed(3) + " mm";
    // FSR
    ansFSR.textContent = "FSR = " + fmtHz(data.FSR);

    // resonance frequencies
    const det00 = data.nu00 - data.nu0;
    const det10 = data.nu10 - data.nu0;

    ansNu.innerHTML =
      "ν₀ = " + fmtHz(data.nu0) + "<br/>" +
      "ν00 (q=" + data.q00 + ") = " + fmtHz(data.nu00) + "  (Δ=" + fmtHz(det00) + ")<br/>" +
      "ν10 (q=" + data.q10 + ") = " + fmtHz(data.nu10) + "  (Δ=" + fmtHz(det10) + ")";

    // alpha
    ansAlpha.textContent = "αr = " + data.alpha.toFixed(5) + " m⁻¹";

    const text =
`Symmetric confocal resonator (d = 0.16 m, λ = ${(data.lambda*1e6).toFixed(3)} µm, ℛ = 0.995 each, n=1)

(a) Mirror radii of curvature:
    R1 = R2 = R = d = 0.16 m

(b) Fundamental (0,0) waist:
    zR = d/2 = 0.08 m
    w0 = sqrt((λ/pi)*(d/2)) = ${(data.w0*1000).toFixed(6)} mm

(c) HG(1,0) at a mirror (z = ±d/2):
    I10(x) ∝ x^2 exp(-2x^2/wm^2), with wm = w0*sqrt(2) = ${(data.wm*1000).toFixed(6)} mm
    Peaks at x = ±wm/sqrt(2) ⇒ peak separation Δx = sqrt(2)*wm = 2*w0
    Δx = ${(data.dxPeaks*1000).toFixed(6)} mm

(d) Resonance frequencies (confocal):
    FSR = c/(2d) = ${data.FSR.toFixed(3)} Hz
    νqmn = FSR * [ q + (m+n+1)/2 ]
    Nearest to ν0=c/λ: ν0 = ${data.nu0.toFixed(3)} Hz
    ν00 = ${(data.nu00).toFixed(3)} Hz  (q=${data.q00})
    ν10 = ${(data.nu10).toFixed(3)} Hz  (q=${data.q10})

(e) Distributed resonator loss coefficient (mirror loss only):
    exp(-αr*2d) = ℛ^2  ⇒  αr = -(1/d) ln(ℛ) = ${data.alpha.toFixed(8)} m^-1
`;
    finalText.textContent = text;
  }

  function render(){
    const lambdaUm = parseFloat(lambdaSlider.value);
    const lambda = lambdaUm * 1e-6;
    lambdaReadout.textContent = lambdaUm.toFixed(3) + " μm";

    const data = compute(lambda);
    updateNumbers(data);

    // resize canvases and draw
    const d0 = diagram.resize();
    renderDiagram(diagram.ctx, d0.w, d0.h, data);

    const p1 = plotBeam.resize();
    renderBeamPlot(plotBeam.ctx, p1.w, p1.h, data);

    const p2 = plotIntensity.resize();
    renderIntensityPlot(plotIntensity.ctx, p2.w, p2.h, data);

    // Update the dedicated final-copy button payload (so it matches live values)
    copyFinalBtn.setAttribute("data-copy", finalText.textContent);
  }

  lambdaSlider.addEventListener("input", render);

  // initial render at λ0 = 1 μm
  render();
})();
</script>
</body>
</html>
