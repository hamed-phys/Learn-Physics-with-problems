<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ray Position in Unstable Optical Resonators (ABCD Matrix Method)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1733;
      --card:#111c3e;
      --ink:#e9eefc;
      --muted:#b8c3ea;
      --faint:rgba(233,238,252,.12);
      --faint2:rgba(233,238,252,.08);
      --accent:#7ee7ff;
      --accent2:#a78bfa;
      --good:#7CFFB2;
      --warn:#ffd166;
      --bad:#ff6b6b;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --serif: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;
      --radius: 18px;
      --radius2: 22px;
    }

    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1200px 700px at 15% 10%, rgba(126,231,255,.10), transparent 55%),
        radial-gradient(900px 600px at 85% 20%, rgba(167,139,250,.10), transparent 55%),
        radial-gradient(900px 700px at 50% 95%, rgba(124,255,178,.07), transparent 60%),
        linear-gradient(180deg, #070a14, #0b1020 35%, #070a14);
      line-height:1.55;
    }

    header{
      padding:32px 18px 14px;
      max-width:1160px;
      margin:0 auto;
    }
    .title{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
      padding:18px 18px 16px;
      border:1px solid var(--faint);
      background: linear-gradient(180deg, rgba(17,28,62,.85), rgba(15,23,51,.72));
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .title:before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(600px 200px at 20% 10%, rgba(126,231,255,.16), transparent 60%),
        radial-gradient(500px 220px at 80% 30%, rgba(167,139,250,.14), transparent 62%);
      pointer-events:none;
      filter: blur(2px);
    }
    .title > *{position:relative}
    h1{
      margin:0;
      font-size: clamp(22px, 2.4vw, 34px);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      max-width: 85ch;
      font-size: 14.5px;
    }

    main{
      max-width:1160px;
      margin: 0 auto;
      padding: 14px 18px 42px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 18px;
      align-items:start;
    }

    nav.toc{
      position: sticky;
      top: 12px;
      align-self:start;
      background: linear-gradient(180deg, rgba(17,28,62,.9), rgba(15,23,51,.76));
      border:1px solid var(--faint);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:14px 14px 10px;
      overflow:hidden;
    }
    nav.toc h2{
      margin: 0 0 8px;
      font-size: 13px;
      letter-spacing:.12em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .toc a{
      display:block;
      padding:8px 10px;
      margin:6px 0;
      border-radius: 12px;
      color: var(--ink);
      text-decoration:none;
      border: 1px solid transparent;
      background: rgba(233,238,252,.04);
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      font-size: 14px;
    }
    .toc a:hover{
      transform: translateY(-1px);
      background: rgba(126,231,255,.07);
      border-color: rgba(126,231,255,.20);
    }

    article{
      min-width: 0;
      display:flex;
      flex-direction:column;
      gap: 14px;
    }

    section{
      background: linear-gradient(180deg, rgba(17,28,62,.86), rgba(15,23,51,.74));
      border:1px solid var(--faint);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      padding: 18px 18px 16px;
      overflow:hidden;
      position:relative;
    }
    section:after{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(800px 160px at 10% 0%, rgba(126,231,255,.06), transparent 60%);
      pointer-events:none;
    }
    section > *{position:relative}
    section h2{
      margin:0 0 10px;
      font-size: 18px;
      letter-spacing:.2px;
    }
    h3{
      margin: 12px 0 8px;
      font-size: 15.5px;
      color: var(--ink);
    }
    p{margin: 8px 0; color: var(--ink)}
    ul{margin: 8px 0 8px 20px; color: var(--ink)}
    li{margin: 6px 0}
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
    }
    .card{
      background: rgba(233,238,252,.04);
      border:1px solid rgba(233,238,252,.10);
      border-radius: 16px;
      padding: 12px 12px 10px;
    }
    .callout{
      border-left: 4px solid var(--accent);
      background: rgba(126,231,255,.06);
    }
    .callout.warn{border-left-color: var(--warn); background: rgba(255,209,102,.07)}
    .callout.bad{border-left-color: var(--bad); background: rgba(255,107,107,.06)}
    .callout.good{border-left-color: var(--good); background: rgba(124,255,178,.06)}
    .kbadge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 4px 10px;
      border: 1px solid rgba(233,238,252,.14);
      background: rgba(233,238,252,.05);
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
    }
    .eqbox{
      margin: 10px 0 6px;
      padding: 12px 12px 10px;
      border-radius: 16px;
      border:1px solid rgba(233,238,252,.12);
      background: rgba(0,0,0,.18);
      overflow:auto;
      position:relative;
    }
    .eq{
      font-family: var(--mono);
      font-size: 13px;
      line-height: 1.5;
      color: #f1f5ff;
      white-space: pre-wrap;
    }
    .copyRow{
      display:flex; gap:10px; flex-wrap:wrap;
      align-items:center;
      margin-top: 8px;
    }
    button.copy{
      appearance:none;
      border:1px solid rgba(233,238,252,.16);
      background: rgba(233,238,252,.06);
      color: var(--ink);
      padding: 8px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-size: 13px;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    button.copy:hover{
      transform: translateY(-1px);
      background: rgba(126,231,255,.08);
      border-color: rgba(126,231,255,.22);
    }
    .mini{
      font-size: 12.5px;
      color: var(--muted);
    }

    .vizWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    .vizGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items:stretch;
    }
    figure{
      margin:0;
      border-radius: 18px;
      border: 1px solid rgba(233,238,252,.12);
      background: rgba(0,0,0,.18);
      overflow:hidden;
    }
    figcaption{
      padding: 10px 12px 10px;
      border-top:1px solid rgba(233,238,252,.10);
      color: var(--muted);
      font-size: 12.5px;
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
      background: rgba(9,12,24,.62);
    }
    canvas.small{ height: 300px; }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    .control{
      border:1px solid rgba(233,238,252,.12);
      background: rgba(233,238,252,.04);
      border-radius: 16px;
      padding: 10px 10px 8px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap: 10px;
      font-size: 12.5px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .control input[type="range"]{
      width:100%;
    }
    .control .val{
      font-family: var(--mono);
      color: var(--ink);
      font-size: 12.5px;
    }

    .resultLine{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      margin-top: 10px;
    }
    .pill{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(233,238,252,.14);
      background: rgba(233,238,252,.05);
      font-size: 12.5px;
      color: var(--muted);
    }
    .pill strong{color:var(--ink); font-weight:600}
    .pill.good{border-color: rgba(124,255,178,.25); background: rgba(124,255,178,.07)}
    .pill.bad{border-color: rgba(255,107,107,.25); background: rgba(255,107,107,.07)}
    .pill.warn{border-color: rgba(255,209,102,.25); background: rgba(255,209,102,.07)}

    footer{
      max-width:1160px;
      margin: 0 auto;
      padding: 0 18px 28px;
      color: var(--muted);
      font-size: 12.5px;
    }

    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
      nav.toc{position:relative; top:auto}
      .vizGrid{grid-template-columns:1fr}
      canvas{height: 300px}
      .controls{grid-template-columns:1fr}
      .grid2{grid-template-columns:1fr}
      .grid3{grid-template-columns:1fr}
    }

    @media print{
      body{background:#fff; color:#000}
      nav.toc{display:none}
      section{box-shadow:none; background:#fff; border:1px solid #ddd}
      canvas{display:none}
      figure{border:1px solid #ddd; background:#fff}
      .eqbox{background:#fff; border:1px solid #ddd}
      button.copy{display:none}
    }

    /* subtle motion */
    @keyframes floatIn{
      from{transform: translateY(8px); opacity:0}
      to{transform: translateY(0); opacity:1}
    }
    section{animation: floatIn .35s ease both}
  </style>
</head>

<body>
<header>
  <div class="title">
    <h1>Ray Position in Unstable Resonators (and a Symmetric Example)</h1>
    <p class="subtitle">
      We use the <span class="kbadge">ABCD ray matrix</span> to derive the closed-form ray position after <em>m</em> round trips in an unstable two-mirror resonator, then apply it numerically to a symmetric cavity and connect everything to interactive plots.
    </p>
  </div>
</header>

<main>
  <nav class="toc" aria-label="Table of contents">
    <h2>On this page</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
  </nav>

  <article>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><strong>What this is about:</strong> tracking a paraxial ray bouncing between two spherical mirrors using a round-trip <span class="kbadge">ABCD matrix</span>.</li>
        <li><strong>Key physics idea:</strong> repeated round trips correspond to multiplying the same 2×2 matrix; the ray position follows a <em>linear recurrence</em>.</li>
        <li><strong>State vector:</strong> <span class="eq">v = [ y , θ ]ᵀ</span>, where <span class="eq">y</span> is transverse displacement (cm) and <span class="eq">θ</span> is small angle (rad).</li>
        <li><strong>Governing update:</strong> after one round trip, <span class="eq">v₁ = M v₀</span>; after <em>m</em> round trips, <span class="eq">v_m = M^m v₀</span>.</li>
        <li><strong>Closed form (unstable case):</strong> if <span class="eq">|b| &gt; 1</span> with <span class="eq">b = (A + D)/2</span>, then the ray position at the reference mirror is
          <span class="eq">y_m = a₁ h₁^m + a₂ h₂^m</span> where <span class="eq">h_{1,2} = b ± √(b² − 1)</span>.</li>
        <li><strong>Symmetric example:</strong> two concave mirrors with given radius magnitude 30 cm, separation <span class="eq">d = 65 cm</span> ⇒ <span class="eq">b ≈ 1.722 &gt; 1</span> (unstable); for <span class="eq">d = 50 cm</span> ⇒ <span class="eq">b ≈ −0.111</span> (stable).</li>
        <li><strong>Final result type:</strong> symbolic derivation + numeric values for <span class="eq">y₁</span> and an aperture-escape estimate (from the same iteration used in the plots).</li>
      </ul>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

      <div class="grid2">
        <div class="card callout">
          <h3>Core definitions (symbols & units)</h3>
          <ul>
            <li><span class="eq">y</span> — transverse ray displacement from the optical axis (cm or m).</li>
            <li><span class="eq">θ</span> — ray angle w.r.t. the axis (rad), assumed small (<em>paraxial</em>).</li>
            <li><span class="eq">d</span> — mirror separation (cm).</li>
            <li><span class="eq">R₁, R₂</span> — mirror radii of curvature (cm). <span class="muted">Sign conventions vary across textbooks.</span></li>
            <li><span class="eq">M = [[A,B],[C,D]]</span> — round-trip ray transfer (ABCD) matrix.</li>
            <li><span class="eq">b = (A + D)/2</span> — half-trace; determines stability.</li>
          </ul>
        </div>

        <div class="card">
          <h3>Physical meaning</h3>
          <p>
            The matrix <span class="eq">M</span> encodes how a ray’s <em>position and slope</em> transform after a full cavity round trip.
            If a small initial perturbation grows exponentially with the number of round trips, the resonator is <strong>unstable</strong> for rays.
          </p>
          <p class="muted">
            Important: “unstable resonator” here is about ray trajectories (geometrical optics), not about laser gain/loss.
          </p>
        </div>
      </div>

      <h3>Key laws / principles (validity & assumptions)</h3>
      <div class="card callout good">
        <ul>
          <li><strong>Paraxial approximation:</strong> <span class="eq">tan θ ≈ θ</span>, and rays stay close enough to the axis that linear optics applies.</li>
          <li><strong>ABCD (ray-transfer) formalism:</strong> any sequence of paraxial optical elements is a product of 2×2 matrices acting on <span class="eq">[y, θ]</span>.</li>
          <li><strong>Stability criterion:</strong> for repeated application of <span class="eq">M</span>, bounded trajectories require <span class="eq">| (A + D)/2 | &lt; 1</span>. If <span class="eq">|b| &gt; 1</span>, one eigenvalue has magnitude &gt; 1 ⇒ divergence.</li>
        </ul>
      </div>

      <h3>Common models / approximations (and why)</h3>
      <div class="grid2">
        <div class="card">
          <p><strong>Free-space propagation over distance d:</strong></p>
          <div class="eqbox">
            <div class="eq">P(d) = [[1, d],
        [0, 1]]</div>
          </div>
          <p class="mini">Meaning: <span class="eq">y → y + dθ</span>, while <span class="eq">θ</span> stays the same.</p>
        </div>
        <div class="card">
          <p><strong>Spherical mirror reflection (paraxial):</strong></p>
          <div class="eqbox">
            <div class="eq">M_R(R) = [[1, 0],
          [-2/R, 1]]</div>
          </div>
          <p class="mini">Meaning: angle changes by <span class="eq">Δθ = −(2/R) y</span> (mirror acts like a thin lens of focal length <span class="eq">f = R/2</span>).</p>
        </div>
      </div>

      <h3>Mini intuition examples</h3>
      <ul>
        <li><strong>Stable cavity:</strong> if <span class="eq">|b| &lt; 1</span>, eigenvalues of <span class="eq">M</span> lie on the unit circle → the ray “sloshes” but stays bounded.</li>
        <li><strong>Unstable cavity:</strong> if <span class="eq">|b| &gt; 1</span>, one eigenvalue satisfies <span class="eq">|h₁| &gt; 1</span> → the ray’s transverse displacement grows roughly like <span class="eq">|h₁|^m</span>.</li>
      </ul>

      <div class="card callout warn">
        <h3>What to watch for (pitfalls)</h3>
        <ul>
          <li><strong>Sign conventions for R:</strong> many laser texts take concave mirrors as negative radius; the mirror matrix often assumes <span class="eq">R</span> is the signed curvature in that convention. Always reconcile definitions.</li>
          <li><strong>“Round trip” reference plane:</strong> be consistent about where <span class="eq">y_m</span> is measured (here: at mirror 1, immediately after reflection, starting the next flight).</li>
          <li><strong>Aperture loss happens at each mirror hit:</strong> a ray can be clipped before completing a full round trip.</li>
        </ul>
      </div>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>Restate the tasks (in plain words)</h3>
      <p>
        <strong>(11.2-8)</strong> For an <em>unstable</em> two-mirror resonator, show that the ray position after <em>m</em> round trips has the form
        <span class="eq">y_m = a₁ h₁^m + a₂ h₂^m</span>,
        where <span class="eq">h_{1,2} = b ± √(b² − 1)</span> and
        <span class="eq">b = 2(1 + d/R₁)(1 + d/R₂) − 1</span>
        (in the book’s sign convention).
      </p>
      <p>
        <strong>(11.2-9)</strong> For a symmetric resonator with two concave mirrors of radius <span class="eq">R = −30 cm</span> separated by <span class="eq">d = 65 cm</span>:
        verify it is unstable; compute <span class="eq">y₁</span> for a ray starting at mirror 1 with <span class="eq">y₀ = 0</span>, <span class="eq">θ₀ = 0.1</span>.
        With 5-cm-diameter apertures, estimate after how many round trips the ray leaves. Also plot <span class="eq">y_m</span> for <span class="eq">m=2,3,…</span> for <span class="eq">d=50 cm</span> and <span class="eq">d=65 cm</span>.
      </p>

      <div class="grid2">
        <div class="card">
          <h3>Given quantities</h3>
          <ul>
            <li>Mirror separation: <span class="eq">d</span> (cm), with cases <span class="eq">d=65 cm</span> and <span class="eq">d=50 cm</span>.</li>
            <li>Symmetric radii: <span class="eq">R₁=R₂=R</span>, with <span class="eq">R = −30 cm</span> (textbook sign).</li>
            <li>Initial ray at mirror 1: <span class="eq">y₀=0</span>, <span class="eq">θ₀=0.1</span>.</li>
            <li>Aperture diameter: 5 cm ⇒ radius <span class="eq">a = 2.5 cm</span>.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Unknowns / what to find</h3>
          <ul>
            <li>Prove the exponential-form solution <span class="eq">y_m = a₁ h₁^m + a₂ h₂^m</span> for unstable cavities.</li>
            <li>Compute numerical <span class="eq">y₁</span> for the given symmetric example.</li>
            <li>Determine (by iteration + aperture test) when the ray first exceeds <span class="eq">|y| &gt; a</span> at either mirror.</li>
            <li>Produce <span class="eq">y_m</span> vs <span class="eq">m</span> plots for <span class="eq">d=50, 65 cm</span>.</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (why these apply)</h3>
      <ul>
        <li><strong>Paraxial ray tracing:</strong> because the problem explicitly asks for ray positions and uses resonator ABCD results.</li>
        <li><strong>Matrix powers & eigenvalues:</strong> because repeating round trips means applying <span class="eq">M</span> repeatedly → the solution is controlled by eigenvalues.</li>
        <li><strong>Stability criterion:</strong> because “unstable resonator” is diagnosed by <span class="eq">|b| &gt; 1</span> (half-trace magnitude).</li>
      </ul>

      <div class="card callout">
        <h3>Assumptions (explicit)</h3>
        <ul>
          <li>Ideal spherical mirrors, no aberrations; perfectly aligned cavity.</li>
          <li>Paraxial approximation: small <span class="eq">θ</span>, linear ray optics.</li>
          <li>We ignore diffraction and wave effects; aperture loss is modeled by geometric clipping when <span class="eq">|y| &gt; a</span> at a mirror.</li>
          <li>We measure <span class="eq">y_m</span> at mirror 1 once per full round trip.</li>
        </ul>
      </div>

      <h3>Possible approaches (compare & choose)</h3>
      <div class="grid3">
        <div class="card">
          <p><strong>Approach A: ABCD matrix + eigenvalues</strong></p>
          <p class="mini">Pros: clean proof of exponential form; directly gives <span class="eq">h₁,h₂</span>. Cons: must keep track of sign conventions.</p>
        </div>
        <div class="card">
          <p><strong>Approach B: derive a second-order recurrence for y</strong></p>
          <p class="mini">Pros: avoids explicit eigenvectors; shows why it’s a “two-exponential” solution. Cons: still needs b and characteristic equation.</p>
        </div>
        <div class="card">
          <p><strong>Approach C: direct iterative simulation only</strong></p>
          <p class="mini">Pros: easy numerically. Cons: does not prove the general closed form.</p>
        </div>
      </div>
      <p><strong>Best choice:</strong> Use <strong>A + B</strong>: build the round-trip matrix, derive the recurrence from matrix properties, and then use eigenvalues for the closed form. Then apply numerically and visualize.</p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

      <ol>
        <li>
          <strong>Define the ray state</strong> at a fixed reference plane (mirror 1).<br>
          <span class="mini">Tool:</span> <span class="eq">v = [y, θ]ᵀ</span>.<br>
          <span class="mini">Meaning:</span> we track one number for position and one for direction.
        </li>
        <li>
          <strong>Write matrices</strong> for propagation and mirror reflection.<br>
          <span class="mini">Tool:</span> <span class="eq">P(d)</span>, <span class="eq">M_R(R)</span>.<br>
          <span class="mini">Meaning:</span> each optical step is linear in paraxial optics.
        </li>
        <li>
          <strong>Multiply to get the round-trip matrix</strong> <span class="eq">M</span> from mirror 1 back to mirror 1.<br>
          <span class="mini">Tool:</span> matrix product order.
        </li>
        <li>
          <strong>Use matrix invariants</strong> for optical systems: typically <span class="eq">det(M)=1</span> for lossless paraxial elements.<br>
          <span class="mini">Meaning:</span> eigenvalues satisfy <span class="eq">h₁ h₂ = 1</span>.
        </li>
        <li>
          <strong>Relate eigenvalues to the trace</strong>: <span class="eq">h² − (A+D)h + 1 = 0</span>.<br>
          <span class="mini">Meaning:</span> the growth/oscillation is fully determined by <span class="eq">b=(A+D)/2</span>.
        </li>
        <li>
          <strong>Express y<sub>m</sub> as a two-mode sum</strong> using eigenvalues (unstable ⇒ real exponentials).<br>
          <span class="mini">Meaning:</span> one term grows while the other decays.
        </li>
        <li>
          <strong>Determine constants</strong> <span class="eq">a₁,a₂</span> from <span class="eq">y₀</span> and <span class="eq">y₁</span>.<br>
          <span class="mini">Tip:</span> quickest is solve a 2×2 system.
        </li>
        <li>
          <strong>For apertures:</strong> simulate hits on mirror 2 (half-trip) and mirror 1 (full-trip) and stop when <span class="eq">|y|&gt;a</span>.<br>
          <span class="mini">Meaning:</span> clipping can occur before a full round trip completes.
        </li>
      </ol>

      <div class="card callout warn">
        <h3>Common mistakes & quick tips</h3>
        <ul>
          <li><strong>Matrix order:</strong> the rightmost matrix acts first.</li>
          <li><strong>Using the wrong mirror sign:</strong> if your computed <span class="eq">b</span> disagrees with the known stability formula, your sign convention is off.</li>
          <li><strong>For unstable cavities:</strong> don’t expect “oscillations”; expect exponential growth with <span class="eq">m</span>.</li>
        </ul>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

      <h3>Physical intuition first (before math)</h3>
      <p>
        A two-mirror cavity repeatedly refocuses (or defocuses) rays. If the net focusing per round trip is too weak (or effectively defocusing),
        a small angular error causes the ray to wander farther from the axis each bounce.
        In matrix terms: repeated multiplication by <span class="eq">M</span> amplifies components along the eigenvector with eigenvalue <span class="eq">|h|&gt;1</span>.
      </p>

      <h3>Step 1 — Ray matrices and the round-trip matrix</h3>
      <p>We choose the ray vector at mirror 1 (just after reflection, heading toward mirror 2):</p>
      <div class="eqbox">
        <div class="eq">v_m = [ y_m, θ_m ]ᵀ   (measured at mirror 1 after m round trips)</div>
        <div class="copyRow">
          <button class="copy" data-copy="v_m = [ y_m, θ_m ]^T   (measured at mirror 1 after m round trips)">Copy</button>
        </div>
      </div>

      <p>Propagation by distance <span class="eq">d</span> and reflection at a spherical mirror of radius <span class="eq">R</span> are:</p>
      <div class="grid2">
        <div class="eqbox">
          <div class="eq">P(d) = [[1, d],
        [0, 1]]</div>
          <div class="copyRow">
            <button class="copy" data-copy="P(d) = [[1, d],[0, 1]]">Copy</button>
          </div>
        </div>
        <div class="eqbox">
          <div class="eq">M_R(R) = [[1, 0],
          [-2/R, 1]]</div>
          <div class="copyRow">
            <button class="copy" data-copy="M_R(R) = [[1, 0],[-2/R, 1]]">Copy</button>
          </div>
        </div>
      </div>

      <p>
        One round trip from mirror 1 back to mirror 1 consists of:
        propagate to mirror 2, reflect at mirror 2, propagate back, reflect at mirror 1.
      </p>
      <div class="eqbox">
        <div class="eq">M = M_R(R₁) · P(d) · M_R(R₂) · P(d)</div>
        <div class="copyRow">
          <button class="copy" data-copy="M = M_R(R1) · P(d) · M_R(R2) · P(d)">Copy</button>
        </div>
      </div>

      <p>Write <span class="eq">M</span> in ABCD form:</p>
      <div class="eqbox">
        <div class="eq">M = [[A, B],
     [C, D]]</div>
      </div>

      <h3>Step 2 — Why y<sub>m</sub> must be a two-exponential form</h3>
      <p>
        The repeated-round-trip evolution is <span class="eq">v_m = M^m v_0</span>. So the behavior is governed by the eigenvalues of <span class="eq">M</span>.
        For a lossless paraxial optical system built from propagation and ideal reflections, the determinant is:
      </p>
      <div class="eqbox">
        <div class="eq">det(P(d)) = 1,   det(M_R(R)) = 1  ⇒  det(M) = 1</div>
        <div class="copyRow">
          <button class="copy" data-copy="det(P(d)) = 1, det(M_R(R)) = 1 ⇒ det(M) = 1">Copy</button>
        </div>
      </div>

      <p>
        Let the eigenvalues be <span class="eq">h₁</span> and <span class="eq">h₂</span>. Then:
      </p>
      <div class="eqbox">
        <div class="eq">h₁ h₂ = det(M) = 1</div>
      </div>

      <p>
        Also, eigenvalues satisfy the characteristic equation:
      </p>
      <div class="eqbox">
        <div class="eq">h² − (A + D) h + det(M) = 0
⇒ h² − (A + D) h + 1 = 0</div>
        <div class="copyRow">
          <button class="copy" data-copy="h^2 − (A + D) h + 1 = 0">Copy</button>
        </div>
      </div>

      <p>Define the half-trace:</p>
      <div class="eqbox">
        <div class="eq">b = (A + D)/2</div>
        <div class="copyRow">
          <button class="copy" data-copy="b = (A + D)/2">Copy</button>
        </div>
      </div>

      <p>Then the characteristic equation becomes:</p>
      <div class="eqbox">
        <div class="eq">h² − 2 b h + 1 = 0</div>
      </div>

      <p>Solving:</p>
      <div class="eqbox">
        <div class="eq">h_{1,2} = b ± √(b² − 1)</div>
        <div class="copyRow">
          <button class="copy" data-copy="h1,2 = b ± √(b^2 − 1)">Copy</button>
        </div>
      </div>

      <p class="muted">
        If <span class="eq">|b| &lt; 1</span>, then <span class="eq">b² − 1 &lt; 0</span> and eigenvalues are complex conjugates on the unit circle (stable).
        If <span class="eq">|b| &gt; 1</span>, then eigenvalues are real and reciprocal; one has magnitude &gt; 1 (unstable).
      </p>

      <h3>Step 3 — From eigenvalues to the stated form y<sub>m</sub> = a₁h₁^m + a₂h₂^m</h3>
      <p>
        Because <span class="eq">M</span> is a 2×2 matrix with (generically) two distinct eigenvalues,
        any component of <span class="eq">M^m v_0</span> is a linear combination of <span class="eq">h₁^m</span> and <span class="eq">h₂^m</span>.
        In particular, the first component (the ray position) must be:
      </p>
      <div class="eqbox">
        <div class="eq">y_m = a₁ h₁^m + a₂ h₂^m   (unstable case: |b|&gt;1 ⇒ h₁,h₂ real)</div>
        <div class="copyRow">
          <button class="copy" data-copy="y_m = a1 h1^m + a2 h2^m">Copy</button>
        </div>
      </div>

      <p>
        The constants <span class="eq">a₁, a₂</span> are set by two initial conditions. A convenient pair is <span class="eq">y₀</span> and <span class="eq">y₁</span>.
        Plugging <span class="eq">m=0</span> and <span class="eq">m=1</span> gives:
      </p>
      <div class="eqbox">
        <div class="eq">y₀ = a₁ + a₂
y₁ = a₁ h₁ + a₂ h₂</div>
      </div>
      <p>Solving this 2×2 system:</p>
      <div class="eqbox">
        <div class="eq">a₁ = (y₁ − h₂ y₀)/(h₁ − h₂)
a₂ = (h₁ y₀ − y₁)/(h₁ − h₂)</div>
        <div class="copyRow">
          <button class="copy" data-copy="a1 = (y1 − h2 y0)/(h1 − h2)\na2 = (h1 y0 − y1)/(h1 − h2)">Copy</button>
        </div>
      </div>

      <h3>Step 4 — Connecting b to mirror radii and spacing</h3>
      <p>
        When you multiply <span class="eq">M = M_R(R₁) P(d) M_R(R₂) P(d)</span> and compute <span class="eq">b=(A+D)/2</span>,
        standard resonator algebra yields (in the textbook’s convention):
      </p>
      <div class="eqbox">
        <div class="eq">b = 2(1 + d/R₁)(1 + d/R₂) − 1</div>
        <div class="copyRow">
          <button class="copy" data-copy="b = 2(1 + d/R1)(1 + d/R2) − 1">Copy</button>
        </div>
      </div>

      <div class="card callout warn">
        <p><strong>Sign convention note (important for the numeric example):</strong>
          The problem states concave mirrors have <span class="eq">R = −30 cm</span>.
          In the mirror matrix used above, we assume concave mirrors have <span class="eq">R &gt; 0</span> (so that reflection adds focusing with <span class="eq">C = −2/R</span>).
          To match the book’s sign, we will use <span class="eq">R_matrix = |R| = 30 cm</span> in the matrix, while using the book’s formula for <span class="eq">b</span> as written.
        </p>
      </div>

      <h3>Step 5 — Apply to the symmetric resonator (Problem 11.2-9)</h3>
      <p>
        Symmetric means <span class="eq">R₁=R₂=R</span>. The book gives <span class="eq">R = −30 cm</span> (concave),
        separation <span class="eq">d = 65 cm</span>.
      </p>

      <p><strong>Stability check using b:</strong></p>
      <div class="eqbox">
        <div class="eq">b = 2(1 + d/R)² − 1
with R = −30 cm, d = 65 cm:
1 + d/R = 1 + 65/(−30) = 1 − 2.1667 = −1.1667
⇒ b ≈ 2(1.3611) − 1 ≈ 1.7222  (&gt;1 ⇒ unstable)</div>
        <div class="copyRow">
          <button class="copy" data-copy="For R=-30 cm, d=65 cm:\n1 + d/R = 1 + 65/(-30) = -1.1667\nb = 2(1 + d/R)^2 - 1 ≈ 1.7222 > 1 ⇒ unstable">Copy</button>
        </div>
      </div>

      <p><strong>Compute y₁ after one round trip:</strong></p>
      <p>
        Use <span class="eq">v₁ = M v₀</span> with <span class="eq">v₀ = [y₀, θ₀]ᵀ = [0, 0.1]ᵀ</span>.
        With <span class="eq">R_matrix = 30 cm</span>, the round-trip matrix becomes numerically:
      </p>
      <div class="eqbox">
        <div class="eq">M = M_R(30) P(65) M_R(30) P(65)
  = [[A, B],
     [C, D]]
  = [[ -3.3333, -151.6667],
     [  0.1556,   6.7778]]</div>
      </div>

      <p>
        Since <span class="eq">y₀=0</span>, the first component is simply <span class="eq">y₁ = A y₀ + B θ₀ = B θ₀</span>.
      </p>
      <div class="eqbox">
        <div class="eq">y₁ = B θ₀ = (−151.6667 cm) × (0.1 rad) ≈ −15.1667 cm</div>
        <div class="copyRow">
          <button class="copy" data-copy="y1 = B θ0 = (−151.6667 cm) × (0.1 rad) ≈ −15.1667 cm">Copy</button>
        </div>
      </div>

      <div class="card callout good">
        <h3>Sanity checks</h3>
        <ul>
          <li><strong>Units:</strong> <span class="eq">B</span> has units of length, so <span class="eq">B θ</span> has units of length → correct for <span class="eq">y</span>.</li>
          <li><strong>Unstable behavior:</strong> <span class="eq">b&gt;1</span> predicts exponential growth in <span class="eq">|y_m|</span>, which the plots will show.</li>
          <li><strong>Sign:</strong> negative <span class="eq">y₁</span> means the ray returns displaced to the opposite side (depending on initial geometry and focusing).</li>
        </ul>
      </div>

      <h3>Step 6 — Aperture loss: when does the ray leave?</h3>
      <p>
        The mirrors have diameter 5 cm ⇒ aperture radius <span class="eq">a = 2.5 cm</span>.
        A ray is clipped when <span class="eq">|y| &gt; a</span> at a mirror surface.
      </p>
      <p>
        Starting at mirror 1 with <span class="eq">y₀=0</span>, the ray reaches mirror 2 after one propagation:
        <span class="eq">y_{(hit\,M2)} = y₀ + d θ₀</span>.
      </p>
      <div class="eqbox">
        <div class="eq">At mirror 2 on the first hit:
y = d θ₀ = (65 cm)(0.1) = 6.5 cm &gt; 2.5 cm  ⇒ clipped before completing 1 round trip.</div>
        <div class="copyRow">
          <button class="copy" data-copy="At mirror 2 first hit: y = d θ0 = (65 cm)(0.1) = 6.5 cm > 2.5 cm ⇒ clipped before 1 round trip">Copy</button>
        </div>
      </div>

      <div class="card callout bad">
        <p>
          <strong>Conclusion for the given numbers:</strong>
          with <span class="eq">θ₀=0.1</span> rad and <span class="eq">a=2.5</span> cm, the ray is lost on the <strong>very first encounter with mirror 2</strong>.
          In terms of “round trips completed,” that is <strong>0 full round trips</strong> (it does not survive to return to mirror 1).
        </p>
        <p class="mini">
          The interactive plots below still show <span class="eq">y_m</span> vs <span class="eq">m</span> as a mathematical trajectory (what would happen without clipping),
          and also compute the earliest clipping event (which depends on aperture and angle).
        </p>
      </div>

      <h3>Step 7 — The requested comparison: d = 50 cm vs d = 65 cm</h3>
      <p>
        Using the stability measure <span class="eq">b = 2(1 + d/R)² − 1</span> with <span class="eq">R = −30 cm</span>:
      </p>
      <div class="eqbox">
        <div class="eq">For d = 50 cm:
1 + d/R = 1 + 50/(−30) = 1 − 1.6667 = −0.6667
b = 2(0.4444) − 1 = −0.1111  (|b|&lt;1 ⇒ stable)

For d = 65 cm:
b ≈ 1.7222 (|b|&gt;1 ⇒ unstable)</div>
        <div class="copyRow">
          <button class="copy" data-copy="d=50 cm: b = 2(1 + 50/(-30))^2 - 1 = -0.1111 ⇒ stable\n\nd=65 cm: b ≈ 1.7222 ⇒ unstable">Copy</button>
        </div>
      </div>

      <p>
        The plots will display <span class="eq">y_m</span> for both cases and let you vary <span class="eq">d</span>, <span class="eq">θ₀</span>, and aperture live.
      </p>

      <div class="eqbox">
        <div class="eq"><strong>FINAL ANSWER (core results):</strong>
(11.2-8) For |b|>1, y_m = a1 h1^m + a2 h2^m,
with h1,2 = b ± √(b^2 − 1),  b = (A+D)/2 = 2(1 + d/R1)(1 + d/R2) − 1.

(11.2-9) For R=-30 cm, d=65 cm: b≈1.7222 ⇒ unstable.
With y0=0, θ0=0.1: y1 ≈ −15.17 cm (at mirror 1 after one round trip, if unclipped).
Aperture radius 2.5 cm: at first hit on mirror 2, y = d θ0 = 6.5 cm > 2.5 cm ⇒ ray leaves before completing 1 round trip.</div>
        <div class="copyRow">
          <button class="copy" data-copy="(11.2-8) For |b|>1: y_m = a1 h1^m + a2 h2^m, with h1,2 = b ± √(b^2 − 1), b = (A+D)/2 = 2(1 + d/R1)(1 + d/R2) − 1.\n\n(11.2-9) For R=-30 cm, d=65 cm: b≈1.7222 ⇒ unstable. With y0=0, θ0=0.1: y1≈−15.17 cm (unclipped). Aperture radius 2.5 cm: at first hit on mirror 2, y=d θ0=6.5 cm>2.5 cm ⇒ leaves before 1 round trip.">Copy final answer</button>
        </div>
      </div>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

      <h3>Re-interpreting the formula y<sub>m</sub> = a₁h₁^m + a₂h₂^m</h3>
      <div class="grid2">
        <div class="card">
          <p><strong>What controls growth?</strong></p>
          <ul>
            <li><span class="eq">h₁</span> and <span class="eq">h₂</span> are eigenvalues of the round-trip mapping.</li>
            <li>Because <span class="eq">h₁ h₂ = 1</span>, one is the reciprocal of the other.</li>
            <li>In the unstable case, typically <span class="eq">|h₁| &gt; 1</span> and <span class="eq">|h₂| &lt; 1</span>, so after many trips:
              <span class="eq">y_m ≈ a₁ h₁^m</span> (dominant growing mode).</li>
          </ul>
        </div>
        <div class="card">
          <p><strong>What do a₁ and a₂ mean?</strong></p>
          <ul>
            <li>They are the projections of the initial ray onto the eigen-directions of the cavity map (in the y-component).</li>
            <li>If <span class="eq">a₁ ≈ 0</span>, the ray could initially align mostly with the decaying mode and stay small for a few trips—until imperfections excite the growing mode.</li>
          </ul>
        </div>
      </div>

      <h3>How parameters change the outcome (connect to the interactive plots)</h3>
      <ul>
        <li><strong>Increase d</strong> (for fixed mirror curvature): changes <span class="eq">b</span> and can push the cavity from stable (<span class="eq">|b|&lt;1</span>) to unstable (<span class="eq">|b|&gt;1</span>).</li>
        <li><strong>Increase θ₀</strong>: increases the initial transverse walk-off (especially at mirror 2 via <span class="eq">y=dθ₀</span>), causing earlier aperture clipping.</li>
        <li><strong>Increase aperture radius a</strong>: delays clipping but does not change stability; it only changes how long a divergent ray can remain inside.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        Instead of diagonalizing <span class="eq">M</span>, you can derive a <strong>second-order recurrence</strong> for <span class="eq">y_m</span>.
        Because <span class="eq">M</span> obeys its own characteristic polynomial (Cayley–Hamilton),
        <span class="eq">M² − 2b M + I = 0</span>. Multiplying by <span class="eq">M^{m-1} v₀</span> gives:
        <span class="eq">v_{m+1} − 2b v_m + v_{m-1} = 0</span>, and therefore the first component satisfies
        <span class="eq">y_{m+1} − 2b y_m + y_{m-1} = 0</span>,
        whose solutions are exactly <span class="eq">h₁^m</span> and <span class="eq">h₂^m</span>.
      </p>

      <div class="card callout">
        <h3>Concept checks (quick self-test)</h3>
        <ul>
          <li><strong>Q:</strong> What condition makes a resonator ray-stable? <strong>A:</strong> <span class="eq">| (A+D)/2 | &lt; 1</span>.</li>
          <li><strong>Q:</strong> In an unstable cavity, why do we get one growing and one decaying exponential? <strong>A:</strong> because <span class="eq">det(M)=1</span> ⇒ eigenvalues satisfy <span class="eq">h₁ h₂ = 1</span>.</li>
          <li><strong>Q:</strong> Does increasing aperture make an unstable cavity stable? <strong>A:</strong> no—stability is set by <span class="eq">M</span>, not by clipping.</li>
          <li><strong>Q:</strong> If <span class="eq">y₀=0</span>, what mainly sets the first-hit position at mirror 2? <strong>A:</strong> <span class="eq">y = d θ₀</span>.</li>
        </ul>
      </div>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

      <div class="vizWrap">
        <div class="card">
          <h3>Interactive controls (affect all canvases)</h3>
          <div class="controls">
            <div class="control">
              <label for="dRange"><span>Mirror spacing d (cm)</span><span class="val" id="dVal">65.0</span></label>
              <input id="dRange" type="range" min="20" max="80" step="0.5" value="65" />
              <div class="mini">Changes stability via <span class="eq">b</span> and changes aperture hits via <span class="eq">y=dθ</span>.</div>
            </div>
            <div class="control">
              <label for="thRange"><span>Initial angle θ₀ (rad)</span><span class="val" id="thVal">0.100</span></label>
              <input id="thRange" type="range" min="0" max="0.200" step="0.001" value="0.100" />
              <div class="mini">Larger θ₀ makes the ray walk off faster and clip earlier.</div>
            </div>
            <div class="control">
              <label for="aRange"><span>Aperture diameter (cm)</span><span class="val" id="aVal">5.0</span></label>
              <input id="aRange" type="range" min="1" max="12" step="0.1" value="5.0" />
              <div class="mini">Geometric clipping threshold: <span class="eq">a = (diameter)/2</span>.</div>
            </div>
          </div>

          <div class="resultLine" id="statusLine" aria-live="polite"></div>
        </div>

        <div class="vizGrid">
          <figure>
            <canvas id="diagram"></canvas>
            <figcaption>
              <strong>Diagram:</strong> Two-mirror resonator geometry (mirror 1 → mirror 2 spacing <span class="eq">d</span>) with ray trajectory and apertures.
            </figcaption>
          </figure>

          <figure>
            <canvas id="plot1" class="small"></canvas>
            <figcaption>
              <strong>Main plot:</strong> Ray position at mirror 1, <span class="eq">y_m</span> vs round trips <span class="eq">m</span>.
              Shows both fixed cases (<span class="eq">d=50</span>, <span class="eq">d=65</span>) and the current slider value.
            </figcaption>
          </figure>
        </div>

        <figure>
          <canvas id="plot2"></canvas>
          <figcaption>
            <strong>Secondary plot:</strong> Parameter sweep: earliest clipping event (in “mirror hits”) vs spacing <span class="eq">d</span>.
            A marker shows the current slider value.
          </figcaption>
        </figure>

        <div class="card">
          <h3>What should change when you move the sliders?</h3>
          <ul>
            <li><strong>Increase d:</strong> the cavity tends to become more unstable (depending on curvature), so <span class="eq">|y_m|</span> grows faster; clipping occurs sooner.</li>
            <li><strong>Increase θ₀:</strong> the very first hit at mirror 2 is at <span class="eq">y=dθ₀</span>, so clipping can happen immediately.</li>
            <li><strong>Increase aperture diameter:</strong> trajectories remain inside longer, but instability (bounded vs unbounded) does not change.</li>
          </ul>
        </div>
      </div>
    </section>
  </article>
</main>

<footer>
  <p>
    Notes: This page uses a standard paraxial mirror matrix with <span class="eq">C = −2/R</span> where <span class="eq">R</span> is taken positive for concave focusing in the matrix calculation.
    The stability expression shown matches the textbook’s stated form by using its sign convention for <span class="eq">R</span>.
  </p>
</footer>

<script>
/* ---------------------------
   Utilities: crisp canvas
---------------------------- */
function setupCanvas(canvas, heightCSS){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(2, Math.floor(rect.width));
  const h = Math.max(2, Math.floor(heightCSS ?? rect.height));
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.imageSmoothingEnabled = true;
  return {ctx, w, h, dpr};
}

function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

/* ---------------------------
   ABCD matrices
   v=[y,theta]^T, y in cm, theta in rad
---------------------------- */
function matMul(A,B){
  return [
    [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],
    [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]
  ];
}
function matVec(M,v){
  return [
    M[0][0]*v[0] + M[0][1]*v[1],
    M[1][0]*v[0] + M[1][1]*v[1]
  ];
}
function det2(M){ return M[0][0]*M[1][1]-M[0][1]*M[1][0]; }
function trace2(M){ return M[0][0]+M[1][1]; }

function P(d){ return [[1,d],[0,1]]; }
// mirror reflection matrix (paraxial), using R positive for concave focusing here:
function MR(R){ return [[1,0],[-2/R,1]]; }

function roundTripMatrix(R1,R2,d){
  // M = MR(R1) * P(d) * MR(R2) * P(d)
  return matMul( MR(R1), matMul( P(d), matMul( MR(R2), P(d) ) ) );
}

/* ---------------------------
   Iterate cavity hits and clipping
   - Mirror 1 reference after reflection: v0=[y0,theta0]
   - Half-trip to mirror 2: v = P(d) v
   - Reflect at mirror 2: v = MR(R2) v
   - Half-trip back to mirror 1: v = P(d) v
   - Reflect at mirror 1: v = MR(R1) v   (this defines the next round-trip state)
---------------------------- */
function simulateHits({R1,R2,d,y0,th0,apRadCm, maxRoundTrips=40}){
  const v0 = [y0, th0];
  const hits = []; // {hitIndex, mirror, y, theta, clipped}
  let v = v0.slice();
  let hitIndex = 0;

  function record(mirror){
    const y = v[0];
    const clipped = Math.abs(y) > apRadCm;
    hits.push({hitIndex, mirror, y, theta:v[1], clipped});
    return clipped;
  }

  // record starting at mirror 1 (hitIndex=0)
  if(record(1)){
    return {hits, escapeHit:0};
  }

  for(let m=0; m<maxRoundTrips; m++){
    // to mirror 2
    v = matVec(P(d), v);
    hitIndex++;
    if(record(2)) return {hits, escapeHit:hitIndex};

    // reflect at mirror 2
    v = matVec(MR(R2), v);

    // to mirror 1
    v = matVec(P(d), v);
    hitIndex++;
    if(record(1)) return {hits, escapeHit:hitIndex};

    // reflect at mirror 1 -> completes a round trip
    v = matVec(MR(R1), v);
  }
  return {hits, escapeHit:null}; // no escape within window
}

function computeYmAtMirror1(R1,R2,d,y0,th0,mMax){
  const M = roundTripMatrix(R1,R2,d);
  const ys = [];
  let v = [y0, th0];
  ys.push({m:0, y:v[0]});
  for(let m=1;m<=mMax;m++){
    v = matVec(M, v);
    ys.push({m, y:v[0]});
  }
  return {M, ys};
}

/* ---------------------------
   Plotting helpers
---------------------------- */
function drawPanelBg(ctx,w,h){
  ctx.clearRect(0,0,w,h);
  // subtle background grid tint
  ctx.fillStyle = 'rgba(9,12,24,0.92)';
  ctx.fillRect(0,0,w,h);
}

function drawAxes(ctx, box, xMin,xMax,yMin,yMax, xLabel,yLabel, title){
  const {x,y,w,h} = box;
  // frame
  ctx.strokeStyle = 'rgba(233,238,252,0.14)';
  ctx.lineWidth = 1;
  ctx.strokeRect(x,y,w,h);

  // title
  ctx.fillStyle = 'rgba(233,238,252,0.92)';
  ctx.font = '600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(title, x+10, y+18);

  // ticks/grid
  const padTop = 28;
  const padLeft = 50;
  const padRight = 14;
  const padBottom = 38;
  const ix0 = x + padLeft;
  const iy0 = y + padTop;
  const iw = w - padLeft - padRight;
  const ih = h - padTop - padBottom;

  // gridlines
  ctx.strokeStyle = 'rgba(233,238,252,0.08)';
  ctx.lineWidth = 1;

  const nGX = 8, nGY = 6;
  for(let i=0;i<=nGX;i++){
    const gx = ix0 + (iw*i/nGX);
    ctx.beginPath(); ctx.moveTo(gx, iy0); ctx.lineTo(gx, iy0+ih); ctx.stroke();
  }
  for(let j=0;j<=nGY;j++){
    const gy = iy0 + (ih*j/nGY);
    ctx.beginPath(); ctx.moveTo(ix0, gy); ctx.lineTo(ix0+iw, gy); ctx.stroke();
  }

  // axes
  ctx.strokeStyle = 'rgba(233,238,252,0.25)';
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(ix0, iy0+ih);
  ctx.lineTo(ix0+iw, iy0+ih);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(ix0, iy0);
  ctx.lineTo(ix0, iy0+ih);
  ctx.stroke();

  // labels
  ctx.fillStyle = 'rgba(184,195,234,0.95)';
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(xLabel, ix0 + iw/2 - ctx.measureText(xLabel).width/2, iy0+ih+28);

  // y label rotated
  ctx.save();
  ctx.translate(ix0-36, iy0 + ih/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
  ctx.restore();

  // tick labels
  ctx.fillStyle = 'rgba(184,195,234,0.9)';
  ctx.font = '11px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';

  function fmt(v){
    const av = Math.abs(v);
    if(av>=100) return v.toFixed(0);
    if(av>=10) return v.toFixed(1);
    if(av>=1) return v.toFixed(2);
    return v.toFixed(3);
  }

  for(let i=0;i<=nGX;i++){
    const xv = xMin + (xMax-xMin)*i/nGX;
    const gx = ix0 + iw*i/nGX;
    ctx.fillText(fmt(xv), gx - 10, iy0+ih+14);
  }
  for(let j=0;j<=nGY;j++){
    const yv = yMax - (yMax-yMin)*j/nGY;
    const gy = iy0 + ih*j/nGY;
    ctx.fillText(fmt(yv), ix0 - 44, gy + 4);
  }

  function xPix(xv){ return ix0 + (xv - xMin) * iw / (xMax-xMin); }
  function yPix(yv){ return iy0 + (yMax - yv) * ih / (yMax-yMin); }

  return {ix0,iy0,iw,ih,xPix,yPix};
}

function drawLegend(ctx, x, y, items){
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  let yy = y;
  for(const it of items){
    ctx.fillStyle = it.color;
    ctx.fillRect(x, yy-9, 12, 3);
    ctx.fillStyle = 'rgba(233,238,252,0.88)';
    ctx.fillText(it.label, x+18, yy);
    yy += 16;
  }
}

/* ---------------------------
   Canvases
---------------------------- */
const els = {
  dRange: document.getElementById('dRange'),
  thRange: document.getElementById('thRange'),
  aRange: document.getElementById('aRange'),
  dVal: document.getElementById('dVal'),
  thVal: document.getElementById('thVal'),
  aVal: document.getElementById('aVal'),
  statusLine: document.getElementById('statusLine'),
  diagram: document.getElementById('diagram'),
  plot1: document.getElementById('plot1'),
  plot2: document.getElementById('plot2')
};

// Problem constants
// Book gives R = -30 cm for concave. We'll use Rmag=30 cm in the mirror matrix.
const Rbook = -30.0;
const Rmag = Math.abs(Rbook);
const y0 = 0.0;

function computeB_fromBook(d){
  // b = 2(1 + d/R1)(1 + d/R2) - 1  with R1=R2=Rbook
  const g = (1 + d/Rbook);
  return 2*g*g - 1;
}

function updateReadouts(){
  const d = parseFloat(els.dRange.value);
  const th0 = parseFloat(els.thRange.value);
  const diam = parseFloat(els.aRange.value);
  els.dVal.textContent = d.toFixed(1);
  els.thVal.textContent = th0.toFixed(3);
  els.aVal.textContent = diam.toFixed(1);
}

function drawDiagram(d, th0, apRad){
  const {ctx,w,h} = setupCanvas(els.diagram, 320);
  drawPanelBg(ctx,w,h);

  const margin = 24;
  const x1 = margin + 30;
  const x2 = w - margin - 30;
  const yC = h*0.55;

  // axis
  ctx.strokeStyle = 'rgba(184,195,234,0.25)';
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(margin, yC);
  ctx.lineTo(w-margin, yC);
  ctx.stroke();

  // mirrors
  function drawMirror(x, label){
    ctx.strokeStyle = 'rgba(126,231,255,0.75)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, yC-95);
    ctx.lineTo(x, yC+95);
    ctx.stroke();

    // aperture mark
    const aPix = 70 * (apRad/2.5); // scale relative to 2.5cm
    ctx.strokeStyle = 'rgba(255,209,102,0.75)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x, yC-aPix);
    ctx.lineTo(x, yC+aPix);
    ctx.stroke();

    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(label, x-18, yC-110);
  }
  drawMirror(x1, "Mirror 1");
  drawMirror(x2, "Mirror 2");

  // distance arrow
  ctx.strokeStyle = 'rgba(167,139,250,0.75)';
  ctx.lineWidth = 1.6;
  ctx.beginPath();
  ctx.moveTo(x1+10, yC-125);
  ctx.lineTo(x2-10, yC-125);
  ctx.stroke();
  // arrowheads
  ctx.beginPath();
  ctx.moveTo(x1+10, yC-125);
  ctx.lineTo(x1+20, yC-130);
  ctx.lineTo(x1+20, yC-120);
  ctx.closePath();
  ctx.fillStyle = 'rgba(167,139,250,0.75)';
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x2-10, yC-125);
  ctx.lineTo(x2-20, yC-130);
  ctx.lineTo(x2-20, yC-120);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = 'rgba(184,195,234,0.95)';
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  const dText = `d = ${d.toFixed(1)} cm`;
  ctx.fillText(dText, (x1+x2)/2 - ctx.measureText(dText).width/2, yC-133);

  // ray line from mirror1 with slope th0 (scaled for drawing)
  const drawScale = 0.9;
  const yStart = yC;
  const rayLen = (x2-x1) * 0.98;
  const yEnd = yStart - drawScale * th0 * 300; // visual scale
  ctx.strokeStyle = 'rgba(124,255,178,0.85)';
  ctx.lineWidth = 2.2;
  ctx.beginPath();
  ctx.moveTo(x1, yStart);
  ctx.lineTo(x1 + rayLen, yEnd);
  ctx.stroke();

  // angle marker
  ctx.strokeStyle = 'rgba(124,255,178,0.55)';
  ctx.lineWidth = 1.6;
  ctx.beginPath();
  ctx.arc(x1+5, yStart, 20, 0, -Math.atan2((yEnd-yStart), rayLen), true);
  ctx.stroke();

  ctx.fillStyle = 'rgba(184,195,234,0.95)';
  const thText = `θ₀ = ${th0.toFixed(3)} rad`;
  ctx.fillText(thText, x1+28, yStart-12);

  // note about clipping at mirror2 first hit: y = d*theta
  const yHit2 = d*th0;
  const clipped = Math.abs(yHit2) > apRad;
  const note = `First hit at mirror 2: y = d·θ₀ = ${(yHit2).toFixed(2)} cm ${clipped ? "(clipped)" : ""}`;
  ctx.fillStyle = clipped ? 'rgba(255,107,107,0.92)' : 'rgba(124,255,178,0.92)';
  ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(note, margin, h-18);

  // small labels
  ctx.fillStyle = 'rgba(184,195,234,0.95)';
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('Optical axis', w-margin-86, yC-8);
}

function drawPlot1(d, th0, apRad){
  const {ctx,w,h} = setupCanvas(els.plot1, 300);
  drawPanelBg(ctx,w,h);

  const box = {x:14,y:10,w:w-28,h:h-20};

  // Data for fixed cases d=50 and d=65, plus current d
  const mMax = 20;
  const fixedDs = [50,65];
  const colors = {
    d50: 'rgba(126,231,255,0.95)',
    d65: 'rgba(167,139,250,0.95)',
    dNow: 'rgba(124,255,178,0.95)'
  };

  function seriesFor(dd){
    return computeYmAtMirror1(Rmag,Rmag,dd,y0,th0,mMax).ys;
  }
  const s50 = seriesFor(50);
  const s65 = seriesFor(65);
  const sNow = seriesFor(d);

  // y range
  const all = s50.concat(s65).concat(sNow);
  const ys = all.map(p=>p.y);
  let yMin = Math.min(...ys), yMax = Math.max(...ys);

  // include aperture lines
  yMin = Math.min(yMin, -apRad*1.2);
  yMax = Math.max(yMax,  apRad*1.2);

  // avoid zero span
  if(Math.abs(yMax-yMin) < 1e-6){ yMax += 1; yMin -= 1; }

  const ax = drawAxes(
    ctx, box,
    0, mMax,
    yMin, yMax,
    'Round trips m (at mirror 1)',
    'y_m at mirror 1 (cm)',
    'Ray position vs round trips'
  );

  // aperture lines
  ctx.strokeStyle = 'rgba(255,209,102,0.55)';
  ctx.lineWidth = 1.4;
  const yA = ax.yPix(apRad);
  const yB = ax.yPix(-apRad);
  ctx.beginPath(); ctx.moveTo(ax.ix0, yA); ctx.lineTo(ax.ix0+ax.iw, yA); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(ax.ix0, yB); ctx.lineTo(ax.ix0+ax.iw, yB); ctx.stroke();

  // plot function
  function drawSeries(series, color){
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    series.forEach((p,i)=>{
      const x = ax.xPix(p.m);
      const y = ax.yPix(p.y);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();

    // points
    ctx.fillStyle = color;
    series.forEach(p=>{
      const x = ax.xPix(p.m);
      const y = ax.yPix(p.y);
      ctx.beginPath();
      ctx.arc(x,y,2.2,0,Math.PI*2);
      ctx.fill();
    });
  }

  drawSeries(s50, colors.d50);
  drawSeries(s65, colors.d65);
  drawSeries(sNow, colors.dNow);

  // legend
  drawLegend(ctx, box.x+20, box.y+40, [
    {color: colors.d50, label: 'Fixed: d = 50 cm'},
    {color: colors.d65, label: 'Fixed: d = 65 cm'},
    {color: colors.dNow, label: `Current: d = ${d.toFixed(1)} cm`},
    {color: 'rgba(255,209,102,0.75)', label: `Aperture: |y| = a = ${apRad.toFixed(2)} cm`}
  ]);
}

function drawPlot2(dNow, th0, apRad){
  const {ctx,w,h} = setupCanvas(els.plot2, 320);
  drawPanelBg(ctx,w,h);

  const box = {x:14,y:10,w:w-28,h:h-20};

  // sweep d in [20,80]
  const dMin = 20, dMax = 80;
  const N = 121;
  const ds = [];
  const esc = []; // earliest clipping hit index (mirror hits), or null -> cap
  const cap = 30; // max hits to show
  for(let i=0;i<N;i++){
    const d = dMin + (dMax-dMin)*i/(N-1);
    const sim = simulateHits({
      R1:Rmag, R2:Rmag, d,
      y0, th0,
      apRadCm: apRad,
      maxRoundTrips: 30
    });
    ds.push(d);
    if(sim.escapeHit === null) esc.push(cap);
    else esc.push(sim.escapeHit);
  }

  // axes: x=d, y=escape hit index (0..cap)
  const ax = drawAxes(
    ctx, box,
    dMin, dMax,
    0, cap,
    'Mirror spacing d (cm)',
    'Earliest clipping hit index (0 = start)',
    'Clipping vs spacing (parameter sweep)'
  );

  // draw curve
  ctx.strokeStyle = 'rgba(126,231,255,0.90)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<N;i++){
    const x = ax.xPix(ds[i]);
    const y = ax.yPix(esc[i]);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  // marker for current d
  const simNow = simulateHits({
    R1:Rmag, R2:Rmag, d:dNow,
    y0, th0,
    apRadCm: apRad,
    maxRoundTrips: 30
  });
  const yMark = (simNow.escapeHit===null) ? cap : simNow.escapeHit;
  const xM = ax.xPix(dNow);
  const yM = ax.yPix(yMark);

  ctx.fillStyle = 'rgba(124,255,178,0.95)';
  ctx.beginPath();
  ctx.arc(xM, yM, 5.2, 0, Math.PI*2);
  ctx.fill();

  // dashed guideline
  ctx.strokeStyle = 'rgba(124,255,178,0.55)';
  ctx.lineWidth = 1.2;
  ctx.setLineDash([6,6]);
  ctx.beginPath(); ctx.moveTo(xM, ax.iy0); ctx.lineTo(xM, ax.iy0+ax.ih); ctx.stroke();
  ctx.setLineDash([]);

  // legend
  drawLegend(ctx, box.x+20, box.y+40, [
    {color: 'rgba(126,231,255,0.90)', label: 'Sweep: earliest clipping (mirror hits)'},
    {color: 'rgba(124,255,178,0.90)', label: `Current d = ${dNow.toFixed(1)} cm`}
  ]);

  // cap note
  ctx.fillStyle = 'rgba(184,195,234,0.9)';
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  const note = `Values at ${cap} mean “not clipped within ${cap} hits” (in this sweep window).`;
  ctx.fillText(note, box.x+20, box.y+box.h-10);
}

function updateStatus(d, th0, apRad){
  const M = roundTripMatrix(Rmag, Rmag, d);
  const A = M[0][0], B = M[0][1], C = M[1][0], D = M[1][1];
  const bMat = 0.5*(A+D);
  const bBook = computeB_fromBook(d);
  const det = det2(M);

  const stable = Math.abs(bBook) < 1;
  const stabilityPill = stable
    ? `<span class="pill good"><strong>Stability:</strong> |b| = ${Math.abs(bBook).toFixed(3)} &lt; 1 (stable)</span>`
    : `<span class="pill bad"><strong>Stability:</strong> |b| = ${Math.abs(bBook).toFixed(3)} &gt; 1 (unstable)</span>`;

  // y1 at mirror1 (unclipped math trajectory)
  const v1 = matVec(M, [y0, th0]);
  const y1 = v1[0];

  // aperture escape
  const sim = simulateHits({R1:Rmag, R2:Rmag, d, y0, th0, apRadCm: apRad, maxRoundTrips: 40});
  let escText = '';
  if(sim.escapeHit === null){
    escText = `<span class="pill good"><strong>Clipping:</strong> not clipped within simulation window</span>`;
  }else{
    const hit = sim.escapeHit;
    // translate hit index to "round trips completed": mirror1 hits at even indices; mirror2 hits at odd indices.
    const mirror = (hit % 2 === 0) ? 1 : 2;
    const completedRoundTrips = Math.floor(hit/2); // because every 2 hits (M2 then M1) completes a round trip from M1 reference
    escText = `<span class="pill warn"><strong>Clipping:</strong> first clipped at mirror ${mirror} on hit #${hit} (≈ ${completedRoundTrips} full round trips completed)</span>`;
  }

  const pill1 = `<span class="pill"><strong>b (book formula):</strong> ${bBook.toFixed(4)}</span>`;
  const pill2 = `<span class="pill"><strong>b (matrix half-trace):</strong> ${bMat.toFixed(4)}</span>`;
  const pill3 = `<span class="pill"><strong>det(M):</strong> ${det.toFixed(4)} (≈1)</span>`;
  const pill4 = `<span class="pill"><strong>y₁ (mirror 1, unclipped):</strong> ${y1.toFixed(3)} cm</span>`;
  const pill5 = `<span class="pill"><strong>First hit at mirror 2:</strong> y = d·θ₀ = ${(d*th0).toFixed(3)} cm</span>`;

  els.statusLine.innerHTML = `${stabilityPill}${pill1}${pill2}${pill3}${pill4}${pill5}${escText}`;
}

function renderAll(){
  updateReadouts();
  const d = parseFloat(els.dRange.value);
  const th0 = parseFloat(els.thRange.value);
  const diam = parseFloat(els.aRange.value);
  const apRad = diam/2;

  updateStatus(d, th0, apRad);
  drawDiagram(d, th0, apRad);
  drawPlot1(d, th0, apRad);
  drawPlot2(d, th0, apRad);
}

['input','change'].forEach(evt=>{
  els.dRange.addEventListener(evt, renderAll);
  els.thRange.addEventListener(evt, renderAll);
  els.aRange.addEventListener(evt, renderAll);
});

window.addEventListener('resize', ()=>{ renderAll(); });

/* ---------------------------
   Copy buttons
---------------------------- */
function copyText(t){
  navigator.clipboard.writeText(t).then(()=>{
    // tiny toast by temporarily changing button text is handled inline
  }).catch(()=>{});
}
document.addEventListener('click', (e)=>{
  const btn = e.target.closest('button.copy');
  if(!btn) return;
  const txt = btn.getAttribute('data-copy') || '';
  const old = btn.textContent;
  copyText(txt);
  btn.textContent = 'Copied!';
  setTimeout(()=>btn.textContent = old, 900);
});

// initial render
renderAll();
</script>
</body>
</html>
