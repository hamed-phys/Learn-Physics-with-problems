<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Ray Position in Unstable Resonators — Eigenvalue Growth & ABCD Matrix Derivation</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:rgba(255,255,255,.06);
      --panel2:rgba(255,255,255,.09);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.72);
      --faint:rgba(255,255,255,.55);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --ok:#86efac;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.14);
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 800px at 20% -10%, rgba(125,211,252,.20), transparent 60%),
        radial-gradient(1000px 700px at 90% 10%, rgba(167,139,250,.18), transparent 60%),
        radial-gradient(900px 600px at 50% 120%, rgba(134,239,172,.10), transparent 60%),
        var(--bg);
      color:var(--text);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding: clamp(18px, 3vw, 34px);
      padding-bottom: 14px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .title{
      display:flex;
      gap:14px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-size: clamp(1.55rem, 2.6vw, 2.25rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:10px 0 0 0;
      color:var(--muted);
      max-width: 80ch;
    }
    .layout{
      max-width:1200px;
      margin:0 auto;
      padding: 0 clamp(14px, 2.5vw, 34px) 44px;
      display:grid;
      grid-template-columns: 290px 1fr;
      gap: 18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns: 1fr;}
    }

    /* Sticky ToC */
    nav.toc{
      position:sticky;
      top:14px;
      background: linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.06));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:14px 14px 12px;
      backdrop-filter: blur(10px);
    }
    nav.toc .toc-title{
      font-weight:700;
      font-size: .95rem;
      letter-spacing:.2px;
      margin:0 0 10px;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .pill{
      font-size:.74rem;
      padding:2px 8px;
      border-radius:999px;
      background:rgba(125,211,252,.12);
      color: rgba(125,211,252,.95);
      border:1px solid rgba(125,211,252,.25);
    }
    .toc a{
      display:block;
      padding:7px 8px;
      border-radius: 12px;
      color: var(--muted);
      font-size:.92rem;
      border:1px solid transparent;
    }
    .toc a:hover{
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-color: rgba(255,255,255,.10);
      text-decoration:none;
    }
    .toc small{color:var(--faint)}
    main{
      min-width:0;
      display:flex;
      flex-direction:column;
      gap: 16px;
    }

    section{
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.05));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: clamp(14px, 2.2vw, 22px);
      backdrop-filter: blur(10px);
      transform: translateY(0);
      transition: transform .18s ease, border-color .18s ease;
    }
    section:hover{transform: translateY(-1px); border-color: rgba(255,255,255,.18);}
    h2{
      margin:0 0 10px;
      font-size: clamp(1.1rem, 1.7vw, 1.4rem);
      letter-spacing:.2px;
    }
    h3{
      margin:14px 0 8px;
      font-size: 1.02rem;
      color: rgba(255,255,255,.90);
    }
    p{margin: 8px 0}
    ul{margin: 8px 0 0 18px}
    li{margin: 6px 0; color: var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 820px){
      .grid2{grid-template-columns: 1fr;}
    }

    .callouts{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
      margin-top: 12px;
    }
    .box{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      border-radius: 16px;
      padding: 12px 12px 10px;
    }
    .box h4{
      margin:0 0 6px;
      font-size: .94rem;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .box p, .box li{color: var(--muted)}
    .assump{grid-column: span 6;}
    .keye{grid-column: span 6;}
    .mist{grid-column: span 6;}
    .final{grid-column: span 6;}
    @media (max-width: 820px){
      .assump,.keye,.mist,.final{grid-column: 1 / -1;}
    }
    .tag{
      font-size:.72rem;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      color: var(--faint);
      background: rgba(255,255,255,.06);
    }
    .eqrow{
      display:flex;
      align-items:stretch;
      gap:10px;
      flex-wrap:wrap;
      margin: 10px 0;
    }
    .eq{
      flex: 1 1 540px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      padding: 10px 12px;
      font-family: var(--mono);
      font-size: .93rem;
      color: rgba(255,255,255,.88);
      overflow:auto;
      white-space: pre;
    }
    button.copy{
      appearance:none;
      border:none;
      cursor:pointer;
      border-radius: 14px;
      padding: 10px 12px;
      background: rgba(125,211,252,.14);
      color: rgba(255,255,255,.92);
      border: 1px solid rgba(125,211,252,.25);
      font-weight: 650;
      letter-spacing:.2px;
      transition: transform .12s ease, background .12s ease;
      min-width: 160px;
    }
    button.copy:hover{background: rgba(125,211,252,.18); transform: translateY(-1px);}
    button.copy:active{transform: translateY(0);}
    .controls{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
      margin-top: 10px;
    }
    .ctrl{
      grid-column: span 4;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 16px;
      padding: 10px 12px;
    }
    @media (max-width: 900px){ .ctrl{grid-column: span 6;} }
    @media (max-width: 520px){ .ctrl{grid-column: 1/-1;} }
    .ctrl label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:.9rem;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .ctrl input[type="range"]{width:100%}
    .ctrl .val{
      font-family: var(--mono);
      color: rgba(255,255,255,.86);
      font-size:.86rem;
      white-space:nowrap;
    }
    .note{
      font-size:.9rem;
      color: var(--muted);
      margin-top: 8px;
    }

    figure{
      margin: 0;
      border-radius: 16px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
    }
    .figcap{
      padding: 10px 12px 12px;
      color: var(--muted);
      font-size:.92rem;
      border-top: 1px solid rgba(255,255,255,.10);
    }
    canvas{
      display:block;
      width:100%;
      height: 320px;
    }
    .canvasTall canvas{height: 360px;}
    .canvasShort canvas{height: 280px;}

    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 10px clamp(14px, 2.5vw, 34px) 34px;
      color: var(--faint);
      font-size:.9rem;
    }

    /* Print-friendly */
    @media print{
      body{background:white; color:#111}
      section, nav.toc{box-shadow:none; backdrop-filter:none}
      nav.toc{position:relative; top:auto}
      .eq{background:#f6f6f6; color:#111}
      button.copy{display:none}
      canvas{display:none}
      figure{display:none}
      a{color:#111; text-decoration:underline}
    }

    /* Subtle entrance */
    @keyframes fadeUp { from {opacity:0; transform:translateY(8px)} to {opacity:1; transform:translateY(0)} }
    section{animation: fadeUp .35s ease both;}
    section:nth-child(2){animation-delay:.03s}
    section:nth-child(3){animation-delay:.06s}
    section:nth-child(4){animation-delay:.09s}
    section:nth-child(5){animation-delay:.12s}
    section:nth-child(6){animation-delay:.15s}
  </style>
</head>
<body>
  <header>
    <div class="title">
      <div>
        <h1>Ray Position in Unstable Resonators: why <span style="color:var(--accent)">y<sub>m</sub></span> grows like eigenvalues<sup>m</sup></h1>
        <p class="subtitle">
          We model a two-mirror resonator using paraxial ray-transfer (ABCD) matrices. In the unstable case,
          the round-trip matrix has real eigenvalues with magnitude &gt; 1, so the ray position after <em>m</em> round trips
          becomes a linear combination of two exponentials: <span style="font-family:var(--mono)">y_m = α₁ h₁^m + α₂ h₂^m</span>.
        </p>
      </div>
      <div class="pill">ABCD • eigenvalues • stability</div>
    </div>
  </header>

  <div class="layout">
    <nav class="toc" aria-label="Table of contents">
      <div class="toc-title">Table of Contents <span class="pill">sticky</span></div>
      <a href="#quick" data-scroll>Quick Summary</a>
      <a href="#part0" data-scroll>PART 0 — Concept Primer</a>
      <a href="#part1" data-scroll>PART 1 — Problem Analysis</a>
      <a href="#part2" data-scroll>PART 2 — Strategy & Tips</a>
      <a href="#part3" data-scroll>PART 3 — Full Solution</a>
      <a href="#part4" data-scroll>PART 4 — Deeper Understanding</a>
      <a href="#part5" data-scroll>PART 5 — Visualization Guide</a>
      <small style="display:block;margin-top:10px;line-height:1.35">
        Tip: Use the sliders to push the cavity from stable (|b|&lt;1) to unstable (|b|&gt;1) and watch
        the ray explode.
      </small>
    </nav>

    <main>
      <section id="quick">
        <h2>Quick Summary</h2>
        <ul>
          <li><strong>What this problem is about:</strong> how a paraxial ray’s transverse position <span style="font-family:var(--mono)">y</span> evolves after repeated round trips in an <em>unstable</em> optical resonator.</li>
          <li><strong>Key physics idea:</strong> one round trip is a <em>linear map</em> on the ray vector, so repeated trips are powers of a 2×2 matrix.</li>
          <li><strong>Governing tool:</strong> ABCD (ray-transfer) matrices with state vector <span style="font-family:var(--mono)">r = (y, θ)</span> (position and angle/slope).</li>
          <li><strong>Core invariant:</strong> for lossless first-order optics, <span style="font-family:var(--mono)">det(T)=1</span> for the round-trip matrix <span style="font-family:var(--mono)">T</span>.</li>
          <li><strong>Stability parameter:</strong> <span style="font-family:var(--mono)">b = (A + D)/2</span>, where <span style="font-family:var(--mono)">T = [[A,B],[C,D]]</span>. Unstable if <span style="font-family:var(--mono)">|b| &gt; 1</span>.</li>
          <li><strong>Key result type:</strong> symbolic closed form
            <span style="font-family:var(--mono)">y_m = α₁ h₁^m + α₂ h₂^m</span> with
            <span style="font-family:var(--mono)">h₁,₂ = b ± √(b² − 1)</span>.
          </li>
          <li><strong>Interpretation:</strong> in an unstable resonator, one eigenvalue has magnitude &gt; 1, so generic rays grow exponentially in |y| with round-trip count.</li>
        </ul>
      </section>

      <section id="part0">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <h3>Core definitions (symbols & units)</h3>
        <ul>
          <li><span style="font-family:var(--mono)">y</span> — transverse ray position (meters).</li>
          <li><span style="font-family:var(--mono)">θ</span> — paraxial ray angle (radians, ≈ slope).</li>
          <li><span style="font-family:var(--mono)">r = (y, θ)^T</span> — ray state vector.</li>
          <li><span style="font-family:var(--mono)">T</span> — <em>round-trip</em> ABCD matrix mapping one round trip: <span style="font-family:var(--mono)">r_{m+1} = T r_m</span>.</li>
          <li><span style="font-family:var(--mono)">A,B,C,D</span> — elements of <span style="font-family:var(--mono)">T</span> (units: A,D dimensionless; B has meters; C has 1/meters).</li>
          <li><span style="font-family:var(--mono)">b = (A + D)/2</span> — half-trace, controls stability (dimensionless).</li>
          <li><span style="font-family:var(--mono)">h₁,h₂</span> — eigenvalues of <span style="font-family:var(--mono)">T</span> (dimensionless).</li>
          <li><span style="font-family:var(--mono)">R₁, R₂</span> — mirror radii of curvature (meters, sign depends on convention).</li>
          <li><span style="font-family:var(--mono)">d</span> — mirror separation (meters).</li>
        </ul>

        <h3>Physical meaning</h3>
        <p>
          The ABCD formalism is the “linear algebra” of paraxial optics: it predicts how a ray’s height and angle change
          after propagation, refraction, or reflection—assuming small angles and near-axis behavior.
          A resonator round trip is a repeated application of the <em>same</em> linear map, so the long-term behavior is
          dictated by the eigenvalues of that map.
        </p>

        <h3>Key laws/principles and validity</h3>
        <ul>
          <li><strong>Paraxial approximation:</strong> angles are small so <span style="font-family:var(--mono)">tan θ ≈ θ</span>, and surfaces can be linearized about the axis.</li>
          <li><strong>First-order (Gaussian) optics:</strong> we neglect aberrations and higher-order terms.</li>
          <li><strong>Lossless linear map:</strong> ideal propagation and reflection conserve étendue in this model, leading to <span style="font-family:var(--mono)">det(T)=1</span>.</li>
        </ul>

        <h3>Common models/approximations (and why)</h3>
        <ul>
          <li><strong>Mirror as a “thin lens” in reflection:</strong> a spherical mirror changes the ray angle proportionally to height; in matrix form it looks like a lens-like kick in <span style="font-family:var(--mono)">θ</span>.</li>
          <li><strong>Matrix powers:</strong> <span style="font-family:var(--mono)">T^m</span> is easiest to understand via eigenvalues/eigenvectors, especially for many round trips.</li>
        </ul>

        <h3>Mini intuition examples</h3>
        <ul>
          <li><strong>Stable resonator:</strong> if eigenvalues lie on the unit circle (complex phases), the ray oscillates but stays bounded—like a harmonic oscillator.</li>
          <li><strong>Unstable resonator:</strong> if eigenvalues are real and one has magnitude &gt; 1, the ray grows exponentially—like an inverted pendulum linearized about the top.</li>
        </ul>

        <h3>What to watch for (pitfalls)</h3>
        <ul>
          <li>Mixing sign conventions for mirror radius <span style="font-family:var(--mono)">R</span> (concave/convex) changes formulas for <span style="font-family:var(--mono)">b</span>.</li>
          <li>Confusing “round trip” index <span style="font-family:var(--mono)">m</span> with “bounce count” on a single mirror.</li>
          <li>For unstable cavities, <span style="font-family:var(--mono)">h₁</span> and <span style="font-family:var(--mono)">h₂</span> are real and reciprocal; forgetting <span style="font-family:var(--mono)">h₁ h₂ = 1</span> often breaks algebra checks.</li>
        </ul>
      </section>

      <section id="part1">
        <h2>PART 1 — Problem Analysis (no solving yet)</h2>

        <p>
          <strong>Restated:</strong> Consider a (two-mirror) unstable resonator described by paraxial ray optics.
          Show that the ray position on a chosen reference plane after <em>m</em> round trips can be written as
          <span style="font-family:var(--mono)">y_m = α₁ h₁^m + α₂ h₂^m</span>,
          where <span style="font-family:var(--mono)">α₁, α₂</span> are constants determined by initial conditions, and
          <span style="font-family:var(--mono)">h₁,₂ = b ± √(b² − 1)</span> with the given expression for <span style="font-family:var(--mono)">b</span>.
        </p>

        <div class="grid2">
          <div>
            <h3>Given quantities</h3>
            <ul>
              <li>Mirror radii <span style="font-family:var(--mono)">R₁, R₂</span> and separation <span style="font-family:var(--mono)">d</span>.</li>
              <li>Unstable resonator condition (implicitly): <span style="font-family:var(--mono)">|b| &gt; 1</span>.</li>
              <li>Definitions: <span style="font-family:var(--mono)">h₁ = b + √(b² − 1)</span>, <span style="font-family:var(--mono)">h₂ = b − √(b² − 1)</span>.</li>
            </ul>
          </div>
          <div>
            <h3>Unknowns / what to prove</h3>
            <ul>
              <li>Show the <em>general form</em> of <span style="font-family:var(--mono)">y_m</span> after <em>m</em> round trips.</li>
              <li>Connect that form to the eigenvalues <span style="font-family:var(--mono)">h₁, h₂</span> of the round-trip map.</li>
              <li>Explain why “unstable” leads to exponential growth (real eigenvalues).</li>
            </ul>
          </div>
        </div>

        <h3>Relevant physical principles (and why they apply)</h3>
        <ul>
          <li><strong>ABCD matrices:</strong> the resonator is built from propagation + reflection, each linear in the paraxial regime → overall linear map per round trip.</li>
          <li><strong>Eigenvalue dynamics:</strong> repeated application <span style="font-family:var(--mono)">T^m</span> is controlled by eigenvalues; this is the natural language for “many round trips.”</li>
          <li><strong>Why not wave optics here?</strong> The question explicitly asks about <em>ray position</em>, and points to an earlier matrix-method section; diffraction and mode structure are beyond first-order ray tracing.</li>
        </ul>

        <div class="callouts">
          <div class="box assump">
            <h4>Assumptions <span class="tag">paraxial</span></h4>
            <ul>
              <li>Small angles: <span style="font-family:var(--mono)">θ ≪ 1</span>.</li>
              <li>Spherical mirrors; first-order reflection law (linear “angle kick”).</li>
              <li>Same round-trip matrix each time (static cavity).</li>
              <li>Ideal, lossless ray-transfer → <span style="font-family:var(--mono)">det(T)=1</span>.</li>
            </ul>
          </div>
          <div class="box keye">
            <h4>Key equations <span class="tag">ABCD</span></h4>
            <ul>
              <li><span style="font-family:var(--mono)">r_{m+1} = T r_m</span>, with <span style="font-family:var(--mono)">T = [[A,B],[C,D]]</span>.</li>
              <li><span style="font-family:var(--mono)">b = (A + D)/2</span>, stability from <span style="font-family:var(--mono)">|b|</span>.</li>
              <li>Characteristic polynomial: <span style="font-family:var(--mono)">h² − 2 b h + 1 = 0</span> (since <span style="font-family:var(--mono)">det(T)=1</span>).</li>
            </ul>
          </div>
        </div>

        <h3>Possible approaches (pros/cons)</h3>
        <ul>
          <li><strong>Matrix eigenvalue method:</strong> diagonalize <span style="font-family:var(--mono)">T</span>, then <span style="font-family:var(--mono)">T^m</span> is easy. <em>Best for insight</em> and directly yields <span style="font-family:var(--mono)">h₁^m, h₂^m</span>.</li>
          <li><strong>Second-order recurrence:</strong> derive a scalar recurrence for <span style="font-family:var(--mono)">y_m</span> using trace/determinant. <em>Best for quick proof</em> without full diagonalization.</li>
          <li><strong>Explicit multiplication:</strong> compute <span style="font-family:var(--mono)">T^m</span> by repeated multiplication. Simple conceptually but inefficient and opaque.</li>
        </ul>
        <p>
          <strong>Choice:</strong> We’ll combine eigenvalues + recurrence: it’s compact, teaches the stability connection,
          and matches the hint “use results in Sec. 1.4D” (standard ABCD eigenvalue/stability facts).
        </p>
      </section>

      <section id="part2">
        <h2>PART 2 — Strategy & Tips (roadmap only)</h2>
        <ol style="margin:8px 0 0 18px; color:var(--muted)">
          <li><strong>Define</strong> the round-trip ray map <span style="font-family:var(--mono)">r_{m+1} = T r_m</span> and note <span style="font-family:var(--mono)">det(T)=1</span>. <em>Meaning:</em> the dynamics is area-preserving in paraxial phase space.</li>
          <li><strong>Introduce</strong> the half-trace <span style="font-family:var(--mono)">b = (A + D)/2</span>. <em>Meaning:</em> it controls whether eigenvalues are complex phases (stable) or real exponentials (unstable).</li>
          <li><strong>Write</strong> the characteristic equation of <span style="font-family:var(--mono)">T</span> using trace and determinant. <em>Tool:</em> <span style="font-family:var(--mono)">h² − (A+D)h + det(T)=0</span>.</li>
          <li><strong>Solve</strong> for eigenvalues <span style="font-family:var(--mono)">h₁,₂</span> and simplify to <span style="font-family:var(--mono)">b ± √(b²−1)</span>. <em>Meaning:</em> these are growth/decay factors per round trip.</li>
          <li><strong>Show</strong> that any component (in particular <span style="font-family:var(--mono)">y_m</span>) is a linear combination of <span style="font-family:var(--mono)">h₁^m</span> and <span style="font-family:var(--mono)">h₂^m</span>. <em>Tool:</em> eigenvector expansion or a second-order recurrence.</li>
          <li><strong>Relate</strong> the constants <span style="font-family:var(--mono)">α₁, α₂</span> to initial conditions. <em>Meaning:</em> they encode how much of each eigenmode is excited.</li>
          <li><strong>Sanity-check</strong> with: (i) units, (ii) <span style="font-family:var(--mono)">h₁h₂=1</span>, (iii) stable limit <span style="font-family:var(--mono)">|b|&lt;1</span> giving oscillations.</li>
        </ol>

        <div class="callouts">
          <div class="box mist">
            <h4>Common mistakes <span class="tag">avoid</span></h4>
            <ul>
              <li>Dropping the determinant condition: the <span style="font-family:var(--mono)">+1</span> term in <span style="font-family:var(--mono)">h² − 2bh + 1</span> comes from <span style="font-family:var(--mono)">det(T)=1</span>.</li>
              <li>Assuming <span style="font-family:var(--mono)">α₁, α₂</span> are “universal constants”—they depend on the chosen initial ray.</li>
              <li>For unstable resonators, forgetting that one eigenvalue must have magnitude &gt; 1 and the other &lt; 1 (because their product is 1).</li>
            </ul>
          </div>
          <div class="box keye">
            <h4>Quick tips <span class="tag">speed</span></h4>
            <ul>
              <li>If you know <span style="font-family:var(--mono)">y_0</span> and <span style="font-family:var(--mono)">y_1</span>, you can get <span style="font-family:var(--mono)">α₁,α₂</span> immediately by solving two linear equations.</li>
              <li>Use <span style="font-family:var(--mono)">h₁h₂=1</span> to simplify limiting-case reasoning.</li>
            </ul>
          </div>
        </div>
      </section>

      <section id="part3">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Physical intuition first: what do we expect?</h3>
        <p>
          A resonator maps rays back onto themselves after each round trip. In a <em>stable</em> resonator, rays remain
          trapped near the axis: you expect bounded oscillation of <span style="font-family:var(--mono)">y_m</span>.
          In an <em>unstable</em> resonator, small deviations grow: you expect <span style="font-family:var(--mono)">|y_m|</span>
          to increase roughly exponentially with the number of round trips. That is exactly what real eigenvalues produce.
        </p>

        <h3>Step 1: Write the round-trip map</h3>
        <p>
          Let the ray at a reference plane (commonly a mirror surface) after the <em>m</em>-th round trip be
        </p>
        <div class="eqrow">
          <div class="eq" id="eq1">r_m = ( y_m , θ_m )^T</div>
          <button class="copy" data-copy="r_m = (y_m, θ_m)^T">Copy equation</button>
        </div>
        <p>
          One full round trip is a linear paraxial transformation, so
        </p>
        <div class="eqrow">
          <div class="eq" id="eq2">r_{m+1} = T r_m,  where  T = [ [A, B], [C, D] ].</div>
          <button class="copy" data-copy="r_{m+1} = T r_m,  T = [[A,B],[C,D]]">Copy equation</button>
        </div>

        <h3>Step 2: Use the determinant (lossless first-order optics)</h3>
        <p>
          For ideal ray-transfer elements (free-space propagation, ideal reflection/refraction) the ABCD matrices are
          symplectic, which implies the round-trip matrix satisfies
        </p>
        <div class="eqrow">
          <div class="eq" id="eq3">det(T) = AD − BC = 1.</div>
          <button class="copy" data-copy="det(T) = AD - BC = 1">Copy equation</button>
        </div>
        <p>
          <em>Why this matters:</em> It forces the eigenvalues to be reciprocal: if one eigenvalue grows (&gt;1),
          the other must shrink (&lt;1).
        </p>

        <h3>Step 3: Introduce the stability parameter b</h3>
        <p>
          Define
        </p>
        <div class="eqrow">
          <div class="eq" id="eq4">b = (A + D)/2.</div>
          <button class="copy" data-copy="b = (A + D)/2">Copy equation</button>
        </div>
        <p>
          This “half-trace” is standard in resonator stability:
          <span style="font-family:var(--mono)">|b| &lt; 1</span> → stable (oscillatory), and
          <span style="font-family:var(--mono)">|b| &gt; 1</span> → unstable (exponential).
        </p>

        <h3>Step 4: Find the eigenvalues h₁, h₂</h3>
        <p>
          Eigenvalues <span style="font-family:var(--mono)">h</span> satisfy <span style="font-family:var(--mono)">det(T − hI)=0</span>:
        </p>
        <div class="eqrow">
          <div class="eq" id="eq5">
det( [ [A-h, B], [C, D-h] ] ) = (A-h)(D-h) - BC = 0.
          </div>
          <button class="copy" data-copy="(A-h)(D-h) - BC = 0">Copy equation</button>
        </div>
        <p>
          Expand and use <span style="font-family:var(--mono)">AD − BC = 1</span>:
        </p>
        <div class="eqrow">
          <div class="eq" id="eq6">
(A-h)(D-h) - BC = AD - h(A+D) + h^2 - BC
               = (AD - BC) - h(A+D) + h^2
               = 1 - h(A+D) + h^2 = 0.
          </div>
          <button class="copy" data-copy="h^2 - h(A+D) + 1 = 0">Copy equation</button>
        </div>
        <p>
          Replace <span style="font-family:var(--mono)">A+D = 2b</span>:
        </p>
        <div class="eqrow">
          <div class="eq" id="eq7">h^2 − 2 b h + 1 = 0.</div>
          <button class="copy" data-copy="h^2 - 2 b h + 1 = 0">Copy equation</button>
        </div>
        <p>
          Solve the quadratic:
        </p>
        <div class="eqrow">
          <div class="eq" id="eq8">h_{1,2} = b ± √(b^2 − 1).</div>
          <button class="copy" data-copy="h_{1,2} = b ± sqrt(b^2 - 1)">Copy equation</button>
        </div>
        <p>
          <em>Interpretation:</em> For an unstable resonator, <span style="font-family:var(--mono)">|b| &gt; 1</span> so
          <span style="font-family:var(--mono)">√(b^2 − 1)</span> is real, hence <span style="font-family:var(--mono)">h₁,h₂</span> are real.
          Also, multiplying the roots gives <span style="font-family:var(--mono)">h₁ h₂ = 1</span>.
        </p>

        <h3>Step 5: Show y<sub>m</sub> is a linear combination of h<sup>m</sup></h3>
        <p>
          There are two clean ways to see this. We’ll present both briefly; either is a complete proof.
        </p>

        <h4>Method A (eigenvector expansion)</h4>
        <p>
          If <span style="font-family:var(--mono)">T</span> has two distinct eigenvalues (the generic case for <span style="font-family:var(--mono)">|b|≠1</span>),
          it has two linearly independent eigenvectors <span style="font-family:var(--mono)">v₁, v₂</span> such that
          <span style="font-family:var(--mono)">T v_i = h_i v_i</span>.
          Any initial ray vector can be decomposed as
        </p>
        <div class="eqrow">
          <div class="eq" id="eq9">r_0 = α₁ v₁ + α₂ v₂.</div>
          <button class="copy" data-copy="r_0 = α1 v1 + α2 v2">Copy equation</button>
        </div>
        <p>
          Apply <span style="font-family:var(--mono)">T^m</span>:
        </p>
        <div class="eqrow">
          <div class="eq" id="eq10">
r_m = T^m r_0 = α₁ T^m v₁ + α₂ T^m v₂
    = α₁ h₁^m v₁ + α₂ h₂^m v₂.
          </div>
          <button class="copy" data-copy="r_m = α1 h1^m v1 + α2 h2^m v2">Copy equation</button>
        </div>
        <p>
          The position <span style="font-family:var(--mono)">y_m</span> is the first component of <span style="font-family:var(--mono)">r_m</span>, so it has the same
          “two-exponential” structure:
        </p>
        <div class="eqrow">
          <div class="eq" id="eq11">y_m = α₁' h₁^m + α₂' h₂^m,</div>
          <button class="copy" data-copy="y_m = α1 h1^m + α2 h2^m">Copy equation</button>
        </div>
        <p>
          where <span style="font-family:var(--mono)">α₁', α₂'</span> are constants determined by the initial ray and the eigenvectors.
          (Many texts simply rename them <span style="font-family:var(--mono)">α₁, α₂</span>, as the problem statement does.)
        </p>

        <h4>Method B (second-order scalar recurrence for y<sub>m</sub>)</h4>
        <p>
          Because <span style="font-family:var(--mono)">T</span> is 2×2 with determinant 1, the Cayley–Hamilton theorem implies
        </p>
        <div class="eqrow">
          <div class="eq" id="eq12">T^2 − (A + D)T + I = 0  ⟹  T^2 − 2b T + I = 0.</div>
          <button class="copy" data-copy="T^2 - 2b T + I = 0">Copy equation</button>
        </div>
        <p>
          Apply this identity to <span style="font-family:var(--mono)">r_m</span>:
        </p>
        <div class="eqrow">
          <div class="eq" id="eq13">
(T^2 − 2b T + I) r_m = 0
⟹ r_{m+2} − 2b r_{m+1} + r_m = 0.
          </div>
          <button class="copy" data-copy="r_{m+2} - 2b r_{m+1} + r_m = 0">Copy equation</button>
        </div>
        <p>
          Taking the first component gives a scalar recurrence:
        </p>
        <div class="eqrow">
          <div class="eq" id="eq14">y_{m+2} − 2b y_{m+1} + y_m = 0.</div>
          <button class="copy" data-copy="y_{m+2} - 2b y_{m+1} + y_m = 0">Copy equation</button>
        </div>
        <p>
          Try a solution of the form <span style="font-family:var(--mono)">y_m = h^m</span>. Substituting gives
          <span style="font-family:var(--mono)">h^2 − 2b h + 1 = 0</span>, whose roots are exactly
          <span style="font-family:var(--mono)">h₁, h₂ = b ± √(b²−1)</span>.
          Therefore the general solution is
        </p>

        <div class="eqrow">
          <div class="eq" id="eq15">y_m = α₁ h₁^m + α₂ h₂^m.</div>
          <button class="copy" data-copy="y_m = α1 h1^m + α2 h2^m">Copy equation</button>
        </div>

        <h3>Step 6: Connect b to cavity geometry (what the given b means)</h3>
        <p>
          In a two-mirror resonator, the round-trip matrix <span style="font-family:var(--mono)">T</span> is built from propagation over distance <span style="font-family:var(--mono)">d</span>
          and reflections from mirrors of curvature <span style="font-family:var(--mono)">R₁, R₂</span>. The exact algebra depends on the sign convention used for <span style="font-family:var(--mono)">R</span>
          (concave vs convex) and where you place the reference plane.
        </p>
        <p>
          What is universal is that the stability parameter is the half-trace:
          <span style="font-family:var(--mono)">b = (A + D)/2</span>.
          The problem statement supplies the geometry-dependent expression for <span style="font-family:var(--mono)">b</span>; we use it directly:
        </p>

        <div class="eqrow">
          <div class="eq" id="eq16">b = 2(1 + d/R₁)(1 + d/R₂) − 1.   (as given)</div>
          <button class="copy" data-copy="b = 2(1 + d/R1)(1 + d/R2) - 1">Copy equation</button>
        </div>

        <div class="callouts">
          <div class="box final">
            <h4>Final Answer <span class="tag">boxed</span></h4>
            <p style="margin:8px 0 10px;color:var(--muted)">
              For an unstable resonator (|b| &gt; 1), the ray position after <em>m</em> round trips is
            </p>
            <div class="eq" style="margin:0 0 10px; white-space:pre-wrap" id="finalEq">
y_m = α₁ h₁^m + α₂ h₂^m,
h₁ = b + √(b² − 1),   h₂ = b − √(b² − 1),
b = (A + D)/2  (and for this cavity, b is given by the stated function of d, R₁, R₂).
            </div>
            <button class="copy" data-copy="y_m = α1 h1^m + α2 h2^m;  h1 = b + sqrt(b^2 - 1);  h2 = b - sqrt(b^2 - 1);  b = (A + D)/2">Copy final answer</button>
          </div>

          <div class="box keye">
            <h4>Sanity checks <span class="tag">quick</span></h4>
            <ul>
              <li><strong>Units:</strong> <span style="font-family:var(--mono)">h</span> and <span style="font-family:var(--mono)">b</span> are dimensionless ⇒ <span style="font-family:var(--mono)">α₁, α₂</span> have units of meters, matching <span style="font-family:var(--mono)">y</span>.</li>
              <li><strong>Reciprocal eigenvalues:</strong> from the quadratic, <span style="font-family:var(--mono)">h₁ h₂ = 1</span>.</li>
              <li><strong>Unstable growth:</strong> if <span style="font-family:var(--mono)">|b| &gt; 1</span>, then one of <span style="font-family:var(--mono)">|h|</span> is &gt; 1 ⇒ exponential divergence.</li>
              <li><strong>Stable limit:</strong> if <span style="font-family:var(--mono)">|b| &lt; 1</span>, write <span style="font-family:var(--mono)">b = cos μ</span> ⇒ <span style="font-family:var(--mono)">h = e^{± i μ}</span>, giving bounded oscillations.</li>
            </ul>
          </div>
        </div>

        <h3>Connecting to the diagram & plots</h3>
        <p>
          The diagram below shows a two-mirror cavity and a representative ray. The plots visualize how the derived
          exponential-in-<span style="font-family:var(--mono)">m</span> form manifests: when <span style="font-family:var(--mono)">|b|</span> crosses 1,
          the eigenvalues become real and the ray height grows rapidly with round trips.
        </p>

        <div class="controls" aria-label="Interactive controls">
          <div class="ctrl">
            <label>
              <span>Mirror separation <span style="font-family:var(--mono)">d</span> (m)</span>
              <span class="val" id="dVal">0.30</span>
            </label>
            <input id="dSlider" type="range" min="0.02" max="0.60" step="0.01" value="0.30" />
            <div class="note">Changes <span style="font-family:var(--mono)">b</span>, hence <span style="font-family:var(--mono)">h₁,h₂</span> and growth.</div>
          </div>
          <div class="ctrl">
            <label>
              <span>Initial position <span style="font-family:var(--mono)">y₀</span> (mm)</span>
              <span class="val" id="y0Val">0.50</span>
            </label>
            <input id="y0Slider" type="range" min="-3.0" max="3.0" step="0.05" value="0.50" />
            <div class="note">Sets overall scale via <span style="font-family:var(--mono)">α₁,α₂</span>.</div>
          </div>
          <div class="ctrl">
            <label>
              <span>Next round-trip position <span style="font-family:var(--mono)">y₁</span> (mm)</span>
              <span class="val" id="y1Val">0.20</span>
            </label>
            <input id="y1Slider" type="range" min="-3.0" max="3.0" step="0.05" value="0.20" />
            <div class="note">Together with <span style="font-family:var(--mono)">y₀</span> determines <span style="font-family:var(--mono)">α₁,α₂</span>.</div>
          </div>
        </div>

        <div class="grid2" style="margin-top:12px">
          <figure class="canvasShort">
            <canvas id="cDiagram" aria-label="Resonator diagram"></canvas>
            <figcaption class="figcap">
              <strong>Diagram:</strong> two-mirror resonator (radii <span style="font-family:var(--mono)">R₁, R₂</span>, spacing <span style="font-family:var(--mono)">d</span>) and a ray whose transverse height is tracked once per round trip.
            </figcaption>
          </figure>

          <figure class="canvasTall">
            <canvas id="cMain" aria-label="Main plot y_m versus m"></canvas>
            <figcaption class="figcap">
              <strong>Main plot:</strong> <span style="font-family:var(--mono)">y_m</span> vs round trips <span style="font-family:var(--mono)">m</span>.
              Solid: closed form <span style="font-family:var(--mono)">α₁ h₁^m + α₂ h₂^m</span>. Dots: recurrence <span style="font-family:var(--mono)">y_{m+2}=2b y_{m+1}-y_m</span>.
            </figcaption>
          </figure>
        </div>

        <figure style="margin-top:12px">
          <canvas id="cSweep" aria-label="Parameter sweep of b and eigenvalues versus d"></canvas>
          <figcaption class="figcap">
            <strong>Secondary plot (parameter sweep):</strong> how <span style="font-family:var(--mono)">b(d)</span> and <span style="font-family:var(--mono)">|h₁(d)|</span> behave as you vary cavity length <span style="font-family:var(--mono)">d</span>.
            The stability boundary is <span style="font-family:var(--mono)">|b|=1</span>.
          </figcaption>
        </figure>
      </section>

      <section id="part4">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpreting the final formula</h3>
        <ul>
          <li><span style="font-family:var(--mono)">h₁</span> and <span style="font-family:var(--mono)">h₂</span> are the <em>per-round-trip multipliers</em> along the two eigen-directions of phase space (specific combinations of <span style="font-family:var(--mono)">y</span> and <span style="font-family:var(--mono)">θ</span>).</li>
          <li><span style="font-family:var(--mono)">α₁, α₂</span> tell you how much your initial ray overlaps with those eigen-directions.</li>
          <li>Because <span style="font-family:var(--mono)">h₁ h₂ = 1</span>, one eigen-direction is expanding while the other is contracting (for <span style="font-family:var(--mono)">|b|&gt;1</span>).</li>
        </ul>

        <h3>How parameter changes affect the outcome (connect to plots)</h3>
        <ul>
          <li>Changing <span style="font-family:var(--mono)">d</span> changes <span style="font-family:var(--mono)">b</span> (via the given expression), which changes <span style="font-family:var(--mono)">h₁, h₂</span>.</li>
          <li>As <span style="font-family:var(--mono)">|b|</span> increases above 1, <span style="font-family:var(--mono)">|h₁|</span> grows and the main plot shows faster divergence in <span style="font-family:var(--mono)">|y_m|</span>.</li>
          <li>Near the boundary <span style="font-family:var(--mono)">|b|≈1</span>, growth is slower (eigenvalues close to ±1), so the ray may look almost linear for small <span style="font-family:var(--mono)">m</span> before exploding.</li>
        </ul>

        <h3>Alternative derivation idea</h3>
        <p>
          Instead of eigenvalues, you can derive the recurrence directly from the matrix mapping:
          write <span style="font-family:var(--mono)">y_{m+1} = A y_m + B θ_m</span> and
          <span style="font-family:var(--mono)">θ_{m+1} = C y_m + D θ_m</span>, eliminate <span style="font-family:var(--mono)">θ_m</span>,
          and use <span style="font-family:var(--mono)">AD-BC=1</span> to obtain
          <span style="font-family:var(--mono)">y_{m+2} - (A+D) y_{m+1} + y_m = 0</span>.
          This is the same recurrence as in PART 3, Method B.
        </p>

        <h3>Concept checks (with answers)</h3>
        <ul>
          <li><strong>Q:</strong> Why are there two exponentials? <strong>A:</strong> The dynamics is governed by a 2×2 matrix with two eigenvalues, so the general solution is a linear combination of two eigenmodes.</li>
          <li><strong>Q:</strong> In an unstable cavity, must <span style="font-family:var(--mono)">|h₁|</span> and <span style="font-family:var(--mono)">|h₂|</span> both exceed 1? <strong>A:</strong> No. Since <span style="font-family:var(--mono)">h₁ h₂ = 1</span>, if one is &gt;1 the other is &lt;1.</li>
          <li><strong>Q:</strong> What changes at <span style="font-family:var(--mono)">|b|=1</span>? <strong>A:</strong> The eigenvalues merge at ±1 (a repeated root). The solution becomes polynomial×exponential (a degenerate case).</li>
          <li><strong>Q:</strong> Why do stable cavities correspond to complex eigenvalues? <strong>A:</strong> For <span style="font-family:var(--mono)">|b|&lt;1</span>, write <span style="font-family:var(--mono)">b=cos μ</span>, then <span style="font-family:var(--mono)">h=e^{±iμ}</span> has unit magnitude, giving bounded oscillations.</li>
        </ul>
      </section>

      <section id="part5">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

        <h3>What each canvas shows</h3>
        <ul>
          <li><strong>Diagram canvas:</strong> a schematic two-mirror resonator with separation <span style="font-family:var(--mono)">d</span> and mirror curvatures <span style="font-family:var(--mono)">R₁, R₂</span>. The ray’s transverse height is sampled once per round trip on the left mirror.</li>
          <li><strong>Main plot:</strong> <span style="font-family:var(--mono)">y_m</span> (mm) versus round-trip index <span style="font-family:var(--mono)">m</span> (dimensionless). It overlays two computations:
            <ul>
              <li>Closed form: <span style="font-family:var(--mono)">y_m = α₁ h₁^m + α₂ h₂^m</span></li>
              <li>Recurrence check: <span style="font-family:var(--mono)">y_{m+2} = 2b y_{m+1} − y_m</span></li>
            </ul>
          </li>
          <li><strong>Secondary plot (sweep):</strong> shows how <span style="font-family:var(--mono)">b(d)</span> and <span style="font-family:var(--mono)">|h₁(d)|</span> vary with <span style="font-family:var(--mono)">d</span>. The stability boundary is marked by <span style="font-family:var(--mono)">|b|=1</span>.</li>
        </ul>

        <h3>Interactive controls</h3>
        <ul>
          <li><strong>Slider <span style="font-family:var(--mono)">d</span>:</strong> changes the geometry-dependent <span style="font-family:var(--mono)">b</span>, which changes <span style="font-family:var(--mono)">h₁,h₂</span>, updating <em>all</em> canvases.</li>
          <li><strong>Sliders <span style="font-family:var(--mono)">y₀</span> and <span style="font-family:var(--mono)">y₁</span>:</strong> set initial conditions for the recurrence and therefore determine <span style="font-family:var(--mono)">α₁,α₂</span>. If you choose initial conditions aligned with the contracting eigen-direction, growth can be temporarily suppressed—but generic choices diverge.</li>
        </ul>

        <div class="box" style="margin-top:10px">
          <h4>Example values used for plotting <span class="tag">clearly labeled</span></h4>
          <p style="margin:6px 0;color:var(--muted)">
            The problem statement is symbolic; for plots we choose fixed example mirror radii:
            <span style="font-family:var(--mono)">R₁ = 0.20 m</span>, <span style="font-family:var(--mono)">R₂ = 0.25 m</span>.
            You vary <span style="font-family:var(--mono)">d</span> with the slider. (These values are only for visualization.)
          </p>
        </div>
      </section>
    </main>
  </div>

  <footer>
    Built with vanilla HTML/CSS/JS (no external libraries). Copy buttons copy plain text. Canvases render crisply with devicePixelRatio handling.
  </footer>

<script>
/* -----------------------------
   Smooth scrolling for ToC
------------------------------ */
document.querySelectorAll('[data-scroll]').forEach(a=>{
  a.addEventListener('click', (e)=>{
    e.preventDefault();
    const id = a.getAttribute('href');
    const el = document.querySelector(id);
    if(!el) return;
    el.scrollIntoView({behavior:'smooth', block:'start'});
  });
});

/* -----------------------------
   Copy buttons
------------------------------ */
async function copyText(txt){
  try{
    await navigator.clipboard.writeText(txt);
    return true;
  }catch(err){
    // fallback
    const ta=document.createElement('textarea');
    ta.value=txt;
    document.body.appendChild(ta);
    ta.select();
    try{ document.execCommand('copy'); document.body.removeChild(ta); return true; }
    catch(e){ document.body.removeChild(ta); return false; }
  }
}
document.querySelectorAll('button.copy').forEach(btn=>{
  btn.addEventListener('click', async ()=>{
    const t = btn.getAttribute('data-copy') || '';
    const ok = await copyText(t);
    const old = btn.textContent;
    btn.textContent = ok ? 'Copied ✓' : 'Copy failed';
    setTimeout(()=>btn.textContent=old, 900);
  });
});

/* -----------------------------
   Canvas utilities (HiDPI + axes)
------------------------------ */
function setupCanvas(canvas){
  const ctx = canvas.getContext('2d');
  function resize(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(2, Math.floor(rect.width * dpr));
    canvas.height = Math.max(2, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return {w: rect.width, h: rect.height, dpr};
  }
  return {ctx, resize};
}

function drawPanel(ctx, w, h){
  ctx.clearRect(0,0,w,h);
  // background
  ctx.fillStyle = 'rgba(0,0,0,0.12)';
  ctx.fillRect(0,0,w,h);
  // subtle grid overlay
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  const step = 32;
  for(let x=0;x<=w;x+=step){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
  }
  for(let y=0;y<=h;y+=step){
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
  }
  ctx.restore();
}

function niceTicks(min, max, count){
  // returns tick values with "nice" step
  const span = max - min;
  if(span <= 0) return [min];
  const raw = span / Math.max(1,count);
  const pow = Math.pow(10, Math.floor(Math.log10(raw)));
  const candidates = [1,2,5,10].map(m=>m*pow);
  let step = candidates[0];
  for(const c of candidates){ if(Math.abs(raw-c) < Math.abs(raw-step)) step=c; }
  const start = Math.ceil(min/step)*step;
  const ticks = [];
  for(let v=start; v<=max+1e-12; v+=step) ticks.push(v);
  return ticks;
}

function drawAxes(ctx, plot){
  const {x0,y0, pw, ph, xmin,xmax,ymin,ymax, xLabel,yLabel, title} = plot;

  // title
  ctx.save();
  ctx.fillStyle = 'rgba(255,255,255,0.92)';
  ctx.font = '700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText(title, x0, y0-10);
  ctx.restore();

  // frame
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1;
  ctx.strokeRect(x0,y0,pw,ph);
  ctx.restore();

  // ticks + grid
  const xt = niceTicks(xmin,xmax,7);
  const yt = niceTicks(ymin,ymax,6);

  ctx.save();
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.70)';
  ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  ctx.lineWidth = 1;

  function X(x){ return x0 + (x-xmin)/(xmax-xmin)*pw; }
  function Y(y){ return y0 + ph - (y-ymin)/(ymax-ymin)*ph; }

  // grid + x ticks
  xt.forEach(v=>{
    const xx = X(v);
    ctx.beginPath(); ctx.moveTo(xx,y0); ctx.lineTo(xx,y0+ph); ctx.stroke();
    ctx.fillText(String(+v.toFixed(3)).replace(/\.?0+$/,''), xx-10, y0+ph+16);
    // tick mark
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.beginPath(); ctx.moveTo(xx,y0+ph); ctx.lineTo(xx,y0+ph+5); ctx.stroke();
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  });

  // grid + y ticks
  yt.forEach(v=>{
    const yy = Y(v);
    ctx.beginPath(); ctx.moveTo(x0,yy); ctx.lineTo(x0+pw,yy); ctx.stroke();
    ctx.fillText(String(+v.toFixed(3)).replace(/\.?0+$/,''), x0-46, yy+4);
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.beginPath(); ctx.moveTo(x0-5,yy); ctx.lineTo(x0,yy); ctx.stroke();
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  });

  // labels
  ctx.save();
  ctx.fillStyle = 'rgba(255,255,255,0.78)';
  ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText(xLabel, x0 + pw - ctx.measureText(xLabel).width, y0+ph+34);
  ctx.translate(x0-58, y0 + ph/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
  ctx.restore();

  ctx.restore();
  return {X,Y};
}

function drawLegend(ctx, x, y, items){
  ctx.save();
  const pad=10, lineH=18;
  const w = Math.max(...items.map(it=>ctx.measureText(it.label).width)) + 58;
  const h = pad*2 + items.length*lineH;
  ctx.fillStyle='rgba(0,0,0,0.35)';
  ctx.strokeStyle='rgba(255,255,255,0.14)';
  ctx.lineWidth=1;
  ctx.beginPath();
  const r=12;
  roundRect(ctx,x,y,w,h,r);
  ctx.fill();
  ctx.stroke();
  items.forEach((it,i)=>{
    const yy = y + pad + i*lineH + 6;
    // line sample
    ctx.strokeStyle = it.stroke;
    ctx.lineWidth = it.width || 2;
    ctx.beginPath(); ctx.moveTo(x+12,yy); ctx.lineTo(x+36,yy); ctx.stroke();
    if(it.marker){
      ctx.fillStyle = it.stroke;
      ctx.beginPath(); ctx.arc(x+24,yy,3.5,0,Math.PI*2); ctx.fill();
    }
    ctx.fillStyle='rgba(255,255,255,0.80)';
    ctx.font='12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(it.label, x+44, yy+4);
  });
  ctx.restore();
}
function roundRect(ctx,x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}

/* -----------------------------
   Physics model used for plots
------------------------------ */
// Example values for plotting
const R1 = 0.20; // m
const R2 = 0.25; // m

// b as given by the problem statement (geometry-dependent), used for the recurrence and eigenvalues
function bOf(d){
  // Using the expression shown in the prompt image: b = 2(1 + d/R1)(1 + d/R2) − 1
  return 2*(1 + d/R1)*(1 + d/R2) - 1;
}

function eigenvaluesFromB(b){
  const disc = b*b - 1;
  if(disc >= 0){
    const s = Math.sqrt(disc);
    return {h1: b + s, h2: b - s, type:'real'};
  }else{
    const s = Math.sqrt(-disc);
    // complex conjugate: b ± i s
    return {h1: {re:b, im:s}, h2:{re:b, im:-s}, type:'complex'};
  }
}

// closed form y_m for real eigenvalues (unstable) AND for stable case (oscillatory)
function yClosedForm(m, y0, y1, b){
  // Use recurrence solution:
  // If |b|>1: y_m = α1 h1^m + α2 h2^m, h1,2 = b ± sqrt(b^2-1)
  // If |b|<1: b=cos μ -> y_m = A cos(m μ) + B sin(m μ)
  const absb = Math.abs(b);

  if(absb > 1 + 1e-12){
    const {h1,h2} = eigenvaluesFromB(b);
    // Solve for α1, α2 from y0 = α1 + α2, y1 = α1 h1 + α2 h2
    const denom = (h1 - h2);
    const a1 = (y1 - y0*h2)/denom;
    const a2 = (y0*h1 - y1)/denom;
    return a1*Math.pow(h1,m) + a2*Math.pow(h2,m);
  }else if(absb < 1 - 1e-12){
    const mu = Math.acos(b);
    // y0 = A
    // y1 = A cos μ + B sin μ -> B = (y1 - y0 cos μ)/sin μ
    const A = y0;
    const B = (y1 - y0*Math.cos(mu))/Math.sin(mu);
    return A*Math.cos(m*mu) + B*Math.sin(m*mu);
  }else{
    // near boundary |b|≈1: repeated root h=sign(b). General solution: y_m = (α1 + α2 m) h^m
    const h = (b>=0)? 1 : -1;
    // y0 = α1
    // y1 = (α1 + α2)*h
    const alpha1 = y0;
    const alpha2 = y1/h - alpha1;
    return (alpha1 + alpha2*m)*Math.pow(h,m);
  }
}

function yByRecurrence(M, y0, y1, b){
  const ys = new Array(M+1);
  ys[0]=y0; ys[1]=y1;
  for(let m=0; m<=M-2; m++){
    ys[m+2] = 2*b*ys[m+1] - ys[m];
  }
  return ys;
}

/* -----------------------------
   Rendering
------------------------------ */
const diagram = setupCanvas(document.getElementById('cDiagram'));
const mainPlot = setupCanvas(document.getElementById('cMain'));
const sweepPlot = setupCanvas(document.getElementById('cSweep'));

const dSlider = document.getElementById('dSlider');
const y0Slider = document.getElementById('y0Slider');
const y1Slider = document.getElementById('y1Slider');
const dVal = document.getElementById('dVal');
const y0Val = document.getElementById('y0Val');
const y1Val = document.getElementById('y1Val');

function format(x, digits=2){
  return (+x).toFixed(digits);
}
function formatSci(x){
  const ax=Math.abs(x);
  if(ax===0) return "0";
  if(ax<1e-3 || ax>1e3) return x.toExponential(2);
  return x.toFixed(4).replace(/\.?0+$/,'');
}

function drawDiagram(state){
  const {ctx, w, h} = state;
  drawPanel(ctx,w,h);

  const pad=20;
  const left = pad+20;
  const right = w-pad-20;
  const midY = h*0.52;

  // Mirrors as arcs
  ctx.save();
  ctx.strokeStyle='rgba(125,211,252,0.85)';
  ctx.lineWidth=2;

  // left mirror (M1)
  ctx.beginPath();
  ctx.arc(left+18, midY, 90, -Math.PI/2, Math.PI/2);
  ctx.stroke();

  // right mirror (M2)
  ctx.strokeStyle='rgba(167,139,250,0.85)';
  ctx.beginPath();
  ctx.arc(right-18, midY, 90, Math.PI/2, 3*Math.PI/2);
  ctx.stroke();
  ctx.restore();

  // axis
  ctx.save();
  ctx.strokeStyle='rgba(255,255,255,0.22)';
  ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(left+10, midY);
  ctx.lineTo(right-10, midY);
  ctx.stroke();
  ctx.restore();

  // a sample ray
  const y0mm = parseFloat(y0Slider.value);
  const y1mm = parseFloat(y1Slider.value);
  const y0 = y0mm*1e-3;
  const y1 = y1mm*1e-3;

  // map y (meters) to pixels
  const yScale = 85e-3; // 85 mm span to edge-ish (visual)
  function yPix(y){ return midY - (y / yScale) * (h*0.33); }

  const x1 = left+10;
  const x2 = right-10;

  ctx.save();
  ctx.strokeStyle='rgba(134,239,172,0.95)';
  ctx.lineWidth=2.2;

  // draw two segments suggesting a round trip
  ctx.beginPath();
  ctx.moveTo(x1, yPix(y0));
  ctx.lineTo(x2, yPix(y1));
  ctx.lineTo(x1, yPix(y0*0.6 - y1*0.4));
  ctx.stroke();

  // markers on left mirror where y_m is sampled
  ctx.fillStyle='rgba(255,255,255,0.9)';
  ctx.beginPath();
  ctx.arc(x1, yPix(y0), 3.8, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // dimension arrow for d
  ctx.save();
  ctx.strokeStyle='rgba(255,255,255,0.65)';
  ctx.fillStyle='rgba(255,255,255,0.80)';
  ctx.lineWidth=1.2;

  const ay = h*0.17;
  ctx.beginPath();
  ctx.moveTo(x1, ay); ctx.lineTo(x2, ay);
  ctx.stroke();
  ctx.beginPath(); // arrowheads
  ctx.moveTo(x1, ay); ctx.lineTo(x1+10, ay-5); ctx.lineTo(x1+10, ay+5); ctx.closePath(); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x2, ay); ctx.lineTo(x2-10, ay-5); ctx.lineTo(x2-10, ay+5); ctx.closePath(); ctx.fill();

  ctx.font='700 13px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';
  ctx.fillText(`d = ${format(parseFloat(dSlider.value),2)} m`, (x1+x2)/2 - 54, ay-10);

  // labels
  ctx.font='700 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText('Mirror 1 (R₁)', left-6, midY+112);
  ctx.fillText('Mirror 2 (R₂)', right-90, midY+112);

  ctx.font='600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillStyle='rgba(255,255,255,0.75)';
  ctx.fillText('Optical axis', (left+right)/2 - 38, midY-8);
  ctx.fillText('Sample y_m here', x1+10, yPix(y0)-10);
  ctx.restore();

  // small info box b, h1, h2
  const d = parseFloat(dSlider.value);
  const b = bOf(d);
  const eig = eigenvaluesFromB(b);

  ctx.save();
  ctx.font='12px var(--mono)';
  ctx.fillStyle='rgba(255,255,255,0.80)';
  const bx = pad+10, by = h-pad-64;
  ctx.fillStyle='rgba(0,0,0,0.35)';
  ctx.strokeStyle='rgba(255,255,255,0.14)';
  ctx.lineWidth=1;
  ctx.beginPath();
  roundRect(ctx, bx, by, 260, 56, 12);
  ctx.fill(); ctx.stroke();

  ctx.fillStyle='rgba(255,255,255,0.85)';
  ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';
  ctx.fillText(`b = ${formatSci(b)}`, bx+10, by+20);
  if(eig.type==='real'){
    ctx.fillText(`h₁ = ${formatSci(eig.h1)}  |h₁|=${formatSci(Math.abs(eig.h1))}`, bx+10, by+38);
  }else{
    ctx.fillText(`|h| = 1 (stable: complex phase)`, bx+10, by+38);
  }
  ctx.restore();
}

function drawMainPlot(state){
  const {ctx,w,h} = state;
  drawPanel(ctx,w,h);

  const d = parseFloat(dSlider.value);
  const b = bOf(d);
  const y0 = parseFloat(y0Slider.value)*1e-3;
  const y1 = parseFloat(y1Slider.value)*1e-3;

  const M = 40;
  const ysRec = yByRecurrence(M, y0, y1, b);
  const ysClosed = new Array(M+1).fill(0).map((_,m)=> yClosedForm(m,y0,y1,b));

  // determine y range
  const all = ysRec.concat(ysClosed);
  let ymin = Math.min(...all), ymax = Math.max(...all);
  if(!isFinite(ymin) || !isFinite(ymax)){ ymin=-1; ymax=1; }
  if(ymin===ymax){ ymin-=1e-3; ymax+=1e-3; }
  // add padding
  const pad = 0.12*(ymax-ymin);
  ymin -= pad; ymax += pad;

  // convert to mm for plotting
  ymin *= 1e3; ymax *= 1e3;

  // plot area
  const x0 = 62, y0p = 44, pw = w-86, ph = h-92;
  const plot = {
    x0, y0:y0p, pw, ph,
    xmin:0, xmax:M,
    ymin, ymax,
    xLabel:'m (round trips)',
    yLabel:'y_m (mm)',
    title:'Ray position vs round trips'
  };

  const {X,Y} = drawAxes(ctx, plot);

  // draw closed form line
  ctx.save();
  ctx.strokeStyle = 'rgba(125,211,252,0.95)';
  ctx.lineWidth = 2.2;
  ctx.beginPath();
  for(let m=0;m<=M;m++){
    const x = X(m);
    const y = Y(ysClosed[m]*1e3);
    if(m===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.restore();

  // draw recurrence points
  ctx.save();
  ctx.fillStyle = 'rgba(167,139,250,0.92)';
  for(let m=0;m<=M;m++){
    const x = X(m);
    const y = Y(ysRec[m]*1e3);
    ctx.beginPath();
    ctx.arc(x,y,3.2,0,Math.PI*2);
    ctx.fill();
  }
  ctx.restore();

  // annotate stability
  ctx.save();
  ctx.fillStyle='rgba(255,255,255,0.80)';
  ctx.font='600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  const stable = (Math.abs(b) < 1);
  const label = stable ? `Stable: |b| = ${formatSci(Math.abs(b))} < 1  (oscillatory)` :
                         `Unstable: |b| = ${formatSci(Math.abs(b))} > 1  (exponential)`;
  ctx.fillText(label, x0, y0p+ph+54);
  ctx.restore();

  // legend
  ctx.save();
  ctx.font='12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  drawLegend(ctx, x0+pw-214, y0p+10, [
    {label:'Closed form', stroke:'rgba(125,211,252,0.95)', width:2.2},
    {label:'Recurrence check', stroke:'rgba(167,139,250,0.92)', width:2.2, marker:true}
  ]);
  ctx.restore();
}

function drawSweepPlot(state){
  const {ctx,w,h} = state;
  drawPanel(ctx,w,h);

  // sweep d
  const dMin = parseFloat(dSlider.min);
  const dMax = parseFloat(dSlider.max);
  const N = 140;
  const ds = [];
  const bs = [];
  const hAbs = [];
  for(let i=0;i<N;i++){
    const d = dMin + (dMax-dMin)*i/(N-1);
    const b = bOf(d);
    ds.push(d);
    bs.push(b);
    const eig = eigenvaluesFromB(b);
    if(eig.type==='real'){
      hAbs.push(Math.max(Math.abs(eig.h1), Math.abs(eig.h2)));
    }else{
      hAbs.push(1);
    }
  }

  // ranges (b and |h|max share axis? We'll use two y-axes: left for b, right for |h|max)
  let bmin = Math.min(...bs), bmax = Math.max(...bs);
  let hmin = Math.min(...hAbs), hmax = Math.max(...hAbs);

  // pad
  const pb = 0.10*(bmax-bmin || 1);
  bmin -= pb; bmax += pb;
  const phh = 0.10*(hmax-hmin || 1);
  hmin = Math.max(0, hmin - phh);
  hmax += phh;

  const x0 = 62, y0 = 44, pw = w-110, ph = h-92;
  const plot = {
    x0, y0, pw, ph,
    xmin:dMin, xmax:dMax,
    ymin:bmin, ymax:bmax,
    xLabel:'d (m)',
    yLabel:'b (dimensionless)',
    title:'Parameter sweep: b(d) and max |h(d)|'
  };

  const {X,Y} = drawAxes(ctx, plot);

  // plot b(d)
  ctx.save();
  ctx.strokeStyle='rgba(134,239,172,0.92)';
  ctx.lineWidth=2.2;
  ctx.beginPath();
  for(let i=0;i<N;i++){
    const x = X(ds[i]);
    const y = Y(bs[i]);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.restore();

  // stability lines at b=+1 and b=-1
  ctx.save();
  ctx.strokeStyle='rgba(255,255,255,0.35)';
  ctx.setLineDash([6,6]);
  ctx.lineWidth=1.4;
  const yPlus = Y(1);
  const yMinus = Y(-1);
  ctx.beginPath(); ctx.moveTo(x0,yPlus); ctx.lineTo(x0+pw,yPlus); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x0,yMinus); ctx.lineTo(x0+pw,yMinus); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle='rgba(255,255,255,0.70)';
  ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';
  ctx.fillText('b=+1', x0+6, yPlus-6);
  ctx.fillText('b=-1', x0+6, yMinus-6);
  ctx.restore();

  // right y-axis for |h|max
  ctx.save();
  // axis line
  const xR = x0 + pw + 20;
  ctx.strokeStyle='rgba(255,255,255,0.18)';
  ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(xR,y0); ctx.lineTo(xR,y0+ph); ctx.stroke();

  // map hAbs to right axis
  function Yh(v){ return y0 + ph - (v-hmin)/(hmax-hmin)*ph; }

  // ticks for right axis
  ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';
  ctx.fillStyle='rgba(255,255,255,0.70)';
  ctx.strokeStyle='rgba(255,255,255,0.10)';
  const ht = niceTicks(hmin,hmax,6);
  ht.forEach(v=>{
    const yy = Yh(v);
    ctx.beginPath(); ctx.moveTo(x0,yy); ctx.lineTo(x0+pw,yy); ctx.stroke(); // grid shared
    ctx.strokeStyle='rgba(255,255,255,0.22)';
    ctx.beginPath(); ctx.moveTo(xR,yy); ctx.lineTo(xR+6,yy); ctx.stroke();
    ctx.strokeStyle='rgba(255,255,255,0.10)';
    ctx.fillText(String(+v.toFixed(3)).replace(/\.?0+$/,''), xR+10, yy+4);
  });

  // right axis label
  ctx.save();
  ctx.translate(xR+42, y0+ph/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillStyle='rgba(255,255,255,0.78)';
  ctx.font='600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText('max |h(d)| (dimensionless)', -92, 0);
  ctx.restore();

  // plot |h|max(d) on right axis
  ctx.strokeStyle='rgba(125,211,252,0.92)';
  ctx.lineWidth=2.2;
  ctx.beginPath();
  for(let i=0;i<N;i++){
    const x = X(ds[i]);
    const y = Yh(hAbs[i]);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  ctx.restore();

  // current d marker line
  const dNow = parseFloat(dSlider.value);
  const bNow = bOf(dNow);
  const eigNow = eigenvaluesFromB(bNow);
  const hNow = (eigNow.type==='real') ? Math.max(Math.abs(eigNow.h1), Math.abs(eigNow.h2)) : 1;

  ctx.save();
  ctx.strokeStyle='rgba(255,255,255,0.55)';
  ctx.lineWidth=1.6;
  const xNow = X(dNow);
  ctx.beginPath(); ctx.moveTo(xNow,y0); ctx.lineTo(xNow,y0+ph); ctx.stroke();

  // point markers
  ctx.fillStyle='rgba(134,239,172,0.95)';
  ctx.beginPath(); ctx.arc(xNow, Y(bNow), 4.0, 0, Math.PI*2); ctx.fill();

  ctx.fillStyle='rgba(125,211,252,0.95)';
  ctx.beginPath(); ctx.arc(xNow, Yh(hNow), 4.0, 0, Math.PI*2); ctx.fill();

  // small info text
  ctx.fillStyle='rgba(255,255,255,0.82)';
  ctx.font='600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  const txt = `at d=${format(dNow,2)} m:  b=${formatSci(bNow)},  max|h|=${formatSci(hNow)}`;
  ctx.fillText(txt, x0, y0+ph+54);

  // legend
  ctx.font='12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  drawLegend(ctx, x0+pw-230, y0+10, [
    {label:'b(d)', stroke:'rgba(134,239,172,0.92)', width:2.2},
    {label:'max |h(d)|', stroke:'rgba(125,211,252,0.92)', width:2.2}
  ]);
  ctx.restore();
}

function renderAll(){
  // update readouts
  dVal.textContent = format(parseFloat(dSlider.value),2);
  y0Val.textContent = format(parseFloat(y0Slider.value),2);
  y1Val.textContent = format(parseFloat(y1Slider.value),2);

  // resize and draw each canvas
  const D = diagram.resize();
  drawDiagram({ctx:diagram.ctx, w:D.w, h:D.h});

  const M = mainPlot.resize();
  drawMainPlot({ctx:mainPlot.ctx, w:M.w, h:M.h});

  const S = sweepPlot.resize();
  drawSweepPlot({ctx:sweepPlot.ctx, w:S.w, h:S.h});
}

// hook controls
[dSlider,y0Slider,y1Slider].forEach(el=>{
  el.addEventListener('input', renderAll);
});

// rerender on resize
let rAF = null;
window.addEventListener('resize', ()=>{
  if(rAF) cancelAnimationFrame(rAF);
  rAF = requestAnimationFrame(()=>{ rAF=null; renderAll(); });
});

// initial render
renderAll();
</script>
</body>
</html>
