<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Planar–Mirror Resonator Containing a Thin Lens (ABCD Matrix, Stability, Gaussian Mode)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.09);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.72);
      --faint: rgba(255,255,255,0.55);
      --accent:#7ee7ff;
      --accent2:#b6ffb0;
      --warn:#ffd36e;
      --danger:#ff7e9a;
      --ok:#77f2a1;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --serif: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;
    }
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background: radial-gradient(1200px 700px at 20% 0%, rgba(126,231,255,0.18), transparent 55%),
                  radial-gradient(900px 600px at 80% 20%, rgba(182,255,176,0.12), transparent 55%),
                  radial-gradient(1200px 900px at 50% 100%, rgba(255,211,110,0.10), transparent 60%),
                  var(--bg);
      line-height:1.55;
    }
    header{
      padding: 34px 18px 18px;
      max-width: 1200px;
      margin: 0 auto;
    }
    header .top{
      display:flex;
      gap:16px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-size: clamp(1.45rem, 2.3vw, 2.2rem);
      letter-spacing:-0.02em;
    }
    .subtitle{
      color: var(--muted);
      margin-top: 8px;
      max-width: 72ch;
    }
    .badge-row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 12px;
    }
    .badge{
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.10);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.9rem;
      color: var(--muted);
      backdrop-filter: blur(6px);
    }

    main{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 18px 60px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 18px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
    }

    nav#toc{
      position: sticky;
      top: 12px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.05));
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: var(--radius);
      padding: 14px 14px 10px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }
    @media (max-width: 980px){
      nav#toc{position: relative; top: 0}
    }
    #toc h2{
      margin:0 0 10px;
      font-size: 1rem;
      color: var(--text);
      letter-spacing: 0.01em;
    }
    #toc a{
      display:block;
      padding: 7px 10px;
      margin: 3px 0;
      border-radius: 12px;
      color: var(--muted);
      text-decoration:none;
      border: 1px solid transparent;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      font-size: 0.95rem;
    }
    #toc a:hover{
      background: rgba(126,231,255,0.10);
      border-color: rgba(126,231,255,0.20);
      color: var(--text);
      transform: translateY(-1px);
    }

    article{
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      overflow:hidden;
    }

    section{
      padding: 12px 0;
      border-top: 1px solid rgba(255,255,255,0.10);
    }
    section:first-of-type{border-top:none}
    h2{
      margin: 4px 0 10px;
      font-size: 1.25rem;
      letter-spacing:-0.01em;
    }
    h3{
      margin: 14px 0 8px;
      font-size: 1.08rem;
      color: rgba(255,255,255,0.92);
    }
    p{margin: 10px 0; color: var(--text)}
    ul{margin: 8px 0 10px 1.1em; color: var(--text)}
    li{margin: 6px 0}
    .muted{color: var(--muted)}
    .faint{color: var(--faint)}
    .mono{font-family: var(--mono)}
    .eq{
      font-family: var(--mono);
      font-size: 0.95rem;
      background: rgba(0,0,0,0.22);
      padding: 3px 6px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.10);
      white-space: nowrap;
    }
    .eq-block{
      background: rgba(0,0,0,0.22);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 12px 12px 10px;
      margin: 10px 0;
      position: relative;
      overflow:auto;
    }
    .eq-block pre{
      margin:0;
      font-family: var(--mono);
      font-size: 0.95rem;
      line-height:1.5;
      color: rgba(255,255,255,0.92);
      white-space: pre;
    }
    .copy-btn{
      position:absolute;
      top:10px;
      right:10px;
      border:none;
      background: rgba(126,231,255,0.14);
      color: var(--text);
      border: 1px solid rgba(126,231,255,0.28);
      padding: 7px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-size: 0.9rem;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
    }
    .copy-btn:hover{transform: translateY(-1px); background: rgba(126,231,255,0.20); border-color: rgba(126,231,255,0.40)}
    .copy-btn:active{transform: translateY(0px)}
    .copy-toast{
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.65);
      border: 1px solid rgba(255,255,255,0.15);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 999px;
      box-shadow: var(--shadow);
      opacity: 0;
      pointer-events:none;
      transition: opacity 160ms ease, transform 160ms ease;
      z-index: 50;
      backdrop-filter: blur(10px);
      font-size: 0.95rem;
    }
    .copy-toast.show{opacity:1; transform: translateX(-50%) translateY(-4px);}

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 900px){
      .grid{grid-template-columns: 1fr}
    }

    .callout{
      border-radius: 18px;
      padding: 12px 12px 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
    }
    .callout h4{
      margin: 0 0 6px;
      font-size: 1rem;
    }
    .callout.assumptions{border-color: rgba(182,255,176,0.25); background: rgba(182,255,176,0.07)}
    .callout.keyeq{border-color: rgba(126,231,255,0.25); background: rgba(126,231,255,0.07)}
    .callout.mistakes{border-color: rgba(255,211,110,0.30); background: rgba(255,211,110,0.08)}
    .callout.final{border-color: rgba(119,242,161,0.30); background: rgba(119,242,161,0.08)}
    .callout .tag{
      display:inline-block;
      font-size: 0.82rem;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.18);
      color: var(--muted);
      margin-right: 8px;
      transform: translateY(-1px);
    }

    .viz{
      margin-top: 10px;
      background: rgba(0,0,0,0.22);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      padding: 12px;
      overflow:hidden;
    }
    .viz h3{margin: 0 0 8px}
    .canvas-wrap{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    canvas{
      width: 100%;
      height: 320px;
      border-radius: 14px;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.10);
      display:block;
    }
    @media (max-width: 900px){
      canvas{height: 280px}
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    @media (max-width: 900px){
      .controls{grid-template-columns: 1fr}
    }
    .control{
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 16px;
      padding: 10px 10px 8px;
    }
    .control label{
      display:flex;
      justify-content: space-between;
      gap: 10px;
      align-items: baseline;
      font-size: 0.95rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .control .val{
      font-family: var(--mono);
      color: var(--text);
      font-size: 0.95rem;
    }
    input[type="range"]{width:100%}
    select{
      width:100%;
      border-radius: 12px;
      padding: 8px 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.25);
      color: var(--text);
      outline:none;
    }

    footer{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 18px 40px;
      color: var(--muted);
    }
    .print-note{color: var(--faint); font-size: 0.95rem}
    @media print{
      body{background:#fff; color:#000}
      nav#toc{display:none}
      article, .viz, .eq-block, .callout{box-shadow:none; backdrop-filter:none}
      canvas{border:1px solid #999}
      .copy-btn{display:none}
    }
  </style>
</head>

<body>
<header>
  <div class="top">
    <div>
      <h1>Planar–Mirror Resonator with a Thin Lens at the Center</h1>
      <div class="subtitle">
        We use the <span class="mono">ABCD</span> (ray-transfer) matrix method to (a) build the round-trip matrix, (b) extract the stability condition
        from the trace criterion, and (c) describe the self-consistent Gaussian beam that fits the cavity.
      </div>
      <div class="badge-row">
        <span class="badge">Paraxial optics</span>
        <span class="badge">ABCD matrices</span>
        <span class="badge">Resonator stability</span>
        <span class="badge">Gaussian beam mode</span>
      </div>
    </div>
  </div>
</header>

<main>
  <nav id="toc" aria-label="Table of contents">
    <h2>Contents</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
  </nav>

  <article>
    <!-- Quick Summary -->
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><span class="muted">What this is:</span> A two–plane-mirror optical resonator of length <span class="eq">d</span> with a thin lens of focal length <span class="eq">f</span> at the midpoint.</li>
        <li><span class="muted">Key physics idea:</span> The cavity repeats after a <em>round trip</em>; in paraxial optics that repetition is encoded by a 2×2 <span class="mono">ABCD</span> matrix.</li>
        <li><span class="muted">Governing tool:</span> Ray-transfer matrices: free space <span class="eq">P(L) = [[1, L],[0, 1]]</span>, thin lens <span class="eq">L(f) = [[1, 0],[-1/f, 1]]</span>.</li>
        <li><span class="muted">Round-trip matrix:</span> With plane mirrors (identity) and central lens, the round trip is <span class="eq">M = ( P(d/2) · L(f) · P(d/2) )²</span>.</li>
        <li><span class="muted">Stability test:</span> For any lossless first-order system, stable resonator modes require <span class="eq">|Tr(M)/2| &lt; 1</span>.</li>
        <li><span class="muted">Result:</span> Here <span class="eq">Tr(M)/2 = A = 1 − 2(d/f) + (d/f)²/2</span> so stability is <span class="eq">0 &lt; d &lt; 4f</span> (for a converging lens, <span class="eq">f &gt; 0</span>), with marginal boundaries at <span class="eq">d → 0</span> and <span class="eq">d = 4f</span>.</li>
        <li><span class="muted">Gaussian mode sketch:</span> In the stable range, the eigenmode has planar wavefronts at the plane mirrors (beam waists there) and a larger spot size at the lens.</li>
      </ul>
    </section>

    <!-- PART 0 -->
    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <h3>Core definitions (symbols & units)</h3>
      <ul>
        <li><span class="eq">y</span> — transverse ray height (m).</li>
        <li><span class="eq">θ</span> — paraxial ray angle relative to the local optical axis (rad, small).</li>
        <li><span class="eq">d</span> — mirror separation (m).</li>
        <li><span class="eq">f</span> — thin-lens focal length (m). For a converging lens, <span class="eq">f &gt; 0</span>.</li>
        <li><span class="eq">λ</span> — wavelength (m), used only when converting the ray result to a Gaussian beam size.</li>
        <li><span class="eq">M = [[A, B],[C, D]]</span> — ray-transfer (ABCD) matrix mapping <span class="eq">[y; θ]</span> between planes.</li>
      </ul>

      <h3>Physical meaning of <span class="mono">ABCD</span></h3>
      <p class="muted">
        The matrix relates <span class="eq">[y_out; θ_out] = M · [y_in; θ_in]</span>.
        Intuitively: <span class="eq">B</span> tells you how a starting angle becomes a position after propagation;
        <span class="eq">C</span> tells you how optical power (lenses/mirrors) couples position into angle.
      </p>

      <div class="callout keyeq">
        <h4><span class="tag">Key matrices</span>Paraxial building blocks</h4>
        <ul>
          <li>Free-space propagation by <span class="eq">L</span>:
            <span class="eq">P(L)= [[1, L],[0, 1]]</span>.</li>
          <li>Thin lens of focal length <span class="eq">f</span>:
            <span class="eq">L(f)= [[1, 0],[-1/f, 1]]</span>.</li>
          <li>Plane mirror: no focusing power → in the resonator matrix formalism (angle measured w.r.t. local propagation direction), it acts like the identity.</li>
        </ul>
      </div>

      <h3>Resonator stability principle</h3>
      <p class="muted">
        A stable cavity supports bounded transverse rays and, correspondingly, a self-reproducing Gaussian eigenmode.
        For a round-trip matrix <span class="eq">M</span> with <span class="eq">det(M)=1</span>, stability is equivalent to
        <span class="eq">|Tr(M)/2| &lt; 1</span>. This is the same as requiring the eigenvalues of <span class="eq">M</span> to be complex phases
        (not real magnification factors).
      </p>

      <h3>Gaussian beam link (why rays predict modes)</h3>
      <p class="muted">
        In paraxial wave optics, the complex beam parameter <span class="eq">q</span> transforms as
        <span class="eq">q_out = (A q_in + B)/(C q_in + D)</span>.
        A cavity mode satisfies the fixed-point condition <span class="eq">q = (Aq+B)/(Cq+D)</span> for the round trip.
        From <span class="eq">q</span> you get beam size <span class="eq">w</span> via
        <span class="eq">1/q = 1/R − i λ/(π w²)</span>.
      </p>

      <h3>Mini intuition examples (quick, conceptual)</h3>
      <ul>
        <li>If <span class="eq">f → ∞</span> (no lens), the cavity becomes plane–parallel: marginal/unstable (rays drift).</li>
        <li>If the lens is strong enough (smaller <span class="eq">f</span>), it can “refocus” the beam each pass, creating a stable mode even though both mirrors are flat.</li>
      </ul>

      <div class="callout mistakes">
        <h4><span class="tag">What to watch for</span>Typical pitfalls</h4>
        <ul>
          <li>Mixing sign conventions: for resonators, angles are usually defined relative to the <em>local</em> propagation direction, making a plane mirror effectively the identity element in the ABCD product.</li>
          <li>Forgetting the lens is encountered twice per round trip.</li>
          <li>Using the “single-pass” matrix in the stability test: stability uses the full round-trip matrix.</li>
          <li>Confusing ray stability with longitudinal resonance (frequency). Here we only analyze transverse stability/mode shape.</li>
        </ul>
      </div>
    </section>

    <!-- PART 1 -->
    <section id="part1">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Problem restatement (in plain words)</h3>
      <p>
        Two flat mirrors form a resonator of length <span class="eq">d</span>. A thin lens of focal length <span class="eq">f</span> sits exactly halfway between them, i.e. at distance <span class="eq">d/2</span> from each mirror.
        We must: (a) compute the ray-transfer matrix for one round trip starting at a mirror, (b) find the stability condition, and (c) describe/sketch the Gaussian mode under stable conditions.
      </p>

      <div class="grid">
        <div class="callout assumptions">
          <h4><span class="tag">Given</span>Quantities</h4>
          <ul>
            <li>Mirror separation: <span class="eq">d</span></li>
            <li>Lens focal length: <span class="eq">f</span></li>
            <li>Lens position: centered (<span class="eq">d/2</span> from each mirror)</li>
            <li>Plane mirrors (radius of curvature <span class="eq">R = ∞</span>)</li>
          </ul>
        </div>
        <div class="callout assumptions">
          <h4><span class="tag">Unknowns</span>What we must find</h4>
          <ul>
            <li>(a) Round-trip ABCD matrix <span class="eq">M</span></li>
            <li>(b) Stability condition on <span class="eq">d</span> and <span class="eq">f</span></li>
            <li>(c) Qualitative Gaussian beam shape: where the waist is, relative spot sizes at mirrors/lens</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why)</h3>
      <ul>
        <li><b>Paraxial (small-angle) approximation</b>: the cavity is analyzed with first-order optics, so ABCD matrices apply.</li>
        <li><b>Round-trip self-consistency</b>: resonator modes reproduce after a round trip; stability comes from eigenvalues of the round-trip matrix.</li>
        <li><b>Gaussian beam/q-parameter formalism</b>: once stable, the mode can be described by a fixed-point complex <span class="eq">q</span>.</li>
      </ul>
      <p class="muted">
        We do <em>not</em> need diffraction integrals or full Maxwell boundary conditions here because the problem explicitly targets first-order resonator theory (ABCD + stability).
      </p>

      <div class="callout assumptions">
        <h4><span class="tag">Assumptions</span>Model idealizations</h4>
        <ul>
          <li>Thin lens: negligible thickness; described solely by focal length <span class="eq">f</span>.</li>
          <li>Lossless, aligned elements; ignore aberrations and finite apertures.</li>
          <li>Paraxial rays and paraxial Gaussian beams.</li>
          <li>Plane mirrors provide reflection but no focusing power.</li>
          <li>Steady-state transverse mode (time-harmonic field).</li>
        </ul>
      </div>

      <h3>Possible approaches (compare 2–3)</h3>
      <ul>
        <li><b>ABCD matrix multiplication (best here):</b> fast, systematic, directly yields stability via trace. Ideal for textbook resonator problems.</li>
        <li><b>Unfolded cavity imaging argument:</b> treat reflections as continuing into mirror images; can give intuitive stability ranges, but still benefits from matrix algebra to avoid mistakes.</li>
        <li><b>Wave optics eigenmode solving:</b> use <span class="eq">q</span>-fixed-point directly. Powerful for beam sizes, but you still need the round-trip ABCD matrix first.</li>
      </ul>

      <p>
        <b>Chosen method:</b> ABCD matrix multiplication for the round trip, then apply the standard stability criterion, and finally solve the fixed-point <span class="eq">q</span> to interpret the Gaussian mode.
      </p>
    </section>

    <!-- PART 2 -->
    <section id="part2">
      <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

      <ol>
        <li>
          <b>Build element matrices</b>
          <div class="muted">Tool: <span class="eq">P(L)</span>, <span class="eq">L(f)</span>. Meaning: encode how rays evolve through each optical segment.</div>
        </li>
        <li>
          <b>Write the single-pass half-cavity matrix</b> from mirror → lens → mirror:
          <div class="muted">Tool: multiply in propagation order. Meaning: describes one transit between mirrors.</div>
        </li>
        <li>
          <b>Square it</b> to get the full round trip (lens is encountered twice):
          <div class="muted">Tool: <span class="eq">M = T²</span>. Meaning: maps a ray back to the starting mirror after one full loop.</div>
        </li>
        <li>
          <b>Extract <span class="mono">A,B,C,D</span></b> explicitly:
          <div class="muted">Meaning: needed for stability and for the Gaussian mode parameter.</div>
        </li>
        <li>
          <b>Apply stability criterion</b>:
          <div class="muted">Tool: <span class="eq">|Tr(M)/2| &lt; 1</span>. Meaning: bounded rays and a physical Gaussian mode exist.</div>
        </li>
        <li>
          <b>Interpret the mode</b> using the <span class="eq">q</span>-fixed-point condition:
          <div class="muted">Tool: <span class="eq">q = (Aq+B)/(Cq+D)</span>. Meaning: gives waist locations and sizes.</div>
        </li>
        <li>
          <b>Sanity checks</b>:
          <div class="muted">Units, limiting cases (<span class="eq">f→∞</span>, boundary <span class="eq">d=4f</span>), and physical shape.</div>
        </li>
      </ol>

      <div class="callout mistakes">
        <h4><span class="tag">Quick tips</span>Common mistakes to avoid</h4>
        <ul>
          <li>Matrix order: the rightmost matrix acts first.</li>
          <li>Don’t forget the lens appears twice per round trip.</li>
          <li>Use the <em>round-trip</em> matrix in the trace test, not a one-way matrix.</li>
          <li>Keep symbols consistent: use the same <span class="eq">d</span> and <span class="eq">f</span> in text and plots.</li>
        </ul>
      </div>
    </section>

    <!-- PART 3 -->
    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Physical intuition first (what we expect)</h3>
      <p>
        A plane–parallel cavity without a lens is not transversely stable: a slightly tilted ray keeps walking off.
        The lens provides focusing each time the light passes the center, acting like “distributed curvature” that can pull rays back toward the axis.
        So we expect a stable range when the cavity length <span class="eq">d</span> is not too large compared with <span class="eq">f</span>.
      </p>

      <h3>(a) Round-trip ray-transfer matrix</h3>
      <p>
        Define the ray vector as <span class="eq">r = [y; θ]</span> with <span class="eq">θ</span> measured relative to the local propagation direction.
        With this convention, a plane mirror contributes no focusing power to the ABCD product (it simply sends the ray back).
      </p>

      <div class="callout keyeq">
        <h4><span class="tag">Step 1</span>Element matrices</h4>
        <ul>
          <li>Propagation by distance <span class="eq">L</span>:
            <span class="eq">P(L)= [[1, L],[0, 1]]</span></li>
          <li>Thin lens:
            <span class="eq">L(f)= [[1, 0],[-1/f, 1]]</span></li>
        </ul>
      </div>

      <p>
        From the left mirror to the lens is a propagation of <span class="eq">d/2</span>, then a lens, then another propagation of <span class="eq">d/2</span> to the right mirror.
        The corresponding single-pass matrix (mirror → mirror) is:
      </p>

      <div class="eq-block">
        <button class="copy-btn" data-copy="T = P(d/2) · L(f) · P(d/2)">Copy</button>
        <pre>T = P(d/2) · L(f) · P(d/2)</pre>
      </div>

      <p class="muted">
        Explanation: the ray first propagates from the mirror to the lens (rightmost <span class="eq">P(d/2)</span> acts first), then gets refracted by the lens, then propagates to the opposite mirror.
      </p>

      <p>
        A <b>round trip</b> starting at (say) the left mirror hits the lens twice (going and returning), so the round-trip matrix is:
      </p>

      <div class="eq-block">
        <button class="copy-btn" data-copy="M = T² = ( P(d/2) · L(f) · P(d/2) )²">Copy</button>
        <pre>M = T² = ( P(d/2) · L(f) · P(d/2) )²</pre>
      </div>

      <p>
        Now compute <span class="eq">M = [[A, B],[C, D]]</span> explicitly. First, compute <span class="eq">T</span>.
        Let <span class="eq">a = d/2</span> for compactness:
      </p>

      <div class="eq-block">
        <button class="copy-btn" data-copy="P(a) = [[1, a],[0, 1]],  L(f) = [[1, 0],[-1/f, 1]]">Copy</button>
        <pre>P(a) = [[1, a],[0, 1]]
L(f) = [[1, 0],[-1/f, 1]]</pre>
      </div>

      <p>
        Multiply step-by-step:
      </p>

      <div class="eq-block">
        <button class="copy-btn" data-copy="First:  L(f)·P(a) = [[1, a],[-1/f, 1 - a/f]]">Copy</button>
        <pre>First:  L(f)·P(a) = [[1, a],
                      [-1/f, 1 - a/f]]</pre>
      </div>

      <p class="muted">Explanation: the lens adds optical power, turning height into angle through the <span class="eq">-1/f</span> term.</p>

      <div class="eq-block">
        <button class="copy-btn" data-copy="Then: T = P(a)·(L(f)·P(a)) = [[1 - a/f, 2a - a²/f],[-1/f, 1 - a/f]]">Copy</button>
        <pre>Then: T = P(a)·(L(f)·P(a))
      = [[1 - a/f,   2a - a²/f],
         [-1/f,      1 - a/f]]</pre>
      </div>

      <p class="muted">
        Explanation: because the cavity is symmetric about the lens, <span class="eq">T</span> has equal diagonal elements.
      </p>

      <p>
        Now square to get the round trip: <span class="eq">M = T²</span>. After algebra (shown here as the final expanded coefficients),
        with <span class="eq">a = d/2</span> substituted back, we obtain:
      </p>

      <div class="eq-block">
        <button class="copy-btn" data-copy="M = [[A, B],[C, D]],  with  A = D = 1 - 2(d/f) + (d/f)²/2,  B = d(d-2f)(d-4f)/(4f²),  C = (d-2f)/f²">Copy</button>
        <pre>M = [[A, B],
     [C, D]]

A = D = 1 − 2(d/f) + (d/f)²/2

B = d(d − 2f)(d − 4f) / (4 f²)

C = (d − 2f) / f²</pre>
      </div>

      <p class="muted">
        Explanation: the symmetry keeps <span class="eq">A = D</span>. Also, because this is a lossless first-order system, <span class="eq">det(M)=1</span> (a good internal check).
      </p>

      <h3>(b) Stability condition</h3>
      <p>
        For a resonator with round-trip matrix <span class="eq">M</span> and <span class="eq">det(M)=1</span>, the stability condition is:
      </p>

      <div class="eq-block">
        <button class="copy-btn" data-copy="Stability: |Tr(M)/2| < 1  (with det(M)=1)">Copy</button>
        <pre>Stability: |Tr(M)/2| &lt; 1  (with det(M)=1)</pre>
      </div>

      <p>
        Here <span class="eq">Tr(M) = A + D = 2A</span>, so <span class="eq">Tr(M)/2 = A</span>. Therefore:
      </p>

      <div class="eq-block">
        <button class="copy-btn" data-copy="A = 1 - 2(d/f) + (d/f)²/2, so stability requires |1 - 2(d/f) + (d/f)²/2| < 1">Copy</button>
        <pre>A = 1 − 2(d/f) + (d/f)²/2

Stability requires:
| 1 − 2(d/f) + (d/f)²/2 | &lt; 1</pre>
      </div>

      <p>
        Let <span class="eq">x = d/f</span>. Solve <span class="eq">| (x² − 4x + 2)/2 | &lt; 1</span>.
        This inequality yields the stable range:
      </p>

      <div class="callout final">
        <h4><span class="tag">Final</span>Stability condition</h4>
        <div class="eq-block" style="margin:8px 0 0;">
          <button class="copy-btn" data-copy="Stable (for a converging lens f>0): 0 < d < 4f  (marginal at d→0 and d=4f; also Tr/2 = -1 at d=2f is marginal)">Copy</button>
          <pre>Stable (for a converging lens f &gt; 0):
0 &lt; d &lt; 4f

Marginal boundaries:
d → 0  (plane–parallel limit)
d = 4f
Also: d = 2f gives Tr(M)/2 = −1 (marginal)</pre>
        </div>
      </div>

      <h3>Sanity checks (stability result)</h3>
      <ul>
        <li><b>Units:</b> the condition compares lengths; <span class="eq">d</span> and <span class="eq">f</span> both in meters → consistent.</li>
        <li><b>Limit <span class="eq">f → ∞</span>:</b> then <span class="eq">A → 1</span> (marginal/unstable), matching a pure plane–parallel cavity.</li>
        <li><b>Large cavity length:</b> if <span class="eq">d &gt; 4f</span>, <span class="eq">|A| &gt; 1</span>, rays grow each round trip → no bounded mode.</li>
      </ul>

      <h3>(c) Gaussian beam that fits the resonator (qualitative sketch + key formulas)</h3>
      <p>
        Under stable conditions, there is a self-consistent Gaussian eigenmode. Because the mirrors are plane and the cavity is symmetric,
        the mode has planar phase fronts at the plane mirrors—equivalently, the beam has a <b>waist at each mirror</b>.
        The spot size grows toward the middle and is largest at the lens plane.
      </p>

      <p>
        To make that quantitative, solve the fixed-point for <span class="eq">q</span> using the round-trip matrix:
        <span class="eq">q = (Aq+B)/(Cq+D)</span>.
        Here <span class="eq">A=D</span>, so the fixed-point reduces to <span class="eq">C q² = B</span>, i.e.
      </p>

      <div class="eq-block">
        <button class="copy-btn" data-copy="Because A=D, the cavity mode satisfies C q² = B → q² = B/C = d(d-4f)/4">Copy</button>
        <pre>Because A = D:
C q² = B  ⇒  q² = B/C

Here:
B/C = d(d − 4f)/4</pre>
      </div>

      <p>
        In the stable range <span class="eq">0 &lt; d &lt; 4f</span>, the factor <span class="eq">d(d-4f)</span> is negative, so <span class="eq">q</span> is purely imaginary:
      </p>

      <div class="eq-block">
        <button class="copy-btn" data-copy="Stable: q = i z_R with z_R = (1/2) sqrt(d(4f-d))  (at a plane mirror reference plane)">Copy</button>
        <pre>Stable: q = i z_R  (at a plane mirror)

z_R = (1/2) √( d(4f − d) )</pre>
      </div>

      <p class="muted">
        Interpretation: a purely imaginary <span class="eq">q</span> means <span class="eq">Re(1/q)=0</span> → infinite wavefront radius → planar phase at the mirror, consistent with a plane mirror.
      </p>

      <p>
        If you want beam sizes, introduce wavelength <span class="eq">λ</span> (not given in the problem; used only for plotting/illustration):
        the waist radius at each plane mirror is
      </p>

      <div class="eq-block">
        <button class="copy-btn" data-copy="Mirror waist radius: w_m = sqrt( λ z_R / π ) = sqrt( (λ/(2π)) * sqrt(d(4f-d)) )">Copy</button>
        <pre>Mirror waist radius:
w_m = √( λ z_R / π )
    = √( (λ/(2π)) · √( d(4f − d) ) )</pre>
      </div>

      <p>
        The lens is at distance <span class="eq">d/2</span> from either mirror waist, so the spot size at the lens plane is (free-space Gaussian expansion from a waist):
      </p>

      <div class="eq-block">
        <button class="copy-btn" data-copy="w_l = w_m * sqrt(1 + ( (d/2)/z_R )^2 ) = w_m * sqrt( 4f/(4f-d) )">Copy</button>
        <pre>Spot size at lens (center):
w_l = w_m · √( 1 + ( (d/2)/z_R )² )
    = w_m · √( 4f/(4f − d) )</pre>
      </div>

      <div class="callout final">
        <h4><span class="tag">Sketch</span>What the Gaussian mode looks like</h4>
        <ul>
          <li>Beam has a <b>waist at the left plane mirror</b>.</li>
          <li>It expands toward the center, reaching a <b>maximum radius at the lens plane</b>.</li>
          <li>Then it symmetrically contracts back to a <b>waist at the right plane mirror</b>.</li>
          <li>The lens “rescues” transverse stability by refocusing the beam each pass.</li>
        </ul>
      </div>

      <p class="muted">
        Connection to the diagram/plots below: the stability plot highlights <span class="eq">0&lt;d/f&lt;4</span>. The beam-size plot shows how <span class="eq">w_m</span> and <span class="eq">w_l</span> vary across that stable range.
      </p>
    </section>

    <!-- PART 4 -->
    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the formulas (what controls what)</h3>
      <ul>
        <li><span class="eq">A = Tr(M)/2</span> controls stability: when <span class="eq">|A|&lt;1</span>, round-trip eigenvalues are complex phases (bounded rays).</li>
        <li>The key dimensionless knob is <span class="eq">x = d/f</span>. Changing <span class="eq">d</span> or <span class="eq">f</span> only matters through their ratio for stability.</li>
        <li><span class="eq">z_R = (1/2)√(d(4f−d))</span> sets the Gaussian confinement: larger <span class="eq">z_R</span> means a bigger waist and slower divergence.</li>
        <li>As <span class="eq">d → 4f</span>, <span class="eq">z_R → 0</span>: the mode “pinches” and the center spot size blows up (you approach the edge of stability).</li>
      </ul>

      <h3>How parameters change the outcome (tie to interactive plots)</h3>
      <ul>
        <li>Increase <span class="eq">d</span> at fixed <span class="eq">f</span>: you move rightward on the stability plot. The cavity becomes unstable once <span class="eq">d ≥ 4f</span>.</li>
        <li>Increase <span class="eq">f</span> at fixed <span class="eq">d</span> (weaker lens): you move leftward in <span class="eq">d/f</span> but also approach the plane–parallel limit; stability becomes marginal as <span class="eq">f→∞</span>.</li>
        <li>Within stability, the beam sizes depend on wavelength as <span class="eq">w ∝ √λ</span>, but the stability boundary does not.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p class="muted">
        You can “unfold” the resonator: replace reflections by mirror images so the beam always propagates forward.
        Then one round trip corresponds to passing through a periodic sequence where the central lens is effectively encountered twice per period.
        The same <span class="mono">ABCD</span> trace condition emerges from Floquet theory (periodic ray dynamics).
      </p>

      <h3>Concept checks (self-test)</h3>
      <ul>
        <li><b>Q:</b> Why does the lens appear twice in <span class="eq">M</span>? <b>A:</b> A round trip goes mirror → lens → other mirror → lens → back.</li>
        <li><b>Q:</b> What does <span class="eq">|Tr(M)/2| &lt; 1</span> mean physically? <b>A:</b> Rays don’t grow without bound; they oscillate transversely instead of diverging.</li>
        <li><b>Q:</b> What happens as <span class="eq">f→∞</span>? <b>A:</b> The system becomes plane–parallel; <span class="eq">A→1</span> (marginal), no robust stable mode.</li>
        <li><b>Q:</b> Where are the waists in the stable symmetric solution? <b>A:</b> At the plane mirrors; spot size peaks at the lens.</li>
      </ul>
    </section>

    <!-- Visualizations -->
    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="viz">
        <h3>Interactive diagram + stability & mode-size plots</h3>
        <div class="canvas-wrap">
          <canvas id="cDiagram" aria-label="Cavity diagram"></canvas>
          <canvas id="cMain" aria-label="Main plot: stability metric"></canvas>
          <canvas id="cSecondary" aria-label="Secondary plot: beam sizes"></canvas>
        </div>

        <div class="controls" role="group" aria-label="Interactive controls">
          <div class="control">
            <label for="sF">
              <span>Focal length <span class="eq">f</span> (m)</span>
              <span class="val" id="vF"></span>
            </label>
            <input id="sF" type="range" min="0.05" max="1.00" step="0.01" value="0.25"/>
            <div class="faint">Converging lens (example values for plots).</div>
          </div>

          <div class="control">
            <label for="sD">
              <span>Cavity length <span class="eq">d</span> (m)</span>
              <span class="val" id="vD"></span>
            </label>
            <input id="sD" type="range" min="0.05" max="3.50" step="0.01" value="0.60"/>
            <div class="faint">Try pushing <span class="eq">d</span> past <span class="eq">4f</span> to see instability.</div>
          </div>

          <div class="control">
            <label for="sLam">
              <span>Wavelength <span class="eq">λ</span> (nm)</span>
              <span class="val" id="vLam"></span>
            </label>
            <input id="sLam" type="range" min="400" max="1550" step="10" value="1064"/>
            <div class="faint">Only affects beam sizes (not stability).</div>
          </div>

          <div class="control">
            <label for="selScale">
              <span>Secondary plot scale</span>
              <span class="val" id="vScale"></span>
            </label>
            <select id="selScale">
              <option value="abs" selected>Absolute (mm)</option>
              <option value="norm">Normalized (w / w_m)</option>
            </select>
            <div class="faint">Switch between absolute and normalized mode sizes.</div>
          </div>
        </div>

        <p class="muted" style="margin-top:10px">
          <b>Diagram:</b> shows mirrors, the central lens, and the distances <span class="eq">d/2</span>.<br/>
          <b>Main plot:</b> graphs the stability metric <span class="eq">|Tr(M)/2| = |A|</span> versus <span class="eq">d/f</span>; stable where it lies below 1.<br/>
          <b>Secondary plot:</b> shows the mirror waist radius <span class="eq">w_m</span> and lens spot radius <span class="eq">w_l</span> versus <span class="eq">d/f</span> (using your chosen <span class="eq">λ</span>).
        </p>
      </div>
    </section>
  </article>
</main>

<footer>
  <div class="print-note">
    Tip: The plotted numbers use example values (you control <span class="eq">f</span>, <span class="eq">d</span>, <span class="eq">λ</span>) because the problem statement is symbolic.
    The symbolic results in the “Final” boxes are the main answers.
  </div>
</footer>

<div id="toast" class="copy-toast" aria-live="polite"></div>

<script>
/* ---------------------- Copy buttons ---------------------- */
(function(){
  const toast = document.getElementById('toast');
  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.classList.remove('show'), 1200);
  }
  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      showToast('Copied ✓');
    }catch(e){
      // Fallback
      const ta = document.createElement('textarea');
      ta.value = txt;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      ta.remove();
      showToast('Copied ✓');
    }
  }
  document.addEventListener('click', (ev)=>{
    const btn = ev.target.closest('.copy-btn');
    if(!btn) return;
    const txt = btn.getAttribute('data-copy') || '';
    copyText(txt);
  });
})();

/* ---------------------- Math helpers ---------------------- */
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function fmt(x, digits=3){
  if(!isFinite(x)) return '—';
  const ax = Math.abs(x);
  if(ax !== 0 && (ax < 1e-3 || ax >= 1e4)) return x.toExponential(2);
  return x.toFixed(digits);
}

/* ---------------------- Canvas rendering (HiDPI) ---------------------- */
function setupHiDPI(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(1, Math.floor(rect.width * dpr));
  const h = Math.max(1, Math.floor(rect.height * dpr));
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h;
  }
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  return {ctx, w: rect.width, h: rect.height, dpr};
}

function drawAxes(ctx, x0, y0, w, h, xMin, xMax, yMin, yMax, opts){
  const {
    title='', xLabel='', yLabel='',
    grid=true, nXTicks=6, nYTicks=6
  } = opts || {};

  // panel background
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.18)';
  ctx.fillRect(x0, y0, w, h);

  // border
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 1;
  ctx.strokeRect(x0+0.5, y0+0.5, w-1, h-1);

  // mapping
  const X = (x)=> x0 + (x - xMin) / (xMax - xMin) * w;
  const Y = (y)=> y0 + h - (y - yMin) / (yMax - yMin) * h;

  // grid + ticks
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.72)';
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;

  if(grid){
    for(let i=0;i<=nXTicks;i++){
      const xt = xMin + i*(xMax-xMin)/nXTicks;
      const xx = X(xt);
      ctx.beginPath(); ctx.moveTo(xx, y0); ctx.lineTo(xx, y0+h); ctx.stroke();
    }
    for(let j=0;j<=nYTicks;j++){
      const yt = yMin + j*(yMax-yMin)/nYTicks;
      const yy = Y(yt);
      ctx.beginPath(); ctx.moveTo(x0, yy); ctx.lineTo(x0+w, yy); ctx.stroke();
    }
  }

  // tick labels
  ctx.fillStyle = 'rgba(255,255,255,0.72)';
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  for(let i=0;i<=nXTicks;i++){
    const xt = xMin + i*(xMax-xMin)/nXTicks;
    const xx = X(xt);
    ctx.beginPath(); ctx.moveTo(xx, y0+h); ctx.lineTo(xx, y0+h+5); ctx.stroke();
    ctx.fillText(fmt(xt,2), xx-10, y0+h+18);
  }
  for(let j=0;j<=nYTicks;j++){
    const yt = yMin + j*(yMax-yMin)/nYTicks;
    const yy = Y(yt);
    ctx.beginPath(); ctx.moveTo(x0-5, yy); ctx.lineTo(x0, yy); ctx.stroke();
    ctx.fillText(fmt(yt,2), x0-44, yy+4);
  }

  // titles/labels
  ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillStyle = 'rgba(255,255,255,0.92)';
  ctx.fillText(title, x0+10, y0+20);

  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillStyle = 'rgba(255,255,255,0.72)';
  ctx.fillText(xLabel, x0 + w - 10 - ctx.measureText(xLabel).width, y0 + h - 10);

  // y label (rotated)
  ctx.save();
  ctx.translate(x0+12, y0+18);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  ctx.restore();
  return {X, Y};
}

/* ---------------------- Optics formulas ---------------------- */
/*
Round-trip matrix:
M = ( P(d/2) L(f) P(d/2) )^2
A = D = 1 - 2(d/f) + (d/f)^2 / 2
B = d(d-2f)(d-4f)/(4 f^2)
C = (d-2f)/f^2

Stability metric: s = |Tr/2| = |A|, stable if s < 1.
Rayleigh range at plane mirror (stable): zR = 0.5*sqrt(d(4f-d))
Mirror waist: w_m = sqrt( λ zR / π )
Lens spot (center): w_l = w_m * sqrt(4f/(4f-d))  (stable only)
*/
function A_of(df){ // df = d/f
  return 1 - 2*df + 0.5*df*df;
}
function stable(d,f){
  return (f > 0) && (d > 0) && (d < 4*f) && (Math.abs(A_of(d/f)) < 1);
}
function zR(d,f){
  // Only meaningful in stable range
  const val = d*(4*f - d);
  if(val <= 0) return NaN;
  return 0.5*Math.sqrt(val);
}
function wMirror(d,f,lambda){
  const zr = zR(d,f);
  if(!isFinite(zr)) return NaN;
  return Math.sqrt(lambda*zr/Math.PI);
}
function wLens(d,f,lambda){
  const wm = wMirror(d,f,lambda);
  if(!isFinite(wm)) return NaN;
  const denom = (4*f - d);
  if(denom <= 0) return NaN;
  return wm*Math.sqrt(4*f/denom);
}

/* ---------------------- Draw: diagram ---------------------- */
function drawDiagram(canvas, params){
  const {ctx, w, h} = setupHiDPI(canvas);
  ctx.clearRect(0,0,w,h);

  // Layout
  const pad = 16;
  const xL = pad + 20;
  const xR = w - pad - 20;
  const yC = h*0.52;
  const lensX = (xL+xR)/2;

  // Background hint
  ctx.fillStyle = 'rgba(0,0,0,0.16)';
  ctx.fillRect(0,0,w,h);

  // Mirrors
  ctx.strokeStyle = 'rgba(255,255,255,0.75)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(xL, yC-90); ctx.lineTo(xL, yC+90);
  ctx.moveTo(xR, yC-90); ctx.lineTo(xR, yC+90);
  ctx.stroke();

  // Mirror labels
  ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.fillText('Plane mirror', xL-10, yC-105);
  ctx.fillText('Plane mirror', xR-110, yC-105);

  // Lens (thin lens symbol)
  ctx.strokeStyle = 'rgba(126,231,255,0.95)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(lensX, yC-95); ctx.lineTo(lensX, yC+95);
  ctx.stroke();

  // Lens arcs
  ctx.strokeStyle = 'rgba(126,231,255,0.55)';
  ctx.lineWidth = 2;
  const arcH = 85;
  ctx.beginPath();
  ctx.arc(lensX-10, yC, 70, -Math.PI/2, Math.PI/2);
  ctx.arc(lensX+10, yC, 70, Math.PI/2, -Math.PI/2);
  ctx.stroke();

  ctx.fillStyle = 'rgba(126,231,255,0.92)';
  ctx.fillText('Thin lens (f)', lensX-45, yC-110);

  // Axis
  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  ctx.lineWidth = 1.5;
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.moveTo(pad, yC); ctx.lineTo(w-pad, yC);
  ctx.stroke();
  ctx.setLineDash([]);

  // Distance markers d/2 and d
  ctx.strokeStyle = 'rgba(182,255,176,0.7)';
  ctx.lineWidth = 2;
  const yDim = yC + 120;
  // main d
  ctx.beginPath();
  ctx.moveTo(xL, yDim); ctx.lineTo(xR, yDim);
  ctx.stroke();
  // ticks
  ctx.beginPath();
  ctx.moveTo(xL, yDim-8); ctx.lineTo(xL, yDim+8);
  ctx.moveTo(xR, yDim-8); ctx.lineTo(xR, yDim+8);
  ctx.stroke();

  ctx.fillStyle = 'rgba(182,255,176,0.9)';
  ctx.fillText('d', (xL+xR)/2 - 6, yDim-10);

  // half distances
  const yHalf = yC + 92;
  ctx.strokeStyle = 'rgba(182,255,176,0.45)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(xL, yHalf); ctx.lineTo(lensX, yHalf);
  ctx.moveTo(lensX, yHalf); ctx.lineTo(xR, yHalf);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(xL, yHalf-7); ctx.lineTo(xL, yHalf+7);
  ctx.moveTo(lensX, yHalf-7); ctx.lineTo(lensX, yHalf+7);
  ctx.moveTo(xR, yHalf-7); ctx.lineTo(xR, yHalf+7);
  ctx.stroke();

  ctx.fillStyle = 'rgba(182,255,176,0.9)';
  ctx.fillText('d/2', (xL+lensX)/2 - 16, yHalf-10);
  ctx.fillText('d/2', (lensX+xR)/2 - 16, yHalf-10);

  // Example Gaussian envelope sketch
  const {d, f, lambda} = params;
  const isStable = stable(d,f);
  const wm = wMirror(d,f,lambda);
  const wl = wLens(d,f,lambda);

  // scale envelope for drawing
  const maxDraw = 70; // px
  let scale = 1;
  if(isStable && isFinite(wl) && wl>0){
    // map wl to maxDraw
    scale = maxDraw / wl;
  }else{
    scale = 0.0;
  }

  // envelope
  if(isStable){
    ctx.strokeStyle = 'rgba(255,211,110,0.9)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<=200;i++){
      const t = i/200;
      const x = xL + t*(xR-xL);
      // map z from 0..d (left mirror to right mirror)
      const z = t*d;
      // waist at z=0 and z=d, approximate symmetric with maximum at center: use free-space from waist at mirror:
      const zr = zR(d,f);
      const wZ = Math.sqrt( (wm*wm) * (1 + (z/zr)*(z/zr)) ); // from left waist
      // but would blow near center; for nice symmetric sketch, blend from both ends:
      const wZ2 = Math.sqrt( (wm*wm) * (1 + ((d-z)/zr)*((d-z)/zr)) );
      const wSym = Math.min(wZ, wZ2); // take smaller (gives waist at both ends and max at center)
      const y = yC - wSym*scale;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    ctx.beginPath();
    for(let i=0;i<=200;i++){
      const t = i/200;
      const x = xL + t*(xR-xL);
      const z = t*d;
      const zr = zR(d,f);
      const wZ = Math.sqrt( (wm*wm) * (1 + (z/zr)*(z/zr)) );
      const wZ2 = Math.sqrt( (wm*wm) * (1 + ((d-z)/zr)*((d-z)/zr)) );
      const wSym = Math.min(wZ, wZ2);
      const y = yC + wSym*scale;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    ctx.fillStyle = 'rgba(255,211,110,0.92)';
    ctx.fillText('Gaussian mode envelope (qualitative)', pad+10, pad+22);
  }else{
    ctx.fillStyle = 'rgba(255,126,154,0.92)';
    ctx.fillText('Unstable: no bounded Gaussian eigenmode', pad+10, pad+22);
  }

  // Status box
  ctx.fillStyle = 'rgba(0,0,0,0.40)';
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 1;
  const bx = pad, by = h - pad - 64, bw = w - 2*pad, bh = 54;
  ctx.fillRect(bx,by,bw,bh);
  ctx.strokeRect(bx+0.5,by+0.5,bw-1,bh-1);

  ctx.font = '13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  const df = d/f;
  const A = A_of(df);
  ctx.fillStyle = 'rgba(255,255,255,0.86)';
  ctx.fillText(`Current ratio d/f = ${fmt(df,3)}   |Tr/2| = |A| = ${fmt(Math.abs(A),3)}   → ${Math.abs(A)<1 ? 'STABLE' : 'UNSTABLE'}`, bx+10, by+22);
  ctx.fillStyle = 'rgba(255,255,255,0.70)';
  ctx.fillText(`Example beam: w_m = ${isFinite(wm)? fmt(wm*1e3,3):'—'} mm,  w_l = ${isFinite(wl)? fmt(wl*1e3,3):'—'} mm   (λ=${Math.round(lambda*1e9)} nm)`, bx+10, by+42);
}

/* ---------------------- Draw: main plot (stability metric) ---------------------- */
function drawMainPlot(canvas, params){
  const {ctx, w, h} = setupHiDPI(canvas);
  ctx.clearRect(0,0,w,h);

  const padL = 56, padR = 18, padT = 28, padB = 34;
  const x0 = padL, y0 = padT, pw = w - padL - padR, ph = h - padT - padB;

  const xMin=0, xMax=6;
  const yMin=0, yMax=2.2;

  const axes = drawAxes(ctx, x0, y0, pw, ph, xMin, xMax, yMin, yMax, {
    title: 'Main plot: stability metric  s = |Tr(M)/2| = |A|  vs  d/f',
    xLabel: 'd/f (dimensionless)',
    yLabel: 's = |A|',
    nXTicks: 6, nYTicks: 6
  });
  const X = axes.X, Y = axes.Y;

  // stability threshold line s=1
  ctx.save();
  ctx.strokeStyle = 'rgba(255,211,110,0.9)';
  ctx.lineWidth = 2;
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.moveTo(X(xMin), Y(1));
  ctx.lineTo(X(xMax), Y(1));
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = 'rgba(255,211,110,0.9)';
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText('threshold s=1', X(xMax)-98, Y(1)-6);
  ctx.restore();

  // stable region shading for f>0: 0<d/f<4
  ctx.save();
  ctx.fillStyle = 'rgba(119,242,161,0.10)';
  const xA = X(0), xB = X(4);
  ctx.fillRect(xA, y0, xB-xA, ph);
  ctx.restore();

  // curve s(x) = |1 - 2x + x^2/2|
  ctx.save();
  ctx.strokeStyle = 'rgba(126,231,255,0.95)';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  const N=600;
  for(let i=0;i<=N;i++){
    const x = xMin + (xMax-xMin)*i/N;
    const s = Math.abs(A_of(x));
    const xx = X(x), yy = Y(s);
    if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
  }
  ctx.stroke();
  ctx.restore();

  // mark current d/f
  const df = params.d/params.f;
  const sCur = Math.abs(A_of(df));
  ctx.save();
  ctx.fillStyle = (sCur<1) ? 'rgba(119,242,161,0.95)' : 'rgba(255,126,154,0.95)';
  ctx.strokeStyle = 'rgba(0,0,0,0.35)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(X(df), Y(sCur), 6, 0, Math.PI*2);
  ctx.fill(); ctx.stroke();

  // legend
  const lx = x0 + 12, ly = y0 + 38;
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.fillRect(lx-6, ly-18, 240, 44);
  ctx.strokeRect(lx-6+0.5, ly-18+0.5, 240-1, 44-1);

  ctx.fillStyle = 'rgba(126,231,255,0.95)';
  ctx.fillRect(lx, ly-10, 18, 3);
  ctx.fillStyle = 'rgba(255,255,255,0.82)';
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText('s(d/f) = |1 − 2(d/f) + (d/f)²/2|', lx+26, ly-6);

  ctx.fillStyle = 'rgba(119,242,161,0.12)';
  ctx.fillRect(lx, ly+10, 18, 12);
  ctx.strokeStyle = 'rgba(119,242,161,0.25)';
  ctx.strokeRect(lx+0.5, ly+10+0.5, 18-1, 12-1);
  ctx.fillStyle = 'rgba(255,255,255,0.82)';
  ctx.fillText('stable band (f>0): 0 < d/f < 4', lx+26, ly+20);

  ctx.restore();
}

/* ---------------------- Draw: secondary plot (beam sizes) ---------------------- */
function drawSecondary(canvas, params){
  const {ctx, w, h} = setupHiDPI(canvas);
  ctx.clearRect(0,0,w,h);

  const padL = 56, padR = 18, padT = 28, padB = 34;
  const x0 = padL, y0 = padT, pw = w - padL - padR, ph = h - padT - padB;

  const xMin=0.05, xMax=3.95; // only stable interior; avoid endpoints
  const scaleMode = params.scaleMode;

  // y-range depends on scale mode
  let yMin, yMax, yLabel, title;
  if(scaleMode === 'norm'){
    yMin = 0.8; yMax = 6.0;
    yLabel = 'spot size (normalized)';
    title = 'Secondary plot: Gaussian spot sizes vs d/f (stable region)  —  normalized';
  }else{
    // absolute mm range (auto-ish, but fixed to keep axes stable)
    yMin = 0.0; yMax = 6.0; // mm, typical
    yLabel = 'spot size (mm)';
    title = 'Secondary plot: Gaussian spot sizes vs d/f (stable region)  —  absolute';
  }

  const axes = drawAxes(ctx, x0, y0, pw, ph, xMin, xMax, yMin, yMax, {
    title,
    xLabel: 'd/f (dimensionless)',
    yLabel,
    nXTicks: 6, nYTicks: 6
  });
  const X = axes.X, Y = axes.Y;

  const f = params.f;
  const lambda = params.lambda;

  // helper to compute sizes along x=d/f keeping f fixed
  function sizesAtX(x){
    const d = x * f;
    const wm = wMirror(d,f,lambda);
    const wl = wLens(d,f,lambda);
    return {wm, wl};
  }

  // curves
  const N=520;

  // Mirror waist curve
  ctx.save();
  ctx.strokeStyle = 'rgba(182,255,176,0.95)';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  for(let i=0;i<=N;i++){
    const x = xMin + (xMax-xMin)*i/N;
    const {wm} = sizesAtX(x);
    let y = wm * 1e3; // mm
    if(scaleMode === 'norm') y = 1.0;
    const xx = X(x), yy = Y(y);
    if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
  }
  ctx.stroke();
  ctx.restore();

  // Lens size curve
  ctx.save();
  ctx.strokeStyle = 'rgba(126,231,255,0.95)';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  for(let i=0;i<=N;i++){
    const x = xMin + (xMax-xMin)*i/N;
    const {wm, wl} = sizesAtX(x);
    let y = wl * 1e3; // mm
    if(scaleMode === 'norm') y = wl / wm;
    const xx = X(x), yy = Y(y);
    if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
  }
  ctx.stroke();
  ctx.restore();

  // marker at current x
  const xCur = params.d/params.f;
  const st = stable(params.d, params.f);
  if(xCur > xMin && xCur < xMax){
    const wm = wMirror(params.d, params.f, params.lambda);
    const wl = wLens(params.d, params.f, params.lambda);

    ctx.save();
    ctx.fillStyle = st ? 'rgba(119,242,161,0.95)' : 'rgba(255,126,154,0.95)';
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = 2;

    // mark wl curve point
    let yWl = (scaleMode === 'norm') ? (wl/wm) : (wl*1e3);
    ctx.beginPath();
    ctx.arc(X(xCur), Y(yWl), 6, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // mark wm curve point (only meaningful in abs plot)
    if(scaleMode !== 'norm'){
      let yWm = wm*1e3;
      ctx.beginPath();
      ctx.arc(X(xCur), Y(yWm), 5, 0, Math.PI*2);
      ctx.fill(); ctx.stroke();
    }
    ctx.restore();
  }

  // legend box
  ctx.save();
  const lx = x0 + 12, ly = y0 + 38;
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.fillRect(lx-6, ly-18, 230, 56);
  ctx.strokeRect(lx-6+0.5, ly-18+0.5, 230-1, 56-1);

  ctx.fillStyle = 'rgba(182,255,176,0.95)';
  ctx.fillRect(lx, ly-10, 18, 3);
  ctx.fillStyle = 'rgba(255,255,255,0.82)';
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText('Mirror waist w_m', lx+26, ly-6);

  ctx.fillStyle = 'rgba(126,231,255,0.95)';
  ctx.fillRect(lx, ly+12, 18, 3);
  ctx.fillStyle = 'rgba(255,255,255,0.82)';
  ctx.fillText('Lens spot w_l (center)', lx+26, ly+16);

  ctx.fillStyle = 'rgba(255,255,255,0.65)';
  ctx.fillText(`λ = ${Math.round(params.lambda*1e9)} nm`, lx, ly+38);
  ctx.restore();
}

/* ---------------------- Controller ---------------------- */
const cDiagram = document.getElementById('cDiagram');
const cMain = document.getElementById('cMain');
const cSecondary = document.getElementById('cSecondary');

const sF = document.getElementById('sF');
const sD = document.getElementById('sD');
const sLam = document.getElementById('sLam');
const selScale = document.getElementById('selScale');

const vF = document.getElementById('vF');
const vD = document.getElementById('vD');
const vLam = document.getElementById('vLam');
const vScale = document.getElementById('vScale');

function getParams(){
  const f = parseFloat(sF.value);
  const d = parseFloat(sD.value);
  const lambda = parseFloat(sLam.value)*1e-9;
  const scaleMode = selScale.value;
  return {f,d,lambda,scaleMode};
}

function updateLabels(p){
  vF.textContent = fmt(p.f,2);
  vD.textContent = fmt(p.d,2);
  vLam.textContent = `${Math.round(p.lambda*1e9)} nm`;
  vScale.textContent = (p.scaleMode === 'abs') ? 'Absolute (mm)' : 'Normalized';
}

function enforceRanges(){
  // Keep d slider max/min sensible relative to f for exploration but not mandatory.
  // We allow d up to 3.5 m so users can exceed 4f for small f.
  // But ensure d>0.
  sD.value = clamp(parseFloat(sD.value), parseFloat(sD.min), parseFloat(sD.max));
}

function renderAll(){
  enforceRanges();
  const p = getParams();
  updateLabels(p);
  drawDiagram(cDiagram, p);
  drawMainPlot(cMain, p);
  drawSecondary(cSecondary, p);
}

[sF,sD,sLam,selScale].forEach(el=> el.addEventListener('input', renderAll));
window.addEventListener('resize', renderAll);

// Initial render
renderAll();
</script>
</body>
</html>
