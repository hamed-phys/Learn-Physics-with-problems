<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Stability of Spherical-Mirror Resonators: Convex vs Concave Mirrors</title>
  <style>
    :root{
      --bg: #0b1020;
      --card:#0f1733;
      --card2:#0c1430;
      --text:#e9ecf6;
      --muted:#b9c0da;
      --faint:#7f89b3;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line: rgba(255,255,255,0.10);
      --line2: rgba(255,255,255,0.16);
      --shadow: 0 14px 40px rgba(0,0,0,0.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      background: radial-gradient(1200px 600px at 20% 0%, rgba(125,211,252,0.12), transparent 60%),
                  radial-gradient(900px 500px at 80% 10%, rgba(167,139,250,0.14), transparent 55%),
                  radial-gradient(900px 700px at 50% 100%, rgba(52,211,153,0.08), transparent 55%),
                  var(--bg);
      color: var(--text);
      line-height: 1.55;
      overflow-x:hidden;
    }

    header{
      padding: 28px 18px 10px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.25fr 0.75fr;
      gap: 18px;
      align-items: stretch;
    }
    @media (max-width: 980px){
      .hero{ grid-template-columns: 1fr; }
    }

    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 18px 18px 16px;
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .titleCard:before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(600px 220px at 20% 20%, rgba(125,211,252,0.18), transparent 60%),
                  radial-gradient(600px 220px at 80% 30%, rgba(167,139,250,0.18), transparent 60%);
      filter: blur(10px);
      opacity:0.7;
      z-index:0;
    }
    .titleCard > *{ position:relative; z-index:1; }

    h1{
      margin: 0 0 8px;
      font-size: clamp(1.35rem, 2.2vw, 2.05rem);
      letter-spacing: 0.2px;
    }
    .subtitle{
      margin: 0;
      color: var(--muted);
      font-size: 0.98rem;
    }
    .pillRow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top: 12px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,0.18);
      color: var(--muted);
      font-size: 0.86rem;
    }
    .dot{
      width: 8px; height:8px; border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(125,211,252,0.15);
    }

    .toc{
      position: sticky;
      top: 14px;
      align-self: start;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 14px 14px 12px;
      box-shadow: var(--shadow);
    }
    .toc h2{
      margin:0 0 8px;
      font-size: 0.95rem;
      letter-spacing:0.3px;
      color: var(--text);
    }
    .toc a{
      display:block;
      color: var(--muted);
      text-decoration:none;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid transparent;
      transition: 180ms ease;
      font-size: 0.92rem;
    }
    .toc a:hover{
      border-color: var(--line2);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      transform: translateX(2px);
    }

    main{
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px 18px 60px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    section{
      background: linear-gradient(180deg, rgba(255,255,255,0.045), rgba(255,255,255,0.022));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow);
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      .grid2{ grid-template-columns: 1fr; }
    }

    h2{
      margin: 0 0 10px;
      font-size: 1.2rem;
    }
    h3{
      margin: 16px 0 8px;
      font-size: 1.02rem;
      color: var(--text);
    }
    p{ margin: 8px 0; color: var(--muted); }
    ul{ margin: 8px 0 0 18px; color: var(--muted); }
    li{ margin: 6px 0; }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
    }
    @media (max-width: 980px){
      .callouts{ grid-template-columns: 1fr; }
    }
    .box{
      border: 1px solid var(--line);
      background: rgba(0,0,0,0.18);
      border-radius: 14px;
      padding: 12px 12px 10px;
      position:relative;
      overflow:hidden;
    }
    .box:before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(400px 180px at 0% 0%, rgba(125,211,252,0.14), transparent 55%),
                  radial-gradient(400px 180px at 100% 0%, rgba(167,139,250,0.12), transparent 55%);
      opacity:0.6;
      filter: blur(14px);
      z-index:0;
    }
    .box > *{ position:relative; z-index:1; }
    .box h4{
      margin: 0 0 6px;
      font-size: 0.95rem;
      letter-spacing: 0.2px;
    }

    .eq{
      font-family: var(--mono);
      color: var(--text);
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--line);
      padding: 6px 8px;
      border-radius: 12px;
      display:inline-block;
      max-width: 100%;
      overflow:auto;
      white-space: nowrap;
    }
    .eqBlock{
      display:flex;
      gap: 10px;
      align-items: stretch;
      margin: 10px 0;
      flex-wrap: wrap;
    }
    .copyBtn{
      appearance:none;
      border: 1px solid var(--line2);
      background: rgba(0,0,0,0.20);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 12px;
      cursor:pointer;
      transition: 180ms ease;
      font-size: 0.9rem;
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
    }
    .copyBtn:hover{
      transform: translateY(-1px);
      border-color: rgba(125,211,252,0.40);
      box-shadow: 0 10px 18px rgba(0,0,0,0.25);
    }
    .copyBtn:active{ transform: translateY(0px); }
    .copyIcon{
      width: 14px; height: 14px;
      border: 2px solid var(--muted);
      border-radius: 3px;
      position: relative;
      opacity:0.9;
    }
    .copyIcon:after{
      content:"";
      position:absolute;
      left: 4px; top: -5px;
      width: 14px; height: 14px;
      border: 2px solid var(--muted);
      border-radius: 3px;
      background: transparent;
      opacity:0.55;
    }

    .vizWrap{
      display:grid;
      grid-template-columns: 1.05fr 0.95fr;
      gap: 14px;
      align-items: start;
      margin-top: 8px;
    }
    @media (max-width: 980px){
      .vizWrap{ grid-template-columns: 1fr; }
    }
    figure{
      margin:0;
      border: 1px solid var(--line);
      background: rgba(0,0,0,0.18);
      border-radius: 16px;
      padding: 10px;
      overflow:hidden;
    }
    figcaption{
      color: var(--faint);
      font-size: 0.88rem;
      margin-top: 8px;
    }
    canvas{
      width: 100%;
      height: auto;
      display:block;
      border-radius: 12px;
      background: rgba(6,10,20,0.85);
      border: 1px solid rgba(255,255,255,0.08);
    }

    .controls{
      border: 1px solid var(--line);
      background: rgba(0,0,0,0.18);
      border-radius: 16px;
      padding: 12px;
    }
    .controlRow{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 8px;
    }
    label{
      display:block;
      color: var(--muted);
      font-size: 0.92rem;
      margin-bottom: 4px;
    }
    input[type="range"]{
      width: 100%;
      accent-color: var(--accent);
    }
    select{
      width:100%;
      padding: 9px 10px;
      border-radius: 12px;
      border: 1px solid var(--line2);
      background: rgba(0,0,0,0.25);
      color: var(--text);
      outline: none;
    }
    .readout{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top: 10px;
      color: var(--muted);
      font-size: 0.92rem;
    }
    .tag{
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.04);
      padding: 6px 10px;
      border-radius: 999px;
    }
    .statusGood{ color: var(--good); }
    .statusBad{ color: var(--bad); }
    .statusWarn{ color: var(--warn); }

    .final{
      border: 1px solid rgba(52,211,153,0.35);
      background: linear-gradient(180deg, rgba(52,211,153,0.10), rgba(0,0,0,0.18));
    }

    .small{
      color: var(--faint);
      font-size: 0.9rem;
    }

    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 0 18px 40px;
      color: var(--faint);
      font-size: 0.92rem;
    }

    /* Print-friendly */
    @media print{
      body{ background:#fff; color:#111; }
      section, .titleCard, .toc, figure, .controls{ box-shadow:none; background:#fff; }
      .toc{ position: static; }
      canvas{ border:1px solid #ddd; background:#fff; }
      .eq{ background:#f6f6f6; border-color:#ddd; color:#111; }
      .copyBtn{ display:none; }
      a{ color:#111; }
    }

    /* Subtle fade-in */
    @keyframes rise { from{ opacity:0; transform: translateY(8px);} to{ opacity:1; transform: translateY(0);} }
    section, .titleCard, .toc{ animation: rise 380ms ease both; }
  </style>
</head>

<body>
<header>
  <div class="hero">
    <div class="titleCard">
      <h1>11.2-5 — Stability of Spherical-Mirror Resonators</h1>
      <p class="subtitle">
        Determine whether a two-mirror optical resonator can be stable when the mirrors are (a) both convex, or (b) one convex and one concave.
        We’ll build the stability condition from paraxial ray optics (ABCD matrices), then apply it cleanly.
      </p>
      <div class="pillRow">
        <span class="pill"><span class="dot"></span>Paraxial / Gaussian optics</span>
        <span class="pill"><span class="dot" style="background:var(--accent2); box-shadow:0 0 0 3px rgba(167,139,250,0.15);"></span>ABCD stability</span>
        <span class="pill"><span class="dot" style="background:var(--good); box-shadow:0 0 0 3px rgba(52,211,153,0.12);"></span>Interactive stability plots</span>
      </div>
    </div>

    <nav class="toc" aria-label="Table of Contents">
      <h2>Contents</h2>
      <a href="#quick">Quick Summary</a>
      <a href="#primer">PART 0 — Concept Primer</a>
      <a href="#analysis">PART 1 — Problem Analysis</a>
      <a href="#strategy">PART 2 — Strategy & Tips</a>
      <a href="#solution">PART 3 — Full Solution</a>
      <a href="#deeper">PART 4 — Deeper Understanding</a>
      <a href="#vizguide">PART 5 — Visualization Guide</a>
    </nav>
  </div>
</header>

<main>
  <section id="quick">
    <h2>Quick Summary</h2>
    <ul>
      <li><b>What this is about:</b> When a two-mirror cavity “traps” nearby rays so they don’t walk off to infinity.</li>
      <li><b>Key physics idea:</b> Stability is determined by the round-trip ray-transfer (ABCD) matrix: bounded rays require eigenvalues on the unit circle.</li>
      <li><b>Governing condition (two spherical mirrors):</b> define <span class="eq">g1 = 1 − L/R1</span>, <span class="eq">g2 = 1 − L/R2</span>; then the cavity is stable iff <span class="eq">0 &lt; g1 g2 &lt; 1</span>.</li>
      <li><b>Sign convention:</b> here <span class="eq">R &gt; 0</span> = concave mirror (focusing for rays inside the cavity), <span class="eq">R &lt; 0</span> = convex mirror (defocusing).</li>
      <li><b>Result (a):</b> two convex mirrors ⇒ <span class="eq">g1 &gt; 1</span>, <span class="eq">g2 &gt; 1</span> ⇒ <span class="eq">g1 g2 &gt; 1</span> ⇒ <b>never stable</b> (for any finite separation <span class="eq">L &gt; 0</span>).</li>
      <li><b>Result (b):</b> one convex + one concave ⇒ can be stable for a range of <span class="eq">L</span> where the concave “focusing” compensates the convex “defocusing”; condition remains <span class="eq">0 &lt; (1 − L/Rc)(1 − L/Rv) &lt; 1</span> with <span class="eq">Rv &lt; 0</span>.</li>
      <li><b>Result type:</b> fully symbolic inequalities + interactive numeric examples in the plots.</li>
    </ul>
  </section>

  <section id="primer">
    <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

    <div class="callouts">
      <div class="box">
        <h4>Core definitions</h4>
        <ul>
          <li><b>Optical resonator:</b> two mirrors facing each other, separation <span class="eq">L</span> (meters), supporting repeated round trips.</li>
          <li><b>Radius of curvature:</b> <span class="eq">R</span> (meters). In this article:
            <ul>
              <li><span class="eq">R &gt; 0</span> means <b>concave</b> as seen from inside the cavity (focusing).</li>
              <li><span class="eq">R &lt; 0</span> means <b>convex</b> as seen from inside (defocusing).</li>
            </ul>
          </li>
          <li><b>g-parameter:</b> <span class="eq">g = 1 − L/R</span> (dimensionless). For two mirrors: <span class="eq">g1, g2</span>.</li>
        </ul>
      </div>

      <div class="box">
        <h4>Physical meaning</h4>
        <ul>
          <li><b>Stability</b> means small transverse deviations of rays (or Gaussian beams) stay bounded after many round trips.</li>
          <li><b>Concave mirrors</b> tend to refocus rays back toward the axis; <b>convex mirrors</b> push rays away.</li>
          <li><span class="eq">g1 g2</span> encodes the net focusing/defocusing of a round trip.</li>
        </ul>
      </div>
    </div>

    <h3>Key law / principle: ABCD matrix stability</h3>
    <p>
      In the paraxial approximation (small angles, near-axis rays), propagation through optical elements is linear in the ray vector
      <span class="eq">[x, θ]^T</span> (transverse position and angle). One round trip corresponds to a 2×2 matrix
      <span class="eq">M = [[A,B],[C,D]]</span>.
      Rays remain bounded if repeated application of <span class="eq">M</span> does not blow up.
    </p>

    <div class="box">
      <h4>Stability criterion (general)</h4>
      <p>
        For a lossless paraxial system with <span class="eq">det(M)=1</span>, stability requires the eigenvalues of <span class="eq">M</span> to lie on the unit circle,
        which is equivalent to:
      </p>
      <div class="eqBlock">
        <span class="eq" id="eqTrace">| (A + D)/2 | &lt; 1</span>
        <button class="copyBtn" data-copy="abs((A + D)/2) < 1">
          <span class="copyIcon" aria-hidden="true"></span>Copy
        </button>
      </div>
      <p class="small">
        At equality, you are at the stability boundary (marginal stability).
      </p>
    </div>

    <h3>Common model assumptions (why they’re used)</h3>
    <ul>
      <li><b>Paraxial rays:</b> small angles, so linear ray transfer works.</li>
      <li><b>Thin mirror approximation:</b> spherical mirror treated as a focusing element with focal strength <span class="eq">−2/R</span> in ABCD form.</li>
      <li><b>Perfect alignment:</b> no tilts/decenters; stability is about intrinsic geometry first.</li>
      <li><b>Geometric stability ↔ Gaussian mode existence:</b> in typical treatments, a stable ray cavity supports stable Gaussian eigenmodes.</li>
    </ul>

    <h3>Mini intuition examples</h3>
    <ul>
      <li><b>Two flat mirrors:</b> neither focuses; a slightly off-axis ray keeps drifting → marginal/unstable to perturbations.</li>
      <li><b>Two concave mirrors:</b> each bounce can refocus; many such cavities are stable if not too long.</li>
    </ul>

    <div class="box">
      <h4>What to watch for (pitfalls)</h4>
      <ul>
        <li><b>Sign convention for R:</b> convex vs concave flips the sign, and it matters a lot in <span class="eq">g = 1 − L/R</span>.</li>
        <li><b>“Stable” is not “high-Q”:</b> stability is geometric; it doesn’t guarantee low loss.</li>
        <li><b>Boundary cases:</b> <span class="eq">g1 g2 = 0</span> or <span class="eq">1</span> are <i>marginal</i>—tiny misalignment can destabilize.</li>
      </ul>
    </div>
  </section>

  <section id="analysis">
    <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

    <h3>Rewrite the problem</h3>
    <p>
      We have a two-mirror resonator made of spherical mirrors separated by distance <span class="eq">L</span>.
      The question asks:
      <b>(a)</b> can a cavity with <i>two convex mirrors</i> be stable?
      <b>(b)</b> can a cavity with <i>one convex and one concave mirror</i> be stable?
    </p>

    <div class="grid2">
      <div class="box">
        <h4>Given</h4>
        <ul>
          <li>Two spherical mirrors, radii <span class="eq">R1</span>, <span class="eq">R2</span> (meters).</li>
          <li>Separation <span class="eq">L &gt; 0</span> (meters).</li>
          <li>Mirror types:
            <ul>
              <li>Convex ⇒ <span class="eq">R &lt; 0</span></li>
              <li>Concave ⇒ <span class="eq">R &gt; 0</span></li>
            </ul>
          </li>
        </ul>
      </div>
      <div class="box">
        <h4>Unknowns / What must be found</h4>
        <ul>
          <li>Whether the stability inequalities can be satisfied in each case.</li>
          <li>If yes (case b), describe the allowed parameter region qualitatively (and with inequalities).</li>
        </ul>
      </div>
    </div>

    <h3>Relevant principles and why they apply</h3>
    <ul>
      <li><b>ABCD matrix optics:</b> spherical mirrors and free-space propagation are paraxial, linear transformations.</li>
      <li><b>Stability criterion:</b> bounded rays under repeated round trips correspond to matrix eigenvalues with magnitude 1.</li>
      <li><b>Why not full wave optics first?</b> The question is purely about stability (geometry). The ABCD method gives the standard, simplest stability test.</li>
    </ul>

    <div class="box">
      <h4>Assumptions (explicit)</h4>
      <ul>
        <li>Paraxial approximation (small angles, near-axis rays).</li>
        <li>Perfectly aligned mirrors and fixed separation <span class="eq">L</span>.</li>
        <li>Ideal spherical mirrors (no aberrations, no apertures/finite size limits).</li>
        <li>Losses ignored for stability (we only check boundedness, not finesse).</li>
      </ul>
    </div>

    <h3>Possible approaches (compare briefly)</h3>
    <ul>
      <li><b>(1) g-parameter stability formula:</b> Fastest—use known result <span class="eq">0 &lt; g1 g2 &lt; 1</span>. <i>Best for conceptual questions like this.</i></li>
      <li><b>(2) Build the ABCD matrix explicitly:</b> More “from first principles” and clarifies where the g’s come from. Slightly longer.</li>
      <li><b>(3) Gaussian beam q-parameter method:</b> Equivalent to ABCD but phrased in beam language; great when asked for waist/spot size.</li>
    </ul>

    <p>
      <b>Chosen approach:</b> Use the g-parameter stability condition (with a short derivation sketch via the trace criterion)
      because it directly answers “can it ever be stable?” by inequality reasoning.
    </p>
  </section>

  <section id="strategy">
    <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

    <ol style="color:var(--muted); margin: 8px 0 0 18px;">
      <li><b>Define sign convention:</b> decide what <span class="eq">R &gt; 0</span> and <span class="eq">R &lt; 0</span> mean physically (concave vs convex). <span class="small">Goal: avoid sign mistakes.</span></li>
      <li><b>Write g-parameters:</b> <span class="eq">g1 = 1 − L/R1</span>, <span class="eq">g2 = 1 − L/R2</span>. <span class="small">Goal: encode geometry into dimensionless numbers.</span></li>
      <li><b>Apply stability test:</b> require <span class="eq">0 &lt; g1 g2 &lt; 1</span>. <span class="small">Goal: translate stability into inequalities.</span></li>
      <li><b>Case (a) both convex:</b> set <span class="eq">R1 &lt; 0</span>, <span class="eq">R2 &lt; 0</span>, infer sign/range of <span class="eq">g1, g2</span>, conclude about product. <span class="small">Physical meaning: net defocusing.</span></li>
      <li><b>Case (b) convex + concave:</b> set one <span class="eq">R &gt; 0</span> and one <span class="eq">R &lt; 0</span>, see whether product can lie between 0 and 1, identify allowed L-range. <span class="small">Physical meaning: focusing compensates defocusing.</span></li>
      <li><b>Sanity checks:</b> look at limits (very small L, very large L) and ensure the conclusion matches intuition. </li>
    </ol>

    <div class="callouts">
      <div class="box">
        <h4>Common mistakes</h4>
        <ul>
          <li>Using a different sign convention for <span class="eq">R</span> without noticing (always state your convention).</li>
          <li>Forgetting <span class="eq">L &gt; 0</span>: “stability” at <span class="eq">L=0</span> isn’t a real cavity.</li>
          <li>Confusing <span class="eq">0 &lt; g1 g2 &lt; 1</span> with <span class="eq">|g1 g2| &lt; 1</span> (sign matters).</li>
        </ul>
      </div>
      <div class="box">
        <h4>Quick tips</h4>
        <ul>
          <li>If a mirror is convex (defocusing), its g-parameter becomes <span class="eq">g = 1 + L/|R|</span>, which is always &gt; 1.</li>
          <li>Because stability needs <span class="eq">g1 g2 &lt; 1</span>, having <b>both</b> g’s &gt; 1 is immediately fatal.</li>
        </ul>
      </div>
    </div>
  </section>

  <section id="solution">
    <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

    <h3>Physical intuition first (before math)</h3>
    <p>
      A stable resonator must “re-collimate” or refocus rays each round trip enough that small transverse errors do not grow.
      Two convex mirrors both defocus: each bounce pushes rays farther away, so we expect runaway divergence.
      If one mirror is concave, it can refocus; stability then becomes a tug-of-war between focusing (concave) and defocusing (convex).
    </p>

    <h3>Step 1: Define symbols and sign convention</h3>
    <ul>
      <li><span class="eq">L</span> = mirror separation (m), with <span class="eq">L &gt; 0</span>.</li>
      <li><span class="eq">R1, R2</span> = radii of curvature (m), with:
        <ul>
          <li><span class="eq">R &gt; 0</span>: concave mirror (focusing for rays inside the cavity).</li>
          <li><span class="eq">R &lt; 0</span>: convex mirror (defocusing inside the cavity).</li>
        </ul>
      </li>
      <li><span class="eq">g1 = 1 − L/R1</span>, <span class="eq">g2 = 1 − L/R2</span> (dimensionless).</li>
    </ul>

    <div class="eqBlock">
      <span class="eq" id="eqg">g1 = 1 − L/R1,   g2 = 1 − L/R2</span>
      <button class="copyBtn" data-copy="g1 = 1 - L/R1; g2 = 1 - L/R2">
        <span class="copyIcon" aria-hidden="true"></span>Copy
      </button>
    </div>

    <h3>Step 2: The stability condition for a two-mirror spherical cavity</h3>
    <p>
      For a two-mirror resonator, the standard result from the round-trip ABCD matrix and the trace criterion
      <span class="eq">|(A + D)/2| &lt; 1</span> reduces to:
    </p>

    <div class="box">
      <h4>Key equation (two-mirror stability)</h4>
      <div class="eqBlock">
        <span class="eq" id="eqStable">0 &lt; g1 g2 &lt; 1</span>
        <button class="copyBtn" data-copy="0 < g1*g2 < 1">
          <span class="copyIcon" aria-hidden="true"></span>Copy
        </button>
      </div>
      <p class="small">
        Boundaries <span class="eq">g1 g2 = 0</span> or <span class="eq">g1 g2 = 1</span> are marginal (on the edge).
      </p>
    </div>

    <h3>Case (a): Two convex mirrors</h3>
    <p>
      If both mirrors are convex, then <span class="eq">R1 &lt; 0</span> and <span class="eq">R2 &lt; 0</span>.
      Write <span class="eq">R1 = −|R1|</span>, <span class="eq">R2 = −|R2|</span>. Then:
    </p>

    <div class="eqBlock">
      <span class="eq" id="eqConvexG">
        g1 = 1 − L/(−|R1|) = 1 + L/|R1|  &gt; 1,
        &nbsp;&nbsp; g2 = 1 + L/|R2| &gt; 1
      </span>
      <button class="copyBtn" data-copy="(two convex) g1 = 1 + L/|R1| > 1, g2 = 1 + L/|R2| > 1">
        <span class="copyIcon" aria-hidden="true"></span>Copy
      </button>
    </div>

    <p>
      Since both g’s exceed 1 for any finite <span class="eq">L &gt; 0</span>, their product satisfies:
    </p>

    <div class="eqBlock">
      <span class="eq" id="eqConvexProd">g1 g2 &gt; 1</span>
      <button class="copyBtn" data-copy="(two convex) g1*g2 > 1 for any L>0">
        <span class="copyIcon" aria-hidden="true"></span>Copy
      </button>
    </div>

    <p>
      But stability requires <span class="eq">g1 g2 &lt; 1</span>, so it is impossible to satisfy the stability inequality.
    </p>

    <div class="box final">
      <h4>Final answer (a)</h4>
      <div class="eqBlock">
        <span class="eq" id="ansA">Two convex mirrors can never form a stable resonator (for any L &gt; 0).</span>
        <button class="copyBtn" data-copy="(a) Two convex mirrors: never stable for any L > 0 (since g1>1 and g2>1, so g1*g2>1).">
          <span class="copyIcon" aria-hidden="true"></span>Copy
        </button>
      </div>
    </div>

    <h3>Case (b): One convex and one concave mirror</h3>
    <p>
      Let mirror 1 be concave: <span class="eq">R1 = Rc &gt; 0</span>, and mirror 2 be convex: <span class="eq">R2 = Rv &lt; 0</span>
      (you can swap labels; the conclusion is the same).
      Then:
    </p>

    <div class="eqBlock">
      <span class="eq" id="eqMixedG">
        g1 = 1 − L/Rc, &nbsp;&nbsp;
        g2 = 1 − L/Rv = 1 + L/|Rv|  &gt; 1
      </span>
      <button class="copyBtn" data-copy="(mixed) g1 = 1 - L/Rc (Rc>0), g2 = 1 + L/|Rv| (Rv<0) > 1">
        <span class="copyIcon" aria-hidden="true"></span>Copy
      </button>
    </div>

    <p>
      Stability demands <span class="eq">0 &lt; g1 g2 &lt; 1</span>. Because <span class="eq">g2 &gt; 1</span>, the product can still be less than 1
      if <span class="eq">g1</span> is positive but sufficiently small:
    </p>

    <div class="box">
      <h4>Inequality reasoning</h4>
      <ul>
        <li><span class="eq">g1 g2 &gt; 0</span> requires <span class="eq">g1 &gt; 0</span> (since <span class="eq">g2 &gt; 0</span>). That means
          <span class="eq">1 − L/Rc &gt; 0 ⇒ L &lt; Rc</span>.</li>
        <li><span class="eq">g1 g2 &lt; 1</span> with <span class="eq">g2 &gt; 1</span> requires
          <span class="eq">g1 &lt; 1/g2</span>.</li>
      </ul>

      <div class="eqBlock">
        <span class="eq" id="eqMixedCond">
          0 &lt; 1 − L/Rc &lt; 1 / (1 + L/|Rv|)
        </span>
        <button class="copyBtn" data-copy="(mixed stability) 0 < 1 - L/Rc < 1/(1 + L/|Rv|), with Rc>0, Rv<0">
          <span class="copyIcon" aria-hidden="true"></span>Copy
        </button>
      </div>
      <p class="small">
        This inequality defines a non-empty range of L for many choices of <span class="eq">Rc</span> and <span class="eq">|Rv|</span>.
        Intuitively: the concave mirror focuses, the convex mirror defocuses, and stability exists when focusing wins “just enough.”
      </p>
    </div>

    <p>
      Therefore, <b>yes</b>, a convex–concave resonator can be stable (for appropriate geometry).
    </p>

    <div class="box final">
      <h4>Final answer (b)</h4>
      <div class="eqBlock">
        <span class="eq" id="ansB">
          A resonator with one convex and one concave mirror can be stable, provided 0 &lt; g1 g2 &lt; 1 (with Rconvex &lt; 0, Rconcave &gt; 0).
        </span>
        <button class="copyBtn" data-copy="(b) One convex + one concave: can be stable for some L, satisfying 0 < (1 - L/R1)(1 - L/R2) < 1 with Rconcave>0 and Rconvex<0.">
          <span class="copyIcon" aria-hidden="true"></span>Copy
        </button>
      </div>
    </div>

    <h3>Sanity checks</h3>
    <ul>
      <li><b>Units:</b> <span class="eq">L/R</span> is dimensionless, so g’s are dimensionless; stability inequalities are consistent.</li>
      <li><b>Limit L → 0:</b> <span class="eq">g1 → 1</span>, <span class="eq">g2 → 1</span>, so <span class="eq">g1 g2 → 1</span> (marginal), matching the idea that zero-length is not a meaningful cavity and flat/near-flat is borderline.</li>
      <li><b>Two convex:</b> as L increases, each convex mirror becomes “more defocusing” → instability only worsens, consistent with <span class="eq">g &gt; 1</span>.</li>
      <li><b>Mixed:</b> increasing L reduces <span class="eq">g1</span> (concave side) while increasing <span class="eq">g2</span> (convex side); stability can occur in between.</li>
    </ul>

    <p>
      The diagram and plots below visualize exactly this: the stable region is the shaded band where <span class="eq">0 &lt; g1 g2 &lt; 1</span>.
    </p>

    <div class="vizWrap">
      <figure>
        <canvas id="cDiagram" aria-label="Resonator geometry diagram"></canvas>
        <figcaption>
          Labeled geometry: two mirrors separated by <span class="eq">L</span>, showing concave vs convex curvature (example sign convention).
        </figcaption>
      </figure>

      <div class="controls">
        <h3 style="margin-top:0;">Interactive Controls (example values for plotting)</h3>
        <p class="small" style="margin-top:0;">
          The problem is symbolic; the sliders pick <i>example</i> radii to show how stability changes. The math/answers above remain general.
        </p>

        <div class="controlRow">
          <div>
            <label for="caseSel">Mirror configuration</label>
            <select id="caseSel">
              <option value="twoConvex">Case (a): two convex mirrors</option>
              <option value="mixed">Case (b): one concave + one convex</option>
              <option value="twoConcave">Extra: two concave mirrors (for comparison)</option>
            </select>
          </div>

          <div>
            <label for="r1">Mirror 1 radius magnitude |R1| (m)</label>
            <input id="r1" type="range" min="0.2" max="5.0" step="0.01" value="1.20">
          </div>

          <div>
            <label for="r2">Mirror 2 radius magnitude |R2| (m)</label>
            <input id="r2" type="range" min="0.2" max="5.0" step="0.01" value="0.90">
          </div>

          <div>
            <label for="lmax">Plot range: L from 0 to L<sub>max</sub> (m)</label>
            <input id="lmax" type="range" min="0.2" max="6.0" step="0.02" value="2.80">
          </div>

          <div>
            <label for="lPick">Marker: chosen separation L (m)</label>
            <input id="lPick" type="range" min="0.00" max="2.80" step="0.01" value="0.80">
          </div>
        </div>

        <div class="readout" id="readout"></div>
      </div>
    </div>

    <div class="grid2" style="margin-top:14px;">
      <figure>
        <canvas id="cMainPlot" aria-label="Main plot: g1*g2 versus L"></canvas>
        <figcaption>
          Main plot: <span class="eq">g1 g2</span> vs <span class="eq">L</span>. The shaded band indicates stability: <span class="eq">0 &lt; g1 g2 &lt; 1</span>.
        </figcaption>
      </figure>
      <figure>
        <canvas id="cSecondaryPlot" aria-label="Secondary plot: g1 and g2 versus L"></canvas>
        <figcaption>
          Secondary plot: <span class="eq">g1(L)</span> and <span class="eq">g2(L)</span>. Convex mirrors force <span class="eq">g&gt;1</span>.
        </figcaption>
      </figure>
    </div>

  </section>

  <section id="deeper">
    <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

    <h3>Re-interpreting the formula</h3>
    <p>
      The parameter <span class="eq">g = 1 − L/R</span> measures how much “curvature focusing” a mirror provides relative to the cavity length.
      For a concave mirror (<span class="eq">R&gt;0</span>), increasing <span class="eq">L</span> decreases <span class="eq">g</span> (more net focusing effect in the round trip).
      For a convex mirror (<span class="eq">R&lt;0</span>), increasing <span class="eq">L</span> increases <span class="eq">g</span> above 1 (stronger net defocusing).
    </p>

    <div class="callouts">
      <div class="box">
        <h4>How changing parameters affects stability</h4>
        <ul>
          <li><b>Two convex:</b> both <span class="eq">g</span> values remain &gt; 1 for any <span class="eq">L&gt;0</span> ⇒ product always &gt; 1 ⇒ always unstable.</li>
          <li><b>Mixed:</b> making the concave radius <span class="eq">Rc</span> smaller (stronger curvature) can create a stable window of <span class="eq">L</span>.</li>
          <li><b>Mixed:</b> making the convex mirror “less convex” (larger <span class="eq">|Rv|</span>) reduces defocusing (smaller <span class="eq">g2</span>), enlarging the stable region.</li>
        </ul>
      </div>
      <div class="box">
        <h4>Alternative derivation idea (brief)</h4>
        <p>
          Use the Gaussian beam <span class="eq">q</span>-parameter with the round-trip ABCD relation
          <span class="eq">q = (Aq + B)/(Cq + D)</span>.
          A stable cavity admits a self-consistent complex <span class="eq">q</span> with finite beam size.
          This leads to the same condition <span class="eq">0 &lt; g1 g2 &lt; 1</span>.
        </p>
      </div>
    </div>

    <h3>Concept checks (quick self-test)</h3>
    <ul>
      <li><b>Q:</b> If one mirror is convex, what can you say about its g-parameter? <b>A:</b> It is always <span class="eq">g = 1 + L/|R| &gt; 1</span> for any <span class="eq">L&gt;0</span>.</li>
      <li><b>Q:</b> Why does “both g &gt; 1” immediately imply instability? <b>A:</b> Because the stability band requires <span class="eq">g1 g2 &lt; 1</span>, but the product of two numbers each greater than 1 is greater than 1.</li>
      <li><b>Q:</b> Can a cavity be stable if <span class="eq">g1 g2 &lt; 0</span>? <b>A:</b> No—the standard two-mirror stability criterion requires <span class="eq">0 &lt; g1 g2 &lt; 1</span>.</li>
      <li><b>Q:</b> What does <span class="eq">g1 g2 = 1</span> represent? <b>A:</b> A marginal (boundary) case—small perturbations can cause drift; in practice it’s not robust.</li>
    </ul>
  </section>

  <section id="vizguide">
    <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

    <h3>What each canvas shows</h3>
    <ul>
      <li><b>Diagram canvas:</b> two mirrors separated by <span class="eq">L</span>, with the selected configuration (convex/concave) drawn by curvature direction. It’s a geometry reminder.</li>
      <li><b>Main plot:</b> <span class="eq">g1 g2</span> vs <span class="eq">L</span> over <span class="eq">[0, Lmax]</span>. The shaded strip between 0 and 1 is the stability region.</li>
      <li><b>Secondary plot:</b> shows <span class="eq">g1(L)</span> and <span class="eq">g2(L)</span> separately so you can see which mirror drives the product.</li>
    </ul>

    <h3>Interactive controls</h3>
    <ul>
      <li><b>Mirror configuration:</b> toggles between the problem’s cases and an extra “two concave” comparison.</li>
      <li><b>|R1|, |R2| sliders:</b> choose example curvature magnitudes. The sign is applied automatically based on the chosen configuration.</li>
      <li><b>Lmax slider:</b> sets the horizontal span of the plots.</li>
      <li><b>Chosen L marker:</b> shows a vertical marker and a dot at the corresponding <span class="eq">g1 g2</span>, with a “Stable/Unstable” readout based on <span class="eq">0 &lt; g1 g2 &lt; 1</span>.</li>
    </ul>

    <div class="box">
      <h4>What you should observe (connect to the theory)</h4>
      <ul>
        <li>In <b>two convex</b>, the main curve stays above 1 (no shaded overlap) → matches “never stable.”</li>
        <li>In <b>mixed</b>, the product may dip into the shaded band for a window of <span class="eq">L</span> → matches “can be stable sometimes.”</li>
      </ul>
    </div>
  </section>
</main>

<footer>
  <p>
    Built with vanilla HTML/CSS/JS. Mathematical core: paraxial (ABCD) stability of two-mirror spherical resonators using the g-parameter condition
    <span class="eq">0 &lt; g1 g2 &lt; 1</span>.
  </p>
</footer>

<script>
/* ----------------------------
   Utility: smooth scroll
---------------------------- */
(function(){
  document.querySelectorAll('.toc a').forEach(a=>{
    a.addEventListener('click', (e)=>{
      const href = a.getAttribute('href');
      if(!href || !href.startsWith('#')) return;
      e.preventDefault();
      const el = document.querySelector(href);
      if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
      history.replaceState(null, '', href);
    });
  });
})();

/* ----------------------------
   Copy buttons
---------------------------- */
(function(){
  function toast(msg){
    const t = document.createElement('div');
    t.textContent = msg;
    t.style.position='fixed';
    t.style.left='50%';
    t.style.bottom='18px';
    t.style.transform='translateX(-50%)';
    t.style.padding='10px 12px';
    t.style.border='1px solid rgba(255,255,255,0.16)';
    t.style.background='rgba(10,16,32,0.92)';
    t.style.color='white';
    t.style.borderRadius='12px';
    t.style.zIndex=9999;
    t.style.boxShadow='0 18px 40px rgba(0,0,0,0.45)';
    t.style.fontSize='0.92rem';
    t.style.opacity='0';
    t.style.transition='200ms ease';
    document.body.appendChild(t);
    requestAnimationFrame(()=>{ t.style.opacity='1'; t.style.transform='translateX(-50%) translateY(-2px)'; });
    setTimeout(()=>{
      t.style.opacity='0';
      t.style.transform='translateX(-50%) translateY(6px)';
      setTimeout(()=>t.remove(), 220);
    }, 1100);
  }

  document.querySelectorAll('.copyBtn').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const txt = btn.getAttribute('data-copy') || '';
      try{
        await navigator.clipboard.writeText(txt);
        toast('Copied!');
      }catch(err){
        // fallback
        const ta = document.createElement('textarea');
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        ta.remove();
        toast('Copied!');
      }
    });
  });
})();

/* ----------------------------
   Canvas helpers
---------------------------- */
function setupCanvas(canvas, preferredHeightPx){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  const cssW = Math.max(280, rect.width);
  const cssH = preferredHeightPx || Math.max(200, Math.round(cssW*0.55));
  canvas.style.height = cssH + 'px';
  canvas.width = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return {ctx, w: cssW, h: cssH, dpr};
}

function clear(ctx,w,h){
  ctx.clearRect(0,0,w,h);
  // subtle background vignette
  const g = ctx.createRadialGradient(w*0.3,h*0.2, 10, w*0.5,h*0.5, Math.max(w,h));
  g.addColorStop(0,'rgba(125,211,252,0.06)');
  g.addColorStop(0.4,'rgba(167,139,250,0.05)');
  g.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle = 'rgba(6,10,20,0.88)';
  ctx.fillRect(0,0,w,h);
  ctx.fillStyle = g;
  ctx.fillRect(0,0,w,h);
}

function drawGridAxes(ctx, w, h, plot){
  // plot: {xMin,xMax,yMin,yMax, padL,padR,padT,padB, xLabel,yLabel,title}
  const padL = plot.padL, padR = plot.padR, padT = plot.padT, padB = plot.padB;
  const x0 = padL, y0 = h-padB, x1 = w-padR, y1 = padT;

  // frame
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1;
  ctx.strokeRect(x0,y1, x1-x0, y0-y1);

  // title
  ctx.fillStyle = 'rgba(233,236,246,0.92)';
  ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(plot.title, x0, Math.max(14, y1-8));

  // ticks
  const nTicks = 6;
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillStyle = 'rgba(185,192,218,0.92)';

  // gridlines and labels x
  for(let i=0;i<=nTicks;i++){
    const t = i/nTicks;
    const x = x0 + t*(x1-x0);
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.beginPath(); ctx.moveTo(x,y1); ctx.lineTo(x,y0); ctx.stroke();

    const val = plot.xMin + t*(plot.xMax-plot.xMin);
    const s = (Math.abs(val) >= 1000) ? val.toExponential(2) : val.toFixed(2);
    ctx.fillText(s, x-10, y0+16);
    // tick mark
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+5); ctx.stroke();
  }

  // gridlines and labels y
  for(let i=0;i<=nTicks;i++){
    const t = i/nTicks;
    const y = y0 - t*(y0-y1);
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke();

    const val = plot.yMin + t*(plot.yMax-plot.yMin);
    const s = (Math.abs(val) >= 1000) ? val.toExponential(2) : val.toFixed(2);
    ctx.fillText(s, 6, y+4);
    // tick mark
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.beginPath(); ctx.moveTo(x0-5,y); ctx.lineTo(x0,y); ctx.stroke();
  }

  // axis labels
  ctx.fillStyle = 'rgba(185,192,218,0.95)';
  ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(plot.xLabel, (x0+x1)/2 - 28, h-8);

  // y label rotated
  ctx.save();
  ctx.translate(12, (y0+y1)/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(plot.yLabel, 0, 0);
  ctx.restore();

  return {x0,y0,x1,y1};
}

function mapX(x, frame, plot){ // to pixel
  const {x0,x1} = frame;
  return x0 + (x - plot.xMin) * (x1-x0) / (plot.xMax - plot.xMin);
}
function mapY(y, frame, plot){
  const {y0,y1} = frame;
  return y0 - (y - plot.yMin) * (y0-y1) / (plot.yMax - plot.yMin);
}

/* ----------------------------
   Physics: g parameters
---------------------------- */
function gParam(L, R){
  return 1 - (L / R);
}

function configFromCase(caseName, R1mag, R2mag){
  // returns signed R1, R2 based on our convention: concave R>0, convex R<0
  if(caseName === 'twoConvex'){
    return {R1: -Math.abs(R1mag), R2: -Math.abs(R2mag), label1:'Convex', label2:'Convex'};
  }
  if(caseName === 'mixed'){
    // Mirror 1 concave, mirror 2 convex by default
    return {R1: +Math.abs(R1mag), R2: -Math.abs(R2mag), label1:'Concave', label2:'Convex'};
  }
  // two concave (comparison)
  return {R1: +Math.abs(R1mag), R2: +Math.abs(R2mag), label1:'Concave', label2:'Concave'};
}

function stabilityValue(g1g2){
  return (g1g2 > 0 && g1g2 < 1);
}

/* ----------------------------
   Draw diagram
---------------------------- */
function drawDiagram(canvas, state){
  const {ctx,w,h} = setupCanvas(canvas, 240);
  clear(ctx,w,h);

  // coordinate system
  const pad = 18;
  const xL = pad + 50, xR = w - pad - 50;
  const yMid = h*0.56;

  // draw optical axis
  ctx.strokeStyle = 'rgba(233,236,246,0.35)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(pad, yMid);
  ctx.lineTo(w-pad, yMid);
  ctx.stroke();

  // mirror shapes
  function drawMirror(x, type, label){
    const H = 110;
    const y0 = yMid - H/2;
    const y1 = yMid + H/2;
    const bulge = 18;

    ctx.lineWidth = 3;
    ctx.strokeStyle = (type === 'Concave') ? 'rgba(125,211,252,0.95)' : 'rgba(251,113,133,0.95)';

    ctx.beginPath();
    if(type === 'Concave'){
      // curves inward toward cavity: "(" on left, ")" on right depending on side
      // We'll draw a curve opening toward the cavity center.
      if(x < w/2){
        ctx.moveTo(x, y0);
        ctx.quadraticCurveTo(x + bulge, yMid, x, y1);
      }else{
        ctx.moveTo(x, y0);
        ctx.quadraticCurveTo(x - bulge, yMid, x, y1);
      }
    }else{
      // convex: curve bulges into cavity away from center
      if(x < w/2){
        ctx.moveTo(x, y0);
        ctx.quadraticCurveTo(x - bulge, yMid, x, y1);
      }else{
        ctx.moveTo(x, y0);
        ctx.quadraticCurveTo(x + bulge, yMid, x, y1);
      }
    }
    ctx.stroke();

    // small hatch line behind mirror
    ctx.strokeStyle = 'rgba(255,255,255,0.14)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x + (x<w/2 ? -12 : 12), y0);
    ctx.lineTo(x + (x<w/2 ? -12 : 12), y1);
    ctx.stroke();

    // label
    ctx.fillStyle = 'rgba(233,236,246,0.92)';
    ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(label, x - 28, y0 - 10);
    ctx.fillStyle = 'rgba(185,192,218,0.92)';
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(type, x - 28, y1 + 18);
  }

  drawMirror(xL, state.label1, 'Mirror 1');
  drawMirror(xR, state.label2, 'Mirror 2');

  // distance L arrow
  ctx.strokeStyle = 'rgba(52,211,153,0.85)';
  ctx.fillStyle = 'rgba(52,211,153,0.90)';
  ctx.lineWidth = 2;
  const yArrow = yMid + 70;
  ctx.beginPath(); ctx.moveTo(xL+10,yArrow); ctx.lineTo(xR-10,yArrow); ctx.stroke();
  // arrowheads
  function arrowHead(x,y,dir){
    ctx.beginPath();
    ctx.moveTo(x,y);
    ctx.lineTo(x + dir*10, y-5);
    ctx.lineTo(x + dir*10, y+5);
    ctx.closePath();
    ctx.fill();
  }
  arrowHead(xL+10,yArrow,-1);
  arrowHead(xR-10,yArrow,+1);

  ctx.fillStyle = 'rgba(52,211,153,0.95)';
  ctx.font = '700 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('L', (xL+xR)/2 - 4, yArrow - 8);

  // show sign convention note
  ctx.fillStyle = 'rgba(185,192,218,0.95)';
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('Sign convention: concave R>0, convex R<0', pad, pad+10);
}

/* ----------------------------
   Draw main plot: g1*g2 vs L
---------------------------- */
function drawMainPlot(canvas, state){
  const {ctx,w,h} = setupCanvas(canvas, 300);
  clear(ctx,w,h);

  // compute curve samples
  const N = 500;
  const xs = [];
  const ys = [];
  for(let i=0;i<=N;i++){
    const L = state.Lmax * (i/N);
    const g1 = gParam(L, state.R1);
    const g2 = gParam(L, state.R2);
    const prod = g1*g2;
    xs.push(L); ys.push(prod);
  }

  // y range: auto with padding, but ensure includes [0,1] band
  let yMin = Math.min(...ys, 0) - 0.2;
  let yMax = Math.max(...ys, 1) + 0.2;
  // clamp extreme blowups a bit for readability
  const span = yMax - yMin;
  if(span > 12){
    // focus around stability region; but keep curve visible
    yMin = Math.max(yMin, -2);
    yMax = Math.min(yMax,  6);
  }

  const plot = {
    xMin: 0, xMax: state.Lmax,
    yMin: yMin, yMax: yMax,
    padL: 54, padR: 14, padT: 28, padB: 38,
    xLabel: 'L (m)',
    yLabel: 'g1 g2 (dimensionless)',
    title: 'Main: Stability indicator g1·g2 vs L'
  };
  const frame = drawGridAxes(ctx,w,h,plot);

  // shade stability band between y=0 and y=1
  const y0 = mapY(0, frame, plot);
  const y1 = mapY(1, frame, plot);
  ctx.fillStyle = 'rgba(52,211,153,0.12)';
  ctx.fillRect(frame.x0, Math.min(y0,y1), frame.x1-frame.x0, Math.abs(y1-y0));
  ctx.strokeStyle = 'rgba(52,211,153,0.35)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(frame.x0, y0); ctx.lineTo(frame.x1, y0);
  ctx.moveTo(frame.x0, y1); ctx.lineTo(frame.x1, y1);
  ctx.stroke();

  // curve
  ctx.lineWidth = 2.2;
  ctx.strokeStyle = 'rgba(125,211,252,0.95)';
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const px = mapX(xs[i], frame, plot);
    const py = mapY(ys[i], frame, plot);
    if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
  }
  ctx.stroke();

  // marker at chosen L
  const g1m = gParam(state.Lpick, state.R1);
  const g2m = gParam(state.Lpick, state.R2);
  const prodm = g1m*g2m;

  const xM = mapX(state.Lpick, frame, plot);
  ctx.strokeStyle = 'rgba(251,191,36,0.65)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(xM, frame.y1);
  ctx.lineTo(xM, frame.y0);
  ctx.stroke();

  const yM = mapY(prodm, frame, plot);
  ctx.fillStyle = 'rgba(251,191,36,0.95)';
  ctx.beginPath();
  ctx.arc(xM, yM, 4.5, 0, Math.PI*2);
  ctx.fill();

  // legend
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillStyle = 'rgba(233,236,246,0.92)';
  ctx.fillText('Curve: g1·g2', frame.x0 + 10, frame.y1 + 18);
  ctx.fillStyle = 'rgba(52,211,153,0.92)';
  ctx.fillText('Shaded: 0 < g1·g2 < 1 (stable)', frame.x0 + 120, frame.y1 + 18);
}

/* ----------------------------
   Draw secondary plot: g1 and g2 vs L
---------------------------- */
function drawSecondaryPlot(canvas, state){
  const {ctx,w,h} = setupCanvas(canvas, 300);
  clear(ctx,w,h);

  const N = 500;
  const xs = [];
  const y1s = [];
  const y2s = [];
  for(let i=0;i<=N;i++){
    const L = state.Lmax * (i/N);
    xs.push(L);
    y1s.push(gParam(L, state.R1));
    y2s.push(gParam(L, state.R2));
  }

  // y range, include 1 line
  let yMin = Math.min(...y1s, ...y2s, 1) - 0.2;
  let yMax = Math.max(...y1s, ...y2s, 1) + 0.2;

  // clamp blowups
  const span = yMax - yMin;
  if(span > 12){
    yMin = Math.max(yMin, -2);
    yMax = Math.min(yMax,  6);
  }

  const plot = {
    xMin: 0, xMax: state.Lmax,
    yMin: yMin, yMax: yMax,
    padL: 54, padR: 14, padT: 28, padB: 38,
    xLabel: 'L (m)',
    yLabel: 'g (dimensionless)',
    title: 'Secondary: Individual g1(L) and g2(L)'
  };
  const frame = drawGridAxes(ctx,w,h,plot);

  // draw y=1 reference line
  const yOne = mapY(1, frame, plot);
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(frame.x0, yOne);
  ctx.lineTo(frame.x1, yOne);
  ctx.stroke();
  ctx.fillStyle = 'rgba(185,192,218,0.85)';
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('g = 1', frame.x0 + 8, yOne - 6);

  // g1 curve
  ctx.lineWidth = 2.2;
  ctx.strokeStyle = 'rgba(167,139,250,0.95)';
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const px = mapX(xs[i], frame, plot);
    const py = mapY(y1s[i], frame, plot);
    if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
  }
  ctx.stroke();

  // g2 curve
  ctx.strokeStyle = 'rgba(125,211,252,0.95)';
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const px = mapX(xs[i], frame, plot);
    const py = mapY(y2s[i], frame, plot);
    if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
  }
  ctx.stroke();

  // marker at chosen L
  const g1m = gParam(state.Lpick, state.R1);
  const g2m = gParam(state.Lpick, state.R2);

  const xM = mapX(state.Lpick, frame, plot);

  ctx.strokeStyle = 'rgba(251,191,36,0.65)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(xM, frame.y1);
  ctx.lineTo(xM, frame.y0);
  ctx.stroke();

  const yM1 = mapY(g1m, frame, plot);
  const yM2 = mapY(g2m, frame, plot);

  ctx.fillStyle = 'rgba(167,139,250,0.95)';
  ctx.beginPath(); ctx.arc(xM, yM1, 4.5, 0, Math.PI*2); ctx.fill();

  ctx.fillStyle = 'rgba(125,211,252,0.95)';
  ctx.beginPath(); ctx.arc(xM, yM2, 4.5, 0, Math.PI*2); ctx.fill();

  // legend
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillStyle = 'rgba(233,236,246,0.92)';
  ctx.fillText('g1(L)', frame.x0 + 10, frame.y1 + 18);
  ctx.fillText('g2(L)', frame.x0 + 80, frame.y1 + 18);

  // tiny color swatches
  ctx.fillStyle = 'rgba(167,139,250,0.95)';
  ctx.fillRect(frame.x0 + 44, frame.y1 + 9, 10, 3);
  ctx.fillStyle = 'rgba(125,211,252,0.95)';
  ctx.fillRect(frame.x0 + 114, frame.y1 + 9, 10, 3);
}

/* ----------------------------
   State + UI
---------------------------- */
const elCase = document.getElementById('caseSel');
const elR1 = document.getElementById('r1');
const elR2 = document.getElementById('r2');
const elLmax = document.getElementById('lmax');
const elLpick = document.getElementById('lPick');
const readout = document.getElementById('readout');

const cDiagram = document.getElementById('cDiagram');
const cMainPlot = document.getElementById('cMainPlot');
const cSecondaryPlot = document.getElementById('cSecondaryPlot');

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function updateLPickRange(){
  const Lmax = parseFloat(elLmax.value);
  elLpick.max = Lmax.toFixed(2);
  // keep value in range
  elLpick.value = clamp(parseFloat(elLpick.value), 0, Lmax).toFixed(2);
}

function formatNum(x){
  if(!isFinite(x)) return '∞';
  const ax = Math.abs(x);
  if(ax >= 1000 || (ax > 0 && ax < 0.001)) return x.toExponential(3);
  return x.toFixed(4);
}

function render(){
  updateLPickRange();

  const caseName = elCase.value;
  const R1mag = parseFloat(elR1.value);
  const R2mag = parseFloat(elR2.value);
  const Lmax = parseFloat(elLmax.value);
  const Lpick = parseFloat(elLpick.value);

  const cfg = configFromCase(caseName, R1mag, R2mag);
  const R1 = cfg.R1, R2 = cfg.R2;

  const g1 = gParam(Lpick, R1);
  const g2 = gParam(Lpick, R2);
  const prod = g1*g2;
  const stable = stabilityValue(prod);

  const statusClass = stable ? 'statusGood' : 'statusBad';
  const statusText = stable ? 'Stable (0 < g1·g2 < 1)' : 'Unstable';

  const caseLabel =
    (caseName==='twoConvex') ? 'Case (a): two convex' :
    (caseName==='mixed') ? 'Case (b): concave + convex' :
    'Comparison: two concave';

  // readout tags
  readout.innerHTML = `
    <span class="tag"><b>${caseLabel}</b></span>
    <span class="tag">R1 = ${formatNum(R1)} m (${cfg.label1})</span>
    <span class="tag">R2 = ${formatNum(R2)} m (${cfg.label2})</span>
    <span class="tag">L = ${formatNum(Lpick)} m</span>
    <span class="tag">g1 = ${formatNum(g1)}</span>
    <span class="tag">g2 = ${formatNum(g2)}</span>
    <span class="tag">g1·g2 = ${formatNum(prod)}</span>
    <span class="tag ${statusClass}"><b>${statusText}</b></span>
  `;

  const state = {caseName, R1, R2, Lmax, Lpick, label1: cfg.label1, label2: cfg.label2};

  drawDiagram(cDiagram, state);
  drawMainPlot(cMainPlot, state);
  drawSecondaryPlot(cSecondaryPlot, state);
}

['input','change'].forEach(evt=>{
  elCase.addEventListener(evt, render);
  elR1.addEventListener(evt, render);
  elR2.addEventListener(evt, render);
  elLmax.addEventListener(evt, render);
  elLpick.addEventListener(evt, render);
});

window.addEventListener('resize', ()=>{
  // debounce-ish
  clearTimeout(window.__rz);
  window.__rz = setTimeout(render, 80);
});

render();
</script>
</body>
</html>
