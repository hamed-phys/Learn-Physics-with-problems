<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Optical TSI Switch Using Programmable Delay Lines (Fiber-Loop Buffers)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#0f1731;
      --card2:#0c1328;
      --ink:#eaf0ff;
      --muted:#b7c3e6;
      --faint:#7f8bb0;
      --line:rgba(255,255,255,.12);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --ok:#86efac;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 18px 60px rgba(0,0,0,.38);
      --shadow2: 0 10px 30px rgba(0,0,0,.26);
      --radius: 18px;
      --radius2: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --serif: ui-serif, Georgia, "Times New Roman", Times, serif;
    }

    *{ box-sizing:border-box; }
    html{ scroll-behavior:smooth; }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1100px 700px at 18% 12%, rgba(125,211,252,.18), transparent 60%),
        radial-gradient(900px 600px at 85% 18%, rgba(167,139,250,.14), transparent 55%),
        radial-gradient(700px 520px at 70% 92%, rgba(134,239,172,.10), transparent 60%),
        linear-gradient(180deg, #070a14, #0b1020 22%, #070a14);
      line-height:1.55;
    }

    a{ color:var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }

    header{
      position:relative;
      padding: 36px 18px 18px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0));
      overflow:hidden;
    }
    header .wrap{
      max-width:1200px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:18px;
      align-items:start;
    }
    .title{
      padding: 18px 18px 22px;
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(15,23,49,.55);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(6px);
      transform: translateZ(0);
    }
    h1{
      margin:0 0 10px;
      font-size: clamp(22px, 2.6vw, 34px);
      letter-spacing: .2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size: 15px;
      max-width: 65ch;
    }
    .meta{
      margin-top:12px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      color:var(--muted);
      font-size:12px;
      white-space:nowrap;
    }
    .dot{
      width:8px;height:8px;border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(125,211,252,.12);
    }

    /* Sticky TOC */
    .toc{
      position: sticky;
      top: 14px;
      align-self:start;
      padding: 14px 14px 12px;
      border-radius: var(--radius);
      border:1px solid var(--line);
      background: rgba(15,23,49,.45);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(6px);
    }
    .toc h2{
      margin:0 0 8px;
      font-size: 14px;
      color: var(--ink);
      letter-spacing:.2px;
    }
    .toc nav{
      display:grid;
      gap:6px;
      font-size: 13px;
    }
    .toc a{
      color: var(--muted);
      padding: 6px 8px;
      border-radius: 10px;
      border:1px solid transparent;
      transition: transform .18s ease, background .18s ease, border-color .18s ease;
    }
    .toc a:hover{
      background: rgba(125,211,252,.08);
      border-color: rgba(125,211,252,.22);
      transform: translateX(2px);
      text-decoration:none;
      color: var(--ink);
    }
    .toc .toplink{
      margin-top:8px;
      display:inline-block;
      color: var(--accent);
      font-weight:600;
    }

    main{
      max-width:1200px;
      margin: 0 auto;
      padding: 18px 18px 40px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    section{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(15,23,49,.40);
      box-shadow: var(--shadow2);
      overflow:hidden;
    }
    section > .hd{
      padding: 16px 18px 12px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,0));
    }
    section > .bd{
      padding: 14px 18px 18px;
    }
    h2{
      margin:0;
      font-size: 18px;
      letter-spacing:.2px;
    }
    p{ margin: 10px 0; color: var(--ink); }
    .muted{ color: var(--muted); }
    .faint{ color: var(--faint); }

    .callouts{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
      margin-top: 10px;
    }
    .card{
      grid-column: span 12;
      border:1px solid var(--line);
      border-radius: var(--radius2);
      background: rgba(12,19,40,.55);
      padding: 12px 12px 12px;
      box-shadow: 0 10px 24px rgba(0,0,0,.22);
      position:relative;
      overflow:hidden;
      transform: translateZ(0);
    }
    .card::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(500px 220px at 10% 10%, rgba(125,211,252,.14), transparent 50%),
                  radial-gradient(500px 220px at 90% 40%, rgba(167,139,250,.12), transparent 52%);
      opacity:.85;
      pointer-events:none;
    }
    .card > *{ position:relative; }
    .card h3{
      margin:0 0 6px;
      font-size: 14px;
      color: var(--ink);
      letter-spacing:.2px;
    }
    .card ul{
      margin:8px 0 0;
      padding-left: 18px;
      color: var(--muted);
    }
    .card li{ margin: 6px 0; }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size:12px;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--muted);
      margin-right: 8px;
    }
    .badge .b{ width:8px; height:8px; border-radius:50%; background: var(--ok); box-shadow: 0 0 0 4px rgba(134,239,172,.12); }
    .badge.warn .b{ background: var(--warn); box-shadow: 0 0 0 4px rgba(251,191,36,.12); }
    .badge.bad .b{ background: var(--bad); box-shadow: 0 0 0 4px rgba(251,113,133,.12); }

    .eq{
      margin: 12px 0;
      padding: 12px 12px 10px;
      border-radius: 14px;
      border:1px dashed rgba(125,211,252,.35);
      background: rgba(125,211,252,.07);
    }
    .eq .row{
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .eq code{
      font-family: var(--mono);
      font-size: 13px;
      color: var(--ink);
      white-space: pre-wrap;
    }
    button.copy{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.24);
      color: var(--ink);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      cursor:pointer;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
    }
    button.copy:hover{
      transform: translateY(-1px);
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.28);
    }
    button.copy:active{ transform: translateY(0); }

    details{
      margin: 12px 0;
      border:1px solid var(--line);
      border-radius: 14px;
      background: rgba(0,0,0,.16);
      overflow:hidden;
    }
    summary{
      cursor:pointer;
      padding: 12px 12px;
      list-style:none;
      user-select:none;
      color: var(--ink);
      font-weight: 650;
      letter-spacing:.2px;
      position:relative;
    }
    summary::-webkit-details-marker{ display:none; }
    summary::after{
      content:"▾";
      position:absolute;
      right: 12px;
      top: 10px;
      color: var(--muted);
      transition: transform .18s ease;
      font-size: 14px;
    }
    details[open] summary::after{ transform: rotate(180deg); }
    details .inside{
      padding: 0 12px 12px;
      color: var(--muted);
    }

    figure{
      margin: 12px 0 0;
      border:1px solid var(--line);
      border-radius: var(--radius2);
      background: rgba(0,0,0,.18);
      overflow:hidden;
    }
    figure figcaption{
      padding: 10px 12px;
      color: var(--muted);
      border-top:1px solid var(--line);
      font-size: 12.5px;
    }
    .plotwrap{
      padding: 10px 10px 0;
    }
    canvas{
      width: 100%;
      height: 320px;
      display:block;
      border-radius: 12px;
      background: rgba(12,19,40,.45);
    }

    .final{
      border:1px solid rgba(134,239,172,.35);
      background: rgba(134,239,172,.08);
      border-radius: var(--radius2);
      padding: 12px;
      margin: 12px 0;
    }
    .final h3{ margin:0 0 8px; font-size: 15px; }
    .final code{ font-family: var(--mono); font-size: 13px; white-space: pre-wrap; }

    .twoCol{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .listgrid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .kbox{
      border:1px solid var(--line);
      border-radius: 14px;
      background: rgba(0,0,0,.14);
      padding: 12px;
    }
    .kbox h3{ margin:0 0 6px; font-size: 14px; }
    .kbox ul{ margin:6px 0 0; padding-left: 18px; color: var(--muted); }
    .kbox li{ margin:6px 0; }

    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 16px 18px 30px;
      color: var(--muted);
      border-top:1px solid var(--line);
    }
    .backTop{
      display:inline-flex;
      gap:8px;
      align-items:center;
      margin-top: 10px;
      padding: 8px 10px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--ink);
      font-weight: 600;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
    }
    .backTop:hover{
      transform: translateY(-1px);
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.28);
      text-decoration:none;
    }

    /* Responsive */
    @media (min-width: 920px){
      .grid{ grid-template-columns: 1fr; }
      .callouts .card{ grid-column: span 6; }
      .twoCol{ grid-template-columns: 1fr 1fr; }
      .listgrid{ grid-template-columns: 1fr 1fr; }
    }
    @media (max-width: 960px){
      header .wrap{ grid-template-columns: 1fr; }
      .toc{ position:relative; top:auto; }
    }

    /* Print-friendly */
    @media print{
      :root{ --bg:#fff; }
      body{
        background:#fff !important;
        color:#000 !important;
      }
      header, section, .toc, .title, .card, .kbox, figure{
        background:#fff !important;
        box-shadow:none !important;
        border-color:#bbb !important;
      }
      a{ color:#000; text-decoration:underline; }
      .toc{ display:none; }
      button.copy{ display:none; }
      canvas{ border:1px solid #ccc; background:#fff !important; }
      section{ break-inside: avoid; page-break-inside: avoid; }
      h1,h2,h3{ color:#000 !important; }
      .muted,.faint{ color:#111 !important; }
    }
  </style>
</head>

<body id="top">
<header>
  <div class="wrap">
    <div class="title">
      <h1>Optical Time-Slot Interchange (TSI) Switch Using Programmable Fiber-Loop Delay Lines</h1>
      <p class="subtitle">
        We redesign the classic five-step optical TSI (time-to-space → fixed delays → space switch → fixed delays → space-to-time)
        into a cleaner architecture that uses <em>programmable</em> delay-line buffers (fiber loops + fast crossbar) to realize time-slot permutations.
        The focus is practical: how to build it, what timing law it uses, and what real engineering constraints matter.
      </p>
      <div class="meta">
        <span class="pill"><span class="dot"></span> Topic: Photonics / Optical Switching</span>
        <span class="pill"><span class="dot" style="background:var(--accent2); box-shadow:0 0 0 4px rgba(167,139,250,.12)"></span> Lens: Applied Physics + Industrial Engineering</span>
        <span class="pill"><span class="dot" style="background:var(--ok); box-shadow:0 0 0 4px rgba(134,239,172,.12)"></span> Result: Symbolic architecture + control law</span>
      </div>
    </div>

    <aside class="toc" aria-label="Table of Contents">
      <h2>Table of Contents</h2>
      <nav>
        <a href="#qs">Quick Summary</a>
        <a href="#p0">PART 0 — Concept Primer</a>
        <a href="#p0b">PART 0B — Industry & Applied Physics</a>
        <a href="#p1">PART 1 — Problem Analysis</a>
        <a href="#p2">PART 2 — Strategy & Tips</a>
        <a href="#p3">PART 3 — Full Solution</a>
        <a href="#p4">PART 4 — Deeper Understanding</a>
        <a href="#p5">PART 5 — Optional Plot Guide</a>
      </nav>
      <a class="toplink" href="#top">Back to top ↑</a>
    </aside>
  </div>
</header>

<main>
  <div class="grid">

    <!-- Quick Summary -->
    <section id="qs">
      <div class="hd"><h2>Quick Summary</h2></div>
      <div class="bd">
        <ul class="muted" style="margin:0; padding-left:18px;">
          <li><strong>What this problem is about:</strong> implement a time-slot interchange (TSI) switch—i.e., a device that <em>permutes</em> optical time slots—using the <strong>programmable delay line</strong> (fiber loop + crossbar) concept.</li>
          <li><strong>Key physics idea:</strong> time shifting in optics is performed by propagation delay; a recirculating loop creates an <em>integer-multiple-of-slot</em> delay <code>mT</code>.</li>
          <li><strong>Governing timing law:</strong> required per-slot delay to map input slot <code>i</code> to output slot <code>π(i)</code> is
            <code>Δ(i) = ((π(i) − i) mod N) · T</code>, for an <code>N</code>-slot frame with slot period <code>T</code>.</li>
          <li><strong>Implementation theme:</strong> use programmable delay-line buffers as a “time memory,” then use space switching to route pulses into and out of those buffers at the correct instants.</li>
          <li><strong>Result type:</strong> symbolic architecture + control schedule (no numbers required), with one example plot showing linear delay <code>τ = mT</code>.</li>
          <li><strong>Physical meaning:</strong> the switch does not “change frequency” or “stretch pulses”—it simply stores each pulse for a controlled number of loop round trips and releases it at the desired time slot.</li>
          <li><strong>Engineering relevance:</strong> it’s an optical analog of a packet/time buffer—critical for grooming, multiplexing, and contention management in high-throughput networks.</li>
        </ul>

        <div class="callouts">
          <div class="card">
            <h3>Problem statement (rewritten)</h3>
            <p class="muted" style="margin:0;">
              A standard optical TSI can be built in five steps using fixed delays and a space switch. Construct a different TSI implementation
              that instead uses the <em>programmable</em> delay line (fiber loop + crossbar) so each pulse can be delayed by an adjustable multiple of the slot time.
            </p>
          </div>
          <div class="card">
            <h3>What you should walk away with</h3>
            <ul>
              <li>A clean hardware block diagram in words (what connects to what).</li>
              <li>The exact timing/delay rule that realizes any slot permutation.</li>
              <li>The practical constraints: switch speed, loss/noise, guard time, buffering contention.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <!-- PART 0 -->
    <section id="p0">
      <div class="hd"><h2>PART 0 — Concept Primer (Theory Before Solving)</h2></div>
      <div class="bd">

        <div class="twoCol">
          <article class="kbox">
            <h3>Core definitions (symbols + SI units)</h3>
            <ul>
              <li><strong>Time slot period</strong> <code>T</code> [s]: time spacing between consecutive slots in a TDM frame.</li>
              <li><strong>Number of slots per frame</strong> <code>N</code> [dimensionless]. Frame duration: <code>T_f = N·T</code> [s].</li>
              <li><strong>Slot index</strong> <code>i</code>, <code>j</code> ∈ {1,…,N} [dimensionless].</li>
              <li><strong>Permutation (TSI mapping)</strong> <code>π(i)</code>: output slot index that receives the pulse from input slot <code>i</code>.</li>
              <li><strong>Programmable delay</strong> <code>Δ</code> [s]: adjustable time shift applied to a pulse.</li>
              <li><strong>Integer delay steps</strong> <code>m</code> [dimensionless]: number of loop round trips in a recirculating buffer.</li>
              <li><strong>Loop delay quantum</strong> <code>T</code> [s]: in the simplest design, each round trip adds exactly one slot period.</li>
            </ul>
          </article>

          <article class="kbox">
            <h3>Physical meaning (intuition)</h3>
            <ul>
              <li><code>T</code> sets your “clock grid.” A TSI must move pulses from one grid point to another.</li>
              <li>A delay line is a <em>time shifter</em>: it stores optical energy in propagation, then releases it later.</li>
              <li>A programmable fiber loop is a <em>discrete-time optical buffer</em>: each circulation adds an additional fixed delay.</li>
              <li>Space switches are “who goes to which path,” while delays are “when it arrives.” TSI is the marriage of both.</li>
            </ul>
          </article>
        </div>

        <div class="eq" data-copy="eq1">
          <div class="row">
            <div>
              <span class="badge"><span class="b"></span> Key equation</span>
              <code id="eq1">Total programmable delay (fiber-loop buffer):
τ = m·T,  where m = 0,1,2,...</code>
            </div>
            <button class="copy" data-copy-target="eq1" aria-label="Copy key equation">Copy</button>
          </div>
          <p class="faint" style="margin:8px 0 0;">
            Here, the loop is designed so one round trip equals one slot period <code>T</code> (or an integer fraction/multiple—see notes).
          </p>
        </div>

        <article class="kbox">
          <h3>Key principles & validity conditions</h3>
          <ul>
            <li><strong>Delay is physical propagation:</strong> <code>Δ = n_g L / c</code> for group index <code>n_g</code> and length <code>L</code>. This is reliable, broadband, and low-distortion if dispersion is managed.</li>
            <li><strong>Discrete-time assumption:</strong> pulses are narrow compared with <code>T</code>, and timing jitter/guard times keep pulses from overlapping after delays.</li>
            <li><strong>Switching assumption:</strong> the crossbar state can change within a fraction of <code>T</code> (typically with guard time) so you can admit/recirculate/release pulses cleanly.</li>
            <li><strong>Linear optics regime:</strong> power low enough that Kerr nonlinearity is negligible (otherwise loop recirculation can distort pulses).</li>
          </ul>
        </article>

        <details>
          <summary>Common models/approximations (and why engineers use them)</summary>
          <div class="inside">
            <ul>
              <li><strong>“Impulse in a slot” model:</strong> treat each slot as either containing one pulse (bit) or not. This reduces the design to integer-time scheduling.</li>
              <li><strong>Loss per pass</strong> <code>α</code> and gain compensation:</strong> model loop power as <code>P_m = P_0 · (G·e^{-α})^m</code>. Used to estimate maximum recirculations before SNR becomes unacceptable.</li>
              <li><strong>Guard time</strong> <code>T_g</code>:</strong> reserve a small time margin so switch transients and jitter do not cause inter-slot interference.</li>
              <li><strong>Dispersion lumping:</strong> treat dispersion per round trip and require <code>m</code> small enough (or compensate) so pulse broadening stays well below <code>T</code>.</li>
            </ul>
          </div>
        </details>

        <article class="kbox">
          <h3>Mini intuition examples (quick conceptual)</h3>
          <ul>
            <li><strong>Example A (no interchange):</strong> If you want slot <code>i</code> to remain slot <code>i</code>, choose <code>m=0</code> (no extra loop trips).</li>
            <li><strong>Example B (shift forward by 2 slots):</strong> To move a pulse two slots later, set <code>m=2</code> so <code>Δ=2T</code>.</li>
            <li><strong>Example C (wrap-around):</strong> In an <code>N</code>-slot frame, shifting “earlier” by 1 slot is equivalent to delaying by <code>(N−1)T</code> (release next frame).</li>
          </ul>
        </article>

        <article class="kbox">
          <h3>What to watch for (pitfalls & hidden assumptions)</h3>
          <ul>
            <li><strong>Modulo logic:</strong> “earlier” output times require a <em>larger</em> delay (wrap-around to next frame).</li>
            <li><strong>Contention:</strong> multiple pulses cannot be released to the same output slot at once. A valid TSI permutation avoids this, but your buffering/routing must respect it.</li>
            <li><strong>Switch transient time:</strong> if the crossbar changes state too slowly, it clips pulses or creates leakage/crosstalk.</li>
            <li><strong>Accumulated impairments:</strong> recirculating loops accumulate loss, ASE (if amplified), and dispersion—limiting max <code>m</code>.</li>
          </ul>
        </article>

      </div>
    </section>

    <!-- PART 0B -->
    <section id="p0b">
      <div class="hd"><h2>PART 0B — Industry & Applied Physics Perspective</h2></div>
      <div class="bd">

        <div class="listgrid">
          <article class="kbox">
            <h3>Where this appears in industry (3+ concrete areas)</h3>
            <ul>
              <li><strong>Optical transport networks:</strong> grooming and rearranging time slots in OTDM/ROADM-adjacent subsystems; burst/slot alignment before wavelength switching.</li>
              <li><strong>Data-center interconnects:</strong> contention management and slot scheduling in high-throughput optical fabrics, especially for bursty traffic.</li>
              <li><strong>Test & measurement / instrumentation:</strong> programmable optical buffering for time-domain multiplexed probing, optical sampling, and delay scanning.</li>
              <li><strong>Signal processing pipelines:</strong> optical beamforming and true-time-delay networks (conceptually similar buffering/steering logic).</li>
            </ul>
          </article>

          <article class="kbox">
            <h3>Why engineers care</h3>
            <ul>
              <li><strong>Performance:</strong> enables deterministic timing alignment and slot rearrangement without O/E/O conversion.</li>
              <li><strong>Reliability:</strong> fewer fixed delay banks can reduce calibration burden; programmable buffers help adapt to drift and reconfiguration needs.</li>
              <li><strong>Cost & footprint:</strong> replacing large sets of distinct fixed delays with fewer re-usable programmable buffers can reduce component count (depending on architecture).</li>
              <li><strong>Manufacturability:</strong> fiber-loop lengths can be standardized; control is moved into electronics/firmware.</li>
            </ul>
          </article>

          <article class="kbox">
            <h3>How it’s validated in practice</h3>
            <ul>
              <li><strong>Eye diagrams / BER testing:</strong> confirm inter-slot interference is not introduced by switching or dispersion.</li>
              <li><strong>Time-interval analysis:</strong> measure jitter and wander at the output versus input clock grid.</li>
              <li><strong>Optical spectrum & OSNR:</strong> check noise accumulation if optical amplifiers are used inside the loop.</li>
              <li><strong>Impulse response tests:</strong> inject sparse pulses and verify that each one emerges at the programmed slot (and only that slot).</li>
            </ul>
          </article>

          <article class="kbox">
            <h3>Design trade-offs & constraints</h3>
            <ul>
              <li><strong>Fast switching vs crosstalk:</strong> faster gates can have worse extinction or more transient leakage; guard times may be needed.</li>
              <li><strong>Loop loss vs max delay:</strong> larger <code>m</code> gives more flexibility but increases attenuation and distortion; amplification helps but adds noise.</li>
              <li><strong>Dispersion management:</strong> many passes broaden pulses; dispersion-compensating fiber or integrated delay lines may be required.</li>
              <li><strong>Thermal drift:</strong> delay depends on length and refractive index; control loops or calibration tables are common.</li>
            </ul>
          </article>
        </div>

        <details>
          <summary>From lab to product: how the ideal model gets adapted</summary>
          <div class="inside">
            <p class="muted">
              The textbook model assumes perfect integer delays and instantaneous, lossless switching. In real systems, engineers:
              (i) add <strong>guard time</strong> to tolerate switch transients,
              (ii) calibrate actual loop delay so that “<code>T</code>” is a measured effective round-trip delay,
              (iii) include <strong>power equalization</strong> across different <code>m</code> values (attenuators or gain control),
              and (iv) enforce scheduling constraints so that no two pulses fight for the same buffer output at the same instant.
            </p>
          </div>
        </details>

      </div>
    </section>

    <!-- PART 1 -->
    <section id="p1">
      <div class="hd"><h2>PART 1 — Problem Analysis (No Solving Yet)</h2></div>
      <div class="bd">

        <article class="kbox">
          <h3>Problem restatement (clear and operational)</h3>
          <p class="muted" style="margin:0;">
            We are given a known TSI implementation that uses fixed delay banks on both sides of a space switch.
            We must propose a different implementation that uses the programmable delay line built from a fiber loop and a crossbar switch
            (the loop can hold a pulse for <code>m</code> round trips, releasing it when commanded).
          </p>
        </article>

        <div class="twoCol">
          <article class="kbox">
            <h3>Given / known from the context</h3>
            <ul>
              <li>Time is slotted with slot duration <code>T</code>.</li>
              <li>A frame contains <code>N</code> slots (typical in TDM systems).</li>
              <li>A TSI performs a permutation <code>π</code> of slots.</li>
              <li>Programmable delay line: can create <code>τ = mT</code> by recirculating in a loop and releasing at <code>t = mT</code>.</li>
            </ul>
          </article>
          <article class="kbox">
            <h3>Unknowns / what must be constructed</h3>
            <ul>
              <li>A hardware architecture (blocks and connections) that realizes TSI using programmable delay lines.</li>
              <li>A control law/schedule: how to set each delay (<code>m</code>) and when to route/release pulses.</li>
              <li>Constraints/assumptions ensuring it works as a TSI (no collisions, timing alignment).</li>
            </ul>
          </article>
        </div>

        <article class="kbox">
          <h3>Relevant principles (and why they apply)</h3>
          <ul>
            <li><strong>Time shifting by buffering:</strong> The loop implements controllable storage; TSI is fundamentally “store then forward” in time.</li>
            <li><strong>Space switching for routing:</strong> You need a cross-connect to decide which buffer (delay line) a pulse enters and which output it exits.</li>
            <li><strong>Permutation constraint:</strong> Since TSI is a one-to-one mapping of slots, a feasible schedule exists that releases exactly one pulse per slot.</li>
          </ul>
          <p class="faint" style="margin:8px 0 0;">
            We do <em>not</em> need wavelength conversion, nonlinear optics, or frequency-domain filtering—this is purely time/space routing.
          </p>
        </article>

        <article class="kbox">
          <h3>Assumptions (explicit)</h3>
          <div style="display:flex; flex-wrap:wrap; gap:8px; margin: 2px 0 10px;">
            <span class="badge"><span class="b"></span> Pulses fit within slots</span>
            <span class="badge warn"><span class="b"></span> Guard time available</span>
            <span class="badge"><span class="b"></span> Switching faster than ~T</span>
            <span class="badge warn"><span class="b"></span> Loss/dispersion manageable</span>
          </div>
          <ul class="muted">
            <li>Pulse width ≪ <code>T</code>, so integer-slot delays do not create overlap if scheduled properly.</li>
            <li>Crossbar switching time is small compared with <code>T</code> (or guard time <code>T_g</code> is reserved).</li>
            <li>Loop round-trip delay is calibrated to be exactly <code>T</code> (or a known multiple), and drift is controlled.</li>
            <li>Optical impairments accumulated over required max <code>m</code> do not destroy the signal quality.</li>
          </ul>
        </article>

        <article class="kbox">
          <h3>Possible approaches (2–3) and comparison</h3>
          <ul class="muted">
            <li><strong>Approach A — Replace fixed delay banks with programmable delay banks (two-stage):</strong>
              keep the same overall structure (DEMUX → delays → space switch → delays → MUX), but each “delay” becomes programmable.
              <em>Pros:</em> conceptually direct. <em>Cons:</em> still uses two banks; may be more hardware than needed.
            </li>
            <li><strong>Approach B — Use programmable delay lines as recirculating buffers (single buffering stage):</strong>
              route each incoming slot into a buffer, hold it for <code>Δ(i)</code>, then release directly into the desired output slot.
              <em>Pros:</em> elegant “store-and-forward” TSI; highlights the programmable delay-line capability. <em>Cons:</em> needs careful scheduling and possibly multiple buffers.
            </li>
            <li><strong>Approach C — Shared central buffer pool:</strong>
              use fewer buffers than <code>N</code> with contention-aware scheduling (not always possible for arbitrary permutations).
              <em>Pros:</em> hardware reduction. <em>Cons:</em> may fail for worst-case permutations; higher control complexity.
            </li>
          </ul>
          <p class="muted">
            <strong>We choose Approach B</strong> because it is genuinely “another implementation” (not just a drop-in replacement),
            and it uses the programmable delay line exactly as intended: an optical time buffer with controlled release.
          </p>
        </article>

      </div>
    </section>

    <!-- PART 2 -->
    <section id="p2">
      <div class="hd"><h2>PART 2 — Strategy & Tips (Roadmap Only)</h2></div>
      <div class="bd">

        <article class="kbox">
          <h3>Minimal plan (8 steps)</h3>
          <ol class="muted" style="margin: 8px 0 0; padding-left: 20px;">
            <li><strong>Define the slot grid:</strong> choose slot period <code>T</code> and frame size <code>N</code>. (Tool: timing model)</li>
            <li><strong>Model the programmable delay:</strong> one loop round trip adds <code>T</code>, so <code>τ=mT</code>. (Tool: fiber-loop buffer law)</li>
            <li><strong>Express the desired permutation:</strong> specify mapping <code>i → π(i)</code>. (Tool: permutation concept)</li>
            <li><strong>Compute required delay per slot:</strong> <code>Δ(i)=((π(i)−i) mod N)T</code>. (Tool: modulo timing alignment)</li>
            <li><strong>Choose the buffer architecture:</strong> a pool of <code>B</code> programmable delay lines (often <code>B=N</code> for guaranteed feasibility). (Tool: buffering logic)</li>
            <li><strong>Input admission routing:</strong> at time slot <code>i</code>, connect DEMUX output to a chosen buffer and set <code>m=Δ(i)/T</code>. (Tool: space switch scheduling)</li>
            <li><strong>Release routing:</strong> at output time slot <code>j</code>, connect the buffer holding the pulse scheduled for slot <code>j</code> to the MUX output. (Tool: time-gated switching)</li>
            <li><strong>Check feasibility constraints:</strong> one pulse per slot at output, no buffer read/write conflicts, and adequate guard time. (Tool: scheduling sanity checks)</li>
          </ol>
        </article>

        <div class="callouts">
          <div class="card">
            <h3>Common mistakes (quick tips)</h3>
            <ul>
              <li><strong>Forgetting wrap-around:</strong> if <code>π(i)&lt;i</code>, you still <em>delay</em>—you don’t “advance” in time; use modulo <code>N</code>.</li>
              <li><strong>Assuming one buffer is enough:</strong> during a frame, multiple pulses must be stored simultaneously.</li>
              <li><strong>Ignoring switch guard time:</strong> real switches need finite transition time; schedule with margin.</li>
              <li><strong>Overlooking loop impairments:</strong> too many round trips can kill OSNR and broaden pulses.</li>
            </ul>
          </div>
          <div class="card">
            <h3>Key engineering tip</h3>
            <p class="muted" style="margin:0;">
              Treat the design as a <strong>discrete-time scheduling problem</strong> (industrial engineering mindset): you have resources (buffers),
              jobs (pulses), processing time (hold duration), and deadlines (target output slots).
            </p>
          </div>
        </div>

      </div>
    </section>

    <!-- PART 3 -->
    <section id="p3">
      <div class="hd"><h2>PART 3 — Full Solution (Detailed + Teaching)</h2></div>
      <div class="bd">

        <article class="kbox">
          <h3>Qualitative intuition first (what we expect)</h3>
          <p class="muted" style="margin:0;">
            A TSI is like re-labeling time positions. Since optics cannot “send a pulse backward in time,” every rearrangement must be done by
            <strong>delaying</strong> pulses and, when necessary, letting some pulses slip into the <em>next</em> frame (wrap-around).
            A programmable loop buffer is perfect: it stores a pulse for an integer number of slot periods and then releases it exactly onto the grid.
          </p>
        </article>

        <article class="kbox">
          <h3>Step 1 — Define the time-slot grid</h3>
          <p class="muted">
            Let the input be an optical signal with <strong>N time slots per frame</strong>.
            Slot <code>i</code> occupies the time window near
            <code>t_in(i) = (i−1)T</code>.
            A TSI implements a permutation <code>π</code> so that the pulse from slot <code>i</code> is delivered at output time
            <code>t_out(π(i)) = (π(i)−1)T</code> (relative to the start of some output frame).
          </p>
          <div class="eq">
            <div class="row">
              <div>
                <span class="badge"><span class="b"></span> Slot timing</span>
                <code id="eq2">Input slot i center time:  t_in(i) = (i−1)·T
Output slot j center time: t_out(j) = (j−1)·T</code>
              </div>
              <button class="copy" data-copy-target="eq2">Copy</button>
            </div>
          </div>
        </article>

        <article class="kbox">
          <h3>Step 2 — Model the programmable delay line as a discrete buffer</h3>
          <p class="muted">
            The programmable delay line (fiber loop + crossbar) admits a pulse into a loop and can keep it circulating.
            Each circulation adds one round-trip delay. If the loop is designed so the round-trip time equals <code>T</code>,
            then after <code>m</code> round trips the pulse experiences delay
            <code>τ = mT</code> and can be released by switching the crossbar state at the correct time.
          </p>
          <div class="eq">
            <div class="row">
              <div>
                <span class="badge"><span class="b"></span> Buffer law</span>
                <code id="eq3">Programmable delay line (loop buffer):
τ(m) = m·T  with integer m ≥ 0</code>
              </div>
              <button class="copy" data-copy-target="eq3">Copy</button>
            </div>
          </div>

          <details>
            <summary>Applied-physics note: what sets the loop delay physically?</summary>
            <div class="inside">
              <p class="muted">
                A fiber loop of length <code>L</code> has group delay per pass <code>T_rt = n_g L / c</code>.
                Setting <code>T_rt ≈ T</code> makes the buffer naturally align to the slot grid.
                In integrated photonics, <code>L</code> is replaced by waveguide spirals; <code>n_g</code> and <code>L</code> variations require calibration.
              </p>
              <div class="eq">
                <div class="row">
                  <div>
                    <span class="badge warn"><span class="b"></span> Physical delay</span>
                    <code id="eq4">Group delay per pass: T_rt = (n_g · L) / c
Design target: T_rt = T</code>
                  </div>
                  <button class="copy" data-copy-target="eq4">Copy</button>
                </div>
              </div>
            </div>
          </details>
        </article>

        <article class="kbox">
          <h3>Step 3 — Compute the required delay for a desired TSI permutation</h3>
          <p class="muted">
            We want the pulse from input slot <code>i</code> to appear at output slot <code>π(i)</code>.
            The raw time difference is
            <code>(π(i)−i)T</code>.
            But if <code>π(i)&lt;i</code>, the output slot occurs “earlier” in the same frame—so the only physical way is to release in the <em>next</em> frame.
            That is exactly handled by modulo arithmetic over the frame size <code>N</code>.
          </p>

          <div class="eq">
            <div class="row">
              <div>
                <span class="badge"><span class="b"></span> Governing TSI delay law</span>
                <code id="eq5">Required delay for slot i → slot π(i):
Δ(i) = ((π(i) − i) mod N) · T</code>
              </div>
              <button class="copy" data-copy-target="eq5">Copy</button>
            </div>
            <p class="faint" style="margin:8px 0 0;">
              “mod N” returns an integer in {0,1,...,N−1}. Thus Δ(i) is always a nonnegative delay, as physics demands.
            </p>
          </div>

          <p class="muted">
            Since the programmable delay line only produces delays in integer multiples of <code>T</code>,
            we set
            <code>m(i) = Δ(i)/T = ( (π(i) − i) mod N )</code>.
          </p>

          <div class="eq">
            <div class="row">
              <div>
                <span class="badge"><span class="b"></span> Control variable</span>
                <code id="eq6">Loop round trips for slot i:
m(i) = Δ(i)/T = ((π(i) − i) mod N)</code>
              </div>
              <button class="copy" data-copy-target="eq6">Copy</button>
            </div>
          </div>
        </article>

        <article class="kbox">
          <h3>Step 4 — Construct “another implementation” using programmable delay lines (Architecture)</h3>

          <p class="muted">
            Here is a concrete implementation that differs from the classic “two fixed delay banks” design:
            use a <strong>buffer pool</strong> of programmable fiber-loop delay lines and use space switching only for <em>admission</em> and <em>release</em>.
            This turns the TSI into a true <strong>store-and-forward optical time buffer</strong>.
          </p>

          <div class="callouts">
            <div class="card">
              <h3>Block-level architecture (verbal block diagram)</h3>
              <ul>
                <li><strong>Input DEMUX (time-to-space):</strong> converts the serial TDM stream into <code>N</code> spatial channels, one per time slot, per frame.</li>
                <li><strong>Admission space switch:</strong> connects the active slot channel to one of <code>B</code> programmable delay-line buffers at the moment the pulse arrives.</li>
                <li><strong>Programmable delay-line buffer bank:</strong> each buffer is a fiber loop + fast crossbar that can hold a pulse for <code>mT</code> and then release it.</li>
                <li><strong>Release space switch:</strong> at each output slot time, connects the buffer scheduled to release to the appropriate output line.</li>
                <li><strong>Output MUX (space-to-time):</strong> recombines into one serial output stream with the desired slot order.</li>
              </ul>
            </div>

            <div class="card">
              <h3>How this differs from the textbook 5-step TSI</h3>
              <ul>
                <li>Instead of two <em>fixed</em> delay banks around the space switch, the “delay” is implemented by <em>programmable storage</em> in the loop buffers.</li>
                <li>The space switch is used as a <em>router</em> into/out of buffers, not as the main mechanism to set timing offsets.</li>
                <li>The key control is the integer <code>m(i)</code> (how long each pulse stays in its loop) plus admission/release scheduling.</li>
              </ul>
            </div>
          </div>

          <details>
            <summary>How many buffers are needed?</summary>
            <div class="inside">
              <p class="muted">
                For an arbitrary permutation of <code>N</code> slots, a safe (worst-case) design is to have <strong>B = N</strong> buffers so that,
                within a frame, you can store all incoming pulses simultaneously and release one per slot later according to the schedule.
                With fewer buffers, some permutations can still work, but feasibility becomes a scheduling/contestion problem.
              </p>
            </div>
          </details>
        </article>

        <article class="kbox">
          <h3>Step 5 — Control schedule (how to operate it)</h3>
          <p class="muted">
            The controller operates in discrete slot time. For each input slot <code>i</code>:
          </p>
          <ul class="muted" style="margin:8px 0 0; padding-left: 18px;">
            <li><strong>Admission:</strong> at time <code>t = (i−1)T</code>, route the pulse into an available buffer <code>b(i)</code> and set that buffer’s loop count to <code>m(i)</code>.</li>
            <li><strong>Hold:</strong> the pulse circulates <code>m(i)</code> times, accruing delay <code>m(i)T</code>.</li>
            <li><strong>Release:</strong> at time <code>t = (i−1)T + m(i)T</code>, command the buffer to exit, and route it (via the release switch) into the output MUX so it occupies slot <code>π(i)</code>.</li>
          </ul>

          <div class="eq">
            <div class="row">
              <div>
                <span class="badge"><span class="b"></span> Timing consistency check</span>
                <code id="eq7">Release time for pulse from slot i:
t_rel(i) = t_in(i) + Δ(i) = (i−1)T + ((π(i)−i) mod N)T

This equals (π(i)−1)T modulo the frame time N·T.</code>
              </div>
              <button class="copy" data-copy-target="eq7">Copy</button>
            </div>
          </div>

          <article class="kbox" style="margin-top:12px;">
            <h3>Sanity checks (must pass)</h3>
            <ul class="muted">
              <li><strong>Units:</strong> <code>Δ</code> and <code>t</code> are in seconds; <code>m</code> is dimensionless; multiplying <code>m·T</code> gives seconds.</li>
              <li><strong>Limiting case:</strong> if <code>π(i)=i</code>, then <code>Δ=0</code> and the pulse exits immediately (no loop storage).</li>
              <li><strong>Wrap-around:</strong> if <code>π(i)=1</code> and <code>i=N</code>, then <code>Δ=((1−N) mod N)T = (1)T</code>: the last slot can be moved to the first slot by delaying one slot into the next frame.</li>
              <li><strong>Permutation feasibility:</strong> because <code>π</code> is one-to-one, exactly one pulse is scheduled per output slot, preventing output collisions (assuming correct routing).</li>
            </ul>
          </article>
        </article>

        <div class="final" id="finalBox">
          <h3>Final Answer (architecture + control law)</h3>
          <div style="display:flex; gap:10px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap;">
            <code id="finalText">Another TSI implementation using the programmable delay line (fiber loop + crossbar):

Hardware blocks:
1) Input DEMUX (time-to-space) → produces N spatial channels (one active each slot).
2) Admission space switch → routes each arriving slot pulse into a chosen programmable loop buffer.
3) Bank of programmable delay-line buffers → each provides τ = mT by keeping the pulse in the loop for m round trips.
4) Release space switch → at each output slot time, connects the appropriate buffer to the output.
5) Output MUX (space-to-time) → recombines into a single serial stream.

Control law for an N-slot frame (slot period T) implementing permutation π:
Required delay for input slot i → output slot π(i):
Δ(i) = ((π(i) − i) mod N)·T
Set loop count:
m(i) = Δ(i)/T = ((π(i) − i) mod N)

Operation:
At t=(i−1)T admit the pulse into its buffer and set m(i).
After m(i) round trips, release and route to the output so it occupies slot π(i) (modulo frame time).</code>
            <button class="copy" data-copy-target="finalText" aria-label="Copy final answer">Copy</button>
          </div>
        </div>

        <!-- Optional single plot -->
        <figure aria-label="Plot of programmable delay versus number of loop round trips">
          <div class="plotwrap">
            <canvas id="plot" width="900" height="320" aria-label="Delay vs round trips plot"></canvas>
          </div>
          <figcaption>
            One simple relationship matters for the programmable delay line: <strong>τ = mT</strong> (linear in the number of loop round trips).
            The plot below uses <em>example values only</em>: <code>T = 1 ns</code>, <code>m = 0…10</code>.
          </figcaption>
        </figure>

      </div>
    </section>

    <!-- PART 4 -->
    <section id="p4">
      <div class="hd"><h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2></div>
      <div class="bd">

        <article class="kbox">
          <h3>Re-interpreting the final formula</h3>
          <p class="muted">
            The formula
            <code>Δ(i)=((π(i)−i) mod N)T</code>
            says: “How far forward in the slot grid must the pulse be shifted to land in the desired output slot?”
            Each term has a clear role:
          </p>
          <ul class="muted">
            <li><strong><code>π(i)−i</code>:</strong> the intended slot displacement (can be negative).</li>
            <li><strong><code>mod N</code>:</strong> converts negative displacements into a positive <em>wrap-around delay</em> (release next frame).</li>
            <li><strong>Multiply by <code>T</code>:</strong> converts slot steps into seconds.</li>
          </ul>
        </article>

        <div class="twoCol">
          <article class="kbox">
            <h3>Parameter dependence (qualitative)</h3>
            <ul class="muted">
              <li><strong>Increase <code>T</code> (slower slot rate):</strong> larger absolute delays for the same permutation; easier switching timing, but lower throughput.</li>
              <li><strong>Increase <code>N</code> (longer frame):</strong> larger worst-case wrap-around delay <code>(N−1)T</code>; more buffering required.</li>
              <li><strong>Increase max <code>m</code> supported:</strong> enables larger permutations without redesign, but stresses loss/dispersion budgets.</li>
            </ul>
          </article>
          <article class="kbox">
            <h3>Alternative derivation idea (brief but meaningful)</h3>
            <p class="muted" style="margin:0;">
              Think of each slot as a phase on a discrete-time circle of length <code>N</code>.
              The permutation selects a target phase. The only allowed operation is adding nonnegative phase steps (delays).
              Therefore the needed delay is the <em>unique nonnegative representative</em> of <code>π(i)−i</code> modulo <code>N</code>,
              which is exactly <code>((π(i)−i) mod N)</code>.
            </p>
          </article>
        </div>

        <article class="kbox">
          <h3>Concept checks (self-test with answers)</h3>
          <ul class="muted">
            <li><strong>Q:</strong> If <code>π(i)=i</code>, what is <code>m(i)</code>? <strong>A:</strong> <code>m(i)=0</code> (no buffering needed).</li>
            <li><strong>Q:</strong> Why can’t we “advance” a pulse in time? <strong>A:</strong> Causality: you can only store and release later, not earlier; hence wrap-around delays for earlier slots.</li>
            <li><strong>Q:</strong> What is the maximum required delay in a frame? <strong>A:</strong> <code>Δ_max = (N−1)T</code>.</li>
            <li><strong>Q:</strong> What physical effects limit large <code>m</code>? <strong>A:</strong> accumulated loss, amplified noise (if used), dispersion/pulse broadening, and crosstalk/switch leakage per pass.</li>
            <li><strong>Q:</strong> From an industrial engineering view, what is the “resource” being scheduled? <strong>A:</strong> the buffer bank (and switch time) — each pulse is a job that occupies one buffer for <code>mT</code> and must be released at a deadline (target slot).</li>
          </ul>
        </article>

      </div>
    </section>

    <!-- PART 5 -->
    <section id="p5">
      <div class="hd"><h2>PART 5 — Optional Plot Guide</h2></div>
      <div class="bd">
        <article class="kbox">
          <h3>What the plot shows (and why it’s useful)</h3>
          <p class="muted">
            The plot visualizes the key control relationship of the programmable delay line:
            <strong>delay grows linearly</strong> with the number of loop round trips:
            <code>τ = mT</code>.
            This is useful because it tells you immediately how “deep” the buffer must be:
            to realize worst-case wrap-around (<code>N−1</code> slots), the buffer must support up to <code>m_max = N−1</code>.
          </p>
          <ul class="muted">
            <li><strong>x-axis:</strong> number of round trips <code>m</code> (dimensionless).</li>
            <li><strong>y-axis:</strong> total delay <code>τ</code> in nanoseconds (ns).</li>
            <li><strong>Example values:</strong> the plot uses <code>T = 1 ns</code> and <code>m = 0…10</code> purely for visualization; the final solution remains symbolic.</li>
            <li><strong>Feature to notice:</strong> constant slope <code>dτ/dm = T</code>; each additional circulation adds exactly one slot period of delay.</li>
          </ul>
        </article>
      </div>
    </section>

  </div>
</main>

<footer>
  <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:space-between;">
    <div>
      <div style="font-weight:700; color:var(--ink);">End of article</div>
      <div class="faint">Optical TSI via programmable delay buffers: physics rules the timing; engineering rules the feasibility.</div>
    </div>
    <a class="backTop" href="#top" aria-label="Back to top">↑ Back to top</a>
  </div>
</footer>

<script>
  // Copy buttons
  (function(){
    function copyText(text){
      if(navigator.clipboard && navigator.clipboard.writeText){
        return navigator.clipboard.writeText(text);
      }
      // Fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.setAttribute('readonly','');
      ta.style.position='fixed';
      ta.style.top='-9999px';
      document.body.appendChild(ta);
      ta.select();
      try{ document.execCommand('copy'); }catch(e){}
      document.body.removeChild(ta);
      return Promise.resolve();
    }

    function flash(btn, ok){
      const old = btn.textContent;
      btn.textContent = ok ? "Copied!" : "Copy failed";
      btn.style.borderColor = ok ? "rgba(134,239,172,.45)" : "rgba(251,113,133,.45)";
      btn.style.background = ok ? "rgba(134,239,172,.10)" : "rgba(251,113,133,.10)";
      setTimeout(()=>{
        btn.textContent = old;
        btn.style.borderColor = "";
        btn.style.background = "";
      }, 950);
    }

    document.addEventListener('click', async (e)=>{
      const btn = e.target.closest('button.copy');
      if(!btn) return;
      const id = btn.getAttribute('data-copy-target');
      const el = document.getElementById(id);
      if(!el) return;
      const text = el.innerText.replace(/\u00A0/g,' ');
      try{
        await copyText(text);
        flash(btn, true);
      }catch(err){
        flash(btn, false);
      }
    });
  })();

  // Single static plot: tau = mT with example T=1 ns
  (function(){
    const canvas = document.getElementById('plot');
    if(!canvas) return;

    function draw(){
      const parent = canvas.parentElement;
      const cssW = Math.max(280, parent.clientWidth - 0);
      const cssH = 320;

      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      canvas.style.width = cssW + "px";
      canvas.style.height = cssH + "px";
      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);

      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.clearRect(0,0,cssW,cssH);

      // Styling helpers (no external libs)
      function line(x1,y1,x2,y2, stroke, w){
        ctx.beginPath();
        ctx.moveTo(x1,y1);
        ctx.lineTo(x2,y2);
        ctx.lineWidth = w || 1;
        ctx.strokeStyle = stroke;
        ctx.stroke();
      }
      function text(s,x,y, fill, font, align, base){
        ctx.fillStyle = fill || "rgba(255,255,255,.92)";
        ctx.font = font || "12px " + getComputedStyle(document.body).fontFamily;
        ctx.textAlign = align || "left";
        ctx.textBaseline = base || "alphabetic";
        ctx.fillText(s,x,y);
      }

      const padL = 56, padR = 18, padT = 40, padB = 44;
      const W = cssW - padL - padR;
      const H = cssH - padT - padB;

      // Example values
      const T_ns = 1.0;
      const mMin = 0, mMax = 10;
      const tauMin = 0, tauMax = mMax * T_ns;

      // Axes mapping
      const x = m => padL + ( (m - mMin) / (mMax - mMin) ) * W;
      const y = tau => padT + H - ( (tau - tauMin) / (tauMax - tauMin) ) * H;

      // Background panel
      ctx.fillStyle = "rgba(0,0,0,.18)";
      ctx.fillRect(10,10,cssW-20,cssH-20);

      // Title
      text("Programmable Delay Line: \u03C4 = mT (example T = 1 ns)", padL, 24, "rgba(255,255,255,.92)", "700 14px " + getComputedStyle(document.body).fontFamily, "left", "alphabetic");

      // Gridlines and ticks
      const grid = "rgba(255,255,255,.10)";
      const axis = "rgba(255,255,255,.65)";
      const tick = "rgba(255,255,255,.65)";
      const lab = "rgba(234,240,255,.92)";
      const sub = "rgba(183,195,230,.92)";

      // Vertical grid (m ticks)
      for(let m = mMin; m <= mMax; m++){
        const X = x(m);
        line(X, padT, X, padT+H, grid, 1);
        // tick label
        text(String(m), X, padT+H+18, sub, "12px " + getComputedStyle(document.body).fontFamily, "center", "middle");
      }

      // Horizontal grid (tau ticks)
      const yTicks = 5;
      for(let k=0; k<=yTicks; k++){
        const tau = tauMin + (tauMax - tauMin) * (k/yTicks);
        const Y = y(tau);
        line(padL, Y, padL+W, Y, grid, 1);
        text(tau.toFixed(0), padL-10, Y, sub, "12px " + getComputedStyle(document.body).fontFamily, "right", "middle");
      }

      // Axes
      line(padL, padT, padL, padT+H, axis, 1.5);
      line(padL, padT+H, padL+W, padT+H, axis, 1.5);

      // Axis labels
      text("m (round trips)", padL + W/2, padT+H+36, lab, "600 12.5px " + getComputedStyle(document.body).fontFamily, "center", "middle");
      // y-axis label (rotated)
      ctx.save();
      ctx.translate(18, padT + H/2);
      ctx.rotate(-Math.PI/2);
      text("\u03C4 (delay) [ns]", 0, 0, lab, "600 12.5px " + getComputedStyle(document.body).fontFamily, "center", "middle");
      ctx.restore();

      // Plot line: tau = m*T
      ctx.beginPath();
      for(let m=mMin; m<=mMax; m++){
        const X = x(m);
        const Y = y(m*T_ns);
        if(m===mMin) ctx.moveTo(X,Y);
        else ctx.lineTo(X,Y);
      }
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(125,211,252,.92)";
      ctx.stroke();

      // Points
      for(let m=mMin; m<=mMax; m++){
        const X = x(m);
        const Y = y(m*T_ns);
        ctx.beginPath();
        ctx.arc(X, Y, 3.2, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,255,255,.90)";
        ctx.fill();
      }

      // Legend
      const lx = padL + W - 190;
      const ly = padT + 10;
      ctx.fillStyle = "rgba(0,0,0,.22)";
      ctx.fillRect(lx, ly, 180, 44);
      ctx.strokeStyle = "rgba(255,255,255,.14)";
      ctx.strokeRect(lx, ly, 180, 44);

      line(lx+12, ly+16, lx+48, ly+16, "rgba(125,211,252,.92)", 2);
      ctx.beginPath(); ctx.arc(lx+30, ly+16, 3.2, 0, Math.PI*2); ctx.fillStyle="rgba(255,255,255,.90)"; ctx.fill();
      text("\u03C4 = mT", lx+58, ly+20, "rgba(234,240,255,.92)", "600 12px " + getComputedStyle(document.body).fontFamily, "left", "alphabetic");
      text("(example T = 1 ns)", lx+58, ly+36, "rgba(183,195,230,.92)", "12px " + getComputedStyle(document.body).fontFamily, "left", "alphabetic");
    }

    let raf = null;
    function requestDraw(){
      if(raf) cancelAnimationFrame(raf);
      raf = requestAnimationFrame(draw);
    }

    window.addEventListener('resize', requestDraw, {passive:true});
    requestDraw();
  })();
</script>
</body>
</html>
