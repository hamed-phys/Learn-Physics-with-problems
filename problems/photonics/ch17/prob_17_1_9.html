<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Bowing Parameters for Ternary Semiconductors (Vegard + Bandgap Bowing)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f1620;
      --panel2:#0d131b;
      --text:#e8eef7;
      --muted:#a9b7cc;
      --faint:#7f8fa8;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line: rgba(255,255,255,0.09);
      --shadow: 0 18px 50px rgba(0,0,0,0.35);
      --radius: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 700px at 18% 8%, rgba(125,211,252,0.10), transparent 55%),
        radial-gradient(900px 600px at 85% 20%, rgba(167,139,250,0.10), transparent 55%),
        radial-gradient(700px 500px at 60% 85%, rgba(52,211,153,0.08), transparent 55%),
        linear-gradient(180deg, #070a0f, var(--bg));
      color:var(--text);
      line-height:1.6;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding: 34px 20px 10px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .title{
      display:flex; gap:14px; align-items:flex-start; flex-wrap:wrap;
    }
    .badge{
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
      background: rgba(255,255,255,0.03);
      margin-top:6px;
    }
    h1{
      margin:0;
      font-size: clamp(22px, 2.2vw, 34px);
      letter-spacing:0.2px;
    }
    .subtitle{
      margin:10px 0 0;
      max-width: 900px;
      color: var(--muted);
      font-size: 15px;
    }

    main{
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px 20px 80px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 18px;
    }

    nav#toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .toc-title{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      margin-bottom:8px;
    }
    .toc-title h2{
      font-size: 13px;
      margin:0;
      color: var(--muted);
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }
    .toc-small{
      font-size:12px; color:var(--faint);
      user-select:none;
    }
    nav#toc ul{list-style:none; padding:0; margin:10px 0 0}
    nav#toc li{margin: 6px 0}
    nav#toc a{
      display:block;
      padding:8px 10px;
      border-radius: 12px;
      border:1px solid transparent;
      color: var(--text);
      font-size: 13px;
      background: rgba(0,0,0,0.08);
    }
    nav#toc a:hover{
      border-color: rgba(125,211,252,0.35);
      background: rgba(125,211,252,0.08);
      text-decoration:none;
    }

    article{
      background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 18px 18px 6px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }

    section{
      padding: 10px 4px 18px;
      border-top: 1px solid rgba(255,255,255,0.07);
    }
    section:first-of-type{border-top:none}
    h2{
      margin: 4px 0 8px;
      font-size: 18px;
      letter-spacing:0.2px;
    }
    h3{
      margin: 14px 0 8px;
      font-size: 15px;
      color: #d9e6ff;
    }
    p{margin: 8px 0}
    ul{margin: 8px 0 8px 20px}
    li{margin: 6px 0}

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1.2fr 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
      nav#toc{position:relative; top:auto}
      .grid2,.grid3{grid-template-columns: 1fr}
    }

    .callout{
      border: 1px solid rgba(255,255,255,0.10);
      border-left: 4px solid rgba(125,211,252,0.70);
      background: rgba(0,0,0,0.18);
      border-radius: 14px;
      padding: 12px 12px;
      margin: 10px 0;
    }
    .callout.good{border-left-color: rgba(52,211,153,0.75)}
    .callout.warn{border-left-color: rgba(251,191,36,0.75)}
    .callout.bad{border-left-color: rgba(251,113,133,0.75)}
    .callout .k{
      font-size:12px;
      color: var(--muted);
      letter-spacing:0.12em;
      text-transform: uppercase;
      margin-bottom: 4px;
    }

    .eq{
      font-family: var(--mono);
      font-size: 13px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 10px 10px;
      overflow:auto;
      position: relative;
    }
    .eq .copyBtn{
      position:absolute;
      top:8px; right:8px;
      font-size:12px;
      padding:6px 9px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.25);
      color: var(--text);
      cursor:pointer;
    }
    .eq .copyBtn:hover{border-color: rgba(125,211,252,0.45)}
    .eq code{white-space: pre}

    .controls{
      display:grid;
      grid-template-columns: 1.2fr 1fr 1fr;
      gap: 12px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.18);
      border-radius: 14px;
      margin: 10px 0 14px;
    }
    @media (max-width: 980px){
      .controls{grid-template-columns: 1fr}
    }
    label{
      display:block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
      letter-spacing:0.08em;
      text-transform: uppercase;
    }
    select, input[type="range"], input[type="number"]{
      width:100%;
      accent-color: var(--accent);
    }
    .ctrlBox{
      padding: 8px 10px;
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      background: rgba(255,255,255,0.03);
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-top:6px;
      color: var(--muted);
      font-size: 12px;
      font-family: var(--mono);
    }

    figure{
      margin: 0;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.16);
      border-radius: 14px;
      padding: 10px;
      overflow:hidden;
    }
    figcaption{
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
    }
    canvas{
      width:100%;
      height: 280px;
      display:block;
      border-radius: 12px;
      background: rgba(8,12,18,0.65);
    }
    .canvasTall{height: 320px;}

    table{
      width:100%;
      border-collapse: collapse;
      overflow:hidden;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.14);
      margin: 10px 0;
    }
    th,td{
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      font-size: 13px;
      vertical-align: top;
    }
    th{
      text-align:left;
      color: #d7e6ff;
      background: rgba(255,255,255,0.04);
      font-size: 12px;
      letter-spacing:0.10em;
      text-transform: uppercase;
    }
    tr:last-child td{border-bottom:none}
    .mono{font-family: var(--mono)}
    .pill{
      display:inline-block;
      padding: 3px 8px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      color: var(--muted);
    }

    .footer{
      padding: 14px 4px 18px;
      color: var(--muted);
      font-size: 12px;
    }

    /* subtle motion */
    @media (prefers-reduced-motion: no-preference){
      article, nav#toc{animation: pop 420ms ease-out both}
      @keyframes pop{
        from{transform: translateY(8px); opacity:0.0}
        to{transform: translateY(0); opacity:1}
      }
    }

    /* print-friendly */
    @media print{
      body{background:white; color:black}
      nav#toc{display:none}
      article{box-shadow:none; background:white; border:1px solid #ddd}
      canvas{background:white}
      .eq{background:#f6f6f6; border-color:#ddd}
      .callout{background:#f8f8f8; border-color:#ddd}
      .controls{display:none}
      a{color:black; text-decoration:underline}
    }
  </style>
</head>
<body>
  <header>
    <div class="title">
      <h1>Bowing Parameters for Ternary Semiconductors</h1>
      <span class="badge">Vegard’s law + bandgap bowing model</span>
      <span class="badge">Interactive plots (composition, lattice match, strain)</span>
    </div>
    <p class="subtitle">
      We model how the bandgap <span class="mono">E<sub>g</sub></span> of a ternary alloy
      <span class="mono">A<sub>x</sub>B<sub>1−x</sub>C</span> deviates from linear interpolation via a
      <span class="mono">bowing parameter b</span>, then connect that nonlinearity to lattice-matching design.
    </p>
  </header>

  <main>
    <nav id="toc" aria-label="Table of contents">
      <div class="toc-title">
        <h2>Contents</h2>
        <div class="toc-small">sticky</div>
      </div>
      <ul>
        <li><a href="#quick">Quick Summary</a></li>
        <li><a href="#part0">PART 0 — Concept Primer</a></li>
        <li><a href="#part1">PART 1 — Problem Analysis</a></li>
        <li><a href="#part2">PART 2 — Strategy & Tips</a></li>
        <li><a href="#part3">PART 3 — Full Solution</a></li>
        <li><a href="#part4">PART 4 — Deeper Understanding</a></li>
        <li><a href="#part5">PART 5 — Visualization Guide</a></li>
      </ul>
    </nav>

    <article>
      <section id="quick">
        <h2>Quick Summary</h2>
        <ul>
          <li>The problem asks for <span class="mono">bowing parameters b</span> for several ternary alloys using the provided <span class="mono">E<sub>g</sub></span>–lattice-constant curves.</li>
          <li>Key physics idea: the <span class="mono">lattice constant a(x)</span> is (approximately) linear in composition (Vegard’s law), but <span class="mono">E<sub>g</sub>(x)</span> is usually <b>nonlinear</b>.</li>
          <li>Model: <span class="mono">E<sub>g</sub>(x) = xE<sub>g</sub>(AC) + (1−x)E<sub>g</sub>(BC) − b x(1−x)</span>.</li>
          <li>How to extract <span class="mono">b</span>: pick a composition (often <span class="mono">x=0.5</span>), read <span class="mono">E<sub>g</sub></span> from the curve, compare to the linear-interpolation value.</li>
          <li>Typical extracted/consistent values (order-of-magnitude from standard curve shapes): <span class="mono">b</span> is small for some III–V’s (tenths of eV) and much larger for some III–nitrides (≈1–4 eV).</li>
          <li>Lattice matching: <span class="mono">b</span> hardly changes <span class="mono">a(x)</span> (that’s Vegard), but it strongly changes the <span class="mono">bandgap you get at the lattice-matched composition</span>.</li>
          <li>Final result type: <b>numeric estimates</b> for <span class="mono">b</span> + an engineering interpretation for epitaxy/substrates.</li>
        </ul>
      </section>

      <section id="part0">
        <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

        <div class="grid2">
          <div>
            <h3>Core definitions (symbols & units)</h3>
            <ul>
              <li><span class="mono">x</span> — alloy composition fraction of the <span class="mono">AC</span> end member (dimensionless, 0→1).</li>
              <li><span class="mono">a(x)</span> — lattice constant (Å). For cubic zincblende it’s the cubic lattice parameter; for wurtzite nitrides we often use the in-plane parameter (Å).</li>
              <li><span class="mono">E<sub>g</sub>(x)</span> — bandgap energy (eV), sets absorption edge / emission wavelength.</li>
              <li><span class="mono">b</span> — bowing parameter (eV), quantifies deviation of <span class="mono">E<sub>g</sub>(x)</span> from linear mixing.</li>
              <li><span class="mono">f(x) = (a(x) − a<sub>s</sub>)/a<sub>s</sub></span> — lattice mismatch (dimensionless) to substrate lattice constant <span class="mono">a<sub>s</sub></span>.</li>
            </ul>
          </div>
          <div>
            <h3>Physical meaning</h3>
            <p>
              <b>Vegard’s law</b> says atoms “average” their spacing, so the lattice constant changes almost linearly with composition:
              <span class="mono">a(x) ≈ xa(AC) + (1−x)a(BC)</span>.
            </p>
            <p>
              The <b>bandgap</b>, however, depends on electronic structure (orbital energies, bonding, band offsets, disorder). Mixing two compounds
              changes these nonlinearly, so <span class="mono">E<sub>g</sub>(x)</span> often curves (“bows”) relative to the straight line between end members.
            </p>
          </div>
        </div>

        <div class="callout good">
          <div class="k">Key model</div>
          <div class="eq" id="eq1">
            <button class="copyBtn" data-copy="E_g(x)=x E_g(AC)+(1-x)E_g(BC)-b x(1-x)">Copy</button>
            <code>E_g(x) = x E_g(AC) + (1 − x) E_g(BC) − b x(1 − x)</code>
          </div>
          <p style="margin-top:8px;color:var(--muted)">
            This form guarantees the correct endpoints: <span class="mono">E<sub>g</sub>(0)=E<sub>g</sub>(BC)</span> and <span class="mono">E<sub>g</sub>(1)=E<sub>g</sub>(AC)</span>.
            The maximum deviation from linear mixing occurs near <span class="mono">x=0.5</span> because <span class="mono">x(1−x)</span> is largest there.
          </p>
        </div>

        <h3>When the model is valid (assumptions/conditions)</h3>
        <ul>
          <li>Random alloy with composition described by a single parameter <span class="mono">x</span> (no strong clustering/ordering).</li>
          <li>Bandgap can be represented by a smooth quadratic in <span class="mono">x</span> over the composition range of interest.</li>
          <li>Temperature fixed (bowing and endpoints can be temperature-dependent; many charts are near room temperature).</li>
          <li>For alloys with direct/indirect transitions (e.g., some III–V’s), <span class="mono">E<sub>g</sub></span> may switch to a different valley; bowing then becomes “piecewise.”</li>
        </ul>

        <h3>Common approximations (and why we use them)</h3>
        <ul>
          <li><b>Vegard’s law for lattice constant</b>: good first design tool for epitaxy and lattice matching.</li>
          <li><b>Single bowing parameter</b>: compresses complex electronic effects (band offsets, disorder, strain, interactions) into one useful engineering number.</li>
          <li><b>Reading from an <span class="mono">E<sub>g</sub></span>–<span class="mono">a</span> chart</b>: avoids needing a separate <span class="mono">E<sub>g</sub>(x)</span> plot, because composition maps to lattice constant linearly.</li>
        </ul>

        <h3>Mini intuition examples</h3>
        <ul>
          <li>If <span class="mono">b = 0</span>, the bandgap is a straight line between endpoints: “perfect linear mixing.”</li>
          <li>If <span class="mono">b &gt; 0</span>, then <span class="mono">E<sub>g</sub>(x)</span> lies <b>below</b> the straight line (the alloy gap is smaller than linear interpolation predicts), strongest near <span class="mono">x=0.5</span>.</li>
        </ul>

        <div class="callout warn">
          <div class="k">What to watch for (pitfalls)</div>
          <ul style="margin:6px 0 0 20px">
            <li><b>Endpoint choice matters</b>: use the correct end-member gaps consistent with the plotted curve (direct vs indirect, same temperature).</li>
            <li><b>Composition mapping</b>: if the plot is <span class="mono">E<sub>g</sub></span> vs <span class="mono">a</span>, you must map <span class="mono">x ↔ a</span> using Vegard’s law.</li>
            <li><b>Large bowing</b> can mean the “single b” model is only approximate; sometimes <span class="mono">b</span> depends on <span class="mono">x</span>.</li>
          </ul>
        </div>
      </section>

      <section id="part1">
        <h2>PART 1 — Problem Analysis (no solving yet)</h2>

        <h3>Rewrite the problem in plain words</h3>
        <p>
          We have ternary semiconductor alloys of the form <span class="mono">A<sub>x</sub>B<sub>1−x</sub>C</span>.
          The lattice constant varies approximately linearly with composition (Vegard’s law), but the bandgap varies nonlinearly (“bows”).
          Using the provided bandgap-versus-lattice-constant curves, estimate the bowing parameter <span class="mono">b</span> for:
        </p>
        <ul>
          <li><span class="mono">Al<sub>x</sub>Ga<sub>1−x</sub>As</span></li>
          <li><span class="mono">GaAs<sub>1−x</sub>P<sub>x</sub></span></li>
          <li><span class="mono">Al<sub>x</sub>Ga<sub>1−x</sub>N</span></li>
          <li><span class="mono">In<sub>x</sub>Ga<sub>1−x</sub>N</span></li>
          <li><span class="mono">Al<sub>x</sub>In<sub>1−x</sub>N</span></li>
          <li><span class="mono">Hg<sub>x</sub>Cd<sub>1−x</sub>Te</span></li>
        </ul>
        <p>
          Then explain what the bowing parameter means for lattice matching to a substrate.
        </p>

        <h3>Given quantities</h3>
        <ul>
          <li>The quadratic bowing model: <span class="mono">E<sub>g</sub>(x)=xE<sub>g</sub>(AC)+(1−x)E<sub>g</sub>(BC)−b x(1−x)</span>.</li>
          <li>Curves from Figs. 17.1-7 and 17.1-8 giving <span class="mono">E<sub>g</sub></span> versus lattice constant for relevant binaries and their ternaries.</li>
          <li>Implicit: Vegard’s law for lattice constant: <span class="mono">a(x)≈xa(AC)+(1−x)a(BC)</span>.</li>
        </ul>

        <h3>Unknowns</h3>
        <ul>
          <li>Bowing parameters <span class="mono">b</span> for the listed alloys (in eV).</li>
          <li>Interpretation: how <span class="mono">b</span> impacts the bandgap at a lattice-matched composition to a substrate.</li>
        </ul>

        <h3>Relevant principles and why they apply</h3>
        <ul>
          <li><b>Vegard’s law</b> applies to lattice constant vs composition for many substitutional alloys (good first-order).</li>
          <li><b>Quadratic bowing model</b> applies because many alloy gaps are well fit by a second-order deviation from linear mixing.</li>
          <li><b>Epitaxial matching</b>: substrate sets in-plane lattice constant, so composition is chosen to minimize mismatch; then the resulting <span class="mono">E<sub>g</sub></span> depends on <span class="mono">b</span>.</li>
        </ul>

        <div class="callout">
          <div class="k">Assumptions</div>
          <ul style="margin:6px 0 0 20px">
            <li><span class="mono">a(x)</span> follows Vegard’s law (linear).</li>
            <li><span class="mono">b</span> is treated as composition-independent (single constant per alloy) for estimation.</li>
            <li>We read approximate values from plotted curves (so results are approximate, typically within a few tenths of eV depending on resolution).</li>
          </ul>
        </div>

        <h3>Possible approaches (compare)</h3>
        <ul>
          <li><b>Midpoint method (fast)</b>: use <span class="mono">x=0.5</span>, read <span class="mono">E<sub>g</sub></span> at mid-lattice-constant, solve for <span class="mono">b</span>. <span class="pill">Pros: quick</span> <span class="pill">Cons: uses only one point</span></li>
          <li><b>Two-point fit (better)</b>: read <span class="mono">E<sub>g</sub></span> at two compositions (e.g., 0.25 and 0.75), least-squares fit <span class="mono">b</span>. <span class="pill">Pros: more robust</span> <span class="pill">Cons: more digitizing</span></li>
          <li><b>Full curve digitization (best)</b>: digitize many points from the curve, fit quadratic. <span class="pill">Pros: most accurate</span> <span class="pill">Cons: most work</span></li>
        </ul>
        <p>
          We’ll use the <b>midpoint method</b> for clarity (and because the problem statement points to using the curves qualitatively).
        </p>
      </section>

      <section id="part2">
        <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

        <ol>
          <li>
            <b>Identify endpoints</b> <span class="mono">(AC, BC)</span>.
            <div class="mono" style="color:var(--muted)">Tool: read end-member gaps from the chart</div>
            <div style="color:var(--muted)">Meaning: anchors the model so the curve must hit these values at x=0 and x=1.</div>
          </li>
          <li>
            <b>Map composition to lattice constant</b> using Vegard’s law.
            <div class="mono" style="color:var(--muted)">Tool: a(x)=x a(AC)+(1-x)a(BC)</div>
            <div style="color:var(--muted)">Meaning: lets an E<sub>g</sub>(a) chart give E<sub>g</sub>(x).</div>
          </li>
          <li>
            <b>Choose a convenient composition</b> (typically <span class="mono">x=0.5</span>).
            <div class="mono" style="color:var(--muted)">Tool: x(1-x) peaks at 0.25</div>
            <div style="color:var(--muted)">Meaning: bowing effect is strongest at mid-composition, improving sensitivity.</div>
          </li>
          <li>
            <b>Read</b> <span class="mono">E<sub>g</sub>(x)</span> from the curve at the corresponding lattice constant.
            <div style="color:var(--muted)">Tip: be consistent about direct vs indirect branch if both appear.</div>
          </li>
          <li>
            <b>Compute linear interpolation</b> at the same <span class="mono">x</span>.
            <div class="mono" style="color:var(--muted)">Tool: E_lin(x)=xE_g(AC)+(1-x)E_g(BC)</div>
            <div style="color:var(--muted)">Meaning: what you would get if there were no bowing.</div>
          </li>
          <li>
            <b>Solve for b</b>:
            <div class="mono" style="color:var(--muted)">b = [E_lin(x) - E_g(x)] / [x(1-x)]</div>
            <div style="color:var(--muted)">Meaning: how strongly the curve dips below the linear line.</div>
          </li>
          <li>
            <b>Interpretation for lattice matching</b>:
            <div style="color:var(--muted)">Given a substrate lattice constant a<sub>s</sub>, Vegard gives the matching composition x; bowing then tells the actual gap at that x.</div>
          </li>
        </ol>

        <div class="callout warn">
          <div class="k">Common mistakes</div>
          <ul style="margin:6px 0 0 20px">
            <li>Mixing data from different temperatures for endpoints vs curve.</li>
            <li>Using the wrong branch (direct vs indirect) when the plot shows both.</li>
            <li>For nearly vertical lines (lattice-matched pairs), confusing “a doesn’t change” with “x doesn’t change.”</li>
          </ul>
        </div>
      </section>

      <section id="part3">
        <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

        <h3>Physical intuition first</h3>
        <p>
          If two compounds have very different bonding/electronic structure (large band offsets, different electronegativities, strong disorder),
          the alloy bands do not interpolate linearly. You expect a stronger deviation from linearity (larger <span class="mono">b</span>).
          Conversely, chemically “similar” pairs often show weaker bowing (small <span class="mono">b</span>).
        </p>

        <h3>Step 1: Write the governing equation and define symbols</h3>
        <div class="eq" id="eq2">
          <button class="copyBtn" data-copy="b = (E_lin(x)-E_g(x)) / (x(1-x));  E_lin(x)=xE_g(AC)+(1-x)E_g(BC)">Copy</button>
          <code>
E_g(x) = x E_g(AC) + (1−x) E_g(BC) − b x(1−x)

E_lin(x) = x E_g(AC) + (1−x) E_g(BC)

Solve for b:
b = [E_lin(x) − E_g(x)] / [x(1−x)]
          </code>
        </div>
        <p>
          Here <span class="mono">E_g(AC)</span> and <span class="mono">E_g(BC)</span> are the end-member bandgaps (eV).
          The denominator <span class="mono">x(1−x)</span> is dimensionless, so <span class="mono">b</span> has units of eV, as expected.
        </p>

        <h3>Step 2: Use Vegard’s law to map the chart (E<sub>g</sub> vs a) into E<sub>g</sub>(x)</h3>
        <div class="eq" id="eq3">
          <button class="copyBtn" data-copy="a(x)=x a(AC)+(1-x)a(BC);  a(0.5)=(a(AC)+a(BC))/2">Copy</button>
          <code>
Vegard (lattice):  a(x) ≈ x a(AC) + (1−x) a(BC)

At x = 0.5:  a(0.5) = [a(AC) + a(BC)] / 2
          </code>
        </div>
        <p>
          The figures plot bandgap against lattice constant. For ternaries, the alloy composition moves you along the line (or curve) between the two binaries.
          Using Vegard’s law, <span class="mono">x=0.5</span> corresponds to the mid-lattice-constant point between the binaries.
        </p>

        <h3>Step 3: Midpoint method for b</h3>
        <p>
          Choose <span class="mono">x=0.5</span>. Then <span class="mono">x(1−x)=0.25</span>, so:
        </p>
        <div class="eq" id="eq4">
          <button class="copyBtn" data-copy="b = 4 [E_lin(0.5) - E_g(0.5)] ;  E_lin(0.5)=0.5(E_g(AC)+E_g(BC))">Copy</button>
          <code>
At x = 0.5:
E_lin(0.5) = 0.5[E_g(AC) + E_g(BC)]

b = [E_lin(0.5) − E_g(0.5)] / 0.25
  = 4 [E_lin(0.5) − E_g(0.5)]
          </code>
        </div>
        <p>
          So once we read the midpoint bandgap from the curve, <span class="mono">b</span> follows immediately.
        </p>

        <h3>Step 4: Estimated bowing parameters from the provided curve shapes</h3>
        <p>
          Because the problem explicitly references the textbook’s <span class="mono">E_g</span>–<span class="mono">a</span> plots (Figs. 17.1-7 and 17.1-8),
          the goal is to extract <b>engineering-level</b> bowing estimates (not ultra-precise digitizations). The values below are consistent with the
          curvature shown (weak bowing for some III–V’s; strong bowing for III–nitrides; significant bowing in HgCdTe).
        </p>

        <table>
          <thead>
            <tr>
              <th>Alloy</th>
              <th>Estimated bowing parameter <span class="mono">b</span> (eV)</th>
              <th>Notes on curve / interpretation</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="mono">Al<sub>x</sub>Ga<sub>1−x</sub>As</td>
              <td><b>≈ 0.2 eV</b> (direct-gap region)<br><span class="pill">order: tenths</span></td>
              <td>
                In the III–V chart, the AlGaAs line is nearly vertical in <span class="mono">a</span> (good lattice match to GaAs), while the gap rises.
                The curvature is relatively mild for the direct branch, giving a small bowing (few × 0.1 eV).
              </td>
            </tr>
            <tr>
              <td class="mono">GaAs<sub>1−x</sub>P<sub>x</sub></td>
              <td><b>≈ 0.2 eV</b><br><span class="pill">order: tenths</span></td>
              <td>
                The GaAs–GaP line shows moderate curvature. A typical midpoint depression of ~0.05 eV implies
                <span class="mono">b ≈ 4×0.05 ≈ 0.2 eV</span>.
              </td>
            </tr>
            <tr>
              <td class="mono">Al<sub>x</sub>Ga<sub>1−x</sub>N</td>
              <td><b>≈ 0.8 eV</b><br><span class="pill">order: ~1</span></td>
              <td>
                In the nitride chart, the AlN–GaN curve bows noticeably below the straight interpolation line,
                indicating stronger electronic nonlinearity than typical arsenides/phosphides.
              </td>
            </tr>
            <tr>
              <td class="mono">In<sub>x</sub>Ga<sub>1−x</sub>N</td>
              <td><b>≈ 1.4 eV</b><br><span class="pill">order: 1–2</span></td>
              <td>
                The InN–GaN bowing is strong (a hallmark of InGaN). Large curvature is needed to connect
                <span class="mono">E_g(GaN)</span> to <span class="mono">E_g(InN)</span> while matching the plotted trend.
              </td>
            </tr>
            <tr>
              <td class="mono">Al<sub>x</sub>In<sub>1−x</sub>N</td>
              <td><b>≈ 4 eV</b><br><span class="pill">order: several</span></td>
              <td>
                AlN and InN are chemically and electronically very different; the plot shows very strong bowing.
                A midpoint depression on the order of ~1 eV gives <span class="mono">b ~ 4 eV</span>.
              </td>
            </tr>
            <tr>
              <td class="mono">Hg<sub>x</sub>Cd<sub>1−x</sub>Te</td>
              <td><b>≈ 0.8 eV</b><br><span class="pill">order: ~1</span></td>
              <td>
                The II–VI chart highlights that HgTe and CdTe are nearly lattice matched (vertical line),
                yet the gap changes dramatically with composition—classic HgCdTe behavior used for IR detectors.
                A sizable bowing (and strong temperature dependence) is typical.
              </td>
            </tr>
          </tbody>
        </table>

        <div class="callout warn">
          <div class="k">Sanity checks</div>
          <ul style="margin:6px 0 0 20px">
            <li><b>Units:</b> <span class="mono">b</span> is in eV because it multiplies a dimensionless factor <span class="mono">x(1−x)</span>.</li>
            <li><b>Limiting cases:</b> if <span class="mono">b=0</span>, curves become straight lines between end gaps.</li>
            <li><b>Maximum bowing effect:</b> the deviation from linear mixing is largest near <span class="mono">x=0.5</span>.</li>
          </ul>
        </div>

        <h3>Step 5: What does b mean for lattice matching to a substrate?</h3>
        <p>
          Lattice matching is primarily about <span class="mono">a(x)</span>. If Vegard’s law holds, the lattice-matched composition is:
        </p>
        <div class="eq" id="eq5">
          <button class="copyBtn" data-copy="x_match = (a_s - a(BC)) / (a(AC)-a(BC));  then E_g(match)=x_match E_g(AC)+(1-x_match)E_g(BC)-b x_match(1-x_match)">Copy</button>
          <code>
Given substrate lattice constant a_s:

x_match = [a_s − a(BC)] / [a(AC) − a(BC)]   (Vegard)

Then the lattice-matched bandgap is:

E_g(match) = x_match E_g(AC) + (1−x_match)E_g(BC) − b x_match(1−x_match)
          </code>
        </div>
        <p>
          <b>Key point:</b> <span class="mono">b</span> does <b>not</b> mainly decide whether you can match the lattice (that’s set by <span class="mono">a(x)</span>),
          but it strongly decides <b>what bandgap you get once you have matched the lattice</b>.
        </p>

        <div class="callout bad">
          <div class="k">Final Answer (copy-ready)</div>
          <div class="eq" id="finalAns">
            <button class="copyBtn" data-copy="Estimated bowing parameters (eV): AlxGa1-xAs ~0.2 (direct region), GaAs1-xPx ~0.2, AlxGa1-xN ~0.8, InxGa1-xN ~1.4, AlxIn1-xN ~4, HgxCd1-xTe ~0.8. Significance: b quantifies how much the alloy bandgap at a given composition (and thus at a lattice-matched composition to a substrate) deviates from linear interpolation; it barely changes lattice matching itself (set by a(x)), but it changes the bandgap/wavelength achievable while lattice-matched.">Copy</button>
            <code>
Estimated bowing parameters b (eV):
• AlxGa1−xAs  ≈ 0.2   (direct-gap region; mild bowing)
• GaAs1−xPx   ≈ 0.2
• AlxGa1−xN   ≈ 0.8
• InxGa1−xN   ≈ 1.4
• AlxIn1−xN   ≈ 4
• HgxCd1−xTe  ≈ 0.8

Significance for lattice matching:
Vegard’s law sets the lattice-matched composition x_match via a(x). The bowing parameter b then determines the
actual bandgap at that lattice-matched composition:
E_g(match)=x_match E_g(AC)+(1−x_match)E_g(BC)−b x_match(1−x_match).
So b strongly affects the wavelength/bandgap achievable while remaining lattice-matched.
            </code>
          </div>
        </div>

        <p>
          Connection to the diagrams/plots below: you’ll see that changing <span class="mono">b</span> leaves the lattice constant curve unchanged
          (still linear in <span class="mono">x</span>), but it reshapes the bandgap curve and therefore shifts the bandgap at the same
          lattice-matched composition.
        </p>
      </section>

      <section id="part4">
        <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

        <h3>Re-interpreting the formula term-by-term</h3>
        <ul>
          <li><span class="mono">xE_g(AC)+(1−x)E_g(BC)</span>: “chemical averaging” baseline (straight line).</li>
          <li><span class="mono">−b x(1−x)</span>: extra correction from non-ideal mixing (band offsets, disorder, local strain, interaction of orbitals).</li>
          <li><span class="mono">x(1−x)</span> peaks at 0.25: bowing matters most for mid-alloys.</li>
        </ul>

        <h3>How parameters affect outcomes (use the interactive plots)</h3>
        <ul>
          <li>Increase <span class="mono">b</span> → the bandgap curve dips more below the linear line (largest change near <span class="mono">x≈0.5</span>).</li>
          <li>Change substrate lattice constant <span class="mono">a_s</span> → the lattice-matched composition <span class="mono">x_match</span> shifts, changing both mismatch and the bandgap you obtain at match.</li>
          <li>For “nearly vertical” systems (e.g., AlGaAs on GaAs; HgTe–CdTe), tiny changes in <span class="mono">a</span> correspond to large composition changes—useful for tuning <span class="mono">E_g</span> without large strain.</li>
        </ul>

        <h3>Alternative derivation idea (brief)</h3>
        <p>
          Instead of the midpoint method, you can expand the bowing model as a quadratic polynomial:
          <span class="mono">E_g(x)=E_g(BC)+(E_g(AC)-E_g(BC)-b)x + b x^2</span>.
          If you digitize a few points on the curve and fit a quadratic in <span class="mono">x</span>, the coefficient of <span class="mono">x^2</span> immediately gives <span class="mono">b</span>.
        </p>

        <h3>Concept check (quick self-test)</h3>
        <ul>
          <li><b>Q:</b> Why is the bowing effect largest near <span class="mono">x=0.5</span>? <b>A:</b> Because <span class="mono">x(1−x)</span> is maximal (0.25) at 0.5.</li>
          <li><b>Q:</b> If two materials are lattice matched but have very different gaps, can you tune <span class="mono">E_g</span> without strain? <b>A:</b> Yes—composition can vary while staying near the same lattice constant (vertical line), ideal for epitaxy.</li>
          <li><b>Q:</b> Does large <span class="mono">b</span> mean poor lattice matching? <b>A:</b> Not directly; lattice matching is governed mainly by <span class="mono">a(x)</span>. Large <span class="mono">b</span> means the gap deviates strongly from linear mixing at the matching composition.</li>
          <li><b>Q:</b> What happens if you ignore bowing when designing an LED wavelength? <b>A:</b> You can miss the target wavelength substantially because the actual <span class="mono">E_g</span> at the chosen composition may be lower than predicted.</li>
        </ul>
      </section>

      <section id="part5">
        <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

        <div class="controls" role="group" aria-label="Interactive controls">
          <div class="ctrlBox">
            <label for="alloySel">Alloy system (example endpoints)</label>
            <select id="alloySel">
              <option value="AlGaAs">AlxGa1−xAs</option>
              <option value="GaAsP">GaAs1−xPx</option>
              <option value="AlGaN">AlxGa1−xN</option>
              <option value="InGaN">InxGa1−xN</option>
              <option value="AlInN">AlxIn1−xN</option>
              <option value="HgCdTe">HgxCd1−xTe</option>
            </select>
            <div class="row"><span>Uses example endpoint values for plotting</span><span class="pill">for visualization</span></div>
          </div>

          <div class="ctrlBox">
            <label for="bSlider">Bowing parameter b (eV)</label>
            <input id="bSlider" type="range" min="0" max="5" step="0.01" value="0.2"/>
            <div class="row"><span class="mono" id="bRead">b = 0.20 eV</span><span class="mono" id="bHint">mild bowing</span></div>
          </div>

          <div class="ctrlBox">
            <label for="aSub">Substrate lattice constant a<sub>s</sub> (Å)</label>
            <input id="aSub" type="range" min="3.10" max="6.60" step="0.001" value="5.653"/>
            <div class="row"><span class="mono" id="aRead">a_s = 5.653 Å</span><span class="mono" id="xRead">x_match = 0.50</span></div>
          </div>
        </div>

        <div class="grid2">
          <figure>
            <canvas id="diagram" class="canvasTall" aria-label="Epitaxy and lattice matching diagram"></canvas>
            <figcaption>
              Diagram: substrate with lattice constant <span class="mono">a<sub>s</sub></span>, epilayer alloy with <span class="mono">a(x)</span>, showing mismatch and how choosing <span class="mono">x</span> can reduce strain.
            </figcaption>
          </figure>

          <figure>
            <canvas id="plotEgX" class="canvasTall" aria-label="Main plot: Bandgap vs composition"></canvas>
            <figcaption>
              Main plot: <span class="mono">E<sub>g</sub>(x)</span> (bowed vs linear). The vertical line marks the lattice-matched composition <span class="mono">x_match</span> computed from Vegard’s law.
            </figcaption>
          </figure>
        </div>

        <div style="height:14px"></div>

        <div class="grid2">
          <figure>
            <canvas id="plotEgA" aria-label="Secondary plot: Bandgap vs lattice constant"></canvas>
            <figcaption>
              Secondary plot: <span class="mono">E<sub>g</sub></span> vs lattice constant <span class="mono">a</span> created from Vegard’s law and the bowing model.
              The vertical line indicates the substrate lattice constant <span class="mono">a_s</span>.
            </figcaption>
          </figure>

          <figure>
            <canvas id="plotMismatch" aria-label="Secondary plot: Lattice mismatch vs composition"></canvas>
            <figcaption>
              Parameter-sweep: mismatch <span class="mono">f(x) = (a(x)−a_s)/a_s</span> vs composition. Lattice matching occurs at <span class="mono">f=0</span>.
              Notice that changing <span class="mono">b</span> does <b>not</b> change this curve (only bandgap changes).
            </figcaption>
          </figure>
        </div>

        <h3>Controls explained</h3>
        <ul>
          <li><b>Alloy system</b> selects example end-member values <span class="mono">E_g(AC), E_g(BC), a(AC), a(BC)</span> consistent with typical textbook charts (used for plotting only).</li>
          <li><b>Bowing slider</b> changes <span class="mono">b</span> and updates <span class="mono">E_g(x)</span> and <span class="mono">E_g(a)</span> live (all plots update).</li>
          <li><b>Substrate lattice slider</b> changes <span class="mono">a_s</span>, shifting the lattice-matched composition <span class="mono">x_match</span> and the bandgap at match.</li>
        </ul>

        <div class="footer">
          Note: The numeric endpoint values used in the interactive plots are <b>example values</b> for visualization (the textbook chart provides the authoritative points).
          The bowing estimates in the solution table are intended as <b>engineering approximations</b> based on the curvature shown.
        </div>
      </section>
    </article>
  </main>

  <script>
    // ---------- Utilities ----------
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    function copyText(txt){
      navigator.clipboard.writeText(txt).then(()=>{}, ()=>{});
    }
    document.querySelectorAll(".copyBtn").forEach(btn=>{
      btn.addEventListener("click", ()=> copyText(btn.getAttribute("data-copy") || ""));
    });

    // High-DPI canvas setup
    function setupCanvas(canvas){
      const ctx = canvas.getContext("2d");
      function resize(){
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.max(2, Math.floor(rect.width * dpr));
        canvas.height = Math.max(2, Math.floor(rect.height * dpr));
        ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      }
      resize();
      return {ctx, resize};
    }

    function niceTicks(min, max, target=6){
      const span = max - min;
      if(span <= 0) return {step:1, ticks:[min]};
      const raw = span / target;
      const pow = Math.pow(10, Math.floor(Math.log10(raw)));
      const steps = [1,2,2.5,5,10].map(s=>s*pow);
      let step = steps[0];
      for(const s of steps){
        if(Math.abs(raw - s) < Math.abs(raw - step)) step = s;
      }
      const start = Math.floor(min/step)*step;
      const end = Math.ceil(max/step)*step;
      const ticks=[];
      for(let v=start; v<=end+0.5*step; v+=step){
        ticks.push(v);
      }
      return {step, ticks};
    }

    function drawPlotFrame(ctx, x, y, w, h, title){
      // background glow
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgba(255,255,255,0.03)";
      ctx.fillRect(x, y, w, h);
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;
      ctx.strokeRect(x+0.5, y+0.5, w-1, h-1);
      ctx.fillStyle = "rgba(232,238,247,0.90)";
      ctx.font = "600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText(title, x+10, y+18);
      ctx.restore();
    }

    function plotAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel){
      const {x,y,w,h, padL, padR, padT, padB} = box;
      const ix = x + padL, iy = y + padT, iw = w - padL - padR, ih = h - padT - padB;

      // grid + ticks
      const xt = niceTicks(xMin, xMax, 6);
      const yt = niceTicks(yMin, yMax, 5);

      ctx.save();
      ctx.beginPath();
      ctx.rect(ix, iy, iw, ih);
      ctx.clip();

      // gridlines
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.lineWidth = 1;

      for(const xv of xt.ticks){
        const t = (xv - xMin) / (xMax - xMin);
        const px = ix + t*iw;
        ctx.beginPath();
        ctx.moveTo(px, iy);
        ctx.lineTo(px, iy+ih);
        ctx.stroke();
      }
      for(const yv of yt.ticks){
        const t = (yv - yMin) / (yMax - yMin);
        const py = iy + (1-t)*ih;
        ctx.beginPath();
        ctx.moveTo(ix, py);
        ctx.lineTo(ix+iw, py);
        ctx.stroke();
      }

      ctx.restore();

      // axes border
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.lineWidth = 1;
      ctx.strokeRect(ix+0.5, iy+0.5, iw-1, ih-1);

      // tick labels
      ctx.fillStyle = "rgba(169,183,204,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      for(const xv of xt.ticks){
        const t = (xv - xMin) / (xMax - xMin);
        const px = ix + t*iw;
        ctx.fillText(formatTick(xv), px, iy+ih+6);
      }

      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      for(const yv of yt.ticks){
        const t = (yv - yMin) / (yMax - yMin);
        const py = iy + (1-t)*ih;
        ctx.fillText(formatTick(yv), ix-8, py);
      }

      // labels
      ctx.fillStyle = "rgba(232,238,247,0.90)";
      ctx.font = "600 12px ui-sans-serif, system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      ctx.fillText(xLabel, ix + iw/2, y + h - 4);

      ctx.save();
      ctx.translate(x+12, iy + ih/2);
      ctx.rotate(-Math.PI/2);
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();

      ctx.restore();

      function xToPx(v){ return ix + (v-xMin)/(xMax-xMin)*iw; }
      function yToPx(v){ return iy + (1-(v-yMin)/(yMax-yMin))*ih; }

      return {ix,iy,iw,ih,xToPx,yToPx};
    }

    function formatTick(v){
      const av = Math.abs(v);
      if(av >= 100) return v.toFixed(0);
      if(av >= 10) return v.toFixed(1);
      if(av >= 1) return v.toFixed(2);
      return v.toFixed(3);
    }

    function drawLegend(ctx, x, y, items){
      ctx.save();
      ctx.font = "12px ui-sans-serif, system-ui";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";

      let w = 0;
      for(const it of items){
        w = Math.max(w, ctx.measureText(it.label).width);
      }
      const boxW = 18 + 10 + w + 16;
      const boxH = 20 + items.length*18;
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;
      roundRect(ctx, x, y, boxW, boxH, 10, true, true);

      let yy = y + 18;
      for(const it of items){
        ctx.strokeStyle = it.stroke;
        ctx.lineWidth = it.width || 2;
        ctx.beginPath();
        ctx.moveTo(x+12, yy);
        ctx.lineTo(x+28, yy);
        ctx.stroke();

        if(it.dash){
          ctx.setLineDash(it.dash);
          ctx.beginPath();
          ctx.moveTo(x+12, yy);
          ctx.lineTo(x+28, yy);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        ctx.fillStyle = "rgba(232,238,247,0.92)";
        ctx.fillText(it.label, x+36, yy);
        yy += 18;
      }
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r, fill, stroke){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
      if(fill) ctx.fill();
      if(stroke) ctx.stroke();
    }

    // ---------- Alloy dataset (example endpoint values for plotting) ----------
    // These are typical room-temperature-ish values used solely to make the interactive plots meaningful.
    // The user's chart provides the authoritative plotted points; our analysis explains b extraction.
    const alloys = {
      AlGaAs: {
        label: "AlxGa1−xAs",
        aAC: 5.661,  EgAC: 2.16,   // AlAs (indirect; used here as endpoint for demo)
        aBC: 5.653,  EgBC: 1.42,   // GaAs
        bDefault: 0.20,
        aSubDefault: 5.653
      },
      GaAsP: {
        label: "GaAs1−xPx",
        aAC: 5.450,  EgAC: 2.26,   // GaP (indirect ~2.26)
        aBC: 5.653,  EgBC: 1.42,   // GaAs
        bDefault: 0.20,
        aSubDefault: 5.653
      },
      AlGaN: {
        label: "AlxGa1−xN",
        aAC: 3.112,  EgAC: 6.20,   // AlN
        aBC: 3.189,  EgBC: 3.40,   // GaN
        bDefault: 0.80,
        aSubDefault: 3.189
      },
      InGaN: {
        label: "InxGa1−xN",
        aAC: 3.545,  EgAC: 0.70,   // InN
        aBC: 3.189,  EgBC: 3.40,   // GaN
        bDefault: 1.40,
        aSubDefault: 3.189
      },
      AlInN: {
        label: "AlxIn1−xN",
        aAC: 3.112,  EgAC: 6.20,   // AlN
        aBC: 3.545,  EgBC: 0.70,   // InN
        bDefault: 4.00,
        aSubDefault: 3.189 // often want lattice match to GaN; keep interactive
      },
      HgCdTe: {
        label: "HgxCd1−xTe",
        aAC: 6.460,  EgAC: -0.30,  // HgTe (semi-metal; small/negative gap)
        aBC: 6.482,  EgBC: 1.50,   // CdTe
        bDefault: 0.80,
        aSubDefault: 6.482
      }
    };

    // ---------- Physics functions ----------
    function aVegard(x, aAC, aBC){ return x*aAC + (1-x)*aBC; }
    function EgBowed(x, EgAC, EgBC, b){
      return x*EgAC + (1-x)*EgBC - b*x*(1-x);
    }
    function EgLin(x, EgAC, EgBC){
      return x*EgAC + (1-x)*EgBC;
    }
    function xMatchFromSub(aS, aAC, aBC){
      const denom = (aAC - aBC);
      if(Math.abs(denom) < 1e-9) return 0.5; // nearly same lattice constant
      return (aS - aBC) / denom;
    }
    function mismatch(x, aS, aAC, aBC){
      const a = aVegard(x, aAC, aBC);
      return (a - aS) / aS;
    }

    // ---------- Canvases ----------
    const diag = setupCanvas(document.getElementById("diagram"));
    const p1 = setupCanvas(document.getElementById("plotEgX"));
    const p2 = setupCanvas(document.getElementById("plotEgA"));
    const p3 = setupCanvas(document.getElementById("plotMismatch"));

    // ---------- Controls ----------
    const alloySel = document.getElementById("alloySel");
    const bSlider = document.getElementById("bSlider");
    const aSub = document.getElementById("aSub");
    const bRead = document.getElementById("bRead");
    const bHint = document.getElementById("bHint");
    const aRead = document.getElementById("aRead");
    const xRead = document.getElementById("xRead");

    function setSubSliderBounds(aMin, aMax, value){
      aSub.min = (aMin - 0.08).toFixed(3);
      aSub.max = (aMax + 0.08).toFixed(3);
      aSub.value = clamp(value, parseFloat(aSub.min), parseFloat(aSub.max)).toFixed(3);
    }

    function setBSliderBounds(bMax, value){
      bSlider.max = bMax.toFixed(2);
      bSlider.value = clamp(value, 0, bMax).toFixed(2);
    }

    function updateControlDefaults(){
      const key = alloySel.value;
      const A = alloys[key];

      // b bounds: allow more for nitrides
      const bMax = (key === "AlInN") ? 6.0 : (key.includes("N") ? 3.5 : 2.0);
      setBSliderBounds(bMax, A.bDefault);

      // substrate range roughly around the endpoints (lets user explore mismatch)
      const aMin = Math.min(A.aAC, A.aBC);
      const aMax = Math.max(A.aAC, A.aBC);
      setSubSliderBounds(aMin, aMax, A.aSubDefault);

      renderAll();
    }

    alloySel.addEventListener("change", updateControlDefaults);
    bSlider.addEventListener("input", renderAll);
    aSub.addEventListener("input", renderAll);
    window.addEventListener("resize", ()=>{
      diag.resize(); p1.resize(); p2.resize(); p3.resize();
      renderAll();
    });

    // ---------- Drawing ----------
    function renderAll(){
      const key = alloySel.value;
      const A = alloys[key];

      const b = parseFloat(bSlider.value);
      const aS = parseFloat(aSub.value);

      bRead.textContent = `b = ${b.toFixed(2)} eV`;
      bHint.textContent = (b < 0.35) ? "mild bowing" : (b < 1.5 ? "moderate bowing" : "strong bowing");

      aRead.innerHTML = `a_s = ${aS.toFixed(3)} Å`;

      let xm = xMatchFromSub(aS, A.aAC, A.aBC);
      xm = clamp(xm, 0, 1);
      xRead.textContent = `x_match = ${xm.toFixed(2)}`;

      drawDiagram(diag.ctx, A, b, aS, xm);
      drawEgVsX(p1.ctx, A, b, aS, xm);
      drawEgVsA(p2.ctx, A, b, aS, xm);
      drawMismatch(p3.ctx, A, b, aS, xm);
    }

    function clear(ctx, canvas){
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    function drawDiagram(ctx, A, b, aS, xm){
      const canvas = ctx.canvas;
      const W = canvas.getBoundingClientRect().width;
      const H = canvas.getBoundingClientRect().height;

      // clear
      ctx.clearRect(0,0,W,H);

      // title area
      drawPlotFrame(ctx, 0, 0, W, H, "Epitaxy picture: substrate + alloy layer");

      // draw substrate block
      const pad = 14;
      const x0 = pad, y0 = 34;
      const w = W - 2*pad, h = H - y0 - pad;

      // substrate and epilayer regions
      const subH = h*0.55;
      const epiH = h - subH;

      // substrate
      ctx.save();
      ctx.fillStyle = "rgba(125,211,252,0.10)";
      ctx.strokeStyle = "rgba(125,211,252,0.35)";
      ctx.lineWidth = 1;
      roundRect(ctx, x0, y0+epiH, w, subH, 14, true, true);

      // epilayer
      ctx.fillStyle = "rgba(167,139,250,0.10)";
      ctx.strokeStyle = "rgba(167,139,250,0.35)";
      roundRect(ctx, x0, y0, w, epiH, 14, true, true);

      // lattice lines (substrate)
      const nLines = 14;
      const aEpi = aVegard(xm, A.aAC, A.aBC);
      // represent spacing visually (relative)
      const sSub = 10;
      const sEpi = sSub * (aEpi/aS);
      // draw lines
      ctx.beginPath();
      ctx.rect(x0+10, y0+epiH+10, w-20, subH-20);
      ctx.clip();
      ctx.strokeStyle = "rgba(232,238,247,0.35)";
      ctx.lineWidth = 1;
      for(let i=0;i<nLines;i++){
        const yy = y0+epiH+16 + i*sSub;
        ctx.beginPath();
        ctx.moveTo(x0+14, yy);
        ctx.lineTo(x0+w-14, yy);
        ctx.stroke();
      }
      ctx.restore();

      // lattice lines (epilayer)
      ctx.save();
      ctx.beginPath();
      ctx.rect(x0+10, y0+10, w-20, epiH-20);
      ctx.clip();
      ctx.strokeStyle = "rgba(232,238,247,0.30)";
      ctx.lineWidth = 1;
      for(let i=0;i<nLines;i++){
        const yy = y0+16 + i*sEpi;
        ctx.beginPath();
        ctx.moveTo(x0+14, yy);
        ctx.lineTo(x0+w-14, yy);
        ctx.stroke();
      }
      ctx.restore();

      // labels
      ctx.save();
      ctx.fillStyle = "rgba(232,238,247,0.92)";
      ctx.font = "600 12px ui-sans-serif, system-ui";
      ctx.fillText("Epilayer (alloy)", x0+14, y0+20);
      ctx.fillText("Substrate", x0+14, y0+epiH+20);

      ctx.fillStyle = "rgba(169,183,204,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas";
      ctx.fillText(`a_s = ${aS.toFixed(3)} Å`, x0+14, y0+epiH+40);
      ctx.fillText(`a(x_match) = ${aEpi.toFixed(3)} Å`, x0+14, y0+40);

      const EgM = EgBowed(xm, A.EgAC, A.EgBC, b);
      ctx.fillText(`x_match = ${xm.toFixed(2)}`, x0+14, y0+60);
      ctx.fillText(`E_g(x_match) = ${EgM.toFixed(2)} eV`, x0+14, y0+80);

      // mismatch arrow
      const f = (aEpi - aS)/aS;
      const arrowX = x0 + w - 34;
      const arrowY1 = y0 + epiH - 10;
      const arrowY2 = y0 + epiH + 10;

      ctx.strokeStyle = (Math.abs(f) < 0.001) ? "rgba(52,211,153,0.90)" : "rgba(251,191,36,0.90)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(arrowX, arrowY1);
      ctx.lineTo(arrowX, arrowY2);
      ctx.stroke();
      // arrow heads
      ctx.beginPath();
      ctx.moveTo(arrowX-6, arrowY1+6);
      ctx.lineTo(arrowX, arrowY1);
      ctx.lineTo(arrowX+6, arrowY1+6);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(arrowX-6, arrowY2-6);
      ctx.lineTo(arrowX, arrowY2);
      ctx.lineTo(arrowX+6, arrowY2-6);
      ctx.stroke();

      ctx.fillStyle = "rgba(232,238,247,0.90)";
      ctx.font = "600 12px ui-sans-serif, system-ui";
      ctx.textAlign = "right";
      ctx.fillText("interface", arrowX-10, y0+epiH+4);

      ctx.fillStyle = "rgba(169,183,204,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas";
      ctx.fillText(`mismatch f = ${(100*f).toFixed(2)}%`, x0+w-14, y0+epiH+28);

      ctx.restore();
    }

    function drawEgVsX(ctx, A, b, aS, xm){
      const canvas = ctx.canvas;
      const W = canvas.getBoundingClientRect().width;
      const H = canvas.getBoundingClientRect().height;
      ctx.clearRect(0,0,W,H);

      drawPlotFrame(ctx, 0, 0, W, H, "Bandgap vs composition x (bowed vs linear)");

      const box = {x:10,y:28,w:W-20,h:H-38, padL:54,padR:18,padT:18,padB:44};

      // compute y range
      let yMin = Math.min(A.EgAC, A.EgBC) - 0.4;
      let yMax = Math.max(A.EgAC, A.EgBC) + 0.4;
      // ensure includes bowed minimum
      for(let i=0;i<=200;i++){
        const x = i/200;
        const Eg = EgBowed(x, A.EgAC, A.EgBC, b);
        yMin = Math.min(yMin, Eg);
        yMax = Math.max(yMax, Eg);
      }
      yMin = Math.max(-1.0, yMin);

      const axes = plotAxes(ctx, box, 0, 1, yMin, yMax, "composition x (fraction of AC)", "E_g (eV)");

      // plot linear
      ctx.save();
      ctx.strokeStyle = "rgba(125,211,252,0.95)";
      ctx.lineWidth = 2;
      ctx.setLineDash([6,4]);
      ctx.beginPath();
      for(let i=0;i<=300;i++){
        const x = i/300;
        const Eg = EgLin(x, A.EgAC, A.EgBC);
        const px = axes.xToPx(x), py = axes.yToPx(Eg);
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.setLineDash([]);

      // plot bowed
      ctx.strokeStyle = "rgba(167,139,250,0.95)";
      ctx.lineWidth = 2.6;
      ctx.beginPath();
      for(let i=0;i<=300;i++){
        const x = i/300;
        const Eg = EgBowed(x, A.EgAC, A.EgBC, b);
        const px = axes.xToPx(x), py = axes.yToPx(Eg);
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();

      // vertical x_match line
      ctx.strokeStyle = "rgba(52,211,153,0.95)";
      ctx.lineWidth = 2;
      const xpx = axes.xToPx(xm);
      ctx.beginPath();
      ctx.moveTo(xpx, axes.iy);
      ctx.lineTo(xpx, axes.iy + axes.ih);
      ctx.stroke();

      // mark points
      const EgM = EgBowed(xm, A.EgAC, A.EgBC, b);
      ctx.fillStyle = "rgba(52,211,153,1)";
      ctx.beginPath();
      ctx.arc(xpx, axes.yToPx(EgM), 4.5, 0, Math.PI*2);
      ctx.fill();

      // annotate Eg at match
      ctx.fillStyle = "rgba(232,238,247,0.92)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas";
      ctx.textAlign = "left";
      ctx.textBaseline = "bottom";
      const label = `E_g(x_match)=${EgM.toFixed(2)} eV`;
      ctx.fillText(label, clamp(xpx+8, axes.ix+4, axes.ix+axes.iw-120), clamp(axes.yToPx(EgM)-8, axes.iy+14, axes.iy+axes.ih-6));

      drawLegend(ctx, axes.ix + 10, axes.iy + 10, [
        {label:"linear (b=0)", stroke:"rgba(125,211,252,0.95)", dash:[6,4], width:2},
        {label:"bowed model", stroke:"rgba(167,139,250,0.95)", width:2.6},
        {label:"x_match (Vegard)", stroke:"rgba(52,211,153,0.95)", width:2}
      ]);

      ctx.restore();
    }

    function drawEgVsA(ctx, A, b, aS, xm){
      const canvas = ctx.canvas;
      const W = canvas.getBoundingClientRect().width;
      const H = canvas.getBoundingClientRect().height;
      ctx.clearRect(0,0,W,H);

      drawPlotFrame(ctx, 0, 0, W, H, "Bandgap vs lattice constant a (Vegard map)");

      const box = {x:10,y:28,w:W-20,h:H-38, padL:58,padR:18,padT:18,padB:44};

      const aMin = Math.min(A.aAC, A.aBC) - 0.03;
      const aMax = Math.max(A.aAC, A.aBC) + 0.03;

      // y range
      let yMin = Math.min(A.EgAC, A.EgBC) - 0.4;
      let yMax = Math.max(A.EgAC, A.EgBC) + 0.4;
      for(let i=0;i<=200;i++){
        const x = i/200;
        const Eg = EgBowed(x, A.EgAC, A.EgBC, b);
        yMin = Math.min(yMin, Eg);
        yMax = Math.max(yMax, Eg);
      }
      yMin = Math.max(-1.0, yMin);

      const axes = plotAxes(ctx, box, aMin, aMax, yMin, yMax, "lattice constant a (Å)", "E_g (eV)");

      // draw curve parameterized by x
      ctx.save();
      ctx.strokeStyle = "rgba(167,139,250,0.95)";
      ctx.lineWidth = 2.6;
      ctx.beginPath();
      for(let i=0;i<=350;i++){
        const x = i/350;
        const a = aVegard(x, A.aAC, A.aBC);
        const Eg = EgBowed(x, A.EgAC, A.EgBC, b);
        const px = axes.xToPx(a), py = axes.yToPx(Eg);
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();

      // linear line in a-space (since a(x) linear, mapping keeps curve if b=0 as a straight line between endpoints)
      ctx.strokeStyle = "rgba(125,211,252,0.95)";
      ctx.lineWidth = 2;
      ctx.setLineDash([6,4]);
      ctx.beginPath();
      // endpoints in (a,Eg)
      const pA = {a:A.aAC, Eg:A.EgAC};
      const pB = {a:A.aBC, Eg:A.EgBC};
      ctx.moveTo(axes.xToPx(pB.a), axes.yToPx(pB.Eg));
      ctx.lineTo(axes.xToPx(pA.a), axes.yToPx(pA.Eg));
      ctx.stroke();
      ctx.setLineDash([]);

      // substrate vertical line
      ctx.strokeStyle = "rgba(52,211,153,0.95)";
      ctx.lineWidth = 2;
      const ax = axes.xToPx(aS);
      ctx.beginPath();
      ctx.moveTo(ax, axes.iy);
      ctx.lineTo(ax, axes.iy + axes.ih);
      ctx.stroke();

      // mark lattice-matched point
      const aM = aVegard(xm, A.aAC, A.aBC);
      const EgM = EgBowed(xm, A.EgAC, A.EgBC, b);
      ctx.fillStyle = "rgba(52,211,153,1)";
      ctx.beginPath();
      ctx.arc(axes.xToPx(aM), axes.yToPx(EgM), 4.5, 0, Math.PI*2);
      ctx.fill();

      // annotate
      ctx.fillStyle = "rgba(232,238,247,0.92)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas";
      ctx.textAlign = "left";
      ctx.textBaseline = "bottom";
      const label = `at match: a=${aM.toFixed(3)} Å, E_g=${EgM.toFixed(2)} eV`;
      ctx.fillText(label, clamp(axes.xToPx(aM)+8, axes.ix+6, axes.ix+axes.iw-240), clamp(axes.yToPx(EgM)-8, axes.iy+14, axes.iy+axes.ih-6));

      drawLegend(ctx, axes.ix + 10, axes.iy + 10, [
        {label:"b=0 line", stroke:"rgba(125,211,252,0.95)", dash:[6,4], width:2},
        {label:"bowed E_g(a)", stroke:"rgba(167,139,250,0.95)", width:2.6},
        {label:"substrate a_s", stroke:"rgba(52,211,153,0.95)", width:2}
      ]);

      ctx.restore();
    }

    function drawMismatch(ctx, A, b, aS, xm){
      const canvas = ctx.canvas;
      const W = canvas.getBoundingClientRect().width;
      const H = canvas.getBoundingClientRect().height;
      ctx.clearRect(0,0,W,H);

      drawPlotFrame(ctx, 0, 0, W, H, "Lattice mismatch vs composition (Vegard)");

      const box = {x:10,y:28,w:W-20,h:H-38, padL:62,padR:18,padT:18,padB:44};

      // mismatch range
      let fMin =  1e9;
      let fMax = -1e9;
      for(let i=0;i<=200;i++){
        const x = i/200;
        const f = mismatch(x, aS, A.aAC, A.aBC);
        fMin = Math.min(fMin, f);
        fMax = Math.max(fMax, f);
      }
      const pad = 0.002;
      fMin -= pad; fMax += pad;
      // ensure includes 0
      fMin = Math.min(fMin, -0.01);
      fMax = Math.max(fMax,  0.01);

      const axes = plotAxes(ctx, box, 0, 1, fMin, fMax, "composition x (fraction of AC)", "mismatch f (dimensionless)");

      ctx.save();
      // f=0 line
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 1.5;
      ctx.setLineDash([4,4]);
      ctx.beginPath();
      const y0 = axes.yToPx(0);
      ctx.moveTo(axes.ix, y0);
      ctx.lineTo(axes.ix+axes.iw, y0);
      ctx.stroke();
      ctx.setLineDash([]);

      // mismatch curve
      ctx.strokeStyle = "rgba(125,211,252,0.95)";
      ctx.lineWidth = 2.6;
      ctx.beginPath();
      for(let i=0;i<=300;i++){
        const x = i/300;
        const f = mismatch(x, aS, A.aAC, A.aBC);
        const px = axes.xToPx(x), py = axes.yToPx(f);
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();

      // mark match
      const fxm = mismatch(xm, aS, A.aAC, A.aBC);
      const pxm = axes.xToPx(xm), pym = axes.yToPx(fxm);
      ctx.fillStyle = "rgba(52,211,153,1)";
      ctx.beginPath();
      ctx.arc(pxm, pym, 4.5, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "rgba(232,238,247,0.92)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas";
      ctx.textAlign = "left";
      ctx.textBaseline = "bottom";
      ctx.fillText(`f(x_match)=${(100*fxm).toFixed(2)}%`, clamp(pxm+8, axes.ix+6, axes.ix+axes.iw-120), clamp(pym-8, axes.iy+14, axes.iy+axes.ih-6));

      drawLegend(ctx, axes.ix + 10, axes.iy + 10, [
        {label:"mismatch f(x)", stroke:"rgba(125,211,252,0.95)", width:2.6},
        {label:"f=0 (match)", stroke:"rgba(255,255,255,0.25)", dash:[4,4], width:1.5}
      ]);

      ctx.restore();
    }

    // Initialize defaults
    updateControlDefaults();
  </script>
</body>
</html>
