<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Statistics of Cathodoluminescence Light — Neyman Type-A (Compound Poisson) Model</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:rgba(255,255,255,0.06);
      --panel2:rgba(255,255,255,0.085);
      --text:rgba(255,255,255,0.92);
      --muted:rgba(255,255,255,0.72);
      --faint:rgba(255,255,255,0.55);
      --accent:#86e1ff;
      --accent2:#b4ffb1;
      --warn:#ffd37a;
      --danger:#ff8fa3;
      --border:rgba(255,255,255,0.12);
      --shadow: 0 18px 55px rgba(0,0,0,0.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(134,225,255,0.14), transparent 60%),
        radial-gradient(900px 600px at 80% 20%, rgba(180,255,177,0.12), transparent 65%),
        radial-gradient(1200px 800px at 50% 90%, rgba(255,211,122,0.10), transparent 65%),
        linear-gradient(180deg, #070a14, #0b1020 55%, #060911);
      overflow-x:hidden;
    }

    header{
      padding: clamp(18px, 3vw, 28px) clamp(16px, 4vw, 44px);
      border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.055), rgba(255,255,255,0.02));
      position:relative;
    }
    header h1{
      margin:0 0 6px 0;
      font-size: clamp(22px, 3.2vw, 34px);
      letter-spacing: -0.02em;
    }
    header p{
      margin:0;
      color:var(--muted);
      max-width: 80ch;
      line-height:1.45;
    }

    main{
      display:grid;
      grid-template-columns: 1fr;
      gap: 18px;
      padding: 18px clamp(16px, 4vw, 44px) 44px;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* Sticky TOC layout for wide screens */
    .layout{
      display:grid;
      grid-template-columns: 280px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns: 1fr;}
    }

    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
      backdrop-filter: blur(10px);
    }
    nav.toc h2{
      margin:0 0 10px 0;
      font-size: 14px;
      color: var(--muted);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }
    nav.toc a{
      display:block;
      padding: 8px 10px;
      margin: 4px 0;
      border-radius: 12px;
      text-decoration:none;
      color: var(--text);
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size: 14px;
      line-height: 1.25;
    }
    nav.toc a:hover{
      background: var(--panel2);
      border-color: rgba(134,225,255,0.35);
      transform: translateY(-1px);
    }
    nav.toc .hint{
      margin-top:10px;
      font-size:12px;
      color:var(--faint);
      line-height:1.35;
    }

    section, article{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: 18px;
      padding: clamp(14px, 2.3vw, 22px);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    section h2, article h2{
      margin:0 0 12px 0;
      font-size: clamp(18px, 2.3vw, 24px);
      letter-spacing:-0.015em;
    }
    section h3, article h3{
      margin:18px 0 10px;
      font-size: 16px;
      color: var(--accent);
      letter-spacing:-0.01em;
    }
    p{color:var(--text); line-height:1.6; margin:10px 0}
    ul{margin:10px 0 10px 22px; color:var(--text)}
    li{margin:7px 0; line-height:1.5}
    .muted{color:var(--muted)}
    .small{font-size: 13px; color:var(--muted)}
    .hr{
      height:1px; background:var(--border); margin:16px 0;
    }

    .grid2{display:grid; grid-template-columns: 1fr 1fr; gap: 14px;}
    @media (max-width: 860px){ .grid2{grid-template-columns: 1fr;} }

    .callout{
      border:1px solid var(--border);
      border-radius: 16px;
      padding: 12px 12px 10px;
      background: rgba(255,255,255,0.04);
    }
    .callout strong{color:var(--accent)}
    .callout.warn strong{color:var(--warn)}
    .callout.danger strong{color:var(--danger)}
    .callout.ok strong{color:var(--accent2)}

    .eqwrap{
      margin: 12px 0;
      padding: 12px 12px 10px;
      border-radius: 16px;
      border: 1px solid rgba(134,225,255,0.28);
      background: rgba(134,225,255,0.06);
      position:relative;
      overflow:hidden;
    }
    .eqtitle{
      display:flex;
      align-items:center;
      gap:10px;
      justify-content:space-between;
      margin-bottom:8px;
    }
    .eqtitle span{
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .eq{
      font-family: var(--mono);
      white-space: pre-wrap;
      word-break: break-word;
      font-size: 14px;
      line-height:1.45;
      color: rgba(255,255,255,0.95);
      margin:0;
    }
    .copyBtn{
      appearance:none;
      border:1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 7px 10px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size: 12px;
      letter-spacing: 0.02em;
    }
    .copyBtn:hover{
      background: rgba(255,255,255,0.09);
      border-color: rgba(134,225,255,0.35);
      transform: translateY(-1px);
    }
    .copyStatus{
      font-size: 12px;
      color: var(--muted);
      margin-left: 10px;
    }

    figure{
      margin:0;
      display:grid;
      gap:10px;
    }
    canvas{
      width:100%;
      height: 320px;
      border-radius: 16px;
      border:1px solid var(--border);
      background: rgba(0,0,0,0.22);
    }
    .canvasTall{height: 360px;}
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap: 12px 16px;
      align-items:center;
      margin-top:10px;
      padding: 10px 10px 6px;
      border: 1px solid var(--border);
      border-radius: 16px;
      background: rgba(255,255,255,0.035);
    }
    .control{
      min-width: 210px;
      flex: 1 1 240px;
    }
    label{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    input[type="range"]{width:100%}
    .pill{
      font-family: var(--mono);
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.05);
      color: var(--text);
    }

    footer{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 clamp(16px, 4vw, 44px) 30px;
      color: var(--faint);
      font-size: 12px;
      line-height:1.5;
    }

    /* Subtle entrance */
    @media (prefers-reduced-motion: no-preference){
      section, article, nav.toc{
        animation: pop .5s ease both;
      }
      @keyframes pop{
        from{transform: translateY(6px); opacity:0}
        to{transform: translateY(0); opacity:1}
      }
    }

    /* Print-friendly */
    @media print{
      body{background:#fff; color:#000}
      header, section, article, nav.toc{box-shadow:none; background:#fff; border:1px solid #ccc}
      nav.toc{position:static}
      canvas{display:none}
      .controls{display:none}
      .copyBtn{display:none}
      .eqwrap{background:#f3f6ff}
    }
  </style>
</head>
<body>
  <header>
    <h1>Statistics of Cathodoluminescence Light (Neyman Type-A / Compound Poisson)</h1>
    <p>
      A CRT phosphor converts a random number of incident electrons into a random number of emitted photons.
      Modeling both stages as Poisson processes leads to a <em>compound Poisson</em> distribution (Neyman Type-A),
      with a mean and variance that reveal why the light is typically <strong>super-Poissonian</strong>.
    </p>
  </header>

  <main>
    <div class="layout">
      <nav class="toc" aria-label="Table of contents">
        <h2>Contents</h2>
        <a href="#quick">Quick Summary</a>
        <a href="#part0">PART 0 — Concept Primer</a>
        <a href="#part1">PART 1 — Problem Analysis</a>
        <a href="#part2">PART 2 — Strategy &amp; Tips</a>
        <a href="#part3">PART 3 — Full Solution</a>
        <a href="#part4">PART 4 — Deeper Understanding</a>
        <a href="#part5">PART 5 — Visualization Guide</a>
        <div class="hint">Tip: click a section to scroll. Use the sliders to see how the mean, variance, and Fano factor change.</div>
      </nav>

      <div>
        <section id="quick">
          <h2>Quick Summary</h2>
          <ul>
            <li><strong>What this is:</strong> statistics of photons from a phosphor hit by a beam of electrons in a fixed time window.</li>
            <li><strong>Key physics idea:</strong> two-stage randomness: (1) random electrons arrive, (2) each electron produces a random photon count.</li>
            <li><strong>Models used:</strong> electron arrivals <span class="pill">K ~ Poisson(m)</span>; photons per electron <span class="pill">X ~ Poisson(G)</span>.</li>
            <li><strong>Governing tool:</strong> conditional probability and the laws of total expectation/variance.</li>
            <li><strong>Distribution:</strong> total photons <span class="pill">N = Σᵢ Xᵢ</span> is a <em>Neyman Type-A</em> (compound Poisson) distribution.</li>
            <li><strong>Mean (symbolic):</strong> <span class="pill">⟨N⟩ = mG</span>.</li>
            <li><strong>Variance (symbolic):</strong> <span class="pill">Var(N) = m(G + G²) = mG(1+G)</span> (super-Poisson unless G→0).</li>
            <li><strong>Key diagnostic:</strong> Fano factor <span class="pill">F = Var(N)/⟨N⟩ = 1 + G</span>.</li>
          </ul>
        </section>

        <article id="part0">
          <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

          <h3>Core definitions (symbols &amp; units)</h3>
          <ul>
            <li><strong>m</strong> — mean number of electrons striking the phosphor in the chosen time window (dimensionless count).</li>
            <li><strong>K</strong> — random number of electrons in that window, modeled as <span class="pill">Poisson(m)</span>.</li>
            <li><strong>G</strong> — mean number of photons emitted per electron (dimensionless count per electron).</li>
            <li><strong>X</strong> — random photons produced by a single electron, modeled as <span class="pill">Poisson(G)</span>.</li>
            <li><strong>N</strong> — total number of emitted photons in the time window (dimensionless count).</li>
          </ul>

          <h3>Physical meaning</h3>
          <p>
            In a CRT phosphor, the electron beam current is not perfectly smooth at the microscopic level:
            individual electrons arrive discretely and randomly. Each arriving electron deposits energy into the phosphor,
            causing a random number of radiative events (photon emissions). The measured light over a short time window is therefore
            a <strong>sum of random contributions</strong>, one per electron.
          </p>

          <h3>Key principles and when they are valid</h3>
          <div class="grid2">
            <div class="callout ok">
              <strong>Poisson arrivals</strong>
              <p class="muted">
                If electrons arrive independently with a constant mean rate and the probability of two arrivals in an infinitesimal interval is negligible,
                then counts in a fixed time follow a Poisson distribution.
              </p>
            </div>
            <div class="callout ok">
              <strong>Independent emission per electron</strong>
              <p class="muted">
                Modeling photons per electron as Poisson assumes many independent microscopic emission opportunities per electron and no strong saturation.
                Each electron’s photon yield is i.i.d. with mean <span class="pill">G</span>.
              </p>
            </div>
          </div>

          <h3>Common models/approximations (why we use them)</h3>
          <ul>
            <li><strong>Compound Poisson model:</strong> total output is a random sum of i.i.d. “jumps.” Here, each electron contributes a random photon count.</li>
            <li><strong>Independence:</strong> simplifies the sum; without it, correlations could change the variance dramatically.</li>
            <li><strong>Stationarity:</strong> assumes m and G are constant over the chosen time window.</li>
          </ul>

          <h3>Mini intuition examples</h3>
          <ul>
            <li><strong>One-stage Poisson:</strong> if electrons directly were counted, and K ~ Poisson(m), then Var(K)=m.</li>
            <li><strong>Two-stage amplification:</strong> if each electron produces on average G photons, fluctuations in K get “multiplied,” and additional fluctuations come from photon production per electron. That typically makes the light noisier than Poisson (super-Poisson).</li>
          </ul>

          <div class="callout warn">
            <strong>What to watch for</strong>
            <ul class="muted">
              <li>Don’t confuse the electron-count random variable <span class="pill">K</span> with its mean <span class="pill">m</span>.</li>
              <li>Conditional distributions matter: <span class="pill">N|K</span> is simpler than <span class="pill">N</span> directly.</li>
              <li>Variance is <em>not</em> just “mean × gain”: you must add an extra term from electron-count fluctuations.</li>
            </ul>
          </div>
        </article>

        <article id="part1">
          <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

          <h3>Problem restatement (in plain words)</h3>
          <p>
            In a fixed time interval, a random number of electrons hit a CRT phosphor. The electron count is Poisson with mean <span class="pill">m</span>.
            Each electron independently produces a random number of emitted photons, also Poisson, with mean <span class="pill">G</span> photons/electron.
            Find the resulting probability distribution <span class="pill">p(n)=P(N=n)</span> for the total photon count, and derive formulas for the mean
            and variance of <span class="pill">N</span>.
          </p>

          <h3>Given quantities</h3>
          <ul>
            <li><span class="pill">K ~ Poisson(m)</span></li>
            <li>Given one electron: <span class="pill">X ~ Poisson(G)</span></li>
            <li>Electrons and photon yields are independent; photon yields are i.i.d. across electrons.</li>
          </ul>

          <h3>Unknowns</h3>
          <ul>
            <li>The full distribution <span class="pill">p(n)</span> for total photons <span class="pill">N</span>.</li>
            <li>The mean <span class="pill">⟨N⟩</span>.</li>
            <li>The variance <span class="pill">σ_N² = Var(N)</span>.</li>
          </ul>

          <h3>Relevant principles (and why)</h3>
          <ul>
            <li><strong>Conditional probability:</strong> compute <span class="pill">P(N=n)</span> by conditioning on the electron count <span class="pill">K</span>, because <span class="pill">N|K</span> becomes a standard Poisson sum.</li>
            <li><strong>Law of total expectation:</strong> <span class="pill">E[N] = E[ E[N|K] ]</span>.</li>
            <li><strong>Law of total variance:</strong> <span class="pill">Var(N) = E[Var(N|K)] + Var(E[N|K])</span>.</li>
          </ul>

          <div class="callout">
            <strong>Assumptions (explicit)</strong>
            <ul class="muted">
              <li>Electron arrivals form a Poisson process (independent increments, stationary rate).</li>
              <li>Each electron’s photon yield is independent of other electrons and of K.</li>
              <li>Photon yield per electron is Poisson with constant mean G (no saturation, no memory effects in the window).</li>
            </ul>
          </div>

          <h3>Possible approaches (compare &amp; choose)</h3>
          <ul>
            <li><strong>Approach A — Conditioning on K (recommended):</strong> simple, uses standard identities; directly matches the hint.</li>
            <li><strong>Approach B — Probability generating function (PGF):</strong> elegant closed form for the distribution and moments; slightly more abstract.</li>
            <li><strong>Approach C — Moment generating function / cumulants:</strong> compact for mean/variance; similar to PGF.</li>
          </ul>
          <p>
            We’ll use <strong>Approach A</strong> (conditional probability) to keep the physics intuition front and center, and we’ll optionally connect to the PGF
            to name the Neyman Type-A distribution cleanly.
          </p>
        </article>

        <article id="part2">
          <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>

          <ol>
            <li>
              <strong>Define the random variables</strong> (<span class="pill">K, X, N</span>) and independence.
              <span class="small">Tool: model setup. Physical meaning: two-stage randomness.</span>
            </li>
            <li>
              <strong>Condition on K=k</strong> to write <span class="pill">N = Σᵢ Xᵢ</span> with k terms.
              <span class="small">Tool: conditional probability. Meaning: fix electron count, only photon yield fluctuates.</span>
            </li>
            <li>
              <strong>Use “sum of Poissons is Poisson”</strong> to identify <span class="pill">N|K=k ~ Poisson(kG)</span>.
              <span class="small">Tool: Poisson additivity. Meaning: photon counts add linearly for fixed k.</span>
            </li>
            <li>
              <strong>Uncondition to get p(n)</strong> via <span class="pill">P(N=n)=Σ_k P(N=n|K=k)P(K=k)</span>.
              <span class="small">Tool: total probability. Meaning: mixture over possible electron counts.</span>
            </li>
            <li>
              <strong>Compute the mean</strong> using <span class="pill">E[N]=E[E[N|K]]</span>.
              <span class="small">Tool: total expectation. Meaning: average photons = average electrons × photons/electron.</span>
            </li>
            <li>
              <strong>Compute the variance</strong> using <span class="pill">Var(N)=E[Var(N|K)] + Var(E[N|K])</span>.
              <span class="small">Tool: total variance. Meaning: “internal” photon noise + “external” electron-count noise.</span>
            </li>
            <li>
              <strong>Sanity checks</strong>: units, limiting cases (e.g., G→0, m→0).
              <span class="small">Meaning: confirm physical reasonableness.</span>
            </li>
          </ol>

          <div class="callout danger">
            <strong>Common mistakes</strong>
            <ul class="muted">
              <li>Forgetting the second term in total variance: <span class="pill">Var(E[N|K])</span>.</li>
              <li>Mixing up “mean gain” G with a deterministic multiplier (it’s random per electron here).</li>
              <li>Assuming the output must be Poisson just because both stages are Poisson (a Poisson mixture is generally not Poisson).</li>
            </ul>
          </div>
        </article>

        <article id="part3">
          <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

          <h3>Physical intuition (before equations)</h3>
          <p>
            If exactly <span class="pill">k</span> electrons hit the phosphor, we’d expect about <span class="pill">kG</span> photons on average, with Poisson-like spread
            from the emission process. But the number of electrons itself fluctuates (Poisson with mean <span class="pill">m</span>), so sometimes more electrons arrive and produce
            many more photons. That extra “input” fluctuation adds variance beyond simple Poisson photon statistics. So we expect:
            <strong>mean scales like mG</strong>, and <strong>variance exceeds the mean</strong>.
          </p>

          <div class="hr"></div>

          <h3>Step 1 — Define variables and conditional structure</h3>
          <p>
            Let <span class="pill">K</span> be the random number of electrons arriving in the fixed time interval.
            The problem states:
          </p>

          <div class="eqwrap" data-copy="K ~ Poisson(m),  P(K=k)=e^{-m} m^k/k!,  k=0,1,2,...">
            <div class="eqtitle">
              <span>Model: electron arrivals</span>
              <div>
                <button class="copyBtn" type="button">Copy</button>
                <span class="copyStatus"></span>
              </div>
            </div>
            <pre class="eq">K ~ Poisson(m)
P(K=k) = e^{-m} m^k / k!,   k = 0,1,2,...</pre>
          </div>

          <p>
            For each electron <span class="pill">i</span>, let <span class="pill">X_i</span> be the number of photons emitted due to that electron.
            The yield per electron is:
          </p>

          <div class="eqwrap" data-copy="X_i ~ Poisson(G),  P(X_i=x)=e^{-G} G^x/x!,  x=0,1,2,...  (i.i.d. across electrons)">
            <div class="eqtitle">
              <span>Model: photons per electron</span>
              <div>
                <button class="copyBtn" type="button">Copy</button>
                <span class="copyStatus"></span>
              </div>
            </div>
            <pre class="eq">X_i ~ Poisson(G)
P(X_i=x) = e^{-G} G^x / x!,   x = 0,1,2,...
(X_i i.i.d. and independent of K)</pre>
          </div>

          <p>
            The total photons in the interval is the random sum:
          </p>
          <div class="eqwrap" data-copy="N = sum_{i=1}^{K} X_i  (with the convention that if K=0 then N=0)">
            <div class="eqtitle">
              <span>Total photons</span>
              <div>
                <button class="copyBtn" type="button">Copy</button>
                <span class="copyStatus"></span>
              </div>
            </div>
            <pre class="eq">N = Σ_{i=1}^{K} X_i
(with N=0 when K=0)</pre>
          </div>

          <h3>Step 2 — Find the conditional distribution N | K = k</h3>
          <p>
            Condition on <span class="pill">K=k</span>. Then <span class="pill">N</span> is a sum of exactly <span class="pill">k</span> i.i.d. Poisson random variables:
            <span class="pill">N|K=k = X_1 + ... + X_k</span>.
          </p>
          <p>
            A key property: the sum of independent Poisson variables is Poisson with mean equal to the sum of means. Each <span class="pill">X_i</span> has mean <span class="pill">G</span>,
            so the conditional mean is <span class="pill">kG</span>. Therefore:
          </p>

          <div class="eqwrap" data-copy="N | (K=k) ~ Poisson(kG),  P(N=n|K=k)=e^{-kG} (kG)^n/n!">
            <div class="eqtitle">
              <span>Conditional distribution</span>
              <div>
                <button class="copyBtn" type="button">Copy</button>
                <span class="copyStatus"></span>
              </div>
            </div>
            <pre class="eq">N | (K=k) ~ Poisson(kG)
P(N=n | K=k) = e^{-kG} (kG)^n / n!,   n=0,1,2,...</pre>
          </div>

          <p class="muted">
            What we did: fixed the number of electrons. Then only the photon production fluctuates, and Poisson additivity makes the result immediate.
          </p>

          <h3>Step 3 — Uncondition to obtain the overall distribution p(n)</h3>
          <p>
            Use the law of total probability:
          </p>

          <div class="eqwrap" data-copy="p(n)=P(N=n)=sum_{k=0}^∞ P(N=n|K=k) P(K=k)">
            <div class="eqtitle">
              <span>Total probability (mixture over k)</span>
              <div>
                <button class="copyBtn" type="button">Copy</button>
                <span class="copyStatus"></span>
              </div>
            </div>
            <pre class="eq">p(n) = P(N=n) = Σ_{k=0}^{∞} P(N=n | K=k) P(K=k)</pre>
          </div>

          <p>
            Substitute the two pieces:
          </p>
          <ul>
            <li><span class="pill">P(K=k)=e^{-m} m^k/k!</span></li>
            <li><span class="pill">P(N=n|K=k)=e^{-kG} (kG)^n/n!</span></li>
          </ul>

          <div class="eqwrap" data-copy="p(n)= e^{-m} * (1/n!) * sum_{k=0}^∞ [ (m^k/k!) e^{-kG} (kG)^n ]">
            <div class="eqtitle">
              <span>Neyman Type-A (explicit series form)</span>
              <div>
                <button class="copyBtn" type="button">Copy</button>
                <span class="copyStatus"></span>
              </div>
            </div>
            <pre class="eq">p(n) = e^{-m} Σ_{k=0}^{∞} ( e^{-kG} (kG)^n / n! ) ( m^k / k! )

     = e^{-m} (1/n!) Σ_{k=0}^{∞} [ (m^k/k!) e^{-kG} (kG)^n ],   n=0,1,2,...</pre>
          </div>

          <p class="muted">
            This is the Neyman Type-A distribution: a Poisson mixture of Poisson distributions (a classic compound Poisson model).
            It generally does not simplify to a single elementary closed form for p(n), but it has a compact generating function (mentioned later).
          </p>

          <h3>Step 4 — Mean of N</h3>
          <p>
            First compute the conditional mean. For a Poisson random variable with mean <span class="pill">λ</span>, the mean is <span class="pill">λ</span>. Hence:
          </p>
          <div class="eqwrap" data-copy="E[N|K=k] = kG">
            <div class="eqtitle">
              <span>Conditional mean</span>
              <div>
                <button class="copyBtn" type="button">Copy</button>
                <span class="copyStatus"></span>
              </div>
            </div>
            <pre class="eq">E[N | K=k] = kG</pre>
          </div>

          <p>
            Apply the law of total expectation:
          </p>
          <div class="eqwrap" data-copy="E[N] = E[E[N|K]] = E[KG] = G E[K] = Gm = mG">
            <div class="eqtitle">
              <span>Mean photons</span>
              <div>
                <button class="copyBtn" type="button">Copy</button>
                <span class="copyStatus"></span>
              </div>
            </div>
            <pre class="eq">E[N] = E( E[N|K] ) = E(KG) = G E[K] = G m = mG</pre>
          </div>

          <p class="muted">
            Interpretation: average light output = (average electrons) × (average photons per electron).
          </p>

          <h3>Step 5 — Variance of N</h3>
          <p>
            For Poisson, <span class="pill">Var(Poisson(λ))=λ</span>. So the conditional variance is:
          </p>
          <div class="eqwrap" data-copy="Var(N|K=k) = kG">
            <div class="eqtitle">
              <span>Conditional variance</span>
              <div>
                <button class="copyBtn" type="button">Copy</button>
                <span class="copyStatus"></span>
              </div>
            </div>
            <pre class="eq">Var(N | K=k) = kG</pre>
          </div>

          <p>
            Now use the law of total variance:
          </p>
          <div class="eqwrap" data-copy="Var(N) = E[Var(N|K)] + Var(E[N|K])">
            <div class="eqtitle">
              <span>Total variance decomposition</span>
              <div>
                <button class="copyBtn" type="button">Copy</button>
                <span class="copyStatus"></span>
              </div>
            </div>
            <pre class="eq">Var(N) = E( Var(N|K) ) + Var( E[N|K] )</pre>
          </div>

          <p>
            Compute each term carefully:
          </p>
          <ul>
            <li>
              <strong>First term:</strong>
              <span class="pill">E[Var(N|K)] = E[KG] = G E[K] = Gm</span>.
            </li>
            <li>
              <strong>Second term:</strong>
              <span class="pill">Var(E[N|K]) = Var(KG) = G² Var(K)</span>.
              Since <span class="pill">K ~ Poisson(m)</span>, <span class="pill">Var(K)=m</span>, so this becomes <span class="pill">G² m</span>.
            </li>
          </ul>

          <div class="eqwrap" data-copy="Var(N)= Gm + G^2 m = m(G + G^2) = mG(1+G)">
            <div class="eqtitle">
              <span>Variance photons</span>
              <div>
                <button class="copyBtn" type="button">Copy</button>
                <span class="copyStatus"></span>
              </div>
            </div>
            <pre class="eq">Var(N) = Gm + G² m = m(G + G²) = mG(1+G)</pre>
          </div>

          <div class="callout ok">
            <strong>Final Answer (boxed)</strong>
            <div class="eqwrap" style="margin-top:10px" data-copy="N is Neyman Type-A (compound Poisson).  Mean: <N>=mG.  Variance: sigma_N^2 = m(G+G^2)=mG(1+G).  Distribution: p(n)=e^{-m} * (1/n!) * sum_{k=0}^∞ (m^k/k!) e^{-kG} (kG)^n.">
              <div class="eqtitle">
                <span>Copyable final result</span>
                <div>
                  <button class="copyBtn" type="button">Copy</button>
                  <span class="copyStatus"></span>
                </div>
              </div>
              <pre class="eq">Distribution (Neyman Type-A):
p(n)= e^{-m} (1/n!) Σ_{k=0}^{∞} [ (m^k/k!) e^{-kG} (kG)^n ].

Mean:
⟨N⟩ = mG.

Variance:
σ_N² = Var(N) = m(G + G²) = mG(1+G).</pre>
            </div>
          </div>

          <h3>Sanity checks</h3>
          <div class="grid2">
            <div class="callout">
              <strong>Units/dimensions</strong>
              <p class="muted">
                m and G are mean counts (dimensionless). ⟨N⟩ and Var(N) are also counts (dimensionless). All formulas are dimensionally consistent.
              </p>
            </div>
            <div class="callout">
              <strong>Limiting cases</strong>
              <ul class="muted">
                <li><span class="pill">m → 0</span>: almost no electrons, so ⟨N⟩→0 and Var→0.</li>
                <li><span class="pill">G → 0</span>: each electron emits almost no photons; ⟨N⟩→0 and Var→0.</li>
                <li><span class="pill">G small</span>: Fano factor <span class="pill">F=1+G≈1</span> → nearly Poisson light.</li>
              </ul>
            </div>
          </div>

          <p>
            <strong>Physical interpretation:</strong>
            The variance has two contributions:
            <span class="pill">mG</span> from photon production randomness <em>given</em> the electron count, plus
            <span class="pill">mG²</span> from fluctuations in the electron number itself (scaled by the squared gain).
            This is why cathodoluminescence often looks noisier than a pure Poisson photon stream.
          </p>

          <p class="muted">
            Connection to the diagram/plots below: the “two-stage” nature is illustrated in the setup diagram, and the plots show how the mean grows like mG
            while the variance grows faster, making the Fano factor exceed 1.
          </p>
        </article>

        <article id="part4">
          <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

          <h3>Re-interpreting the formulas</h3>
          <ul>
            <li><strong>⟨N⟩ = mG</strong> — linear in both the mean electron count (brightness of the beam) and mean photons per electron (phosphor efficiency).</li>
            <li><strong>Var(N) = mG + mG²</strong> — additivity of two noise sources:
              <ul>
                <li><span class="pill">mG</span>: “intrinsic” photon emission noise (Poisson yield at fixed K).</li>
                <li><span class="pill">mG²</span>: “input” electron-count noise, amplified by gain squared.</li>
              </ul>
            </li>
            <li><strong>Fano factor F = 1 + G</strong> — tells you immediately that the output is super-Poisson (F&gt;1) whenever G&gt;0.</li>
          </ul>

          <h3>Parameter effects (connect to the interactive plots)</h3>
          <ul>
            <li>Increasing <span class="pill">m</span> scales both mean and variance linearly (brighter beam → more photons and more absolute noise).</li>
            <li>Increasing <span class="pill">G</span> increases mean linearly but increases variance roughly like <span class="pill">~ mG²</span> at large G (noise grows faster than mean).</li>
            <li>The ratio <span class="pill">Var/Mean = 1+G</span> depends only on <span class="pill">G</span> (not on m), so changing m shifts curves up/down without changing super-Poisson “excess.”</li>
          </ul>

          <h3>Alternative derivation idea (brief)</h3>
          <p>
            Use the probability generating function (PGF). For a compound Poisson sum,
            <span class="pill">G_N(z) = exp(m (G_X(z) - 1))</span>,
            where <span class="pill">G_X(z)</span> is the PGF of the jump distribution (photons per electron).
            For <span class="pill">X ~ Poisson(G)</span>, <span class="pill">G_X(z) = exp(G(z-1))</span>, giving
            <span class="pill">G_N(z)=exp(m(exp(G(z-1)) - 1))</span>.
            Differentiating at <span class="pill">z=1</span> yields ⟨N⟩ and Var(N) quickly.
          </p>

          <div class="eqwrap" data-copy="PGF:  G_N(z)=E[z^N]=exp( m( exp(G(z-1)) - 1 ) ).  Then <N>=G_N'(1)=mG,  Var(N)=G_N''(1)+G_N'(1)-[G_N'(1)]^2=mG(1+G).">
            <div class="eqtitle">
              <span>Optional: generating function</span>
              <div>
                <button class="copyBtn" type="button">Copy</button>
                <span class="copyStatus"></span>
              </div>
            </div>
            <pre class="eq">G_N(z) = E[z^N] = exp( m( exp(G(z-1)) - 1 ) )
⇒ ⟨N⟩ = mG
⇒ Var(N) = mG(1+G)</pre>
          </div>

          <h3>Concept check (quick self-test)</h3>
          <ul>
            <li><strong>Q:</strong> If electron arrivals were perfectly fixed (no fluctuation), would Var(N) still have the <span class="pill">mG²</span> term?
              <br><strong>A:</strong> No. That term comes from Var(K). If K is fixed, only the <span class="pill">mG</span> (photon-yield) term remains.</li>
            <li><strong>Q:</strong> Does increasing m change the Fano factor <span class="pill">F</span>?
              <br><strong>A:</strong> No. <span class="pill">F=1+G</span> depends only on G.</li>
            <li><strong>Q:</strong> Why is the distribution not Poisson even though both stages are Poisson?
              <br><strong>A:</strong> Because mixing Poisson means (random <span class="pill">kG</span>) creates extra variance; a Poisson mixture is generally non-Poisson.</li>
            <li><strong>Q:</strong> For large G, what dominates Var(N)?
              <br><strong>A:</strong> <span class="pill">mG²</span> dominates, meaning input (electron-count) noise amplified by gain squared.</li>
          </ul>
        </article>

        <article id="part5">
          <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

          <div class="grid2">
            <figure>
              <canvas id="setupCanvas" class="canvasTall" aria-label="Labeled diagram of electron beam and phosphor"></canvas>
              <figcaption class="small">
                <strong>Diagram:</strong> electron arrivals (Poisson, mean m) hit a phosphor; each electron emits photons (Poisson, mean G). Total photons N is the random sum.
              </figcaption>
            </figure>

            <figure>
              <canvas id="plotCanvas" class="canvasTall" aria-label="Main plot of mean and variance versus mean electron count"></canvas>
              <figcaption class="small">
                <strong>Main plot:</strong> as m increases, mean ⟨N⟩ grows like mG and variance grows like mG(1+G), showing super-Poisson behavior.
              </figcaption>
            </figure>
          </div>

          <figure style="margin-top:14px">
            <canvas id="plotCanvas2" aria-label="Secondary plot of Fano factor versus mean photons per electron"></canvas>
            <figcaption class="small">
              <strong>Secondary plot:</strong> Fano factor <span class="pill">F = Var(N)/⟨N⟩ = 1 + G</span> vs G. This depends only on G and is always &gt; 1 for G &gt; 0.
            </figcaption>
          </figure>

          <div class="controls" role="group" aria-label="Interactive controls for parameters">
            <div class="control">
              <label for="mSlider">
                Mean electrons per window, <span class="pill">m</span>
                <span class="pill" id="mVal">20</span>
              </label>
              <input id="mSlider" type="range" min="1" max="80" step="1" value="20"/>
              <div class="small">Changes the horizontal scale in the main plot and updates all visuals.</div>
            </div>

            <div class="control">
              <label for="gSlider">
                Mean photons per electron, <span class="pill">G</span>
                <span class="pill" id="gVal">2.0</span>
              </label>
              <input id="gSlider" type="range" min="0.1" max="8" step="0.1" value="2.0"/>
              <div class="small">Controls the excess noise: Fano factor becomes <span class="pill">1+G</span>.</div>
            </div>

            <div class="control">
              <label for="modeSelect">
                Main plot mode
                <span class="pill" id="modeVal">Mean &amp; Variance</span>
              </label>
              <select id="modeSelect" style="width:100%; padding:8px 10px; border-radius:12px; border:1px solid rgba(255,255,255,0.16); background:rgba(0,0,0,0.25); color:var(--text)">
                <option value="mv" selected>Mean &amp; Variance vs m</option>
                <option value="sd">Std dev &amp; Mean vs m</option>
                <option value="cv">Coefficient of variation vs m</option>
              </select>
              <div class="small">Switches what the main plot emphasizes (all computed from the same formulas).</div>
            </div>
          </div>

          <div class="callout">
            <strong>What should change when you move sliders?</strong>
            <ul class="muted">
              <li>Increasing <span class="pill">m</span> shifts mean and variance up linearly in the main plot (brighter beam → more photons).</li>
              <li>Increasing <span class="pill">G</span> increases mean linearly but makes variance grow faster; the Fano factor line in the secondary plot moves up as <span class="pill">1+G</span>.</li>
              <li>The setup diagram annotates the current m and G to keep symbols consistent with the text.</li>
            </ul>
          </div>
        </article>
      </div>
    </div>
  </main>

  <footer>
    <p>
      Notes: Numeric values shown in the plots are <strong>example values</strong> chosen for visualization; the final analytic results are fully symbolic.
      This model is widely used in photodetection and scintillation-like processes where a Poisson number of primary events each produces a Poisson number of secondaries.
    </p>
  </footer>

  <script>
    // ---------- Copy buttons ----------
    (function initCopy(){
      const wraps = document.querySelectorAll('.eqwrap');
      wraps.forEach(w=>{
        const btn = w.querySelector('.copyBtn');
        const status = w.querySelector('.copyStatus');
        if(!btn) return;
        btn.addEventListener('click', async ()=>{
          const text = w.getAttribute('data-copy') || w.innerText.trim();
          try{
            await navigator.clipboard.writeText(text);
            if(status){ status.textContent = 'Copied!'; setTimeout(()=>status.textContent='', 1100); }
          }catch(e){
            if(status){ status.textContent = 'Copy failed (browser permission).'; setTimeout(()=>status.textContent='', 1800); }
          }
        });
      });
    })();

    // ---------- Math helpers ----------
    function meanN(m, G){ return m*G; }
    function varN(m, G){ return m*G*(1+G); } // m(G + G^2)
    function sdN(m, G){ return Math.sqrt(varN(m,G)); }
    function fano(G){ return 1 + G; }
    function cv(m,G){
      const mu = meanN(m,G);
      return mu>0 ? sdN(m,G)/mu : 0;
    }

    // ---------- Canvas utilities (HiDPI + responsive) ----------
    function setupHiDPICanvas(canvas){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect.width * dpr));
      const h = Math.max(2, Math.floor(rect.height * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {ctx, w: rect.width, h: rect.height, dpr};
    }

    function clear(ctx, w, h){
      ctx.clearRect(0,0,w,h);
    }

    // ---------- Drawing primitives ----------
    function roundRect(ctx, x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function drawGrid(ctx, x0,y0,w,h, nx, ny){
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      for(let i=0;i<=nx;i++){
        const x = x0 + w*(i/nx);
        ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+h); ctx.stroke();
      }
      for(let j=0;j<=ny;j++){
        const y = y0 + h*(j/ny);
        ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+w,y); ctx.stroke();
      }
      ctx.restore();
    }

    function drawAxes(ctx, plot){
      const {x,y,w,h} = plot;
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, y+h);
      ctx.lineTo(x+w, y+h);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x, y+h);
      ctx.stroke();
      ctx.restore();
    }

    function drawTicks(ctx, plot, xMin,xMax,yMin,yMax, xTicks=5, yTicks=5, xLabel='', yLabel=''){
      const {x,y,w,h} = plot;
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.strokeStyle = 'rgba(255,255,255,0.22)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      for(let i=0;i<=xTicks;i++){
        const t = i/xTicks;
        const xv = xMin + (xMax-xMin)*t;
        const xp = x + w*t;
        ctx.beginPath();
        ctx.moveTo(xp, y+h);
        ctx.lineTo(xp, y+h+6);
        ctx.stroke();
        ctx.fillText(formatNumber(xv), xp, y+h+8);
      }
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      for(let j=0;j<=yTicks;j++){
        const t = j/yTicks;
        const yv = yMin + (yMax-yMin)*(1-t);
        const yp = y + h*t;
        ctx.beginPath();
        ctx.moveTo(x-6, yp);
        ctx.lineTo(x, yp);
        ctx.stroke();
        ctx.fillText(formatNumber(yv), x-8, yp);
      }
      // Labels
      ctx.save();
      ctx.font = '13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillStyle = 'rgba(255,255,255,0.86)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText(xLabel, x + w/2, y + h + 42);
      ctx.translate(x - 48, y + h/2);
      ctx.rotate(-Math.PI/2);
      ctx.textBaseline = 'top';
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();
      ctx.restore();
    }

    function mapX(xVal, xMin,xMax, plot){
      const {x,w} = plot;
      return x + (xVal-xMin)/(xMax-xMin)*w;
    }
    function mapY(yVal, yMin,yMax, plot){
      const {y,h} = plot;
      return y + (1-(yVal-yMin)/(yMax-yMin))*h;
    }

    function drawLine(ctx, xs, ys, style){
      ctx.save();
      ctx.lineWidth = style.lineWidth || 2;
      ctx.strokeStyle = style.stroke || 'rgba(134,225,255,0.95)';
      ctx.setLineDash(style.dash || []);
      ctx.beginPath();
      for(let i=0;i<xs.length;i++){
        if(i===0) ctx.moveTo(xs[i], ys[i]);
        else ctx.lineTo(xs[i], ys[i]);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawLegend(ctx, items, x, y){
      ctx.save();
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';

      let yy = y;
      items.forEach(it=>{
        ctx.strokeStyle = it.stroke;
        ctx.lineWidth = 3;
        ctx.setLineDash(it.dash || []);
        ctx.beginPath();
        ctx.moveTo(x, yy);
        ctx.lineTo(x+26, yy);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.fillText(it.label, x+34, yy);
        yy += 18;
      });
      ctx.restore();
    }

    function drawTitle(ctx, title, w){
      ctx.save();
      ctx.font = '600 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(title, 14, 12);
      ctx.restore();
    }

    function formatNumber(v){
      const av = Math.abs(v);
      if(av >= 1000) return v.toFixed(0);
      if(av >= 100) return v.toFixed(0);
      if(av >= 10) return v.toFixed(1);
      if(av >= 1) return v.toFixed(2);
      return v.toFixed(3);
    }

    // ---------- Diagram canvas ----------
    function renderSetup(canvas, m, G){
      const {ctx, w, h} = setupHiDPICanvas(canvas);
      clear(ctx, w, h);

      // background panel tint
      ctx.save();
      roundRect(ctx, 10, 10, w-20, h-20, 16);
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.10)';
      ctx.stroke();
      ctx.restore();

      drawTitle(ctx, 'Physical setup (two-stage Poisson model)', w);

      // Beam source
      const src = {x: 60, y: h*0.52};
      const phosphor = {x: w-95, y: h*0.52, r: 46};

      // Source box
      ctx.save();
      roundRect(ctx, 24, src.y-60, 150, 120, 16);
      ctx.fillStyle = 'rgba(134,225,255,0.08)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(134,225,255,0.22)';
      ctx.stroke();

      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText('Electron beam', 36, src.y-48);

      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      ctx.fillText('K ~ Poisson(m)', 36, src.y-26);
      ctx.fillText('m = ' + formatNumber(m), 36, src.y-8);
      ctx.restore();

      // Phosphor target
      ctx.save();
      ctx.beginPath();
      ctx.arc(phosphor.x, phosphor.y, phosphor.r, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(180,255,177,0.08)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(180,255,177,0.25)';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText('Phosphor', phosphor.x, phosphor.y + phosphor.r + 10);

      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      ctx.fillText('X ~ Poisson(G)', phosphor.x, phosphor.y + phosphor.r + 28);
      ctx.fillText('G = ' + formatNumber(G), phosphor.x, phosphor.y + phosphor.r + 44);
      ctx.restore();

      // Beam arrow and electrons
      ctx.save();
      const xStart = 190, xEnd = phosphor.x - phosphor.r - 18;
      const yBeam = src.y;
      ctx.strokeStyle = 'rgba(255,255,255,0.22)';
      ctx.lineWidth = 2;
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(xStart, yBeam);
      ctx.lineTo(xEnd, yBeam);
      ctx.stroke();
      ctx.setLineDash([]);

      // Arrow head
      ctx.fillStyle = 'rgba(255,255,255,0.22)';
      ctx.beginPath();
      ctx.moveTo(xEnd, yBeam);
      ctx.lineTo(xEnd-10, yBeam-6);
      ctx.lineTo(xEnd-10, yBeam+6);
      ctx.closePath();
      ctx.fill();

      // draw a few electrons as dots
      const nDots = 7;
      for(let i=0;i<nDots;i++){
        const t = (i+0.6)/nDots;
        const x = xStart + (xEnd-xStart)*t;
        const y = yBeam + (Math.sin(i*1.7)*8);
        ctx.beginPath();
        ctx.arc(x, y, 3.4, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(134,225,255,0.85)';
        ctx.fill();
      }
      ctx.restore();

      // Photon burst near phosphor
      ctx.save();
      const burstN = 18;
      for(let i=0;i<burstN;i++){
        const ang = (i/burstN)*Math.PI*1.6 - Math.PI*0.8;
        const r = phosphor.r + 8 + (i%3)*6;
        const x = phosphor.x + Math.cos(ang)*r;
        const y = phosphor.y + Math.sin(ang)*r;
        ctx.beginPath();
        ctx.arc(x, y, 2.6, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(255,211,122,0.9)';
        ctx.fill();
      }
      ctx.restore();

      // Total output annotation
      ctx.save();
      const outBoxX = w*0.38, outBoxY = 42, outBoxW = w*0.42, outBoxH = 70;
      roundRect(ctx, outBoxX, outBoxY, outBoxW, outBoxH, 16);
      ctx.fillStyle = 'rgba(255,211,122,0.06)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,211,122,0.22)';
      ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText('Total photons in window:', outBoxX+12, outBoxY+10);
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      ctx.fillStyle = 'rgba(255,255,255,0.78)';
      ctx.fillText('N = Σ_{i=1..K} X_i', outBoxX+12, outBoxY+32);
      const mu = meanN(m,G), va = varN(m,G);
      ctx.fillText('<N> = mG = ' + formatNumber(mu), outBoxX+12, outBoxY+50);
      ctx.fillText('Var(N) = mG(1+G) = ' + formatNumber(va), outBoxX+240, outBoxY+50);
      ctx.restore();
    }

    // ---------- Plot 1: vs m ----------
    function renderMainPlot(canvas, mMax, G, mode){
      const {ctx, w, h} = setupHiDPICanvas(canvas);
      clear(ctx, w, h);

      // Panel
      ctx.save();
      roundRect(ctx, 10, 10, w-20, h-20, 16);
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.10)';
      ctx.stroke();
      ctx.restore();

      let title = '';
      if(mode==='mv') title = 'Mean and variance of photon counts vs mean electrons m';
      if(mode==='sd') title = 'Mean and standard deviation vs mean electrons m';
      if(mode==='cv') title = 'Coefficient of variation (σ/μ) vs mean electrons m';
      drawTitle(ctx, title, w);

      const padL = 70, padR = 24, padT = 46, padB = 68;
      const plot = {x: padL, y: padT, w: w-padL-padR, h: h-padT-padB};

      // choose x range and sample
      const xMin = 0, xMax = mMax;
      const n = 200;
      const xs = [];
      const y1 = [];
      const y2 = [];

      // compute data
      for(let i=0;i<n;i++){
        const mm = xMin + (xMax-xMin)*(i/(n-1));
        let a,b;
        if(mode==='mv'){
          a = meanN(mm,G);
          b = varN(mm,G);
        }else if(mode==='sd'){
          a = meanN(mm,G);
          b = sdN(mm,G);
        }else{ // cv
          a = cv(mm,G);
          b = 0; // unused
        }
        xs.push(mm);
        y1.push(a);
        y2.push(b);
      }

      // y range
      let yMin=0, yMax=1;
      if(mode==='mv'){
        yMax = Math.max(...y2, ...y1) * 1.08 + 1e-9;
      }else if(mode==='sd'){
        yMax = Math.max(...y2, ...y1) * 1.08 + 1e-9;
      }else{
        yMax = Math.max(...y1) * 1.15 + 1e-9;
      }

      // grid
      drawGrid(ctx, plot.x, plot.y, plot.w, plot.h, 6, 6);
      drawAxes(ctx, plot);

      // ticks
      const xLabel = 'm (mean electrons per time window) [count]';
      let yLabel = '';
      if(mode==='mv') yLabel = 'Counts [photons² for variance shown as magnitude]';
      if(mode==='sd') yLabel = 'Counts [photons]';
      if(mode==='cv') yLabel = 'σ/μ [dimensionless]';
      drawTicks(ctx, plot, xMin,xMax, yMin,yMax, 5, 5, xLabel, yLabel);

      // map lines
      const xp = xs.map(v=>mapX(v,xMin,xMax,plot));
      const yp1 = y1.map(v=>mapY(v,yMin,yMax,plot));
      if(mode!=='cv'){
        const yp2 = y2.map(v=>mapY(v,yMin,yMax,plot));
        // Mean line
        drawLine(ctx, xp, yp1, {stroke:'rgba(134,225,255,0.95)', lineWidth:2.6});
        // Second line
        drawLine(ctx, xp, yp2, {stroke:'rgba(180,255,177,0.95)', lineWidth:2.6, dash:[7,6]});
        drawLegend(ctx, [
          {label:'Mean ⟨N⟩ = mG', stroke:'rgba(134,225,255,0.95)', dash:[]},
          {label:(mode==='mv'?'Variance Var(N) = mG(1+G)':'Std dev σ = √(mG(1+G))'), stroke:'rgba(180,255,177,0.95)', dash:[7,6]}
        ], plot.x + 10, plot.y + 12);

        // highlight current m (at 70% of max, just a guide line)
        const mCur = mMax*0.75;
        const xCur = mapX(mCur, xMin,xMax, plot);
        ctx.save();
        ctx.strokeStyle = 'rgba(255,211,122,0.26)';
        ctx.lineWidth = 2;
        ctx.setLineDash([4,6]);
        ctx.beginPath();
        ctx.moveTo(xCur, plot.y);
        ctx.lineTo(xCur, plot.y + plot.h);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = 'rgba(255,211,122,0.9)';
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'bottom';
        const muCur = meanN(mCur,G);
        const vaCur = varN(mCur,G);
        ctx.fillText('example m = ' + formatNumber(mCur), xCur + 6, plot.y + plot.h - 6);
        ctx.fillText('⟨N⟩=' + formatNumber(muCur) + (mode==='mv' ? (', Var=' + formatNumber(vaCur)) : (', σ=' + formatNumber(Math.sqrt(vaCur)))), xCur + 6, plot.y + plot.h - 24);
        ctx.restore();

      }else{
        // CV only
        drawLine(ctx, xp, yp1, {stroke:'rgba(134,225,255,0.95)', lineWidth:2.6});
        drawLegend(ctx, [
          {label:'CV = σ/μ = √(mG(1+G)) / (mG)', stroke:'rgba(134,225,255,0.95)', dash:[]}
        ], plot.x + 10, plot.y + 12);

        // asymptotic note: CV ~ 1/√m for fixed G
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.75)';
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'bottom';
        ctx.fillText('For fixed G, CV decreases ~ 1/√m (more averaging with more electrons).', plot.x + 10, plot.y + plot.h - 10);
        ctx.restore();
      }

      // Annotate current G
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.80)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'top';
      ctx.fillText('G = ' + formatNumber(G), w - 24, 14);
      ctx.restore();
    }

    // ---------- Plot 2: Fano factor vs G ----------
    function renderFanoPlot(canvas, m, Gcur){
      const {ctx, w, h} = setupHiDPICanvas(canvas);
      clear(ctx, w, h);

      ctx.save();
      roundRect(ctx, 10, 10, w-20, h-20, 16);
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.10)';
      ctx.stroke();
      ctx.restore();

      drawTitle(ctx, 'Fano factor F = Var(N)/⟨N⟩ = 1 + G (independent of m)', w);

      const padL = 70, padR = 24, padT = 46, padB = 60;
      const plot = {x: padL, y: padT, w: w-padL-padR, h: h-padT-padB};

      const xMin = 0, xMax = 8;
      const yMin = 1, yMax = 9;

      drawGrid(ctx, plot.x, plot.y, plot.w, plot.h, 6, 6);
      drawAxes(ctx, plot);
      drawTicks(ctx, plot, xMin,xMax, yMin,yMax, 6, 4,
        'G (mean photons per electron) [count/electron]',
        'Fano factor F [dimensionless]'
      );

      // line F=1+G
      const n = 180;
      const xs = [], ys = [];
      for(let i=0;i<n;i++){
        const g = xMin + (xMax-xMin)*(i/(n-1));
        xs.push(mapX(g,xMin,xMax,plot));
        ys.push(mapY(fano(g),yMin,yMax,plot));
      }
      drawLine(ctx, xs, ys, {stroke:'rgba(180,255,177,0.95)', lineWidth:2.8});

      // highlight current G
      const xCur = mapX(Gcur, xMin,xMax, plot);
      const yCur = mapY(fano(Gcur), yMin,yMax, plot);
      ctx.save();
      ctx.strokeStyle = 'rgba(255,211,122,0.28)';
      ctx.lineWidth = 2;
      ctx.setLineDash([5,6]);
      ctx.beginPath();
      ctx.moveTo(xCur, plot.y);
      ctx.lineTo(xCur, plot.y + plot.h);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(plot.x, yCur);
      ctx.lineTo(plot.x + plot.w, yCur);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.beginPath();
      ctx.arc(xCur, yCur, 5, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,211,122,0.95)';
      ctx.fill();

      ctx.fillStyle = 'rgba(255,255,255,0.86)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      ctx.fillText('G=' + formatNumber(Gcur) + ' → F=' + formatNumber(fano(Gcur)), xCur + 8, yCur - 8);

      // Note about m
      ctx.fillStyle = 'rgba(255,255,255,0.72)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      ctx.fillText('Example m = ' + formatNumber(m) + ' (does not change F).', plot.x + 10, plot.y + plot.h - 10);

      drawLegend(ctx, [
        {label:'F = 1 + G', stroke:'rgba(180,255,177,0.95)', dash:[]}
      ], plot.x + 10, plot.y + 12);

      ctx.restore();
    }

    // ---------- Controller ----------
    const setupCanvas = document.getElementById('setupCanvas');
    const plotCanvas = document.getElementById('plotCanvas');
    const plotCanvas2 = document.getElementById('plotCanvas2');

    const mSlider = document.getElementById('mSlider');
    const gSlider = document.getElementById('gSlider');
    const mVal = document.getElementById('mVal');
    const gVal = document.getElementById('gVal');

    const modeSelect = document.getElementById('modeSelect');
    const modeVal = document.getElementById('modeVal');

    function renderAll(){
      const m = parseFloat(mSlider.value);
      const G = parseFloat(gSlider.value);
      const mode = modeSelect.value;

      mVal.textContent = String(m.toFixed(0));
      gVal.textContent = String(G.toFixed(1));

      modeVal.textContent =
        mode==='mv' ? 'Mean & Variance' :
        mode==='sd' ? 'Mean & Std dev' : 'CV';

      // Example plotting choice: show main plot over m in [0, mSliderMax]
      const mMax = parseFloat(mSlider.max);

      renderSetup(setupCanvas, m, G);
      renderMainPlot(plotCanvas, mMax, G, mode);
      renderFanoPlot(plotCanvas2, m, G);
    }

    mSlider.addEventListener('input', renderAll);
    gSlider.addEventListener('input', renderAll);
    modeSelect.addEventListener('change', renderAll);

    // Re-render on resize to keep crisp + responsive
    let resizeTimer = null;
    window.addEventListener('resize', ()=>{
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(renderAll, 80);
    });

    // Initial render
    renderAll();
  </script>
</body>
</html>
