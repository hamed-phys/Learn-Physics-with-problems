<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Bose–Einstein Photon-Number Distribution: Normalization, Mean/Variance, and Zero-Count Probability</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#0f1624;
      --card:#121c2e;
      --text:#e8eefc;
      --muted:#a9b6d3;
      --accent:#7aa2ff;
      --accent2:#69f0ae;
      --warn:#ffcc66;
      --danger:#ff6b6b;
      --line:rgba(255,255,255,0.10);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius:18px;
      --radius2:24px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 700px at 10% -10%, rgba(122,162,255,0.22), transparent 55%),
                  radial-gradient(900px 600px at 100% 0%, rgba(105,240,174,0.12), transparent 50%),
                  linear-gradient(180deg, var(--bg), #070a10 70%);
      color:var(--text);
      line-height:1.6;
    }
    header{
      padding:28px 18px 12px;
      max-width:1200px;
      margin:0 auto;
    }
    .title-wrap{
      display:grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap:14px;
      align-items:end;
    }
    @media (max-width: 900px){
      .title-wrap{grid-template-columns:1fr}
    }
    h1{
      margin:0 0 10px 0;
      font-size: clamp(1.6rem, 2.6vw, 2.4rem);
      letter-spacing:0.2px;
    }
    .subtitle{
      color:var(--muted);
      margin:0;
      font-size:1rem;
      max-width:68ch;
    }
    .badge-row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
      align-items:center;
    }
    @media (max-width: 900px){
      .badge-row{justify-content:flex-start}
    }
    .badge{
      padding:7px 10px;
      border-radius:999px;
      background: rgba(255,255,255,0.07);
      border:1px solid rgba(255,255,255,0.10);
      color:var(--muted);
      font-size:0.88rem;
      backdrop-filter: blur(6px);
    }

    main{
      max-width:1200px;
      margin: 0 auto;
      padding: 10px 18px 42px;
    }

    .layout{
      display:grid;
      grid-template-columns: 290px 1fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns:1fr}
    }

    nav#toc{
      position:sticky;
      top:12px;
      align-self:start;
      background: rgba(18,28,46,0.70);
      border:1px solid rgba(255,255,255,0.10);
      border-radius: var(--radius2);
      padding:14px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    @media (max-width: 980px){
      nav#toc{
        position:relative;
        top:auto;
      }
    }
    nav#toc h2{
      font-size:1rem;
      margin:0 0 10px 0;
      color:var(--text);
      letter-spacing:0.2px;
    }
    .toc-links{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .toc-links a{
      text-decoration:none;
      color:var(--muted);
      padding:8px 10px;
      border-radius:12px;
      border:1px solid transparent;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      font-size:0.95rem;
    }
    .toc-links a:hover{
      background: rgba(122,162,255,0.10);
      border-color: rgba(122,162,255,0.22);
      color: var(--text);
      transform: translateX(2px);
    }
    .toc-mini{
      margin-top:10px;
      padding-top:10px;
      border-top: 1px solid rgba(255,255,255,0.10);
      color: var(--muted);
      font-size:0.9rem;
    }

    section{
      scroll-margin-top: 16px;
      margin-bottom: 16px;
    }

    .card{
      background: rgba(18,28,46,0.75);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: var(--radius2);
      padding: 18px 18px 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    .card h2{
      margin:0 0 10px 0;
      font-size:1.28rem;
    }
    .card h3{
      margin:16px 0 8px 0;
      font-size:1.07rem;
      color: var(--text);
    }
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 920px){ .grid2{grid-template-columns:1fr} }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    @media (max-width: 900px){ .callouts{grid-template-columns:1fr} }

    .callout{
      border-radius: var(--radius);
      padding:12px 12px 10px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
    }
    .callout strong{color:var(--text)}
    .callout.assumptions{border-color: rgba(105,240,174,0.22); background: rgba(105,240,174,0.06)}
    .callout.keyeq{border-color: rgba(122,162,255,0.22); background: rgba(122,162,255,0.06)}
    .callout.pitfalls{border-color: rgba(255,204,102,0.25); background: rgba(255,204,102,0.06)}
    .callout.final{border-color: rgba(255,107,107,0.25); background: rgba(255,107,107,0.06)}

    .eq{
      font-family: var(--mono);
      font-size:0.98rem;
      white-space: pre-wrap;
      background: rgba(0,0,0,0.35);
      border:1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      padding:10px 10px;
      margin:10px 0;
      position:relative;
    }
    .eq .copybtn, .copy-final{
      position:absolute;
      top:10px;
      right:10px;
      font-family: var(--sans);
      font-size:0.85rem;
      padding:7px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.07);
      color: var(--text);
      cursor:pointer;
      transition: transform 120ms ease, background 120ms ease;
    }
    .eq .copybtn:hover, .copy-final:hover{ background: rgba(122,162,255,0.14); transform: translateY(-1px); }
    .eq .copybtn:active, .copy-final:active{ transform: translateY(0px) scale(0.99); }

    .finalbox{
      position:relative;
      border-radius: var(--radius2);
      padding:14px 14px 12px;
      border: 1px solid rgba(255,107,107,0.28);
      background: rgba(255,107,107,0.08);
      margin-top:10px;
    }
    .finalbox .copy-final{
      position:absolute;
      top:12px;
      right:12px;
    }
    .finaltext{
      font-family: var(--mono);
      white-space: pre-wrap;
      margin:0;
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
      margin-top:12px;
      padding:12px;
      border-radius: var(--radius2);
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.20);
    }
    @media (max-width: 980px){ .controls{grid-template-columns:1fr} }
    .control{
      padding:10px 10px 8px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:0.95rem;
      color:var(--muted);
      margin-bottom:8px;
    }
    .control .val{
      color: var(--text);
      font-family: var(--mono);
      font-size:0.95rem;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .btnrow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-top:8px;
    }
    .btn{
      cursor:pointer;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.14);
      padding:8px 12px;
      background: rgba(255,255,255,0.06);
      color: var(--text);
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      user-select:none;
    }
    .btn:hover{
      background: rgba(105,240,174,0.10);
      border-color: rgba(105,240,174,0.22);
      transform: translateY(-1px);
    }
    .btn:active{ transform: translateY(0px) scale(0.99); }

    figure{
      margin:0;
      padding:0;
    }
    .canvasWrap{
      border-radius: var(--radius2);
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.25);
      overflow:hidden;
      box-shadow: 0 10px 26px rgba(0,0,0,0.28);
    }
    canvas{
      display:block;
      width:100%;
      height: 320px;
    }
    #plotMain{height: 360px;}
    #plotDist{height: 340px;}
    #diagram{height: 260px;}

    .small{
      font-size:0.95rem;
      color: var(--muted);
    }

    ul{margin:8px 0 0 20px}
    li{margin:6px 0}

    .hr{
      height:1px;
      background: rgba(255,255,255,0.10);
      margin: 14px 0;
    }

    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 0 18px 24px;
      color: var(--muted);
      font-size:0.95rem;
    }

    /* subtle fade-in */
    .fadein{
      animation: fadeUp 520ms ease both;
    }
    @keyframes fadeUp{
      from{opacity:0; transform: translateY(8px);}
      to{opacity:1; transform: translateY(0);}
    }

    /* print friendly */
    @media print{
      body{background:#fff; color:#111}
      header, main, footer{max-width: 100%; padding: 0.6cm;}
      nav#toc{display:none}
      .card, .canvasWrap{box-shadow:none; backdrop-filter:none; background:#fff; border-color:#ccc}
      .eq{background:#f6f6f6; border-color:#ccc}
      .controls{display:none}
      .copybtn, .copy-final{display:none}
      canvas{height: 240px;}
    }
  </style>
</head>

<body>
  <header class="fadein">
    <div class="title-wrap">
      <div>
        <h1>Bose–Einstein Photon Counts (Geometric Law): Normalization, Mean/Variance, and a 20-ns “Zero-Click” Probability</h1>
        <p class="subtitle">
          We treat photon counts in a time window for chaotic (thermal) light: the Bose–Einstein photon-number distribution is geometric.
          You’ll verify its statistics and use it to compute the probability of detecting <em>no photons</em> in a fixed time interval.
        </p>
      </div>
      <div class="badge-row">
        <span class="badge">Topic: photon statistics</span>
        <span class="badge">Model: Bose–Einstein (thermal)</span>
        <span class="badge">Key result: P(0)=1/(1+ n̄)</span>
      </div>
    </div>
  </header>

  <main class="layout fadein">
    <nav id="toc" aria-label="Table of contents">
      <h2>Table of Contents</h2>
      <div class="toc-links">
        <a href="#quick">Quick Summary</a>
        <a href="#part0">PART 0 — Concept Primer</a>
        <a href="#part1">PART 1 — Problem Analysis</a>
        <a href="#part2">PART 2 — Strategy & Tips</a>
        <a href="#part3">PART 3 — Full Solution</a>
        <a href="#part4">PART 4 — Deeper Understanding</a>
        <a href="#part5">PART 5 — Visualization Guide</a>
      </div>
      <div class="toc-mini">
        <div><strong class="muted">Interactive:</strong> change photon flux and time window; plots update live.</div>
      </div>
    </nav>

    <div>
      <section id="quick" class="card">
        <h2>Quick Summary</h2>
        <ul>
          <li><strong>What this is about:</strong> photon-number fluctuations for light obeying <em>Bose–Einstein</em> (thermal/chaotic) statistics.</li>
          <li><strong>Key idea:</strong> in a single “mode” (or a single coherence cell), the photon count <span class="muted">n</span> follows a <em>geometric distribution</em>.</li>
          <li><strong>Governing distribution:</strong> <span class="muted">P(n)</span> is geometric with mean <span class="muted">n̄</span> (dimensionless photons per time bin).</li>
          <li><strong>Core equations:</strong> normalization via a geometric series; mean and variance via standard sums.</li>
          <li><strong>Statistics to verify:</strong> <span class="muted">⟨n⟩ = n̄</span> and <span class="muted">Var(n)=σ² = n̄ + n̄²</span> (super-Poisson “bunching”).</li>
          <li><strong>Applied result type:</strong> numeric probability of zero counts in <span class="muted">T = 20 ns</span> for flux <span class="muted">Φ = 1 photon/ns</span>.</li>
          <li><strong>Final numeric:</strong> for <span class="muted">n̄ = ΦT = 20</span>, <span class="muted">P(0)=1/(1+n̄)=1/21≈0.0476</span>.</li>
        </ul>
      </section>

      <section id="part0" class="card">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <h3>Core definitions (symbols & units)</h3>
        <ul>
          <li><strong>n</strong>: detected photon number in a chosen time window (unit: photons; treated as an integer random variable).</li>
          <li><strong>P(n)</strong>: probability to detect exactly <span class="muted">n</span> photons (unitless).</li>
          <li><strong>n̄</strong> (read “n-bar”): mean photon number in the window, <span class="muted">n̄ = ⟨n⟩</span> (unitless).</li>
          <li><strong>Φ</strong>: average photon flux (photons per unit time, e.g. photons/ns).</li>
          <li><strong>T</strong>: detection time window (e.g. ns).</li>
          <li><strong>σ²</strong>: variance <span class="muted">Var(n)=⟨n²⟩−⟨n⟩²</span> (photons²).</li>
        </ul>

        <h3>Physical meaning</h3>
        <ul>
          <li><strong>Photon statistics</strong> tell you how “noisy” a light field is beyond its average intensity.</li>
          <li><strong>Bose–Einstein / thermal light</strong> exhibits <em>photon bunching</em>: photons arrive in clumps, making fluctuations larger than Poisson.</li>
          <li>In a single coherence cell (one mode), the thermal photon-number distribution becomes geometric, giving <span class="muted">σ² = n̄ + n̄²</span>.</li>
        </ul>

        <h3>Key principles and validity (assumptions/conditions)</h3>
        <ul>
          <li><strong>Thermal (chaotic) light</strong> in a single mode has a Bose–Einstein number distribution.</li>
          <li><strong>Time-bin model:</strong> counting photons in a window of duration <span class="muted">T</span>. If the bin is about a coherence time (or you effectively select one mode), BE statistics are appropriate.</li>
          <li><strong>Stationary average flux:</strong> the mean count is <span class="muted">n̄ = ΦT</span>.</li>
          <li><strong>Contrast with Poisson:</strong> for coherent light (laser), <span class="muted">Var(n)=n̄</span> and <span class="muted">P(0)=e^{-n̄}</span>. Thermal light yields a much larger zero-count probability when <span class="muted">n̄</span> is big, because counts are bursty.</li>
        </ul>

        <h3>Common models/approximations and why we use them</h3>
        <ul>
          <li><strong>Single-mode thermal model:</strong> simplest closed-form BE distribution; highlights bunching clearly.</li>
          <li><strong>Time-bin “one-mode” approximation:</strong> treat each detection window as one effective mode. (If many modes contribute, you get a negative binomial distribution and reduced bunching.)</li>
        </ul>

        <h3>Mini intuition examples</h3>
        <ul>
          <li><strong>Example 1 (small mean):</strong> if <span class="muted">n̄=0.1</span>, then <span class="muted">P(0)=1/(1.1)≈0.909</span> (most bins are empty).</li>
          <li><strong>Example 2 (large mean):</strong> if <span class="muted">n̄=20</span>, BE gives <span class="muted">P(0)=1/21≈0.048</span>, while Poisson would give <span class="muted">e^{-20}≈2×10⁻⁹</span>. Huge difference: thermal light has “dark gaps” between bursts.</li>
        </ul>

        <div class="callouts">
          <div class="callout pitfalls">
            <strong>What to watch for (pitfalls)</strong>
            <ul>
              <li>Confusing <span class="muted">Bose–Einstein energy occupancy</span> with <span class="muted">photon count in a time bin</span>. Here it’s photon-number statistics.</li>
              <li>Using Poisson by habit: Poisson is for coherent (shot-noise-limited) light, not thermal single-mode light.</li>
              <li>For thermal light with many modes, the variance changes; single-mode gives the largest bunching.</li>
            </ul>
          </div>
          <div class="callout assumptions">
            <strong>Model assumptions (in this problem)</strong>
            <ul>
              <li>Photon counts in the chosen interval follow the single-mode Bose–Einstein (geometric) distribution.</li>
              <li>Average flux is constant so <span class="muted">n̄ = ΦT</span>.</li>
              <li>Ideal counting: no dead time, no afterpulsing, unit quantum efficiency (unless stated otherwise).</li>
            </ul>
          </div>
        </div>
      </section>

      <section id="part1" class="card">
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

        <h3>Rewrite the problem in plain words</h3>
        <p class="muted">
          (a) You are given a Bose–Einstein photon-number distribution (a geometric distribution) and must prove it sums to 1,
          then compute its mean and variance. (b) Using an average photon flux of 1 photon/ns, find the probability that
          zero photons are detected in a 20-ns interval.
        </p>

        <h3>Given quantities</h3>
        <ul>
          <li>Distribution form (from the referenced equation): a Bose–Einstein photon-number law parameterized by mean <span class="muted">n̄</span>.</li>
          <li>Average photon flux: <span class="muted">Φ = 1 photon/ns</span>.</li>
          <li>Time interval: <span class="muted">T = 20 ns</span>.</li>
        </ul>

        <h3>Unknowns / what must be found</h3>
        <ul>
          <li>(a) Show <span class="muted">∑_{n=0}^∞ P(n)=1</span>, <span class="muted">⟨n⟩=n̄</span>, and <span class="muted">σ² = n̄ + n̄²</span>.</li>
          <li>(b) Compute <span class="muted">P(0)</span> for <span class="muted">n̄ = ΦT</span>.</li>
        </ul>

        <h3>Relevant principles and why they apply</h3>
        <ul>
          <li><strong>Geometric series sums</strong> apply because <span class="muted">P(n)</span> is proportional to <span class="muted">r^n</span>.</li>
          <li><strong>Expectation definitions</strong> apply: <span class="muted">⟨n⟩=∑ nP(n)</span>, <span class="muted">⟨n²⟩=∑ n²P(n)</span>.</li>
          <li><strong>Flux-to-mean conversion</strong> applies because average counts in a window are <span class="muted">n̄=ΦT</span> under stationarity.</li>
        </ul>

        <h3>Explicit assumptions</h3>
        <ul>
          <li>Single-mode (or one effective mode per time bin) thermal statistics → geometric (Bose–Einstein) photon-number distribution.</li>
          <li>Counts are independent across bins (not needed for single-bin probability).</li>
          <li>Ideal detector for the probability calculation.</li>
        </ul>

        <h3>Possible approaches (and comparison)</h3>
        <ul>
          <li><strong>Approach A: geometric-series identities</strong> (best here): directly sum <span class="muted">∑ r^n</span>, <span class="muted">∑ nr^n</span>, <span class="muted">∑ n²r^n</span>. <em>Fast, transparent.</em></li>
          <li><strong>Approach B: generating function</strong>: use <span class="muted">G(z)=∑ P(n)z^n</span>; compute derivatives at <span class="muted">z=1</span>. <em>Elegant, scalable.</em></li>
          <li><strong>Approach C: known results for geometric distribution</strong>: quote standard mean/variance. <em>Quick but less instructional.</em></li>
        </ul>

        <p><strong>Chosen method:</strong> Approach A (explicit sums). It teaches the normalization and the moments from first principles with minimal machinery.</p>
      </section>

      <section id="part2" class="card">
        <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

        <ol>
          <li><strong>Write the BE photon-number distribution in a geometric form</strong><br/>
            <span class="muted">Tool:</span> identify <span class="muted">r = n̄/(1+n̄)</span> and prefactor <span class="muted">(1-r)</span>.<br/>
            <span class="muted">Physical meaning:</span> each extra photon is suppressed by a constant ratio <span class="muted">r</span>.
          </li>
          <li><strong>Prove normalization</strong><br/>
            <span class="muted">Tool:</span> geometric series <span class="muted">∑ r^n = 1/(1-r)</span> (for <span class="muted">|r|&lt;1</span>).<br/>
            <span class="muted">Meaning:</span> total probability must be 1.
          </li>
          <li><strong>Compute the mean ⟨n⟩</strong><br/>
            <span class="muted">Tool:</span> sum identity <span class="muted">∑ n r^n = r/(1-r)²</span>.<br/>
            <span class="muted">Meaning:</span> average photons per bin.
          </li>
          <li><strong>Compute ⟨n²⟩ and the variance</strong><br/>
            <span class="muted">Tool:</span> identity <span class="muted">∑ n² r^n = r(1+r)/(1-r)³</span>.<br/>
            <span class="muted">Meaning:</span> quantifies fluctuations (“noise”).
          </li>
          <li><strong>Relate mean to flux</strong><br/>
            <span class="muted">Tool:</span> <span class="muted">n̄ = ΦT</span> for steady flux.<br/>
            <span class="muted">Meaning:</span> connect lab rate to distribution parameter.
          </li>
          <li><strong>Evaluate P(0)</strong><br/>
            <span class="muted">Tool:</span> plug <span class="muted">n=0</span> into <span class="muted">P(n)</span>.<br/>
            <span class="muted">Meaning:</span> probability of no detector clicks in the bin.
          </li>
          <li><strong>Sanity-check limiting cases</strong><br/>
            <span class="muted">Tool:</span> check <span class="muted">n̄→0</span> and <span class="muted">n̄→∞</span> behavior.<br/>
            <span class="muted">Meaning:</span> ensure results match physical intuition.
          </li>
        </ol>

        <div class="callout pitfalls">
          <strong>Common mistakes & quick tips</strong>
          <ul>
            <li>When using series, ensure <span class="muted">|r|&lt;1</span>. Here <span class="muted">r = n̄/(1+n̄)</span> is always in (0,1).</li>
            <li>Don’t forget that <span class="muted">Var(n)=⟨n²⟩−⟨n⟩²</span>, not just <span class="muted">⟨n²⟩</span>.</li>
            <li>Part (b): the mean count is <span class="muted">n̄=ΦT</span>, not <span class="muted">Φ</span> alone.</li>
          </ul>
        </div>
      </section>

      <section id="part3" class="card">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Start with physical intuition</h3>
        <p class="muted">
          Thermal (Bose–Einstein) light is “bursty”: photons arrive in bunches. That means even if the mean number
          in a 20-ns window is large (like 20), you can still get empty windows with non-negligible probability.
          Mathematically, that shows up as a variance larger than the mean: <span class="muted">σ² = n̄ + n̄²</span>.
        </p>

        <div class="callout keyeq">
          <strong>Given Bose–Einstein (single-mode) photon-number distribution</strong>
          <div class="eq" data-copy="P(n) = (1/(1+n̄)) (n̄/(1+n̄))^n,   n = 0,1,2,...">
            <button class="copybtn" type="button">Copy</button>
            P(n) = (1/(1+n̄)) (n̄/(1+n̄))^n,   n = 0,1,2,...
          </div>
          <div class="small">
            Here <span class="muted">n̄</span> is the mean photon number in the counting window (dimensionless).
          </div>
        </div>

        <h3>(a) Normalization</h3>
        <p>
          Define the ratio
          <span class="muted">r = n̄/(1+n̄)</span>. Since <span class="muted">n̄ ≥ 0</span>, we have <span class="muted">0 ≤ r &lt; 1</span>.
          Then the distribution is
        </p>

        <div class="eq" data-copy="Let r = n̄/(1+n̄). Then P(n) = (1-r) r^n.">
          <button class="copybtn" type="button">Copy</button>
          Let r = n̄/(1+n̄). Then P(n) = (1-r) r^n.
        </div>

        <p>
          Now sum over all <span class="muted">n</span>:
        </p>

        <div class="eq" data-copy="∑_{n=0}^∞ P(n) = (1-r) ∑_{n=0}^∞ r^n = (1-r) (1/(1-r)) = 1.">
          <button class="copybtn" type="button">Copy</button>
          ∑_{n=0}^∞ P(n) = (1-r) ∑_{n=0}^∞ r^n = (1-r) (1/(1-r)) = 1.
        </div>

        <p class="muted">
          We used the geometric series <span class="muted">∑ r^n = 1/(1-r)</span> (valid because <span class="muted">|r|&lt;1</span>).
          So the distribution is normalized.
        </p>

        <h3>(a) Mean ⟨n⟩</h3>
        <p>
          By definition,
          <span class="muted">⟨n⟩ = ∑_{n=0}^∞ n P(n)</span>.
          Substitute <span class="muted">P(n)=(1-r)r^n</span>:
        </p>

        <div class="eq" data-copy="⟨n⟩ = (1-r) ∑_{n=0}^∞ n r^n.">
          <button class="copybtn" type="button">Copy</button>
          ⟨n⟩ = (1-r) ∑_{n=0}^∞ n r^n.
        </div>

        <p>
          Use the standard identity (derivable by differentiating the geometric series):
          <span class="muted">∑_{n=0}^∞ n r^n = r/(1-r)²</span>.
          Then
        </p>

        <div class="eq" data-copy="⟨n⟩ = (1-r) [ r/(1-r)^2 ] = r/(1-r).">
          <button class="copybtn" type="button">Copy</button>
          ⟨n⟩ = (1-r) [ r/(1-r)^2 ] = r/(1-r).
        </div>

        <p>
          Now substitute <span class="muted">r = n̄/(1+n̄)</span>. Compute <span class="muted">1-r = 1/(1+n̄)</span>, so
        </p>

        <div class="eq" data-copy="⟨n⟩ = [n̄/(1+n̄)] / [1/(1+n̄)] = n̄.">
          <button class="copybtn" type="button">Copy</button>
          ⟨n⟩ = [n̄/(1+n̄)] / [1/(1+n̄)] = n̄.
        </div>

        <p class="muted">
          So the parameter <span class="muted">n̄</span> really is the mean photon number.
        </p>

        <h3>(a) Variance σ²</h3>
        <p>
          We compute <span class="muted">⟨n²⟩</span> and then subtract <span class="muted">⟨n⟩²</span>.
          Start from
          <span class="muted">⟨n²⟩ = ∑ n² P(n) = (1-r)∑ n² r^n</span>.
        </p>

        <div class="eq" data-copy="⟨n^2⟩ = (1-r) ∑_{n=0}^∞ n^2 r^n.">
          <button class="copybtn" type="button">Copy</button>
          ⟨n^2⟩ = (1-r) ∑_{n=0}^∞ n^2 r^n.
        </div>

        <p>
          Use the identity (also obtained via differentiating series twice):
          <span class="muted">∑_{n=0}^∞ n² r^n = r(1+r)/(1-r)³</span>.
          Then
        </p>

        <div class="eq" data-copy="⟨n^2⟩ = (1-r) [ r(1+r)/(1-r)^3 ] = r(1+r)/(1-r)^2.">
          <button class="copybtn" type="button">Copy</button>
          ⟨n^2⟩ = (1-r) [ r(1+r)/(1-r)^3 ] = r(1+r)/(1-r)^2.
        </div>

        <p>
          Now compute the variance:
        </p>

        <div class="eq" data-copy="Var(n) = ⟨n^2⟩ − ⟨n⟩^2 = r(1+r)/(1-r)^2 − [r/(1-r)]^2 = r/(1-r)^2.">
          <button class="copybtn" type="button">Copy</button>
          Var(n) = ⟨n^2⟩ − ⟨n⟩^2
                 = r(1+r)/(1-r)^2 − [r/(1-r)]^2
                 = r/(1-r)^2.
        </div>

        <p>
          Substitute <span class="muted">r = n̄/(1+n̄)</span> and <span class="muted">1-r = 1/(1+n̄)</span>:
        </p>

        <div class="eq" data-copy="Var(n) = [n̄/(1+n̄)] / [1/(1+n̄)]^2 = n̄(1+n̄) = n̄ + n̄^2.">
          <button class="copybtn" type="button">Copy</button>
          Var(n) = [n̄/(1+n̄)] / [1/(1+n̄)]^2 = n̄(1+n̄) = n̄ + n̄^2.
        </div>

        <p class="muted">
          This is the hallmark of thermal light: variance exceeds the mean by an extra <span class="muted">n̄²</span> term (bunching).
        </p>

        <h3>(b) Probability of zero photons in 20 ns</h3>
        <p>
          First convert the given photon flux to the mean count in the window:
          <span class="muted">n̄ = ΦT</span>.
          With <span class="muted">Φ = 1 photon/ns</span> and <span class="muted">T = 20 ns</span>,
        </p>

        <div class="eq" data-copy="n̄ = ΦT = (1 photon/ns)(20 ns) = 20.">
          <button class="copybtn" type="button">Copy</button>
          n̄ = ΦT = (1 photon/ns)(20 ns) = 20.
        </div>

        <p>
          For the BE distribution,
          <span class="muted">P(0) = (1/(1+n̄)) (n̄/(1+n̄))^0 = 1/(1+n̄)</span>.
          Therefore,
        </p>

        <div class="finalbox">
          <button class="copy-final" type="button" id="copyFinalBtn">Copy final answer</button>
          <pre class="finaltext" id="finalAnswerText">Given Φ = 1 photon/ns and T = 20 ns, the mean count is n̄ = ΦT = 20.
For Bose–Einstein (single-mode thermal) statistics:
P(0) = 1/(1+n̄) = 1/21 ≈ 0.0476 (about 4.76%).</pre>
        </div>

        <div class="callouts">
          <div class="callout assumptions">
            <strong>Sanity checks</strong>
            <ul>
              <li><strong>Units:</strong> <span class="muted">ΦT</span> → (photons/time)·(time) = photons (dimensionless count). OK.</li>
              <li><strong>Limit n̄→0:</strong> <span class="muted">P(0)=1/(1+n̄)→1</span>. Almost always empty. OK.</li>
              <li><strong>Limit n̄→∞:</strong> <span class="muted">P(0)≈1/n̄</span> (decays slowly), reflecting burstiness. OK.</li>
            </ul>
          </div>
          <div class="callout keyeq">
            <strong>Connection to the plots</strong>
            <ul>
              <li>Main plot shows <span class="muted">P(0)</span> vs time window <span class="muted">T</span> (for both BE and Poisson for comparison).</li>
              <li>Secondary plot shows the full distribution <span class="muted">P(n)</span> vs <span class="muted">n</span> for the current <span class="muted">n̄</span>.</li>
            </ul>
          </div>
        </div>
      </section>

      <section id="part4" class="card">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpreting the final formulas</h3>
        <ul>
          <li><strong>Geometric form:</strong> <span class="muted">P(n)=(1-r)r^n</span> with <span class="muted">r=n̄/(1+n̄)</span>.
            Larger <span class="muted">n̄</span> pushes <span class="muted">r</span> closer to 1, making the tail heavier (more big bursts).</li>
          <li><strong>Variance:</strong> <span class="muted">σ²=n̄+n̄²</span>. The extra <span class="muted">n̄²</span> term is the “bunching penalty”:
            fluctuations scale quadratically with mean for thermal single-mode light.</li>
          <li><strong>Zero-count probability:</strong> <span class="muted">P(0)=1/(1+n̄)</span> decreases only as <span class="muted">1/n̄</span>,
            not exponentially. That is why empty bins remain plausible even at high mean.</li>
        </ul>

        <h3>How changing parameters affects outcomes (connect to plots)</h3>
        <ul>
          <li>Increasing <span class="muted">Φ</span> or <span class="muted">T</span> increases <span class="muted">n̄=ΦT</span>.</li>
          <li>As <span class="muted">n̄</span> increases, the BE distribution broadens strongly (variance grows like <span class="muted">n̄²</span>),
              and <span class="muted">P(0)</span> decreases slowly.</li>
          <li>Compared to Poisson, thermal light has more probability at both very small counts (including 0) and very large counts:
              the hallmark of “clumping”.</li>
        </ul>

        <h3>Alternative derivation idea (brief)</h3>
        <p class="muted">
          Use the probability generating function
          <span class="muted">G(z)=∑ P(n)z^n = (1-r)/(1-rz)</span>.
          Then
          <span class="muted">⟨n⟩ = G'(1)</span> and
          <span class="muted">Var(n)=G''(1)+G'(1)−(G'(1))²</span>.
          This method generalizes neatly when you combine multiple modes.
        </p>

        <h3>Concept checks (self-test)</h3>
        <ul>
          <li><strong>Q:</strong> Why is the thermal variance larger than Poisson?<br/>
              <strong>A:</strong> Photon bunching produces correlated arrivals, adding an <span class="muted">n̄²</span> term.</li>
          <li><strong>Q:</strong> If you double the time window, what happens to <span class="muted">n̄</span>?<br/>
              <strong>A:</strong> It doubles: <span class="muted">n̄=ΦT</span>.</li>
          <li><strong>Q:</strong> For BE statistics, does <span class="muted">P(0)</span> fall exponentially with <span class="muted">T</span>?<br/>
              <strong>A:</strong> No. Since <span class="muted">P(0)=1/(1+ΦT)</span>, it falls roughly like <span class="muted">1/T</span>.</li>
          <li><strong>Q:</strong> What distribution would you expect for an ideal single-mode laser?<br/>
              <strong>A:</strong> Poisson: <span class="muted">P(n)=e^{-n̄} n̄^n/n!</span>.</li>
        </ul>
      </section>

      <section id="part5" class="card">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

        <div class="controls" aria-label="Interactive controls">
          <div class="control">
            <label>
              Photon flux Φ <span class="muted">(photons/ns)</span>
              <span class="val" id="phiVal">1.00</span>
            </label>
            <input id="phiSlider" type="range" min="0.05" max="5" step="0.05" value="1.0"/>
            <div class="small">Changes the mean as <span class="muted">n̄ = ΦT</span>.</div>
          </div>

          <div class="control">
            <label>
              Time window T <span class="muted">(ns)</span>
              <span class="val" id="tVal">20.0</span>
            </label>
            <input id="tSlider" type="range" min="1" max="60" step="0.5" value="20"/>
            <div class="small">Counts photons detected inside one time bin of duration <span class="muted">T</span>.</div>
          </div>

          <div class="control">
            <label>
              Plot max photon number n<sub>max</sub>
              <span class="val" id="nmaxVal">80</span>
            </label>
            <input id="nmaxSlider" type="range" min="20" max="200" step="5" value="80"/>
            <div class="btnrow">
              <div class="btn" id="snapBtn" title="Set controls to Φ=1, T=20 (problem values)">Use problem values</div>
              <div class="btn" id="poissonToggle" title="Toggle Poisson comparison">Poisson comparison: <span id="poisState">ON</span></div>
            </div>
          </div>
        </div>

        <div class="grid2" style="margin-top:14px;">
          <figure class="canvasWrap">
            <canvas id="diagram" aria-label="Photon counting diagram"></canvas>
          </figure>
          <div>
            <h3>What you are seeing</h3>
            <ul>
              <li><strong>Diagram (left):</strong> a light beam hits a detector that counts photons inside a chosen time gate <span class="muted">T</span>.
                  The mean count is <span class="muted">n̄=ΦT</span>.</li>
              <li><strong>Main plot (below):</strong> <span class="muted">P(0)</span> versus <span class="muted">T</span> for the current flux <span class="muted">Φ</span>.
                  Thermal (BE) falls as <span class="muted">1/(1+ΦT)</span>; Poisson falls as <span class="muted">e^{-ΦT}</span>.</li>
              <li><strong>Secondary plot:</strong> the full distribution <span class="muted">P(n)</span> versus <span class="muted">n</span> at the current <span class="muted">n̄</span>.
                  Watch how BE has a heavier tail and more weight near <span class="muted">n=0</span> than Poisson.</li>
            </ul>
          </div>
        </div>

        <div class="hr"></div>

        <figure class="canvasWrap" style="margin-bottom:14px;">
          <canvas id="plotMain" aria-label="Main plot: P(0) vs time window"></canvas>
        </figure>

        <figure class="canvasWrap">
          <canvas id="plotDist" aria-label="Secondary plot: P(n) vs n"></canvas>
        </figure>

        <div class="callouts" style="margin-top:14px;">
          <div class="callout keyeq">
            <strong>Key equations used by the plots</strong>
            <div class="eq" data-copy="n̄ = ΦT;   P_BE(0) = 1/(1+n̄);   P_Pois(0) = exp(-n̄).">
              <button class="copybtn" type="button">Copy</button>
              n̄ = ΦT;   P_BE(0) = 1/(1+n̄);   P_Pois(0) = exp(-n̄).
            </div>
          </div>
          <div class="callout pitfalls">
            <strong>Plot-reading tips</strong>
            <ul>
              <li>BE curve decreases slowly with <span class="muted">T</span> (hyperbola), Poisson decreases extremely fast (exponential).</li>
              <li>If Poisson seems “stuck at 0” for large <span class="muted">n̄</span>, that’s real: <span class="muted">e^{-n̄}</span> becomes tiny quickly.</li>
              <li>In the distribution plot, probabilities can span many orders of magnitude; the axis is linear, so very small values may look flat.</li>
            </ul>
          </div>
        </div>
      </section>
    </div>
  </main>

  <footer class="fadein">
    <div class="hr"></div>
    <p>
      Built as a self-contained learning article (vanilla HTML/CSS/JS). Interactive plots compare Bose–Einstein (thermal) and Poisson (coherent) photon counting.
    </p>
  </footer>

  <script>
    // ---------- Clipboard helpers ----------
    function copyTextToClipboard(text){
      if(navigator.clipboard && navigator.clipboard.writeText){
        navigator.clipboard.writeText(text).catch(()=>fallbackCopy(text));
      } else {
        fallbackCopy(text);
      }
    }
    function fallbackCopy(text){
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.style.position='fixed';
      ta.style.left='-9999px';
      ta.style.top='-9999px';
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      try{ document.execCommand('copy'); }catch(e){}
      document.body.removeChild(ta);
    }
    document.querySelectorAll('.eq').forEach(eq=>{
      const btn = eq.querySelector('.copybtn');
      if(!btn) return;
      btn.addEventListener('click', ()=>{
        const payload = eq.getAttribute('data-copy') || eq.innerText.replace('Copy','').trim();
        copyTextToClipboard(payload);
        btn.textContent = 'Copied!';
        setTimeout(()=>btn.textContent='Copy', 900);
      });
    });
    const copyFinalBtn = document.getElementById('copyFinalBtn');
    copyFinalBtn.addEventListener('click', ()=>{
      copyTextToClipboard(document.getElementById('finalAnswerText').innerText.trim());
      copyFinalBtn.textContent='Copied!';
      setTimeout(()=>copyFinalBtn.textContent='Copy final answer', 900);
    });

    // ---------- Math for distributions ----------
    function pBE(n, nbar){
      // P(n) = (1/(1+nbar))*(nbar/(1+nbar))^n
      if(nbar < 0) return 0;
      const denom = 1 + nbar;
      const r = (denom === 0) ? 0 : (nbar/denom);
      return (1/denom) * Math.pow(r, n);
    }
    function pPoisson(n, lambda){
      // P(n)=exp(-λ) λ^n / n!
      if(lambda < 0) return 0;
      // compute in log-space for stability when needed
      // log P = -λ + n log λ - log(n!)
      if(lambda === 0) return (n===0)?1:0;
      let logFact = 0;
      for(let k=2;k<=n;k++) logFact += Math.log(k);
      const logP = -lambda + n*Math.log(lambda) - logFact;
      return Math.exp(logP);
    }

    // ---------- Canvas utilities ----------
    function setupHiDPICanvas(canvas){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(10, Math.floor(rect.width));
      const h = Math.max(10, Math.floor(rect.height));
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {ctx, w, h, dpr};
    }

    function clear(ctx, w, h){
      ctx.clearRect(0,0,w,h);
      // background wash for contrast
      const g = ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0,'rgba(255,255,255,0.04)');
      g.addColorStop(1,'rgba(255,255,255,0.01)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);
    }

    function drawTitle(ctx, x, y, text){
      ctx.save();
      ctx.fillStyle = 'rgba(232,238,252,0.92)';
      ctx.font = '600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(text, x, y);
      ctx.restore();
    }

    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, opts={}){
      const {x, y, w, h} = box;
      const pad = opts.pad ?? 52;
      const rightPad = opts.rightPad ?? 16;
      const topPad = opts.topPad ?? 34;
      const bottomPad = opts.bottomPad ?? 46;
      const left = x + pad;
      const top = y + topPad;
      const innerW = w - pad - rightPad;
      const innerH = h - topPad - bottomPad;

      // helper: map data -> pixel
      function X(u){ return left + (u-xMin)/(xMax-xMin)*innerW; }
      function Y(v){ return top + innerH - (v-yMin)/(yMax-yMin)*innerH; }

      // grid + ticks
      const nXTicks = opts.nXTicks ?? 6;
      const nYTicks = opts.nYTicks ?? 6;

      ctx.save();
      ctx.lineWidth = 1;

      // grid
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.setLineDash([3,4]);
      for(let i=0;i<=nXTicks;i++){
        const t = xMin + (xMax-xMin)*i/nXTicks;
        const xx = X(t);
        ctx.beginPath();
        ctx.moveTo(xx, top);
        ctx.lineTo(xx, top+innerH);
        ctx.stroke();
      }
      for(let j=0;j<=nYTicks;j++){
        const t = yMin + (yMax-yMin)*j/nYTicks;
        const yy = Y(t);
        ctx.beginPath();
        ctx.moveTo(left, yy);
        ctx.lineTo(left+innerW, yy);
        ctx.stroke();
      }
      ctx.setLineDash([]);

      // axes
      ctx.strokeStyle = 'rgba(255,255,255,0.22)';
      ctx.beginPath();
      ctx.moveTo(left, top);
      ctx.lineTo(left, top+innerH);
      ctx.lineTo(left+innerW, top+innerH);
      ctx.stroke();

      // tick labels
      ctx.fillStyle = 'rgba(169,182,211,0.95)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

      function fmt(v){
        const a = Math.abs(v);
        if(a>=1000) return v.toFixed(0);
        if(a>=100) return v.toFixed(0);
        if(a>=10) return v.toFixed(1);
        if(a>=1) return v.toFixed(2);
        return v.toFixed(3);
      }

      for(let i=0;i<=nXTicks;i++){
        const t = xMin + (xMax-xMin)*i/nXTicks;
        const xx = X(t);
        ctx.beginPath();
        ctx.moveTo(xx, top+innerH);
        ctx.lineTo(xx, top+innerH+6);
        ctx.strokeStyle = 'rgba(255,255,255,0.22)';
        ctx.stroke();
        const label = fmt(t);
        ctx.fillText(label, xx - ctx.measureText(label).width/2, top+innerH+20);
      }
      for(let j=0;j<=nYTicks;j++){
        const t = yMin + (yMax-yMin)*j/nYTicks;
        const yy = Y(t);
        ctx.beginPath();
        ctx.moveTo(left-6, yy);
        ctx.lineTo(left, yy);
        ctx.strokeStyle = 'rgba(255,255,255,0.22)';
        ctx.stroke();
        const label = fmt(t);
        ctx.fillText(label, left - 10 - ctx.measureText(label).width, yy + 4);
      }

      // axis labels
      ctx.fillStyle = 'rgba(232,238,252,0.92)';
      ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(xLabel, left + innerW/2 - ctx.measureText(xLabel).width/2, top+innerH+38);

      // y label rotated
      ctx.save();
      ctx.translate(left - 40, top + innerH/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
      ctx.restore();

      ctx.restore();

      return {X, Y, left, top, innerW, innerH};
    }

    function drawLegend(ctx, items, x, y){
      ctx.save();
      ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      const pad = 10;
      const lineH = 18;

      // compute box size
      let w = 0;
      items.forEach(it=>{
        const tw = ctx.measureText(it.label).width;
        w = Math.max(w, 28 + tw);
      });
      const h = pad*2 + items.length*lineH;

      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 1;
      roundRect(ctx, x, y, w+pad*2, h, 12);
      ctx.fill();
      ctx.stroke();

      items.forEach((it, i)=>{
        const yy = y + pad + i*lineH + 6;
        ctx.strokeStyle = it.stroke;
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(x+pad, yy);
        ctx.lineTo(x+pad+18, yy);
        ctx.stroke();
        ctx.fillStyle = 'rgba(232,238,252,0.92)';
        ctx.fillText(it.label, x+pad+26, yy+4);
      });

      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    // ---------- Drawing: Diagram ----------
    function drawDiagram(){
      const canvas = document.getElementById('diagram');
      const {ctx, w, h} = setupHiDPICanvas(canvas);
      clear(ctx, w, h);
      drawTitle(ctx, 14, 22, 'Diagram: Photon counting in a time gate');

      const margin = 18;
      const x0 = margin, y0 = 34, W = w - 2*margin, H = h - 50;

      // detector box
      const detX = x0 + W*0.70, detY = y0 + H*0.24, detW = W*0.24, detH = H*0.52;
      ctx.save();
      ctx.fillStyle = 'rgba(122,162,255,0.10)';
      ctx.strokeStyle = 'rgba(122,162,255,0.35)';
      ctx.lineWidth = 2;
      roundRect(ctx, detX, detY, detW, detH, 16);
      ctx.fill(); ctx.stroke();

      // detector "window"
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      roundRect(ctx, detX+12, detY+16, detW-24, detH-32, 12);
      ctx.fill();

      // beam arrow
      const beamY = detY + detH/2;
      const beamX1 = x0 + 18;
      const beamX2 = detX - 10;

      ctx.strokeStyle = 'rgba(105,240,174,0.65)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(beamX1, beamY);
      ctx.lineTo(beamX2, beamY);
      ctx.stroke();

      // arrow head
      ctx.fillStyle = 'rgba(105,240,174,0.75)';
      ctx.beginPath();
      ctx.moveTo(beamX2, beamY);
      ctx.lineTo(beamX2-14, beamY-8);
      ctx.lineTo(beamX2-14, beamY+8);
      ctx.closePath();
      ctx.fill();

      // photons dots along beam (stylized)
      for(let i=0;i<10;i++){
        const t = i/9;
        const px = beamX1 + (beamX2-beamX1)*t + (Math.sin(i*1.7)*3);
        const py = beamY + (Math.cos(i*1.3)*6);
        ctx.fillStyle = (i%2===0) ? 'rgba(105,240,174,0.70)' : 'rgba(105,240,174,0.35)';
        ctx.beginPath();
        ctx.arc(px, py, 3.2, 0, Math.PI*2);
        ctx.fill();
      }

      // time gate bracket
      const gateX = x0 + W*0.18;
      const gateW = W*0.32;
      const gateY = y0 + H*0.78;

      ctx.strokeStyle = 'rgba(255,255,255,0.20)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(gateX, gateY);
      ctx.lineTo(gateX, gateY-18);
      ctx.moveTo(gateX, gateY);
      ctx.lineTo(gateX+gateW, gateY);
      ctx.moveTo(gateX+gateW, gateY);
      ctx.lineTo(gateX+gateW, gateY-18);
      ctx.stroke();

      // labels
      ctx.fillStyle = 'rgba(232,238,252,0.92)';
      ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('Light beam (thermal/BE stats)', beamX1, beamY-16);
      ctx.fillText('Detector', detX + detW*0.25, detY-10);

      ctx.fillStyle = 'rgba(169,182,211,0.95)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.fillText('Count photons in time window T', gateX, gateY+22);

      // show current values
      const phi = state.phi, T = state.T;
      const nbar = phi*T;
      ctx.fillStyle = 'rgba(169,182,211,0.95)';
      ctx.fillText(`Φ = ${phi.toFixed(2)} photons/ns`, x0+6, y0+18);
      ctx.fillText(`T = ${T.toFixed(1)} ns`, x0+6, y0+36);
      ctx.fillText(`n̄ = ΦT = ${nbar.toFixed(2)}`, x0+6, y0+54);

      // show P0 BE
      const p0 = 1/(1+nbar);
      ctx.fillStyle = 'rgba(255,204,102,0.90)';
      ctx.fillText(`P_BE(0) = 1/(1+n̄) = ${p0.toFixed(4)}`, x0+6, y0+72);

      ctx.restore();
    }

    // ---------- Drawing: Main Plot (P0 vs T) ----------
    function drawMainPlot(){
      const canvas = document.getElementById('plotMain');
      const {ctx, w, h} = setupHiDPICanvas(canvas);
      clear(ctx, w, h);

      const phi = state.phi;
      const showPois = state.showPoisson;

      drawTitle(ctx, 14, 22, 'Main plot: Zero-count probability P(0) vs time window T');

      const box = {x:0,y:0,w:w,h:h};
      const Tmax = 60;
      const xMin = 0, xMax = Tmax;
      const yMin = 0, yMax = 1;

      const ax = drawAxes(ctx, box, xMin, xMax, yMin, yMax, 'T (ns)', 'P(0)');

      // curves
      const N = 400;
      // BE curve
      ctx.save();
      ctx.lineWidth = 2.5;
      ctx.strokeStyle = 'rgba(255,204,102,0.95)'; // warm
      ctx.beginPath();
      for(let i=0;i<=N;i++){
        const T = xMin + (xMax-xMin)*i/N;
        const nbar = phi*T;
        const p0 = 1/(1+nbar);
        const x = ax.X(T);
        const y = ax.Y(p0);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();

      // Poisson curve (optional)
      if(showPois){
        ctx.strokeStyle = 'rgba(105,240,174,0.90)';
        ctx.beginPath();
        for(let i=0;i<=N;i++){
          const T = xMin + (xMax-xMin)*i/N;
          const nbar = phi*T;
          const p0 = Math.exp(-nbar);
          const x = ax.X(T);
          const y = ax.Y(p0);
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
      }
      ctx.restore();

      // marker at current T
      const Tcur = state.T;
      const nbarCur = phi*Tcur;
      const p0BE = 1/(1+nbarCur);
      const xC = ax.X(Tcur), yC = ax.Y(p0BE);

      ctx.save();
      ctx.fillStyle = 'rgba(255,204,102,0.95)';
      ctx.beginPath();
      ctx.arc(xC, yC, 5, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();

      // annotation text
      ctx.save();
      ctx.fillStyle = 'rgba(232,238,252,0.92)';
      ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      const info = `Current: Φ=${phi.toFixed(2)} photons/ns, T=${Tcur.toFixed(1)} ns → n̄=${nbarCur.toFixed(2)}, P_BE(0)=${p0BE.toFixed(4)}`;
      ctx.fillText(info, ax.left, ax.top - 10);
      ctx.restore();

      // legend
      const items = [
        {label:'Bose–Einstein (thermal): P(0)=1/(1+ΦT)', stroke:'rgba(255,204,102,0.95)'}
      ];
      if(showPois) items.push({label:'Poisson (coherent): P(0)=exp(-ΦT)', stroke:'rgba(105,240,174,0.90)'});
      drawLegend(ctx, items, w - 360, 40);
    }

    // ---------- Drawing: Distribution Plot (P(n) vs n) ----------
    function drawDistributionPlot(){
      const canvas = document.getElementById('plotDist');
      const {ctx, w, h} = setupHiDPICanvas(canvas);
      clear(ctx, w, h);

      const phi = state.phi, T = state.T;
      const nbar = phi*T;
      const nmax = state.nmax;
      const showPois = state.showPoisson;

      drawTitle(ctx, 14, 22, 'Secondary plot: Photon-number distribution P(n) in one time bin');

      // Determine y max for visibility (use max at n=0 for BE and Poisson)
      const p0BE = 1/(1+nbar);
      const p0P = Math.exp(-nbar);
      let yMax = Math.max(p0BE, showPois ? p0P : 0);
      // also consider peak of Poisson near nbar; approximate with sqrt normalization, but ok:
      // We'll sample to find max for plotting region.
      let ySampleMax = 0;
      for(let n=0;n<=Math.min(nmax, 250);n++){
        ySampleMax = Math.max(ySampleMax, pBE(n, nbar));
        if(showPois) ySampleMax = Math.max(ySampleMax, pPoisson(n, nbar));
      }
      yMax = Math.max(yMax, ySampleMax) * 1.15;
      yMax = Math.min(1, yMax);
      const yMin = 0;

      const box = {x:0,y:0,w:w,h:h};
      const ax = drawAxes(ctx, box, 0, nmax, yMin, yMax, 'n (photons in the bin)', 'P(n)');

      // draw BE as connected line
      ctx.save();
      ctx.lineWidth = 2.5;
      ctx.strokeStyle = 'rgba(255,204,102,0.95)';
      ctx.beginPath();
      for(let n=0;n<=nmax;n++){
        const x = ax.X(n);
        const y = ax.Y(pBE(n, nbar));
        if(n===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();

      // draw points for BE
      ctx.fillStyle = 'rgba(255,204,102,0.85)';
      for(let n=0;n<=nmax;n+=Math.max(1, Math.floor(nmax/30))){
        const x = ax.X(n);
        const y = ax.Y(pBE(n, nbar));
        ctx.beginPath();
        ctx.arc(x,y,3.3,0,Math.PI*2);
        ctx.fill();
      }

      // Poisson as line + points (optional)
      if(showPois){
        ctx.strokeStyle = 'rgba(105,240,174,0.90)';
        ctx.beginPath();
        for(let n=0;n<=nmax;n++){
          const x = ax.X(n);
          const y = ax.Y(pPoisson(n, nbar));
          if(n===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();

        ctx.fillStyle = 'rgba(105,240,174,0.78)';
        for(let n=0;n<=nmax;n+=Math.max(1, Math.floor(nmax/30))){
          const x = ax.X(n);
          const y = ax.Y(pPoisson(n, nbar));
          ctx.beginPath();
          ctx.arc(x,y,3.3,0,Math.PI*2);
          ctx.fill();
        }
      }
      ctx.restore();

      // annotate mean and variance
      const varBE = nbar + nbar*nbar;
      ctx.save();
      ctx.fillStyle = 'rgba(232,238,252,0.92)';
      ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(`Current: n̄ = ΦT = ${nbar.toFixed(2)}   |   Var_BE = n̄ + n̄² = ${varBE.toFixed(2)}   |   P_BE(0) = ${p0BE.toFixed(4)}`, ax.left, ax.top - 10);
      ctx.restore();

      // legend
      const items = [
        {label:'Bose–Einstein: P(n)=(1/(1+n̄))(n̄/(1+n̄))^n', stroke:'rgba(255,204,102,0.95)'}
      ];
      if(showPois) items.push({label:'Poisson: P(n)=e^{-n̄} n̄^n/n!', stroke:'rgba(105,240,174,0.90)'});
      drawLegend(ctx, items, w - 430, 40);
    }

    // ---------- State + UI ----------
    const state = {
      phi: 1.0,
      T: 20.0,
      nmax: 80,
      showPoisson: true
    };

    const phiSlider = document.getElementById('phiSlider');
    const tSlider = document.getElementById('tSlider');
    const nmaxSlider = document.getElementById('nmaxSlider');

    const phiVal = document.getElementById('phiVal');
    const tVal = document.getElementById('tVal');
    const nmaxVal = document.getElementById('nmaxVal');
    const poisState = document.getElementById('poisState');

    function syncUI(){
      phiVal.textContent = Number(state.phi).toFixed(2);
      tVal.textContent = Number(state.T).toFixed(1);
      nmaxVal.textContent = String(state.nmax);
      poisState.textContent = state.showPoisson ? 'ON' : 'OFF';

      // update final answer box live to reflect current Φ and T (while still showing the "problem" result when set)
      const nbar = state.phi * state.T;
      const p0 = 1/(1+nbar);
      const final = `Given Φ = ${state.phi.toFixed(2)} photon/ns and T = ${state.T.toFixed(1)} ns, the mean count is n̄ = ΦT = ${nbar.toFixed(2)}.
For Bose–Einstein (single-mode thermal) statistics:
P(0) = 1/(1+n̄) = 1/${(1+nbar).toFixed(2)} ≈ ${p0.toFixed(4)} (${(p0*100).toFixed(2)}%).`;
      document.getElementById('finalAnswerText').innerText = final;
    }

    function redrawAll(){
      syncUI();
      drawDiagram();
      drawMainPlot();
      drawDistributionPlot();
    }

    phiSlider.addEventListener('input', ()=>{
      state.phi = Number(phiSlider.value);
      redrawAll();
    });
    tSlider.addEventListener('input', ()=>{
      state.T = Number(tSlider.value);
      redrawAll();
    });
    nmaxSlider.addEventListener('input', ()=>{
      state.nmax = Number(nmaxSlider.value);
      redrawAll();
    });

    document.getElementById('snapBtn').addEventListener('click', ()=>{
      state.phi = 1.0;
      state.T = 20.0;
      phiSlider.value = String(state.phi);
      tSlider.value = String(state.T);
      redrawAll();
    });

    document.getElementById('poissonToggle').addEventListener('click', ()=>{
      state.showPoisson = !state.showPoisson;
      redrawAll();
    });

    // ---------- Responsive redraw (ResizeObserver) ----------
    const ro = new ResizeObserver(()=>{
      redrawAll();
    });
    ['diagram','plotMain','plotDist'].forEach(id=>ro.observe(document.getElementById(id)));

    // initial draw
    redrawAll();
  </script>
</body>
</html>
