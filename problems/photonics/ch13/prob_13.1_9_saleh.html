<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Levitation by Light Pressure — Hydrogen Atom vs Gravity</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101a33;
      --card:#0f1830;
      --text:#eaf0ff;
      --muted:#b7c3e6;
      --faint:#7f8bb3;
      --accent:#7cf2c7;
      --accent2:#7aa7ff;
      --warn:#ffd08a;
      --bad:#ff7a7a;
      --ok:#7cf2c7;
      --line:rgba(255,255,255,.10);
      --shadow: 0 16px 40px rgba(0,0,0,.45);
      --radius:18px;
      --radius2:24px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(122,167,255,.18), transparent 60%),
        radial-gradient(900px 600px at 80% 0%, rgba(124,242,199,.12), transparent 55%),
        radial-gradient(900px 700px at 70% 90%, rgba(255,208,138,.10), transparent 60%),
        linear-gradient(180deg, #070a14, var(--bg));
      line-height:1.55;
      overflow-x:hidden;
    }
    a{color:var(--accent2); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:28px 18px 14px;
      position:relative;
    }
    .wrap{
      width:min(1200px, 92vw);
      margin:0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap:18px;
      align-items:start;
    }
    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--radius2);
      padding:22px 22px 18px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .titleCard:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(700px 240px at 35% 0%, rgba(124,242,199,.18), transparent 60%),
                  radial-gradient(600px 240px at 70% 10%, rgba(122,167,255,.18), transparent 55%);
      pointer-events:none;
      filter: blur(1px);
      opacity:.7;
    }
    .titleCard > *{position:relative}
    h1{
      font-size: clamp(1.65rem, 2.1vw + 1rem, 2.45rem);
      margin:0 0 8px;
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      margin:0 0 14px;
      max-width: 68ch;
    }
    .metaRow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      margin-top:10px;
    }
    .pill{
      border:1px solid var(--line);
      background: rgba(16,26,51,.55);
      padding:7px 10px;
      border-radius:999px;
      color:var(--muted);
      font-size:.92rem;
      display:flex;
      gap:8px;
      align-items:center;
      backdrop-filter: blur(6px);
    }
    .dot{
      width:8px; height:8px; border-radius:999px;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(124,242,199,.12);
    }
    .sideCard{
      position:sticky;
      top:14px;
      background: rgba(16,26,51,.62);
      border:1px solid var(--line);
      border-radius: var(--radius2);
      padding:16px 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .tocTitle{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .tocTitle h2{
      font-size:1.02rem;
      margin:0;
      color:var(--text);
    }
    .toc{
      margin:0;
      padding-left:18px;
      color:var(--muted);
      font-size:.95rem;
    }
    .toc li{margin:8px 0}
    .toc a{color:var(--muted)}
    .toc a:hover{color:var(--text)}
    main{
      padding: 8px 18px 44px;
    }
    section{
      margin-top:18px;
      background: rgba(16,26,51,.45);
      border:1px solid var(--line);
      border-radius: var(--radius2);
      padding: 18px 18px;
      box-shadow: 0 10px 26px rgba(0,0,0,.28);
    }
    section h2{
      margin:0 0 10px;
      font-size:1.35rem;
      letter-spacing:.15px;
    }
    section h3{
      margin:16px 0 8px;
      font-size:1.12rem;
      color:var(--text);
    }
    p{margin: 8px 0; color: var(--text)}
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      align-items:start;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:14px;
      align-items:start;
    }
    .callout{
      border-radius: var(--radius);
      border:1px solid var(--line);
      background: rgba(15,24,48,.70);
      padding: 14px 14px 12px;
      position:relative;
      overflow:hidden;
    }
    .callout:before{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(800px 220px at 20% 0%, rgba(122,167,255,.14), transparent 60%);
      opacity:.7;
      pointer-events:none;
    }
    .callout > *{position:relative}
    .calloutTitle{
      display:flex; align-items:center; gap:10px;
      margin:0 0 8px;
      font-weight:650;
    }
    .badge{
      font-size:.82rem;
      padding:3px 9px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      color:var(--muted);
    }
    ul{margin:8px 0 8px 20px; color:var(--muted)}
    li{margin:6px 0}
    code, .eq{
      font-family:var(--mono);
      font-size:.95rem;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      padding:2px 7px;
      border-radius:10px;
      color:#f0f5ff;
    }
    .eqBlock{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
      padding: 10px 12px;
      border-radius: var(--radius);
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      margin:10px 0;
    }
    .copyBtn{
      cursor:pointer;
      user-select:none;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:8px 10px;
      border-radius:12px;
      font-size:.9rem;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      white-space:nowrap;
    }
    .copyBtn:hover{transform: translateY(-1px); background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.22)}
    .copyBtn:active{transform: translateY(0px) scale(.99)}
    .kpiRow{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:12px;
      margin-top: 8px;
    }
    .kpi{
      padding: 12px 12px 10px;
      border-radius: var(--radius);
      background: rgba(15,24,48,.72);
      border:1px solid var(--line);
    }
    .kpi .label{color:var(--muted); font-size:.9rem}
    .kpi .value{font-size:1.12rem; font-weight:700; margin-top:4px}
    .kpi .note{color:var(--faint); font-size:.85rem; margin-top:4px}
    .vizCard{
      border-radius: var(--radius2);
      border:1px solid var(--line);
      background: rgba(15,24,48,.60);
      padding: 14px;
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
      overflow:hidden;
    }
    .vizTop{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-bottom:10px;
    }
    .vizTop h3{margin:0; font-size:1.06rem}
    .controls{
      display:flex; flex-wrap:wrap; gap:10px; align-items:center;
      color:var(--muted);
      font-size:.93rem;
    }
    .control{
      display:flex; gap:8px; align-items:center;
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      padding:8px 10px;
      border-radius: 14px;
    }
    input[type="range"]{width: 190px}
    select, input[type="number"]{
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.14);
      color: var(--text);
      border-radius: 10px;
      padding:6px 8px;
      font-family: var(--sans);
      outline:none;
    }
    .canvasWrap{
      width:100%;
      aspect-ratio: 16/9;
      min-height: 260px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      overflow:hidden;
    }
    canvas{width:100%; height:100%; display:block}
    .small{
      font-size:.95rem;
      color: var(--muted);
    }
    .finalBox{
      border:1px solid rgba(124,242,199,.28);
      background: linear-gradient(180deg, rgba(124,242,199,.12), rgba(124,242,199,.06));
    }
    .warnBox{
      border:1px solid rgba(255,208,138,.30);
      background: linear-gradient(180deg, rgba(255,208,138,.12), rgba(255,208,138,.06));
    }
    .mistBox{
      border:1px solid rgba(255,122,122,.30);
      background: linear-gradient(180deg, rgba(255,122,122,.12), rgba(255,122,122,.06));
    }
    footer{
      padding: 22px 18px 36px;
      color: var(--muted);
    }
    .printHint{color:var(--faint); font-size:.9rem}

    @media (max-width: 980px){
      .hero{grid-template-columns: 1fr}
      .sideCard{position:relative; top:auto}
      .kpiRow{grid-template-columns: 1fr 1fr}
      .grid2{grid-template-columns: 1fr}
      .grid3{grid-template-columns: 1fr}
    }
    @media print{
      body{background:#fff; color:#000}
      header, footer{page-break-inside:avoid}
      .sideCard{display:none}
      section{box-shadow:none}
      .copyBtn, .controls{display:none}
      .canvasWrap{border:1px solid #aaa}
      code,.eq{border:1px solid #aaa; background:#f5f5f5; color:#000}
    }

    /* subtle motion */
    @keyframes floatIn{
      from{transform: translateY(8px); opacity:0}
      to{transform: translateY(0); opacity:1}
    }
    section{animation: floatIn .35s ease both}
    section:nth-of-type(2){animation-delay:.04s}
    section:nth-of-type(3){animation-delay:.08s}
    section:nth-of-type(4){animation-delay:.12s}
  </style>
</head>

<body>
<header>
  <div class="wrap hero">
    <div class="titleCard">
      <h1>Levitation by Light Pressure: Can Photons Hold Up a Hydrogen Atom?</h1>
      <p class="subtitle">
        We compare the downward gravitational force on a single hydrogen atom near Earth’s surface
        with the upward force from a laser beam when photon momentum is transferred to the atom.
        The punchline: only a few dozen 1-eV photons per second (under idealized conditions) can balance gravity.
      </p>
      <div class="metaRow">
        <div class="pill"><span class="dot"></span><span>Topic: radiation pressure &amp; momentum</span></div>
        <div class="pill"><span class="dot" style="background:var(--accent2)"></span><span>Level: intro modern physics</span></div>
        <div class="pill"><span class="dot" style="background:var(--warn)"></span><span>Idealized: perfect momentum transfer</span></div>
      </div>
    </div>

    <aside class="sideCard" aria-label="Table of contents">
      <div class="tocTitle">
        <h2>Table of Contents</h2>
        <span class="badge">sticky</span>
      </div>
      <ol class="toc">
        <li><a href="#quick">Quick Summary</a></li>
        <li><a href="#part0">PART 0 — Concept Primer</a></li>
        <li><a href="#part1">PART 1 — Problem Analysis</a></li>
        <li><a href="#part2">PART 2 — Strategy &amp; Tips</a></li>
        <li><a href="#part3">PART 3 — Full Solution</a></li>
        <li><a href="#part4">PART 4 — Deeper Understanding</a></li>
        <li><a href="#part5">PART 5 — Visualization Guide</a></li>
      </ol>
    </aside>
  </div>
</header>

<main class="wrap">
  <section id="quick">
    <h2>Quick Summary</h2>
    <ul>
      <li><b>What it’s about:</b> balancing gravity on a single hydrogen atom with <b>light pressure</b> from a laser beam.</li>
      <li><b>Key idea:</b> photons carry momentum; transferring that momentum produces a force <code>F = (Δp)/(Δt)</code>.</li>
      <li><b>Photon momentum:</b> for a photon of energy <code>Eγ</code>, <code>pγ = Eγ / c</code> (in vacuum).</li>
      <li><b>Gravity:</b> near Earth, the weight is <code>Fg = m g</code>.</li>
      <li><b>Absorption case:</b> if each photon’s full momentum is delivered (absorbed), average force from rate <code>R</code> is <code>F = R (Eγ/c)</code>.</li>
      <li><b>Reflection case:</b> perfect reflection doubles momentum transfer: <code>F = R (2Eγ/c)</code>.</li>
      <li><b>Numeric results for 1-eV photons (ideal):</b> need about <b>31 photons/s</b> (absorbing) or <b>15 photons/s</b> (reflecting) to hold up a hydrogen atom; corresponding powers are <b>4.9×10⁻¹⁸ W</b> or <b>2.45×10⁻¹⁸ W</b>.</li>
    </ul>
  </section>

  <section id="part0">
    <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

    <div class="grid2">
      <article class="callout">
        <div class="calloutTitle"><span class="badge">Core definitions</span>Radiation pressure &amp; photon momentum</div>
        <p class="muted">
          Light is electromagnetic radiation. Even though photons are massless, they carry
          <b>energy</b> and <b>momentum</b>. When light interacts with matter, momentum exchange produces a mechanical force.
        </p>

        <ul>
          <li><b>Photon energy</b> <code>Eγ</code> (joules, J). Often given in eV: <code>1 eV = 1.602×10⁻¹⁹ J</code>.</li>
          <li><b>Speed of light</b> <code>c ≈ 2.998×10⁸ m/s</code> (vacuum).</li>
          <li><b>Photon momentum</b> <code>pγ = Eγ / c</code> (kg·m/s).</li>
          <li><b>Force</b> is momentum transfer per time: <code>F = Δp / Δt</code> (newtons, N).</li>
          <li><b>Photon rate</b> <code>R</code> = photons per second (s⁻¹).</li>
          <li><b>Optical power</b> <code>P = R Eγ</code> (watts, W = J/s).</li>
        </ul>
      </article>

      <article class="callout">
        <div class="calloutTitle"><span class="badge">Physical meaning</span>What does “momentum transfer” mean?</div>
        <p class="muted">
          Think of a photon as a tiny “packet” that pushes when it is <b>absorbed</b> or <b>reflected</b>.
        </p>
        <ul>
          <li><b>Absorption:</b> photon goes away; atom gains approximately <code>+pγ</code> upward. So <code>Δp ≈ pγ</code> per photon.</li>
          <li><b>Perfect reflection:</b> photon reverses direction; momentum change is about <code>Δp ≈ 2pγ</code> delivered to the atom.</li>
        </ul>
        <p class="muted">
          In real life, atoms don’t act like mirrors and momentum transfer depends on scattering, internal states,
          recoil, saturation, and beam geometry. This problem explicitly asks for <b>ideal conditions</b>.
        </p>
      </article>
    </div>

    <div class="grid2">
      <article class="callout warnBox">
        <div class="calloutTitle"><span class="badge">Validity &amp; assumptions</span>When are these formulas valid?</div>
        <ul>
          <li>We assume <b>vacuum</b> so photon momentum is <code>Eγ/c</code> without refractive-index corrections.</li>
          <li>We assume <b>full momentum transfer</b> to the atom (every photon hits and transfers the intended momentum).</li>
          <li>We ignore <b>thermal motion</b>, <b>quantum state dynamics</b>, and <b>beam divergence</b>.</li>
          <li>Gravity is taken constant at sea level: <code>g = 9.8 m/s²</code>.</li>
        </ul>
      </article>

      <article class="callout mistBox">
        <div class="calloutTitle"><span class="badge">What to watch for</span>Common pitfalls</div>
        <ul>
          <li>Mixing up <b>energy</b> and <b>momentum</b>: use <code>pγ = Eγ/c</code>, not <code>Eγ</code> itself.</li>
          <li>Forgetting unit conversions: <code>1 eV = 1.602×10⁻¹⁹ J</code>.</li>
          <li>Confusing absorption vs reflection: reflection doubles <code>Δp</code>.</li>
          <li>Forgetting that force depends on <b>rate</b>: <code>F = R Δp</code>.</li>
        </ul>
      </article>
    </div>

    <h3>Mini intuition examples (quick)</h3>
    <ul>
      <li>If you double the photon energy <code>Eγ</code>, each photon carries double momentum, so you need roughly <b>half</b> as many photons per second to get the same force.</li>
      <li>If the target reflects perfectly instead of absorbing, each photon delivers about twice the momentum, so the required photon rate halves again.</li>
    </ul>
  </section>

  <section id="part1">
    <h2>PART 1 — Problem Analysis (No solving yet)</h2>

    <h3>Restating the problem</h3>
    <p class="muted">
      A hydrogen atom (mass <code>m = 1.67×10⁻²⁷ kg</code>) is near Earth’s surface.
      (a) Find its gravitational force (weight). (b) A vertical laser emits photons of energy 1 eV;
      if one photon hits per second and transfers its full momentum to the atom, find the average upward force.
      (c) Find the photon rate and optical power needed to exactly balance gravity (no falling) in ideal vacuum conditions.
      (d) Repeat (c) if the atom were perfectly reflecting.
    </p>

    <div class="grid2">
      <div class="callout">
        <div class="calloutTitle"><span class="badge">Given</span>Known quantities</div>
        <ul>
          <li>Hydrogen atom mass: <code>m = 1.67×10⁻²⁷ kg</code></li>
          <li>Gravitational acceleration: <code>g = 9.8 m/s²</code></li>
          <li>Photon energy (for parts b–d): <code>Eγ = 1 eV = 1.602×10⁻¹⁹ J</code></li>
          <li>Speed of light: <code>c = 2.998×10⁸ m/s</code></li>
        </ul>
      </div>

      <div class="callout">
        <div class="calloutTitle"><span class="badge">Unknowns</span>What we must find</div>
        <ul>
          <li>(a) Weight: <code>Fg</code> (N)</li>
          <li>(b) Force from 1 photon/s: <code>F1</code> (N)</li>
          <li>(c) Required photon rate: <code>Rabs</code> (s⁻¹) and power <code>Pabs</code> (W)</li>
          <li>(d) Required photon rate: <code>Rref</code> (s⁻¹) and power <code>Pref</code> (W)</li>
        </ul>
      </div>
    </div>

    <h3>Relevant principles (and why)</h3>
    <ul>
      <li><b>Newtonian weight:</b> near Earth, gravitational force on a small mass is <code>Fg = m g</code>. Applicable because speeds are nonrelativistic and near-surface gravity is approximately uniform.</li>
      <li><b>Photon momentum:</b> in vacuum <code>pγ = Eγ / c</code>. Applicable because photons are free-space laser photons.</li>
      <li><b>Force as momentum flux:</b> average force is momentum transferred per unit time: <code>F = R Δp</code>. Applicable because we are counting photon impacts per second.</li>
    </ul>
    <p class="muted">
      We do <b>not</b> need Maxwell stress-tensor machinery or detailed atomic scattering models because the problem states idealized full momentum transfer and asks for average forces.
    </p>

    <div class="callout warnBox">
      <div class="calloutTitle"><span class="badge">Assumptions</span>Explicit idealizations</div>
      <ul>
        <li>Laser is perfectly aligned upward; all momentum transfer is vertical.</li>
        <li>Every photon hits the atom and transfers the stated momentum (no misses, no partial scattering).</li>
        <li>For part (d), “perfectly reflecting” means photon reverses direction, giving <code>Δp = 2pγ</code>.</li>
        <li>Ignore recoil-induced Doppler shifts and internal excitation dynamics.</li>
      </ul>
    </div>

    <h3>Possible approaches (choose &amp; compare)</h3>
    <ul>
      <li><b>Momentum-per-photon approach (best here):</b> compute <code>pγ = Eγ/c</code>, then <code>F = RΔp</code>. Fast, transparent, directly matches the statement “full momentum transfer.”</li>
      <li><b>Radiation pressure approach:</b> use <code>P = I/c</code> (absorption) or <code>2I/c</code> (reflection) and multiply by area. Not ideal here because the atom’s effective area is not provided; the problem gives photon counting instead.</li>
      <li><b>Energy–momentum 4-vector approach:</b> relativistically elegant but unnecessary for these small, nonrelativistic forces.</li>
    </ul>
    <p><b>We choose the momentum-per-photon approach</b> because it uses only the given photon energy and the stated “one photon per second” condition.</p>
  </section>

  <section id="part2">
    <h2>PART 2 — Strategy &amp; Tips (Roadmap only)</h2>
    <ol class="muted">
      <li><b>Compute weight</b>: use <code>Fg = m g</code>. <i>Meaning:</i> constant downward force to be balanced.</li>
      <li><b>Convert photon energy</b>: <code>Eγ (J) = (Eγ in eV) × 1.602×10⁻¹⁹</code>. <i>Meaning:</i> put energy in SI so force comes out in newtons.</li>
      <li><b>Find photon momentum</b>: <code>pγ = Eγ/c</code>. <i>Meaning:</i> momentum carried by each photon.</li>
      <li><b>Part (b) force from one photon each second</b>: <code>F1 = pγ / 1s</code>. <i>Meaning:</i> average push from a single-photon-per-second “momentum drip.”</li>
      <li><b>Balance gravity (absorption)</b>: set <code>Fg = Rabs pγ</code> and solve for <code>Rabs</code>. <i>Meaning:</i> photon arrival rate required to hover.</li>
      <li><b>Compute power (absorption)</b>: <code>Pabs = Rabs Eγ</code>. <i>Meaning:</i> energy per time carried by those photons.</li>
      <li><b>Repeat for reflection</b>: replace <code>Δp</code> by <code>2pγ</code>, so <code>Rref = Fg/(2pγ)</code> and <code>Pref = Rref Eγ</code>.</li>
      <li><b>Sanity checks</b>: confirm units, direction (up vs down), and scaling with <code>Eγ</code>.</li>
    </ol>

    <div class="callout mistBox">
      <div class="calloutTitle"><span class="badge">Quick tips</span>Avoid these mistakes</div>
      <ul>
        <li>Don’t use <code>p = E</code>. The correct relation is <code>p = E/c</code>.</li>
        <li>Don’t forget the eV→J conversion.</li>
        <li>Reflection doubles momentum transfer but does <b>not</b> change photon energy; power changes because the needed rate changes.</li>
      </ul>
    </div>
  </section>

  <section id="part3">
    <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

    <h3>Physical intuition before calculating</h3>
    <p class="muted">
      A hydrogen atom is extremely light, so its weight is tiny. A photon’s momentum is also tiny,
      but if you deliver photons steadily, the momentum transfer per second becomes a measurable (though still tiny) force.
      Because <code>pγ = Eγ/c</code>, higher-energy photons push more per photon, so fewer are needed per second.
    </p>

    <article class="callout">
      <div class="calloutTitle"><span class="badge">Key equations</span>Use these throughout</div>

      <div class="eqBlock">
        <div><span class="eq">Fg = m g</span> <span class="muted"> (weight near Earth)</span></div>
        <button class="copyBtn" data-copy="Fg = m g">Copy</button>
      </div>

      <div class="eqBlock">
        <div><span class="eq">pγ = Eγ / c</span> <span class="muted"> (photon momentum in vacuum)</span></div>
        <button class="copyBtn" data-copy="pγ = Eγ / c">Copy</button>
      </div>

      <div class="eqBlock">
        <div><span class="eq">F = R Δp</span> <span class="muted"> (average force from momentum transfer rate)</span></div>
        <button class="copyBtn" data-copy="F = R Δp">Copy</button>
      </div>
    </article>

    <h3>(a) Gravitational force on the hydrogen atom</h3>
    <p>
      Define:
      <code>m = 1.67×10⁻²⁷ kg</code>, <code>g = 9.8 m/s²</code>.
      The gravitational force magnitude is
      <code>Fg = m g</code> downward.
    </p>

    <div class="eqBlock">
      <div class="muted">
        <span class="eq">Fg = (1.67×10⁻²⁷ kg)(9.8 m/s²) = 1.64×10⁻²⁶ N</span>
        <span class="muted"> (downward)</span>
      </div>
      <button class="copyBtn" data-copy="Fg = 1.64×10^-26 N (downward)">Copy</button>
    </div>

    <p class="muted">
      <b>What we did:</b> multiplied mass by gravitational acceleration. This is the constant force we must counteract with light.
    </p>

    <h3>(b) Upward force from one 1-eV photon per second (full momentum transfer)</h3>
    <p>
      Photon energy:
      <code>Eγ = 1 eV = 1.602×10⁻¹⁹ J</code>.
      In vacuum, photon momentum is
      <code>pγ = Eγ / c</code>.
    </p>

    <div class="eqBlock">
      <div class="muted">
        <span class="eq">pγ = (1.602×10⁻¹⁹ J)/(2.998×10⁸ m/s) = 5.34×10⁻²⁸ kg·m/s</span>
      </div>
      <button class="copyBtn" data-copy="pγ = 5.34×10^-28 kg·m/s (for Eγ = 1 eV)">Copy</button>
    </div>

    <p>
      If one photon strikes each second and transfers its full momentum to the atom (absorption-like case),
      the average force is
      <code>F1 = pγ / (1 s)</code>.
    </p>

    <div class="eqBlock">
      <div class="muted">
        <span class="eq">F1 = 5.34×10⁻²⁸ N</span> <span class="muted">(upward)</span>
      </div>
      <button class="copyBtn" data-copy="F1 = 5.34×10^-28 N (upward, 1 photon/s of 1 eV)">Copy</button>
    </div>

    <p class="muted">
      <b>Interpretation:</b> one photon per second is far too small to balance <code>Fg ≈ 1.64×10⁻²⁶ N</code>—we need tens of photons per second for 1-eV photons.
    </p>

    <h3>(c) Photon rate and optical power needed to prevent falling (ideal absorption case)</h3>
    <p>
      Let <code>Rabs</code> be the required photon rate (photons/s). Each photon delivers momentum <code>Δp = pγ</code>.
      The upward force is
      <code>Fup = Rabs pγ</code>.
      For levitation (no falling), set <code>Fup = Fg</code>:
    </p>

    <div class="eqBlock">
      <div class="muted">
        <span class="eq">Fg = Rabs (Eγ/c)  ⇒  Rabs = (Fg c)/Eγ</span>
      </div>
      <button class="copyBtn" data-copy="Rabs = (Fg c)/Eγ">Copy</button>
    </div>

    <p>
      Now plug numbers: <code>Fg = 1.64×10⁻²⁶ N</code>, <code>c = 2.998×10⁸ m/s</code>, <code>Eγ = 1.602×10⁻¹⁹ J</code>.
    </p>

    <div class="eqBlock">
      <div class="muted">
        <span class="eq">Rabs = (1.64×10⁻²⁶ × 2.998×10⁸)/(1.602×10⁻¹⁹) = 3.06×10¹ ≈ 31 photons/s</span>
      </div>
      <button class="copyBtn" data-copy="Rabs ≈ 31 photons/s (absorbing, Eγ = 1 eV)">Copy</button>
    </div>

    <p>
      The corresponding optical power is energy per time:
      <code>Pabs = Rabs Eγ</code>.
    </p>

    <div class="eqBlock">
      <div class="muted">
        <span class="eq">Pabs = (30.6 s⁻¹)(1.602×10⁻¹⁹ J) = 4.91×10⁻¹⁸ W</span>
      </div>
      <button class="copyBtn" data-copy="Pabs = 4.91×10^-18 W (absorbing, Eγ = 1 eV)">Copy</button>
    </div>

    <h3>(d) Photon rate if the atom is perfectly reflecting</h3>
    <p>
      Perfect reflection reverses the photon’s momentum, doubling momentum transfer to the atom:
      <code>Δp = 2pγ = 2Eγ/c</code>.
      Thus
      <code>Fg = Rref (2Eγ/c)</code>, so:
    </p>

    <div class="eqBlock">
      <div class="muted">
        <span class="eq">Rref = (Fg c)/(2Eγ) = Rabs/2</span>
      </div>
      <button class="copyBtn" data-copy="Rref = (Fg c)/(2Eγ) = Rabs/2">Copy</button>
    </div>

    <p>
      Numerically (for 1 eV):
    </p>

    <div class="eqBlock">
      <div class="muted">
        <span class="eq">Rref = 30.6/2 = 15.3 photons/s</span>
      </div>
      <button class="copyBtn" data-copy="Rref ≈ 15.3 photons/s (perfect reflection, Eγ = 1 eV)">Copy</button>
    </div>

    <p>
      Power is <code>Pref = Rref Eγ</code>:
    </p>

    <div class="eqBlock">
      <div class="muted">
        <span class="eq">Pref = (15.3 s⁻¹)(1.602×10⁻¹⁹ J) = 2.45×10⁻¹⁸ W</span>
      </div>
      <button class="copyBtn" data-copy="Pref = 2.45×10^-18 W (perfect reflection, Eγ = 1 eV)">Copy</button>
    </div>

    <div class="callout finalBox">
      <div class="calloutTitle"><span class="badge">Final answers</span>All parts (numeric)</div>
      <div class="eqBlock">
        <div class="muted">
          <span class="eq">
            (a) Fg = 1.64×10⁻²⁶ N downward
            | (b) F(1 photon/s) = 5.34×10⁻²⁸ N upward
            | (c) Rabs ≈ 31 photons/s, Pabs = 4.91×10⁻¹⁸ W
            | (d) Rref ≈ 15.3 photons/s, Pref = 2.45×10⁻¹⁸ W
          </span>
        </div>
        <button class="copyBtn" data-copy="(a) Fg = 1.64×10^-26 N downward
(b) F(1 photon/s, 1 eV) = 5.34×10^-28 N upward
(c) Absorbing: R ≈ 31 photons/s, P = 4.91×10^-18 W
(d) Reflecting: R ≈ 15.3 photons/s, P = 2.45×10^-18 W">Copy</button>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><b>Units:</b> <code>m g</code> gives N. <code>E/c</code> gives momentum (N·s), and multiplying by rate (s⁻¹) returns N.</li>
        <li><b>Scaling:</b> required rate <code>R ∝ 1/Eγ</code>. Higher-energy photons reduce the needed photon count.</li>
        <li><b>Direction:</b> gravity is downward; laser is upward, so levitation means setting upward force equal to <code>Fg</code>.</li>
        <li><b>Reflection:</b> doubling momentum transfer halves required photon rate and halves required power.</li>
      </ul>
    </div>

    <p class="muted">
      Connection to the diagram &amp; plots below: the diagram shows a vertical laser pushing up against gravity,
      while the plots show how the required photon rate and power vary with photon energy and interaction type.
    </p>
  </section>

  <section id="part4">
    <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

    <h3>Reinterpreting the formulas</h3>
    <div class="grid2">
      <div class="callout">
        <div class="calloutTitle"><span class="badge">Absorption</span>Hover condition</div>
        <p class="muted">
          For absorption-like transfer:
        </p>
        <div class="eqBlock">
          <div class="muted"><span class="eq">Rabs = (m g c)/Eγ</span></div>
          <button class="copyBtn" data-copy="Rabs = (m g c)/Eγ">Copy</button>
        </div>
        <ul>
          <li><code>m</code> larger → heavier → higher required rate.</li>
          <li><code>g</code> larger → stronger gravity → higher rate.</li>
          <li><code>Eγ</code> larger → more momentum per photon → lower rate.</li>
          <li><code>c</code> sets the energy-to-momentum conversion scale.</li>
        </ul>
      </div>

      <div class="callout">
        <div class="calloutTitle"><span class="badge">Power</span>Why does power scale simply?</div>
        <p class="muted">
          Multiply the required rate by energy:
        </p>
        <div class="eqBlock">
          <div class="muted"><span class="eq">Pabs = Rabs Eγ = m g c</span></div>
          <button class="copyBtn" data-copy="Pabs = m g c (absorption)">Copy</button>
        </div>
        <p class="muted">
          Notice something striking: in this idealized photon-counting model,
          the <b>required power for absorption does not depend on photon energy</b>!
          Higher-energy photons push more but you need fewer of them; the product cancels.
        </p>
        <div class="eqBlock">
          <div class="muted"><span class="eq">Pref = (m g c)/2</span></div>
          <button class="copyBtn" data-copy="Pref = (m g c)/2 (perfect reflection)">Copy</button>
        </div>
        <p class="muted">
          Perfect reflection halves the required power because each photon transfers twice the momentum.
        </p>
      </div>
    </div>

    <h3>How changing parameters affects outcomes (tie to plots)</h3>
    <ul>
      <li>Increasing photon energy <code>Eγ</code> slides the <b>required photon rate</b> curve downward as <code>1/Eγ</code>.</li>
      <li>In this ideal model, <b>power stays flat</b> vs <code>Eγ</code> (absorption) and is flat at half that value for reflection.</li>
      <li>Increasing the mass <code>m</code> scales both required rate and power upward linearly.</li>
    </ul>

    <h3>Alternative derivation idea (brief)</h3>
    <p class="muted">
      Instead of counting photons, you can use radiation pressure:
      intensity <code>I</code> carries momentum flux <code>I/c</code> (absorption) or <code>2I/c</code> (reflection),
      and force is <code>F = (I A)/c</code>. But you would need an effective interaction area <code>A</code>,
      which this problem avoids by giving a photon rate directly.
    </p>

    <h3>Concept check (self-test)</h3>
    <ul>
      <li><b>Q:</b> If photon energy doubles, what happens to required photon rate (absorption)? <b>A:</b> It halves because <code>R ∝ 1/Eγ</code>.</li>
      <li><b>Q:</b> In the ideal model, does required power depend on photon energy? <b>A:</b> No; <code>Pabs = m g c</code> (absorption).</li>
      <li><b>Q:</b> Why does reflection help? <b>A:</b> Momentum change is ~<code>2pγ</code> instead of <code>pγ</code>, doubling force at fixed rate.</li>
      <li><b>Q:</b> What real-world effects could break the ideal model? <b>A:</b> Finite scattering cross-section, missed photons, internal atomic transitions, recoil heating, beam divergence.</li>
    </ul>
  </section>

  <section id="part5">
    <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

    <div class="vizCard" aria-label="Interactive visualizations">
      <div class="vizTop">
        <h3>Interactive: Atom + Laser Diagram, Required Photon Rate, and Power vs Photon Energy</h3>
        <div class="controls">
          <div class="control">
            <label for="Eev"><b>Photon energy</b> Eγ (eV)</label>
            <input id="Eev" type="range" min="0.1" max="5.0" step="0.1" value="1.0" />
            <span id="Eread" class="badge">1.0 eV</span>
          </div>
          <div class="control">
            <label for="mode"><b>Interaction</b></label>
            <select id="mode">
              <option value="abs">Absorb (Δp = p)</option>
              <option value="ref">Reflect (Δp = 2p)</option>
            </select>
          </div>
          <div class="control">
            <label for="mScale"><b>Mass scale</b> ×</label>
            <input id="mScale" type="number" min="0.1" max="1000" step="0.1" value="1.0" />
            <span class="badge">relative to H atom</span>
          </div>
        </div>
      </div>

      <div class="grid3">
        <div>
          <div class="small muted">Diagram (geometry &amp; forces)</div>
          <div class="canvasWrap"><canvas id="cDiagram"></canvas></div>
        </div>
        <div>
          <div class="small muted">Main plot: required photon rate R(Eγ)</div>
          <div class="canvasWrap"><canvas id="cMain"></canvas></div>
        </div>
        <div>
          <div class="small muted">Secondary plot: required optical power P(Eγ)</div>
          <div class="canvasWrap"><canvas id="cSecondary"></canvas></div>
        </div>
      </div>

      <div class="kpiRow" aria-label="Live computed values">
        <div class="kpi">
          <div class="label">Weight Fg</div>
          <div class="value" id="kFg">—</div>
          <div class="note">downward</div>
        </div>
        <div class="kpi">
          <div class="label">Photon momentum pγ</div>
          <div class="value" id="kPg">—</div>
          <div class="note">per photon</div>
        </div>
        <div class="kpi">
          <div class="label">Required rate R</div>
          <div class="value" id="kR">—</div>
          <div class="note">photons/s</div>
        </div>
        <div class="kpi">
          <div class="label">Required power P</div>
          <div class="value" id="kP">—</div>
          <div class="note">watts</div>
        </div>
      </div>

      <p class="small muted" style="margin-top:10px">
        <b>What each canvas shows:</b>
        (1) A laser beam pushing upward against gravity on the atom.
        (2) The required photon rate vs photon energy, with a marker at the current slider value.
        (3) Required optical power vs photon energy, showing the “absorb” and “reflect” cases.
      </p>
      <p class="small muted">
        <b>Interactive controls:</b>
        Increase <code>Eγ</code> to see the required photon rate drop as <code>1/Eγ</code>. Switch between absorption and reflection to halve/double the needed rate and power.
        Change the mass scale to see linear scaling with mass in all outputs and plots.
      </p>
    </div>

    <div class="callout">
      <div class="calloutTitle"><span class="badge">Consistency</span>Symbols used in text and plots</div>
      <ul>
        <li><code>m</code>: atom mass (plotted as “mass scale × hydrogen mass”).</li>
        <li><code>g</code>: 9.8 m/s².</li>
        <li><code>Eγ</code>: photon energy (slider, eV).</li>
        <li><code>R</code>: required photon rate to satisfy <code>Fup = Fg</code>.</li>
        <li><code>P</code>: required optical power <code>P = R Eγ</code>.</li>
      </ul>
    </div>
  </section>
</main>

<footer class="wrap">
  <p class="printHint">
    Print-friendly tip: use your browser’s print function; the sticky TOC and buttons are hidden in print view.
  </p>
</footer>

<script>
/* ---------- Utilities ---------- */
function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

function fmtSci(x, sig=3){
  if (!isFinite(x)) return "—";
  if (x === 0) return "0";
  const e = Math.floor(Math.log10(Math.abs(x)));
  const m = x / Math.pow(10, e);
  const mm = m.toFixed(sig-1);
  return `${mm}×10^${e}`;
}

function fmtEng(x){
  if (!isFinite(x)) return "—";
  const ax = Math.abs(x);
  if (ax === 0) return "0";
  if (ax >= 1e-3 && ax < 1e3) return x.toPrecision(4);
  return fmtSci(x, 3);
}

function copyText(t){
  navigator.clipboard.writeText(t).then(()=>{
    // tiny feedback handled by button text swap
  }).catch(()=>{});
}

/* ---------- Copy buttons ---------- */
document.querySelectorAll(".copyBtn").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    const t = btn.getAttribute("data-copy") || "";
    if (!t) return;
    const old = btn.textContent;
    copyText(t);
    btn.textContent = "Copied!";
    setTimeout(()=>btn.textContent = old, 850);
  });
});

/* ---------- Physics model ---------- */
const CONST = {
  mH: 1.67e-27,     // kg
  g: 9.8,           // m/s^2
  c: 2.998e8,       // m/s
  eV: 1.602e-19     // J
};

function compute(EeV, mode, mScale){
  const m = CONST.mH * mScale;
  const Fg = m * CONST.g;
  const E = EeV * CONST.eV;
  const p = E / CONST.c;
  const dp = (mode === "ref") ? 2*p : p;
  const R = Fg / dp;        // photons/s
  const P = R * E;          // W
  return {m, Fg, EeV, E, p, dp, R, P, mode, mScale};
}

/* ---------- Canvas rendering (HiDPI + responsive) ---------- */
class HiDPICanvas {
  constructor(canvas){
    this.canvas = canvas;
    this.ctx = canvas.getContext("2d");
    this.dpr = window.devicePixelRatio || 1;
    this.w = 0; this.h = 0;
  }
  resize(){
    const rect = this.canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    this.dpr = dpr;
    const w = Math.max(1, Math.floor(rect.width * dpr));
    const h = Math.max(1, Math.floor(rect.height * dpr));
    if (w !== this.canvas.width || h !== this.canvas.height){
      this.canvas.width = w;
      this.canvas.height = h;
    }
    this.w = w; this.h = h;
    this.ctx.setTransform(1,0,0,1,0,0);
    this.ctx.scale(dpr, dpr);
    this.cssW = rect.width;
    this.cssH = rect.height;
  }
  clear(bg="rgba(0,0,0,0)"){
    const c = this.ctx;
    c.save();
    c.setTransform(1,0,0,1,0,0);
    c.clearRect(0,0,this.canvas.width,this.canvas.height);
    c.restore();
    if (bg && bg !== "transparent"){
      c.save();
      c.fillStyle = bg;
      c.fillRect(0,0,this.cssW,this.cssH);
      c.restore();
    }
  }
}

function drawRoundedRect(ctx,x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

function drawAxes(ctx, box, xLabel, yLabel, title){
  const {x,y,w,h} = box;
  ctx.save();
  // panel
  ctx.fillStyle = "rgba(0,0,0,.14)";
  ctx.strokeStyle = "rgba(255,255,255,.12)";
  drawRoundedRect(ctx, x, y, w, h, 12);
  ctx.fill();
  ctx.stroke();

  // title
  ctx.fillStyle = "rgba(234,240,255,.95)";
  ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto";
  ctx.fillText(title, x+10, y+18);

  // axis labels
  ctx.fillStyle = "rgba(183,195,230,.95)";
  ctx.font = "500 11px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto";
  ctx.fillText(xLabel, x + w/2 - ctx.measureText(xLabel).width/2, y + h - 6);

  ctx.save();
  ctx.translate(x+10, y + h/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
  ctx.restore();

  ctx.restore();
}

function plot2D(ctx, box, xMin, xMax, yMin, yMax, series, opts){
  // series: [{name, colorRGBA, data:[{x,y}]}]
  const padL = 44, padR = 14, padT = 28, padB = 28;
  const px = box.x + padL;
  const py = box.y + padT;
  const pw = box.w - padL - padR;
  const ph = box.h - padT - padB;

  function X(x){ return px + (x - xMin) * (pw / (xMax - xMin)); }
  function Y(y){ return py + ph - (y - yMin) * (ph / (yMax - yMin)); }

  // grid + ticks
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.fillStyle = "rgba(183,195,230,.95)";
  ctx.font = "500 10px ui-sans-serif, system-ui";

  const nTicks = 5;
  for(let i=0;i<=nTicks;i++){
    const tx = xMin + (xMax-xMin)*i/nTicks;
    const xg = X(tx);
    ctx.beginPath();
    ctx.moveTo(xg, py);
    ctx.lineTo(xg, py+ph);
    ctx.stroke();
    const label = (opts.xFmt ? opts.xFmt(tx) : tx.toFixed(1));
    ctx.fillText(label, xg - ctx.measureText(label).width/2, py+ph+14);
  }
  for(let i=0;i<=nTicks;i++){
    const ty = yMin + (yMax-yMin)*i/nTicks;
    const yg = Y(ty);
    ctx.beginPath();
    ctx.moveTo(px, yg);
    ctx.lineTo(px+pw, yg);
    ctx.stroke();
    const label = (opts.yFmt ? opts.yFmt(ty) : ty.toPrecision(3));
    ctx.fillText(label, px-8-ctx.measureText(label).width, yg+3);
  }

  // axes lines
  ctx.strokeStyle = "rgba(255,255,255,.18)";
  ctx.beginPath();
  ctx.moveTo(px, py);
  ctx.lineTo(px, py+ph);
  ctx.lineTo(px+pw, py+ph);
  ctx.stroke();

  // series
  series.forEach(s=>{
    ctx.strokeStyle = s.colorRGBA || "rgba(122,167,255,.95)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    let started=false;
    for(const pt of s.data){
      const xx = X(pt.x), yy = Y(pt.y);
      if(!started){ ctx.moveTo(xx,yy); started=true; }
      else ctx.lineTo(xx,yy);
    }
    ctx.stroke();
  });

  // legend (if more than one)
  if (series.length > 1){
    let lx = px + 8;
    let ly = py + 8;
    ctx.font = "600 10px ui-sans-serif, system-ui";
    series.forEach((s, i)=>{
      ctx.fillStyle = s.colorRGBA;
      ctx.fillRect(lx, ly + i*14 + 2, 10, 3);
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.fillText(s.name, lx+14, ly + i*14 + 6);
    });
  }

  ctx.restore();

  return {X, Y, px, py, pw, ph};
}

function drawMarker(ctx, map, x, y, label){
  ctx.save();
  ctx.strokeStyle = "rgba(124,242,199,.90)";
  ctx.fillStyle = "rgba(124,242,199,.90)";
  ctx.lineWidth = 1.5;

  // vertical line
  ctx.beginPath();
  ctx.moveTo(map.X(x), map.py);
  ctx.lineTo(map.X(x), map.py + map.ph);
  ctx.stroke();

  // point
  ctx.beginPath();
  ctx.arc(map.X(x), map.Y(y), 4.2, 0, Math.PI*2);
  ctx.fill();

  // label bubble
  const tx = map.X(x) + 8;
  const ty = map.Y(y) - 10;
  ctx.font = "600 10px ui-sans-serif, system-ui";
  const tw = ctx.measureText(label).width + 12;
  ctx.fillStyle = "rgba(0,0,0,.55)";
  ctx.strokeStyle = "rgba(255,255,255,.18)";
  drawRoundedRect(ctx, tx, ty-12, tw, 18, 8);
  ctx.fill(); ctx.stroke();
  ctx.fillStyle = "rgba(234,240,255,.95)";
  ctx.fillText(label, tx+6, ty+2);

  ctx.restore();
}

/* ---------- Diagram drawing ---------- */
function drawDiagram(hc, state){
  hc.resize();
  const ctx = hc.ctx;
  const W = hc.cssW, H = hc.cssH;
  hc.clear("rgba(0,0,0,.12)");

  // soft vignette
  ctx.save();
  const grad = ctx.createRadialGradient(W*0.5,H*0.35, 10, W*0.5,H*0.5, Math.max(W,H)*0.7);
  grad.addColorStop(0,"rgba(122,167,255,.12)");
  grad.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,W,H);
  ctx.restore();

  // ground line
  ctx.strokeStyle = "rgba(255,255,255,.18)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(18, H*0.80);
  ctx.lineTo(W-18, H*0.80);
  ctx.stroke();

  // laser beam
  const beamX = W*0.28;
  ctx.save();
  ctx.strokeStyle = "rgba(122,167,255,.85)";
  ctx.lineWidth = 10;
  ctx.lineCap = "round";
  ctx.globalAlpha = 0.30;
  ctx.beginPath();
  ctx.moveTo(beamX, H*0.78);
  ctx.lineTo(beamX, H*0.18);
  ctx.stroke();
  ctx.globalAlpha = 0.9;
  ctx.lineWidth = 2.2;
  ctx.beginPath();
  ctx.moveTo(beamX, H*0.78);
  ctx.lineTo(beamX, H*0.18);
  ctx.stroke();
  ctx.restore();

  // atom (circle)
  const ax = W*0.64, ay = H*0.46;
  ctx.save();
  ctx.fillStyle = "rgba(124,242,199,.18)";
  ctx.strokeStyle = "rgba(124,242,199,.90)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(ax, ay, 18, 0, Math.PI*2);
  ctx.fill();
  ctx.stroke();

  // little orbit ring
  ctx.strokeStyle = "rgba(255,255,255,.18)";
  ctx.lineWidth = 1.3;
  ctx.beginPath();
  ctx.ellipse(ax, ay, 30, 14, -0.4, 0, Math.PI*2);
  ctx.stroke();
  ctx.restore();

  // arrows: gravity down, light force up
  function arrow(x1,y1,x2,y2,color,label){
    ctx.save();
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
    const ang = Math.atan2(y2-y1, x2-x1);
    const head = 8;
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2 - head*Math.cos(ang-Math.PI/6), y2 - head*Math.sin(ang-Math.PI/6));
    ctx.lineTo(x2 - head*Math.cos(ang+Math.PI/6), y2 - head*Math.sin(ang+Math.PI/6));
    ctx.closePath();
    ctx.fill();

    ctx.font = "600 12px ui-sans-serif, system-ui";
    ctx.fillStyle = "rgba(234,240,255,.95)";
    ctx.fillText(label, x2 + 10, y2 + 4);
    ctx.restore();
  }

  arrow(ax, ay+30, ax, ay+78, "rgba(255,122,122,.92)", "Fg (down)");
  arrow(ax, ay-30, ax, ay-78, "rgba(124,242,199,.92)", "F_light (up)");

  // photon path hint from beam to atom
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.20)";
  ctx.setLineDash([6,6]);
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(beamX, ay);
  ctx.lineTo(ax-22, ay);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = "rgba(183,195,230,.95)";
  ctx.font = "500 11px ui-sans-serif, system-ui";
  ctx.fillText("photons →", (beamX+ax)/2 - 26, ay - 8);
  ctx.restore();

  // annotation box with current numbers
  const {Fg, p, R, P, mode, EeV, mScale} = state;
  const lines = [
    `Eγ = ${EeV.toFixed(1)} eV`,
    `mode: ${mode === "ref" ? "reflect" : "absorb"}`,
    `mass scale: ×${mScale.toFixed(2)}`,
    `Fg = ${fmtSci(Fg)} N`,
    `pγ = ${fmtSci(p)} N·s`,
    `R = ${fmtEng(R)} s⁻¹`,
    `P = ${fmtSci(P)} W`
  ];
  ctx.save();
  ctx.font = "600 11px ui-sans-serif, system-ui";
  const pad = 10;
  let maxW = 0;
  lines.forEach(s => maxW = Math.max(maxW, ctx.measureText(s).width));
  const bx = 18, by = 18, bw = maxW + pad*2, bh = lines.length*15 + pad*2 - 2;
  ctx.fillStyle = "rgba(0,0,0,.40)";
  ctx.strokeStyle = "rgba(255,255,255,.14)";
  drawRoundedRect(ctx, bx, by, bw, bh, 12);
  ctx.fill(); ctx.stroke();
  ctx.fillStyle = "rgba(234,240,255,.95)";
  lines.forEach((s,i)=> ctx.fillText(s, bx+pad, by+pad+12+i*15));
  ctx.restore();
}

/* ---------- Plots ---------- */
function buildSeries(mScale){
  // energy range for plots
  const xMin = 0.1, xMax = 5.0, n=120;
  const xs = [];
  for(let i=0;i<=n;i++){
    xs.push(xMin + (xMax-xMin)*i/n);
  }
  const absData = [];
  const refData = [];
  const absP = [];
  const refP = [];
  for(const EeV of xs){
    const sAbs = compute(EeV, "abs", mScale);
    const sRef = compute(EeV, "ref", mScale);
    absData.push({x:EeV, y:sAbs.R});
    refData.push({x:EeV, y:sRef.R});
    absP.push({x:EeV, y:sAbs.P});
    refP.push({x:EeV, y:sRef.P});
  }
  return {xs, absData, refData, absP, refP};
}

function drawMainPlot(hc, state, seriesPack){
  hc.resize();
  const ctx = hc.ctx;
  hc.clear("rgba(0,0,0,.12)");
  const W = hc.cssW, H = hc.cssH;

  const box = {x:10, y:10, w:W-20, h:H-20};
  drawAxes(ctx, box, "Photon energy Eγ (eV)", "Required rate R (photons/s)", "Required photon rate vs photon energy");

  // determine y range based on mass scale and low energy worst-case
  const yMax = Math.max(seriesPack.absData[0].y, 1) * 1.08;
  const yMin = 0;

  const map = plot2D(ctx, box, 0.1, 5.0, yMin, yMax,
    [
      {name:"Absorb", colorRGBA:"rgba(122,167,255,.95)", data: seriesPack.absData},
      {name:"Reflect", colorRGBA:"rgba(124,242,199,.95)", data: seriesPack.refData}
    ],
    {
      xFmt: (x)=>x.toFixed(1),
      yFmt: (y)=> (y>=1 ? y.toFixed(0) : y.toPrecision(2))
    }
  );

  // marker at current state
  const yHere = (state.mode === "ref") ? compute(state.EeV,"ref",state.mScale).R : compute(state.EeV,"abs",state.mScale).R;
  drawMarker(ctx, map, state.EeV, yHere, `R = ${fmtEng(yHere)} s⁻¹`);
}

function drawSecondaryPlot(hc, state, seriesPack){
  hc.resize();
  const ctx = hc.ctx;
  hc.clear("rgba(0,0,0,.12)");
  const W = hc.cssW, H = hc.cssH;

  const box = {x:10, y:10, w:W-20, h:H-20};
  drawAxes(ctx, box, "Photon energy Eγ (eV)", "Power P (W)", "Required optical power vs photon energy");

  // y range: power is constant in this model, but keep padding
  const yAbs = compute(1.0,"abs",state.mScale).P;
  const yRef = compute(1.0,"ref",state.mScale).P;
  const yMax = Math.max(yAbs, yRef) * 1.35;
  const yMin = 0;

  const map = plot2D(ctx, box, 0.1, 5.0, yMin, yMax,
    [
      {name:"Absorb (P = mgc)", colorRGBA:"rgba(122,167,255,.95)", data: seriesPack.absP},
      {name:"Reflect (P = mgc/2)", colorRGBA:"rgba(124,242,199,.95)", data: seriesPack.refP}
    ],
    {
      xFmt: (x)=>x.toFixed(1),
      yFmt: (y)=> {
        if (y === 0) return "0";
        const s = fmtSci(y);
        return s.replace("×10^","e");
      }
    }
  );

  const yHere = (state.mode === "ref") ? compute(state.EeV,"ref",state.mScale).P : compute(state.EeV,"abs",state.mScale).P;
  drawMarker(ctx, map, state.EeV, yHere, `P = ${fmtSci(yHere)} W`);
}

/* ---------- Live UI wiring ---------- */
const elE = document.getElementById("Eev");
const elEread = document.getElementById("Eread");
const elMode = document.getElementById("mode");
const elMScale = document.getElementById("mScale");

const kFg = document.getElementById("kFg");
const kPg = document.getElementById("kPg");
const kR  = document.getElementById("kR");
const kP  = document.getElementById("kP");

const cDiagram = new HiDPICanvas(document.getElementById("cDiagram"));
const cMain = new HiDPICanvas(document.getElementById("cMain"));
const cSecondary = new HiDPICanvas(document.getElementById("cSecondary"));

let seriesPack = null;

function updateAll(){
  const EeV = parseFloat(elE.value);
  const mode = elMode.value;
  let mScale = parseFloat(elMScale.value);
  if (!isFinite(mScale) || mScale <= 0) mScale = 1;
  mScale = clamp(mScale, 0.1, 1000);
  elMScale.value = mScale;

  elEread.textContent = `${EeV.toFixed(1)} eV`;

  const state = compute(EeV, mode, mScale);

  // KPIs
  kFg.textContent = `${fmtSci(state.Fg)} N`;
  kPg.textContent = `${fmtSci(state.p)} N·s`;
  kR.textContent  = `${fmtEng(state.R)}`;
  kP.textContent  = `${fmtSci(state.P)} W`;

  // rebuild series if mass scale changes enough (always rebuild: small cost, simpler + robust)
  seriesPack = buildSeries(mScale);

  // draw
  drawDiagram(cDiagram, state);
  drawMainPlot(cMain, state, seriesPack);
  drawSecondaryPlot(cSecondary, state, seriesPack);
}

/* responsive redraw */
const ro = new ResizeObserver(()=> updateAll());
ro.observe(document.querySelector(".vizCard"));

elE.addEventListener("input", updateAll);
elMode.addEventListener("change", updateAll);
elMScale.addEventListener("input", updateAll);

// initial
updateAll();
</script>
</body>
</html>
