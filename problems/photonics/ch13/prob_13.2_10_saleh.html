<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Random Partitioning of Coherent Light (Photon Statistics through a Beam Splitter)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101a33;
      --card:#0f1730;
      --ink:#eaf0ff;
      --muted:#a9b4d6;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.12);
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius:18px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--ink);
      background:
        radial-gradient(900px 700px at 15% 10%, rgba(125,211,252,.12), transparent 60%),
        radial-gradient(800px 650px at 85% 25%, rgba(167,139,250,.10), transparent 55%),
        radial-gradient(700px 700px at 50% 90%, rgba(52,211,153,.08), transparent 55%),
        linear-gradient(180deg, #070a14, var(--bg));
      line-height:1.55;
    }

    header{
      padding: 28px 18px 18px;
      border-bottom: 1px solid var(--line);
      position: relative;
      overflow:hidden;
    }
    header .wrap{
      max-width: 1180px;
      margin: 0 auto;
      display:grid;
      grid-template-columns: 1.3fr .7fr;
      gap: 18px;
      align-items: end;
    }
    h1{
      margin:0;
      font-size: clamp(26px, 3vw, 40px);
      letter-spacing: .2px;
    }
    header p{
      margin:10px 0 0;
      color: var(--muted);
      max-width: 72ch;
    }
    .badgeRow{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      flex-wrap:wrap;
    }
    .badge{
      padding:8px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      background: rgba(255,255,255,.04);
      color: var(--muted);
      font-size:12px;
      white-space:nowrap;
      backdrop-filter: blur(6px);
    }

    main{
      max-width: 1180px;
      margin: 0 auto;
      padding: 18px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 18px;
      align-items:start;
    }

    nav#toc{
      position: sticky;
      top: 14px;
      align-self:start;
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(255,255,255,.03);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    nav#toc .tocHead{
      padding: 14px 14px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    nav#toc .tocHead strong{
      font-size: 13px;
      letter-spacing:.35px;
      text-transform: uppercase;
      color: var(--muted);
    }
    nav#toc .tocHead button{
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      color: var(--ink);
      border-radius: 10px;
      padding: 7px 10px;
      cursor:pointer;
      font-size:12px;
    }
    nav#toc ul{
      list-style:none;
      padding: 10px 10px 14px;
      margin:0;
      display:flex;
      flex-direction:column;
      gap: 8px;
    }
    nav#toc a{
      display:block;
      padding: 10px 10px;
      text-decoration:none;
      color: var(--ink);
      border-radius: 12px;
      border: 1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      font-size: 14px;
    }
    nav#toc a:hover{
      background: rgba(125,211,252,.08);
      border-color: rgba(125,211,252,.22);
      transform: translateY(-1px);
    }
    nav#toc small{
      color: var(--muted);
      font-size: 12px;
    }

    article{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(255,255,255,.03);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .content{
      padding: 18px 18px 24px;
    }

    section{
      padding: 14px 0;
      border-top: 1px solid var(--line);
    }
    section:first-of-type{ border-top:none; padding-top:0; }
    h2{
      margin: 0 0 8px;
      font-size: clamp(18px, 2.2vw, 26px);
    }
    h3{
      margin: 14px 0 8px;
      font-size: 16px;
      color: var(--ink);
    }
    p{ margin: 8px 0; color: var(--ink); }
    .muted{ color: var(--muted); }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
      nav#toc{ position: relative; top:auto; }
      header .wrap{ grid-template-columns: 1fr; }
      .badgeRow{ justify-content:flex-start; }
    }
    @media (max-width: 720px){
      .grid2{ grid-template-columns: 1fr; }
    }

    .callout{
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      border-radius: 16px;
      padding: 12px 12px;
      margin: 10px 0;
      position: relative;
      overflow:hidden;
    }
    .callout::before{
      content:"";
      position:absolute;
      inset:0;
      background: radial-gradient(500px 130px at 20% 0%, rgba(125,211,252,.12), transparent 55%);
      pointer-events:none;
    }
    .callout > *{ position: relative; }
    .callout .tag{
      display:inline-block;
      font-size: 12px;
      color: var(--muted);
      letter-spacing:.25px;
      text-transform: uppercase;
      margin-bottom: 6px;
    }
    .callout.assumptions::before{ background: radial-gradient(520px 140px at 18% 0%, rgba(167,139,250,.12), transparent 55%); }
    .callout.mistakes::before{ background: radial-gradient(520px 140px at 18% 0%, rgba(251,191,36,.12), transparent 55%); }
    .callout.answer::before{ background: radial-gradient(520px 140px at 18% 0%, rgba(52,211,153,.12), transparent 55%); }

    .eqRow{
      display:flex;
      gap:10px;
      align-items:stretch;
      margin: 10px 0;
      flex-wrap:wrap;
    }
    pre.eq{
      margin:0;
      padding: 12px 12px;
      border-radius: 14px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      overflow:auto;
      max-width: 100%;
      font-size: 13px;
      line-height: 1.45;
      flex:1 1 460px;
      box-shadow: 0 10px 28px rgba(0,0,0,.25);
    }
    button.copy{
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--ink);
      border-radius: 14px;
      padding: 10px 12px;
      cursor:pointer;
      font-size: 13px;
      min-width: 120px;
      transition: transform .15s ease, background .15s ease;
      box-shadow: 0 10px 28px rgba(0,0,0,.25);
    }
    button.copy:hover{ transform: translateY(-1px); background: rgba(125,211,252,.10); }
    button.copy:active{ transform: translateY(0px); }

    ul{
      margin: 8px 0 8px 20px;
      color: var(--ink);
    }
    li{ margin: 6px 0; }
    .k{ color: var(--accent); font-weight: 600; }

    .vizPanel{
      border:1px solid var(--line);
      border-radius: 18px;
      overflow:hidden;
      background: rgba(0,0,0,.18);
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      margin: 10px 0;
    }
    .vizTop{
      padding: 12px 12px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      flex-wrap:wrap;
    }
    .vizTop .title{
      font-weight: 650;
      letter-spacing:.2px;
    }
    .controls{
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .ctrl{
      display:flex;
      gap: 8px;
      align-items:center;
      border:1px solid var(--line);
      border-radius: 14px;
      padding: 8px 10px;
      background: rgba(255,255,255,.04);
    }
    .ctrl label{
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
    }
    .ctrl input[type="range"]{ width: 180px; }
    .ctrl input[type="number"]{
      width: 90px;
      border-radius: 10px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.2);
      color: var(--ink);
      padding: 6px 8px;
      font-size: 13px;
    }
    .ctrl select{
      border-radius: 10px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.2);
      color: var(--ink);
      padding: 6px 8px;
      font-size: 13px;
    }
    .canvasWrap{
      padding: 10px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    .canvasGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 900px){
      .canvasGrid{ grid-template-columns: 1fr; }
    }
    canvas{
      width: 100%;
      height: 340px;
      display:block;
      border-radius: 14px;
      border:1px solid var(--line);
      background: rgba(8,12,24,.6);
    }
    .foot{
      padding: 14px 18px;
      border-top: 1px solid var(--line);
      color: var(--muted);
      font-size: 13px;
    }

    .fadeIn{
      animation: fadeIn .55s ease both;
    }
    @keyframes fadeIn{
      from{ opacity:0; transform: translateY(6px); }
      to{ opacity:1; transform: translateY(0); }
    }

    /* print-friendly */
    @media print{
      body{ background:#fff; color:#000; }
      header, nav#toc, .vizPanel, button.copy{ display:none !important; }
      article{ box-shadow:none; border:none; background:#fff; }
      section{ border-color:#ddd; }
      pre.eq{ background:#f6f6f6; border-color:#ddd; color:#000; box-shadow:none; }
      .callout{ background:#f7f7f7; border-color:#ddd; }
    }
  </style>
</head>

<body>
<header class="fadeIn">
  <div class="wrap">
    <div>
      <h1>Random Partitioning of Coherent Light</h1>
      <p>
        A lossless beam splitter “thins” a photon stream: each photon is randomly sent to transmission with probability
        <span class="k">τ</span> and to reflection with probability <span class="k">1−τ</span>.
        We show that coherent light keeps a Poisson photon-number distribution under this random partitioning,
        compute mean reflected photons, and derive the signal-to-noise ratio expression.
      </p>
    </div>
    <div class="badgeRow">
      <span class="badge">Topic: Quantum Optics / Photon Statistics</span>
      <span class="badge">Key tool: Binomial thinning</span>
      <span class="badge">Result: Poisson → Poisson</span>
    </div>
  </div>
</header>

<main class="fadeIn">
  <nav id="toc" aria-label="Table of contents">
    <div class="tocHead">
      <strong>Table of Contents</strong>
      <button id="tocToggle" type="button" aria-expanded="true">Collapse</button>
    </div>
    <ul id="tocList">
      <li><a href="#qs">Quick Summary<br><small>Results at a glance</small></a></li>
      <li><a href="#p0">PART 0 — Concept Primer<br><small>Theory first</small></a></li>
      <li><a href="#p1">PART 1 — Problem Analysis<br><small>What’s given & why</small></a></li>
      <li><a href="#p2">PART 2 — Strategy & Tips<br><small>Roadmap</small></a></li>
      <li><a href="#p3">PART 3 — Full Solution<br><small>Derivations</small></a></li>
      <li><a href="#p4">PART 4 — Deeper Understanding<br><small>Interpret & extend</small></a></li>
      <li><a href="#p5">PART 5 — Visualization Guide<br><small>Read the canvases</small></a></li>
    </ul>
  </nav>

  <article>
    <div class="content">
      <section id="qs">
        <h2>Quick Summary</h2>
        <ul>
          <li><span class="k">What this is about:</span> Photon-number statistics after random partitioning by a lossless beam splitter (transmission probability <span class="k">τ</span>).</li>
          <li><span class="k">Key physics idea:</span> Each photon is independently routed, so conditional on <span class="k">n</span> incident photons, the transmitted count <span class="k">m</span> is binomial: <span class="k">m|n ~ Bin(n, τ)</span>.</li>
          <li><span class="k">Governing equation (random partitioning):</span> the “binomial thinning” transform
            <span class="k">p(m)=∑<sub>n=m</sub>∞ C(n,m) τ<sup>m</sup>(1−τ)<sup>n−m</sup> p₀(n)</span>.
          </li>
          <li><span class="k">Main result (Part a):</span> If the input is coherent (Poisson)
            <span class="k">p₀(n)=e<sup>−n̄</sup> n̄<sup>n</sup>/n!</span>, then the output remains Poisson:
            <span class="k">p(m)=e<sup>−τn̄</sup>(τn̄)<sup>m</sup>/m!</span>.
          </li>
          <li><span class="k">Mean reflected photons (Part b):</span> <span class="k">⟨r⟩=(1−τ) n̄</span> for the reflected arm (with <span class="k">r=n−m</span>).</li>
          <li><span class="k">SNR (Part c):</span> With definition <span class="k">SNR = ⟨m⟩² / Var(m)</span>, coherent light gives
            <span class="k">SNR = τ n̄</span> because <span class="k">Var(m)=⟨m⟩</span> for Poisson.</li>
          <li><span class="k">Final results:</span> symbolic closed forms (Poisson form preserved, means scale linearly with τ).</li>
        </ul>
      </section>

      <section id="p0">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <h3>Core definitions (symbols & units)</h3>
        <ul>
          <li><span class="k">n</span>: incident photon number in a chosen detection window (dimensionless count).</li>
          <li><span class="k">m</span>: transmitted photon number (dimensionless count).</li>
          <li><span class="k">r</span>: reflected photon number (dimensionless count), typically <span class="k">r = n − m</span>.</li>
          <li><span class="k">τ</span>: beam-splitter intensity transmittance (dimensionless, 0 ≤ τ ≤ 1). Reflectance is <span class="k">1−τ</span> for lossless.</li>
          <li><span class="k">p₀(n)</span>: input photon-number distribution; <span class="k">p(m)</span>: output (transmitted) distribution.</li>
          <li><span class="k">n̄ = ⟨n⟩</span>: mean incident photon number (dimensionless).</li>
          <li><span class="k">Var(X)</span>: variance; <span class="k">ΔX²</span> often denotes the same quantity.</li>
        </ul>

        <h3>Physical meaning</h3>
        <p>
          A lossless beam splitter does not “create” or “destroy” photons (in an ideal model), but it
          <em>randomly routes</em> each incident photon into one of two output ports.
          If we focus on one output (say transmission), we see a randomly thinned photon stream.
        </p>

        <h3>Key principle: conditional binomial + mixing</h3>
        <p class="muted">
          If you know there were exactly <span class="k">n</span> photons incident, and each photon is transmitted independently with probability <span class="k">τ</span>,
          then the number transmitted <span class="k">m</span> is binomial:
          <span class="k">P(m|n)=C(n,m) τ^m (1−τ)^{n−m}</span>.
          If <span class="k">n</span> itself is random (with distribution <span class="k">p₀(n)</span>), the observed distribution is a weighted sum over <span class="k">n</span>.
        </p>

        <div class="callout assumptions">
          <div class="tag">Validity conditions</div>
          <ul>
            <li>Beam splitter is <span class="k">lossless</span> and <span class="k">linear</span>; no absorption or gain.</li>
            <li>Photons are routed <span class="k">independently</span> (no bunching/antibunching introduced by the splitter itself for coherent input).</li>
            <li>We consider a fixed detection time window so “photon number” is well-defined for counting statistics.</li>
          </ul>
        </div>

        <h3>Common models/approximations and why</h3>
        <ul>
          <li><span class="k">Coherent light (laser, single mode):</span> photon number is Poisson. This is the canonical “shot-noise-limited” field.</li>
          <li><span class="k">Random partitioning (thinning):</span> used to model beam splitters, partial detection efficiency, and losses (replace τ by efficiency η).</li>
          <li><span class="k">Independence assumption:</span> enables binomial conditional statistics; without it, output statistics can change form (e.g., number states become binomial).</li>
        </ul>

        <h3>Mini intuition examples</h3>
        <ul>
          <li><span class="k">Example 1 (deterministic n):</span> If exactly <span class="k">n=10</span> photons arrive and <span class="k">τ=0.3</span>, the mean transmitted is <span class="k">3</span> and the distribution is binomial over <span class="k">m=0..10</span>.</li>
          <li><span class="k">Example 2 (Poisson n):</span> If arrivals are Poisson with mean <span class="k">n̄</span>, “keeping each arrival with probability τ” produces another Poisson process with mean <span class="k">τ n̄</span>.</li>
        </ul>

        <div class="callout mistakes">
          <div class="tag">What to watch for</div>
          <ul>
            <li>Mixing up <span class="k">conditional</span> binomial statistics (<span class="k">m|n</span>) with the <span class="k">unconditional</span> output distribution <span class="k">p(m)</span>.</li>
            <li>Forgetting losslessness: in this problem <span class="k">τ + (1−τ) = 1</span>.</li>
            <li>Using the wrong SNR definition. Here the quoted result matches <span class="k">SNR = ⟨m⟩² / Var(m)</span>.</li>
          </ul>
        </div>
      </section>

      <section id="p1">
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

        <h3>Problem restatement (in plain words)</h3>
        <p>
          Coherent light (Poisson photon-number statistics) is sent into a lossless beam splitter.
          The splitter randomly sends each photon to the transmitted port with probability <span class="k">τ</span>
          (and to the reflected port with probability <span class="k">1−τ</span>).
          Using the random-partitioning formula, prove:
        </p>
        <ul>
          <li><b>(a)</b> The transmitted photon-number distribution keeps the Poisson form (only the mean changes).</li>
          <li><b>(b)</b> The mean photon number in the reflected beam is <span class="k">(1−τ) n̄</span>.</li>
          <li><b>(c)</b> For coherent light, prove the SNR expression <span class="k">SNR = τ n̄</span> (matching Eq. 13.2-34 in the prompt excerpt).</li>
        </ul>

        <h3>Given quantities</h3>
        <ul>
          <li>Random partitioning (thinning) equation:
            <span class="k">p(m)=∑<sub>n=m</sub>∞ C(n,m) τ^m (1−τ)^{n−m} p₀(n)</span>.
          </li>
          <li>Coherent-light input distribution (Poisson): <span class="k">p₀(n)=e^{−n̄} n̄^n/n!</span>.</li>
          <li>Lossless beam-splitter: transmitted probability <span class="k">τ</span>, reflected probability <span class="k">1−τ</span>.</li>
        </ul>

        <h3>Unknowns / what must be found</h3>
        <ul>
          <li>Closed-form expression for <span class="k">p(m)</span> when <span class="k">p₀(n)</span> is Poisson.</li>
          <li>Mean reflected photon number <span class="k">⟨r⟩</span>.</li>
          <li>SNR formula for coherent light, consistent with the cited equation.</li>
        </ul>

        <h3>Relevant principles and why they apply</h3>
        <ul>
          <li><span class="k">Law of total probability:</span> unconditional <span class="k">p(m)</span> is sum over <span class="k">n</span> of <span class="k">P(m|n)p₀(n)</span>.</li>
          <li><span class="k">Binomial conditional routing:</span> independent routing per photon in a lossless splitter gives <span class="k">P(m|n)</span> binomial.</li>
          <li><span class="k">Moments of Poisson:</span> Poisson has <span class="k">Var(n)=⟨n⟩</span>, and thinning preserves Poisson form.</li>
        </ul>
        <p class="muted">
          We do <em>not</em> need full field-operator beam-splitter transformations here; the problem is purely about photon-number
          distributions under random partitioning (a classical-probability view of counting statistics).
        </p>

        <div class="callout assumptions">
          <div class="tag">Assumptions we will use</div>
          <ul>
            <li>Independent photon routing with constant probability <span class="k">τ</span> (no saturation, no mode dependence).</li>
            <li>Same counting window for input and outputs; ideal detection (unless τ is interpreted as detection efficiency).</li>
            <li>Coherent input means Poisson photon-number distribution with mean <span class="k">n̄</span>.</li>
          </ul>
        </div>

        <h3>Possible approaches (pros/cons)</h3>
        <ul>
          <li><b>Approach A: Direct substitution into the sum</b> (what the problem requests).<br>
            <span class="muted">Pros:</span> explicit, self-contained, uses the given Eq. (13.2-33).<br>
            <span class="muted">Cons:</span> requires careful algebra to recognize the exponential series.
          </li>
          <li><b>Approach B: Probability generating functions</b> (PGFs).<br>
            <span class="muted">Pros:</span> very clean: thinning corresponds to composition of PGFs.<br>
            <span class="muted">Cons:</span> slightly more advanced if PGFs are unfamiliar.
          </li>
          <li><b>Approach C: Poisson process “thinning theorem”</b> (stochastic processes).<br>
            <span class="muted">Pros:</span> strongest intuition; immediate result.<br>
            <span class="muted">Cons:</span> relies on external theorem beyond the text’s provided equation.
          </li>
        </ul>

        <p><b>We choose Approach A</b> because it follows the prompt exactly and produces the closed form transparently.</p>
      </section>

      <section id="p2">
        <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

        <ol>
          <li>
            <b>Goal:</b> Write down the thinning formula for <span class="k">p(m)</span>.<br>
            <b>Tool:</b> Eq. (13.2-33).<br>
            <b>Meaning:</b> output statistics are a mixture over possible incident photon numbers.
          </li>
          <li>
            <b>Goal:</b> Substitute Poisson <span class="k">p₀(n)</span> into the sum.<br>
            <b>Tool:</b> <span class="k">p₀(n)=e^{−n̄} n̄^n/n!</span>.<br>
            <b>Meaning:</b> coherent light has independent photon counts (shot noise).
          </li>
          <li>
            <b>Goal:</b> Simplify the combinatorial factor with factorials.<br>
            <b>Tool:</b> <span class="k">C(n,m)=n!/(m!(n−m)!)</span>.<br>
            <b>Meaning:</b> isolate a sum over <span class="k">k=n−m</span>.
          </li>
          <li>
            <b>Goal:</b> Recognize the remaining series as an exponential.<br>
            <b>Tool:</b> <span class="k">∑_{k=0}∞ x^k/k! = e^x</span>.<br>
            <b>Meaning:</b> you will get a Poisson form with mean <span class="k">τ n̄</span>.
          </li>
          <li>
            <b>Goal:</b> Compute <span class="k">⟨m⟩</span> and <span class="k">⟨r⟩</span>.<br>
            <b>Tool:</b> For Poisson, <span class="k">⟨m⟩=τ n̄</span>; or use conditional expectation: <span class="k">⟨m|n⟩=τ n</span>.<br>
            <b>Meaning:</b> mean power splits according to τ and 1−τ.
          </li>
          <li>
            <b>Goal:</b> Derive SNR for coherent output.<br>
            <b>Tool:</b> Use definition consistent with Eq. (13.2-34): <span class="k">SNR = ⟨m⟩²/Var(m)</span>.<br>
            <b>Meaning:</b> for Poisson, noise is shot noise: <span class="k">Var(m)=⟨m⟩</span>.
          </li>
        </ol>

        <div class="callout mistakes">
          <div class="tag">Common mistakes & quick tips</div>
          <ul>
            <li>When simplifying the sum, switch to <span class="k">k=n−m</span> so the lower limit becomes <span class="k">k=0</span>.</li>
            <li>Keep track of factors of <span class="k">τ^m</span> and <span class="k">(1−τ)^{n−m}</span> separately before combining with <span class="k">n̄^n</span>.</li>
            <li>Check limiting cases: <span class="k">τ→0</span> should give almost always <span class="k">m=0</span>; <span class="k">τ→1</span> should recover the input distribution.</li>
          </ul>
        </div>
      </section>

      <section id="p3">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Physical intuition (before equations)</h3>
        <p>
          A coherent state has Poisson-distributed photon counts—like arrivals in a Poisson process.
          If you randomly keep each photon with probability <span class="k">τ</span>, you expect the kept stream to remain Poisson,
          just with a reduced average rate. So we anticipate:
          <span class="k">⟨m⟩ = τ n̄</span> and <span class="k">p(m)</span> Poisson with mean <span class="k">τ n̄</span>.
          Reflection should similarly have mean <span class="k">(1−τ)n̄</span>.
        </p>

        <div class="eqRow">
          <pre class="eq" id="eq-thin">Random partitioning (given):
p(m) = Σ_{n=m}^{∞} C(n,m) τ^m (1−τ)^{n−m} p0(n)

Coherent (Poisson) input:
p0(n) = e^{−n̄} n̄^n / n!</pre>
          <button class="copy" data-copy-target="eq-thin">Copy equations</button>
        </div>

        <h3>(a) Poisson-in → Poisson-out (use Eq. 13.2-33)</h3>
        <p>
          Start from the thinning formula and substitute the Poisson input distribution.
          Define all symbols:
          <span class="k">n</span> = incident photons, <span class="k">m</span> = transmitted photons, <span class="k">τ</span> = transmission probability, <span class="k">n̄</span> = mean incident photons.
        </p>

        <div class="eqRow">
          <pre class="eq" id="eq-a1">p(m) = Σ_{n=m}^{∞} C(n,m) τ^m (1−τ)^{n−m} e^{−n̄} n̄^n / n!</pre>
          <button class="copy" data-copy-target="eq-a1">Copy step</button>
        </div>

        <p>
          Now use the factorial form of the binomial coefficient:
          <span class="k">C(n,m)=n!/(m!(n−m)!)</span>.
          This cancels the <span class="k">n!</span> in the Poisson denominator.
        </p>

        <div class="eqRow">
          <pre class="eq" id="eq-a2">p(m) = Σ_{n=m}^{∞} [ n!/(m!(n−m)!) ] τ^m (1−τ)^{n−m} e^{−n̄} n̄^n / n!
     = e^{−n̄} τ^m / m!  Σ_{n=m}^{∞} (1−τ)^{n−m} n̄^n / (n−m)!</pre>
          <button class="copy" data-copy-target="eq-a2">Copy step</button>
        </div>

        <p>
          Make a clean change of variables:
          let <span class="k">k = n − m</span>, so that <span class="k">n = m + k</span>.
          When <span class="k">n = m</span>, we have <span class="k">k = 0</span>. As <span class="k">n → ∞</span>, <span class="k">k → ∞</span>.
        </p>

        <div class="eqRow">
          <pre class="eq" id="eq-a3">p(m) = e^{−n̄} τ^m / m!  Σ_{k=0}^{∞} (1−τ)^k n̄^{m+k} / k!
     = e^{−n̄} (τ^m n̄^m)/m!  Σ_{k=0}^{∞} [ ( (1−τ) n̄ )^k / k! ]</pre>
          <button class="copy" data-copy-target="eq-a3">Copy step</button>
        </div>

        <p>
          The remaining sum is the exponential series:
          <span class="k">∑_{k=0}∞ x^k/k! = e^x</span> with <span class="k">x = (1−τ)n̄</span>.
        </p>

        <div class="eqRow">
          <pre class="eq" id="eq-a4">Σ_{k=0}^{∞} [ ( (1−τ) n̄ )^k / k! ] = e^{(1−τ)n̄}

So:
p(m) = e^{−n̄} (τ n̄)^m / m!  · e^{(1−τ)n̄}
     = e^{−τ n̄} (τ n̄)^m / m!</pre>
          <button class="copy" data-copy-target="eq-a4">Copy step</button>
        </div>

        <div class="callout answer">
          <div class="tag">Part (a) final result</div>
          <div class="eqRow" style="margin-top:6px">
            <pre class="eq" id="eq-a-final">Transmitted photon-number distribution for coherent (Poisson) input:

p(m) = exp(−τ n̄) · (τ n̄)^m / m!   (Poisson with mean μ = τ n̄)</pre>
            <button class="copy" data-copy-target="eq-a-final">Copy result</button>
          </div>
          <p class="muted" style="margin-top:6px">
            Interpretation: random partitioning preserves the Poisson <em>shape</em>; it simply rescales the mean by τ.
          </p>
        </div>

        <h4>Sanity checks (Part a)</h4>
        <ul>
          <li><b>Normalization:</b> Poisson sums to 1 automatically.</li>
          <li><b>Limiting cases:</b>
            <span class="k">τ→0</span> gives <span class="k">p(0)→1</span>;
            <span class="k">τ→1</span> gives the original Poisson with mean <span class="k">n̄</span>.
          </li>
          <li><b>Physical meaning:</b> average counts drop in proportion to transmitted intensity.</li>
        </ul>

        <h3>(b) Mean photon number in the reflected beam</h3>
        <p>
          Let <span class="k">r</span> be the reflected photon number in the same window.
          For a lossless beam splitter with no loss, each incident photon ends up either transmitted or reflected, so
          <span class="k">r = n − m</span>.
        </p>

        <p>
          A straightforward (and very general) way uses conditional expectations:
          for fixed <span class="k">n</span>, the transmitted count is binomial, so
          <span class="k">⟨m|n⟩ = τ n</span>.
          Therefore <span class="k">⟨r|n⟩ = ⟨n−m|n⟩ = n − τ n = (1−τ)n</span>.
        </p>

        <div class="eqRow">
          <pre class="eq" id="eq-b1">⟨r⟩ = ⟨ ⟨r|n⟩ ⟩  (law of total expectation)
     = ⟨ (1−τ) n ⟩
     = (1−τ) ⟨n⟩
     = (1−τ) n̄</pre>
          <button class="copy" data-copy-target="eq-b1">Copy derivation</button>
        </div>

        <div class="callout answer">
          <div class="tag">Part (b) final result</div>
          <div class="eqRow" style="margin-top:6px">
            <pre class="eq" id="eq-b-final">Mean reflected photon number (lossless beam splitter):

⟨r⟩ = (1 − τ) n̄</pre>
            <button class="copy" data-copy-target="eq-b-final">Copy result</button>
          </div>
        </div>

        <h4>Sanity checks (Part b)</h4>
        <ul>
          <li><b>Energy/photon conservation in mean:</b> <span class="k">⟨m⟩ + ⟨r⟩ = τn̄ + (1−τ)n̄ = n̄</span>.</li>
          <li><b>Limits:</b> <span class="k">τ→1</span> gives <span class="k">⟨r⟩→0</span>; <span class="k">τ→0</span> gives <span class="k">⟨r⟩→n̄</span>.</li>
        </ul>

        <h3>(c) Prove Eq. (13.2-34) for coherent light (SNR)</h3>
        <p>
          The excerpt’s coherent-light SNR result matches the definition
          <span class="k">SNR = ⟨m⟩² / Var(m)</span>
          (sometimes called an “inverse relative noise” measure).
          For coherent light, we just proved the transmitted distribution is Poisson with mean
          <span class="k">μ = ⟨m⟩ = τ n̄</span>.
        </p>

        <p>
          A Poisson random variable satisfies <span class="k">Var(m)=μ</span>. Therefore:
        </p>

        <div class="eqRow">
          <pre class="eq" id="eq-c1">For coherent (Poisson) transmitted counts:

⟨m⟩ = μ = τ n̄
Var(m) = μ = τ n̄

SNR = ⟨m⟩² / Var(m)
    = (τ n̄)² / (τ n̄)
    = τ n̄</pre>
          <button class="copy" data-copy-target="eq-c1">Copy derivation</button>
        </div>

        <div class="callout answer">
          <div class="tag">Part (c) final result</div>
          <div class="eqRow" style="margin-top:6px">
            <pre class="eq" id="eq-c-final">For coherent light (Poisson) under random partitioning:

SNR = ⟨m⟩² / Var(m) = τ n̄</pre>
            <button class="copy" data-copy-target="eq-c-final">Copy final answer</button>
          </div>
          <p class="muted" style="margin-top:6px">
            Physical meaning: as you transmit fewer photons (smaller τ or smaller n̄), shot noise becomes relatively more important.
          </p>
        </div>

        <h4>Sanity checks (Part c)</h4>
        <ul>
          <li><b>Dimensionless:</b> SNR is dimensionless; <span class="k">τ n̄</span> is dimensionless.</li>
          <li><b>Limits:</b> <span class="k">τ→0</span> gives SNR→0; <span class="k">τ→1</span> gives SNR→<span class="k">n̄</span>.</li>
          <li><b>Interpretation:</b> In this SNR definition, “better” SNR grows linearly with average detected photons.</li>
        </ul>

        <p class="muted">
          Connection to the diagram and plots below: the diagram shows mean splitting; the distribution plot verifies “Poisson stays Poisson”;
          the SNR plot shows the linear dependence <span class="k">SNR = τ n̄</span>.
        </p>

        <div class="vizPanel" id="viz">
          <div class="vizTop">
            <div class="title">Interactive Visualization — Beam Splitter Thinning, Output Statistics, and SNR</div>
            <div class="controls" aria-label="Interactive controls">
              <div class="ctrl">
                <label for="tau">τ (transmittance)</label>
                <input id="tau" type="range" min="0" max="1" step="0.001" value="0.50"/>
                <span id="tauVal" class="muted" style="min-width:58px; text-align:right;">0.500</span>
              </div>
              <div class="ctrl">
                <label for="nbar">n̄ (mean input)</label>
                <input id="nbar" type="range" min="0.2" max="40" step="0.1" value="12"/>
                <span id="nbarVal" class="muted" style="min-width:58px; text-align:right;">12.0</span>
              </div>
              <div class="ctrl">
                <label for="distType">Input model</label>
                <select id="distType">
                  <option value="poisson" selected>Coherent (Poisson)</option>
                  <option value="thermal">Thermal (Bose–Einstein)</option>
                </select>
              </div>
              <div class="ctrl">
                <label for="mmax">m max (plot)</label>
                <input id="mmax" type="number" min="10" max="250" step="1" value="60"/>
              </div>
            </div>
          </div>

          <div class="canvasWrap">
            <canvas id="cnvDiagram" aria-label="Beam splitter diagram canvas"></canvas>
            <div class="canvasGrid">
              <canvas id="cnvMain" aria-label="Main plot canvas: photon-number distribution"></canvas>
              <canvas id="cnvSweep" aria-label="Secondary plot canvas: SNR versus τ"></canvas>
            </div>
            <p class="muted" style="margin: 0 2px 2px;">
              Notes: “Thermal (Bose–Einstein)” is included as a comparison because the excerpt mentions it; the problem’s proofs are for coherent light.
              All plots update live when you change <span class="k">τ</span> or <span class="k">n̄</span>.
            </p>
          </div>
        </div>

      </section>

      <section id="p4">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpreting the final formulas</h3>
        <ul>
          <li><span class="k">p(m) = Poisson(μ)</span> with <span class="k">μ=τ n̄</span>: the beam splitter acts like a constant “keep probability” τ.</li>
          <li><span class="k">⟨r⟩=(1−τ)n̄</span>: the reflected port carries the complementary mean count.</li>
          <li><span class="k">SNR = τ n̄</span> (with <span class="k">SNR=⟨m⟩²/Var(m)</span>): SNR is set purely by the average detected photon number for coherent (shot-noise-limited) light.</li>
        </ul>

        <h3>How changing parameters affects outcomes (connect to plots)</h3>
        <ul>
          <li>Increasing <span class="k">τ</span> shifts the output distribution to larger <span class="k">m</span> and narrows it <em>relative</em> to its mean in the SNR sense (SNR rises).</li>
          <li>Increasing <span class="k">n̄</span> similarly increases the mean counts in both ports and increases SNR linearly for coherent light.</li>
          <li>Comparing models: thermal input has larger fluctuations than Poisson; after partitioning it remains thermal in form (mean scales), and its SNR saturates as <span class="k">⟨m⟩/(⟨m⟩+1)</span> in this definition.</li>
        </ul>

        <h3>Alternative derivation idea (brief)</h3>
        <p>
          Use a probability generating function (PGF). If <span class="k">G₀(z)=∑ₙ p₀(n) zⁿ</span>,
          then binomial thinning gives <span class="k">G(z)=G₀( (1−τ)+τ z )</span>.
          For Poisson, <span class="k">G₀(z)=exp(n̄(z−1))</span>, so
          <span class="k">G(z)=exp( n̄( (1−τ)+τ z −1)) = exp( τ n̄ (z−1) )</span>, which is Poisson with mean <span class="k">τ n̄</span>.
        </p>

        <h3>Concept check (quick self-test)</h3>
        <ul>
          <li><b>Q:</b> If τ = 0.25 and input is Poisson with mean n̄ = 20, what is ⟨m⟩?<br><b>A:</b> ⟨m⟩ = τ n̄ = 5.</li>
          <li><b>Q:</b> For coherent light, does a beam splitter introduce extra noise beyond shot noise in each output port?<br><b>A:</b> No. Each output’s marginal photon-number distribution is Poisson; it’s still shot-noise-limited (though the two outputs are correlated via n = m + r in a given window).</li>
          <li><b>Q:</b> Why does p(m) become binomial if the input is a number state |n⟩?<br><b>A:</b> Because then n is fixed (not random), so m|n is binomial and no mixing over n occurs.</li>
          <li><b>Q:</b> With SNR = ⟨m⟩²/Var(m), what happens to coherent SNR if detection efficiency is reduced?<br><b>A:</b> It scales down linearly with efficiency (replace τ by η).</li>
        </ul>
      </section>

      <section id="p5">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

        <h3>What each canvas shows</h3>
        <ul>
          <li><b>Diagram (top canvas):</b> a labeled beam splitter with input mean photon number <span class="k">n̄</span>, transmitted mean <span class="k">⟨m⟩=τ n̄</span>, and reflected mean <span class="k">⟨r⟩=(1−τ)n̄</span>.</li>
          <li><b>Main quantitative plot (bottom-left):</b>
            photon-number distribution <span class="k">p(m)</span> vs <span class="k">m</span>.
            It overlays:
            <ul>
              <li><span class="k">Exact thinning sum</span> (computed from the input model and Eq. 13.2-33), and</li>
              <li><span class="k">Closed form</span> (for coherent: Poisson with mean τn̄; for thermal: Bose–Einstein with mean τn̄).</li>
            </ul>
            For coherent input, the curves coincide—this is the “Poisson stays Poisson” result.
          </li>
          <li><b>Secondary plot (bottom-right):</b> parameter sweep of <span class="k">SNR(τ)</span> at fixed <span class="k">n̄</span>.
            For coherent, it is a straight line <span class="k">SNR=τ n̄</span>.
            For thermal (comparison), it follows <span class="k">SNR=⟨m⟩/(⟨m⟩+1)</span> with <span class="k">⟨m⟩=τ n̄</span>.
          </li>
        </ul>

        <h3>Interactive controls</h3>
        <ul>
          <li><b>τ slider:</b> changes the transmission probability. Expect the mean transmitted counts and SNR to increase with τ, while reflected mean decreases.</li>
          <li><b>n̄ slider:</b> changes the mean input photon number (example values for visualization). Expect distributions to shift to larger m and coherent SNR to rise linearly.</li>
          <li><b>Input model select:</b> toggles between coherent (Poisson) and thermal (Bose–Einstein) to show how partitioning behaves for different statistics (coherent is the problem’s focus).</li>
          <li><b>m max:</b> just sets the horizontal range of the distribution plot.</li>
        </ul>

        <div class="callout answer">
          <div class="tag">Final Answer (plain text)</div>
          <div class="eqRow" style="margin-top:6px">
            <pre class="eq" id="final-answer">Using p(m)=Σ_{n=m}∞ C(n,m) τ^m (1−τ)^{n−m} p0(n):

(a) For coherent light p0(n)=e^{−n̄} n̄^n/n!, the partitioned distribution is
    p(m)=e^{−τ n̄}(τ n̄)^m/m!  (Poisson with mean ⟨m⟩=τ n̄).

(b) For a lossless splitter, reflected mean photon number is
    ⟨r⟩=(1−τ)n̄.

(c) With SNR defined as ⟨m⟩^2/Var(m), coherent output is Poisson so Var(m)=⟨m⟩=τ n̄, hence
    SNR = ⟨m⟩^2/Var(m) = τ n̄.</pre>
            <button class="copy" data-copy-target="final-answer">Copy final answer</button>
          </div>
        </div>
      </section>

    </div>

    <footer class="foot">
      Built as a self-contained learning article (no external libraries). Interactive canvases are computed directly from the equations shown above.
    </footer>
  </article>
</main>

<script>
/* -------------------------
   Utility: smooth scrolling + TOC collapse
-------------------------- */
(function(){
  const links = document.querySelectorAll('#toc a');
  links.forEach(a=>{
    a.addEventListener('click', (e)=>{
      const href = a.getAttribute('href');
      if(!href || !href.startsWith('#')) return;
      e.preventDefault();
      const el = document.querySelector(href);
      if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
      history.replaceState(null, '', href);
    });
  });

  const btn = document.getElementById('tocToggle');
  const list = document.getElementById('tocList');
  btn.addEventListener('click', ()=>{
    const expanded = btn.getAttribute('aria-expanded') === 'true';
    btn.setAttribute('aria-expanded', String(!expanded));
    list.style.display = expanded ? 'none' : 'block';
    btn.textContent = expanded ? 'Expand' : 'Collapse';
  });
})();

/* -------------------------
   Copy buttons for equations/results
-------------------------- */
(function(){
  function copyText(txt){
    if(navigator.clipboard && navigator.clipboard.writeText){
      return navigator.clipboard.writeText(txt);
    }
    // fallback
    const ta = document.createElement('textarea');
    ta.value = txt;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
    return Promise.resolve();
  }

  document.querySelectorAll('button.copy').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const id = btn.getAttribute('data-copy-target');
      const el = document.getElementById(id);
      if(!el) return;
      const txt = el.innerText.trim();
      const old = btn.textContent;
      try{
        await copyText(txt);
        btn.textContent = 'Copied ✓';
      }catch(e){
        btn.textContent = 'Copy failed';
      }
      setTimeout(()=>btn.textContent = old, 1100);
    });
  });
})();

/* -------------------------
   Math helpers (distributions)
-------------------------- */
function factorialTable(nMax){
  const f = new Array(nMax+1);
  f[0]=1;
  for(let i=1;i<=nMax;i++) f[i]=f[i-1]*i;
  return f;
}

function poissonPmf(m, mu){
  if(mu < 0) return 0;
  // stable-ish for moderate m by recurrence could be better; here we clamp plot ranges.
  let logp = -mu + m*Math.log(mu) - logFactorial(m);
  return Math.exp(logp);
}

let _logFactCache = [0]; // log(0!) = 0
function logFactorial(n){
  for(let k=_logFactCache.length; k<=n; k++){
    _logFactCache[k] = _logFactCache[k-1] + Math.log(k);
  }
  return _logFactCache[n];
}

function binomCoeffLog(n,m){
  // log(C(n,m)) = log(n!) - log(m!) - log((n-m)!)
  return logFactorial(n) - logFactorial(m) - logFactorial(n-m);
}

function thinningFromInput(mMax, tau, inputType, nbar){
  // Compute p(m) via the thinning sum:
  // p(m)= Σ_{n=m}∞ C(n,m) τ^m (1−τ)^{n−m} p0(n)
  // We'll truncate n at nMax where tail is tiny.
  // Choose nMax based on mean + several std.
  const muIn = nbar;
  const stdIn = (inputType==='poisson') ? Math.sqrt(muIn) : Math.sqrt(muIn*(muIn+1)); // thermal var = nbar(nbar+1)
  const nMax = Math.max(mMax, Math.ceil(muIn + 10*stdIn + 20));
  const out = new Array(mMax+1).fill(0);

  // precompute p0(n)
  const p0 = new Array(nMax+1).fill(0);
  if(inputType==='poisson'){
    // Poisson nbar
    // compute via recurrence for numerical stability
    p0[0] = Math.exp(-muIn);
    for(let n=1;n<=nMax;n++){
      p0[n] = p0[n-1]*muIn/n;
    }
  }else{
    // single-mode thermal (Bose–Einstein): p0(n)= (1/(1+nbar)) (nbar/(1+nbar))^n
    const q = muIn/(1+muIn);
    const pref = 1/(1+muIn);
    let pow = 1;
    for(let n=0;n<=nMax;n++){
      p0[n] = pref*pow;
      pow *= q;
    }
  }

  // sum
  const oneMinus = 1 - tau;
  for(let m=0;m<=mMax;m++){
    let s = 0;
    for(let n=m;n<=nMax;n++){
      // term = C(n,m)*tau^m*(1-tau)^(n-m)*p0(n)
      // compute in log to avoid overflow
      let logt = binomCoeffLog(n,m) + m*Math.log(Math.max(tau, 1e-16)) + (n-m)*Math.log(Math.max(oneMinus, 1e-16)) + Math.log(Math.max(p0[n], 1e-300));
      s += Math.exp(logt);
    }
    out[m] = s;
  }

  // normalize (small truncation error)
  let Z = out.reduce((a,b)=>a+b,0);
  if(Z>0){
    for(let m=0;m<=mMax;m++) out[m] /= Z;
  }
  return out;
}

function closedFormOutput(mMax, tau, inputType, nbar){
  // For these two input types, thinning preserves form with mean scaled by tau.
  const muOut = tau*nbar;
  const out = new Array(mMax+1).fill(0);
  if(inputType==='poisson'){
    out[0] = Math.exp(-muOut);
    for(let m=1;m<=mMax;m++){
      out[m] = out[m-1]*muOut/m;
    }
  }else{
    // thermal: p(m)= 1/(1+muOut) * (muOut/(1+muOut))^m
    const pref = 1/(1+muOut);
    const q = muOut/(1+muOut);
    let pow = 1;
    for(let m=0;m<=mMax;m++){
      out[m] = pref*pow;
      pow *= q;
    }
  }
  return out;
}

function meanFromPmf(p){
  let s=0;
  for(let i=0;i<p.length;i++) s += i*p[i];
  return s;
}

function varFromPmf(p, mean){
  let s=0;
  for(let i=0;i<p.length;i++){
    const d=i-mean;
    s += d*d*p[i];
  }
  return s;
}

/* -------------------------
   Canvas drawing (hi-DPI + responsive)
-------------------------- */
function setupCanvas(canvas){
  const ctx = canvas.getContext('2d');
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(2, Math.round(rect.width*dpr));
    canvas.height = Math.max(2, Math.round(rect.height*dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return {w: rect.width, h: rect.height, dpr};
  }
  return {ctx, resize};
}

function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title, opts={}){
  const {x=0,y=0,w=300,h=200} = box;
  const padL = 54, padR = 18, padT = 38, padB = 44;
  const px0 = x + padL, px1 = x + w - padR;
  const py0 = y + h - padB, py1 = y + padT;

  // background
  ctx.save();
  ctx.clearRect(x,y,w,h);

  // panel glow
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(x,y,w,h);

  // title
  ctx.fillStyle = 'rgba(234,240,255,0.92)';
  ctx.font = '600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(title, x+12, y+22);

  // grid
  ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  ctx.lineWidth = 1;

  const xTicks = opts.xTicks ?? 6;
  const yTicks = opts.yTicks ?? 5;

  for(let i=0;i<=xTicks;i++){
    const t = i/xTicks;
    const X = px0 + t*(px1-px0);
    ctx.beginPath();
    ctx.moveTo(X, py0);
    ctx.lineTo(X, py1);
    ctx.stroke();
  }
  for(let j=0;j<=yTicks;j++){
    const t = j/yTicks;
    const Y = py0 - t*(py0-py1);
    ctx.beginPath();
    ctx.moveTo(px0, Y);
    ctx.lineTo(px1, Y);
    ctx.stroke();
  }

  // axes
  ctx.strokeStyle = 'rgba(255,255,255,0.55)';
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(px0, py0);
  ctx.lineTo(px1, py0);
  ctx.lineTo(px1, py1);
  ctx.stroke();

  // ticks + labels
  ctx.fillStyle = 'rgba(169,180,214,0.95)';
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';

  function fx(t){ return xMin + t*(xMax-xMin); }
  function fy(t){ return yMin + t*(yMax-yMin); }

  for(let i=0;i<=xTicks;i++){
    const t=i/xTicks;
    const X = px0 + t*(px1-px0);
    const val = fx(t);
    ctx.beginPath();
    ctx.moveTo(X, py0);
    ctx.lineTo(X, py0+5);
    ctx.strokeStyle = 'rgba(255,255,255,0.55)';
    ctx.stroke();
    const s = (Math.abs(val) >= 1000) ? val.toExponential(1) : (Math.abs(xMax-xMin) <= 1 ? val.toFixed(2) : val.toFixed(0));
    ctx.fillText(s, X-10, py0+20);
  }

  for(let j=0;j<=yTicks;j++){
    const t=j/yTicks;
    const Y = py0 - t*(py0-py1);
    const val = fy(t);
    ctx.beginPath();
    ctx.moveTo(px0-5, Y);
    ctx.lineTo(px0, Y);
    ctx.strokeStyle = 'rgba(255,255,255,0.55)';
    ctx.stroke();
    const s = (val===0) ? '0' : (val < 0.01 ? val.toExponential(1) : val.toFixed(2));
    ctx.fillText(s, px0-46, Y+4);
  }

  // axis labels
  ctx.fillStyle = 'rgba(234,240,255,0.85)';
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(xLabel, (px0+px1)/2 - 20, y+h-14);

  // y label rotated
  ctx.save();
  ctx.translate(x+16, (py0+py1)/2 + 18);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  ctx.restore();

  // mapping function
  function Xmap(xv){ return px0 + (xv-xMin)/(xMax-xMin)*(px1-px0); }
  function Ymap(yv){ return py0 - (yv-yMin)/(yMax-yMin)*(py0-py1); }

  return {px0,px1,py0,py1, Xmap, Ymap};
}

function drawLegend(ctx, x, y, items){
  ctx.save();
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  let yy=y;
  items.forEach(it=>{
    ctx.fillStyle = it.color;
    ctx.fillRect(x, yy-9, 10, 10);
    ctx.fillStyle = 'rgba(234,240,255,0.86)';
    ctx.fillText(it.label, x+14, yy);
    yy += 16;
  });
  ctx.restore();
}

function strokeLine(ctx, pts, color, width=2){
  if(pts.length<2) return;
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.stroke();
  ctx.restore();
}

function drawPoints(ctx, pts, color){
  ctx.save();
  ctx.fillStyle = color;
  for(const p of pts){
    ctx.beginPath();
    ctx.arc(p.x, p.y, 2.2, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

/* -------------------------
   Draw diagram canvas
-------------------------- */
function drawDiagram(ctx, W, H, tau, nbar){
  ctx.clearRect(0,0,W,H);

  // background
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(0,0,W,H);

  const margin=18;
  const x0=margin, x1=W-margin, y0=margin, y1=H-margin;

  // title
  ctx.fillStyle = 'rgba(234,240,255,0.92)';
  ctx.font = '600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('Beam Splitter: Random Partitioning (lossless)', x0, y0+18);

  // beam splitter box
  const bx = W*0.52, by = H*0.52;
  const bw = 80, bh = 80;

  // input arrow
  const inX = W*0.12, inY = by;
  const outTX = W*0.86, outTY = by - H*0.18;
  const outRX = W*0.86, outRY = by + H*0.18;

  function arrow(xa,ya, xb,yb){
    const dx=xb-xa, dy=yb-ya;
    const L=Math.hypot(dx,dy) || 1;
    const ux=dx/L, uy=dy/L;
    const head=10;
    ctx.beginPath();
    ctx.moveTo(xa,ya);
    ctx.lineTo(xb, yb);
    ctx.stroke();
    // head
    ctx.beginPath();
    ctx.moveTo(xb,yb);
    ctx.lineTo(xb - head*(ux) + head*0.55*(-uy), yb - head*(uy) + head*0.55*(ux));
    ctx.lineTo(xb - head*(ux) - head*0.55*(-uy), yb - head*(uy) - head*0.55*(ux));
    ctx.closePath();
    ctx.fill();
  }

  // draw arrows
  ctx.strokeStyle = 'rgba(125,211,252,0.75)';
  ctx.fillStyle = 'rgba(125,211,252,0.85)';
  ctx.lineWidth = 2.2;
  arrow(inX, inY, bx-bw/2, by);

  ctx.strokeStyle = 'rgba(167,139,250,0.70)';
  ctx.fillStyle = 'rgba(167,139,250,0.85)';
  arrow(bx+bw/2, by, outTX, outTY);

  ctx.strokeStyle = 'rgba(52,211,153,0.70)';
  ctx.fillStyle = 'rgba(52,211,153,0.85)';
  arrow(bx+bw/2, by, outRX, outRY);

  // splitter element
  ctx.save();
  ctx.translate(bx,by);
  ctx.rotate(-Math.PI/4);
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.strokeStyle = 'rgba(255,255,255,0.45)';
  ctx.lineWidth = 1.2;
  ctx.fillRect(-bw/2,-bh/2,bw,bh);
  ctx.strokeRect(-bw/2,-bh/2,bw,bh);

  // diagonal partially reflecting surface
  ctx.strokeStyle = 'rgba(255,255,255,0.75)';
  ctx.lineWidth = 2.4;
  ctx.beginPath();
  ctx.moveTo(-bw/2,0);
  ctx.lineTo(bw/2,0);
  ctx.stroke();
  ctx.restore();

  // labels
  const muT = tau*nbar;
  const muR = (1-tau)*nbar;

  ctx.fillStyle = 'rgba(234,240,255,0.88)';
  ctx.font = '13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(`Input mean: n̄ = ${nbar.toFixed(1)} photons/window`, inX, inY-16);

  ctx.fillStyle = 'rgba(167,139,250,0.95)';
  ctx.fillText(`Transmitted: ⟨m⟩ = τ n̄ = ${muT.toFixed(2)}`, W*0.60, outTY-10);

  ctx.fillStyle = 'rgba(52,211,153,0.95)';
  ctx.fillText(`Reflected: ⟨r⟩ = (1−τ) n̄ = ${muR.toFixed(2)}`, W*0.60, outRY+18);

  ctx.fillStyle = 'rgba(169,180,214,0.9)';
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(`Lossless: τ + (1−τ) = 1`, x0, y1);

  // tau badge
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(W*0.04, y0+32, 160, 34, 12);
  ctx.fill(); ctx.stroke();
  ctx.fillStyle = 'rgba(234,240,255,0.90)';
  ctx.font = '600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(`τ = ${tau.toFixed(3)}`, W*0.04+12, y0+55);
}

/* -------------------------
   Draw distribution plot
-------------------------- */
function drawDistributionPlot(ctx, W, H, tau, nbar, inputType, mMax){
  // compute pmfs
  const pThin = thinningFromInput(mMax, tau, inputType, nbar);
  const pClosed = closedFormOutput(mMax, tau, inputType, nbar);

  // y range
  const yMax = Math.max(...pThin, ...pClosed) * 1.15;
  const axes = drawAxes(ctx, {x:0,y:0,w:W,h:H}, 0, mMax, 0, Math.max(0.06, yMax), 'm (photons / window)', 'p(m) [dimensionless]', 'Photon-number distribution after partitioning', {xTicks:6, yTicks:5});

  // lines
  const ptsThin=[], ptsClosed=[];
  for(let m=0;m<=mMax;m++){
    ptsThin.push({x: axes.Xmap(m), y: axes.Ymap(pThin[m])});
    ptsClosed.push({x: axes.Xmap(m), y: axes.Ymap(pClosed[m])});
  }

  // colors (set by RGBA strings directly)
  const cThin = 'rgba(125,211,252,0.95)';
  const cClosed = (inputType==='poisson') ? 'rgba(52,211,153,0.90)' : 'rgba(167,139,250,0.92)';

  strokeLine(ctx, ptsThin, cThin, 2.4);
  drawPoints(ctx, ptsThin.filter((_,i)=> i%3===0), 'rgba(125,211,252,0.85)');

  strokeLine(ctx, ptsClosed, cClosed, 2.4);

  // legend
  const legend = [
    {label: 'Thinning sum (Eq. 13.2-33)', color: cThin},
    {label: (inputType==='poisson') ? 'Closed form: Poisson(μ=τ n̄)' : 'Closed form: Thermal (mean μ=τ n̄)', color: cClosed},
  ];
  drawLegend(ctx, axes.px0 + 8, axes.py1 + 16, legend);

  // annotation: mean
  const mu = tau*nbar;
  ctx.save();
  ctx.fillStyle = 'rgba(234,240,255,0.86)';
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(`Mean μ = ⟨m⟩ = τ n̄ = ${mu.toFixed(2)}`, axes.px0 + 8, axes.py1 + 72);
  ctx.restore();

  return {pThin, pClosed};
}

/* -------------------------
   Draw SNR sweep plot
-------------------------- */
function drawSNRPlot(ctx, W, H, nbar, inputType, tauCurrent){
  // sweep tau in [0,1]
  const N = 140;
  const taus = [];
  const snrCoherent = [];
  const snrThermal = [];

  for(let i=0;i<=N;i++){
    const tau = i/N;
    const mu = tau*nbar;

    // coherent SNR = mu (for definition mean^2/var with var=mu)
    const snrC = mu;

    // thermal (single-mode) var = mu(mu+1) => SNR = mu^2 / (mu(mu+1)) = mu/(mu+1)
    const snrT = (mu<=0) ? 0 : (mu/(mu+1));

    taus.push(tau);
    snrCoherent.push(snrC);
    snrThermal.push(snrT);
  }

  const yMax = Math.max(1e-6, Math.max(...snrCoherent, 1.0)) * 1.05; // keep room, thermal tops at 1
  const axes = drawAxes(ctx, {x:0,y:0,w:W,h:H}, 0, 1, 0, yMax, 'τ (dimensionless)', 'SNR (dimensionless)', 'SNR sweep vs τ (fixed n̄)', {xTicks:5, yTicks:5});

  // build points
  const ptsC=[], ptsT=[];
  for(let i=0;i<taus.length;i++){
    ptsC.push({x: axes.Xmap(taus[i]), y: axes.Ymap(snrCoherent[i])});
    ptsT.push({x: axes.Xmap(taus[i]), y: axes.Ymap(snrThermal[i])});
  }

  // plot depending on chosen input model: still show both (educational), highlight current selection
  const cC = 'rgba(52,211,153,0.92)';
  const cT = 'rgba(167,139,250,0.92)';
  strokeLine(ctx, ptsC, cC, 2.4);
  strokeLine(ctx, ptsT, cT, 2.4);

  // current tau marker
  const xM = axes.Xmap(tauCurrent);
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.65)';
  ctx.lineWidth = 1.2;
  ctx.setLineDash([5,5]);
  ctx.beginPath();
  ctx.moveTo(xM, axes.py0);
  ctx.lineTo(xM, axes.py1);
  ctx.stroke();
  ctx.setLineDash([]);

  // compute current SNR for selected
  const mu = tauCurrent*nbar;
  const snrSel = (inputType==='poisson') ? mu : (mu<=0?0:mu/(mu+1));
  const yM = axes.Ymap(snrSel);
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.beginPath();
  ctx.arc(xM, yM, 3.8, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // legend
  drawLegend(ctx, axes.px0 + 8, axes.py1 + 16, [
    {label: 'Coherent: SNR = τ n̄', color: cC},
    {label: 'Thermal: SNR = (τ n̄)/(τ n̄ + 1)', color: cT},
  ]);

  // text
  ctx.save();
  ctx.fillStyle = 'rgba(234,240,255,0.86)';
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(`At τ=${tauCurrent.toFixed(3)}: ⟨m⟩=τ n̄=${mu.toFixed(2)}, selected SNR=${snrSel.toFixed(3)}`, axes.px0 + 8, axes.py1 + 72);
  ctx.restore();
}

/* -------------------------
   Main render loop
-------------------------- */
(function(){
  const cnvDiagram = document.getElementById('cnvDiagram');
  const cnvMain = document.getElementById('cnvMain');
  const cnvSweep = document.getElementById('cnvSweep');

  const diag = setupCanvas(cnvDiagram);
  const main = setupCanvas(cnvMain);
  const sweep = setupCanvas(cnvSweep);

  const tauEl = document.getElementById('tau');
  const nbarEl = document.getElementById('nbar');
  const typeEl = document.getElementById('distType');
  const mmaxEl = document.getElementById('mmax');
  const tauVal = document.getElementById('tauVal');
  const nbarVal = document.getElementById('nbarVal');

  function clamp(v, a, b){ return Math.min(b, Math.max(a, v)); }

  function readState(){
    let tau = parseFloat(tauEl.value);
    let nbar = parseFloat(nbarEl.value);
    let type = typeEl.value;
    let mmax = parseInt(mmaxEl.value, 10);
    if(!Number.isFinite(mmax)) mmax = 60;
    mmax = clamp(mmax, 10, 250);
    mmaxEl.value = String(mmax);

    tauVal.textContent = tau.toFixed(3);
    nbarVal.textContent = nbar.toFixed(1);

    return {tau, nbar, type, mmax};
  }

  function render(){
    const {tau, nbar, type, mmax} = readState();

    // resize
    const rD = diag.resize();
    const rM = main.resize();
    const rS = sweep.resize();

    // draw
    drawDiagram(diag.ctx, rD.w, rD.h, tau, nbar);
    drawDistributionPlot(main.ctx, rM.w, rM.h, tau, nbar, type, mmax);
    drawSNRPlot(sweep.ctx, rS.w, rS.h, nbar, type, tau);
  }

  // events
  [tauEl, nbarEl, typeEl, mmaxEl].forEach(el=>{
    el.addEventListener('input', render);
    el.addEventListener('change', render);
  });
  window.addEventListener('resize', render);

  // Initial draw
  render();
})();
</script>
</body>
</html>
