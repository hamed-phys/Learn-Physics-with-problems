<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Noisiness of a Discrete-Uniform Photon-Number Distribution</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101a33;
      --panel2:#0e1730;
      --text:#e9eefc;
      --muted:#b7c3ea;
      --faint:#7f8bb6;
      --accent:#7aa7ff;
      --accent2:#72f0c3;
      --warn:#ffcf6e;
      --danger:#ff7a9b;
      --ok:#8dff9a;
      --border:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --radius2:24px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 700px at 15% 10%, rgba(122,167,255,.18), transparent 60%),
                  radial-gradient(900px 600px at 85% 20%, rgba(114,240,195,.12), transparent 55%),
                  radial-gradient(900px 700px at 50% 90%, rgba(255,207,110,.10), transparent 60%),
                  var(--bg);
      color:var(--text);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:28px 18px 10px;
      max-width:1180px;
      margin:0 auto;
    }
    .topbar{
      display:flex;
      gap:14px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .titleblock{
      flex:1 1 520px;
      min-width:280px;
    }
    h1{
      font-size:clamp(1.55rem, 2.5vw, 2.25rem);
      margin:0 0 8px;
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      max-width:78ch;
      margin:0;
    }
    .badgeRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:14px;
    }
    .badge{
      font-size:.86rem;
      color:var(--muted);
      border:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      padding:8px 10px;
      border-radius:999px;
      display:inline-flex;
      gap:8px;
      align-items:center;
      backdrop-filter: blur(10px);
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background:var(--accent);
      box-shadow:0 0 0 3px rgba(122,167,255,.12);
      flex:0 0 auto;
    }
    .layout{
      max-width:1180px;
      margin:0 auto;
      padding:14px 18px 60px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:16px;
      align-items:start;
    }
    nav{
      position:sticky;
      top:12px;
      align-self:start;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius:var(--radius2);
      box-shadow:var(--shadow);
      padding:14px 14px 12px;
    }
    nav h2{
      font-size:1rem;
      margin:4px 0 10px;
      color:var(--text);
      letter-spacing:.2px;
    }
    .toc{
      list-style:none;
      padding:0;margin:0;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .toc a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      color:var(--muted);
      border:1px solid transparent;
      background:transparent;
      transition:transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:.95rem;
    }
    .toc a:hover{
      background:rgba(122,167,255,.10);
      border-color:rgba(122,167,255,.25);
      transform:translateY(-1px);
      text-decoration:none;
      color:var(--text);
    }
    main{
      display:flex;
      flex-direction:column;
      gap:16px;
      min-width:0;
    }
    section{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius:var(--radius2);
      box-shadow:var(--shadow);
      padding:18px 18px 16px;
      overflow:hidden;
      position:relative;
    }
    section:before{
      content:"";
      position:absolute;
      inset:0;
      background:radial-gradient(800px 140px at 20% 0%, rgba(122,167,255,.10), transparent 60%),
                 radial-gradient(800px 140px at 80% 0%, rgba(114,240,195,.08), transparent 60%);
      pointer-events:none;
      opacity:.75;
    }
    section > *{position:relative}
    h3{
      margin:0 0 10px;
      font-size:1.25rem;
      letter-spacing:.2px;
    }
    h4{
      margin:14px 0 8px;
      font-size:1.05rem;
      color:var(--text);
    }
    p{margin:10px 0; color:var(--text)}
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:12px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns:1fr}
      nav{position:relative; top:auto}
      .grid2,.grid3{grid-template-columns:1fr}
    }
    .callouts{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
    }
    @media (max-width: 800px){ .callouts{grid-template-columns:1fr} }
    .card{
      border:1px solid var(--border);
      border-radius:var(--radius);
      background:linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,.10));
      padding:12px 12px 10px;
    }
    .card strong{color:var(--text)}
    .kicker{
      text-transform:uppercase;
      letter-spacing:.14em;
      font-size:.78rem;
      color:var(--faint);
      margin:0 0 8px;
    }
    ul{margin:8px 0 10px 20px; color:var(--text)}
    li{margin:6px 0}
    .eq{
      font-family:var(--mono);
      background:rgba(122,167,255,.10);
      border:1px solid rgba(122,167,255,.18);
      padding:2px 6px;
      border-radius:10px;
      display:inline-block;
      color:var(--text);
      white-space:nowrap;
    }
    .eqblock{
      margin:10px 0;
      padding:12px 12px;
      border-radius:16px;
      background:rgba(122,167,255,.08);
      border:1px solid rgba(122,167,255,.18);
      overflow:auto;
      position:relative;
    }
    .eqblock pre{
      margin:0;
      font-family:var(--mono);
      font-size:.95rem;
      color:var(--text);
      line-height:1.45;
      white-space:pre-wrap;
    }
    .copyRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-top:8px;
    }
    button.copyBtn{
      border:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      color:var(--text);
      padding:9px 10px;
      border-radius:12px;
      cursor:pointer;
      font-size:.9rem;
      transition:transform .12s ease, border-color .12s ease;
    }
    button.copyBtn:hover{transform:translateY(-1px); border-color:rgba(122,167,255,.35)}
    button.copyBtn:active{transform:translateY(0px)}
    .pill{
      font-family:var(--mono);
      font-size:.86rem;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.18);
      color:var(--muted);
    }
    .controls{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:flex-end;
    }
    .control{
      flex:1 1 220px;
      min-width:220px;
      border:1px solid var(--border);
      border-radius:var(--radius);
      padding:12px;
      background:rgba(0,0,0,.15);
    }
    label{display:block; color:var(--muted); font-size:.92rem; margin-bottom:8px}
    input[type="range"]{width:100%}
    .valRow{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:baseline;
      margin-top:6px;
    }
    .bigVal{
      font-family:var(--mono);
      font-size:1.1rem;
      color:var(--text);
    }
    .tiny{font-size:.86rem; color:var(--faint)}
    figure{
      margin:0;
      border:1px solid var(--border);
      border-radius:var(--radius2);
      overflow:hidden;
      background:rgba(0,0,0,.18);
    }
    figcaption{
      padding:10px 12px;
      color:var(--muted);
      border-top:1px solid var(--border);
      font-size:.92rem;
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      background:transparent;
    }
    .canvasTall canvas{height:360px}
    .canvasShort canvas{height:280px}
    .footer{
      color:var(--muted);
      font-size:.92rem;
      padding:18px;
      max-width:1180px;
      margin:0 auto 24px;
      opacity:.95;
    }
    .hr{
      height:1px;
      background:var(--border);
      margin:12px 0;
    }

    /* Print-friendly */
    @media print{
      body{background:#fff;color:#000}
      nav{display:none}
      section,figure{box-shadow:none}
      .eq{border:1px solid #ddd;background:#f6f6f6;color:#000}
      .eqblock{border:1px solid #ddd;background:#fafafa}
      button.copyBtn{display:none}
      canvas{display:none}
      figcaption{border-top:1px solid #ddd}
    }

    /* subtle motion */
    @media (prefers-reduced-motion: no-preference){
      section{animation:fadeInUp .45s ease both}
      section:nth-child(2){animation-delay:.04s}
      section:nth-child(3){animation-delay:.08s}
      section:nth-child(4){animation-delay:.12s}
      section:nth-child(5){animation-delay:.16s}
      section:nth-child(6){animation-delay:.20s}
      section:nth-child(7){animation-delay:.24s}
      @keyframes fadeInUp{
        from{opacity:0; transform:translateY(8px)}
        to{opacity:1; transform:translateY(0)}
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="topbar">
      <div class="titleblock">
        <h1>Noisiness of a Discrete-Uniform Photon-Number Distribution</h1>
        <p class="subtitle">
          We analyze a light source whose photon number <span class="eq">n</span> is uniformly distributed over a finite set of integers.
          You’ll compute normalization, mean, variance, and the signal-to-noise ratio (SNR), then compare with Poisson (ideal laser) and Bose–Einstein (single-mode thermal) statistics.
        </p>
        <div class="badgeRow">
          <span class="badge"><span class="dot"></span><span>Topic: photon-counting noise</span></span>
          <span class="badge"><span class="dot" style="background:var(--accent2); box-shadow:0 0 0 3px rgba(114,240,195,.12)"></span><span>Key outputs: variance, SNR, comparisons</span></span>
          <span class="badge"><span class="dot" style="background:var(--warn); box-shadow:0 0 0 3px rgba(255,207,110,.12)"></span><span>Interactive: sweep mean photon number</span></span>
        </div>
      </div>
    </div>
  </header>

  <div class="layout">
    <nav aria-label="Table of contents">
      <h2>Table of Contents</h2>
      <ul class="toc">
        <li><a href="#quick">Quick Summary</a></li>
        <li><a href="#part0">PART 0 — Concept Primer</a></li>
        <li><a href="#part1">PART 1 — Problem Analysis</a></li>
        <li><a href="#part2">PART 2 — Strategy &amp; Tips</a></li>
        <li><a href="#part3">PART 3 — Full Solution</a></li>
        <li><a href="#part4">PART 4 — Deeper Understanding</a></li>
        <li><a href="#part5">PART 5 — Visualization Guide</a></li>
      </ul>
      <div class="hr"></div>
      <div class="control" style="margin-top:10px">
        <label for="nbarSlider">Interactive control: mean photon number <span class="eq">n̄</span> (example for plots)</label>
        <input id="nbarSlider" type="range" min="0.10" max="10.00" step="0.01" value="2.00" />
        <div class="valRow">
          <div class="bigVal"><span class="eq">n̄</span> = <span id="nbarVal">2.00</span></div>
          <div class="tiny">plots update live</div>
        </div>
        <div class="valRow" style="margin-top:8px">
          <div class="pill">Uniform support: <span class="eq">n = 0…M</span>, with <span class="eq">M ≈ 2 n̄</span></div>
        </div>
      </div>
    </nav>

    <main>
      <section id="quick">
        <h3>Quick Summary</h3>
        <ul>
          <li>We study photon-count fluctuations when the photon number is <strong>discrete-uniform</strong> over <span class="eq">n=0,1,2,…,M</span> with <span class="eq">p(n)=1/(M+1)</span>.</li>
          <li>With the problem’s parameterization <span class="eq">M = 2 n̄</span> (so the mean is <span class="eq">n̄</span>), the variance becomes <span class="eq">σ_n^2 = n̄(n̄+1)/3</span>.</li>
          <li>We use the photon-counting SNR definition <span class="eq">SNR = n̄/σ_n</span> (dimensionless).</li>
          <li>Uniform distribution SNR: <span class="eq">SNR_u = √(3 n̄/(n̄+1))</span>.</li>
          <li>Poisson (ideal single-mode laser/coherent): <span class="eq">σ^2=n̄</span>, so <span class="eq">SNR_P=√n̄</span>.</li>
          <li>Bose–Einstein (single-mode thermal): <span class="eq">σ^2=n̄(n̄+1)</span>, so <span class="eq">SNR_T=√(n̄/(n̄+1))</span>.</li>
          <li>Comparison with an ideal laser: uniform is <strong>quieter</strong> for <span class="eq">n̄&lt;2</span>, equal at <span class="eq">n̄=2</span>, and <strong>noisier</strong> for <span class="eq">n̄&gt;2</span>.</li>
          <li>Compared to single-mode thermal light, the uniform source has a constant SNR improvement factor <span class="eq">SNR_u/SNR_T = √3</span>.</li>
        </ul>

        <div class="copyRow">
          <button class="copyBtn" data-copy="p(n)=1/(M+1),  n=0,1,...,M;   with M=2 n̄">Copy distribution</button>
          <button class="copyBtn" data-copy="σ_n^2 = n̄(n̄+1)/3;   SNR_u = n̄/σ_n = √(3 n̄/(n̄+1))">Copy key result</button>
          <button class="copyBtn" data-copy="Poisson: σ^2=n̄, SNR=√n̄; Thermal: σ^2=n̄(n̄+1), SNR=√(n̄/(n̄+1))">Copy comparisons</button>
          <span class="pill" id="statusPill" aria-live="polite">Ready</span>
        </div>
      </section>

      <section id="part0">
        <h3>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h3>

        <div class="callouts">
          <div class="card">
            <div class="kicker">Core definitions</div>
            <ul>
              <li><strong>Photon number</strong> <span class="eq">n</span> (unitless): integer count of photons in a given mode/time window.</li>
              <li><strong>Probability mass function</strong> <span class="eq">p(n)</span>: probability that the measurement yields exactly <span class="eq">n</span> photons.</li>
              <li><strong>Mean photon number</strong> <span class="eq">n̄ = ⟨n⟩ = Σ_n n p(n)</span>.</li>
              <li><strong>Variance</strong> <span class="eq">σ_n^2 = ⟨(n-n̄)^2⟩ = ⟨n^2⟩ - n̄^2</span>.</li>
              <li><strong>SNR (counting)</strong> <span class="eq">SNR = n̄/σ_n</span>: “signal” is the mean count, “noise” is the standard deviation.</li>
            </ul>
          </div>
          <div class="card">
            <div class="kicker">Physical meaning</div>
            <ul>
              <li><span class="eq">n̄</span> sets the average brightness in the detection window.</li>
              <li><span class="eq">σ_n</span> quantifies shot-to-shot fluctuations of photon counts.</li>
              <li>Higher <span class="eq">SNR</span> means “quieter” light (relative fluctuations smaller).</li>
              <li>A useful derived metric is the <strong>Fano factor</strong> <span class="eq">F = σ_n^2 / n̄</span>:<br/>
                <span class="eq">F=1</span> Poisson (coherent), <span class="eq">F&gt;1</span> super-Poisson (bunched), <span class="eq">F&lt;1</span> sub-Poisson (quiet).</li>
            </ul>
          </div>
        </div>

        <h4>Key laws/principles and validity</h4>
        <ul>
          <li>All results here are <strong>probability/statistics</strong> applied to photon counts. We assume independent identically defined measurement windows and a stationary distribution.</li>
          <li>Poisson statistics model an <strong>ideal coherent state</strong> (good approximation for a single-mode laser well above threshold and without technical noise).</li>
          <li>Bose–Einstein statistics model <strong>single-mode thermal light</strong> (maximum bunching for a single mode; <span class="eq">g^(2)(0)=2</span>).</li>
        </ul>

        <h4>Common models/approximations</h4>
        <ul>
          <li><strong>Finite-support discrete uniform:</strong> all photon numbers in a range are equally likely. This is unusual physically, but can be engineered as a mixture of number states.</li>
          <li><strong>“Mean parameterization”:</strong> the problem sets the upper cutoff as <span class="eq">M=2n̄</span> so that the mean automatically equals <span class="eq">n̄</span>. In practice, for discrete <span class="eq">n</span> we need <span class="eq">M</span> to be an integer; treat <span class="eq">M</span> as the nearest integer when thinking about real implementations.</li>
        </ul>

        <h4>Mini intuition examples</h4>
        <ul>
          <li><strong>Poisson:</strong> if <span class="eq">n̄=9</span>, then <span class="eq">σ=3</span> and <span class="eq">SNR=3</span>. Relative noise <span class="eq">σ/n̄=1/3</span>.</li>
          <li><strong>Thermal:</strong> if <span class="eq">n̄=9</span>, then <span class="eq">σ≈√(9·10)=√90≈9.49</span>, so <span class="eq">SNR≈0.95</span> (much noisier due to bunching).</li>
        </ul>

        <div class="callouts">
          <div class="card">
            <div class="kicker">What to watch for</div>
            <ul>
              <li>Don’t confuse <span class="eq">σ</span> (standard deviation) with <span class="eq">σ^2</span> (variance).</li>
              <li>For a discrete uniform distribution, the formulas differ slightly from the continuous case.</li>
              <li>Be explicit about what “SNR” means (here: <span class="eq">n̄/σ</span>).</li>
              <li>Remember that <span class="eq">M=2n̄</span> implies <span class="eq">n̄</span> is (effectively) half an integer if <span class="eq">M</span> must be integer.</li>
            </ul>
          </div>
          <div class="card">
            <div class="kicker">Useful sums (discrete)</div>
            <div class="eqblock">
              <pre>Σ_{k=1}^{j} k = j(j+1)/2
Σ_{k=1}^{j} k^2 = j(j+1)(2j+1)/6</pre>
            </div>
          </div>
        </div>
      </section>

      <section id="part1">
        <h3>PART 1 — Problem Analysis (no solving yet)</h3>

        <h4>Problem rewritten</h4>
        <p>
          A light source produces a photon stream such that the photon number <span class="eq">n</span> in a fixed detection window is uniformly distributed over integers
          <span class="eq">0 ≤ n ≤ 2 n̄</span>:
          <span class="eq">p(n)=1/(2 n̄ + 1)</span> on that range, and <span class="eq">0</span> otherwise.
          (Equivalently, uniform over <span class="eq">n=0,1,...,M</span> with <span class="eq">M=2n̄</span>.)
        </p>

        <div class="grid2">
          <div class="card">
            <div class="kicker">Given</div>
            <ul>
              <li>Discrete uniform photon-number distribution on a finite set.</li>
              <li>Support: <span class="eq">n = 0,1,...,M</span> where <span class="eq">M = 2 n̄</span>.</li>
            </ul>
          </div>
          <div class="card">
            <div class="kicker">Unknowns / tasks</div>
            <ul>
              <li>(a) Verify normalization and mean <span class="eq">n̄</span>; compute <span class="eq">σ_n^2</span> and SNR; compare with Bose–Einstein and Poisson of same mean.</li>
              <li>(b) Decide if the source is quieter/noisier than an ideal single-mode laser for <span class="eq">n̄&lt;2</span>, <span class="eq">n̄=2</span>, <span class="eq">n̄&gt;2</span>.</li>
              <li>(c) Find factor by which its SNR exceeds that of single-mode thermal light.</li>
              <li>(d) Suggest a mechanism to generate this distribution.</li>
            </ul>
          </div>
        </div>

        <h4>Relevant principles (and why)</h4>
        <ul>
          <li><strong>Discrete probability:</strong> normalization and moments are computed by summation because photon number is integer-valued.</li>
          <li><strong>Moment method:</strong> compute <span class="eq">⟨n⟩</span> and <span class="eq">⟨n^2⟩</span>, then <span class="eq">σ^2=⟨n^2⟩-⟨n⟩^2</span>.</li>
          <li><strong>Benchmark statistics:</strong> Poisson (coherent/ideal laser) and Bose–Einstein (single-mode thermal) are standard references for “shot noise” and “bunching”.</li>
        </ul>

        <div class="callouts">
          <div class="card">
            <div class="kicker">Assumptions</div>
            <ul>
              <li>Photon counts are measured in identical time windows (stationary statistics).</li>
              <li>The distribution is exactly uniform on its support (no technical drift within a window).</li>
              <li>SNR is defined as <span class="eq">n̄/σ_n</span> (counting SNR).</li>
              <li>For comparisons, Poisson and Bose–Einstein are taken at the same mean <span class="eq">n̄</span>.</li>
            </ul>
          </div>
          <div class="card">
            <div class="kicker">Possible approaches</div>
            <ul>
              <li><strong>Direct summation:</strong> use known formulas for <span class="eq">Σ n</span> and <span class="eq">Σ n^2</span>. Fast, exact, best here.</li>
              <li><strong>Use known uniform-variance formula:</strong> for uniform integers <span class="eq">0..M</span>, <span class="eq">Var = M(M+2)/12</span>. Quick but less “derivation-friendly”.</li>
              <li><strong>Generating functions:</strong> overkill for this finite uniform case; useful if distributions are more complex.</li>
            </ul>
            <p class="muted" style="margin-top:8px"><strong>Chosen:</strong> direct summation (transparent, teaches the method).</p>
          </div>
        </div>
      </section>

      <section id="part2">
        <h3>PART 2 — Strategy &amp; Tips (roadmap only)</h3>
        <ol style="margin:8px 0 10px 20px">
          <li>
            <strong>Normalize</strong>: compute <span class="eq">Σ_{n=0}^{M} p(n)</span>.
            <span class="muted">Tool:</span> finite sum of constants.
            <span class="muted">Meaning:</span> ensures it is a valid probability distribution.
          </li>
          <li>
            <strong>Find the mean</strong> <span class="eq">⟨n⟩</span>:
            <span class="muted">Tool:</span> <span class="eq">⟨n⟩=Σ n p(n)</span> with <span class="eq">Σ n</span>.
            <span class="muted">Meaning:</span> average photon count (“brightness”).
          </li>
          <li>
            <strong>Compute</strong> <span class="eq">⟨n^2⟩</span>:
            <span class="muted">Tool:</span> <span class="eq">⟨n^2⟩=Σ n^2 p(n)</span> with <span class="eq">Σ n^2</span>.
            <span class="muted">Meaning:</span> needed for variance.
          </li>
          <li>
            <strong>Variance</strong>: use <span class="eq">σ^2 = ⟨n^2⟩ - ⟨n⟩^2</span>.
            <span class="muted">Meaning:</span> absolute count noise level.
          </li>
          <li>
            <strong>SNR</strong>: compute <span class="eq">SNR=n̄/σ</span>.
            <span class="muted">Meaning:</span> relative noisiness of the source.
          </li>
          <li>
            <strong>Benchmarks</strong>: write down Poisson and thermal variances at the same <span class="eq">n̄</span> and compare SNRs.
          </li>
          <li>
            <strong>Inequality test for part (b)</strong>: compare <span class="eq">SNR_u</span> vs <span class="eq">SNR_P</span> by squaring both sides to avoid algebraic mistakes.
          </li>
          <li>
            <strong>Factor for part (c)</strong>: take the ratio <span class="eq">SNR_u/SNR_T</span> and simplify.
          </li>
          <li>
            <strong>Mechanism (d)</strong>: interpret the uniform distribution as a uniform mixture of number states and propose a state-preparation / modulation / feedback scheme.
          </li>
        </ol>

        <div class="callouts">
          <div class="card">
            <div class="kicker">Common mistakes</div>
            <ul>
              <li>Forgetting the <span class="eq">n=0</span> term (it matters for normalization but not for <span class="eq">Σ n</span>).</li>
              <li>Using continuous-uniform variance <span class="eq">(b-a)^2/12</span> without discrete correction.</li>
              <li>Comparing variances when the question asks for SNR (you must take square roots).</li>
            </ul>
          </div>
          <div class="card">
            <div class="kicker">Quick tips</div>
            <ul>
              <li>Set <span class="eq">M=2n̄</span> early to keep expressions compact.</li>
              <li>When comparing SNRs, compare squared SNRs to keep it clean.</li>
              <li>Track whether you’re using <span class="eq">σ</span> or <span class="eq">σ^2</span> in each step.</li>
            </ul>
          </div>
        </div>
      </section>

      <section id="part3">
        <h3>PART 3 — Full Solution (DETAILED + TEACHING)</h3>

        <h4>Physical intuition first</h4>
        <p>
          A uniform photon-number distribution “spreads” probability evenly across a finite range.
          That makes it less “peaky” than Poisson for small means (where Poisson has relatively large fractional noise),
          but for large means Poisson becomes very sharp (<span class="eq">σ∝√n̄</span>) while the uniform distribution’s width scales roughly like the range (<span class="eq">σ∝n̄</span>), so uniform eventually becomes relatively noisier than Poisson.
          Compared to thermal light (which has very large fluctuations from bunching), a bounded uniform distribution should be substantially quieter.
        </p>

        <div class="card">
          <div class="kicker">Define the distribution cleanly</div>
          <p>
            Let <span class="eq">M</span> be the maximum photon number in the support.
            The discrete-uniform distribution is
            <span class="eq">p(n)=1/(M+1)</span> for integers <span class="eq">n=0,1,...,M</span>, and <span class="eq">p(n)=0</span> otherwise.
            The problem uses <span class="eq">M = 2 n̄</span> to enforce mean <span class="eq">n̄</span>.
          </p>
        </div>

        <h4>(a) Normalization and mean</h4>
        <p><strong>Normalization</strong> requires <span class="eq">Σ_{n=0}^{M} p(n)=1</span>.</p>
        <div class="eqblock">
          <pre>Σ_{n=0}^{M} p(n) = Σ_{n=0}^{M} 1/(M+1)
                 = (M+1) · 1/(M+1)
                 = 1.</pre>
        </div>
        <p class="muted">What we did: summed a constant probability over the (M+1) equally likely outcomes.</p>

        <p><strong>Mean photon number</strong> is <span class="eq">⟨n⟩=Σ n p(n)</span>:</p>
        <div class="eqblock">
          <pre>⟨n⟩ = Σ_{n=0}^{M} n · 1/(M+1)
    = (1/(M+1)) Σ_{n=1}^{M} n
    = (1/(M+1)) · [ M(M+1)/2 ]
    = M/2.</pre>
        </div>
        <p class="muted">We used Σn = M(M+1)/2 and noted the n=0 term contributes nothing.</p>
        <p>
          Therefore <span class="eq">⟨n⟩ = M/2</span>. If <span class="eq">M=2n̄</span>, then <span class="eq">⟨n⟩=n̄</span>, as requested.
        </p>

        <h4>(a) Variance</h4>
        <p>
          We compute <span class="eq">⟨n^2⟩</span> and then use <span class="eq">σ_n^2 = ⟨n^2⟩ - ⟨n⟩^2</span>.
        </p>
        <div class="eqblock">
          <pre>⟨n^2⟩ = Σ_{n=0}^{M} n^2 · 1/(M+1)
      = (1/(M+1)) Σ_{n=1}^{M} n^2
      = (1/(M+1)) · [ M(M+1)(2M+1)/6 ]
      = M(2M+1)/6.</pre>
        </div>
        <p class="muted">We used Σ n² = M(M+1)(2M+1)/6 and canceled (M+1).</p>

        <div class="eqblock">
          <pre>σ_n^2 = ⟨n^2⟩ - ⟨n⟩^2
     = [ M(2M+1)/6 ] - [ (M/2)^2 ]
     = (2M^2 + M)/6 - M^2/4
     = (4M^2 + 2M - 3M^2)/12
     = (M^2 + 2M)/12
     = M(M+2)/12.</pre>
        </div>
        <p class="muted">We put terms over a common denominator to simplify.</p>

        <div class="card">
          <div class="kicker">Substitute the problem parameterization</div>
          <p>
            With <span class="eq">M = 2n̄</span>:
          </p>
          <div class="eqblock">
            <pre>σ_n^2 = M(M+2)/12
     = (2n̄)(2n̄+2)/12
     = (4 n̄ (n̄+1))/12
     = n̄(n̄+1)/3.</pre>
          </div>
          <p>
            So the standard deviation is <span class="eq">σ_n = √( n̄(n̄+1)/3 )</span>.
          </p>
        </div>

        <h4>(a) SNR and comparison to Poisson &amp; Bose–Einstein</h4>
        <p>
          Using <span class="eq">SNR = n̄/σ_n</span>, the discrete-uniform SNR is
        </p>
        <div class="eqblock">
          <pre>SNR_u = n̄ / √( n̄(n̄+1)/3 )
      = √( 3 n̄ / (n̄+1) ).</pre>
        </div>

        <div class="grid2">
          <div class="card">
            <div class="kicker">Poisson (ideal single-mode laser / coherent)</div>
            <ul>
              <li><span class="eq">σ_P^2 = n̄</span></li>
              <li><span class="eq">SNR_P = n̄/√n̄ = √n̄</span></li>
            </ul>
          </div>
          <div class="card">
            <div class="kicker">Bose–Einstein (single-mode thermal)</div>
            <ul>
              <li><span class="eq">σ_T^2 = n̄(n̄+1)</span></li>
              <li><span class="eq">SNR_T = n̄/√(n̄(n̄+1)) = √( n̄/(n̄+1) )</span></li>
            </ul>
          </div>
        </div>

        <h4>(b) Quieter or noisier than an ideal laser?</h4>
        <p>
          “Quieter” in SNR terms means <strong>larger SNR</strong>.
          Compare <span class="eq">SNR_u</span> to <span class="eq">SNR_P</span>:
        </p>
        <div class="eqblock">
          <pre>SNR_u > SNR_P  ⇔  √(3 n̄/(n̄+1)) > √n̄
Square both sides (all positive):
3 n̄/(n̄+1) > n̄  ⇔  3/(n̄+1) > 1
⇔  3 > n̄ + 1
⇔  n̄ < 2.</pre>
        </div>
        <div class="card">
          <div class="kicker">Conclusion for (b)</div>
          <ul>
            <li>If <span class="eq">n̄ &lt; 2</span>: <span class="eq">SNR_u &gt; SNR_P</span> → uniform source is <strong>quieter</strong> than an ideal single-mode laser.</li>
            <li>If <span class="eq">n̄ = 2</span>: <span class="eq">SNR_u = SNR_P</span> → <strong>equally noisy</strong> in SNR terms.</li>
            <li>If <span class="eq">n̄ &gt; 2</span>: <span class="eq">SNR_u &lt; SNR_P</span> → uniform source is <strong>noisier</strong> than an ideal single-mode laser.</li>
          </ul>
        </div>

        <h4>(c) SNR improvement factor over single-mode thermal light</h4>
        <p>
          Compute the ratio:
        </p>
        <div class="eqblock">
          <pre>SNR_u / SNR_T
= √( 3 n̄/(n̄+1) ) / √( n̄/(n̄+1) )
= √3.</pre>
        </div>
        <div class="card">
          <div class="kicker">Conclusion for (c)</div>
          <p>
            The SNR of the discrete-uniform source is larger than that of single-mode thermal light by a constant factor
            <span class="eq">√3 ≈ 1.732</span>, independent of <span class="eq">n̄</span>.
          </p>
        </div>

        <h4>(d) Suggest a mechanism to generate this distribution</h4>
        <p>
          The state described is a <strong>uniform mixture of Fock (number) states</strong>:
          <span class="eq">ρ = (1/(M+1)) Σ_{n=0}^{M} |n⟩⟨n|</span>.
          This is not a typical “natural” optical state, but it is engineerable by <strong>state preparation + classical randomness</strong>.
        </p>
        <div class="callouts">
          <div class="card">
            <div class="kicker">One concrete mechanism (conceptual)</div>
            <ul>
              <li>Use a high-Q storage cavity.</li>
              <li>Have a heralded single-photon source (e.g., SPDC with a number-resolving herald) that can add photons to the cavity one by one.</li>
              <li>At each step <span class="eq">k</span> (starting from 0), flip a classical random decision:
                <strong>stop</strong> with probability <span class="eq">1/(M+1-k)</span>, otherwise add one photon and continue, until reaching <span class="eq">M</span>.</li>
              <li>This produces a uniform distribution over final photon numbers <span class="eq">0…M</span> (each stopping point is equally likely).</li>
            </ul>
          </div>
          <div class="card">
            <div class="kicker">Other plausible routes</div>
            <ul>
              <li><strong>Photon-number filtering:</strong> start with a broader distribution and use number-resolving detection + feedforward to accept events uniformly across a target range.</li>
              <li><strong>Active intensity stabilization + dithering:</strong> in a counting window, randomly set the mean of a near-number-state-like source across discrete levels and time-average to flatten the resulting mixture.</li>
              <li><strong>Quantum nondemolition (QND) measurement:</strong> repeatedly measure and condition on photon number bins, then randomize uniformly among bins via controlled photon addition/subtraction.</li>
            </ul>
          </div>
        </div>

        <h4>Sanity checks</h4>
        <div class="callouts">
          <div class="card">
            <div class="kicker">Units/dimensions</div>
            <p>
              <span class="eq">n</span>, <span class="eq">n̄</span>, and <span class="eq">σ</span> are all dimensionless counts.
              So <span class="eq">SNR = n̄/σ</span> is also dimensionless—consistent.
            </p>
          </div>
          <div class="card">
            <div class="kicker">Limiting cases</div>
            <ul>
              <li><span class="eq">n̄→0</span>: uniform collapses near vacuum; <span class="eq">SNR_u→0</span> as expected (no signal).</li>
              <li><span class="eq">n̄→∞</span>: <span class="eq">SNR_u→√3</span> (saturates), while <span class="eq">SNR_P=√n̄→∞</span> (Poisson gets relatively quieter).</li>
              <li>Thermal: <span class="eq">SNR_T→1</span> as <span class="eq">n̄→∞</span>, consistent with very large absolute fluctuations but comparable to the mean.</li>
            </ul>
          </div>
        </div>

        <div class="card">
          <div class="kicker">FINAL ANSWER (boxed)</div>
          <div class="eqblock">
            <pre>(a) For uniform n=0..M with p(n)=1/(M+1):
    ⟨n⟩=M/2,  Var=σ_n^2=M(M+2)/12.
    With M=2 n̄:  ⟨n⟩=n̄,  σ_n^2 = n̄(n̄+1)/3,
    SNR_u = n̄/σ_n = √(3 n̄/(n̄+1)).
    Poisson (laser): σ^2=n̄, SNR_P=√n̄.
    Thermal (Bose–Einstein, single mode): σ^2=n̄(n̄+1), SNR_T=√(n̄/(n̄+1)).

(b) Compared to ideal laser (Poisson):
    n̄<2 → SNR_u>SNR_P (quieter),
    n̄=2 → equal,
    n̄>2 → SNR_u<SNR_P (noisier).

(c) SNR_u / SNR_T = √3.

(d) Mechanism: engineer a uniform mixture of Fock states |n⟩, e.g., sequential photon-addition into a cavity with randomized stopping (or number-resolving conditioning + feedforward) to make all n=0..M equally likely.</pre>
          </div>
          <div class="copyRow">
            <button class="copyBtn" data-copy="Uniform n=0..M: ⟨n⟩=M/2, Var=M(M+2)/12. With M=2 n̄: Var=n̄(n̄+1)/3, SNR_u=√(3 n̄/(n̄+1)). Poisson: Var=n̄, SNR=√n̄. Thermal: Var=n̄(n̄+1), SNR=√(n̄/(n̄+1)). Laser comparison: n̄<2 quieter, n̄=2 equal, n̄>2 noisier. SNR ratio vs thermal: √3.">Copy final answer (plain text)</button>
          </div>
        </div>
      </section>

      <section id="part4">
        <h3>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h3>

        <h4>Re-interpreting the final formulas</h4>
        <div class="grid2">
          <div class="card">
            <div class="kicker">Uniform statistics</div>
            <p>
              <span class="eq">σ_u^2 = n̄(n̄+1)/3</span> grows ~ <span class="eq">n̄^2/3</span> for large <span class="eq">n̄</span>, because the distribution’s width scales with its cutoff <span class="eq">M=2n̄</span>.
            </p>
            <p class="muted">
              That’s why <span class="eq">SNR_u</span> approaches a constant <span class="eq">√3</span> at large <span class="eq">n̄</span>.
            </p>
          </div>
          <div class="card">
            <div class="kicker">Benchmarks</div>
            <p>
              Poisson noise has <span class="eq">σ_P^2=n̄</span> so <span class="eq">σ_P∝√n̄</span>, giving <span class="eq">SNR_P=√n̄</span> that increases without bound.
              Thermal light has <span class="eq">σ_T^2=n̄(n̄+1)</span>, so <span class="eq">σ_T≈n̄</span> at large means and <span class="eq">SNR_T→1</span>.
            </p>
          </div>
        </div>

        <h4>How changing <span class="eq">n̄</span> affects the outcome (connect to plots)</h4>
        <ul>
          <li><strong>Main SNR plot:</strong> as you increase <span class="eq">n̄</span>, the Poisson curve rises like <span class="eq">√n̄</span>, the thermal curve saturates to 1, and the uniform curve saturates to <span class="eq">√3</span>.</li>
          <li><strong>Secondary plot (Fano factor):</strong> Poisson stays at <span class="eq">F=1</span>, thermal increases like <span class="eq">F=n̄+1</span>, and uniform increases like <span class="eq">F=(n̄+1)/3</span>.</li>
          <li>The crossover at <span class="eq">n̄=2</span> (uniform vs Poisson SNR) is visible in the SNR plot.</li>
        </ul>

        <h4>Alternative derivation idea</h4>
        <p>
          You could quote the known result for a discrete uniform distribution on integers <span class="eq">0..M</span>:
          <span class="eq">Var = (M^2-1)/12</span> for support <span class="eq">1..M</span>, and adjust for shifting/scaling.
          Using the direct summation we did is usually safer (no risk of mixing conventions).
        </p>

        <h4>Concept check (self-test)</h4>
        <ul>
          <li><strong>Q:</strong> If <span class="eq">n̄</span> is large, why doesn’t <span class="eq">SNR_u</span> grow like <span class="eq">√n̄</span>?<br/>
              <strong>A:</strong> Because the uniform support width scales with <span class="eq">n̄</span>, so <span class="eq">σ∝n̄</span>, making <span class="eq">n̄/σ</span> approach a constant.</li>
          <li><strong>Q:</strong> What does <span class="eq">F&lt;1</span> indicate? Is the uniform source sub-Poisson?<br/>
              <strong>A:</strong> <span class="eq">F&lt;1</span> is sub-Poisson. For uniform, <span class="eq">F_u=(n̄+1)/3</span>, so it is sub-Poisson only when <span class="eq">n̄&lt;2</span>.</li>
          <li><strong>Q:</strong> Thermal light has higher or lower SNR than Poisson at the same <span class="eq">n̄</span>?<br/>
              <strong>A:</strong> Lower SNR (more noise): <span class="eq">SNR_T=√(n̄/(n̄+1)) &lt; √n̄</span> for all <span class="eq">n̄&gt;0</span>.</li>
          <li><strong>Q:</strong> Why is <span class="eq">SNR_u/SNR_T</span> constant? <br/>
              <strong>A:</strong> Both variances scale as <span class="eq">n̄(n̄+1)</span> up to a constant factor (1 vs 1/3), so the square-root ratio is <span class="eq">√3</span>.</li>
        </ul>
      </section>

      <section id="part5">
        <h3>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h3>

        <div class="grid3">
          <figure class="canvasTall">
            <canvas id="diagramCanvas"></canvas>
            <figcaption>
              <strong>Diagram:</strong> photon-counting setup (source → detector) plus an inset histogram of the discrete-uniform <span class="eq">p(n)</span> for the chosen <span class="eq">n̄</span> (example). The support uses <span class="eq">M=round(2n̄)</span> for visualizing integer outcomes.
            </figcaption>
          </figure>

          <div class="card">
            <div class="kicker">Interactive control</div>
            <p class="muted" style="margin-top:6px">
              Use the slider to change <span class="eq">n̄</span>. This updates:
            </p>
            <ul>
              <li>Histogram width (<span class="eq">M≈2n̄</span>) in the diagram.</li>
              <li>Markers on both plots at the selected <span class="eq">n̄</span>.</li>
              <li>Displayed numeric values for <span class="eq">SNR</span> and <span class="eq">F</span>.</li>
            </ul>
            <div class="hr"></div>
            <div class="kicker">What to look for</div>
            <ul>
              <li>SNR crossover near <span class="eq">n̄=2</span> between uniform and Poisson.</li>
              <li>Uniform SNR saturation to <span class="eq">√3</span>.</li>
              <li>Thermal SNR saturation to <span class="eq">1</span>.</li>
            </ul>
          </div>
        </div>

        <div class="grid2" style="margin-top:12px">
          <figure class="canvasShort">
            <canvas id="snrCanvas"></canvas>
            <figcaption>
              <strong>Main plot:</strong> <span class="eq">SNR(n̄)</span> for uniform, Poisson, and thermal statistics. Axes include gridlines and ticks; marker shows the current slider value.
            </figcaption>
          </figure>

          <figure class="canvasShort">
            <canvas id="fanoCanvas"></canvas>
            <figcaption>
              <strong>Secondary plot:</strong> Fano factor <span class="eq">F=σ^2/n̄</span> vs <span class="eq">n̄</span>. Poisson stays at 1; thermal grows as <span class="eq">n̄+1</span>; uniform grows as <span class="eq">(n̄+1)/3</span>.
            </figcaption>
          </figure>
        </div>

        <div class="card" style="margin-top:12px">
          <div class="kicker">Live numerical readout (from the same formulas used in the text)</div>
          <div class="grid2">
            <div>
              <p style="margin:6px 0"><strong>Uniform:</strong> <span class="eq">σ_u^2 = n̄(n̄+1)/3</span>, <span class="eq">SNR_u = √(3n̄/(n̄+1))</span></p>
              <p style="margin:6px 0"><strong>Poisson:</strong> <span class="eq">σ_P^2=n̄</span>, <span class="eq">SNR_P=√n̄</span></p>
              <p style="margin:6px 0"><strong>Thermal:</strong> <span class="eq">σ_T^2=n̄(n̄+1)</span>, <span class="eq">SNR_T=√(n̄/(n̄+1))</span></p>
            </div>
            <div class="card" style="background:rgba(0,0,0,.12)">
              <p style="margin:6px 0"><span class="pill">At current <span class="eq">n̄</span></span></p>
              <p style="margin:8px 0" class="muted">
                <span class="eq">SNR_u</span> = <span id="snrU" class="eq">—</span> &nbsp;|&nbsp;
                <span class="eq">SNR_P</span> = <span id="snrP" class="eq">—</span> &nbsp;|&nbsp;
                <span class="eq">SNR_T</span> = <span id="snrT" class="eq">—</span>
              </p>
              <p style="margin:8px 0" class="muted">
                <span class="eq">F_u</span> = <span id="fU" class="eq">—</span> &nbsp;|&nbsp;
                <span class="eq">F_P</span> = <span id="fP" class="eq">—</span> &nbsp;|&nbsp;
                <span class="eq">F_T</span> = <span id="fT" class="eq">—</span>
              </p>
              <p style="margin:8px 0" class="muted">
                Thermal improvement: <span class="eq">SNR_u/SNR_T</span> = <span id="ratioUT" class="eq">—</span> (should be <span class="eq">√3</span>)
              </p>
            </div>
          </div>
        </div>
      </section>

      <footer class="footer">
        <div class="hr"></div>
        <p>
          This article used only discrete probability and standard photon statistics benchmarks. The plotted values use the same symbolic formulas derived above.
          For real experimental realizations, remember that enforcing an exactly uniform mixture over photon number is a state-engineering challenge—yet it’s conceptually clear how conditioning + feedforward can approximate it.
        </p>
      </footer>
    </main>
  </div>

  <script>
    // ---------- Utilities ----------
    const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
    const fmt = (x, d=3) => {
      if (!isFinite(x)) return "—";
      const s = x.toFixed(d);
      // trim trailing zeros for nicer display
      return s.replace(/\.?0+$/,'');
    };

    function copyText(text){
      return navigator.clipboard.writeText(text);
    }

    // ---------- Copy buttons ----------
    (function(){
      const pill = document.getElementById('statusPill');
      document.querySelectorAll('.copyBtn').forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          const txt = btn.getAttribute('data-copy') || '';
          try{
            await copyText(txt);
            pill.textContent = "Copied ✓";
            pill.style.borderColor = "rgba(141,255,154,.45)";
            setTimeout(()=>{
              pill.textContent = "Ready";
              pill.style.borderColor = "rgba(255,255,255,.10)";
            }, 900);
          }catch(e){
            pill.textContent = "Copy failed";
            pill.style.borderColor = "rgba(255,122,155,.45)";
            setTimeout(()=>{
              pill.textContent = "Ready";
              pill.style.borderColor = "rgba(255,255,255,.10)";
            }, 1100);
          }
        });
      });
    })();

    // ---------- Canvas plotting framework ----------
    class HiDPICanvas {
      constructor(canvas){
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.dpr = window.devicePixelRatio || 1;
        this.resizeObserver = new ResizeObserver(()=>this.resize());
        this.resizeObserver.observe(canvas);
        this.resize();
      }
      resize(){
        const rect = this.canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        this.dpr = dpr;
        this.canvas.width = Math.max(2, Math.floor(rect.width * dpr));
        this.canvas.height = Math.max(2, Math.floor(rect.height * dpr));
        this.ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
        if (this.onResize) this.onResize();
      }
      clear(){
        const rect = this.canvas.getBoundingClientRect();
        this.ctx.clearRect(0,0,rect.width,rect.height);
      }
      size(){
        const rect = this.canvas.getBoundingClientRect();
        return {w: rect.width, h: rect.height};
      }
    }

    function drawPanelBackground(ctx, x, y, w, h){
      // subtle background to improve contrast (still transparent overall)
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgba(0,0,0,0.18)";
      roundRect(ctx, x, y, w, h, 16);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, opts){
      const {x, y, w, h} = box;
      const padL = opts.padL ?? 56;
      const padR = opts.padR ?? 18;
      const padT = opts.padT ?? 34;
      const padB = opts.padB ?? 48;
      const plot = { x: x+padL, y: y+padT, w: w-padL-padR, h: h-padT-padB };

      // background
      ctx.save();
      drawPanelBackground(ctx, x, y, w, h);

      // title
      ctx.fillStyle = "rgba(233,238,252,0.95)";
      ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(opts.title ?? "", x+14, y+20);

      // gridlines + ticks
      const xTicks = opts.xTicks ?? 6;
      const yTicks = opts.yTicks ?? 5;

      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.lineWidth = 1;

      // vertical grid + x tick labels
      ctx.fillStyle = "rgba(183,195,234,0.85)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      for(let i=0;i<=xTicks;i++){
        const t = i/xTicks;
        const xx = plot.x + t*plot.w;
        ctx.beginPath();
        ctx.moveTo(xx, plot.y);
        ctx.lineTo(xx, plot.y+plot.h);
        ctx.stroke();
        const val = xMin + t*(xMax-xMin);
        const s = fmt(val, opts.xTickDP ?? 1);
        ctx.fillText(s, xx-ctx.measureText(s).width/2, plot.y+plot.h+18);
      }

      // horizontal grid + y tick labels
      for(let j=0;j<=yTicks;j++){
        const t = j/yTicks;
        const yy = plot.y + (1-t)*plot.h;
        ctx.beginPath();
        ctx.moveTo(plot.x, yy);
        ctx.lineTo(plot.x+plot.w, yy);
        ctx.stroke();
        const val = yMin + t*(yMax-yMin);
        const s = fmt(val, opts.yTickDP ?? 1);
        ctx.fillText(s, plot.x-10-ctx.measureText(s).width, yy+4);
      }

      // axes lines
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(plot.x, plot.y);
      ctx.lineTo(plot.x, plot.y+plot.h);
      ctx.lineTo(plot.x+plot.w, plot.y+plot.h);
      ctx.stroke();

      // axis labels
      ctx.fillStyle = "rgba(183,195,234,0.95)";
      ctx.font = "12.5px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      const xLabel = opts.xLabel ?? "";
      const yLabel = opts.yLabel ?? "";
      // x label
      ctx.fillText(xLabel, plot.x + plot.w/2 - ctx.measureText(xLabel).width/2, y + h - 14);

      // y label rotated
      ctx.save();
      ctx.translate(x+16, plot.y+plot.h/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
      ctx.restore();

      // legend (optional)
      if(opts.legend && opts.legend.length){
        const items = opts.legend;
        let lx = plot.x + 8;
        let ly = plot.y + 8;
        ctx.font = "12.5px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        items.forEach((it, idx)=>{
          const label = it.label;
          const color = it.color;
          // swatch line
          ctx.strokeStyle = color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(lx, ly + idx*18);
          ctx.lineTo(lx+18, ly + idx*18);
          ctx.stroke();
          ctx.fillStyle = "rgba(233,238,252,0.92)";
          ctx.fillText(label, lx+24, ly+4 + idx*18);
        });
      }

      ctx.restore();

      const xToPx = (xVal) => plot.x + (xVal - xMin) / (xMax - xMin) * plot.w;
      const yToPx = (yVal) => plot.y + (1 - (yVal - yMin) / (yMax - yMin)) * plot.h;

      return {plot, xToPx, yToPx};
    }

    function drawCurve(ctx, mapper, fn, xMin, xMax, steps, color){
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2.4;
      ctx.beginPath();
      for(let i=0;i<=steps;i++){
        const x = xMin + (i/steps)*(xMax-xMin);
        const y = fn(x);
        const px = mapper.xToPx(x);
        const py = mapper.yToPx(y);
        if(i===0) ctx.moveTo(px,py);
        else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawMarker(ctx, mapper, xVal, yVal, color){
      const px = mapper.xToPx(xVal);
      const py = mapper.yToPx(yVal);
      ctx.save();
      ctx.fillStyle = color;
      ctx.strokeStyle = "rgba(255,255,255,0.85)";
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.arc(px, py, 5.5, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    // ---------- Physics formulas ----------
    function snrUniform(nbar){ return Math.sqrt(3*nbar/(nbar+1)); }
    function snrPoisson(nbar){ return Math.sqrt(nbar); }
    function snrThermal(nbar){ return Math.sqrt(nbar/(nbar+1)); }

    function fanoUniform(nbar){ return (nbar+1)/3; }     // Var/nbar = [nbar(nbar+1)/3]/nbar
    function fanoPoisson(_nbar){ return 1; }
    function fanoThermal(nbar){ return (nbar*(nbar+1))/nbar; } // = nbar+1

    // ---------- Diagram (setup + histogram inset) ----------
    const diagram = new HiDPICanvas(document.getElementById('diagramCanvas'));
    const snrPlot = new HiDPICanvas(document.getElementById('snrCanvas'));
    const fanoPlot = new HiDPICanvas(document.getElementById('fanoCanvas'));

    function drawDiagram(nbar){
      const ctx = diagram.ctx;
      const {w,h} = diagram.size();
      ctx.clearRect(0,0,w,h);

      // outer panel
      drawPanelBackground(ctx, 10, 10, w-20, h-20);

      // title
      ctx.fillStyle = "rgba(233,238,252,0.95)";
      ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Photon-counting setup + uniform p(n) histogram (example)", 24, 34);

      // Draw source box
      const sx = 44, sy = 70, sw = Math.min(240, w*0.34), sh = 90;
      ctx.fillStyle = "rgba(122,167,255,0.10)";
      ctx.strokeStyle = "rgba(122,167,255,0.35)";
      ctx.lineWidth = 1.4;
      roundRect(ctx, sx, sy, sw, sh, 18);
      ctx.fill(); ctx.stroke();

      ctx.fillStyle = "rgba(233,238,252,0.95)";
      ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Light source", sx+14, sy+28);

      ctx.fillStyle = "rgba(183,195,234,0.92)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      const M = Math.max(0, Math.round(2*nbar));
      ctx.fillText(`p(n)=1/(M+1) on n=0..M`, sx+14, sy+52);
      ctx.fillText(`M = round(2 n̄) = ${M}`, sx+14, sy+72);

      // Draw detector box
      const dx = w - 44 - sw, dy = sy, dw = sw, dh = sh;
      ctx.fillStyle = "rgba(114,240,195,0.09)";
      ctx.strokeStyle = "rgba(114,240,195,0.35)";
      ctx.lineWidth = 1.4;
      roundRect(ctx, dx, dy, dw, dh, 18);
      ctx.fill(); ctx.stroke();

      ctx.fillStyle = "rgba(233,238,252,0.95)";
      ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Photon-number", dx+14, dy+28);
      ctx.fillText("detector", dx+14, dy+46);

      ctx.fillStyle = "rgba(183,195,234,0.92)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      ctx.fillText("outputs integer n", dx+14, dy+70);

      // Arrow between
      const ax1 = sx+sw+16, ay = sy+sh/2;
      const ax2 = dx-16;
      ctx.strokeStyle = "rgba(233,238,252,0.70)";
      ctx.lineWidth = 2.0;
      ctx.beginPath();
      ctx.moveTo(ax1, ay);
      ctx.lineTo(ax2, ay);
      ctx.stroke();
      // arrowhead
      ctx.fillStyle = "rgba(233,238,252,0.70)";
      ctx.beginPath();
      ctx.moveTo(ax2, ay);
      ctx.lineTo(ax2-12, ay-7);
      ctx.lineTo(ax2-12, ay+7);
      ctx.closePath();
      ctx.fill();

      // Small "count window" glyph under arrow
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 1.3;
      ctx.beginPath();
      ctx.moveTo((ax1+ax2)/2 - 34, ay+22);
      ctx.lineTo((ax1+ax2)/2 + 34, ay+22);
      ctx.stroke();
      ctx.fillStyle = "rgba(183,195,234,0.90)";
      ctx.font = "12.5px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("fixed time window", (ax1+ax2)/2 - 54, ay+44);

      // Histogram inset
      const hx = 44, hy = sy + sh + 32;
      const hw = w - 88;
      const hh = h - hy - 44;
      // inset box
      ctx.fillStyle = "rgba(0,0,0,0.10)";
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;
      roundRect(ctx, hx, hy, hw, hh, 18);
      ctx.fill(); ctx.stroke();

      // axes inside inset
      const padL=54, padR=18, padT=20, padB=42;
      const px = hx+padL, py = hy+padT, pw = hw-padL-padR, ph = hh-padT-padB;
      // gridlines
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.lineWidth = 1;
      for(let i=0;i<=6;i++){
        const xx = px + (i/6)*pw;
        ctx.beginPath(); ctx.moveTo(xx, py); ctx.lineTo(xx, py+ph); ctx.stroke();
      }
      for(let j=0;j<=4;j++){
        const yy = py + (j/4)*ph;
        ctx.beginPath(); ctx.moveTo(px, yy); ctx.lineTo(px+pw, yy); ctx.stroke();
      }
      // axis lines
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 1.2;
      ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px,py+ph); ctx.lineTo(px+pw,py+ph); ctx.stroke();

      // labels
      ctx.fillStyle = "rgba(183,195,234,0.95)";
      ctx.font = "12.5px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("n (photons)", px + pw/2 - 40, hy + hh - 14);
      ctx.save();
      ctx.translate(hx+18, py + ph/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText("p(n)", -14, 0);
      ctx.restore();

      // bar chart: uniform p=1/(M+1)
      const p = 1/(M+1);
      const yMax = Math.max(p*1.25, 0.25); // keep visible even for large M
      const toY = (v)=> py + (1 - v/yMax)*ph;

      // ticks
      ctx.fillStyle = "rgba(183,195,234,0.85)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      for(let i=0;i<=6;i++){
        const t=i/6;
        const nTick = Math.round(t*M);
        const xx = px + t*pw;
        const s = String(nTick);
        ctx.fillText(s, xx-ctx.measureText(s).width/2, py+ph+18);
      }
      for(let j=0;j<=4;j++){
        const t=j/4;
        const val = (1-t)*yMax;
        const s = fmt(val, 2);
        const yy = py + t*ph;
        ctx.fillText(s, px-10-ctx.measureText(s).width, yy+4);
      }

      // bars
      const nBars = Math.min(M+1, 60); // cap bars for readability; still represents uniform
      const step = (M+1)/nBars;
      const barW = pw/nBars;

      ctx.fillStyle = "rgba(122,167,255,0.35)";
      ctx.strokeStyle = "rgba(122,167,255,0.60)";
      ctx.lineWidth = 1;
      for(let i=0;i<nBars;i++){
        const x0 = px + i*barW + 0.5;
        const y0 = toY(p);
        const y1 = py+ph;
        const bh = y1-y0;
        ctx.fillRect(x0, y0, barW-1, bh);
      }

      // annotate mean
      const meanX = px + ( (nbar)/(M||1) )*pw;
      ctx.strokeStyle = "rgba(114,240,195,0.85)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(meanX, py);
      ctx.lineTo(meanX, py+ph);
      ctx.stroke();
      ctx.fillStyle = "rgba(233,238,252,0.92)";
      ctx.font = "600 12.5px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("mean n̄", meanX+6, py+16);
    }

    // ---------- Plots ----------
    function drawSNRPlot(nbar){
      const ctx = snrPlot.ctx;
      const {w,h} = snrPlot.size();
      ctx.clearRect(0,0,w,h);

      const xMin=0.1, xMax=10.0;
      // y max: Poisson at 10 => sqrt(10)=3.16; add headroom
      const yMin=0, yMax=3.6;

      const mapper = drawAxes(ctx, {x:10,y:10,w:w-20,h:h-20}, xMin,xMax,yMin,yMax, {
        title: "SNR vs mean photon number n̄",
        xLabel: "n̄ (photons per window)",
        yLabel: "SNR = n̄/σ",
        xTicks: 6,
        yTicks: 6,
        xTickDP: 1,
        yTickDP: 1,
        legend: [
          {label:"Uniform", color:"rgba(122,167,255,0.95)"},
          {label:"Poisson (laser)", color:"rgba(233,238,252,0.88)"},
          {label:"Thermal", color:"rgba(114,240,195,0.95)"}
        ]
      });

      // curves
      drawCurve(ctx, mapper, snrUniform, xMin, xMax, 400, "rgba(122,167,255,0.95)");
      drawCurve(ctx, mapper, snrPoisson, xMin, xMax, 400, "rgba(233,238,252,0.80)");
      drawCurve(ctx, mapper, snrThermal, xMin, xMax, 400, "rgba(114,240,195,0.95)");

      // marker
      drawMarker(ctx, mapper, nbar, snrUniform(nbar), "rgba(122,167,255,0.95)");
      drawMarker(ctx, mapper, nbar, snrPoisson(nbar), "rgba(233,238,252,0.88)");
      drawMarker(ctx, mapper, nbar, snrThermal(nbar), "rgba(114,240,195,0.95)");

      // highlight crossover nbar=2 between uniform and poisson
      const xCross = 2.0;
      const yCross = snrPoisson(xCross);
      ctx.save();
      ctx.strokeStyle = "rgba(255,207,110,0.85)";
      ctx.lineWidth = 2;
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(mapper.xToPx(xCross), mapper.plot.y);
      ctx.lineTo(mapper.xToPx(xCross), mapper.plot.y + mapper.plot.h);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(255,207,110,0.95)";
      ctx.font = "600 12.5px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("crossover n̄=2", mapper.xToPx(xCross)+6, mapper.plot.y+18);
      ctx.restore();
    }

    function drawFanoPlot(nbar){
      const ctx = fanoPlot.ctx;
      const {w,h} = fanoPlot.size();
      ctx.clearRect(0,0,w,h);

      const xMin=0.1, xMax=10.0;
      // Thermal Fano = nbar+1 => 11 at 10
      const yMin=0, yMax=12;

      const mapper = drawAxes(ctx, {x:10,y:10,w:w-20,h:h-20}, xMin,xMax,yMin,yMax, {
        title: "Fano factor F = σ²/n̄ (noise type indicator)",
        xLabel: "n̄ (photons per window)",
        yLabel: "F (dimensionless)",
        xTicks: 6,
        yTicks: 6,
        xTickDP: 1,
        yTickDP: 0,
        legend: [
          {label:"Uniform", color:"rgba(122,167,255,0.95)"},
          {label:"Poisson", color:"rgba(233,238,252,0.88)"},
          {label:"Thermal", color:"rgba(114,240,195,0.95)"}
        ]
      });

      drawCurve(ctx, mapper, fanoUniform, xMin, xMax, 400, "rgba(122,167,255,0.95)");
      drawCurve(ctx, mapper, fanoPoisson, xMin, xMax, 20, "rgba(233,238,252,0.80)");
      drawCurve(ctx, mapper, fanoThermal, xMin, xMax, 400, "rgba(114,240,195,0.95)");

      drawMarker(ctx, mapper, nbar, fanoUniform(nbar), "rgba(122,167,255,0.95)");
      drawMarker(ctx, mapper, nbar, fanoPoisson(nbar), "rgba(233,238,252,0.88)");
      drawMarker(ctx, mapper, nbar, fanoThermal(nbar), "rgba(114,240,195,0.95)");

      // F=1 reference line
      ctx.save();
      ctx.strokeStyle = "rgba(255,207,110,0.75)";
      ctx.lineWidth = 2;
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(mapper.plot.x, mapper.yToPx(1));
      ctx.lineTo(mapper.plot.x + mapper.plot.w, mapper.yToPx(1));
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(255,207,110,0.95)";
      ctx.font = "600 12.5px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("F=1 (Poisson)", mapper.plot.x+8, mapper.yToPx(1)-8);
      ctx.restore();
    }

    // ---------- Live readouts ----------
    function updateReadouts(nbar){
      document.getElementById('nbarVal').textContent = fmt(nbar, 2);

      const su = snrUniform(nbar);
      const sp = snrPoisson(nbar);
      const st = snrThermal(nbar);

      document.getElementById('snrU').textContent = fmt(su, 4);
      document.getElementById('snrP').textContent = fmt(sp, 4);
      document.getElementById('snrT').textContent = fmt(st, 4);

      document.getElementById('fU').textContent = fmt(fanoUniform(nbar), 4);
      document.getElementById('fP').textContent = fmt(fanoPoisson(nbar), 4);
      document.getElementById('fT').textContent = fmt(fanoThermal(nbar), 4);

      document.getElementById('ratioUT').textContent = fmt(su/st, 4);
    }

    // ---------- Master redraw ----------
    function redrawAll(){
      const nbar = parseFloat(document.getElementById('nbarSlider').value);
      updateReadouts(nbar);
      drawDiagram(nbar);
      drawSNRPlot(nbar);
      drawFanoPlot(nbar);
    }

    // Hook slider
    const slider = document.getElementById('nbarSlider');
    slider.addEventListener('input', redrawAll);

    // Redraw on resize (each canvas resizes itself, then call redraw)
    diagram.onResize = redrawAll;
    snrPlot.onResize = redrawAll;
    fanoPlot.onResize = redrawAll;

    // Initial draw
    redrawAll();

    // ---------- Smooth TOC scrolling ----------
    document.querySelectorAll('nav a[href^="#"]').forEach(a=>{
      a.addEventListener('click', (e)=>{
        e.preventDefault();
        const id = a.getAttribute('href').slice(1);
        const el = document.getElementById(id);
        if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
      });
    });
  </script>
</body>
</html>
