<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Binomial Photon-Number Distribution: Normalization, Moments, and SNR</title>
  <style>
    :root{
      --bg:#0b0f17;
      --card:#111827;
      --card2:#0f172a;
      --text:#e5e7eb;
      --muted:#a7b0bf;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(125,211,252,.14), transparent 60%),
        radial-gradient(900px 500px at 95% 0%, rgba(167,139,250,.14), transparent 55%),
        radial-gradient(900px 600px at 40% 105%, rgba(52,211,153,.10), transparent 60%),
        var(--bg);
      line-height:1.55;
    }
    header{
      padding:28px 18px 10px;
      max-width:1200px;
      margin:0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.35fr .65fr;
      gap:16px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns:1fr}
    }
    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:18px 18px 16px;
      box-shadow:var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .titleCard:before{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(700px 260px at 15% 0%, rgba(125,211,252,.20), transparent 55%),
        radial-gradient(700px 260px at 85% 0%, rgba(167,139,250,.18), transparent 55%);
      opacity:.55;
      pointer-events:none;
    }
    .titleCard > *{position:relative}
    h1{
      margin:0 0 6px;
      font-size:clamp(22px, 3.1vw, 34px);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size:clamp(13px, 1.5vw, 15px);
    }
    .metaRow{
      margin-top:12px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      color:var(--muted);
      font-size:12.5px;
      white-space:nowrap;
    }
    .pill b{color:var(--text); font-weight:650}
    .controlCard{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:14px;
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .controls{
      display:grid;
      gap:10px;
    }
    .ctrl{
      display:grid;
      gap:6px;
    }
    .ctrl label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:13px;
      color:var(--muted);
    }
    .ctrl label span.value{
      color:var(--text);
      font-variant-numeric: tabular-nums;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    input[type="number"]{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.25);
      color:var(--text);
      font-size:14px;
      outline:none;
    }
    .miniNote{
      margin:8px 0 0;
      color:var(--muted);
      font-size:12px;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding:14px 18px 70px;
      display:grid;
      grid-template-columns: 280px 1fr;
      gap:16px;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
    }
    aside.toc{
      position:sticky;
      top:12px;
      align-self:start;
      background:rgba(17,24,39,.70);
      backdrop-filter: blur(10px);
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:14px 12px;
      box-shadow:var(--shadow);
    }
    @media (max-width: 980px){
      aside.toc{position:relative; top:auto}
    }
    .toc h2{
      margin:0 0 8px;
      font-size:14px;
      color:var(--muted);
      letter-spacing:.3px;
      text-transform:uppercase;
    }
    .toc a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      color:var(--text);
      text-decoration:none;
      font-size:13px;
      border:1px solid transparent;
    }
    .toc a:hover{
      background:rgba(255,255,255,.04);
      border-color:rgba(255,255,255,.08);
    }
    .toc a small{color:var(--muted)}
    .content{
      display:grid;
      gap:14px;
    }

    section.card{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:18px;
      box-shadow:var(--shadow);
      animation: fadeUp .45s ease both;
    }
    @keyframes fadeUp{
      from{opacity:0; transform:translateY(6px)}
      to{opacity:1; transform:translateY(0)}
    }
    section.card h2{
      margin:0 0 10px;
      font-size:18px;
      letter-spacing:.2px;
    }
    section.card h3{
      margin:14px 0 8px;
      font-size:15.5px;
      color:var(--text);
    }
    p{margin:10px 0; color:rgba(229,231,235,.95)}
    ul{margin:8px 0 10px 18px; color:rgba(229,231,235,.95)}
    li{margin:6px 0}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 780px){
      .grid2{grid-template-columns:1fr}
    }

    .callout{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius:16px;
      padding:12px 12px;
    }
    .callout strong{color:var(--accent)}
    .callout.warn strong{color:var(--warn)}
    .callout.good strong{color:var(--good)}
    .callout.bad strong{color:var(--bad)}
    .eq{
      position:relative;
      margin:10px 0;
      padding:12px 12px 12px 12px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(15,23,42,.65);
      overflow:hidden;
    }
    .eq pre{
      margin:0;
      font-family:var(--mono);
      font-size:13px;
      color:rgba(229,231,235,.95);
      white-space:pre-wrap;
      word-break:break-word;
    }
    .copyBtn{
      position:absolute;
      top:10px;
      right:10px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:var(--text);
      font-size:12px;
      padding:6px 9px;
      border-radius:12px;
      cursor:pointer;
      transition: transform .08s ease, background .2s ease;
    }
    .copyBtn:hover{background: rgba(255,255,255,.10)}
    .copyBtn:active{transform: scale(.98)}
    .kpiRow{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 900px){
      .kpiRow{grid-template-columns: 1fr 1fr}
    }
    @media (max-width: 520px){
      .kpiRow{grid-template-columns: 1fr}
    }
    .kpi{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.16);
      border-radius:16px;
      padding:10px 12px;
    }
    .kpi .label{
      color:var(--muted);
      font-size:12px;
    }
    .kpi .val{
      font-size:16px;
      margin-top:4px;
      font-variant-numeric: tabular-nums;
    }

    figure{
      margin:10px 0 0;
      border-radius:16px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }
    figure figcaption{
      padding:10px 12px;
      color:var(--muted);
      font-size:12.5px;
      border-top:1px solid rgba(255,255,255,.08);
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
    }
    .canvasTall canvas{height:360px}
    .canvasShort canvas{height:280px}
    .foot{
      margin-top:8px;
      color:var(--muted);
      font-size:12.5px;
    }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding:16px 18px 34px;
      color:var(--muted);
      font-size:12.5px;
    }

    @media print{
      body{background:#fff; color:#000}
      header, main, footer{max-width:none}
      .titleCard, .controlCard, section.card, aside.toc{box-shadow:none; background:#fff; border-color:#ddd}
      .copyBtn{display:none}
      canvas{display:none}
      figure{border-color:#ddd}
      .pill{border-color:#ddd; background:#fff}
      .callout{border-color:#ddd; background:#fff}
      .eq{border-color:#ddd; background:#fff}
      .subtitle, .pill, .kpi .label, .foot, figcaption{color:#333}
      a{color:#000; text-decoration:none}
    }
  </style>
</head>
<body>

<header>
  <div class="hero">
    <div class="titleCard">
      <h1>Statistics of the Binomial Photon-Number Distribution</h1>
      <p class="subtitle">
        A mini-lecture + worked derivation: why a lossy beam splitter turns a number state into binomial photon statistics, how to normalize the distribution,
        how to compute mean/variance, and what the signal-to-noise ratio does in the limits <span style="font-family:var(--mono)">p → 0</span> and <span style="font-family:var(--mono)">p → 1</span>.
      </p>
      <div class="metaRow">
        <span class="pill"><b>Core model</b> Binomial PMF</span>
        <span class="pill"><b>Parameters</b> M (trials), p (success prob.)</span>
        <span class="pill"><b>Key outputs</b> ⟨n⟩, Var(n), SNR</span>
        <span class="pill"><b>Physics</b> loss / splitting of photons</span>
      </div>
      <div class="kpiRow" aria-label="Live computed statistics">
        <div class="kpi">
          <div class="label">Mean ⟨n⟩ (photons)</div>
          <div class="val" id="kpiMean">—</div>
        </div>
        <div class="kpi">
          <div class="label">Variance Var(n) (photons²)</div>
          <div class="val" id="kpiVar">—</div>
        </div>
        <div class="kpi">
          <div class="label">Fano factor F = Var/⟨n⟩</div>
          <div class="val" id="kpiFano">—</div>
        </div>
        <div class="kpi">
          <div class="label">SNR = ⟨n⟩/σ</div>
          <div class="val" id="kpiSNR">—</div>
        </div>
      </div>
    </div>

    <div class="controlCard" aria-label="Interactive controls">
      <div class="controls">
        <div class="ctrl">
          <label for="pSlider">
            <span>Transmission / success probability <span style="font-family:var(--mono)">p</span></span>
            <span class="value" id="pVal">0.50</span>
          </label>
          <input id="pSlider" type="range" min="0.01" max="0.99" step="0.01" value="0.50"/>
        </div>

        <div class="ctrl">
          <label for="mInput">
            <span>Input photon number / trials <span style="font-family:var(--mono)">M</span></span>
            <span class="value" id="mVal">20</span>
          </label>
          <input id="mInput" type="number" min="1" max="200" step="1" value="20"/>
        </div>

        <div class="callout good">
          <strong>Example values (for plots):</strong>
          <div class="miniNote">
            The math results are fully symbolic. The slider and input only choose <em>example</em> values for the canvases and live KPIs.
          </div>
        </div>
      </div>
    </div>
  </div>
</header>

<main>
  <aside class="toc" aria-label="Table of contents">
    <h2>Contents</h2>
    <a href="#quick">Quick Summary <small>• results at a glance</small></a>
    <a href="#primer">PART 0 — Concept Primer <small>• theory</small></a>
    <a href="#analysis">PART 1 — Problem Analysis <small>• setup</small></a>
    <a href="#strategy">PART 2 — Strategy & Tips <small>• roadmap</small></a>
    <a href="#solution">PART 3 — Full Solution <small>• derivations</small></a>
    <a href="#deeper">PART 4 — Deeper Understanding <small>• meaning</small></a>
    <a href="#viz">PART 5 — Visualization Guide <small>• read the plots</small></a>
  </aside>

  <div class="content">
    <section class="card" id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>What this is about:</b> photon-number statistics described by a <b>binomial</b> distribution for photon-number-squeezed light.</li>
        <li><b>Key physics idea:</b> a <b>number state</b> (exactly <span style="font-family:var(--mono)">M</span> photons) passing through a <b>loss / beam splitter</b> yields a random transmitted photon number <span style="font-family:var(--mono)">n</span>.</li>
        <li><b>Governing distribution:</b> for <span style="font-family:var(--mono)">n = 0…M</span>, the photon-number PMF is
          <span style="font-family:var(--mono)">P(n) = C(M,n) p^n (1-p)^(M-n)</span>.</li>
        <li><b>Normalization:</b> <span style="font-family:var(--mono)">∑_{n=0}^M P(n) = (p + (1-p))^M = 1</span> (binomial theorem).</li>
        <li><b>Moments:</b> mean <span style="font-family:var(--mono)">⟨n⟩ = Mp</span>; variance <span style="font-family:var(--mono)">Var(n)=Mp(1-p)</span>.</li>
        <li><b>SNR:</b> with <span style="font-family:var(--mono)">σ = √Var</span>, <span style="font-family:var(--mono)">SNR = ⟨n⟩/σ = √(Mp/(1-p)) = √(⟨n⟩/(1-p))</span>.</li>
        <li><b>Limits:</b> <span style="font-family:var(--mono)">p→1</span> gives a <b>number state</b> (variance → 0, SNR → ∞); <span style="font-family:var(--mono)">p→0</span> gives mostly <b>vacuum</b> for fixed <span style="font-family:var(--mono)">M</span> (and in the Poisson scaling limit, it approaches <b>coherent-state</b> shot noise).</li>
      </ul>

      <div class="grid2">
        <figure class="canvasShort">
          <canvas id="canvasDiagram"></canvas>
          <figcaption><b>Diagram:</b> A number state |M⟩ enters a beam splitter (transmission p). The transmitted arm has binomial photon statistics P(n).</figcaption>
        </figure>
        <figure class="canvasShort">
          <canvas id="canvasPMF"></canvas>
          <figcaption><b>Main plot:</b> Binomial photon-number distribution P(n) vs n for the chosen example p and M.</figcaption>
        </figure>
      </div>

      <figure class="canvasTall">
        <canvas id="canvasSweep"></canvas>
        <figcaption><b>Secondary plot:</b> Mean ⟨n⟩, variance Var(n), and SNR vs p (for the chosen example M). Move p to see how squeezing (Var&lt;⟨n⟩) emerges.</figcaption>
      </figure>
    </section>

    <section class="card" id="primer">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <h3>Core definitions (symbols and units)</h3>
      <ul>
        <li><b>Photon number</b> <span style="font-family:var(--mono)">n</span> (unit: photons): the discrete count measured by an ideal photon-number-resolving detector.</li>
        <li><b>Number (Fock) state</b> <span style="font-family:var(--mono)">|M⟩</span>: a quantum optical state with <b>exactly</b> <span style="font-family:var(--mono)">M</span> photons, i.e. zero photon-number uncertainty.</li>
        <li><b>Photon-number distribution</b> <span style="font-family:var(--mono)">P(n)</span>: probability that a measurement yields <span style="font-family:var(--mono)">n</span>.</li>
        <li><b>Mean</b> <span style="font-family:var(--mono)">⟨n⟩</span> and <b>variance</b> <span style="font-family:var(--mono)">Var(n)=⟨(n-⟨n⟩)^2⟩</span> (units: photons and photons²).</li>
        <li><b>Binomial parameters</b>: <span style="font-family:var(--mono)">M</span> (integer trials) and <span style="font-family:var(--mono)">p</span> (success probability, dimensionless).</li>
      </ul>

      <h3>Physical meaning of the key quantities</h3>
      <p>
        In many optical settings, “success” means “a photon ends up in the transmitted mode” (or “survives loss”).
        If an input contains exactly <span style="font-family:var(--mono)">M</span> photons, and each photon independently transmits with probability <span style="font-family:var(--mono)">p</span>,
        then the transmitted photon number is a random variable <span style="font-family:var(--mono)">n</span> between 0 and M.
      </p>
      <p>
        The <b>variance</b> tells you the fluctuation strength. A useful dimensionless measure is the <b>Fano factor</b>
        <span style="font-family:var(--mono)">F = Var(n)/⟨n⟩</span>.
        <span style="font-family:var(--mono)">F&lt;1</span> indicates <b>sub-Poissonian</b> statistics (photon-number squeezing).
      </p>

      <h3>Key laws/principles and validity</h3>
      <div class="callout">
        <strong>Beam-splitter (loss) model:</strong>
        <p class="foot">
          Loss can be modeled as mixing the field with vacuum at a beam splitter of intensity transmission <span style="font-family:var(--mono)">p</span>.
          This is valid for linear, passive loss without gain, and it preserves quantum commutation relations by including an “environment” mode.
        </p>
      </div>

      <h3>Common models/approximations and why we use them</h3>
      <ul>
        <li><b>Independent transmission:</b> each photon is treated as an independent Bernoulli trial through a passive linear element.</li>
        <li><b>Ideal photon counting:</b> we assume the measurement directly samples <span style="font-family:var(--mono)">P(n)</span> (no detector dark counts or inefficiency beyond p).</li>
        <li><b>Poisson (coherent-state) limit:</b> if <span style="font-family:var(--mono)">M→∞</span>, <span style="font-family:var(--mono)">p→0</span> with <span style="font-family:var(--mono)">Mp</span> fixed, the binomial approaches a Poisson distribution (useful conceptual bridge to shot noise).</li>
      </ul>

      <h3>Mini intuition examples (no long algebra)</h3>
      <ul>
        <li><b>Example 1:</b> If <span style="font-family:var(--mono)">M=1</span> (a single-photon state), then transmitted counts are either 0 or 1 with probabilities <span style="font-family:var(--mono)">1-p</span> and <span style="font-family:var(--mono)">p</span>. That’s the simplest binomial case.</li>
        <li><b>Example 2:</b> If <span style="font-family:var(--mono)">p=1</span>, every photon transmits, so <span style="font-family:var(--mono)">n=M</span> always: zero fluctuations (perfect number state).</li>
      </ul>

      <h3>What to watch for (pitfalls)</h3>
      <ul>
        <li>Confusing <span style="font-family:var(--mono)">M</span> (maximum possible n) with the mean <span style="font-family:var(--mono)">⟨n⟩</span>.</li>
        <li>Using the wrong “SNR” definition. Here we use the common counting-statistics choice <span style="font-family:var(--mono)">SNR = ⟨n⟩/σ</span>.</li>
        <li>Taking the limit <span style="font-family:var(--mono)">p→0</span> without stating whether <span style="font-family:var(--mono)">M</span> is fixed or scaled (the physical interpretation changes).</li>
      </ul>
    </section>

    <section class="card" id="analysis">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Problem rewritten in plain language</h3>
      <p>
        You are given the binomial photon-number distribution
        <span style="font-family:var(--mono)">P(n) = [M!/(M-n)!n!] p^n (1-p)^(M-n)</span>
        for <span style="font-family:var(--mono)">n = 0,1,...,M</span>.
        You must:
      </p>
      <ul>
        <li>(a) propose a physical mechanism that converts a number state into binomial photon statistics,</li>
        <li>(b) prove normalization,</li>
        <li>(c) compute mean and variance in terms of <span style="font-family:var(--mono)">p</span> and <span style="font-family:var(--mono)">M</span>,</li>
        <li>(d) express SNR in terms of <span style="font-family:var(--mono)">⟨n⟩</span> and <span style="font-family:var(--mono)">p</span>, evaluate limits <span style="font-family:var(--mono)">p→0</span> and <span style="font-family:var(--mono)">p→1</span>, and interpret the light in those limits.</li>
      </ul>

      <h3>Given quantities</h3>
      <ul>
        <li><span style="font-family:var(--mono)">M</span>: nonnegative integer (maximum photon number / initial photon number for a number state interpretation).</li>
        <li><span style="font-family:var(--mono)">p</span>: probability parameter, <span style="font-family:var(--mono)">0 ≤ p ≤ 1</span> (often transmission/efficiency).</li>
      </ul>

      <h3>Unknowns / targets</h3>
      <ul>
        <li>(a) a plausible physical process;</li>
        <li>(b) show <span style="font-family:var(--mono)">∑ P(n)=1</span>;</li>
        <li>(c) compute <span style="font-family:var(--mono)">⟨n⟩</span> and <span style="font-family:var(--mono)">Var(n)</span>;</li>
        <li>(d) compute <span style="font-family:var(--mono)">SNR</span>, evaluate limits, interpret states.</li>
      </ul>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li><b>Binomial theorem</b> applies directly to normalization because the PMF has the exact form of binomial coefficients times powers.</li>
        <li><b>Generating functions / Bernoulli-sum statistics</b> apply to moments because binomial counts are sums of independent Bernoulli trials.</li>
        <li><b>Beam-splitter loss model</b> applies as a physical mechanism because linear loss is equivalent to mixing with vacuum.</li>
      </ul>
      <p>
        We do <em>not</em> need nonlinear optics or detailed Hamiltonian evolution for parts (b)–(d); they are purely statistical properties of the binomial PMF.
      </p>

      <div class="callout warn">
        <strong>Assumptions (made explicit):</strong>
        <ul>
          <li>Photon transmission events are independent and identical (same p for each photon).</li>
          <li>The device is linear and passive (beam splitter / attenuation), with vacuum entering the unused port.</li>
          <li>Photon counting measures photon number in the transmitted mode.</li>
        </ul>
      </div>

      <h3>Possible approaches (compare briefly)</h3>
      <ul>
        <li><b>Approach 1: Binomial theorem + combinatorial identities</b> — fastest for normalization and simple moment identities.</li>
        <li><b>Approach 2: Probability-generating function</b> <span style="font-family:var(--mono)">G(z)=⟨z^n⟩</span> — clean and systematic for mean/variance.</li>
        <li><b>Approach 3: Quantum beam-splitter transformation</b> — best for part (a), showing why loss of a Fock state gives a binomial distribution.</li>
      </ul>
      <p>
        <b>Best choice:</b> use the beam-splitter picture for (a), and the generating function (plus binomial theorem) for (b)–(d). This yields compact derivations with clear physical meaning.
      </p>
    </section>

    <section class="card" id="strategy">
      <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

      <ol>
        <li>
          <b>Mechanism:</b> model loss/splitting with a beam splitter of transmission <span style="font-family:var(--mono)">p</span>.
          <div class="foot">Tool: beam-splitter transformation; meaning: photons randomly partition into two output modes.</div>
        </li>
        <li>
          <b>Write the PMF:</b> identify <span style="font-family:var(--mono)">P(n)=C(M,n)p^n(1-p)^(M-n)</span>.
          <div class="foot">Tool: binomial coefficient; meaning: “choose n transmitted out of M”.</div>
        </li>
        <li>
          <b>Normalization:</b> sum <span style="font-family:var(--mono)">P(n)</span> over n and apply the binomial theorem.
          <div class="foot">Meaning: probabilities add to 1.</div>
        </li>
        <li>
          <b>Mean:</b> compute <span style="font-family:var(--mono)">⟨n⟩</span> either via generating function or as a sum of Bernoulli trials.
          <div class="foot">Meaning: average transmitted photon number.</div>
        </li>
        <li>
          <b>Variance:</b> compute <span style="font-family:var(--mono)">Var(n)</span> from <span style="font-family:var(--mono)">⟨n^2⟩</span> or Bernoulli-sum properties.
          <div class="foot">Meaning: strength of photon-number fluctuations (squeezing if reduced).</div>
        </li>
        <li>
          <b>SNR:</b> define <span style="font-family:var(--mono)">SNR=⟨n⟩/σ</span> with <span style="font-family:var(--mono)">σ=√Var</span>, then rewrite in terms of <span style="font-family:var(--mono)">⟨n⟩</span> and p.
          <div class="foot">Meaning: “how many sigma” the mean signal is above noise.</div>
        </li>
        <li>
          <b>Limits:</b> evaluate p→0 and p→1 carefully and interpret physical states.
          <div class="foot">Tip: state whether M is fixed or scaled (Poisson limit) when interpreting p→0.</div>
        </li>
      </ol>

      <div class="callout bad">
        <strong>Common mistakes:</strong>
        <ul>
          <li>Forgetting that n only runs to M (finite support).</li>
          <li>Mixing up variance <span style="font-family:var(--mono)">Mp(1-p)</span> with <span style="font-family:var(--mono)">Mp</span>.</li>
          <li>Calling the p→0 fixed-M case “Poisson” (it’s mostly vacuum); Poisson requires the scaling limit <span style="font-family:var(--mono)">M→∞, p→0</span> with <span style="font-family:var(--mono)">Mp</span> fixed.</li>
        </ul>
      </div>
    </section>

    <section class="card" id="solution">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Physical intuition before calculating</h3>
      <p>
        If you start with exactly <span style="font-family:var(--mono)">M</span> photons, then an attenuator or beam splitter with transmission <span style="font-family:var(--mono)">p</span>
        effectively asks, for each photon: “did it transmit?”
        That is the textbook setting for a binomial count: after M independent trials, the number of transmitted photons n is binomially distributed.
        As p increases, the distribution shifts to larger n and becomes narrower near n≈M; as p decreases, most probability moves toward n=0.
      </p>

      <h3>(a) A plausible mechanism converting number-state light into binomial statistics</h3>
      <p>
        Consider a single optical mode prepared in the number state <span style="font-family:var(--mono)">|M⟩</span> entering one port of a beam splitter.
        The other input port is vacuum <span style="font-family:var(--mono)">|0⟩</span>. Let the intensity transmission be <span style="font-family:var(--mono)">p</span> and reflection be <span style="font-family:var(--mono)">1-p</span>.
      </p>
      <div class="callout">
        <strong>Beam splitter as loss:</strong>
        <p class="foot">
          Any passive linear loss channel can be represented as a beam splitter mixing the signal mode with an environmental vacuum mode.
          Measuring the transmitted output alone produces classical-looking counting statistics, even though the joint state remains pure.
        </p>
      </div>
      <p>
        In this picture, each of the M photons is routed into the transmitted output with probability p and into the reflected (loss/environment) output with probability 1−p.
        Therefore, the probability to detect exactly n photons in the transmitted arm is the number of ways to choose which n out of M transmitted, times the probability of that pattern:
      </p>

      <div class="eq" id="eqPmf">
        <button class="copyBtn" data-copy-target="eqPmfText">Copy</button>
        <pre id="eqPmfText">P(n) = C(M,n) p^n (1-p)^(M-n),   n = 0,1,...,M
where C(M,n) = M! / [(M-n)! n!].</pre>
      </div>

      <p>
        That is exactly the binomial distribution given in the problem, with the clear physical meaning:
        <b>choose n transmitted photons out of M, with independent transmission probability p</b>.
      </p>

      <h3>(b) Prove the binomial distribution is normalized</h3>
      <p>
        We must show <span style="font-family:var(--mono)">∑_{n=0}^{M} P(n) = 1</span>.
        Substitute the PMF:
      </p>

      <div class="eq" id="eqNorm">
        <button class="copyBtn" data-copy-target="eqNormText">Copy</button>
        <pre id="eqNormText">Sum_{n=0}^M P(n)
= Sum_{n=0}^M C(M,n) p^n (1-p)^(M-n).</pre>
      </div>

      <p>
        Recognize the binomial theorem:
        <span style="font-family:var(--mono)">(x+y)^M = ∑_{n=0}^{M} C(M,n) x^n y^(M-n)</span>.
        Here, set <span style="font-family:var(--mono)">x=p</span>, <span style="font-family:var(--mono)">y=1-p</span>:
      </p>

      <div class="eq" id="eqNorm2">
        <button class="copyBtn" data-copy-target="eqNorm2Text">Copy</button>
        <pre id="eqNorm2Text">Sum_{n=0}^M C(M,n) p^n (1-p)^(M-n)
= (p + (1-p))^M
= 1^M
= 1.</pre>
      </div>

      <p>
        <b>Conclusion:</b> the distribution is properly normalized.
      </p>

      <h3>(c) Mean ⟨n⟩ and variance Var(n) in terms of p and M</h3>

      <p>
        A very clean method is the <b>probability-generating function</b>
        <span style="font-family:var(--mono)">G(z) = ⟨z^n⟩ = ∑_{n=0}^M P(n) z^n</span>.
        For the binomial PMF:
      </p>

      <div class="eq" id="eqG">
        <button class="copyBtn" data-copy-target="eqGText">Copy</button>
        <pre id="eqGText">G(z) = Sum_{n=0}^M C(M,n) (p z)^n (1-p)^(M-n)
     = ( (1-p) + p z )^M.</pre>
      </div>

      <p>
        Differentiate to get moments. First moment:
        <span style="font-family:var(--mono)">G'(z) = dG/dz</span>.
      </p>

      <div class="eq" id="eqMean">
        <button class="copyBtn" data-copy-target="eqMeanText">Copy</button>
        <pre id="eqMeanText">G(z) = ( (1-p) + p z )^M
G'(z) = M p ( (1-p) + p z )^(M-1)

Mean: ⟨n⟩ = G'(1)
          = M p ( (1-p) + p )^(M-1)
          = M p.</pre>
      </div>

      <p>
        Next, compute <span style="font-family:var(--mono)">⟨n(n-1)⟩ = G''(1)</span>:
      </p>

      <div class="eq" id="eqSecond">
        <button class="copyBtn" data-copy-target="eqSecondText">Copy</button>
        <pre id="eqSecondText">G'(z) = M p ( (1-p) + p z )^(M-1)
G''(z) = M (M-1) p^2 ( (1-p) + p z )^(M-2)

So ⟨n(n-1)⟩ = G''(1) = M (M-1) p^2.</pre>
      </div>

      <p>
        Use the identity <span style="font-family:var(--mono)">n^2 = n(n-1) + n</span>, so
        <span style="font-family:var(--mono)">⟨n^2⟩ = ⟨n(n-1)⟩ + ⟨n⟩</span>:
      </p>

      <div class="eq" id="eqVar">
        <button class="copyBtn" data-copy-target="eqVarText">Copy</button>
        <pre id="eqVarText">⟨n^2⟩ = M(M-1)p^2 + Mp.

Var(n) = ⟨n^2⟩ - ⟨n⟩^2
       = [M(M-1)p^2 + Mp] - (Mp)^2
       = Mp - Mp^2
       = Mp(1-p).</pre>
      </div>

      <div class="callout good">
        <strong>Key result (moments):</strong>
        <div class="eq" id="eqMoments" style="margin-top:10px">
          <button class="copyBtn" data-copy-target="eqMomentsText">Copy</button>
          <pre id="eqMomentsText">⟨n⟩ = M p
Var(n) = Mp(1-p)
σ_n = sqrt(Mp(1-p)).</pre>
        </div>
      </div>

      <h3>(d) SNR in terms of ⟨n⟩ and p; limits p→0 and p→1</h3>
      <p>
        Define the photon-counting signal-to-noise ratio as
        <span style="font-family:var(--mono)">SNR = ⟨n⟩ / σ_n</span>,
        where <span style="font-family:var(--mono)">σ_n = √Var(n)</span>.
        Using the results above:
      </p>

      <div class="eq" id="eqSNR">
        <button class="copyBtn" data-copy-target="eqSNRText">Copy</button>
        <pre id="eqSNRText">SNR = ⟨n⟩ / sqrt(Var(n))
    = (Mp) / sqrt(Mp(1-p))
    = sqrt( Mp / (1-p) ).</pre>
      </div>

      <p>
        The problem asks for SNR in terms of <span style="font-family:var(--mono)">⟨n⟩</span> and <span style="font-family:var(--mono)">p</span>.
        Since <span style="font-family:var(--mono)">⟨n⟩=Mp</span>, substitute:
      </p>

      <div class="eq" id="eqSNR2">
        <button class="copyBtn" data-copy-target="eqSNR2Text">Copy</button>
        <pre id="eqSNR2Text">Because ⟨n⟩ = Mp,

SNR = sqrt( ⟨n⟩ / (1-p) ).</pre>
      </div>

      <h3>Limiting cases and physical interpretation</h3>
      <div class="grid2">
        <div class="callout">
          <strong>Limit p → 1 (nearly perfect transmission)</strong>
          <p>
            Then <span style="font-family:var(--mono)">Var(n)=Mp(1-p) → 0</span>.
            The distribution collapses to <span style="font-family:var(--mono)">P(n)=δ_{n,M}</span> (all photons transmit),
            i.e. a <b>number state</b> in the transmitted mode.
          </p>
          <p class="foot">
            SNR: <span style="font-family:var(--mono)">SNR = √(⟨n⟩/(1-p)) → ∞</span> because the noise σ goes to zero.
          </p>
        </div>

        <div class="callout">
          <strong>Limit p → 0 (very weak transmission / strong loss)</strong>
          <p>
            For <b>fixed M</b>, <span style="font-family:var(--mono)">⟨n⟩=Mp → 0</span> and the distribution concentrates at <span style="font-family:var(--mono)">n=0</span>:
            the transmitted mode is almost always <b>vacuum</b>.
          </p>
          <p class="foot">
            SNR: since <span style="font-family:var(--mono)">1-p≈1</span>, <span style="font-family:var(--mono)">SNR ≈ √⟨n⟩ → 0</span>.
          </p>
        </div>
      </div>

      <div class="callout warn" style="margin-top:12px">
        <strong>Important nuance (Poisson / coherent-state limit):</strong>
        <p class="foot">
          If instead you take the <em>scaling limit</em> <span style="font-family:var(--mono)">M→∞</span>, <span style="font-family:var(--mono)">p→0</span> while keeping <span style="font-family:var(--mono)">Mp = ⟨n⟩</span> fixed,
          the binomial distribution approaches a <b>Poisson</b> distribution with mean ⟨n⟩. That corresponds to <b>shot-noise</b> statistics
          often associated with coherent light.
        </p>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><b>Units:</b> ⟨n⟩ has units of photons; Var(n) has photons²; SNR is dimensionless.</li>
        <li><b>Bounds:</b> Var(n)=Mp(1-p)≥0 and is maximal at p=1/2 for fixed M.</li>
        <li><b>Sub-Poisson:</b> Fano factor <span style="font-family:var(--mono)">F=Var/⟨n⟩ = 1-p</span> satisfies <span style="font-family:var(--mono)">F&lt;1</span> for any <span style="font-family:var(--mono)">p&gt;0</span>.</li>
      </ul>

      <div class="callout good">
        <strong>Final Answer (all parts, plain text)</strong>
        <div class="eq" id="finalAnswer" style="margin-top:10px">
          <button class="copyBtn" data-copy-target="finalAnswerText">Copy</button>
          <pre id="finalAnswerText">(a) Mechanism: Send a number state |M⟩ into a beam splitter (or loss channel modeled as a beam splitter) of transmission p with vacuum in the other port. The transmitted photon count n is binomial: P(n)=C(M,n)p^n(1-p)^(M-n).

(b) Normalization: ∑_{n=0}^M C(M,n)p^n(1-p)^(M-n) = (p+(1-p))^M = 1.

(c) Mean and variance: ⟨n⟩ = Mp,  Var(n) = Mp(1-p),  σ_n = √(Mp(1-p)).

(d) SNR (counting): SNR = ⟨n⟩/σ_n = √(Mp/(1-p)) = √(⟨n⟩/(1-p)).
Limits: p→1 ⇒ Var→0, SNR→∞, transmitted light approaches a number state n=M.
p→0 with fixed M ⇒ ⟨n⟩→0, mostly vacuum, SNR→0 (and in the scaling limit M→∞, p→0 with Mp fixed ⇒ Poisson/shot-noise statistics).</pre>
        </div>
      </div>

      <p>
        Connection to the diagram and plots:
        the beam splitter in the diagram implements the “choose n out of M” random partition.
        The main plot shows the resulting PMF across n,
        while the secondary plot shows how ⟨n⟩, Var(n), and SNR change as you adjust p.
      </p>
    </section>

    <section class="card" id="deeper">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the formulas: what controls what?</h3>
      <ul>
        <li><b>Mean</b> ⟨n⟩=Mp: increases linearly with both initial photon number (M) and transmission (p).</li>
        <li><b>Variance</b> Var=Mp(1−p): has two competing effects—more photons increase fluctuations, but higher p suppresses fluctuations by reducing randomness (approaching a fixed outcome n=M).</li>
        <li><b>Fano factor</b> F=1−p: depends only on p. As p increases, F decreases below 1 → stronger photon-number squeezing.</li>
        <li><b>SNR</b> = √(⟨n⟩/(1−p)): grows with mean and also grows strongly as p→1 because noise vanishes.</li>
      </ul>

      <h3>How changing parameters affects outcomes (tie to interactive plots)</h3>
      <ul>
        <li>Increasing <b>M</b> spreads the PMF over more n-values, typically making the distribution narrower in <em>relative</em> terms (fractional noise decreases like 1/√M for moderate p).</li>
        <li>Increasing <b>p</b> shifts the PMF peak rightward (higher n) and reduces the Fano factor (more squeezing).</li>
        <li>Near <b>p≈1</b>, the PMF collapses near n=M and the SNR curve spikes upward because σ→0.</li>
      </ul>

      <h3>An alternative derivation idea (brief)</h3>
      <p>
        Instead of generating functions, you can model the transmitted count as a sum of M independent Bernoulli random variables:
        <span style="font-family:var(--mono)">n = X1 + X2 + ... + XM</span> with <span style="font-family:var(--mono)">P(Xi=1)=p</span>.
        Then ⟨n⟩ is the sum of means, and Var(n) is the sum of variances (independence), giving the same results immediately.
      </p>

      <h3>Concept checks (quick Q&A)</h3>
      <ul>
        <li><b>Q:</b> Why is the distribution sub-Poissonian for p&gt;0? <b>A:</b> Because F=Var/⟨n⟩=1−p&lt;1, so fluctuations are reduced below shot noise.</li>
        <li><b>Q:</b> When is the distribution symmetric? <b>A:</b> At p=1/2 (then P(n)=P(M−n)).</li>
        <li><b>Q:</b> What physical element sets p? <b>A:</b> Beam-splitter transmission, propagation loss, or detection efficiency—any linear attenuation mapped to a beam splitter with vacuum.</li>
        <li><b>Q:</b> If you observe Var≈0, what state are you near? <b>A:</b> A number state (or very strongly number-squeezed state), corresponding here to p≈1.</li>
      </ul>
    </section>

    <section class="card" id="viz">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <h3>What each canvas shows</h3>
      <ul>
        <li><b>Diagram canvas:</b> A beam splitter with transmission p fed by a number state |M⟩ and vacuum |0⟩. The transmitted arm yields the binomial statistics P(n).</li>
        <li><b>Main plot (PMF):</b> Discrete probability mass P(n) vs photon number n (0…M). The peak is near n≈Mp.</li>
        <li><b>Secondary plot (sweep vs p):</b> Curves of ⟨n⟩, Var(n), and SNR as functions of p for the chosen example M. This shows how increasing p both increases mean and reduces relative noise (F=1−p).</li>
      </ul>

      <h3>Interactive controls</h3>
      <ul>
        <li><b>Slider p:</b> changes transmission/success probability. Expect the PMF peak to move right with larger p; the variance curve to decrease relative to the mean; and SNR to grow sharply as p→1.</li>
        <li><b>Input M:</b> changes initial photon number. Expect the PMF support (0…M) to expand and the mean/variance scales to rise proportionally.</li>
      </ul>

      <div class="callout">
        <strong>Consistency note:</strong>
        <p class="foot">
          The symbols in the plots match the text exactly: the plotted PMF is
          <span style="font-family:var(--mono)">P(n)=C(M,n)p^n(1-p)^(M-n)</span>,
          and the plotted curves use ⟨n⟩=Mp and Var=Mp(1-p).
        </p>
      </div>
    </section>
  </div>
</main>

<footer>
  <div>
    <b>Print tip:</b> This page is print-friendly; canvases are hidden in print view while the full derivations remain.
  </div>
</footer>

<script>
(function(){
  // ---------- Smooth scrolling for TOC ----------
  document.querySelectorAll('.toc a').forEach(a=>{
    a.addEventListener('click', (e)=>{
      const href = a.getAttribute('href');
      if(!href || !href.startsWith('#')) return;
      const el = document.querySelector(href);
      if(!el) return;
      e.preventDefault();
      el.scrollIntoView({behavior:'smooth', block:'start'});
      history.replaceState(null, '', href);
    });
  });

  // ---------- Copy buttons ----------
  function copyTextFromElement(id){
    const el = document.getElementById(id);
    if(!el) return;
    const text = el.innerText;
    navigator.clipboard.writeText(text).then(()=> {
      // Small UI feedback: temporary label
      const btn = document.querySelector(`button[data-copy-target="${id}"]`);
      if(btn){
        const old = btn.textContent;
        btn.textContent = 'Copied!';
        setTimeout(()=>btn.textContent = old, 900);
      }
    }).catch(()=>{});
  }
  document.querySelectorAll('.copyBtn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const target = btn.getAttribute('data-copy-target');
      copyTextFromElement(target);
    });
  });

  // ---------- Math helpers ----------
  // Lanczos approximation for log-gamma to compute combinations stably.
  function logGamma(z){
    const p = [
      676.5203681218851,
      -1259.1392167224028,
      771.32342877765313,
      -176.61502916214059,
      12.507343278686905,
      -0.13857109526572012,
      9.9843695780195716e-6,
      1.5056327351493116e-7
    ];
    if(z < 0.5){
      // Reflection formula
      return Math.log(Math.PI) - Math.log(Math.sin(Math.PI*z)) - logGamma(1 - z);
    }
    z -= 1;
    let x = 0.99999999999980993;
    for(let i=0;i<p.length;i++) x += p[i]/(z+i+1);
    const t = z + p.length - 0.5;
    return 0.5*Math.log(2*Math.PI) + (z+0.5)*Math.log(t) - t + Math.log(x);
  }
  function logChoose(n,k){
    if(k<0 || k>n) return -Infinity;
    return logGamma(n+1) - logGamma(k+1) - logGamma(n-k+1);
  }
  function binomPMF(n, M, p){
    if(n<0 || n>M) return 0;
    const lp = logChoose(M,n) + n*Math.log(p) + (M-n)*Math.log(1-p);
    return Math.exp(lp);
  }

  // ---------- Canvas drawing helpers ----------
  function setupCanvas(canvas){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(2, Math.floor(rect.width * dpr));
    const h = Math.max(2, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
    }
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return {ctx, w: rect.width, h: rect.height, dpr};
  }
  function clear(ctx, w, h){
    ctx.clearRect(0,0,w,h);
  }
  function roundRect(ctx, x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }
  function drawPanel(ctx, x,y,w,h){
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    roundRect(ctx,x,y,w,h,16);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  // Plot axes with ticks & grid
  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
    const {x,y,w,h} = box;
    const padL = 58, padR = 16, padT = 34, padB = 42;
    const px = x + padL, py = y + padT;
    const pw = w - padL - padR, ph = h - padT - padB;

    // panel
    drawPanel(ctx, x,y,w,h);

    // title
    ctx.save();
    ctx.fillStyle = 'rgba(229,231,235,0.95)';
    ctx.font = '600 13px ui-sans-serif, system-ui';
    ctx.fillText(title, x+14, y+20);
    ctx.restore();

    // grid/ticks
    const xTicks = 6;
    const yTicks = 5;

    function xToPx(v){ return px + (v - xMin) * pw / (xMax - xMin); }
    function yToPx(v){ return py + ph - (v - yMin) * ph / (yMax - yMin); }

    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;

    // vertical grid
    for(let i=0;i<=xTicks;i++){
      const t = xMin + (xMax-xMin)*i/xTicks;
      const X = xToPx(t);
      ctx.beginPath();
      ctx.moveTo(X, py);
      ctx.lineTo(X, py+ph);
      ctx.stroke();
    }
    // horizontal grid
    for(let i=0;i<=yTicks;i++){
      const t = yMin + (yMax-yMin)*i/yTicks;
      const Y = yToPx(t);
      ctx.beginPath();
      ctx.moveTo(px, Y);
      ctx.lineTo(px+pw, Y);
      ctx.stroke();
    }

    // axes
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.beginPath();
    ctx.moveTo(px, py+ph);
    ctx.lineTo(px+pw, py+ph);
    ctx.lineTo(px+pw, py);
    ctx.stroke();

    // tick labels
    ctx.fillStyle = 'rgba(167,176,191,0.95)';
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    for(let i=0;i<=xTicks;i++){
      const t = xMin + (xMax-xMin)*i/xTicks;
      const X = xToPx(t);
      ctx.fillText(formatTick(t), X, py+ph+8);
    }
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for(let i=0;i<=yTicks;i++){
      const t = yMin + (yMax-yMin)*i/yTicks;
      const Y = yToPx(t);
      ctx.fillText(formatTick(t), px-8, Y);
    }

    // labels
    ctx.fillStyle = 'rgba(229,231,235,0.92)';
    ctx.font = '600 12px ui-sans-serif, system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(xLabel, px + pw/2, y + h - 8);

    ctx.save();
    ctx.translate(x+16, py+ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    ctx.restore();

    return {
      plot: {x:px, y:py, w:pw, h:ph},
      xToPx: (v)=> xToPx(v),
      yToPx: (v)=> yToPx(v)
    };
  }

  function formatTick(v){
    const av = Math.abs(v);
    if(av >= 1000) return v.toFixed(0);
    if(av >= 100) return v.toFixed(0);
    if(av >= 10) return v.toFixed(1);
    if(av >= 1) return v.toFixed(2);
    return v.toFixed(3);
  }

  function drawLegend(ctx, items, x, y){
    ctx.save();
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.textBaseline = 'middle';
    let xx = x;
    items.forEach(it=>{
      // swatch
      ctx.fillStyle = it.color;
      ctx.globalAlpha = 0.95;
      ctx.fillRect(xx, y-5, 14, 10);
      ctx.globalAlpha = 1;
      // text
      ctx.fillStyle = 'rgba(229,231,235,0.92)';
      ctx.fillText(it.label, xx+20, y);
      xx += 20 + ctx.measureText(it.label).width + 16;
    });
    ctx.restore();
  }

  // ---------- Draw diagram ----------
  function drawDiagram(canvas, p, M){
    const {ctx, w, h} = setupCanvas(canvas);
    clear(ctx, w, h);

    // Background panel
    drawPanel(ctx, 0, 0, w, h);

    // Title
    ctx.save();
    ctx.fillStyle = 'rgba(229,231,235,0.95)';
    ctx.font = '600 13px ui-sans-serif, system-ui';
    ctx.fillText('Beam-splitter (loss) mechanism for binomial statistics', 14, 20);
    ctx.restore();

    // Coordinates
    const cx = w*0.52, cy = h*0.52;
    const bs = Math.min(w,h)*0.18;

    // Input waveguide line
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(28, cy);
    ctx.lineTo(cx-bs*0.9, cy);
    ctx.stroke();

    // Beam splitter square
    ctx.fillStyle = 'rgba(125,211,252,0.10)';
    ctx.strokeStyle = 'rgba(125,211,252,0.45)';
    ctx.lineWidth = 2;
    roundRect(ctx, cx-bs/2, cy-bs/2, bs, bs, 10);
    ctx.fill(); ctx.stroke();

    // Diagonal split line inside
    ctx.strokeStyle = 'rgba(229,231,235,0.70)';
    ctx.beginPath();
    ctx.moveTo(cx-bs/2+8, cy+bs/2-8);
    ctx.lineTo(cx+bs/2-8, cy-bs/2+8);
    ctx.stroke();

    // Outputs: transmitted to right, reflected upward
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 2;

    // Transmitted
    ctx.beginPath();
    ctx.moveTo(cx+bs/2, cy);
    ctx.lineTo(w-24, cy);
    ctx.stroke();

    // Reflected (loss/env)
    ctx.beginPath();
    ctx.moveTo(cx, cy-bs/2);
    ctx.lineTo(cx, 34);
    ctx.stroke();

    // Labels
    ctx.fillStyle = 'rgba(229,231,235,0.92)';
    ctx.font = '13px ui-sans-serif, system-ui';

    ctx.fillText(`Input: |M⟩ with M = ${M}`, 30, cy-10);

    ctx.fillStyle = 'rgba(167,176,191,0.95)';
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillText('Vacuum |0⟩ enters unused port (environment)', cx-160, 46);

    // p label
    ctx.fillStyle = 'rgba(125,211,252,0.95)';
    ctx.font = '600 12px ui-sans-serif, system-ui';
    ctx.fillText(`Transmission p = ${p.toFixed(2)}`, cx+bs/2+10, cy-14);

    ctx.fillStyle = 'rgba(167,176,191,0.95)';
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillText(`Reflection 1-p = ${(1-p).toFixed(2)}`, cx+10, cy-bs/2-10);

    ctx.fillStyle = 'rgba(229,231,235,0.92)';
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillText('Transmitted mode photon count n ~ Binomial(M,p)', w*0.55, cy+18);

    // Tiny note about binomial
    ctx.fillStyle = 'rgba(167,176,191,0.95)';
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillText('Meaning: choose which n of the M photons transmit.', 14, h-18);

    ctx.restore();
  }

  // ---------- Draw PMF plot ----------
  function drawPMF(canvas, p, M){
    const {ctx, w, h} = setupCanvas(canvas);
    clear(ctx, w, h);

    // Compute PMF
    const pmf = [];
    let maxP = 0;
    for(let n=0;n<=M;n++){
      const val = binomPMF(n, M, p);
      pmf.push(val);
      if(val > maxP) maxP = val;
    }
    const yMax = maxP * 1.12;

    const axes = drawAxes(
      ctx,
      {x:0,y:0,w:w,h:h},
      0, Math.max(1, M),
      0, Math.max(1e-6, yMax),
      'Photon number n (photons)',
      'P(n) (probability)',
      'Binomial photon-number distribution P(n)'
    );

    // Draw discrete bars + markers
    const {plot, xToPx, yToPx} = axes;
    ctx.save();

    // Bars
    for(let n=0;n<=M;n++){
      const X = xToPx(n);
      const Y = yToPx(pmf[n]);
      const baseY = yToPx(0);
      const barW = Math.min(18, plot.w/(M+1)*0.7);
      ctx.fillStyle = 'rgba(125,211,252,0.25)';
      ctx.strokeStyle = 'rgba(125,211,252,0.75)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.rect(X - barW/2, Y, barW, baseY - Y);
      ctx.fill();
      ctx.stroke();

      // marker dot
      ctx.fillStyle = 'rgba(229,231,235,0.92)';
      ctx.beginPath();
      ctx.arc(X, Y, 2.4, 0, Math.PI*2);
      ctx.fill();
    }

    // Mean indicator line at n=Mp
    const mean = M*p;
    const Xm = xToPx(mean);
    ctx.strokeStyle = 'rgba(167,139,250,0.9)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6,4]);
    ctx.beginPath();
    ctx.moveTo(Xm, plot.y);
    ctx.lineTo(Xm, plot.y + plot.h);
    ctx.stroke();
    ctx.setLineDash([]);

    // Label mean
    ctx.fillStyle = 'rgba(167,139,250,0.92)';
    ctx.font = '600 12px ui-sans-serif, system-ui';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(`mean ⟨n⟩ = Mp = ${mean.toFixed(2)}`, Xm + 6, plot.y + 6);

    // Legend
    drawLegend(ctx, [
      {label:'P(n)', color:'rgba(125,211,252,0.75)'},
      {label:'mean', color:'rgba(167,139,250,0.9)'}
    ], plot.x + 6, plot.y + 18);

    ctx.restore();
  }

  // ---------- Draw sweep plot (mean, variance, SNR vs p) ----------
  function drawSweep(canvas, M, pNow){
    const {ctx, w, h} = setupCanvas(canvas);
    clear(ctx, w, h);

    // Sweep p in [0,1]
    const N = 250;
    const ps = [];
    const meanArr = [];
    const varArr = [];
    const snrArr = [];
    let yMax = 0;

    for(let i=0;i<=N;i++){
      const p = i/N;
      // Avoid exact endpoints for SNR to prevent division by zero in rendering;
      // still show trend by clamping.
      const pc = Math.min(0.999, Math.max(0.001, p));
      const mean = M*pc;
      const vari = M*pc*(1-pc);
      const snr = mean / Math.sqrt(Math.max(1e-12, vari));
      ps.push(p);
      meanArr.push(mean);
      varArr.push(vari);
      snrArr.push(snr);

      // Use a combined y-scale; SNR can be larger, so cap display gracefully.
      yMax = Math.max(yMax, mean, vari, Math.min(snr, 20)); // cap snr in yMax estimate for readability
    }
    yMax *= 1.12;
    yMax = Math.max(1, yMax);

    const axes = drawAxes(
      ctx,
      {x:0,y:0,w:w,h:h},
      0, 1,
      0, yMax,
      'p (dimensionless)',
      'Value (photons or dimensionless)',
      'Parameter sweep vs p (example M fixed)'
    );
    const {plot, xToPx, yToPx} = axes;

    // Helper to draw line
    function drawLine(arr, color, capSNR=false){
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i=0;i<arr.length;i++){
        const x = xToPx(ps[i]);
        const val = capSNR ? Math.min(arr[i], yMax) : arr[i];
        const y = yToPx(val);
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    ctx.save();
    // Mean, variance, SNR (SNR may be larger; we draw it but its trend matters)
    drawLine(meanArr, 'rgba(125,211,252,0.85)');
    drawLine(varArr, 'rgba(52,211,153,0.85)');
    drawLine(snrArr, 'rgba(167,139,250,0.85)', true);

    // Current p marker
    const xP = xToPx(pNow);
    ctx.strokeStyle = 'rgba(255,255,255,0.55)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([5,4]);
    ctx.beginPath();
    ctx.moveTo(xP, plot.y);
    ctx.lineTo(xP, plot.y+plot.h);
    ctx.stroke();
    ctx.setLineDash([]);

    // Labels near current p
    const meanNow = M*pNow;
    const varNow = M*pNow*(1-pNow);
    const snrNow = meanNow/Math.sqrt(Math.max(1e-12,varNow));
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';

    // Place labels with small vertical spacing
    const labelX = Math.min(plot.x + plot.w - 180, xP + 8);
    const labelY = plot.y + 8;

    ctx.fillStyle = 'rgba(125,211,252,0.95)';
    ctx.fillText(`⟨n⟩ = Mp = ${meanNow.toFixed(2)}`, labelX, labelY);

    ctx.fillStyle = 'rgba(52,211,153,0.95)';
    ctx.fillText(`Var = Mp(1-p) = ${varNow.toFixed(2)}`, labelX, labelY+18);

    ctx.fillStyle = 'rgba(167,139,250,0.95)';
    ctx.fillText(`SNR = ⟨n⟩/σ = ${snrNow.toFixed(2)}`, labelX, labelY+36);

    // Legend
    drawLegend(ctx, [
      {label:'⟨n⟩', color:'rgba(125,211,252,0.85)'},
      {label:'Var', color:'rgba(52,211,153,0.85)'},
      {label:'SNR', color:'rgba(167,139,250,0.85)'}
    ], plot.x + 6, plot.y + 18);

    // Note about SNR scaling
    ctx.fillStyle = 'rgba(167,176,191,0.90)';
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'bottom';
    ctx.fillText('Note: SNR diverges as p→1 (noise→0); displayed trend is clipped for readability.', plot.x + 6, plot.y + plot.h - 6);

    ctx.restore();
  }

  // ---------- Update KPIs ----------
  function updateKPIs(p, M){
    const mean = M*p;
    const vari = M*p*(1-p);
    const fano = vari / Math.max(1e-12, mean);
    const snr = mean / Math.sqrt(Math.max(1e-12, vari));

    document.getElementById('kpiMean').textContent = mean.toFixed(4);
    document.getElementById('kpiVar').textContent  = vari.toFixed(4);
    document.getElementById('kpiFano').textContent = fano.toFixed(4);
    document.getElementById('kpiSNR').textContent  = (p>0.999 ? '→ ∞' : snr.toFixed(4));
  }

  // ---------- State + render ----------
  const pSlider = document.getElementById('pSlider');
  const mInput = document.getElementById('mInput');
  const pVal = document.getElementById('pVal');
  const mVal = document.getElementById('mVal');

  const canvDiagram = document.getElementById('canvasDiagram');
  const canvPMF = document.getElementById('canvasPMF');
  const canvSweep = document.getElementById('canvasSweep');

  function clamp(v, a, b){ return Math.min(b, Math.max(a, v)); }

  function getState(){
    const p = parseFloat(pSlider.value);
    let M = parseInt(mInput.value, 10);
    if(!Number.isFinite(M)) M = 20;
    M = clamp(M, 1, 200);
    mInput.value = M;
    return {p, M};
  }

  function render(){
    const {p, M} = getState();
    pVal.textContent = p.toFixed(2);
    mVal.textContent = String(M);

    updateKPIs(p, M);
    drawDiagram(canvDiagram, p, M);
    drawPMF(canvPMF, p, M);
    drawSweep(canvSweep, M, p);
  }

  // Events
  pSlider.addEventListener('input', render);
  mInput.addEventListener('input', render);

  // Resize handling
  let resizeTimer = null;
  window.addEventListener('resize', ()=>{
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(render, 60);
  });

  // Initial render
  render();
})();
</script>

</body>
</html>
