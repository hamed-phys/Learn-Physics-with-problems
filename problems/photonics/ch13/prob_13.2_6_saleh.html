<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Negative-Binomial Distribution from Summed Thermal (Bose–Einstein) Variables: Limits to Geometric and Poisson</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101a33;
      --panel2:#0f1730;
      --text:#e9eefc;
      --muted:#b7c2e6;
      --faint:#7f8bb6;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#86efac;
      --warn:#fbbf24;
      --bad:#fb7185;
      --border:rgba(255,255,255,.10);
      --shadow: 0 16px 50px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html{ scroll-behavior:smooth; }
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 700px at 20% 0%, rgba(125,211,252,.12), transparent 60%),
                  radial-gradient(900px 600px at 80% 10%, rgba(167,139,250,.12), transparent 55%),
                  linear-gradient(180deg, var(--bg), #070a14 60%, #060812);
      color:var(--text);
      line-height:1.55;
    }

    header{
      padding: clamp(18px, 3vw, 34px);
      border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, rgba(16,26,51,.85), rgba(16,26,51,.35));
      backdrop-filter: blur(10px);
      position: sticky;
      top:0;
      z-index:50;
    }
    header .titlebar{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:16px;
      max-width: 1200px;
      margin:0 auto;
    }
    h1{
      margin:0;
      font-weight:800;
      letter-spacing:-0.02em;
      font-size: clamp(20px, 2.2vw, 34px);
      line-height:1.1;
    }
    .subtitle{
      margin-top:8px;
      color:var(--muted);
      max-width: 70ch;
      font-size: clamp(13px, 1.2vw, 16px);
    }

    main{
      max-width: 1200px;
      margin:0 auto;
      padding: clamp(16px, 2.6vw, 34px);
      display:grid;
      grid-template-columns: 1fr 320px;
      gap: 22px;
      align-items:start;
    }

    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
      aside{ position:static !important; top:auto !important; }
    }

    article{
      display:flex;
      flex-direction:column;
      gap: 18px;
      min-width:0;
    }

    section{
      background: linear-gradient(180deg, rgba(16,26,51,.85), rgba(12,18,36,.75));
      border:1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 18px 18px;
      overflow:hidden;
      position:relative;
    }
    section:before{
      content:"";
      position:absolute;
      inset:0;
      background: radial-gradient(900px 240px at 20% -10%, rgba(125,211,252,.10), transparent 55%),
                  radial-gradient(900px 260px at 90% 10%, rgba(167,139,250,.08), transparent 60%);
      pointer-events:none;
    }
    section > *{ position:relative; }

    h2{
      margin:0 0 8px 0;
      font-size: clamp(16px, 1.6vw, 22px);
      letter-spacing:-0.01em;
    }
    h3{
      margin:14px 0 8px 0;
      font-size: clamp(14px, 1.2vw, 18px);
      color: var(--text);
    }

    p{ margin: 10px 0; color: var(--muted); }
    ul{ margin:10px 0 10px 20px; color: var(--muted); }
    li{ margin: 6px 0; }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 760px){
      .grid2{ grid-template-columns:1fr; }
    }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    @media (max-width: 880px){
      .callouts{ grid-template-columns:1fr; }
    }

    .card{
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(10,14,28,.55), rgba(10,14,28,.25));
      border-radius: 16px;
      padding: 14px;
    }
    .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(125,211,252,.12);
      border:1px solid rgba(125,211,252,.25);
      color: var(--text);
      font-size: 12px;
      letter-spacing:.02em;
      margin-bottom: 10px;
    }
    .tag .dot{
      width:8px; height:8px;
      border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(125,211,252,.12);
    }

    .equation{
      margin: 10px 0;
      border-radius: 14px;
      overflow:hidden;
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(6,9,18,.75), rgba(6,9,18,.45));
    }
    .equation .eqbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 12px;
      border-bottom:1px solid var(--border);
      background: rgba(255,255,255,.03);
    }
    .equation .eqbar strong{
      font-size: 13px;
      color: var(--text);
      letter-spacing:.01em;
    }
    .equation pre{
      margin:0;
      padding: 12px;
      font-family: var(--mono);
      font-size: 13px;
      color: #eaf2ff;
      overflow:auto;
      white-space: pre;
    }

    button.copyBtn{
      appearance:none;
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      color: var(--text);
      padding: 7px 10px;
      border-radius: 10px;
      font-size: 12px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
    }
    button.copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.07);
      border-color: rgba(255,255,255,.18);
    }
    button.copyBtn:active{ transform: translateY(0px) scale(.99); }

    .ok{
      border-left: 4px solid rgba(134,239,172,.85);
    }
    .warn{
      border-left: 4px solid rgba(251,191,36,.85);
    }
    .bad{
      border-left: 4px solid rgba(251,113,133,.85);
    }
    .mini{
      color: var(--faint);
      font-size: 12.5px;
    }

    aside{
      position: sticky;
      top: 92px;
      display:flex;
      flex-direction:column;
      gap: 14px;
    }

    nav.toc{
      padding: 14px;
      border-radius: 18px;
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(16,26,51,.85), rgba(12,18,36,.70));
      box-shadow: var(--shadow);
    }
    nav.toc h2{
      font-size: 14px;
      margin:0 0 10px 0;
      color: var(--text);
    }
    nav.toc a{
      display:block;
      padding: 7px 10px;
      margin: 4px 0;
      border-radius: 12px;
      color: var(--muted);
      text-decoration:none;
      border:1px solid transparent;
      transition: background .12s ease, border-color .12s ease;
      font-size: 13px;
    }
    nav.toc a:hover{
      background: rgba(255,255,255,.04);
      border-color: rgba(255,255,255,.10);
      color: var(--text);
    }

    .vizPanel{
      padding: 14px;
      border-radius: 18px;
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(16,26,51,.85), rgba(12,18,36,.72));
      box-shadow: var(--shadow);
    }
    .vizPanel h2{
      font-size: 14px;
      margin:0 0 12px 0;
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-bottom: 10px;
    }
    .control{
      border:1px solid var(--border);
      border-radius: 14px;
      padding: 10px;
      background: rgba(255,255,255,.03);
    }
    .control label{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-size: 13px;
      color: var(--text);
      margin-bottom: 8px;
    }
    .control .value{
      font-family: var(--mono);
      color: var(--accent);
      font-size: 12.5px;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      margin-top: 8px;
      color: var(--muted);
      font-size: 12.5px;
    }
    .row input[type="checkbox"]{ transform: translateY(1px); }

    figure{
      margin:0;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    canvas{
      width:100%;
      height: 300px;
      border-radius: 16px;
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(6,9,18,.65), rgba(6,9,18,.35));
    }
    .canvasSmall{ height: 220px; }

    footer{
      max-width:1200px;
      margin: 18px auto 50px auto;
      padding: 0 18px;
      color: var(--faint);
      font-size: 12.5px;
    }

    /* Print-friendly */
    @media print{
      header, aside { display:none !important; }
      main{ grid-template-columns:1fr; padding:0; }
      section{ box-shadow:none; background:#fff; color:#000; border:1px solid #ddd; }
      p, li, .mini{ color:#000; }
      .equation pre{ color:#000; }
      body{ background:#fff; }
      a{ color:#000; text-decoration:underline; }
      button{ display:none !important; }
    }

    /* Subtle motion */
    @media (prefers-reduced-motion:no-preference){
      section{ animation: rise .4s ease both; }
      @keyframes rise{
        from{ opacity:0; transform: translateY(6px); }
        to{ opacity:1; transform: translateY(0); }
      }
    }

    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color: var(--muted);
      font-size: 12.5px;
    }
    .pill b{ color: var(--text); font-weight:700; }
    .kpiRow{ display:flex; flex-wrap:wrap; gap:10px; margin-top:10px; }
    .hr{
      height:1px;
      background: var(--border);
      margin: 14px 0;
    }
  </style>
</head>
<body>
  <header>
    <div class="titlebar">
      <div>
        <h1>Negative-Binomial Photon-Count Statistics from Summed Thermal Modes</h1>
        <div class="subtitle">
          Verify two important limits of the negative-binomial distribution: it becomes the Bose–Einstein (geometric) distribution for one mode (<span class="pill"><b>M=1</b></span>), and it approaches a Poisson distribution as the number of independent modes grows (<span class="pill"><b>M→∞</b></span>) at fixed mean photon number <span class="pill"><b>n̄</b></span>.
        </div>
      </div>
      <div class="kpiRow">
        <span class="pill"><b>Topic</b> statistical optics / probability</span>
        <span class="pill"><b>Key idea</b> sums of i.i.d. geometric RVs</span>
      </div>
    </div>
  </header>

  <main>
    <article>
      <!-- Quick Summary -->
      <section id="quick-summary">
        <div class="tag"><span class="dot"></span><span>Quick Summary</span></div>
        <ul>
          <li><b>What this is about:</b> A negative-binomial distribution for total photon number <b>n</b> when <b>M</b> independent thermal (Bose–Einstein) modes are summed.</li>
          <li><b>Physics idea:</b> <i>Many independent modes “average out” fluctuations</i>, turning super-Poissonian thermal statistics into Poisson (shot-noise) statistics.</li>
          <li><b>Governing probability law:</b> for fixed mean <b>n̄</b>, the count distribution is
            <span class="pill"><b>p(n)=C(n+M−1,n) ( (n̄/M)^n / (1+n̄/M)^{n+M} )</b></span>.
          </li>
          <li><b>Limit 1 (M=1):</b> reduces to the <b>geometric / Bose–Einstein</b> distribution
            <span class="pill"><b>p(n)= (n̄^n)/(1+n̄)^{n+1}</b></span>.
          </li>
          <li><b>Limit 2 (M→∞):</b> at fixed <b>n̄</b>, approaches <b>Poisson</b>:
            <span class="pill"><b>p(n)→ e^{−n̄} n̄^n / n!</b></span>.
          </li>
          <li><b>Result type:</b> symbolic asymptotics + visual convergence (interactive plots).</li>
        </ul>
      </section>

      <!-- PART 0 -->
      <section id="part0">
        <h2>PART 0 — Concept Primer</h2>

        <div class="grid2">
          <div class="card ok">
            <h3>Core definitions (symbols &amp; meanings)</h3>
            <ul>
              <li><b>n</b> (dimensionless): total counted quanta (e.g., photons) in a detection window.</li>
              <li><b>M</b> (dimensionless): number of <i>independent, identical</i> modes / degrees of freedom being summed.</li>
              <li><b>n̄</b> (dimensionless): mean total count, i.e. <b>n̄ = E[n]</b>.</li>
              <li><b>Geometric / Bose–Einstein</b> distribution: photon-number statistics for a single thermal mode.</li>
              <li><b>Negative binomial</b> distribution: distribution of a sum of independent geometric random variables.</li>
            </ul>
          </div>

          <div class="card">
            <h3>Physical meaning (statistical optics lens)</h3>
            <p>
              A single thermal optical mode has <i>bunched</i> photons, producing large fluctuations
              (variance larger than the mean). If you observe <b>M</b> independent thermal modes and add their photon numbers,
              the relative fluctuations shrink roughly like <b>1/M</b>, and the distribution becomes more “shot-noise-like.”
            </p>
            <p class="mini">
              In many experiments, increasing the number of independent speckle grains / temporal modes / spatial modes in the detection
              area moves statistics from thermal-like toward Poisson-like.
            </p>
          </div>
        </div>

        <div class="callouts">
          <div class="card warn">
            <h3>Key principle: sums &amp; generating functions</h3>
            <p>
              Independence means probability generating functions multiply. The geometric distribution has a simple generating function,
              so the sum of <b>M</b> i.i.d. geometrics becomes negative binomial.
            </p>
          </div>

          <div class="card bad">
            <h3>Validity conditions (assumptions)</h3>
            <ul>
              <li>Modes are <b>independent</b> (no mutual correlations).</li>
              <li>Each mode has the <b>same</b> thermal (geometric) statistics.</li>
              <li>Total mean <b>n̄</b> is fixed while letting <b>M</b> vary.</li>
            </ul>
          </div>
        </div>

        <h3>Common models / approximations (why we use them)</h3>
        <ul>
          <li><b>Large-M limit:</b> use asymptotics like <b>(1 + x/M)^M → e^x</b>, and Stirling-like products for factorial ratios.</li>
          <li><b>Fixed mean n̄:</b> we keep the total average photon number constant while spreading it over many modes.</li>
        </ul>

        <h3>Mini intuition examples</h3>
        <ul>
          <li><b>M=1:</b> one thermal mode → strong bunching → geometric tail; the probability falls slowly with n.</li>
          <li><b>M large:</b> many independent contributions → fluctuations average out → distribution narrows → Poisson.</li>
        </ul>

        <h3>What to watch for</h3>
        <ul>
          <li>Confusing <b>mean per mode</b> (<b>n̄/M</b>) with <b>total mean</b> (<b>n̄</b>).</li>
          <li>Taking <b>M→∞</b> while accidentally letting <b>n̄</b> change (the Poisson limit requires fixed n̄).</li>
          <li>Dropping the combinatorial factor <b>C(n+M−1,n)</b>, which is crucial for the limit behavior.</li>
        </ul>
      </section>

      <!-- PART 1 -->
      <section id="part1">
        <h2>PART 1 — Problem Analysis</h2>

        <h3>Restate the problem</h3>
        <p>
          You are given the negative-binomial distribution for the sum of <b>M</b> identically distributed geometric (Bose–Einstein)
          random variables. The distribution is parameterized by the <b>total mean</b> <b>n̄</b>:
        </p>

        <div class="equation" data-copy="eq-nb">
          <div class="eqbar">
            <strong>Negative binomial form (given)</strong>
            <button class="copyBtn" data-copy-btn="eq-nb">Copy</button>
          </div>
          <pre id="eq-nb">p_M(n) = C(n+M-1, n) * ( (n̄/M)^n ) / (1 + n̄/M)^(n+M)
where C(a,b) = a! / (b!(a-b)!)</pre>
        </div>

        <p>
          Verify:
          (i) for <b>M=1</b>, this reduces to the Bose–Einstein (geometric) distribution;
          (ii) as <b>M→∞</b> (with fixed <b>n̄</b>), it approaches a Poisson distribution with mean <b>n̄</b>.
        </p>

        <h3>Given quantities</h3>
        <ul>
          <li><b>M</b>: positive integer (mode number).</li>
          <li><b>n̄</b>: fixed mean total count.</li>
          <li><b>p_M(n)</b>: probability mass function for <b>n=0,1,2,...</b></li>
        </ul>

        <h3>Unknowns / what must be shown</h3>
        <ul>
          <li>Show <b>p_1(n) = (n̄^n)/(1+n̄)^(n+1)</b>.</li>
          <li>Show <b>lim<sub>M→∞</sub> p_M(n) = e^(−n̄) n̄^n / n!</b> for each fixed n.</li>
        </ul>

        <h3>Relevant principles (and why)</h3>
        <ul>
          <li><b>Combinatorics of negative binomial:</b> captures the multiplicity of partitions of n among M modes.</li>
          <li><b>Asymptotic limits:</b> the Poisson limit emerges from <b>(1 + n̄/M)^M → e^{n̄}</b> and factorial-ratio behavior.</li>
        </ul>

        <div class="card warn">
          <h3>Assumptions (explicit)</h3>
          <ul>
            <li><b>M→∞</b> is taken with <b>n̄ fixed</b>, and <b>n is fixed</b> (pointwise convergence of the PMF).</li>
            <li>All random variables are well-defined for nonnegative integers, and standard limits apply.</li>
          </ul>
        </div>

        <h3>Possible approaches (compare)</h3>
        <ul>
          <li><b>Direct substitution + asymptotics (best here):</b> plug in M=1, then use standard limits for M→∞. Fast and transparent.</li>
          <li><b>Generating functions:</b> show the PGF tends to exp(n̄(z−1)) → Poisson. Elegant but slightly more abstract.</li>
          <li><b>Moment matching:</b> show all factorial moments converge to Poisson’s. Works, but longer.</li>
        </ul>

        <p><b>Chosen approach:</b> direct algebra for M=1, and controlled asymptotics for M→∞, because the given formula is already in a limit-friendly form.</p>
      </section>

      <!-- PART 2 -->
      <section id="part2">
        <h2>PART 2 — Strategy &amp; Tips</h2>

        <ol style="margin:10px 0 10px 22px; color: var(--muted);">
          <li><b>Goal:</b> Evaluate the formula at <b>M=1</b>. <b>Tool:</b> simplify the binomial coefficient. <b>Meaning:</b> one mode = thermal statistics.</li>
          <li><b>Goal:</b> Rewrite p<sub>M</sub>(n) into factors that have clear M→∞ limits. <b>Tool:</b> separate the combinatorial term and the normalization term.</li>
          <li><b>Goal:</b> Take the limit of the “Poisson core” factor. <b>Tool:</b> (1 + x/M)^M → e^x, and (1 + x/M)^n → 1 for fixed n.</li>
          <li><b>Goal:</b> Take the limit of the combinatorial prefactor. <b>Tool:</b> factorial ratio as a finite product: (n+M−1)!/(M−1)! = ∏_{k=0}^{n-1}(M+k).</li>
          <li><b>Goal:</b> Combine limits carefully, keeping n fixed. <b>Meaning:</b> the resulting PMF is Poisson with mean n̄.</li>
          <li><b>Sanity checks:</b> verify normalization form and compare variance trends (optional but insightful).</li>
        </ol>

        <div class="callouts">
          <div class="card bad">
            <h3>Common mistakes</h3>
            <ul>
              <li>Replacing C(n+M−1,n) by M^n/n! without justifying (it’s true in the limit, but show it).</li>
              <li>Forgetting that the exponent is <b>n+M</b>, not just M.</li>
              <li>Letting n grow with M; the simplest Poisson limit is for fixed n (pointwise PMF).</li>
            </ul>
          </div>
          <div class="card ok">
            <h3>Quick tips</h3>
            <ul>
              <li>Convert factorial ratios into products; limits become obvious.</li>
              <li>Factor (1 + n̄/M)^{n+M} = (1 + n̄/M)^M (1 + n̄/M)^n.</li>
              <li>Track which pieces tend to 1, which tend to e^{±n̄}, and which carry n̄^n/n!.</li>
            </ul>
          </div>
        </div>
      </section>

      <!-- PART 3 -->
      <section id="part3">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Physical intuition before calculating</h3>
        <p>
          For a <b>single thermal mode</b>, photons “bunch,” producing a broad, geometric distribution.
          If you sum <b>many independent thermal modes</b>, the total is an average of many independent contributions,
          so relative intensity fluctuations shrink. In the large-M limit, the statistics should resemble
          <b>shot noise</b>, i.e. a <b>Poisson</b> distribution with the same mean <b>n̄</b>.
        </p>

        <div class="hr"></div>

        <h3>Step A — Verify the M = 1 limit (Bose–Einstein / geometric)</h3>
        <p>
          Start from the given negative-binomial form (define all symbols):
          <b>n</b> is a nonnegative integer count, <b>M</b> is the number of summed i.i.d. geometric variables,
          and <b>n̄</b> is the mean total count.
        </p>

        <div class="equation" data-copy="eq-stepA">
          <div class="eqbar">
            <strong>Start with p<sub>M</sub>(n)</strong>
            <button class="copyBtn" data-copy-btn="eq-stepA">Copy</button>
          </div>
          <pre id="eq-stepA">p_M(n) = C(n+M-1, n) * ( (n̄/M)^n ) / (1 + n̄/M)^(n+M)</pre>
        </div>

        <p>
          Set <b>M=1</b>. Then the combinatorial factor becomes:
          <span class="pill"><b>C(n+1−1, n) = C(n, n) = 1</b></span>.
        </p>

        <p>
          Also, <b>n̄/M = n̄</b> and <b>n+M = n+1</b>. Therefore:
        </p>

        <div class="equation" data-copy="eq-be">
          <div class="eqbar">
            <strong>M=1 ⇒ Bose–Einstein (geometric) distribution</strong>
            <button class="copyBtn" data-copy-btn="eq-be">Copy</button>
          </div>
          <pre id="eq-be">p_1(n) = (n̄^n) / (1 + n̄)^(n+1),   n = 0,1,2,...</pre>
        </div>

        <p class="mini">
          Interpretation: the probability decays like a geometric series in n, with mean n̄. This is the standard
          photon-number distribution for a single thermal mode.
        </p>

        <div class="hr"></div>

        <h3>Step B — Verify the M → ∞ limit (Poisson)</h3>
        <p>
          We take <b>M→∞</b> while holding <b>n̄ fixed</b> and looking at a fixed count <b>n</b>.
          Begin by separating the pieces that will have clean limits.
        </p>

        <p>
          Write the denominator as:
          <span class="pill"><b>(1 + n̄/M)^(n+M) = (1 + n̄/M)^M · (1 + n̄/M)^n</b></span>.
        </p>

        <p>
          So we can rewrite:
        </p>

        <div class="equation" data-copy="eq-factor">
          <div class="eqbar">
            <strong>Factorized form for limits</strong>
            <button class="copyBtn" data-copy-btn="eq-factor">Copy</button>
          </div>
          <pre id="eq-factor">p_M(n) = C(n+M-1, n) * (n̄/M)^n * (1 + n̄/M)^(-M) * (1 + n̄/M)^(-n)</pre>
        </div>

        <h3>Step B1 — Limit of the “exponential” factor</h3>
        <p>
          Use the standard limit <b>(1 + x/M)^M → e^x</b> as <b>M→∞</b>.
          With x = n̄:
        </p>
        <ul>
          <li><b>(1 + n̄/M)^(-M) → e^(−n̄)</b>.</li>
          <li>For fixed n, <b>(1 + n̄/M)^(-n) → 1</b> because (1 + n̄/M) → 1.</li>
        </ul>

        <h3>Step B2 — Limit of the combinatorial prefactor</h3>
        <p>
          Expand the binomial coefficient:
        </p>
        <div class="equation" data-copy="eq-comb">
          <div class="eqbar">
            <strong>Binomial coefficient as a product</strong>
            <button class="copyBtn" data-copy-btn="eq-comb">Copy</button>
          </div>
          <pre id="eq-comb">C(n+M-1, n) = (n+M-1)! / (n!(M-1)!)
            = (1/n!) * ∏_{k=0}^{n-1} (M + k)</pre>
        </div>

        <p>
          Multiply by (n̄/M)^n:
        </p>
        <div class="equation" data-copy="eq-comb2">
          <div class="eqbar">
            <strong>Combine with (n̄/M)<sup>n</sup></strong>
            <button class="copyBtn" data-copy-btn="eq-comb2">Copy</button>
          </div>
          <pre id="eq-comb2">C(n+M-1, n) * (n̄/M)^n
= (n̄^n / n!) * ∏_{k=0}^{n-1} (1 + k/M)</pre>
        </div>

        <p>
          Now take <b>M→∞</b> with fixed n. Each factor (1 + k/M) → 1, and there are only finitely many factors (k=0,...,n−1), so:
        </p>
        <p>
          <span class="pill"><b>∏_{k=0}^{n-1} (1 + k/M) → 1</b></span>
          hence
          <span class="pill"><b>C(n+M-1, n) * (n̄/M)^n → n̄^n / n!</b></span>.
        </p>

        <h3>Step B3 — Combine all limits</h3>
        <p>
          Putting the pieces together:
        </p>
        <ul>
          <li>Combinatorial+power term → <b>n̄^n / n!</b></li>
          <li>(1 + n̄/M)^(-M) → <b>e^(−n̄)</b></li>
          <li>(1 + n̄/M)^(-n) → <b>1</b></li>
        </ul>

        <div class="equation" data-copy="eq-poisson">
          <div class="eqbar">
            <strong>Poisson limit (final)</strong>
            <button class="copyBtn" data-copy-btn="eq-poisson">Copy</button>
          </div>
          <pre id="eq-poisson">lim_{M→∞} p_M(n) = e^(−n̄) * (n̄^n / n!)   (Poisson with mean n̄)</pre>
        </div>

        <div class="card ok">
          <h3>Sanity checks</h3>
          <ul>
            <li><b>Units:</b> all quantities are dimensionless counts/probabilities → consistent.</li>
            <li><b>Limiting cases:</b> M=1 gives geometric; large M gives Poisson → matches physical intuition (fluctuations average out).</li>
            <li><b>Physical meaning:</b> a single thermal mode is strongly bunched; many independent modes produce near-shot-noise statistics.</li>
          </ul>
        </div>

        <p class="mini">
          Connection to plots: in the interactive PMF plot, as you increase M the negative-binomial curve collapses toward the Poisson curve.
          The variance plot shows the Fano factor trending to 1.
        </p>
      </section>

      <!-- PART 4 -->
      <section id="part4">
        <h2>PART 4 — Deeper Understanding</h2>

        <h3>Re-interpret the final formula</h3>
        <p>
          The negative-binomial PMF
          <span class="pill"><b>p_M(n)=C(n+M−1,n) ( (n̄/M)^n / (1+n̄/M)^{n+M} )</b></span>
          has two intuitive ingredients:
        </p>
        <ul>
          <li><b>C(n+M−1,n)</b>: “How many ways” to distribute n indistinguishable quanta across M modes (a stars-and-bars count).</li>
          <li><b>(n̄/M)^n / (1+n̄/M)^{n+M}</b>: sets the exponential/geometric tail controlled by the mean per mode n̄/M.</li>
        </ul>

        <h3>How changing parameters affects outcomes (connect to plots)</h3>
        <ul>
          <li>Increasing <b>M</b> (fixed n̄) reduces relative fluctuations: the PMF becomes narrower and more Poisson-like.</li>
          <li>Increasing <b>n̄</b> (fixed M) shifts the distribution to larger n and increases absolute spread; for small M it remains heavy-tailed.</li>
        </ul>

        <div class="equation" data-copy="eq-var">
          <div class="eqbar">
            <strong>Useful fluctuation metric (shown in the secondary plot)</strong>
            <button class="copyBtn" data-copy-btn="eq-var">Copy</button>
          </div>
          <pre id="eq-var">For this parameterization:
mean:    E[n] = n̄
variance:Var(n) = n̄ + (n̄^2)/M
Fano factor: F = Var/mean = 1 + n̄/M</pre>
        </div>

        <p class="mini">
          The variance formula explains the Poisson limit immediately: as M→∞, Var(n)→n̄ so F→1.
          For M=1, Var(n)=n̄+n̄² (thermal bunching), so F=1+n̄.
        </p>

        <h3>Alternative derivation idea (brief)</h3>
        <p>
          Using the probability generating function (PGF):
          a geometric distribution has PGF <span class="pill"><b>G(z)=1/(1+n̄(1−z))</b></span> (up to parameter conventions).
          The sum of M i.i.d. variables has PGF <b>G(z)^M</b>, which tends to
          <span class="pill"><b>exp(n̄(z−1))</b></span> as M→∞—the PGF of a Poisson distribution.
        </p>

        <h3>Concept checks (with answers)</h3>
        <ul>
          <li><b>Q:</b> Why does M→∞ give Poisson rather than Gaussian? <b>A:</b> The variable is discrete counts; the PMF converges pointwise to Poisson at fixed n̄. A Gaussian approximation may emerge for large n̄, but that’s a different limit.</li>
          <li><b>Q:</b> What must be held fixed to get Poisson? <b>A:</b> The total mean n̄ (and consider fixed n for PMF convergence).</li>
          <li><b>Q:</b> What indicates “thermal” behavior in the variance? <b>A:</b> Var(n) > n̄, i.e. Fano factor F > 1 (super-Poissonian).</li>
        </ul>
      </section>

      <!-- PART 5 -->
      <section id="part5">
        <h2>PART 5 — Visualization Guide</h2>

        <h3>What each canvas shows</h3>
        <ul>
          <li><b>Diagram canvas:</b> a cartoon of <b>M independent thermal modes</b> (each geometric-distributed count) feeding into a <b>sum</b> that produces total n.</li>
          <li><b>Main plot (PMF):</b> p(n) vs n comparing:
            <span class="pill"><b>Negative binomial</b></span>,
            <span class="pill"><b>Poisson (same n̄)</b></span>,
            and <span class="pill"><b>Geometric (M=1)</b></span> for reference.
          </li>
          <li><b>Secondary plot (fluctuations):</b> the <b>Fano factor</b> F = Var/mean = 1 + n̄/M vs M, showing convergence to 1.</li>
        </ul>

        <h3>Interactive controls</h3>
        <ul>
          <li><b>Slider “M (modes)”: </b> changes the number of summed independent thermal modes. Increasing M should make the negative-binomial curve approach Poisson.</li>
          <li><b>Slider “n̄ (mean)”: </b> changes the mean total count. This shifts both Poisson and negative-binomial to larger n; it also changes how quickly F approaches 1 with M.</li>
          <li><b>Checkbox “Show Poisson overlay”: </b> toggles the Poisson comparison curve.</li>
        </ul>

        <div class="card warn">
          <h3>Reading the convergence correctly</h3>
          <ul>
            <li>For small M, the negative-binomial tail is heavier than Poisson (more large-n events).</li>
            <li>As M grows, the difference shrinks; eventually curves nearly coincide (Poisson limit).</li>
            <li>The secondary plot quantifies this: <b>F → 1</b> means Poisson-like variance.</li>
          </ul>
        </div>
      </section>
    </article>

    <aside>
      <nav class="toc" aria-label="Table of contents">
        <h2>Table of Contents</h2>
        <a href="#quick-summary">Quick Summary</a>
        <a href="#part0">PART 0 — Concept Primer</a>
        <a href="#part1">PART 1 — Problem Analysis</a>
        <a href="#part2">PART 2 — Strategy &amp; Tips</a>
        <a href="#part3">PART 3 — Full Solution</a>
        <a href="#part4">PART 4 — Deeper Understanding</a>
        <a href="#part5">PART 5 — Visualization Guide</a>
      </nav>

      <div class="vizPanel">
        <h2>Interactive Visualizations</h2>

        <div class="controls">
          <div class="control">
            <label>
              <span>M (modes)</span>
              <span class="value" id="Mval">10</span>
            </label>
            <input type="range" id="Mslider" min="1" max="80" step="1" value="10" />
            <div class="row"><span class="mini">Thermal → Poisson as M increases</span><span class="mini">integer</span></div>
          </div>

          <div class="control">
            <label>
              <span>n̄ (mean total count)</span>
              <span class="value" id="nbarVal">6.0</span>
            </label>
            <input type="range" id="nbarSlider" min="0.5" max="18" step="0.1" value="6.0" />
            <div class="row"><span class="mini">Example value for plotting</span><span class="mini">dimensionless</span></div>
          </div>

          <div class="control">
            <label>
              <span>Comparison</span>
              <span class="value">toggle</span>
            </label>
            <div class="row">
              <label style="margin:0; display:flex; gap:10px; align-items:center; justify-content:flex-start; color:var(--muted); font-size:13px;">
                <input type="checkbox" id="showPoisson" checked />
                Show Poisson overlay
              </label>
            </div>
            <div class="row">
              <label style="margin:0; display:flex; gap:10px; align-items:center; justify-content:flex-start; color:var(--muted); font-size:13px;">
                <input type="checkbox" id="showGeo" checked />
                Show geometric (M=1) reference
              </label>
            </div>
          </div>
        </div>

        <figure>
          <canvas id="diagram" class="canvasSmall" aria-label="Diagram canvas"></canvas>
          <canvas id="pmfPlot" aria-label="PMF plot canvas"></canvas>
          <canvas id="fanoPlot" class="canvasSmall" aria-label="Fano factor plot canvas"></canvas>
          <div class="mini">All plots update live when you change M or n̄.</div>
        </figure>
      </div>
    </aside>
  </main>

  <footer>
    Built as a self-contained learning article (vanilla HTML/CSS/JS). Plots use example parameters for visualization; the mathematical results are symbolic and general.
  </footer>

  <script>
    // ---------- Copy buttons ----------
    function copyTextFromId(id){
      const el = document.getElementById(id);
      const text = el ? el.textContent : "";
      navigator.clipboard.writeText(text).then(()=>{
        const btn = document.querySelector(`[data-copy-btn="${id}"]`);
        if(!btn) return;
        const old = btn.textContent;
        btn.textContent = "Copied ✓";
        setTimeout(()=>btn.textContent = old, 900);
      }).catch(()=>{
        // fallback
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
      });
    }
    document.querySelectorAll(".copyBtn").forEach(btn=>{
      btn.addEventListener("click", ()=>copyTextFromId(btn.getAttribute("data-copy-btn")));
    });

    // ---------- Math helpers (stable logs) ----------
    // Lanczos approximation for logGamma (works well for positive x).
    function logGamma(z){
      const p = [
        676.5203681218851,
        -1259.1392167224028,
        771.32342877765313,
        -176.61502916214059,
        12.507343278686905,
        -0.13857109526572012,
        9.9843695780195716e-6,
        1.5056327351493116e-7
      ];
      if(z < 0.5){
        // Reflection formula: Γ(z)Γ(1-z) = π/sin(πz)
        return Math.log(Math.PI) - Math.log(Math.sin(Math.PI*z)) - logGamma(1 - z);
      }
      z -= 1;
      let x = 0.99999999999980993;
      for(let i=0;i<p.length;i++) x += p[i]/(z+i+1);
      const t = z + p.length - 0.5;
      return 0.5*Math.log(2*Math.PI) + (z+0.5)*Math.log(t) - t + Math.log(x);
    }

    function logFactorial(n){
      if(n < 0) return NaN;
      return logGamma(n + 1);
    }

    function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

    // Negative binomial (as given): p_M(n)=C(n+M-1,n) ( (nbar/M)^n ) / (1+nbar/M)^(n+M)
    function nbPMF(n, M, nbar){
      if(M <= 0) return 0;
      if(n < 0) return 0;
      // Use logs to avoid overflow:
      // logC = log((n+M-1)!)-log(n!)-log((M-1)!)
      const logC = logFactorial(n + M - 1) - logFactorial(n) - logFactorial(M - 1);
      const a = nbar / M;
      const logTerm = (n === 0 ? 0 : n*Math.log(a)) - (n + M)*Math.log(1 + a);
      const logp = logC + logTerm;
      return Math.exp(logp);
    }

    function poissonPMF(n, lambda){
      if(n < 0) return 0;
      // log = -λ + n log λ - log(n!)
      const logp = -lambda + (n===0 ? 0 : n*Math.log(lambda)) - logFactorial(n);
      return Math.exp(logp);
    }

    function geometricPMF(n, nbar){
      // Bose–Einstein / geometric on n=0,1,... : p(n)= nbar^n / (1+nbar)^(n+1)
      const logp = (n===0?0:n*Math.log(nbar)) - (n+1)*Math.log(1 + nbar);
      return Math.exp(logp);
    }

    // ---------- Canvas plotting utilities ----------
    function setupCanvas(canvas){
      const ctx = canvas.getContext("2d");
      function resize(){
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        const w = Math.max(1, Math.floor(rect.width * dpr));
        const h = Math.max(1, Math.floor(rect.height * dpr));
        if(canvas.width !== w || canvas.height !== h){
          canvas.width = w;
          canvas.height = h;
        }
        ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      }
      resize();
      return {ctx, resize};
    }

    function niceTicks(min, max, target=5){
      const span = max - min;
      if(span <= 0) return [min];
      const raw = span / target;
      const pow10 = Math.pow(10, Math.floor(Math.log10(raw)));
      const steps = [1,2,5,10].map(s=>s*pow10);
      let step = steps[0];
      for(const s of steps){
        if(raw <= s){ step = s; break; }
      }
      const start = Math.ceil(min/step)*step;
      const ticks = [];
      for(let v=start; v<=max+1e-9; v+=step) ticks.push(+v.toFixed(12));
      return ticks;
    }

    function drawAxes(ctx, W, H, plot, opts){
      // plot area margins
      const m = opts.margins;
      const x0 = m.l, y0 = m.t, x1 = W - m.r, y1 = H - m.b;
      ctx.save();
      ctx.clearRect(0,0,W,H);

      // background
      ctx.fillStyle = "rgba(0,0,0,0)";
      ctx.fillRect(0,0,W,H);

      // Title
      ctx.fillStyle = "rgba(233,238,252,0.95)";
      ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText(opts.title, m.l, 8);

      // grid + axes
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;

      // ticks
      const xt = niceTicks(plot.xmin, plot.xmax, 6);
      const yt = niceTicks(plot.ymin, plot.ymax, 5);

      function xMap(x){ return x0 + (x - plot.xmin) * (x1 - x0) / (plot.xmax - plot.xmin); }
      function yMap(y){ return y1 - (y - plot.ymin) * (y1 - y0) / (plot.ymax - plot.ymin); }

      // gridlines
      ctx.beginPath();
      xt.forEach(v=>{
        const x = xMap(v);
        ctx.moveTo(x, y0);
        ctx.lineTo(x, y1);
      });
      yt.forEach(v=>{
        const y = yMap(v);
        ctx.moveTo(x0, y);
        ctx.lineTo(x1, y);
      });
      ctx.stroke();

      // axes lines
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.beginPath();
      ctx.moveTo(x0, y1);
      ctx.lineTo(x1, y1);
      ctx.moveTo(x0, y0);
      ctx.lineTo(x0, y1);
      ctx.stroke();

      // tick labels
      ctx.fillStyle = "rgba(183,194,230,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.textBaseline = "top";
      ctx.textAlign = "center";
      xt.forEach(v=>{
        const x = xMap(v);
        ctx.fillText(String(v), x, y1 + 6);
      });
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      yt.forEach(v=>{
        const y = yMap(v);
        ctx.fillText(String(v), x0 - 6, y);
      });

      // axis labels
      ctx.fillStyle = "rgba(233,238,252,0.9)";
      ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      ctx.fillText(opts.xlabel, (x0 + x1)/2, H - 6);

      ctx.save();
      ctx.translate(12, (y0 + y1)/2);
      ctx.rotate(-Math.PI/2);
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(opts.ylabel, 0, 0);
      ctx.restore();

      // legend (simple)
      if(opts.legend && opts.legend.length){
        const pad=8;
        let lx = x1 - 10;
        let ly = y0 + 26;
        ctx.textAlign="right";
        ctx.textBaseline="middle";
        ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        opts.legend.forEach(item=>{
          // line sample
          ctx.strokeStyle = item.color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(lx-70, ly);
          ctx.lineTo(lx-40, ly);
          ctx.stroke();
          // label
          ctx.fillStyle = "rgba(233,238,252,0.92)";
          ctx.fillText(item.label, lx, ly);
          ly += 18;
        });
      }

      ctx.restore();
      return {x0,y0,x1,y1,xMap,yMap};
    }

    function drawLine(ctx, mapper, xs, ys, color, dashed=false){
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.setLineDash(dashed ? [6,6] : []);
      ctx.beginPath();
      for(let i=0;i<xs.length;i++){
        const x = mapper.xMap(xs[i]);
        const y = mapper.yMap(ys[i]);
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawStem(ctx, mapper, xs, ys, color){
      // discrete PMF: vertical stems + markers
      ctx.save();
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = 2;
      for(let i=0;i<xs.length;i++){
        const x = mapper.xMap(xs[i]);
        const y = mapper.yMap(ys[i]);
        const y0 = mapper.yMap(0);
        ctx.beginPath();
        ctx.moveTo(x, y0);
        ctx.lineTo(x, y);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    // ---------- Diagram ----------
    function drawDiagram(ctx, W, H, M, nbar){
      ctx.clearRect(0,0,W,H);
      const pad = 14;
      ctx.fillStyle = "rgba(233,238,252,0.95)";
      ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText("Diagram: M independent thermal modes summed → total photon count n", pad, 10);

      // Draw mode boxes (up to show 8; if larger, show ellipsis)
      const maxBoxes = 8;
      const shown = Math.min(M, maxBoxes);
      const boxW = (W - 2*pad) / (shown + 2.0);
      const boxH = Math.min(50, H*0.23);
      const topY = 46;

      for(let i=0;i<shown;i++){
        const x = pad + i*boxW;
        const y = topY;
        // box
        ctx.fillStyle = "rgba(125,211,252,0.10)";
        ctx.strokeStyle = "rgba(125,211,252,0.30)";
        ctx.lineWidth = 1.5;
        roundRect(ctx, x, y, boxW*0.9, boxH, 10, true, true);
        // label
        ctx.fillStyle = "rgba(233,238,252,0.92)";
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillText(`n${i+1} ~ Geom`, x+8, y+8);
      }

      if(M > maxBoxes){
        ctx.fillStyle = "rgba(183,194,230,0.85)";
        ctx.font = "700 16px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.fillText("⋯", pad + shown*boxW + 4, topY + boxH/2);
      }

      // Sum node
      const sumX = W - pad - 90;
      const sumY = topY + boxH/2;
      ctx.fillStyle = "rgba(167,139,250,0.12)";
      ctx.strokeStyle = "rgba(167,139,250,0.35)";
      ctx.lineWidth = 1.5;
      roundRect(ctx, sumX, sumY-30, 90, 60, 14, true, true);

      ctx.fillStyle = "rgba(233,238,252,0.95)";
      ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("SUM", sumX+45, sumY-8);
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillText("n = Σ nᵢ", sumX+45, sumY+12);

      // arrows from boxes to sum
      ctx.strokeStyle = "rgba(233,238,252,0.25)";
      ctx.lineWidth = 1.5;
      for(let i=0;i<shown;i++){
        const x = pad + i*boxW + boxW*0.9;
        const y = topY + boxH/2;
        arrow(ctx, x, y, sumX, sumY);
      }

      // Bottom note
      ctx.fillStyle = "rgba(183,194,230,0.90)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textAlign = "left";
      ctx.textBaseline = "bottom";
      const note = `Example parameters: M = ${M}, n̄ = ${nbar.toFixed(1)} (mean total count).`;
      ctx.fillText(note, pad, H - 12);
    }

    function roundRect(ctx, x, y, w, h, r, fill, stroke){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
      if(fill) ctx.fill();
      if(stroke) ctx.stroke();
    }

    function arrow(ctx, x0, y0, x1, y1){
      const dx = x1 - x0, dy = y1 - y0;
      const L = Math.hypot(dx,dy);
      if(L < 1) return;
      const ux = dx/L, uy = dy/L;
      const endX = x1 - 10*ux, endY = y1 - 10*uy;
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      // arrowhead
      const a = 6;
      const px = -uy, py = ux;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(endX + a*px, endY + a*py);
      ctx.lineTo(endX - a*px, endY - a*py);
      ctx.closePath();
      ctx.fillStyle = "rgba(233,238,252,0.25)";
      ctx.fill();
    }

    // ---------- Plotting: PMF ----------
    function drawPMF(ctx, W, H, M, nbar, showPoisson, showGeo){
      // choose n-range so we see most mass
      const nMax = Math.max(18, Math.ceil(nbar + 6*Math.sqrt(nbar + (nbar*nbar)/Math.max(1,M))));
      const xs = [];
      for(let n=0;n<=nMax;n++) xs.push(n);

      const nb = xs.map(n=>nbPMF(n,M,nbar));
      const poi = xs.map(n=>poissonPMF(n,nbar));
      const geo = xs.map(n=>geometricPMF(n,nbar));

      let ymax = 0;
      nb.forEach(v=>ymax=Math.max(ymax,v));
      if(showPoisson) poi.forEach(v=>ymax=Math.max(ymax,v));
      if(showGeo) geo.forEach(v=>ymax=Math.max(ymax,v));
      ymax = ymax*1.15 + 1e-12;

      const plot = {xmin:0, xmax:nMax, ymin:0, ymax:ymax};
      const mapper = drawAxes(ctx, W, H, plot, {
        title: "Main plot: PMF p(n) vs n",
        xlabel: "n (photon count, dimensionless)",
        ylabel: "p(n) (probability)",
        margins: {l:58, r:16, t:30, b:34},
        legend: [
          {label:`Negative binomial (M=${M})`, color:"rgba(125,211,252,0.95)"},
          ...(showPoisson ? [{label:"Poisson (mean n̄)", color:"rgba(134,239,172,0.95)"}] : []),
          ...(showGeo ? [{label:"Geometric / BE (M=1)", color:"rgba(251,191,36,0.95)"}] : []),
        ]
      });

      // draw discrete stems
      drawStem(ctx, mapper, xs, nb, "rgba(125,211,252,0.95)");
      if(showPoisson) drawLine(ctx, mapper, xs, poi, "rgba(134,239,172,0.95)", true);
      if(showGeo) drawLine(ctx, mapper, xs, geo, "rgba(251,191,36,0.95)", true);

      // small annotation about convergence
      ctx.save();
      ctx.fillStyle = "rgba(183,194,230,0.90)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      const txt = (M===1) ? "M=1: NB = geometric (thermal)" : (M>=40 ? "Large M: NB ≈ Poisson" : "Increase M to see NB → Poisson");
      ctx.fillText(txt, mapper.x0 + 8, mapper.y0 + 8);
      ctx.restore();
    }

    // ---------- Plotting: Fano factor vs M ----------
    function drawFano(ctx, W, H, Mcurrent, nbar){
      // Sweep M from 1..80
      const Ms = [];
      const Fs = [];
      const Mmax = 80;
      for(let m=1;m<=Mmax;m++){
        Ms.push(m);
        Fs.push(1 + nbar/m);
      }
      const ymin = 1;
      const ymax = 1 + nbar; // at M=1
      const plot = {xmin:1, xmax:Mmax, ymin:ymin, ymax:ymax*1.05};

      const mapper = drawAxes(ctx, W, H, plot, {
        title: "Secondary plot: Fluctuations (Fano factor F = Var/mean)",
        xlabel: "M (number of modes)",
        ylabel: "F (dimensionless)",
        margins: {l:58, r:16, t:30, b:34},
        legend: [{label:"F = 1 + n̄/M", color:"rgba(167,139,250,0.95)"}]
      });

      drawLine(ctx, mapper, Ms, Fs, "rgba(167,139,250,0.95)", false);

      // highlight current M
      ctx.save();
      const x = mapper.xMap(Mcurrent);
      const y = mapper.yMap(1 + nbar/Mcurrent);
      ctx.fillStyle = "rgba(233,238,252,0.95)";
      ctx.strokeStyle = "rgba(233,238,252,0.35)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "rgba(183,194,230,0.90)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.textAlign = "left";
      ctx.textBaseline = "bottom";
      ctx.fillText(`M=${Mcurrent}, F=${(1+nbar/Mcurrent).toFixed(3)}`, mapper.x0 + 8, mapper.y1 - 8);
      ctx.restore();
    }

    // ---------- State + rendering ----------
    const diagramCanvas = document.getElementById("diagram");
    const pmfCanvas = document.getElementById("pmfPlot");
    const fanoCanvas = document.getElementById("fanoPlot");

    const d0 = setupCanvas(diagramCanvas);
    const d1 = setupCanvas(pmfCanvas);
    const d2 = setupCanvas(fanoCanvas);

    const Mslider = document.getElementById("Mslider");
    const nbarSlider = document.getElementById("nbarSlider");
    const Mval = document.getElementById("Mval");
    const nbarVal = document.getElementById("nbarVal");
    const showPoisson = document.getElementById("showPoisson");
    const showGeo = document.getElementById("showGeo");

    function render(){
      const M = parseInt(Mslider.value,10);
      const nbar = parseFloat(nbarSlider.value);
      Mval.textContent = String(M);
      nbarVal.textContent = nbar.toFixed(1);

      // resize (responsive + crisp)
      d0.resize(); d1.resize(); d2.resize();

      // use CSS pixel sizes for drawAxes; our contexts are already set to CSS coords via setTransform(dpr,...)
      const r0 = diagramCanvas.getBoundingClientRect();
      const r1 = pmfCanvas.getBoundingClientRect();
      const r2 = fanoCanvas.getBoundingClientRect();

      drawDiagram(d0.ctx, r0.width, r0.height, M, nbar);
      drawPMF(d1.ctx, r1.width, r1.height, M, nbar, showPoisson.checked, showGeo.checked);
      drawFano(d2.ctx, r2.width, r2.height, M, nbar);
    }

    // events
    [Mslider, nbarSlider, showPoisson, showGeo].forEach(el=>{
      el.addEventListener("input", render);
      el.addEventListener("change", render);
    });

    window.addEventListener("resize", ()=>{
      // re-render on resize for crisp scaling
      render();
    });

    // initial draw
    render();
  </script>
</body>
</html>
