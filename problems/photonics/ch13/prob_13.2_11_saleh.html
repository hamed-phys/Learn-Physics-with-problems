<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Random Partitioning of Single-Mode Thermal Light (Beam Splitter): Bose–Einstein Form, Mean Counts, and SNR</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#101a33;
      --card2:#0f1730;
      --text:#e8eeff;
      --muted:#b7c3ffcc;
      --accent:#7aa7ff;
      --accent2:#7dffcf;
      --warn:#ffcc66;
      --ok:#8bff8b;
      --danger:#ff7a7a;
      --border:rgba(255,255,255,.12);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1100px 700px at 10% -10%, rgba(122,167,255,.28), transparent 55%),
        radial-gradient(900px 700px at 90% 0%, rgba(125,255,207,.18), transparent 55%),
        radial-gradient(900px 900px at 50% 110%, rgba(255,204,102,.10), transparent 60%),
        var(--bg);
      line-height:1.55;
    }
    a{color:var(--accent)}
    header{
      padding:28px 18px 16px;
      max-width:1200px;
      margin:0 auto;
    }
    .kicker{
      display:inline-flex;
      gap:10px;
      align-items:center;
      padding:8px 12px;
      border:1px solid var(--border);
      border-radius:999px;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow:var(--shadow);
      color:var(--muted);
      font-size:13px;
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #fff, var(--accent));
      box-shadow:0 0 18px rgba(122,167,255,.45);
    }
    h1{
      margin:14px 0 8px;
      font-size: clamp(26px, 2.6vw, 40px);
      letter-spacing:.2px;
      line-height:1.15;
    }
    .sub{
      color:var(--muted);
      max-width:78ch;
      font-size:15.5px;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding:0 18px 60px;
      display:grid;
      grid-template-columns: 330px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
    }

    aside{
      position:sticky;
      top:14px;
      align-self:start;
      border:1px solid var(--border);
      border-radius:18px;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .tocHead{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--border);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .tocHead strong{font-size:14px; letter-spacing:.2px}
    .tocHead span{font-size:12px;color:var(--muted)}
    .toc{
      padding:10px 10px 14px;
    }
    .toc a{
      display:block;
      padding:9px 10px;
      margin:4px 0;
      border-radius:12px;
      text-decoration:none;
      color:var(--text);
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:13.5px;
    }
    .toc a:hover{
      background:rgba(122,167,255,.10);
      border-color:rgba(122,167,255,.25);
      transform: translateY(-1px);
    }

    .controls{
      padding:12px 14px 14px;
      border-top:1px solid var(--border);
      background:linear-gradient(180deg, rgba(0,0,0,.08), rgba(0,0,0,.02));
    }
    .controls h3{
      margin:0 0 8px;
      font-size:13px;
      color:var(--muted);
      letter-spacing:.25px;
    }
    .ctrlRow{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
      margin:10px 0;
    }
    label{
      font-size:13px;
      color:var(--text);
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .pillVal{
      font-family:var(--mono);
      font-size:12px;
      padding:6px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      color:var(--muted);
      min-width:86px;
      text-align:right;
    }
    .btnRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    button{
      cursor:pointer;
      border:1px solid var(--border);
      color:var(--text);
      background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      padding:9px 10px;
      border-radius:12px;
      font-size:12.5px;
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
    }
    button:hover{
      transform: translateY(-1px);
      border-color: rgba(122,167,255,.35);
      background:linear-gradient(180deg, rgba(122,167,255,.16), rgba(255,255,255,.03));
    }
    .content{
      display:flex;
      flex-direction:column;
      gap:16px;
    }
    section, article{
      border:1px solid var(--border);
      border-radius:18px;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .secHead{
      padding:14px 16px;
      border-bottom:1px solid var(--border);
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:flex-start;
      background:linear-gradient(180deg, rgba(0,0,0,.06), rgba(0,0,0,0));
    }
    .secHead h2{
      margin:0;
      font-size:16px;
      letter-spacing:.2px;
    }
    .secBody{
      padding:14px 16px 16px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:14px;
    }
    @media (max-width: 980px){
      .grid2{grid-template-columns:1fr}
      aside{position:relative; top:0}
    }
    .callout{
      border:1px solid var(--border);
      border-radius:16px;
      padding:12px 12px;
      background:linear-gradient(180deg, rgba(122,167,255,.10), rgba(255,255,255,.02));
    }
    .callout.warn{
      background:linear-gradient(180deg, rgba(255,204,102,.15), rgba(255,255,255,.02));
    }
    .callout.ok{
      background:linear-gradient(180deg, rgba(139,255,139,.12), rgba(255,255,255,.02));
    }
    .callout h3{
      margin:0 0 6px;
      font-size:13.5px;
      letter-spacing:.2px;
      color:var(--text);
    }
    .callout ul{margin:8px 0 0 18px;color:var(--muted)}
    .eqBox{
      border:1px dashed rgba(122,167,255,.35);
      border-radius:16px;
      padding:12px;
      background:rgba(10,16,32,.55);
      overflow:auto;
    }
    .eq{
      font-family:var(--mono);
      font-size:13.5px;
      color:#eaf1ff;
      white-space:pre-wrap;
    }
    .copyBtn{
      float:right;
      margin-left:10px;
      font-size:12px;
      padding:7px 9px;
      border-radius:12px;
      border:1px solid rgba(122,167,255,.35);
      background:rgba(122,167,255,.10);
    }
    .copyBtn:active{transform:translateY(0)}
    .mini{
      color:var(--muted);
      font-size:13.5px;
    }
    .twoCols{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 720px){
      .twoCols{grid-template-columns:1fr}
    }
    figure{
      margin:0;
      padding:12px 12px 14px;
    }
    figcaption{
      margin-top:10px;
      color:var(--muted);
      font-size:13px;
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    }
    .canvasTall{height:360px}
    .canvasShort{height:300px}

    .badgeRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:8px;
    }
    .badge{
      font-family:var(--mono);
      font-size:12px;
      padding:6px 9px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      color:var(--muted);
    }

    footer{
      max-width:1200px;
      margin:18px auto 0;
      padding:0 18px 28px;
      color:var(--muted);
      font-size:13px;
    }

    @media print{
      body{background:white;color:#111}
      header, main, footer{max-width:100%}
      aside{display:none}
      section, article{box-shadow:none;background:white;border:1px solid #ddd}
      canvas{border:1px solid #ddd}
      .copyBtn{display:none}
    }

    /* subtle animation */
    .fadeIn{
      animation: fadeIn .35s ease both;
    }
    @keyframes fadeIn{
      from{opacity:0; transform: translateY(4px)}
      to{opacity:1; transform: translateY(0)}
    }
  </style>
</head>
<body>
<header class="fadeIn">
  <div class="kicker"><span class="dot"></span><span>Quantum/Statistical Optics • Beam Splitters • Photon-Number Statistics</span></div>
  <h1>Random Partitioning of Single-Mode Thermal Light</h1>
  <p class="sub">
    We analyze how a <b>lossless beam splitter</b> (or any random partitioning process) “thins” an incoming photon stream.
    For <b>single-mode thermal light</b>, the photon-number distribution keeps its <b>Bose–Einstein (geometric)</b> form—only the mean changes.
    We then compute the reflected mean photon number and prove the thermal-light <b>SNR</b> formula shown as Eq. (13.2-35) in your excerpt.
  </p>
</header>

<main class="fadeIn">
  <aside>
    <div class="tocHead">
      <strong>Table of Contents</strong>
      <span>sticky nav</span>
    </div>
    <nav class="toc" id="toc">
      <a href="#quick">Quick Summary</a>
      <a href="#part0">PART 0 — Concept Primer</a>
      <a href="#part1">PART 1 — Problem Analysis</a>
      <a href="#part2">PART 2 — Strategy & Tips</a>
      <a href="#part3">PART 3 — Full Solution</a>
      <a href="#part4">PART 4 — Deeper Understanding</a>
      <a href="#part5">PART 5 — Visualization Guide</a>
      <a href="#viz">Interactive Visualizations</a>
    </nav>

    <div class="controls">
      <h3>Interactive Controls (update all plots)</h3>

      <div class="ctrlRow">
        <div>
          <label for="tau">Beam-splitter transmittance &tau; (dimensionless)</label>
          <input id="tau" type="range" min="0" max="1" step="0.001" value="0.60"/>
        </div>
        <div class="pillVal" id="tauVal">τ = 0.600</div>
      </div>

      <div class="ctrlRow">
        <div>
          <label for="nbar">Input thermal mean photon number n&#772; (dimensionless)</label>
          <input id="nbar" type="range" min="0.05" max="20" step="0.05" value="5.00"/>
        </div>
        <div class="pillVal" id="nbarVal">n̄ = 5.00</div>
      </div>

      <div class="btnRow">
        <button id="presetLow">Preset: dim (n̄=0.5)</button>
        <button id="presetMid">Preset: moderate (n̄=5)</button>
        <button id="presetHigh">Preset: bright (n̄=15)</button>
      </div>

      <div class="badgeRow">
        <span class="badge" id="muT">μ<sub>T</sub>=τn̄</span>
        <span class="badge" id="muR">μ<sub>R</sub>=(1−τ)n̄</span>
        <span class="badge" id="snrTherm">SNR<sub>th</sub>=…</span>
      </div>
    </div>
  </aside>

  <div class="content">

    <section id="quick">
      <div class="secHead">
        <h2>Quick Summary</h2>
      </div>
      <div class="secBody">
        <ul class="mini">
          <li><b>What this is about:</b> A lossless beam splitter randomly partitions an input photon number <span class="eq">n</span> into transmitted counts <span class="eq">m</span> (and reflected <span class="eq">r=n-m</span>).</li>
          <li><b>Key physics idea:</b> Conditional on <span class="eq">n</span>, the partition is <b>binomial</b>; unconditional statistics follow by averaging over <span class="eq">p₀(n)</span>.</li>
          <li><b>Governing equation (random partitioning):</b> <span class="eq">p(m)=∑_{n=m}^∞ C(n,m) τ^m (1−τ)^{n-m} p₀(n)</span> (Eq. 13.2-33).</li>
          <li><b>Thermal input:</b> single-mode thermal light has Bose–Einstein (geometric) distribution <span class="eq">p₀(n)= (n̄^n)/(1+n̄)^{n+1}</span>.</li>
          <li><b>Main result (a):</b> After partitioning, <span class="eq">p(m)</span> is again Bose–Einstein with mean <span class="eq">μ=τ n̄</span> (same functional form, reduced mean).</li>
          <li><b>Main result (b):</b> Reflected mean photon number is <span class="eq">⟨r⟩=(1−τ) n̄</span>.</li>
          <li><b>Main result (c):</b> With SNR defined as <span class="eq">SNR = ⟨m⟩² / Var(m)</span>, thermal light gives <span class="eq">SNR_th = (τ n̄)/(τ n̄ + 1)</span> (Eq. 13.2-35).</li>
        </ul>
      </div>
    </section>

    <article id="part0">
      <div class="secHead">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>
      </div>
      <div class="secBody">
        <div class="grid2">
          <div>
            <h3 style="margin:0 0 8px;font-size:14.5px;">Core definitions (symbols & meaning)</h3>
            <ul class="mini">
              <li><span class="eq">n</span>: photon number in the <b>input</b> single optical mode (dimensionless count).</li>
              <li><span class="eq">m</span>: photon number in the <b>transmitted</b> output mode (dimensionless count).</li>
              <li><span class="eq">r</span>: photon number in the <b>reflected</b> output mode; for lossless splitting <span class="eq">r = n − m</span>.</li>
              <li><span class="eq">τ</span>: beam-splitter <b>intensity transmittance</b> (0 to 1). Reflection is <span class="eq">1−τ</span>.</li>
              <li><span class="eq">p₀(n)</span>: input photon-number distribution.</li>
              <li><span class="eq">p(m)</span>: transmitted photon-number distribution after random partitioning.</li>
              <li><span class="eq">n̄</span>: mean photon number of input thermal light (dimensionless).</li>
            </ul>

            <div class="callout ok" style="margin-top:12px;">
              <h3>Physical meaning: “random partitioning”</h3>
              <div class="mini">
                For each incoming photon, the beam splitter routes it to transmission with probability <span class="eq">τ</span>
                and to reflection with probability <span class="eq">1−τ</span>.
                Given an input Fock state <span class="eq">|n⟩</span>, the output photon number in one arm is therefore <b>binomially distributed</b>.
              </div>
            </div>

            <div class="callout" style="margin-top:12px;">
              <h3>Key law/principle used</h3>
              <div class="mini">
                <b>Law of total probability</b>:
                you compute the unconditional distribution by averaging the conditional binomial splitting over the input <span class="eq">p₀(n)</span>.
                This is exactly Eq. (13.2-33).
              </div>
            </div>
          </div>

          <div>
            <div class="callout warn">
              <h3>Assumptions / validity</h3>
              <ul>
                <li><b>Lossless, linear</b> beam splitter (no absorption).</li>
                <li><b>Single mode</b> thermal light (one spatial/polarization/frequency mode).</li>
                <li>Ideal partitioning: each photon is routed independently with probability <span class="eq">τ</span>.</li>
                <li>No detector saturation; counting statistics are well-defined.</li>
              </ul>
            </div>

            <h3 style="margin:12px 0 8px;font-size:14.5px;">Common models/approximations</h3>
            <ul class="mini">
              <li><b>Binomial thinning</b> model: <span class="eq">m|n ~ Binomial(n,τ)</span>.</li>
              <li><b>Thermal (Bose–Einstein)</b> photon statistics: geometric distribution determined by <span class="eq">n̄</span>.</li>
              <li><b>Generating functions</b> are often the cleanest algebraic tool.</li>
            </ul>

            <div class="callout" style="margin-top:12px;">
              <h3>Mini intuition examples</h3>
              <ul>
                <li>If the input is a fixed-number state <span class="eq">n</span>, the transmitted counts fluctuate binomially (pure “splitting noise”).</li>
                <li>If the input already fluctuates (thermal light), the output inherits both input fluctuations <i>and</i> splitting noise—but remarkably keeps the same geometric form.</li>
              </ul>
            </div>

            <div class="callout warn" style="margin-top:12px;">
              <h3>What to watch for (pitfalls)</h3>
              <ul>
                <li>Mixing up <span class="eq">τ</span> (intensity transmittance) with amplitude coefficients.</li>
                <li>For thermal light, variance is <span class="eq">Var(n)=n̄(n̄+1)</span> (larger than Poisson).</li>
                <li>Be explicit about the SNR definition (here: <span class="eq">⟨m⟩²/Var(m)</span>).</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </article>

    <article id="part1">
      <div class="secHead">
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>
      </div>
      <div class="secBody">
        <p class="mini">
          <b>Restate the problem:</b> A single-mode thermal field with photon-number distribution <span class="eq">p₀(n)</span> is sent onto a lossless beam splitter of transmittance <span class="eq">τ</span>.
          The splitter randomly partitions photons into transmitted and reflected outputs.
        </p>

        <div class="twoCols">
          <div class="callout">
            <h3>Given</h3>
            <ul class="mini">
              <li>Random partitioning formula (Eq. 13.2-33): <span class="eq">p(m)=∑_{n=m}^∞ C(n,m) τ^m (1−τ)^{n-m} p₀(n)</span>.</li>
              <li>Input is <b>single-mode thermal</b> (Bose–Einstein) with mean <span class="eq">n̄</span>.</li>
              <li>Lossless beam splitter, reflection probability <span class="eq">1−τ</span>.</li>
            </ul>
          </div>

          <div class="callout">
            <h3>Unknowns / to show</h3>
            <ul class="mini">
              <li>(a) Show <span class="eq">p(m)</span> is again Bose–Einstein (geometric) in <span class="eq">m</span>.</li>
              <li>(b) Show reflected mean photon number <span class="eq">⟨r⟩=(1−τ)n̄</span>.</li>
              <li>(c) Prove Eq. (13.2-35): thermal-light SNR after partitioning.</li>
            </ul>
          </div>
        </div>

        <p class="mini" style="margin-top:10px;">
          <b>Relevant principles & why they apply:</b> The beam splitter is linear and lossless, so photon routing is purely probabilistic
          (binomial conditional on <span class="eq">n</span>). The unconditional statistics follow by averaging (law of total probability). For thermal light, it is natural to use generating functions
          because the Bose–Einstein distribution has a simple power-series form.
        </p>

        <div class="callout warn">
          <h3>Assumptions (explicit)</h3>
          <ul class="mini">
            <li>Single-mode thermal state: diagonal in Fock basis with Bose–Einstein photon statistics.</li>
            <li>Ideal splitter: independent routing of each photon with probabilities <span class="eq">τ</span> and <span class="eq">1−τ</span>.</li>
            <li>No losses aside from splitting (so transmitted + reflected equals input photon number per event).</li>
          </ul>
        </div>

        <h3 style="margin:12px 0 6px;font-size:14.5px;">Possible approaches (compare)</h3>
        <ul class="mini">
          <li><b>Direct summation</b> of Eq. (13.2-33) using combinatorial identities (works well for geometric distributions).</li>
          <li><b>Probability generating function (PGF)</b>: use composition property of binomial thinning; typically the cleanest and most general.</li>
          <li><b>Moment method</b> for (b) and (c): compute <span class="eq">⟨m⟩</span> and <span class="eq">Var(m)</span> using conditional expectation/variance formulas.</li>
        </ul>
        <p class="mini">
          <b>Best choice:</b> Use the <b>PGF</b> (or an equivalent summation) for (a) because it exposes why the Bose–Einstein family is closed under thinning.
          Then use <b>moments</b> for (b) and (c), because SNR depends only on mean and variance.
        </p>
      </div>
    </article>

    <article id="part2">
      <div class="secHead">
        <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>
      </div>
      <div class="secBody">
        <ol class="mini" style="margin:0 0 0 18px;">
          <li><b>Write the thermal distribution</b> <span class="eq">p₀(n)</span> in terms of <span class="eq">n̄</span>. <i>Tool:</i> Bose–Einstein formula. <i>Meaning:</i> fixes all moments.</li>
          <li><b>Introduce the PGF</b> <span class="eq">G₀(z)=∑ p₀(n) z^n</span>. <i>Tool:</i> power series. <i>Meaning:</i> encodes the full distribution.</li>
          <li><b>Use binomial-thinning composition</b>: for transmitted counts, <span class="eq">G(z)=G₀((1−τ)+τ z)</span>. <i>Tool:</i> sum over binomial conditional distribution. <i>Meaning:</i> “replace” each photon by a Bernoulli route.</li>
          <li><b>Recognize the resulting PGF</b> as Bose–Einstein with mean <span class="eq">τ n̄</span>. <i>Meaning:</i> proves (a).</li>
          <li><b>Compute ⟨m⟩ and ⟨r⟩</b> by conditional expectation: <span class="eq">⟨m|n⟩=τ n</span>, <span class="eq">⟨r|n⟩=(1−τ)n</span>. <i>Meaning:</i> proves (b) quickly.</li>
          <li><b>Compute Var(m)</b> using law of total variance:
              <span class="eq">Var(m)=E[Var(m|n)] + Var(E[m|n])</span>. <i>Meaning:</i> separates splitting noise from input noise.</li>
          <li><b>Insert thermal moments</b> <span class="eq">E[n]=n̄</span>, <span class="eq">Var(n)=n̄(n̄+1)</span> to simplify.</li>
          <li><b>Form SNR</b> using the definition in the excerpt:
              <span class="eq">SNR = ⟨m⟩² / Var(m)</span>. <i>Meaning:</i> yields Eq. (13.2-35).</li>
        </ol>

        <div class="callout warn" style="margin-top:12px;">
          <h3>Common mistakes & quick tips</h3>
          <ul class="mini">
            <li>Don’t assume Poisson variance for thermal light; use <span class="eq">Var(n)=n̄(n̄+1)</span>.</li>
            <li>Keep <span class="eq">τ</span> between 0 and 1; check limiting cases <span class="eq">τ→0</span> and <span class="eq">τ→1</span>.</li>
            <li>Be explicit about which output you mean (transmitted vs reflected). They are symmetric under <span class="eq">τ ↔ 1−τ</span>.</li>
          </ul>
        </div>
      </div>
    </article>

    <article id="part3">
      <div class="secHead">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>
      </div>
      <div class="secBody">
        <div class="callout ok">
          <h3>Physical intuition (before math)</h3>
          <div class="mini">
            A thermal state is “highly bunched”: it has large photon-number fluctuations.
            A beam splitter does not “create coherence”; it just randomly routes photons.
            So we expect the output to remain thermal-like (bunched), but with a reduced mean proportional to how much power we transmit (<span class="eq">τ</span>) or reflect (<span class="eq">1−τ</span>).
          </div>
        </div>

        <h3 style="margin:12px 0 6px;font-size:14.5px;">(a) Bose–Einstein form is preserved under random partitioning</h3>

        <p class="mini">
          <b>Step 1: Write the single-mode thermal (Bose–Einstein) photon-number distribution.</b><br/>
          For mean photon number <span class="eq">n̄</span>, the thermal distribution is
        </p>

        <div class="eqBox">
          <button class="copyBtn" data-copy="p0(n) = (nbar^n) / (1+nbar)^(n+1),  n = 0,1,2,...">Copy</button>
          <div class="eq">
p₀(n) = (n̄^n) / (1 + n̄)^(n+1),   n = 0,1,2,...
          </div>
        </div>

        <p class="mini">
          This is a geometric distribution in <span class="eq">n</span>. It satisfies <span class="eq">∑ p₀(n)=1</span>, <span class="eq">⟨n⟩=n̄</span>, and <span class="eq">Var(n)=n̄(n̄+1)</span>.
        </p>

        <p class="mini">
          <b>Step 2: Use the random partitioning law (Eq. 13.2-33).</b><br/>
          Conditional on input <span class="eq">n</span>, the number transmitted is binomial:
          <span class="eq">P(m|n)=C(n,m) τ^m (1−τ)^{n−m}</span>. Averaging over <span class="eq">p₀(n)</span> gives
        </p>

        <div class="eqBox">
          <button class="copyBtn" data-copy="p(m) = sum_{n=m}^∞ C(n,m) τ^m (1-τ)^(n-m) p0(n)">Copy</button>
          <div class="eq">
p(m) = ∑_{n=m}^∞ C(n,m) τ^m (1−τ)^(n−m) p₀(n).   (13.2-33)
          </div>
        </div>

        <p class="mini">
          <b>Step 3: Evaluate the sum using a standard binomial-series identity.</b><br/>
          Insert <span class="eq">p₀(n)= (1/(1+n̄)) (n̄/(1+n̄))^n</span> into Eq. (13.2-33):
        </p>

        <div class="eqBox">
          <button class="copyBtn" data-copy="p(m) = (1/(1+nbar)) * τ^m * (nbar/(1+nbar))^m * sum_{k=0}^∞ C(m+k,m) [ (1-τ) * nbar/(1+nbar) ]^k">Copy</button>
          <div class="eq">
Let n = m + k (k = 0,1,2,...). Then

p(m) = ∑_{k=0}^∞ C(m+k,m) τ^m (1−τ)^k * (1/(1+n̄)) * (n̄/(1+n̄))^(m+k)

     = (1/(1+n̄)) * [τ n̄/(1+n̄)]^m * ∑_{k=0}^∞ C(m+k,m) [ (1−τ) n̄/(1+n̄) ]^k .
          </div>
        </div>

        <p class="mini">
          Now use the identity (valid for <span class="eq">|x|&lt;1</span>):
          <span class="eq">∑_{k=0}^∞ C(m+k,m) x^k = 1/(1−x)^{m+1}</span>.
          Here <span class="eq">x = (1−τ) n̄/(1+n̄)</span>, which is indeed &lt;1 for <span class="eq">τ∈[0,1]</span>, <span class="eq">n̄≥0</span>.
        </p>

        <p class="mini">
          <b>Step 4: Simplify to reveal Bose–Einstein form.</b><br/>
          Compute
          <span class="eq">1−x = 1 − (1−τ)n̄/(1+n̄) = (1 + τ n̄)/(1+n̄)</span>.
          Therefore,
          <span class="eq">1/(1−x)^{m+1} = ((1+n̄)/(1+τ n̄))^{m+1}</span>.
          Substituting gives
        </p>

        <div class="eqBox">
          <button class="copyBtn" data-copy="p(m) = ( (τ nbar)^m ) / (1 + τ nbar)^(m+1),  m=0,1,2,...">Copy</button>
          <div class="eq">
p(m) = (1/(1+n̄)) * [τ n̄/(1+n̄)]^m * ((1+n̄)/(1+τ n̄))^(m+1)

     = ( (τ n̄)^m ) / (1 + τ n̄)^(m+1),   m=0,1,2,...
          </div>
        </div>

        <div class="callout ok" style="margin-top:12px;">
          <h3>Result (a) — boxed</h3>
          <div class="eq" style="font-size:14px;">
            p(m) = ( (τ n̄)^m ) / (1 + τ n̄)^(m+1)  &nbsp; (Bose–Einstein / geometric form with mean μ=τn̄).
          </div>
          <div class="mini" style="margin-top:6px;">
            So the transmitted arm is thermal with a reduced mean photon number <span class="eq">μ=τ n̄</span>. (Likewise the reflected arm has mean <span class="eq">(1−τ)n̄</span>.)
          </div>
        </div>

        <h3 style="margin:14px 0 6px;font-size:14.5px;">(b) Mean photon number in the reflected arm</h3>

        <p class="mini">
          Let <span class="eq">r</span> be the reflected photon number. Conditioned on input <span class="eq">n</span>, reflection is also binomial:
          <span class="eq">r|n ~ Binomial(n, 1−τ)</span>, so
          <span class="eq">⟨r|n⟩ = (1−τ)n</span>.
          Taking expectation over the input distribution:
        </p>

        <div class="eqBox">
          <button class="copyBtn" data-copy="<r> = (1-τ) <n> = (1-τ) nbar">Copy</button>
          <div class="eq">
⟨r⟩ = E[ ⟨r|n⟩ ] = E[ (1−τ)n ] = (1−τ) E[n] = (1−τ) n̄.
          </div>
        </div>

        <div class="callout ok" style="margin-top:12px;">
          <h3>Result (b) — boxed</h3>
          <div class="eq" style="font-size:14px;">⟨r⟩ = (1 − τ) n̄.</div>
        </div>

        <h3 style="margin:14px 0 6px;font-size:14.5px;">(c) Prove Eq. (13.2-35): SNR for partitioned single-mode thermal light</h3>

        <p class="mini">
          The excerpt’s SNR values imply the definition
          <span class="eq">SNR = ⟨m⟩² / Var(m)</span>
          (because for Poisson, <span class="eq">Var(m)=⟨m⟩</span> giving <span class="eq">SNR=⟨m⟩</span>, which matches Eq. 13.2-34).
          We will compute <span class="eq">⟨m⟩</span> and <span class="eq">Var(m)</span> for thermal input.
        </p>

        <div class="callout">
          <h3>Tool: law of total expectation and total variance</h3>
          <div class="eq" style="margin-top:6px;">
E[m] = E( E[m|n] ) <br/>
Var(m) = E( Var(m|n) ) + Var( E[m|n] ).
          </div>
        </div>

        <p class="mini" style="margin-top:10px;">
          <b>Step 1: Conditional moments for binomial splitting.</b><br/>
          Given <span class="eq">n</span>, we have <span class="eq">m|n ~ Binomial(n,τ)</span>, hence
          <span class="eq">E[m|n]=τn</span> and <span class="eq">Var(m|n)=nτ(1−τ)</span>.
        </p>

        <p class="mini">
          <b>Step 2: Unconditional mean.</b><br/>
          Using <span class="eq">E[n]=n̄</span> for thermal light:
        </p>

        <div class="eqBox">
          <button class="copyBtn" data-copy="<m> = τ nbar">Copy</button>
          <div class="eq">
⟨m⟩ = E( E[m|n] ) = E( τ n ) = τ E[n] = τ n̄.
          </div>
        </div>

        <p class="mini">
          <b>Step 3: Unconditional variance.</b><br/>
          Apply total variance:
        </p>

        <div class="eqBox">
          <button class="copyBtn" data-copy="Var(m) = E[n τ(1-τ)] + Var(τ n) = τ(1-τ) nbar + τ^2 Var(n)">Copy</button>
          <div class="eq">
Var(m) = E(Var(m|n)) + Var(E[m|n])
       = E( n τ(1−τ) ) + Var( τ n )
       = τ(1−τ) E[n] + τ² Var(n).
          </div>
        </div>

        <p class="mini">
          For single-mode thermal light, <span class="eq">Var(n)=n̄(n̄+1)</span>. Substitute:
        </p>

        <div class="eqBox">
          <button class="copyBtn" data-copy="Var(m) = τ(1-τ) nbar + τ^2 nbar(nbar+1) = τ nbar (1 + τ nbar)">Copy</button>
          <div class="eq">
Var(m) = τ(1−τ) n̄ + τ² n̄(n̄+1)
       = τ n̄ [ (1−τ) + τ(n̄+1) ]
       = τ n̄ [ 1 + τ n̄ ].
          </div>
        </div>

        <p class="mini">
          <b>Step 4: Form the SNR.</b>
        </p>

        <div class="eqBox">
          <button class="copyBtn" data-copy="SNR_th = <m>^2 / Var(m) = (τ nbar)^2 / [τ nbar (1 + τ nbar)] = (τ nbar)/(1 + τ nbar)">Copy</button>
          <div class="eq">
SNR_th = ⟨m⟩² / Var(m)
       = (τ n̄)² / [ τ n̄ (1 + τ n̄) ]
       = (τ n̄) / (1 + τ n̄).
          </div>
        </div>

        <div class="callout ok" style="margin-top:12px;">
          <h3>Result (c) — boxed (Eq. 13.2-35)</h3>
          <div class="eq" style="font-size:14px;">
            SNR<sub>thermal</sub> = (τ n̄) / (τ n̄ + 1).
          </div>
        </div>

        <h3 style="margin:14px 0 6px;font-size:14.5px;">Sanity checks</h3>
        <ul class="mini">
          <li><b>Units:</b> photon numbers are dimensionless; SNR is dimensionless. ✔</li>
          <li><b>Limit τ→0:</b> ⟨m⟩→0, SNR→0. ✔</li>
          <li><b>Limit τ→1:</b> SNR→ n̄/(n̄+1), the known thermal SNR for the full beam. ✔</li>
          <li><b>Bright limit τn̄≫1:</b> SNR_th→1 (thermal noise dominates so intensity measurement never becomes “very high SNR”). ✔</li>
          <li><b>Connection to (a):</b> Since (a) showed the output remains thermal with mean μ=τn̄, you can also get
              <span class="eq">Var(m)=μ(μ+1)</span> and hence <span class="eq">SNR=μ²/[μ(μ+1)] = μ/(μ+1)</span>. Same result. ✔</li>
        </ul>

        <p class="mini">
          <b>Diagram/plots connection:</b> The diagram below shows the input thermal mode split into transmitted and reflected outputs.
          The distribution plot confirms the Bose–Einstein shape is preserved, only the mean rescales by <span class="eq">τ</span> or <span class="eq">1−τ</span>.
          The SNR plot shows why thermal light saturates at SNR ≈ 1 at high brightness, unlike coherent light.
        </p>

        <div class="eqBox" style="margin-top:12px;">
          <button class="copyBtn" data-copy="Final results:\n(a) p(m) = ((τ n̄)^m)/(1+τ n̄)^(m+1) (thermal form preserved)\n(b) <r> = (1-τ) n̄\n(c) SNR_th = (τ n̄)/(1+τ n̄) with SNR = <m>^2/Var(m)">Copy final answer</button>
          <div class="eq">
FINAL RESULTS (plain text)
(a) p(m) = ((τ n̄)^m)/(1+τ n̄)^(m+1)  (thermal/Bose–Einstein form preserved; mean μ=τ n̄)
(b) ⟨r⟩ = (1−τ) n̄
(c) SNR_th = (τ n̄)/(1+τ n̄), using SNR = ⟨m⟩² / Var(m)
          </div>
        </div>
      </div>
    </article>

    <article id="part4">
      <div class="secHead">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>
      </div>
      <div class="secBody">
        <div class="grid2">
          <div>
            <h3 style="margin:0 0 8px;font-size:14.5px;">Interpret the formulas</h3>
            <ul class="mini">
              <li><b>Closure under thinning:</b> Thermal (geometric) distributions are “stable” under binomial thinning, just like Poisson distributions are.</li>
              <li><b>Parameter control:</b> The only change is the mean photon number: <span class="eq">n̄ → τ n̄</span> (transmission) and <span class="eq">n̄ → (1−τ)n̄</span> (reflection).</li>
              <li><b>Noise structure:</b> <span class="eq">Var(m)=τ n̄(1+τ n̄)</span> has a linear term (splitting noise) and a quadratic term (thermal excess noise).</li>
              <li><b>SNR saturation:</b> <span class="eq">SNR_th = μ/(1+μ)</span> approaches 1 even for huge μ—thermal intensity fluctuations scale strongly with mean.</li>
            </ul>

            <div class="callout" style="margin-top:12px;">
              <h3>Alternative derivation idea (brief)</h3>
              <div class="mini">
                Use the <b>probability generating function</b> (PGF).
                For binomial thinning, <span class="eq">G(z)=G₀((1−τ)+τz)</span>.
                The thermal PGF is <span class="eq">G₀(z)=1/(1+n̄(1−z))</span>.
                Substituting gives <span class="eq">G(z)=1/(1+τn̄(1−z))</span>, which is again thermal with mean <span class="eq">τn̄</span>.
              </div>
            </div>
          </div>

          <div>
            <div class="callout ok">
              <h3>Concept checks (self-test, with answers)</h3>
              <ul class="mini">
                <li><b>Q:</b> If the input is thermal with mean 2 and τ=0.25, what is the transmitted mean? <b>A:</b> <span class="eq">μ=τn̄=0.5</span>.</li>
                <li><b>Q:</b> Does partitioning make thermal light Poisson? <b>A:</b> No; it stays Bose–Einstein (geometric), just with a smaller mean.</li>
                <li><b>Q:</b> Why doesn’t SNR grow without bound for thermal light at high power? <b>A:</b> Because <span class="eq">Var ∼ μ²</span> (excess noise), so <span class="eq">μ²/Var → 1</span>.</li>
                <li><b>Q:</b> What swaps if you analyze reflection instead of transmission? <b>A:</b> Replace <span class="eq">τ</span> by <span class="eq">1−τ</span>.</li>
              </ul>
            </div>

            <div class="callout warn" style="margin-top:12px;">
              <h3>Common mistakes (again, because they’re common)</h3>
              <ul class="mini">
                <li>Using <span class="eq">Var(n)=n̄</span> for thermal states (that’s Poisson/coherent).</li>
                <li>Forgetting the SNR definition used in the text (it is not always <span class="eq">mean/std</span>).</li>
                <li>Confusing photon-number statistics with field-amplitude statistics.</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </article>

    <article id="part5">
      <div class="secHead">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>
      </div>
      <div class="secBody">
        <ul class="mini">
          <li><b>Diagram canvas:</b> Shows an input single-mode thermal beam entering a lossless beam splitter. The outputs are labeled transmitted (T) and reflected (R), with probabilities <span class="eq">τ</span> and <span class="eq">1−τ</span>. The means <span class="eq">μ_T=τn̄</span> and <span class="eq">μ_R=(1−τ)n̄</span> update live.</li>
          <li><b>Main plot (SNR vs τ):</b> Curves for coherent and thermal light using the excerpt’s definition <span class="eq">SNR=⟨m⟩²/Var(m)</span>. At fixed <span class="eq">n̄</span>, increasing <span class="eq">τ</span> increases the coherent SNR linearly, while the thermal SNR saturates below 1.</li>
          <li><b>Secondary plot (photon-number distributions):</b> Plots <span class="eq">p(n)</span> for the input thermal light and <span class="eq">p(m)</span> for transmitted and reflected outputs. All are geometric; the outputs shift toward smaller means as <span class="eq">τ</span> changes.</li>
          <li><b>Interactive controls:</b> The <span class="eq">τ</span> slider changes the split ratio; the <span class="eq">n̄</span> slider changes brightness. Both update the diagram and <i>all</i> plots.</li>
        </ul>
      </div>
    </article>

    <section id="viz">
      <div class="secHead">
        <h2>Interactive Visualizations</h2>
      </div>
      <div class="secBody">
        <div class="twoCols">
          <figure>
            <canvas id="diagram" class="canvasShort" aria-label="Beam splitter diagram"></canvas>
            <figcaption>
              <b>Diagram:</b> Lossless beam splitter randomly partitions photons. Labels show <span class="eq">τ</span>, <span class="eq">1−τ</span>,
              and the output means <span class="eq">μ_T=τn̄</span>, <span class="eq">μ_R=(1−τ)n̄</span>.
            </figcaption>
          </figure>

          <figure>
            <canvas id="snrPlot" class="canvasShort" aria-label="SNR versus transmittance plot"></canvas>
            <figcaption>
              <b>Main plot:</b> SNR vs <span class="eq">τ</span> for coherent and thermal light (definition: <span class="eq">⟨m⟩²/Var(m)</span>).
              Coherent: <span class="eq">SNR=τn̄</span>. Thermal: <span class="eq">SNR=τn̄/(1+τn̄)</span>.
            </figcaption>
          </figure>
        </div>

        <figure style="margin-top:12px;">
          <canvas id="distPlot" class="canvasTall" aria-label="Photon number distribution plot"></canvas>
          <figcaption>
            <b>Secondary plot:</b> Bose–Einstein distributions (geometric) for input and partitioned outputs.
            The shape is preserved; only the mean changes.
          </figcaption>
        </figure>
      </div>
    </section>

  </div>
</main>

<footer class="fadeIn">
  <div>
    Notes: Symbols follow the excerpt: <span class="eq">τ</span> is intensity transmittance and <span class="eq">n̄</span> is the mean photon number of the input single-mode thermal state.
    Plots use “example values” provided by the sliders (since the original problem is symbolic).
  </div>
</footer>

<script>
(function(){
  // ---------- Helpers ----------
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

  function fmt(x, d=3){
    return (+x).toFixed(d);
  }

  function setupCanvas(canvas){
    const ctx = canvas.getContext('2d');
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(280, rect.width);
      const h = Math.max(240, rect.height);
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {w,h,dpr};
    }
    return {ctx, resize};
  }

  function roundNice(x){
    if(x<=0) return 1;
    const p = Math.pow(10, Math.floor(Math.log10(x)));
    const m = x/p;
    let n=1;
    if(m<1.5) n=1;
    else if(m<3.5) n=2;
    else if(m<7.5) n=5;
    else n=10;
    return n*p;
  }

  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, opts){
    const {x, y, w, h} = box;
    const padL = opts.padL ?? 54, padR = opts.padR ?? 18, padT = opts.padT ?? 32, padB = opts.padB ?? 44;
    const plot = {x:x+padL, y:y+padT, w:w-padL-padR, h:h-padT-padB};

    // background
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect(x,y,w,h);

    // title
    ctx.fillStyle = 'rgba(232,238,255,0.95)';
    ctx.font = '600 13.5px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(opts.title ?? '', x+14, y+20);

    // axis labels
    ctx.fillStyle = 'rgba(183,195,255,0.85)';
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(opts.xLabel ?? '', plot.x + plot.w/2 - 30, y + h - 14);
    ctx.save();
    ctx.translate(x+14, plot.y + plot.h/2 + 28);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(opts.yLabel ?? '', 0, 0);
    ctx.restore();

    // ticks
    const xSpan = xMax - xMin;
    const ySpan = yMax - yMin;
    const xStep = roundNice(xSpan / 5);
    const yStep = roundNice(ySpan / 5);

    const x0 = Math.ceil(xMin / xStep) * xStep;
    const y0 = Math.ceil(yMin / yStep) * yStep;

    // grid
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let xv=x0; xv<=xMax+1e-12; xv+=xStep){
      const xp = plot.x + (xv-xMin)/xSpan * plot.w;
      ctx.moveTo(xp, plot.y);
      ctx.lineTo(xp, plot.y+plot.h);
    }
    for(let yv=y0; yv<=yMax+1e-12; yv+=yStep){
      const yp = plot.y + plot.h - (yv-yMin)/ySpan * plot.h;
      ctx.moveTo(plot.x, yp);
      ctx.lineTo(plot.x+plot.w, yp);
    }
    ctx.stroke();

    // border
    ctx.strokeStyle = 'rgba(255,255,255,0.14)';
    ctx.strokeRect(plot.x, plot.y, plot.w, plot.h);

    // tick labels
    ctx.fillStyle = 'rgba(183,195,255,0.85)';
    ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    for(let xv=x0; xv<=xMax+1e-12; xv+=xStep){
      const xp = plot.x + (xv-xMin)/xSpan * plot.w;
      ctx.fillText((Math.abs(xStep)>=1? xv.toFixed(2): xv.toFixed(3)), xp-12, plot.y+plot.h+16);
      ctx.beginPath();
      ctx.moveTo(xp, plot.y+plot.h);
      ctx.lineTo(xp, plot.y+plot.h+5);
      ctx.strokeStyle='rgba(255,255,255,0.18)';
      ctx.stroke();
    }
    for(let yv=y0; yv<=yMax+1e-12; yv+=yStep){
      const yp = plot.y + plot.h - (yv-yMin)/ySpan * plot.h;
      ctx.fillText((Math.abs(yStep)>=1? yv.toFixed(2): yv.toFixed(3)), plot.x-46, yp+4);
      ctx.beginPath();
      ctx.moveTo(plot.x-5, yp);
      ctx.lineTo(plot.x, yp);
      ctx.strokeStyle='rgba(255,255,255,0.18)';
      ctx.stroke();
    }

    ctx.restore();

    // mapping functions
    const X = (xv)=> plot.x + (xv-xMin)/xSpan * plot.w;
    const Y = (yv)=> plot.y + plot.h - (yv-yMin)/ySpan * plot.h;

    return {plot, X, Y};
  }

  function drawLegend(ctx, items, x, y){
    ctx.save();
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    let yy=y;
    items.forEach(it=>{
      ctx.fillStyle = it.color;
      ctx.fillRect(x, yy-9, 14, 3);
      ctx.fillStyle = 'rgba(232,238,255,0.92)';
      ctx.fillText(it.label, x+20, yy);
      yy += 16;
    });
    ctx.restore();
  }

  function linePlot(ctx, map, xs, ys, color){
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<xs.length;i++){
      const x = map.X(xs[i]);
      const y = map.Y(ys[i]);
      if(i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function pointsPlot(ctx, map, xs, ys, color){
    ctx.save();
    ctx.fillStyle = color;
    for(let i=0;i<xs.length;i++){
      const x = map.X(xs[i]);
      const y = map.Y(ys[i]);
      ctx.beginPath();
      ctx.arc(x,y,2.6,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  // Bose–Einstein (single-mode thermal) photon-number distribution with mean mu:
  // p(n) = mu^n / (1+mu)^(n+1)
  function pThermal(n, mu){
    if(mu<=0) return (n===0)? 1 : 0;
    return Math.pow(mu, n) / Math.pow(1+mu, n+1);
  }

  // ---------- State ----------
  const tauEl = document.getElementById('tau');
  const nbarEl = document.getElementById('nbar');
  const tauVal = document.getElementById('tauVal');
  const nbarVal = document.getElementById('nbarVal');
  const muT = document.getElementById('muT');
  const muR = document.getElementById('muR');
  const snrTherm = document.getElementById('snrTherm');

  const presetLow = document.getElementById('presetLow');
  const presetMid = document.getElementById('presetMid');
  const presetHigh = document.getElementById('presetHigh');

  const diag = setupCanvas(document.getElementById('diagram'));
  const snrC = setupCanvas(document.getElementById('snrPlot'));
  const distC = setupCanvas(document.getElementById('distPlot'));

  function getParams(){
    const tau = parseFloat(tauEl.value);
    const nbar = parseFloat(nbarEl.value);
    return {tau, nbar};
  }

  // ---------- Drawing ----------
  function drawDiagram({tau, nbar}){
    const {ctx} = diag;
    const {w,h} = diag.resize();
    ctx.clearRect(0,0,w,h);

    const margin=14;
    const x0=margin, y0=margin, W=w-2*margin, H=h-2*margin;

    // panel
    ctx.save();
    ctx.fillStyle='rgba(255,255,255,0.02)';
    ctx.fillRect(x0,y0,W,H);
    ctx.strokeStyle='rgba(255,255,255,0.14)';
    ctx.strokeRect(x0,y0,W,H);

    // title
    ctx.fillStyle='rgba(232,238,255,0.95)';
    ctx.font='600 13.5px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Beam Splitter: Random Partitioning', x0+12, y0+22);

    // geometry points
    const cx = x0 + W*0.55;
    const cy = y0 + H*0.55;
    const bsSize = Math.min(W,H)*0.18;

    // incoming beam arrow
    ctx.strokeStyle='rgba(122,167,255,0.95)';
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(x0+W*0.10, cy);
    ctx.lineTo(cx-bsSize*0.95, cy);
    ctx.stroke();
    // arrow head
    ctx.beginPath();
    ctx.moveTo(cx-bsSize*0.95, cy);
    ctx.lineTo(cx-bsSize*0.95-10, cy-6);
    ctx.lineTo(cx-bsSize*0.95-10, cy+6);
    ctx.closePath();
    ctx.fillStyle='rgba(122,167,255,0.95)';
    ctx.fill();

    // label input
    ctx.fillStyle='rgba(183,195,255,0.92)';
    ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Input single-mode thermal', x0+W*0.08, cy-14);
    ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText(`mean n̄ = ${fmt(nbar,2)}`, x0+W*0.08, cy+18);

    // beam splitter (a tilted square)
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(-Math.PI/4);
    ctx.fillStyle='rgba(255,255,255,0.06)';
    ctx.strokeStyle='rgba(255,255,255,0.22)';
    ctx.lineWidth=2;
    ctx.fillRect(-bsSize/2,-bsSize/2,bsSize,bsSize);
    ctx.strokeRect(-bsSize/2,-bsSize/2,bsSize,bsSize);
    // semi-reflective coating stripe
    ctx.strokeStyle='rgba(125,255,207,0.75)';
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(-bsSize/2, 0);
    ctx.lineTo(bsSize/2, 0);
    ctx.stroke();
    ctx.restore();

    // transmitted beam (right)
    ctx.strokeStyle='rgba(125,255,207,0.95)';
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(cx+bsSize*0.95, cy);
    ctx.lineTo(x0+W*0.92, cy);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x0+W*0.92, cy);
    ctx.lineTo(x0+W*0.92-10, cy-6);
    ctx.lineTo(x0+W*0.92-10, cy+6);
    ctx.closePath();
    ctx.fillStyle='rgba(125,255,207,0.95)';
    ctx.fill();

    // reflected beam (up)
    ctx.strokeStyle='rgba(255,204,102,0.95)';
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(cx, cy-bsSize*0.95);
    ctx.lineTo(cx, y0+H*0.12);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cx, y0+H*0.12);
    ctx.lineTo(cx-6, y0+H*0.12+10);
    ctx.lineTo(cx+6, y0+H*0.12+10);
    ctx.closePath();
    ctx.fillStyle='rgba(255,204,102,0.95)';
    ctx.fill();

    // labels T and R with tau and means
    const muTrans = tau*nbar;
    const muRefl = (1-tau)*nbar;

    ctx.fillStyle='rgba(232,238,255,0.95)';
    ctx.font='600 12.5px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Transmitted (T)', x0+W*0.68, cy-16);
    ctx.fillText('Reflected (R)', cx-44, y0+H*0.18);

    ctx.fillStyle='rgba(183,195,255,0.92)';
    ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText(`τ = ${fmt(tau,3)}`, x0+W*0.68, cy+6);
    ctx.fillText(`μ_T = τ n̄ = ${fmt(muTrans,2)}`, x0+W*0.68, cy+24);

    ctx.fillText(`1−τ = ${fmt(1-tau,3)}`, cx-70, y0+H*0.23);
    ctx.fillText(`μ_R = (1−τ) n̄ = ${fmt(muRefl,2)}`, cx-110, y0+H*0.23 + 18);

    // small note
    ctx.fillStyle='rgba(183,195,255,0.78)';
    ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Conditional on n:  m|n ~ Binomial(n, τ)', x0+12, y0+H-14);

    ctx.restore();
  }

  function drawSNR({tau, nbar}){
    const {ctx} = snrC;
    const {w,h} = snrC.resize();
    ctx.clearRect(0,0,w,h);

    // curves vs tau in [0,1]
    const xs = [];
    const ysCo = [];
    const ysTh = [];
    for(let i=0;i<=300;i++){
      const t = i/300;
      xs.push(t);
      const mu = t*nbar;
      ysCo.push(mu);                // coherent: SNR = <m> = τ n̄ (since Var=μ)
      ysTh.push(mu/(1+mu));         // thermal: SNR = μ/(1+μ) with μ=τ n̄
    }

    // y-range
    let yMax = Math.max(...ysCo, ...ysTh);
    yMax = Math.max(1, yMax);
    const map = drawAxes(ctx, {x:0,y:0,w,h}, 0, 1, 0, yMax*1.05, {
      title: 'SNR vs Transmittance τ (example n̄ from slider)',
      xLabel: 'τ (dimensionless)',
      yLabel: 'SNR = ⟨m⟩² / Var(m) (dimensionless)'
    });

    // plot
    linePlot(ctx, map, xs, ysCo, 'rgba(125,255,207,0.95)');
    linePlot(ctx, map, xs, ysTh, 'rgba(255,204,102,0.95)');

    // highlight current tau
    const mu = tau*nbar;
    const snrCo = mu;
    const snrTh = mu/(1+mu);

    ctx.save();
    ctx.strokeStyle='rgba(232,238,255,0.35)';
    ctx.lineWidth=1;
    ctx.setLineDash([5,5]);
    ctx.beginPath();
    ctx.moveTo(map.X(tau), map.plot.y);
    ctx.lineTo(map.X(tau), map.plot.y+map.plot.h);
    ctx.stroke();
    ctx.setLineDash([]);

    // points
    ctx.fillStyle='rgba(125,255,207,0.95)';
    ctx.beginPath(); ctx.arc(map.X(tau), map.Y(snrCo), 4,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='rgba(255,204,102,0.95)';
    ctx.beginPath(); ctx.arc(map.X(tau), map.Y(snrTh), 4,0,Math.PI*2); ctx.fill();

    // small annotation
    ctx.fillStyle='rgba(232,238,255,0.92)';
    ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText(`τ=${fmt(tau,3)},  μ=τn̄=${fmt(mu,2)}`, map.plot.x+10, map.plot.y+18);
    ctx.fillText(`SNR_coh=μ=${fmt(snrCo,2)}`, map.plot.x+10, map.plot.y+36);
    ctx.fillText(`SNR_th=μ/(1+μ)=${fmt(snrTh,3)}`, map.plot.x+10, map.plot.y+54);

    drawLegend(ctx, [
      {label:'coherent: SNR = τ n̄', color:'rgba(125,255,207,0.95)'},
      {label:'thermal: SNR = τ n̄ / (1+τ n̄)', color:'rgba(255,204,102,0.95)'}
    ], map.plot.x + map.plot.w - 230, map.plot.y + 18);

    ctx.restore();
  }

  function drawDistribution({tau, nbar}){
    const {ctx} = distC;
    const {w,h} = distC.resize();
    ctx.clearRect(0,0,w,h);

    const muIn = nbar;
    const muT = tau*nbar;
    const muR = (1-tau)*nbar;

    // choose max n for plotting: cover the largest mean with enough tail
    const muMax = Math.max(muIn, muT, muR);
    const nMax = Math.min(80, Math.max(25, Math.ceil(6*muMax + 12)));

    const xs = [];
    const pIn = [];
    const pT = [];
    const pR = [];
    for(let n=0;n<=nMax;n++){
      xs.push(n);
      pIn.push(pThermal(n, muIn));
      pT.push(pThermal(n, muT));
      pR.push(pThermal(n, muR));
    }

    const yMax = Math.max(...pIn, ...pT, ...pR) * 1.15;

    const map = drawAxes(ctx, {x:0,y:0,w,h}, 0, nMax, 0, yMax, {
      title: 'Photon-Number Distributions (Bose–Einstein / geometric)',
      xLabel: 'photon number k (dimensionless)',
      yLabel: 'probability p(k) (dimensionless)',
      padR: 22,
      padL: 62,
      padT: 32,
      padB: 46
    });

    // plot as lines + points
    linePlot(ctx, map, xs, pIn, 'rgba(122,167,255,0.95)');
    pointsPlot(ctx, map, xs, pIn, 'rgba(122,167,255,0.95)');

    linePlot(ctx, map, xs, pT, 'rgba(125,255,207,0.95)');
    pointsPlot(ctx, map, xs, pT, 'rgba(125,255,207,0.95)');

    linePlot(ctx, map, xs, pR, 'rgba(255,204,102,0.95)');
    pointsPlot(ctx, map, xs, pR, 'rgba(255,204,102,0.95)');

    drawLegend(ctx, [
      {label:`input thermal: n̄=${fmt(muIn,2)}`, color:'rgba(122,167,255,0.95)'},
      {label:`transmitted: μ=τn̄=${fmt(muT,2)}`, color:'rgba(125,255,207,0.95)'},
      {label:`reflected: μ=(1−τ)n̄=${fmt(muR,2)}`, color:'rgba(255,204,102,0.95)'}
    ], map.plot.x + map.plot.w - 260, map.plot.y + 18);

    // add formula text
    ctx.save();
    ctx.fillStyle='rgba(232,238,255,0.92)';
    ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText('p(k) = μ^k / (1+μ)^(k+1)', map.plot.x+10, map.plot.y+map.plot.h-10);
    ctx.restore();
  }

  function updateBadges({tau, nbar}){
    tauVal.textContent = `τ = ${fmt(tau,3)}`;
    nbarVal.textContent = `n̄ = ${fmt(nbar,2)}`;

    const muTrans = tau*nbar;
    const muRefl = (1-tau)*nbar;
    muT.innerHTML = `μ<sub>T</sub>=τn̄=${fmt(muTrans,2)}`;
    muR.innerHTML = `μ<sub>R</sub>=(1−τ)n̄=${fmt(muRefl,2)}`;

    const snr = (muTrans<=0)? 0 : (muTrans/(1+muTrans));
    snrTherm.innerHTML = `SNR<sub>th</sub>=${fmt(snr,3)}`;
  }

  function renderAll(){
    const p = getParams();
    updateBadges(p);
    drawDiagram(p);
    drawSNR(p);
    drawDistribution(p);
  }

  // ---------- Events ----------
  tauEl.addEventListener('input', renderAll);
  nbarEl.addEventListener('input', renderAll);

  presetLow.addEventListener('click', ()=>{
    nbarEl.value = '0.50';
    renderAll();
  });
  presetMid.addEventListener('click', ()=>{
    nbarEl.value = '5.00';
    renderAll();
  });
  presetHigh.addEventListener('click', ()=>{
    nbarEl.value = '15.00';
    renderAll();
  });

  // ResizeObserver for responsive canvases
  const ro = new ResizeObserver(()=>renderAll());
  ro.observe(document.getElementById('diagram'));
  ro.observe(document.getElementById('snrPlot'));
  ro.observe(document.getElementById('distPlot'));

  window.addEventListener('resize', renderAll);

  // Smooth scroll for TOC
  document.getElementById('toc').addEventListener('click', (e)=>{
    const a = e.target.closest('a');
    if(!a) return;
    const id = a.getAttribute('href');
    if(id && id.startsWith('#')){
      e.preventDefault();
      const el = document.querySelector(id);
      if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
    }
  });

  // Copy buttons
  async function copyText(text){
    try{
      await navigator.clipboard.writeText(text);
      return true;
    }catch(err){
      // fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.style.position='fixed';
      ta.style.left='-9999px';
      document.body.appendChild(ta);
      ta.select();
      try{
        document.execCommand('copy');
        document.body.removeChild(ta);
        return true;
      }catch(e){
        document.body.removeChild(ta);
        return false;
      }
    }
  }

  document.body.addEventListener('click', async (e)=>{
    const btn = e.target.closest('.copyBtn');
    if(!btn) return;
    const text = btn.getAttribute('data-copy') || '';
    const ok = await copyText(text);
    const old = btn.textContent;
    btn.textContent = ok ? 'Copied!' : 'Copy failed';
    setTimeout(()=>btn.textContent = old, 900);
  });

  // Initial render
  renderAll();
})();
</script>
</body>
</html>
