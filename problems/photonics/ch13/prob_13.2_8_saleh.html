<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Photon-Number Statistics of Multimode Thermal Light → Negative Binomial</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111936;
      --card2:#0f1731;
      --ink:#e9eefc;
      --muted:#b9c3e6;
      --faint:#7f8bb8;
      --accent:#7cf0c7;
      --accent2:#7aa7ff;
      --warn:#ffd37a;
      --danger:#ff7aa5;
      --border: rgba(255,255,255,.10);
      --shadow: 0 12px 40px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 800px at 10% 0%, rgba(122,167,255,.18), transparent 55%),
        radial-gradient(900px 650px at 90% 10%, rgba(124,240,199,.14), transparent 55%),
        radial-gradient(700px 500px at 50% 95%, rgba(255,122,165,.10), transparent 60%),
        var(--bg);
      color:var(--ink);
      line-height:1.55;
    }

    header{
      padding: 28px 18px 18px;
      position: relative;
      overflow:hidden;
    }

    .hero{
      max-width: 1200px;
      margin: 0 auto;
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:16px;
      align-items:stretch;
    }

    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 18px 16px;
      position:relative;
    }

    .titleCard h1{
      font-size: clamp(22px, 2.2vw, 34px);
      margin: 4px 0 8px;
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color: var(--muted);
      max-width: 72ch;
    }

    .metaRow{
      margin-top: 12px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      border:1px solid var(--border);
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(15,23,49,.55);
      color: var(--muted);
      font-size: 13px;
      user-select:none;
      backdrop-filter: blur(6px);
    }
    .dot{
      width:9px;height:9px;border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 16px rgba(124,240,199,.55);
    }

    .tocCard{
      background: rgba(17,25,54,.55);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
      position: sticky;
      top: 10px;
      align-self:start;
      max-height: calc(100vh - 20px);
      overflow:auto;
    }
    .tocCard h2{
      margin: 2px 0 8px;
      font-size: 14px;
      color: var(--muted);
      letter-spacing:.3px;
      text-transform: uppercase;
    }
    .tocCard a{
      display:block;
      padding: 7px 10px;
      border-radius: 10px;
      text-decoration:none;
      color: var(--ink);
      border:1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      font-size: 14px;
    }
    .tocCard a:hover{
      background: rgba(122,167,255,.10);
      border-color: rgba(122,167,255,.18);
      transform: translateX(2px);
    }

    main{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 18px 60px;
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:16px;
      align-items:start;
    }

    @media (max-width: 980px){
      .hero, main{grid-template-columns: 1fr}
      .tocCard{position:relative; top:0; max-height:none}
    }

    section{
      background: rgba(17,25,54,.55);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px;
      margin-bottom: 16px;
      position:relative;
      overflow:hidden;
    }

    section::before{
      content:"";
      position:absolute;
      inset:auto -20% 0 -20%;
      height:1px;
      background: linear-gradient(90deg, transparent, rgba(124,240,199,.40), transparent);
      opacity:.35;
    }

    h2{
      margin: 0 0 10px;
      font-size: 20px;
      letter-spacing:.2px;
    }
    h3{
      margin: 16px 0 8px;
      font-size: 16px;
      color: var(--muted);
    }

    p{margin: 8px 0; color: var(--ink)}
    ul{margin: 8px 0 8px 18px; color: var(--ink)}
    li{margin: 6px 0}

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 780px){
      .grid2{grid-template-columns: 1fr}
    }

    .callout{
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 12px 12px 10px;
      background: rgba(15,23,49,.55);
    }
    .callout strong{
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing:.35px;
      font-size: 12px;
    }
    .callout.assumptions strong{color: var(--warn)}
    .callout.mistakes strong{color: var(--danger)}
    .callout.key strong{color: var(--accent)}
    .callout.answer strong{color: var(--accent2)}

    .eqBox{
      margin-top: 8px;
      border:1px solid var(--border);
      border-radius: 16px;
      background: rgba(12,18,40,.65);
      padding: 10px 10px 8px;
      position:relative;
    }
    pre.eq{
      margin: 0;
      padding: 8px;
      overflow:auto;
      font-family: var(--mono);
      font-size: 13px;
      color: #eaf1ff;
      white-space: pre-wrap;
    }
    .copyBtn{
      position:absolute;
      top: 10px;
      right: 10px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--ink);
      padding: 6px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-size: 12px;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      user-select:none;
    }
    .copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(124,240,199,.10);
      border-color: rgba(124,240,199,.25);
    }
    .copyBtn:active{transform: translateY(0px) scale(.98)}
    .copied{
      outline: 2px solid rgba(124,240,199,.35);
      box-shadow: 0 0 0 6px rgba(124,240,199,.10);
    }

    .vizPanel{
      padding: 14px;
      background: rgba(15,23,49,.65);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      position: sticky;
      top: 10px;
      overflow:hidden;
    }
    @media (max-width: 980px){
      .vizPanel{position:relative; top:0}
    }
    .vizPanel h2{
      margin: 0 0 10px;
      font-size: 18px;
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 10px;
    }
    .control{
      border:1px solid var(--border);
      border-radius: 14px;
      padding: 10px 10px 8px;
      background: rgba(17,25,54,.55);
    }
    label{
      display:flex;
      justify-content: space-between;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
      user-select:none;
    }
    input[type="range"]{
      width:100%;
      margin-top: 8px;
    }
    .control .val{
      font-family: var(--mono);
      color: var(--ink);
      font-size: 12px;
      opacity:.95;
    }
    .row{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
      margin: 8px 0 2px;
    }
    .toggle{
      display:flex;
      align-items:center;
      gap:8px;
      font-size: 12px;
      color: var(--muted);
      user-select:none;
    }
    .toggle input{transform: translateY(1px)}
    .btn{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--ink);
      padding: 8px 10px;
      border-radius: 14px;
      cursor:pointer;
      font-size: 12px;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      user-select:none;
    }
    .btn:hover{
      transform: translateY(-1px);
      background: rgba(122,167,255,.10);
      border-color: rgba(122,167,255,.25);
    }

    canvas{
      width: 100%;
      height: 240px;
      display:block;
      border-radius: 16px;
      background: rgba(10,14,30,.55);
      border: 1px solid rgba(255,255,255,.10);
      margin-top: 10px;
    }
    .canvasTall{height: 280px}
    .canvasShort{height: 210px}

    .caption{
      margin-top: 8px;
      color: var(--faint);
      font-size: 12px;
    }

    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 0 18px 40px;
      color: var(--faint);
      font-size: 12px;
    }

    @media print{
      body{background:#fff; color:#000}
      header, .vizPanel, .tocCard{display:none !important}
      section{break-inside: avoid; box-shadow:none; border:1px solid #bbb; background:#fff}
      .eqBox{background:#fff}
      pre.eq{color:#000}
      a{color:#000}
    }

    /* subtle motion */
    @keyframes floatIn{
      from{opacity:0; transform: translateY(6px)}
      to{opacity:1; transform: translateY(0)}
    }
    section, .vizPanel, .titleCard, .tocCard{animation: floatIn .35s ease both}
  </style>
</head>
<body>
<header>
  <div class="hero">
    <div class="titleCard">
      <h1>Photon-Number Statistics for a Beam of Multimode Thermal Light</h1>
      <p class="subtitle">
        Using Mandel’s formula (a Poisson mixture over a fluctuating integrated rate) we show that
        a beam composed of <span style="color:var(--accent);font-weight:600">M identical thermal modes</span>
        yields a <span style="color:var(--accent2);font-weight:600">negative-binomial photon-number distribution</span>.
      </p>
      <div class="metaRow">
        <div class="pill"><span class="dot"></span> Poisson mixture (Mandel)</div>
        <div class="pill"><span class="dot" style="background:var(--accent2)"></span> Gamma-distributed rate</div>
        <div class="pill"><span class="dot" style="background:var(--warn)"></span> Multimode thermal → NB</div>
      </div>
    </div>

    <nav class="tocCard" aria-label="Table of Contents">
      <h2>Table of Contents</h2>
      <a href="#quick">Quick Summary</a>
      <a href="#part0">PART 0 — Concept Primer</a>
      <a href="#part1">PART 1 — Problem Analysis</a>
      <a href="#part2">PART 2 — Strategy & Tips</a>
      <a href="#part3">PART 3 — Full Solution</a>
      <a href="#part4">PART 4 — Deeper Understanding</a>
      <a href="#part5">PART 5 — Visualization Guide</a>
    </nav>
  </div>
</header>

<main>
  <article>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>What this is about:</b> photon counting from <b>multimode thermal light</b> (M independent identical modes).</li>
        <li><b>Key idea:</b> thermal light has <b>random intensity</b>; photon counts are a <b>Poisson process conditioned on that intensity</b>.</li>
        <li><b>Governing tool:</b> <b>Mandel’s formula</b> (Poisson mixture):
          \(P(n)=\int_0^\infty \frac{w^n e^{-w}}{n!}\,p(w)\,dw\).</li>
        <li><b>Given model:</b> the integrated rate \(w\ge 0\) has a <b>gamma density</b> for M identical modes.</li>
        <li><b>Result type:</b> a <b>symbolic closed-form</b> photon-number distribution.</li>
        <li><b>Final result:</b> \(P(n)\) becomes a <b>negative-binomial distribution</b> with parameters \(M\) and mean \(\langle w\rangle\).</li>
        <li><b>Key scaling:</b> \(\mathrm{Var}(n)=\langle n\rangle + \langle n\rangle^2/M\) → “excess noise” decreases as M increases.</li>
      </ul>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <h3>Core definitions (symbols & units)</h3>
      <div class="grid2">
        <div class="callout key">
          <strong>Photon count</strong>
          <p>
            \(n\) = number of detected photo-events in a time gate \(T\). Dimensionless integer: \(n=0,1,2,\dots\).
          </p>
        </div>
        <div class="callout key">
          <strong>Integrated rate</strong>
          <p>
            \(w=\int_0^T \lambda(t)\,dt\), where \(\lambda(t)\) is the (possibly random) detection rate (s\(^{-1}\)).
            Thus \(w\) is dimensionless and equals the <b>mean count</b> for a fixed realization of the light.
          </p>
        </div>
      </div>

      <h3>Physical meaning of the key quantities</h3>
      <ul>
        <li>\(\lambda(t)\) describes how “bright” the beam is at the detector at time \(t\). For thermal light it fluctuates strongly.</li>
        <li>\(w\) is the <b>total expected number of counts</b> during the gate for that particular realization of the fluctuations.</li>
        <li>\(p(w)\) is the probability density of that random total brightness.</li>
      </ul>

      <h3>Key principle: Mandel’s formula (Poisson mixture)</h3>
      <p>
        Photon detection in a short interval is well-modeled as a Poisson process if the rate is known.
        If the rate is <i>random</i>, then the unconditional counts are a mixture of Poissons.
      </p>
      <div class="callout assumptions">
        <strong>When it is valid</strong>
        <ul>
          <li>Semiclassical photodetection with shot noise: conditional counts are Poisson given the intensity (or rate).</li>
          <li>Stationary statistics inside the gate, or at least well-defined integrated rate \(w\).</li>
          <li>Independent modes add intensities (no phase-sensitive detection).</li>
        </ul>
      </div>

      <div class="eqBox">
        <button class="copyBtn" data-copy="mandel">Copy</button>
        <pre class="eq" id="mandel">Mandel’s formula (Poisson mixture):
P(n) = ∫₀^∞ [ (w^n e^(−w)) / n! ] p(w) dw</pre>
      </div>

      <h3>Common model here: multimode thermal light → gamma-distributed integrated rate</h3>
      <p>
        A single thermal mode has exponentially distributed intensity (and thus an exponential distribution for \(w\)).
        A sum of <b>M independent identical exponentials</b> is a <b>gamma distribution</b>.
      </p>

      <div class="callout key">
        <strong>Mini intuition examples</strong>
        <ul>
          <li><b>M=1:</b> maximal bunching → broad count distribution (geometric / Bose–Einstein in photon number).</li>
          <li><b>M→∞:</b> fluctuations average out → distribution approaches Poisson with mean \(\langle n\rangle\).</li>
        </ul>
      </div>

      <div class="callout mistakes">
        <strong>What to watch for</strong>
        <ul>
          <li>Confusing \(w\) (random mean count) with \(n\) (actual integer count).</li>
          <li>Forgetting that a gamma–Poisson mixture is exactly negative binomial.</li>
          <li>Dropping normalization constants in the gamma density (they matter!).</li>
          <li>Mixing notations: here \(\langle w\rangle\) plays the role of the mean photon number in the gate.</li>
        </ul>
      </div>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (No solving yet)</h2>

      <h3>Problem restatement</h3>
      <p>
        You are given a multimode thermal light source comprising <b>M identical independent modes</b>.
        The random integrated rate \(w\) has a gamma probability density \(p(w)\).
        Using Mandel’s formula, show that the photon-number distribution \(P(n)\) is a
        <b>negative-binomial distribution</b> (as defined in the referenced earlier problem).
      </p>

      <h3>Given quantities</h3>
      <ul>
        <li>\(M\): number of identical modes (positive integer).</li>
        <li>\(\langle w\rangle\): mean integrated rate (dimensionless mean count in the gate).</li>
        <li>Gamma density for \(w\ge 0\):
          <div class="eqBox">
            <button class="copyBtn" data-copy="pw">Copy</button>
            <pre class="eq" id="pw">p(w) = [1/(M−1)!] (M/⟨w⟩)^M w^(M−1) exp[−(M/⟨w⟩) w] ,   w ≥ 0</pre>
          </div>
        </li>
        <li>Mandel’s formula: \(P(n)=\int_0^\infty \frac{w^n e^{-w}}{n!} p(w)\,dw\).</li>
      </ul>

      <h3>Unknowns / What must be shown</h3>
      <ul>
        <li>Compute \(P(n)\) and show it matches the <b>negative-binomial form</b>.</li>
        <li>Identify how the parameters depend on \(M\) and \(\langle w\rangle\).</li>
      </ul>

      <h3>Relevant principles and why they apply</h3>
      <ul>
        <li><b>Poisson conditional statistics:</b> given a fixed integrated rate \(w\), counts are Poisson with mean \(w\).</li>
        <li><b>Gamma statistics for summed modes:</b> M independent exponential contributions sum to a gamma distribution.</li>
        <li>Other tools (e.g., full quantum field operators) are unnecessary here because Mandel’s formula already encodes the required semiclassical photodetection model.</li>
      </ul>

      <div class="callout assumptions">
        <strong>Assumptions</strong>
        <ul>
          <li>Modes are statistically independent and identical.</li>
          <li>Detection is linear, counts add, and the gate integrates the rate into \(w\).</li>
          <li>No dead time / saturation; ideal Poisson shot noise conditioned on intensity.</li>
        </ul>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ul>
        <li><b>(A) Direct integration (best here):</b> insert \(p(w)\) into Mandel’s formula and evaluate using the gamma integral. Fast and explicit.</li>
        <li><b>(B) Generating functions:</b> show that the probability generating function equals that of a negative binomial. Elegant, often shorter.</li>
        <li><b>(C) “Sum of geometric modes” reasoning:</b> photon number for each thermal mode is geometric; the sum of M i.i.d. geometrics is negative binomial. Conceptual but uses an extra known result.</li>
      </ul>
      <p><b>Chosen approach:</b> (A) Direct integration, because the problem explicitly asks to use Mandel’s formula and provides \(p(w)\) in gamma form.</p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy & Tips (Roadmap only)</h2>

      <ol>
        <li><b>Goal:</b> Write \(P(n)\) using Mandel’s formula. <br/>
          <b>Tool:</b> Poisson pmf \((w^n e^{-w}/n!)\). <br/>
          <b>Meaning:</b> average over random brightness \(w\).</li>

        <li><b>Goal:</b> Substitute the provided gamma density \(p(w)\). <br/>
          <b>Tool:</b> algebraic combination of exponentials and powers. <br/>
          <b>Meaning:</b> you’ll get one integral of the form \(\int_0^\infty w^{k-1} e^{-aw}\,dw\).</li>

        <li><b>Goal:</b> Recognize and evaluate the gamma integral. <br/>
          <b>Tool:</b> \(\int_0^\infty w^{\alpha-1} e^{-\beta w}\,dw=\Gamma(\alpha)/\beta^\alpha\). <br/>
          <b>Meaning:</b> converts the mixture to a closed form in \(n\).</li>

        <li><b>Goal:</b> Rewrite the factorial/gamma ratio into a binomial coefficient. <br/>
          <b>Tool:</b> \(\Gamma(n+M)=(n+M-1)!\), \(\binom{n+M-1}{n}=\frac{(n+M-1)!}{n!(M-1)!}\). <br/>
          <b>Meaning:</b> reveals the negative-binomial structure.</li>

        <li><b>Goal:</b> Identify NB parameters and sanity-check normalization & limits. <br/>
          <b>Tool:</b> limiting cases \(M=1\) and \(M\to\infty\), mean/variance formulas. <br/>
          <b>Meaning:</b> confirms physical behavior: bunching reduces with more modes.</li>
      </ol>

      <div class="callout mistakes">
        <strong>Common mistakes & quick tips</strong>
        <ul>
          <li>Combine exponentials carefully: \(e^{-w}\cdot e^{-(M/\langle w\rangle)w}=e^{-(1+M/\langle w\rangle)w}\).</li>
          <li>Track constants: \((M/\langle w\rangle)^M\) must survive to the final expression.</li>
          <li>Remember \(\Gamma(n+M)=(n+M-1)!\) only when \(n,M\) are integers.</li>
        </ul>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Physical intuition (before math)</h3>
      <p>
        Thermal light is “spiky”: its instantaneous intensity fluctuates. If you look at one detection gate,
        some gates are dim (few counts) and some are bright (many counts). This <b>extra randomness</b> makes
        the photon-number distribution broader than Poisson (super-Poissonian). If you combine many independent
        modes, fluctuations average out, so the distribution narrows and approaches Poisson as \(M\to\infty\).
      </p>

      <h3>Step 1: Start from Mandel’s formula</h3>
      <p>
        Let \(n\) be the detected photon number (counts) in the gate, and let \(w\) be the integrated rate.
        Conditioned on \(w\), the counts are Poisson:
      </p>
      <div class="eqBox">
        <button class="copyBtn" data-copy="poiss">Copy</button>
        <pre class="eq" id="poiss">Conditional (given w):
P(n | w) = (w^n e^(−w)) / n!   ,  n = 0,1,2,...</pre>
      </div>
      <p>
        Unconditionally, average over the randomness of \(w\):
      </p>
      <div class="eqBox">
        <button class="copyBtn" data-copy="mandel2">Copy</button>
        <pre class="eq" id="mandel2">Unconditional count distribution:
P(n) = ∫₀^∞ P(n|w) p(w) dw
     = ∫₀^∞ [ (w^n e^(−w)) / n! ] p(w) dw</pre>
      </div>

      <h3>Step 2: Insert the given gamma density for multimode thermal light</h3>
      <p>
        The problem states that \(w\) is gamma-distributed:
      </p>
      <div class="eqBox">
        <button class="copyBtn" data-copy="gammaW">Copy</button>
        <pre class="eq" id="gammaW">Given (gamma density):
p(w) = [1/(M−1)!] (M/⟨w⟩)^M w^(M−1) exp[−(M/⟨w⟩) w] ,  w ≥ 0</pre>
      </div>

      <p>
        Substitute into Mandel’s formula:
      </p>

      <div class="eqBox">
        <button class="copyBtn" data-copy="sub1">Copy</button>
        <pre class="eq" id="sub1">P(n) = ∫₀^∞ (w^n e^(−w) / n!) · [1/(M−1)!] (M/⟨w⟩)^M w^(M−1) e^{−(M/⟨w⟩)w} dw</pre>
      </div>

      <h3>Step 3: Combine powers and exponentials to expose a standard integral</h3>
      <p>
        Combine the powers of \(w\): \(w^n \cdot w^{M-1} = w^{n+M-1}\).<br/>
        Combine exponentials: \(e^{-w}\,e^{-(M/\langle w\rangle)w}=e^{-\left(1+M/\langle w\rangle\right)w}\).
      </p>

      <div class="eqBox">
        <button class="copyBtn" data-copy="sub2">Copy</button>
        <pre class="eq" id="sub2">P(n) = [1/(n!(M−1)!)] (M/⟨w⟩)^M ∫₀^∞ w^(n+M−1) exp[−(1 + M/⟨w⟩) w] dw</pre>
      </div>

      <p>
        Now the remaining integral is a gamma integral of the form
        \(\int_0^\infty w^{\alpha-1} e^{-\beta w}dw = \Gamma(\alpha)/\beta^\alpha\).
        Here:
      </p>
      <ul>
        <li>\(\alpha = n+M\) because \(\alpha-1 = n+M-1\)</li>
        <li>\(\beta = 1 + M/\langle w\rangle\)</li>
      </ul>

      <h3>Step 4: Evaluate the gamma integral</h3>
      <div class="eqBox">
        <button class="copyBtn" data-copy="gammaInt">Copy</button>
        <pre class="eq" id="gammaInt">∫₀^∞ w^(n+M−1) e^{−β w} dw = Γ(n+M) / β^(n+M)   with β = 1 + M/⟨w⟩</pre>
      </div>

      <p>
        Since \(n\) and \(M\) are integers, \(\Gamma(n+M)=(n+M-1)!\). Substitute:
      </p>

      <div class="eqBox">
        <button class="copyBtn" data-copy="pn1">Copy</button>
        <pre class="eq" id="pn1">P(n) = [1/(n!(M−1)!)] (M/⟨w⟩)^M · (n+M−1)! / (1 + M/⟨w⟩)^(n+M)</pre>
      </div>

      <h3>Step 5: Rewrite into negative-binomial form</h3>
      <p>
        First simplify the denominator:
      </p>
      <div class="eqBox">
        <button class="copyBtn" data-copy="betaRewrite">Copy</button>
        <pre class="eq" id="betaRewrite">1 + M/⟨w⟩ = (⟨w⟩ + M)/⟨w⟩
⇒ (1 + M/⟨w⟩)^(n+M) = (⟨w⟩ + M)^(n+M) / ⟨w⟩^(n+M)</pre>
      </div>

      <p>
        Insert this into \(P(n)\). The factors of \(\langle w\rangle\) become:
        \((M/\langle w\rangle)^M \times \langle w\rangle^{n+M} = M^M \langle w\rangle^n\).
      </p>

      <div class="eqBox">
        <button class="copyBtn" data-copy="pn2">Copy</button>
        <pre class="eq" id="pn2">P(n) = (n+M−1)! / [n!(M−1)!] · [ M^M ⟨w⟩^n ] / (⟨w⟩ + M)^(n+M)</pre>
      </div>

      <p>
        Recognize the combinatorial factor:
      </p>
      <div class="eqBox">
        <button class="copyBtn" data-copy="comb">Copy</button>
        <pre class="eq" id="comb">C(n+M−1, n) = (n+M−1)! / [n!(M−1)!]</pre>
      </div>

      <p>
        Split the remaining ratio into two terms, one raised to \(n\) and one to \(M\):
      </p>

      <div class="eqBox">
        <button class="copyBtn" data-copy="finalNB">Copy</button>
        <pre class="eq" id="finalNB">FINAL:
P(n) = C(n+M−1, n) · ( ⟨w⟩/(⟨w⟩+M) )^n · ( M/(⟨w⟩+M) )^M ,  n = 0,1,2,...

This is the negative-binomial distribution with “shape” M and mean ⟨n⟩ = ⟨w⟩.</pre>
      </div>

      <div class="callout answer">
        <strong>Final answer (boxed)</strong>
        <p style="margin:8px 0 0;color:var(--ink)">
          The photon-number distribution produced by a gamma-distributed integrated rate (multimode thermal light) is
          <b>negative binomial</b>:
        </p>
        <div class="eqBox" style="margin-top:10px">
          <button class="copyBtn" data-copy="finalOnly">Copy</button>
          <pre class="eq" id="finalOnly">P(n) = (n+M−1 choose n) ( ⟨w⟩/(⟨w⟩+M) )^n ( M/(⟨w⟩+M) )^M</pre>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <div class="grid2">
        <div class="callout key">
          <strong>Units / dimensions</strong>
          <p>
            \(w\) is dimensionless (rate integrated over time), so \(\langle w\rangle\) is also dimensionless.
            \(P(n)\) is dimensionless and normalized.
          </p>
        </div>
        <div class="callout key">
          <strong>Limiting cases</strong>
          <ul>
            <li><b>M=1:</b> \(P(n)=(\langle w\rangle/(1+\langle w\rangle))^n (1/(1+\langle w\rangle))\) → geometric (single-mode thermal).</li>
            <li><b>M→∞:</b> with fixed \(\langle w\rangle\), fluctuations vanish and \(P(n)\) approaches Poisson(\(\langle w\rangle\)).</li>
          </ul>
        </div>
      </div>

      <h3>Physical interpretation in plain language</h3>
      <p>
        The negative binomial arises because you are counting Poisson events whose mean \(w\) itself fluctuates with a gamma distribution.
        Thermal light produces exactly this kind of “Poisson-with-random-mean” behavior, and multiple independent modes reduce the relative fluctuations.
      </p>

      <p>
        Connection to the diagram and plots: the diagram shows M incoherent modes contributing to the detected intensity.
        The plots show how \(P(n)\) broadens for small \(M\) (strong bunching) and narrows toward Poisson for large \(M\).
      </p>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the final formula</h3>
      <ul>
        <li>\(\binom{n+M-1}{n}\) controls the combinatorics of distributing counts among \(M\) effective degrees of freedom.</li>
        <li>\(\left(\frac{\langle w\rangle}{\langle w\rangle+M}\right)^n\) sets how quickly the tail decays with \(n\) (brighter mean → heavier tail).</li>
        <li>\(\left(\frac{M}{\langle w\rangle+M}\right)^M\) ensures normalization and encodes the “shape” set by the number of modes.</li>
      </ul>

      <h3>Mean, variance, and “excess noise” vs mode number</h3>
      <p>
        For this negative-binomial parameterization:
      </p>
      <div class="eqBox">
        <button class="copyBtn" data-copy="moments">Copy</button>
        <pre class="eq" id="moments">⟨n⟩ = ⟨w⟩
Var(n) = ⟨n⟩ + ⟨n⟩² / M
Fano factor: F = Var(n)/⟨n⟩ = 1 + ⟨n⟩/M
Second-order coherence (thermal multimode): g²(0) = 1 + 1/M</pre>
      </div>

      <p>
        These show two distinct “mode-number effects”:
      </p>
      <ul>
        <li><b>Counting noise:</b> the “+⟨n⟩” term is the irreducible Poisson shot noise.</li>
        <li><b>Classical intensity noise:</b> the “+⟨n⟩²/M” term is from intensity fluctuations; it shrinks as \(1/M\).</li>
      </ul>

      <h3>How changing parameters affects the outcome (tie to interactive plots)</h3>
      <ul>
        <li>Increasing <b>\(\langle w\rangle\)</b> shifts \(P(n)\) to larger \(n\) and increases the Fano factor \(F=1+\langle w\rangle/M\).</li>
        <li>Increasing <b>\(M\)</b> reduces bunching and narrows \(P(n)\); the curve approaches Poisson for large \(M\).</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        Each single thermal mode has a geometric (Bose–Einstein) photon-number distribution.
        The sum of \(M\) independent identical geometric random variables is negative binomial.
        This yields the same \(P(n)\) without performing the mixture integral.
      </p>

      <h3>Concept checks (self-test)</h3>
      <ul>
        <li><b>Q:</b> What happens to \(P(n)\) if \(M\) doubles while \(\langle w\rangle\) stays fixed? <b>A:</b> It becomes narrower; excess noise decreases by \(\sim 1/M\).</li>
        <li><b>Q:</b> Why isn’t the distribution Poisson for thermal light? <b>A:</b> Because the mean rate fluctuates gate-to-gate; Poisson assumes a fixed mean.</li>
        <li><b>Q:</b> What does \(M=1\) represent physically? <b>A:</b> A single temporal/spatial/polarization mode (maximal bunching).</li>
        <li><b>Q:</b> Which term vanishes as \(M\to\infty\) in the variance? <b>A:</b> The \(\langle n\rangle^2/M\) intensity-noise term.</li>
      </ul>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <h3>What each canvas shows</h3>
      <ul>
        <li><b>Diagram (top):</b> A multimode thermal source with <b>M</b> independent modes feeding a detector over a gate time \(T\). Their intensities add to a random integrated rate \(w\).</li>
        <li><b>Main plot:</b> Photon-number distribution \(P(n)\) vs \(n\) for the <b>negative-binomial</b> result. Optionally overlays a <b>Poisson</b> distribution with the same mean \(\langle n\rangle=\langle w\rangle\).</li>
        <li><b>Secondary plot:</b> Parameter sweep vs \(M\): shows <b>Fano factor</b> \(F=1+\langle n\rangle/M\) and <b>coherence</b> \(g^{(2)}(0)=1+1/M\). Both drop toward 1 as \(M\) increases.</li>
      </ul>

      <h3>Interactive controls</h3>
      <ul>
        <li><b>Slider “M”:</b> changes the number of modes. Expect the NB distribution to narrow and the sweep curves to decrease.</li>
        <li><b>Slider “⟨w⟩”:</b> changes the mean count. Expect the distribution to shift right; the Fano factor curve rises because \(F=1+\langle w\rangle/M\).</li>
        <li><b>Toggle “Show Poisson”:</b> overlays Poisson(\(\langle w\rangle\)). For large \(M\), NB and Poisson nearly coincide.</li>
      </ul>
      <p class="caption">All plotted values use the same symbols as the derivation. If the original problem provides no numbers, the sliders supply <b>example values</b> for visualization only; the final result remains symbolic.</p>
    </section>
  </article>

  <aside class="vizPanel" aria-label="Interactive Visualizations">
    <h2>Interactive Visualizations</h2>

    <div class="controls">
      <div class="control">
        <label>
          <span>Number of modes, <b>M</b></span>
          <span class="val" id="Mval">10</span>
        </label>
        <input id="Mslider" type="range" min="1" max="50" step="1" value="10" />
      </div>
      <div class="control">
        <label>
          <span>Mean integrated rate, <b>⟨w⟩</b> (counts)</span>
          <span class="val" id="wval">6.0</span>
        </label>
        <input id="wslider" type="range" min="0.2" max="20" step="0.1" value="6.0" />
      </div>
    </div>

    <div class="row">
      <label class="toggle"><input id="poissonToggle" type="checkbox" checked /> Show Poisson overlay (same mean)</label>
      <button class="btn" id="resetBtn">Reset example values</button>
    </div>

    <canvas id="diagram" class="canvasShort" aria-label="Multimode thermal light diagram"></canvas>
    <div class="caption">Diagram: M independent thermal modes contribute to the random integrated rate <span style="font-family:var(--mono)">w</span>.</div>

    <canvas id="plot1" class="canvasTall" aria-label="Photon-number distribution plot"></canvas>
    <div class="caption">Main plot: Negative-binomial photon-number distribution <span style="font-family:var(--mono)">P(n)</span>.</div>

    <canvas id="plot2" class="canvasTall" aria-label="Parameter sweep plot"></canvas>
    <div class="caption">Secondary plot: sweep vs <span style="font-family:var(--mono)">M</span> showing <span style="font-family:var(--mono)">F</span> and <span style="font-family:var(--mono)">g²(0)</span>.</div>
  </aside>
</main>

<footer>
  <p>
    Built as a self-contained learning article (vanilla HTML/CSS/JS). Equations are provided in copyable plain-text form.
  </p>
</footer>

<script>
/* -------------------------- Copy buttons -------------------------- */
(function(){
  const map = {
    mandel: document.getElementById('mandel').innerText,
    pw: document.getElementById('pw').innerText,
    poiss: document.getElementById('poiss').innerText,
    mandel2: document.getElementById('mandel2').innerText,
    gammaW: document.getElementById('gammaW').innerText,
    sub1: document.getElementById('sub1').innerText,
    sub2: document.getElementById('sub2').innerText,
    gammaInt: document.getElementById('gammaInt').innerText,
    pn1: document.getElementById('pn1').innerText,
    betaRewrite: document.getElementById('betaRewrite').innerText,
    pn2: document.getElementById('pn2').innerText,
    comb: document.getElementById('comb').innerText,
    finalNB: document.getElementById('finalNB').innerText,
    finalOnly: document.getElementById('finalOnly').innerText,
    moments: document.getElementById('moments').innerText
  };
  document.querySelectorAll('.copyBtn').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const key = btn.getAttribute('data-copy');
      const txt = map[key] ?? '';
      try{
        await navigator.clipboard.writeText(txt);
        btn.classList.add('copied');
        const old = btn.textContent;
        btn.textContent = 'Copied';
        setTimeout(()=>{ btn.classList.remove('copied'); btn.textContent = old; }, 850);
      }catch(e){
        btn.textContent = 'Copy failed';
        setTimeout(()=>btn.textContent='Copy', 900);
      }
    });
  });
})();

/* -------------------------- Math helpers -------------------------- */
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

function buildLogFact(nMax){
  const lf = new Float64Array(nMax+1);
  lf[0]=0;
  for(let i=1;i<=nMax;i++) lf[i]=lf[i-1]+Math.log(i);
  return lf;
}
function logChoose(n,k,logFact){
  if(k<0 || k>n) return -Infinity;
  return logFact[n]-logFact[k]-logFact[n-k];
}
function negBinP(n,M,mean,logFact){
  // P(n) = C(n+M-1, n) (mean/(mean+M))^n (M/(mean+M))^M
  const a = mean/(mean+M);
  const b = M/(mean+M);
  const N = n+M-1;
  const logC = logChoose(N, n, logFact);
  return Math.exp(logC + n*Math.log(a) + M*Math.log(b));
}
function poissonP(n,mean){
  // stable enough for moderate n (<=200) by log form
  let logP = -mean + n*Math.log(mean) - logFactorialApprox(n);
  return Math.exp(logP);
}
function logFactorialApprox(n){
  // for integer n up to a few hundred, Stirling with correction is fine
  if(n<2) return 0;
  const x = n + 1;
  return (x-0.5)*Math.log(x) - x + 0.5*Math.log(2*Math.PI) + 1/(12*x) - 1/(360*x*x*x);
}

/* -------------------------- Canvas utilities -------------------------- */
function setupCanvas(canvas){
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  function resize(){
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(2, Math.floor(rect.width * dpr));
    canvas.height = Math.max(2, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  }
  resize();
  return {ctx, resize};
}
function clear(ctx, w, h){
  ctx.clearRect(0,0,w,h);
}

/* -------------------------- Plotting primitives -------------------------- */
function drawAxes(ctx, box, xLabel, yLabel, title){
  const {x,y,w,h} = box;
  // background panel
  ctx.save();
  ctx.fillStyle = 'rgba(10,14,30,.35)';
  ctx.fillRect(x,y,w,h);

  // title
  ctx.fillStyle = 'rgba(233,238,252,.92)';
  ctx.font = '600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText(title, x+10, y+18);

  // axis labels
  ctx.fillStyle = 'rgba(185,195,230,.90)';
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText(xLabel, x + w - 10 - ctx.measureText(xLabel).width, y + h - 8);

  // y label rotated
  ctx.save();
  ctx.translate(x+12, y + 22);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  // border
  ctx.strokeStyle = 'rgba(255,255,255,.12)';
  ctx.lineWidth = 1;
  ctx.strokeRect(x,y,w,h);
  ctx.restore();
}

function drawGridAndTicks(ctx, plotArea, xMin, xMax, yMin, yMax, xTicks, yTicks){
  const {x,y,w,h} = plotArea;
  ctx.save();
  // grid
  ctx.strokeStyle = 'rgba(255,255,255,.08)';
  ctx.lineWidth = 1;

  // vertical grid + x ticks
  ctx.fillStyle = 'rgba(185,195,230,.85)';
  ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

  for(let i=0;i<=xTicks;i++){
    const t = i/xTicks;
    const X = x + t*w;
    ctx.beginPath();
    ctx.moveTo(X, y);
    ctx.lineTo(X, y+h);
    ctx.stroke();

    const val = xMin + t*(xMax-xMin);
    const lbl = (Math.abs(val) >= 10 || xMax-xMin>20) ? String(Math.round(val)) : val.toFixed(1);
    ctx.fillText(lbl, X-ctx.measureText(lbl).width/2, y+h+14);
  }

  // horizontal grid + y ticks
  for(let j=0;j<=yTicks;j++){
    const t = j/yTicks;
    const Y = y + (1-t)*h;
    ctx.beginPath();
    ctx.moveTo(x, Y);
    ctx.lineTo(x+w, Y);
    ctx.stroke();

    const val = yMin + t*(yMax-yMin);
    const lbl = (val>=1 || yMax>2) ? val.toFixed(2) : val.toFixed(3);
    ctx.fillText(lbl, x-8-ctx.measureText(lbl).width, Y+4);
  }

  // axis lines
  ctx.strokeStyle = 'rgba(255,255,255,.16)';
  ctx.beginPath();
  ctx.moveTo(x, y+h);
  ctx.lineTo(x+w, y+h);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x, y+h);
  ctx.stroke();

  ctx.restore();
}

function mapX(xVal, xMin, xMax, plotArea){
  return plotArea.x + (xVal-xMin)/(xMax-xMin) * plotArea.w;
}
function mapY(yVal, yMin, yMax, plotArea){
  return plotArea.y + (1 - (yVal-yMin)/(yMax-yMin)) * plotArea.h;
}

function drawLegend(ctx, items, x, y){
  ctx.save();
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  let yy = y;
  items.forEach(it=>{
    ctx.strokeStyle = it.stroke;
    ctx.lineWidth = it.width || 3;
    ctx.beginPath();
    ctx.moveTo(x, yy);
    ctx.lineTo(x+18, yy);
    ctx.stroke();
    if(it.dash){
      // draw dashed preview
      ctx.setLineDash(it.dash);
      ctx.beginPath();
      ctx.moveTo(x, yy);
      ctx.lineTo(x+18, yy);
      ctx.stroke();
      ctx.setLineDash([]);
    }
    ctx.fillStyle = 'rgba(233,238,252,.92)';
    ctx.fillText(it.label, x+24, yy+4);
    yy += 16;
  });
  ctx.restore();
}

/* -------------------------- Diagram drawing -------------------------- */
function drawDiagram(ctx, canvas){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  clear(ctx, w, h);

  // soft background
  ctx.save();
  ctx.fillStyle = 'rgba(10,14,30,.35)';
  ctx.fillRect(0,0,w,h);
  ctx.strokeStyle = 'rgba(255,255,255,.10)';
  ctx.strokeRect(8,8,w-16,h-16);
  ctx.restore();

  // source block
  const sx=30, sy=40, sw=160, sh=90;
  ctx.save();
  ctx.fillStyle = 'rgba(122,167,255,.12)';
  ctx.strokeStyle = 'rgba(122,167,255,.28)';
  ctx.lineWidth = 2;
  roundRect(ctx, sx, sy, sw, sh, 16);
  ctx.fill(); ctx.stroke();

  ctx.fillStyle = 'rgba(233,238,252,.95)';
  ctx.font = '600 13px ui-sans-serif, system-ui';
  ctx.fillText('Multimode thermal source', sx+12, sy+24);
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace';
  ctx.fillStyle = 'rgba(185,195,230,.92)';
  ctx.fillText('M independent modes', sx+12, sy+44);

  // draw little mode lines inside
  const lines = 6;
  for(let i=0;i<lines;i++){
    const yy = sy+56 + i*10;
    ctx.strokeStyle = 'rgba(124,240,199,.55)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(sx+12, yy);
    ctx.lineTo(sx+sw-12, yy);
    ctx.stroke();
  }
  ctx.restore();

  // propagation arrow
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,.25)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(sx+sw+18, sy+sh/2);
  ctx.lineTo(sx+sw+210, sy+sh/2);
  ctx.stroke();
  drawArrowHead(ctx, sx+sw+210, sy+sh/2, 0, 10);

  ctx.fillStyle = 'rgba(185,195,230,.9)';
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillText('Intensity adds → random w', sx+sw+30, sy+sh/2 - 10);
  ctx.fillStyle = 'rgba(185,195,230,.9)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace';
  ctx.fillText('w = ∫₀ᵀ λ(t) dt', sx+sw+30, sy+sh/2 + 12);
  ctx.restore();

  // detector
  const dx = sx+sw+230, dy=35, dw=150, dh=100;
  ctx.save();
  ctx.fillStyle = 'rgba(124,240,199,.10)';
  ctx.strokeStyle = 'rgba(124,240,199,.28)';
  ctx.lineWidth=2;
  roundRect(ctx, dx, dy, dw, dh, 18);
  ctx.fill(); ctx.stroke();

  ctx.fillStyle = 'rgba(233,238,252,.95)';
  ctx.font = '600 13px ui-sans-serif, system-ui';
  ctx.fillText('Photon counter', dx+14, dy+24);
  ctx.fillStyle = 'rgba(185,195,230,.92)';
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillText('Gate time: T', dx+14, dy+44);
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace';
  ctx.fillText('Counts: n ~ Poisson(w)', dx+14, dy+64);

  // small histogram icon
  const hx = dx+20, hy = dy+74;
  for(let i=0;i<6;i++){
    const barH = 6 + i*3;
    ctx.fillStyle = 'rgba(255,255,255,.20)';
    ctx.fillRect(hx+i*12, hy+20-barH, 8, barH);
  }
  ctx.restore();

  // footer note
  ctx.save();
  ctx.fillStyle = 'rgba(185,195,230,.75)';
  ctx.font = '11px ui-sans-serif, system-ui';
  ctx.fillText('Gamma-distributed w (sum of M exponentials) → Negative-binomial P(n)', 30, h-18);
  ctx.restore();
}

function roundRect(ctx,x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}
function drawArrowHead(ctx, x, y, angle, size){
  ctx.save();
  ctx.translate(x,y);
  ctx.rotate(angle);
  ctx.fillStyle = 'rgba(255,255,255,.25)';
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.lineTo(-size, size*0.55);
  ctx.lineTo(-size, -size*0.55);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

/* -------------------------- Main plot: P(n) -------------------------- */
function drawDistributionPlot(ctx, canvas, M, mean, showPoisson){
  const W = canvas.clientWidth, H = canvas.clientHeight;
  clear(ctx, W, H);

  // layout
  const padL = 58, padR = 18, padT = 34, padB = 38;
  const box = {x:10,y:10,w:W-20,h:H-20};
  drawAxes(ctx, box, 'n (counts)', 'P(n)', 'Photon-number distribution');

  const plot = {x: box.x+padL, y: box.y+padT, w: box.w-padL-padR, h: box.h-padT-padB};

  // choose nmax based on mean+variance
  const varN = mean + (mean*mean)/M;
  let nMax = Math.ceil(mean + 6*Math.sqrt(varN) + 10);
  nMax = clamp(nMax, 20, 220);

  // log factorial for choose
  const logFact = buildLogFact(nMax + M + 5);

  // compute probabilities
  const Pnb = [];
  const Pp = [];
  let yMax = 0;
  for(let n=0;n<=nMax;n++){
    const p = negBinP(n, M, mean, logFact);
    Pnb.push(p);
    yMax = Math.max(yMax, p);
    if(showPoisson){
      const q = poissonP(n, mean);
      Pp.push(q);
      yMax = Math.max(yMax, q);
    }
  }
  yMax *= 1.18;
  const xMin = 0, xMax = nMax;
  const yMin = 0, yMaxUsed = yMax;

  // grid and ticks
  const xTicks = 8;
  const yTicks = 5;
  drawGridAndTicks(ctx, plot, xMin, xMax, yMin, yMaxUsed, xTicks, yTicks);

  // bars for NB
  ctx.save();
  const barW = plot.w/(nMax+1);
  for(let n=0;n<=nMax;n++){
    const x0 = mapX(n-0.45, xMin, xMax, plot);
    const x1 = mapX(n+0.45, xMin, xMax, plot);
    const y0 = mapY(0, yMin, yMaxUsed, plot);
    const y1 = mapY(Pnb[n], yMin, yMaxUsed, plot);
    ctx.fillStyle = 'rgba(124,240,199,.18)';
    ctx.strokeStyle = 'rgba(124,240,199,.40)';
    ctx.lineWidth = 1;
    ctx.fillRect(x0, y1, Math.max(1, x1-x0), y0-y1);
    ctx.strokeRect(x0, y1, Math.max(1, x1-x0), y0-y1);
  }
  ctx.restore();

  // line for NB
  ctx.save();
  ctx.strokeStyle = 'rgba(124,240,199,.85)';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  for(let n=0;n<=nMax;n++){
    const X = mapX(n, xMin, xMax, plot);
    const Y = mapY(Pnb[n], yMin, yMaxUsed, plot);
    if(n===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
  }
  ctx.stroke();
  ctx.restore();

  // optional Poisson overlay
  if(showPoisson){
    ctx.save();
    ctx.strokeStyle = 'rgba(122,167,255,.90)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6,5]);
    ctx.beginPath();
    for(let n=0;n<=nMax;n++){
      const X = mapX(n, xMin, xMax, plot);
      const Y = mapY(Pp[n], yMin, yMaxUsed, plot);
      if(n===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
    }
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  // annotation box with mean/var
  ctx.save();
  const fx = 16, fy = box.y + box.h - 60;
  ctx.fillStyle = 'rgba(15,23,49,.70)';
  ctx.strokeStyle = 'rgba(255,255,255,.14)';
  ctx.lineWidth = 1;
  roundRect(ctx, fx, fy, 260, 46, 14);
  ctx.fill(); ctx.stroke();

  ctx.fillStyle = 'rgba(233,238,252,.92)';
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillText(`M = ${M}   ⟨n⟩ = ⟨w⟩ = ${mean.toFixed(2)}`, fx+12, fy+18);
  ctx.fillStyle = 'rgba(185,195,230,.92)';
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillText(`Var(n) = ⟨n⟩ + ⟨n⟩²/M = ${varN.toFixed(2)}`, fx+12, fy+36);
  ctx.restore();

  // legend
  const items = [
    {label:'Negative binomial (multimode thermal)', stroke:'rgba(124,240,199,.85)', width:3}
  ];
  if(showPoisson){
    items.push({label:'Poisson (same mean)', stroke:'rgba(122,167,255,.90)', width:2, dash:[6,5]});
  }
  drawLegend(ctx, items, box.x + box.w - 270, box.y + 26);
}

/* -------------------------- Secondary plot: sweep vs M -------------------------- */
function drawSweepPlot(ctx, canvas, mean){
  const W = canvas.clientWidth, H = canvas.clientHeight;
  clear(ctx, W, H);

  const padL = 58, padR = 18, padT = 34, padB = 38;
  const box = {x:10,y:10,w:W-20,h:H-20};
  drawAxes(ctx, box, 'M (modes)', 'Value (dimensionless)', 'Parameter sweep vs mode number');

  const plot = {x: box.x+padL, y: box.y+padT, w: box.w-padL-padR, h: box.h-padT-padB};

  const Mmin = 1, Mmax = 50;
  const xs = [];
  const F = [];
  const g2 = [];
  let yMax = 1;
  for(let M=Mmin; M<=Mmax; M++){
    xs.push(M);
    const f = 1 + mean/M;
    const g = 1 + 1/M;
    F.push(f);
    g2.push(g);
    yMax = Math.max(yMax, f, g);
  }
  yMax = Math.min(6, yMax*1.12);
  const yMin = 1;

  drawGridAndTicks(ctx, plot, Mmin, Mmax, yMin, yMax, 7, 5);

  // F line
  ctx.save();
  ctx.strokeStyle = 'rgba(255,211,122,.92)'; // warn-ish
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const X = mapX(xs[i], Mmin, Mmax, plot);
    const Y = mapY(F[i], yMin, yMax, plot);
    if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
  }
  ctx.stroke();
  ctx.restore();

  // g2 line
  ctx.save();
  ctx.strokeStyle = 'rgba(122,167,255,.92)';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const X = mapX(xs[i], Mmin, Mmax, plot);
    const Y = mapY(g2[i], yMin, yMax, plot);
    if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
  }
  ctx.stroke();
  ctx.restore();

  // baseline at 1
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,.18)';
  ctx.setLineDash([4,5]);
  ctx.lineWidth = 1.5;
  const Y1 = mapY(1, yMin, yMax, plot);
  ctx.beginPath();
  ctx.moveTo(plot.x, Y1);
  ctx.lineTo(plot.x+plot.w, Y1);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();

  // legend
  drawLegend(ctx, [
    {label:`Fano factor F = 1 + ⟨n⟩/M  (⟨n⟩=${mean.toFixed(1)})`, stroke:'rgba(255,211,122,.92)', width:3},
    {label:'g²(0) = 1 + 1/M', stroke:'rgba(122,167,255,.92)', width:3}
  ], box.x + 18, box.y + 26);

  // note box
  ctx.save();
  const fx = box.x + box.w - 280;
  const fy = box.y + box.h - 56;
  ctx.fillStyle = 'rgba(15,23,49,.70)';
  ctx.strokeStyle = 'rgba(255,255,255,.14)';
  ctx.lineWidth = 1;
  roundRect(ctx, fx, fy, 264, 42, 14);
  ctx.fill(); ctx.stroke();
  ctx.fillStyle = 'rgba(233,238,252,.92)';
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillText('Both curves → 1 as M increases', fx+12, fy+18);
  ctx.fillStyle = 'rgba(185,195,230,.92)';
  ctx.fillText('More modes → weaker relative fluctuations', fx+12, fy+34);
  ctx.restore();
}

/* -------------------------- Wiring & responsiveness -------------------------- */
const Mslider = document.getElementById('Mslider');
const wslider = document.getElementById('wslider');
const Mval = document.getElementById('Mval');
const wval = document.getElementById('wval');
const poissonToggle = document.getElementById('poissonToggle');
const resetBtn = document.getElementById('resetBtn');

const diagramCanvas = document.getElementById('diagram');
const plot1Canvas = document.getElementById('plot1');
const plot2Canvas = document.getElementById('plot2');

const diagram = setupCanvas(diagramCanvas);
const plot1 = setupCanvas(plot1Canvas);
const plot2 = setupCanvas(plot2Canvas);

function updateLabels(){
  const M = parseInt(Mslider.value,10);
  const mean = parseFloat(wslider.value);
  Mval.textContent = String(M);
  wval.textContent = mean.toFixed(1);
}

function renderAll(){
  updateLabels();
  const M = parseInt(Mslider.value,10);
  const mean = parseFloat(wslider.value);
  const showP = poissonToggle.checked;

  drawDiagram(diagram.ctx, diagramCanvas);
  drawDistributionPlot(plot1.ctx, plot1Canvas, M, mean, showP);
  drawSweepPlot(plot2.ctx, plot2Canvas, mean);
}

[Mslider, wslider, poissonToggle].forEach(el=>{
  el.addEventListener('input', renderAll);
});

resetBtn.addEventListener('click', ()=>{
  Mslider.value = 10;
  wslider.value = 6.0;
  poissonToggle.checked = true;
  renderAll();
});

function resizeAll(){
  diagram.resize();
  plot1.resize();
  plot2.resize();
  renderAll();
}

window.addEventListener('resize', ()=>{
  // debounce a bit
  clearTimeout(window.__rz);
  window.__rz = setTimeout(resizeAll, 80);
});

// initial render
renderAll();
</script>
</body>
</html>
