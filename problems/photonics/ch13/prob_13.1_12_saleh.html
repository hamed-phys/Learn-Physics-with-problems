<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Photon Momentum Exchange at a Lossless Beamsplitter</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101833;
      --panel2:#0f1630;
      --text:#e9ecff;
      --muted:#b8c0ff;
      --faint:#7f8ad6;
      --accent:#7cf0c8;
      --accent2:#7cb8ff;
      --warn:#ffd166;
      --danger:#ff6b6b;
      --ok:#7cf0c8;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 15% 10%, rgba(124,184,255,.18), transparent 60%),
        radial-gradient(1000px 700px at 80% 30%, rgba(124,240,200,.12), transparent 60%),
        radial-gradient(900px 600px at 60% 90%, rgba(255,209,102,.08), transparent 60%),
        var(--bg);
      line-height:1.5;
    }
    header{
      padding:28px 20px 16px;
      max-width:1200px;
      margin:0 auto;
    }
    .title{
      display:flex;
      gap:14px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .badge{
      font-size:12px;
      letter-spacing:.08em;
      text-transform:uppercase;
      padding:6px 10px;
      border-radius:999px;
      background:rgba(124,240,200,.14);
      color:var(--accent);
      border:1px solid rgba(124,240,200,.25);
      transform: translateY(3px);
    }
    h1{
      font-size: clamp(22px, 2.6vw, 34px);
      margin:0;
      line-height:1.15;
    }
    .subtitle{
      margin:10px 0 0;
      color:var(--muted);
      max-width: 74ch;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding: 0 20px 40px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }

    nav.toc{
      position:sticky;
      top:14px;
      background: linear-gradient(180deg, rgba(16,24,51,.95), rgba(16,24,51,.75));
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      padding:16px 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    nav.toc h2{
      font-size:14px;
      margin:0 0 10px;
      color:var(--muted);
      letter-spacing:.02em;
    }
    nav.toc a{
      display:block;
      padding:8px 10px;
      border-radius: 12px;
      color: var(--text);
      text-decoration:none;
      border:1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      font-size:14px;
    }
    nav.toc a:hover{
      background: rgba(124,184,255,.10);
      border-color: rgba(124,184,255,.22);
      transform: translateX(2px);
    }
    nav.toc .mini{
      margin-top:10px;
      padding:10px;
      border-radius: 14px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      color: var(--muted);
      font-size:13px;
    }

    article{
      background: linear-gradient(180deg, rgba(16,24,51,.92), rgba(16,24,51,.78));
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .content{
      padding:18px 18px 6px;
    }

    section{
      padding: 14px 0 4px;
      border-top:1px solid rgba(255,255,255,.08);
    }
    section:first-of-type{ border-top:none; padding-top:6px;}
    h2{
      margin:0 0 8px;
      font-size: 18px;
      letter-spacing:.01em;
    }
    h3{
      margin: 14px 0 8px;
      font-size: 15px;
      color: var(--muted);
    }
    p{ margin: 8px 0; color: rgba(233,236,255,.93); }
    ul{ margin: 8px 0 10px 22px; }
    li{ margin: 6px 0; color: rgba(233,236,255,.92); }
    .grid2{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:14px;
    }
    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
      nav.toc{ position:relative; top:0; }
      .grid2{ grid-template-columns:1fr; }
    }

    .callouts{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:12px;
      margin-top:10px;
    }
    .card{
      grid-column: span 12;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding:12px 12px;
    }
    .card strong{ color: var(--text); }
    .card .label{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-weight:700;
      letter-spacing:.02em;
    }
    .pill{
      width:10px;height:10px;border-radius:999px; display:inline-block;
      background: var(--accent2);
      box-shadow: 0 0 0 3px rgba(124,184,255,.15);
    }
    .pill.warn{ background: var(--warn); box-shadow: 0 0 0 3px rgba(255,209,102,.16); }
    .pill.danger{ background: var(--danger); box-shadow: 0 0 0 3px rgba(255,107,107,.15); }
    .pill.ok{ background: var(--ok); box-shadow: 0 0 0 3px rgba(124,240,200,.15); }

    .eq{
      font-family: var(--mono);
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding:10px 10px;
      margin:10px 0;
      overflow:auto;
      position:relative;
    }
    .eq pre{
      margin:0;
      white-space: pre-wrap;
      word-break: break-word;
      color: rgba(233,236,255,.95);
      font-size: 13px;
      line-height:1.45;
    }
    .copyBtn{
      position:absolute;
      top:8px;
      right:8px;
      padding:7px 10px;
      border-radius: 12px;
      background: rgba(124,240,200,.14);
      border:1px solid rgba(124,240,200,.25);
      color: var(--accent);
      cursor:pointer;
      font-size:12px;
      transition: transform .12s ease, background .12s ease;
      user-select:none;
    }
    .copyBtn:hover{ transform: translateY(-1px); background: rgba(124,240,200,.18); }
    .copyBtn:active{ transform: translateY(0px) scale(.98); }

    .vizWrap{
      padding:14px 18px 18px;
      border-top:1px solid rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(15,22,48,.92), rgba(15,22,48,.70));
    }
    .vizGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      align-items:stretch;
    }
    .vizGrid .wide{ grid-column: 1 / -1; }
    @media (max-width: 980px){
      .vizGrid{ grid-template-columns: 1fr; }
      .vizGrid .wide{ grid-column:auto; }
    }
    figure{
      margin:0;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      overflow:hidden;
    }
    figcaption{
      padding:10px 12px;
      border-top:1px solid rgba(255,255,255,.08);
      color: var(--muted);
      font-size: 13px;
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      background: linear-gradient(180deg, rgba(8,12,25,.75), rgba(8,12,25,.55));
    }
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:flex-end;
      justify-content:space-between;
      margin-bottom:12px;
    }
    .control{
      flex: 1 1 220px;
      min-width: 220px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding:10px 12px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      font-size:13px;
      color: var(--muted);
      margin-bottom:8px;
    }
    .control input[type="range"]{
      width:100%;
    }
    .readout{
      font-family: var(--mono);
      font-size:12px;
      color: rgba(233,236,255,.92);
      padding:2px 8px;
      border-radius: 10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      white-space:nowrap;
    }
    .noteRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .note{
      flex: 1 1 260px;
      background: rgba(124,184,255,.08);
      border:1px solid rgba(124,184,255,.18);
      border-radius: 14px;
      padding:10px 12px;
      color: rgba(233,236,255,.90);
      font-size: 13px;
    }

    footer{
      max-width:1200px;
      margin: 14px auto 28px;
      padding: 0 20px;
      color: rgba(184,192,255,.85);
      font-size: 13px;
    }
    .hr{
      height:1px;
      background: rgba(255,255,255,.10);
      margin: 14px 0;
    }
    @media print{
      body{ background:white; color:black; }
      nav.toc{ display:none; }
      article, .control, figure, .card{ box-shadow:none; }
      canvas{ display:none; }
      .vizWrap{ display:none; }
      .badge{ display:none; }
    }
  </style>
</head>

<body>
<header>
  <div class="title">
    <div class="badge">Quantum optics • momentum • beamsplitter</div>
    <h1>Photon Momentum Exchange at a Lossless Beamsplitter</h1>
  </div>
  <p class="subtitle">
    We treat a single photon as a plane-wave mode incident on an ideal (lossless) beamsplitter.
    The key idea is that a beamsplitter creates a <em>superposition of output modes</em>; each output mode has a well-defined wavevector, hence a well-defined photon momentum.
  </p>
</header>

<main>
  <nav class="toc" aria-label="Table of Contents">
    <h2>On this page</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
    <div class="mini">
      <div style="font-weight:700; margin-bottom:6px;">Interactive controls</div>
      <div>Use the sliders below the plots to change:</div>
      <ul style="margin:8px 0 0 18px;">
        <li>Incidence angle <span style="font-family:var(--mono);">θ</span></li>
        <li>Reflectivity <span style="font-family:var(--mono);">R = |r|²</span></li>
      </ul>
    </div>
  </nav>

  <article>
    <div class="content">
      <section id="quick">
        <h2>Quick Summary</h2>
        <ul>
          <li>We model a single photon as a plane-wave mode with wavevector <span style="font-family:var(--mono);">k</span>.</li>
          <li>Photon momentum is <span style="font-family:var(--mono);">p = ħ k</span> (units: kg·m/s). Magnitude in vacuum: <span style="font-family:var(--mono);">|p| = ħω/c = h/λ</span>.</li>
          <li>A lossless beamsplitter maps an input mode into a coherent superposition of <em>transmitted</em> and <em>reflected</em> output modes.</li>
          <li>For a planar beamsplitter (same medium on both sides): tangential component of <span style="font-family:var(--mono);">k</span> is preserved; the normal component flips sign upon reflection.</li>
          <li>Possible output photon momenta are therefore two vectors: transmitted <span style="font-family:var(--mono);">p_t</span> (same direction as incident) and reflected <span style="font-family:var(--mono);">p_r</span> (specular reflection).</li>
          <li>Probabilities are <span style="font-family:var(--mono);">T = |t|²</span> and <span style="font-family:var(--mono);">R = |r|²</span> with <span style="font-family:var(--mono);">R + T = 1</span> (lossless).</li>
          <li>Average momentum transferred to the beamsplitter per incident photon is <span style="font-family:var(--mono);">⟨Δp⟩ = 2 R |p| cosθ</span> along the surface normal (for equal refractive index on both sides).</li>
        </ul>
      </section>

      <section id="part0">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <div class="grid2">
          <div>
            <h3>Core definitions (symbols & units)</h3>
            <ul>
              <li><span style="font-family:var(--mono);">λ</span> — wavelength (m). Example for plotting: <span style="font-family:var(--mono);">λ = 800 nm</span>.</li>
              <li><span style="font-family:var(--mono);">ω</span> — angular frequency (rad/s), related by <span style="font-family:var(--mono);">ω = 2πc/λ</span> in vacuum.</li>
              <li><span style="font-family:var(--mono);">k</span> — wavevector (1/m), with magnitude <span style="font-family:var(--mono);">|k| = 2π/λ</span> (vacuum).</li>
              <li><span style="font-family:var(--mono);">p</span> — photon momentum vector (kg·m/s). In a plane-wave mode: <span style="font-family:var(--mono);">p = ħk</span>.</li>
              <li><span style="font-family:var(--mono);">r, t</span> — complex reflection and transmission <em>amplitudes</em> of the beamsplitter; probabilities are <span style="font-family:var(--mono);">R=|r|²</span>, <span style="font-family:var(--mono);">T=|t|²</span>.</li>
              <li><span style="font-family:var(--mono);">θ</span> — incidence angle (rad or degrees), measured from the surface normal.</li>
            </ul>

            <h3>Physical meaning</h3>
            <ul>
              <li><strong>Momentum as direction of propagation:</strong> In a plane wave, the photon’s momentum points along the propagation direction (along <span style="font-family:var(--mono);">k</span>).</li>
              <li><strong>Beamsplitter outputs are distinct modes:</strong> The transmitted and reflected plane waves propagate in different directions, so they correspond to different momentum eigenstates.</li>
              <li><strong>“Lossless” means probability conservation:</strong> If there is no absorption or scattering into other modes, then <span style="font-family:var(--mono);">R+T=1</span>.</li>
            </ul>
          </div>

          <div>
            <div class="callouts">
              <div class="card">
                <div class="label"><span class="pill ok"></span>Key principle</div>
                <p style="margin:8px 0 0;">
                  A single photon incident on a lossless beamsplitter emerges in a <strong>superposition</strong> of
                  “reflected” and “transmitted” momentum states. Measurement yields one outcome with probabilities set by <span style="font-family:var(--mono);">|r|²</span> and <span style="font-family:var(--mono);">|t|²</span>.
                </p>
              </div>
              <div class="card">
                <div class="label"><span class="pill warn"></span>When valid</div>
                <p style="margin:8px 0 0;">
                  Plane-wave mode description assumes a well-defined propagation direction (narrow angular spread),
                  linear optics, and an ideal (unitary) beamsplitter with no loss.
                </p>
              </div>
              <div class="card">
                <div class="label"><span class="pill danger"></span>What to watch for</div>
                <ul style="margin:8px 0 0 18px;">
                  <li>Confusing <em>amplitudes</em> (<span style="font-family:var(--mono);">r,t</span>) with <em>probabilities</em> (<span style="font-family:var(--mono);">R,T</span>).</li>
                  <li>Forgetting reflection flips only the <em>normal</em> component of momentum.</li>
                  <li>Ignoring the possibility of a relative phase between reflected and transmitted amplitudes (important for interference, but not for single-output probabilities).</li>
                </ul>
              </div>
            </div>
          </div>
        </div>

        <h3>Common models/approximations and why we use them</h3>
        <ul>
          <li><strong>Ideal planar interface:</strong> gives specular reflection and simple momentum component rules.</li>
          <li><strong>Single-frequency plane wave:</strong> makes the momentum magnitude <span style="font-family:var(--mono);">|p|</span> sharp.</li>
          <li><strong>Unitary beamsplitter transformation:</strong> ensures probability conservation for a lossless device.</li>
        </ul>

        <h3>Mini intuition examples</h3>
        <ul>
          <li><strong>Perfect mirror (R=1):</strong> the photon always reflects, so the mirror receives a momentum kick of magnitude <span style="font-family:var(--mono);">2|p|cosθ</span> along the normal.</li>
          <li><strong>Perfect transmitter (R=0):</strong> nothing reflects; the photon keeps its momentum direction, so average momentum transfer is zero.</li>
        </ul>
      </section>

      <section id="part1">
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

        <h3>Restating the problem</h3>
        <p>
          A single photon, prepared in a plane-wave mode (so it has a definite wavevector), impinges on a lossless beamsplitter.
          We must (1) give the photon’s momentum vector <em>before</em> it reaches the beamsplitter, and (2) list the possible momentum vectors <em>after</em> the beamsplitter along with their observation probabilities.
        </p>

        <h3>Given</h3>
        <ul>
          <li>A single photon in a plane-wave mode (definite <span style="font-family:var(--mono);">k</span>, hence definite <span style="font-family:var(--mono);">p</span>).</li>
          <li>A lossless beamsplitter characterized by complex amplitudes <span style="font-family:var(--mono);">r</span> and <span style="font-family:var(--mono);">t</span> (with <span style="font-family:var(--mono);">|r|²+|t|²=1</span>).</li>
          <li>Planar geometry (implicit in “beamsplitter/mirror” language): one incident direction and two output directions (reflected and transmitted).</li>
        </ul>

        <h3>Unknowns / what to find</h3>
        <ul>
          <li>The incident momentum vector <span style="font-family:var(--mono);">p_i</span>.</li>
          <li>The possible output momentum vectors <span style="font-family:var(--mono);">p_r</span> (reflected) and <span style="font-family:var(--mono);">p_t</span> (transmitted).</li>
          <li>The probabilities <span style="font-family:var(--mono);">P(p_r)=R</span> and <span style="font-family:var(--mono);">P(p_t)=T</span>.</li>
        </ul>

        <h3>Relevant principles (and why)</h3>
        <ul>
          <li><strong>Quantum plane-wave momentum:</strong> a plane-wave mode is a momentum eigenstate → <span style="font-family:var(--mono);">p=ħk</span>.</li>
          <li><strong>Boundary-condition geometry:</strong> at a planar interface, tangential <span style="font-family:var(--mono);">k</span> is conserved; reflection flips the normal component. This determines the two possible output momentum directions.</li>
          <li><strong>Lossless beamsplitter unitarity:</strong> ensures <span style="font-family:var(--mono);">R+T=1</span>; probabilities are the squared magnitudes of amplitudes.</li>
        </ul>
        <p>
          We do <em>not</em> need detailed Fresnel coefficients or polarization-dependent formulas because the problem asks only for possible momentum values and probabilities in a generic lossless beamsplitter model.
        </p>

        <div class="callouts">
          <div class="card">
            <div class="label"><span class="pill warn"></span>Assumptions (explicit)</div>
            <ul style="margin:8px 0 0 18px;">
              <li>Ideal, planar, lossless beamsplitter with two output modes (one reflected, one transmitted).</li>
              <li>Same propagation medium on both sides (so <span style="font-family:var(--mono);">|k|</span> is unchanged for transmission; used in our plots). If indices differ, directions follow Snell’s law and <span style="font-family:var(--mono);">|k|</span> may change with medium.</li>
              <li>Single-frequency photon (sharp <span style="font-family:var(--mono);">ω</span>, sharp <span style="font-family:var(--mono);">|p|</span>).</li>
            </ul>
          </div>
        </div>

        <h3>Possible approaches (compare 2–3)</h3>
        <ul>
          <li><strong>Mode-operator (beam splitter matrix) approach:</strong> write the unitary transformation of input creation operators and infer output probabilities. <em>Best</em> for emphasizing superposition and probabilities.</li>
          <li><strong>Wavevector geometry approach:</strong> use conservation of tangential <span style="font-family:var(--mono);">k</span> and specular reflection to get <span style="font-family:var(--mono);">p_r, p_t</span>. <em>Best</em> for the momentum vectors.</li>
          <li><strong>Classical EM momentum flux:</strong> use radiation pressure ideas to compute momentum transfer. <em>Best</em> for average momentum exchange, but less direct for “possible measurement outcomes.”</li>
        </ul>
        <p>
          We’ll combine the <strong>wavevector geometry</strong> (to get the momentum vectors) with the <strong>unitary beamsplitter model</strong> (to get probabilities).
        </p>
      </section>

      <section id="part2">
        <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>
        <ol style="margin:8px 0 12px 22px;">
          <li>
            <strong>Set coordinates.</strong>
            Goal: define “normal” and “tangential” directions.
            Tool: planar-interface geometry.
            Meaning: lets us decompose momentum into components.
          </li>
          <li>
            <strong>Write incident momentum.</strong>
            Goal: express <span style="font-family:var(--mono);">p_i</span> in components using <span style="font-family:var(--mono);">p=ħk</span>.
            Meaning: a plane-wave photon has a definite momentum vector.
          </li>
          <li>
            <strong>Determine reflected direction.</strong>
            Goal: apply specular reflection rules to <span style="font-family:var(--mono);">k</span>.
            Tool: flip normal component, keep tangential component.
            Meaning: reflected photon momentum is another eigenvalue possibility.
          </li>
          <li>
            <strong>Determine transmitted direction.</strong>
            Goal: identify transmitted momentum (same direction if same medium).
            Meaning: transmission keeps momentum direction in this simplified model.
          </li>
          <li>
            <strong>Attach probabilities.</strong>
            Goal: assign <span style="font-family:var(--mono);">R=|r|²</span>, <span style="font-family:var(--mono);">T=|t|²</span>.
            Tool: lossless beamsplitter unitarity <span style="font-family:var(--mono);">R+T=1</span>.
          </li>
          <li>
            <strong>Compute momentum exchange (optional but insightful).</strong>
            Goal: find average momentum transferred to the beamsplitter.
            Tool: conditional momentum change × probability.
            Meaning: connects quantum outcomes to radiation pressure.
          </li>
        </ol>

        <div class="callouts">
          <div class="card">
            <div class="label"><span class="pill danger"></span>Common mistakes & quick tips</div>
            <ul style="margin:8px 0 0 18px;">
              <li><strong>Mistake:</strong> Saying “photon has half momentum after a 50/50 beamsplitter.” <strong>Tip:</strong> Momentum outcomes are discrete (reflected or transmitted); “half” appears only in <em>average</em> momentum transfer.</li>
              <li><strong>Mistake:</strong> Dropping the phase of <span style="font-family:var(--mono);">r</span>. <strong>Tip:</strong> Phase matters for interference (two-path experiments), though not for single-output probabilities.</li>
              <li><strong>Mistake:</strong> Flipping the wrong component. <strong>Tip:</strong> Only the component along the surface normal changes sign upon reflection.</li>
            </ul>
          </div>
        </div>
      </section>

      <section id="part3">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Physical intuition first (what should happen?)</h3>
        <p>
          A lossless beamsplitter has two “ports” (directions) for the photon to leave: it can go through (transmission)
          or bounce (reflection). Since the photon is a plane wave, each output corresponds to a definite propagation direction,
          hence a definite momentum vector. Quantum mechanics says the outgoing state is a superposition of these two possibilities,
          and a momentum-direction measurement will return either the transmitted momentum or the reflected momentum.
        </p>

        <h3>Step 1 — Coordinate system and incident wavevector</h3>
        <p>
          Choose a planar beamsplitter surface with a unit normal along <span style="font-family:var(--mono);">+x</span>.
          Let the plane of incidence be the <span style="font-family:var(--mono);">x–z</span> plane.
          The incidence angle <span style="font-family:var(--mono);">θ</span> is measured from the surface normal.
        </p>
        <p>
          For a plane wave in vacuum,
          <span style="font-family:var(--mono);">|k| = 2π/λ</span>
          and a single photon has momentum
          <span style="font-family:var(--mono);">p = ħk</span>.
        </p>

        <div class="eq" id="eq1">
          <button class="copyBtn" data-copy-target="eq1">Copy</button>
          <pre>Photon momentum (plane-wave mode):
p = ħ k
|p| = ħ|k| = ħ(2π/λ) = h/λ = ħω/c</pre>
        </div>

        <p>
          Decompose the incident wavevector (and momentum) into components:
        </p>

        <div class="eq" id="eq2">
          <button class="copyBtn" data-copy-target="eq2">Copy</button>
          <pre>Let |p| = p0.

Incident momentum components (plane of incidence x–z):
p_i = ( p0 cosθ ) x̂ + ( p0 sinθ ) ẑ
i.e., p_ix = p0 cosθ,  p_iz = p0 sinθ</pre>
        </div>

        <p>
          <strong>What we did:</strong> used geometry to resolve the momentum along the surface normal (<span style="font-family:var(--mono);">x̂</span>) and along the surface (here <span style="font-family:var(--mono);">ẑ</span>).
          <strong>Why:</strong> reflection/transmission act differently on normal vs tangential components.
        </p>

        <h3>Step 2 — Reflected momentum vector</h3>
        <p>
          For specular reflection at a planar interface:
        </p>
        <ul>
          <li>The tangential component (parallel to the surface) is unchanged.</li>
          <li>The normal component flips sign.</li>
        </ul>

        <div class="eq" id="eq3">
          <button class="copyBtn" data-copy-target="eq3">Copy</button>
          <pre>Reflected momentum (specular):
p_r = ( -p0 cosθ ) x̂ + ( +p0 sinθ ) ẑ</pre>
        </div>

        <p>
          <strong>What we did:</strong> applied “flip normal, keep tangential.”
          <strong>Why:</strong> the interface enforces translational symmetry along the surface, conserving tangential momentum.
        </p>

        <h3>Step 3 — Transmitted momentum vector</h3>
        <p>
          In the simplest beamsplitter model with the same medium on both sides (as assumed for our plots),
          transmission continues in the same direction as incidence:
        </p>

        <div class="eq" id="eq4">
          <button class="copyBtn" data-copy-target="eq4">Copy</button>
          <pre>Transmitted momentum (same medium):
p_t = ( +p0 cosθ ) x̂ + ( +p0 sinθ ) ẑ = p_i</pre>
        </div>

        <p>
          <strong>Note:</strong> If refractive indices differ, the transmitted direction changes by Snell’s law and
          the magnitude of <span style="font-family:var(--mono);">k</span> in the new medium becomes <span style="font-family:var(--mono);">|k| = n(2π/λ0)</span>.
          The “two possible outcomes” idea still holds; only the transmitted vector changes.
        </p>

        <h3>Step 4 — Quantum state after the beamsplitter and probabilities</h3>
        <p>
          A lossless beamsplitter acts as a <strong>unitary</strong> transformation between input and output modes.
          For a single input photon in one port, the outgoing state is a coherent superposition of the transmitted and reflected single-photon states:
        </p>

        <div class="eq" id="eq5">
          <button class="copyBtn" data-copy-target="eq5">Copy</button>
          <pre>Single-photon output state (one input port):
|ψ_out⟩ = t |1_t⟩ + r |1_r⟩

Probabilities:
P(transmit) = |t|² = T
P(reflect)  = |r|² = R
Lossless: R + T = 1</pre>
        </div>

        <p>
          <strong>Meaning:</strong> the photon does not split into “half a photon.” Instead, it is in a superposition of two distinct momentum eigenstates.
          When you measure which direction it goes (equivalently, its momentum direction), you obtain one of the two momenta:
          <span style="font-family:var(--mono);">p_t</span> with probability <span style="font-family:var(--mono);">T</span> or <span style="font-family:var(--mono);">p_r</span> with probability <span style="font-family:var(--mono);">R</span>.
        </p>

        <h3>Step 5 — Momentum exchange (the “kick” to the beamsplitter)</h3>
        <p>
          Momentum conservation says: the beamsplitter receives the opposite of the photon’s momentum change.
          Conditioned on reflection, the photon’s momentum changes from <span style="font-family:var(--mono);">p_i</span> to <span style="font-family:var(--mono);">p_r</span>:
        </p>

        <div class="eq" id="eq6">
          <button class="copyBtn" data-copy-target="eq6">Copy</button>
          <pre>Photon momentum change if reflected:
Δp_photon(reflect) = p_r − p_i
= [(-p0 cosθ) − (p0 cosθ)] x̂ + [(p0 sinθ) − (p0 sinθ)] ẑ
= ( -2 p0 cosθ ) x̂</pre>
        </div>

        <p>
          So the beamsplitter gains momentum
          <span style="font-family:var(--mono);">Δp_BS(reflect) = +2 p0 cosθ x̂</span>.
          If transmitted (same medium assumption), <span style="font-family:var(--mono);">p_t = p_i</span> so the momentum change is zero.
        </p>

        <p>
          Therefore, the <strong>average</strong> momentum delivered to the beamsplitter per incident photon is:
        </p>

        <div class="eq" id="eq7">
          <button class="copyBtn" data-copy-target="eq7">Copy</button>
          <pre>Average momentum transfer to the beamsplitter (per photon):
⟨Δp_BS⟩ = R (2 p0 cosθ) x̂ + T (0)
= (2 R p0 cosθ) x̂</pre>
        </div>

        <div class="callouts">
          <div class="card">
            <div class="label"><span class="pill ok"></span>Final Answer (boxed)</div>
            <div class="eq" id="finalAnswer" style="margin-top:10px;">
              <button class="copyBtn" data-copy-target="finalAnswer">Copy</button>
              <pre>Let the photon have wavelength λ (vacuum) and incidence angle θ from the surface normal.

Before the beamsplitter:
p_i = ħk,  with |k| = 2π/λ, so |p| = p0 = h/λ,
p_i = (p0 cosθ) x̂ + (p0 sinθ) ẑ.

After a lossless beamsplitter (two possible outcomes):
1) Transmitted momentum: p_t = ( +p0 cosθ ) x̂ + ( +p0 sinθ ) ẑ  (same direction as incident)
   Probability: P(p_t) = T = |t|².

2) Reflected momentum (specular): p_r = ( -p0 cosθ ) x̂ + ( +p0 sinθ ) ẑ
   Probability: P(p_r) = R = |r|².

Lossless condition: R + T = 1.

(Insight) Average momentum delivered to the beamsplitter per photon:
⟨Δp_BS⟩ = (2 R p0 cosθ) x̂.</pre>
            </div>
          </div>
        </div>

        <h3>Sanity checks</h3>
        <ul>
          <li><strong>Units:</strong> <span style="font-family:var(--mono);">p0 = h/λ</span> has units of (J·s)/m = kg·m/s ✓</li>
          <li><strong>Limiting cases:</strong>
            <ul>
              <li><span style="font-family:var(--mono);">R=1</span> ⇒ always reflect, beamsplitter gets <span style="font-family:var(--mono);">2p0 cosθ</span> along normal ✓</li>
              <li><span style="font-family:var(--mono);">R=0</span> ⇒ always transmit, average transfer 0 ✓</li>
              <li><span style="font-family:var(--mono);">θ=90°</span> (grazing) ⇒ <span style="font-family:var(--mono);">cosθ→0</span>, vanishing normal momentum kick ✓</li>
            </ul>
          </li>
          <li><strong>Direction:</strong> reflection reverses the normal component, so momentum change points along <span style="font-family:var(--mono);">−x̂</span> for the photon and <span style="font-family:var(--mono);">+x̂</span> for the beamsplitter ✓</li>
        </ul>

        <p>
          <strong>Connection to the diagram and plots:</strong>
          In the diagram, the incident and transmitted arrows point to the right (positive normal component),
          while the reflected arrow points to the left (negative normal component).
          The main plot shows how the average normal momentum transfer <span style="font-family:var(--mono);">⟨Δp_BS⟩</span> scales like <span style="font-family:var(--mono);">cosθ</span> and is proportional to reflectivity <span style="font-family:var(--mono);">R</span>.
        </p>
      </section>

      <section id="part4">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpreting the final formulas</h3>
        <ul>
          <li><span style="font-family:var(--mono);">p0 = h/λ</span> sets the overall momentum scale: shorter wavelength → bigger photon momentum.</li>
          <li><span style="font-family:var(--mono);">cosθ</span> is the fraction of momentum along the surface normal; only that component reverses in reflection.</li>
          <li><span style="font-family:var(--mono);">R</span> determines how often the “momentum-flip” event occurs; it multiplies the kick in the average.</li>
        </ul>

        <h3>How parameter changes affect outcomes (connect to plots)</h3>
        <ul>
          <li>Increasing <span style="font-family:var(--mono);">R</span> increases the reflection probability and increases average momentum transfer linearly.</li>
          <li>Increasing <span style="font-family:var(--mono);">θ</span> (more grazing) reduces <span style="font-family:var(--mono);">cosθ</span>, shrinking the normal momentum kick.</li>
          <li>The two possible momentum vectors always have the same magnitude <span style="font-family:var(--mono);">p0</span> (in the same-medium model); only the direction changes.</li>
        </ul>

        <h3>An alternative derivation idea (brief)</h3>
        <p>
          You can derive the probabilities and superposition using the standard beamsplitter unitary matrix acting on mode creation operators:
          <span style="font-family:var(--mono);">â_out = t â_in + r b̂_in</span>, etc.
          With vacuum in the second input port, a single photon in the first port transforms into
          <span style="font-family:var(--mono);">t|1,0⟩ + r|0,1⟩</span>, giving the same <span style="font-family:var(--mono);">|t|²</span> and <span style="font-family:var(--mono);">|r|²</span>.
          Geometry then maps each output port to its corresponding momentum vector.
        </p>

        <h3>Concept checks (quick self-test)</h3>
        <ul>
          <li><strong>Q:</strong> After a 50/50 beamsplitter, does the photon have momentum magnitude <span style="font-family:var(--mono);">p0/2</span>? <strong>A:</strong> No. It has magnitude <span style="font-family:var(--mono);">p0</span> in either outcome; only the <em>average</em> momentum transfer involves the factor 1/2.</li>
          <li><strong>Q:</strong> Which momentum component changes sign on reflection? <strong>A:</strong> The component along the surface normal.</li>
          <li><strong>Q:</strong> What does “lossless” enforce on <span style="font-family:var(--mono);">R</span> and <span style="font-family:var(--mono);">T</span>? <strong>A:</strong> <span style="font-family:var(--mono);">R+T=1</span>.</li>
          <li><strong>Q:</strong> Why can reflection and transmission interfere in some setups? <strong>A:</strong> Because the output state is a coherent superposition with a definite relative phase between <span style="font-family:var(--mono);">r</span> and <span style="font-family:var(--mono);">t</span>.</li>
        </ul>
      </section>

      <section id="part5">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>
        <p>
          The interactive graphics below use <strong>example values</strong> for wavelength (default <span style="font-family:var(--mono);">λ = 800 nm</span>) purely to put numbers on the vertical axis.
          The symbolic results above remain the real “answer.”
        </p>
        <ul>
          <li><strong>Diagram canvas:</strong> shows the planar beamsplitter (vertical line), the incident ray, and the two possible output rays. Labels show <span style="font-family:var(--mono);">p_i</span>, <span style="font-family:var(--mono);">p_t</span>, <span style="font-family:var(--mono);">p_r</span>, and angle <span style="font-family:var(--mono);">θ</span>.</li>
          <li><strong>Main plot:</strong> graphs average normal momentum transferred to the beamsplitter per photon:
            <span style="font-family:var(--mono);">⟨Δp_BS⟩ = 2 R (h/λ) cosθ</span>, vs <span style="font-family:var(--mono);">θ</span>.
          </li>
          <li><strong>Secondary plot:</strong> displays the probabilities <span style="font-family:var(--mono);">R</span> and <span style="font-family:var(--mono);">T=1−R</span> as a bar chart.</li>
          <li><strong>Controls:</strong>
            <ul>
              <li><span style="font-family:var(--mono);">θ</span> slider changes the geometry (direction components) and the <span style="font-family:var(--mono);">cosθ</span> factor, updating all canvases.</li>
              <li><span style="font-family:var(--mono);">R</span> slider changes the split ratio; it updates the probability bars and rescales the average momentum-transfer curve.</li>
            </ul>
          </li>
        </ul>
      </section>
    </div>

    <div class="vizWrap" aria-label="Interactive visualizations">
      <div class="controls">
        <div class="control">
          <label for="theta">
            Incidence angle <span style="font-family:var(--mono);">θ</span> (deg)
            <span class="readout" id="thetaOut">30.0°</span>
          </label>
          <input id="theta" type="range" min="0" max="80" step="0.1" value="30">
        </div>

        <div class="control">
          <label for="R">
            Reflectivity <span style="font-family:var(--mono);">R = |r|²</span>
            <span class="readout" id="ROut">0.50</span>
          </label>
          <input id="R" type="range" min="0" max="1" step="0.01" value="0.50">
        </div>

        <div class="control">
          <label for="lambda">
            Example wavelength <span style="font-family:var(--mono);">λ</span> (nm)
            <span class="readout" id="lambdaOut">800 nm</span>
          </label>
          <input id="lambda" type="range" min="400" max="1600" step="10" value="800">
        </div>
      </div>

      <div class="vizGrid">
        <figure class="wide">
          <canvas id="diagram" height="320"></canvas>
          <figcaption><strong>Diagram:</strong> incident photon and the two possible output modes at a planar beamsplitter.</figcaption>
        </figure>

        <figure>
          <canvas id="mainPlot" height="320"></canvas>
          <figcaption><strong>Main plot:</strong> average normal momentum transfer per photon, ⟨Δp<sub>BS</sub>⟩ vs θ (example λ).</figcaption>
        </figure>

        <figure>
          <canvas id="probPlot" height="320"></canvas>
          <figcaption><strong>Secondary plot:</strong> probabilities of outcomes: reflection (R) and transmission (T=1−R).</figcaption>
        </figure>
      </div>

      <div class="noteRow">
        <div class="note">
          <strong>Interpretation tip:</strong> The photon’s momentum is not “partly reflected and partly transmitted” in a single run.
          The <em>state</em> is a superposition, but a momentum-direction measurement yields one full momentum vector.
        </div>
        <div class="note">
          <strong>Numerical scale:</strong> Momentum is tiny (≈10⁻²⁷ kg·m/s for optical photons). The plots show this scale for intuition; the symbolic dependence is the key physics.
        </div>
      </div>
    </div>
  </article>
</main>

<footer>
  <div class="hr"></div>
  <div>
    Built as a self-contained learning article: vanilla HTML/CSS/JS, no external libraries.
    The visuals use example numerical values where the problem statement is symbolic.
  </div>
</footer>

<script>
(function(){
  // ---------- Utilities ----------
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  function copyFromEq(id){
    const el = document.getElementById(id);
    if(!el) return;
    const pre = el.querySelector('pre');
    const text = pre ? pre.innerText : el.innerText;
    navigator.clipboard.writeText(text).then(()=>{
      // tiny feedback
      const btn = el.querySelector('.copyBtn');
      if(btn){
        const old = btn.textContent;
        btn.textContent = "Copied!";
        setTimeout(()=>btn.textContent = old, 900);
      }
    }).catch(()=>{});
  }

  document.querySelectorAll('.copyBtn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const id = btn.getAttribute('data-copy-target');
      copyFromEq(id);
    });
  });

  // Smooth scroll for TOC
  document.querySelectorAll('nav.toc a').forEach(a=>{
    a.addEventListener('click', (e)=>{
      const href = a.getAttribute('href');
      if(href && href.startsWith('#')){
        e.preventDefault();
        const target = document.querySelector(href);
        if(target) target.scrollIntoView({behavior:'smooth', block:'start'});
      }
    });
  });

  // ---------- Physical constants (SI) ----------
  const h = 6.62607015e-34;     // J*s
  const c = 299792458;          // m/s

  // ---------- Canvas helpers ----------
  function setupCanvas(canvas){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(2, Math.floor(rect.width * dpr));
    const hpx = Math.max(2, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== hpx){
      canvas.width = w; canvas.height = hpx;
    }
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return {ctx, dpr, wCSS: rect.width, hCSS: rect.height};
  }

  function drawGrid(ctx, x0,y0,w,h, xTicks, yTicks){
    ctx.save();
    ctx.globalAlpha = 0.85;

    // Background panel
    ctx.fillStyle = "rgba(0,0,0,0.10)";
    ctx.fillRect(x0,y0,w,h);

    // Gridlines
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i=0;i<=xTicks;i++){
      const x = x0 + (w*i/xTicks);
      ctx.moveTo(x, y0);
      ctx.lineTo(x, y0+h);
    }
    for(let j=0;j<=yTicks;j++){
      const y = y0 + (h*j/yTicks);
      ctx.moveTo(x0, y);
      ctx.lineTo(x0+w, y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawAxes(ctx, plot){
    const {x0,y0,w,h} = plot;
    ctx.save();
    ctx.strokeStyle = "rgba(233,236,255,0.75)";
    ctx.lineWidth = 1.25;
    ctx.beginPath();
    ctx.moveTo(x0, y0+h);
    ctx.lineTo(x0+w, y0+h);
    ctx.moveTo(x0, y0);
    ctx.lineTo(x0, y0+h);
    ctx.stroke();
    ctx.restore();
  }

  function drawText(ctx, txt, x,y, color="rgba(233,236,255,0.92)", size=12, align="left", baseline="alphabetic", font="system-ui"){
    ctx.save();
    ctx.fillStyle = color;
    ctx.font = `${size}px ${font}`;
    ctx.textAlign = align;
    ctx.textBaseline = baseline;
    ctx.fillText(txt, x, y);
    ctx.restore();
  }

  function niceNumber(x){
    // crude, for tick labels
    if(x === 0) return "0";
    const abs = Math.abs(x);
    if(abs >= 1e-24) return x.toExponential(2);
    if(abs >= 1e-12) return x.toExponential(2);
    return x.toExponential(2);
  }

  function arrow(ctx, x1,y1,x2,y2, color="rgba(124,240,200,0.95)", width=2){
    const dx = x2-x1, dy = y2-y1;
    const L = Math.hypot(dx,dy) || 1;
    const ux = dx/L, uy = dy/L;
    const head = 10;
    ctx.save();
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = width;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
    // head
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2 - head*(ux) + head*0.55*(-uy), y2 - head*(uy) + head*0.55*(ux));
    ctx.lineTo(x2 - head*(ux) - head*0.55*(-uy), y2 - head*(uy) - head*0.55*(ux));
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // ---------- State ----------
  const dom = {
    theta: document.getElementById('theta'),
    R: document.getElementById('R'),
    lambda: document.getElementById('lambda'),
    thetaOut: document.getElementById('thetaOut'),
    ROut: document.getElementById('ROut'),
    lambdaOut: document.getElementById('lambdaOut'),
    diagram: document.getElementById('diagram'),
    mainPlot: document.getElementById('mainPlot'),
    probPlot: document.getElementById('probPlot')
  };

  function getState(){
    const thetaDeg = parseFloat(dom.theta.value);
    const R = parseFloat(dom.R.value);
    const lambdaNm = parseFloat(dom.lambda.value);
    const lambda = lambdaNm * 1e-9;
    const p0 = h / lambda; // magnitude (vacuum)
    return {thetaDeg, theta: thetaDeg*Math.PI/180, R, T: 1-R, lambdaNm, lambda, p0};
  }

  function updateReadouts(st){
    dom.thetaOut.textContent = `${st.thetaDeg.toFixed(1)}°`;
    dom.ROut.textContent = st.R.toFixed(2);
    dom.lambdaOut.textContent = `${Math.round(st.lambdaNm)} nm`;
  }

  // ---------- Diagram ----------
  function drawDiagram(st){
    const {ctx, wCSS, hCSS} = setupCanvas(dom.diagram);
    ctx.clearRect(0,0,wCSS,hCSS);

    // Title
    drawText(ctx, "Planar Beamsplitter Geometry", 14, 18, "rgba(233,236,255,0.92)", 14, "left", "alphabetic", "system-ui");

    const pad = 16;
    const x0 = pad, y0 = 34;
    const w = wCSS - 2*pad;
    const h = hCSS - y0 - pad;

    // draw subtle grid (for crispness)
    drawGrid(ctx, x0, y0, w, h, 8, 6);

    // Beamsplitter plane: vertical line at center
    const xBS = x0 + 0.55*w;
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.55)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(xBS, y0+8);
    ctx.lineTo(xBS, y0+h-8);
    ctx.stroke();
    ctx.restore();

    drawText(ctx, "Beamsplitter", xBS+8, y0+18, "rgba(184,192,255,0.95)", 12);

    // coordinate axes (x normal to right, z up)
    const ox = x0 + 0.18*w;
    const oy = y0 + 0.80*h;
    arrow(ctx, ox, oy, ox+70, oy, "rgba(124,184,255,0.9)", 2);
    arrow(ctx, ox, oy, ox, oy-70, "rgba(124,184,255,0.9)", 2);
    drawText(ctx, "x (normal)", ox+72, oy+4, "rgba(184,192,255,0.95)", 11, "left", "top");
    drawText(ctx, "z (tangent)", ox-6, oy-74, "rgba(184,192,255,0.95)", 11, "right", "top");

    // Rays
    const theta = st.theta;
    // define a nominal incident direction: from left toward beamsplitter, angled upward by theta in x-z plane
    const dirInc = {x: Math.cos(theta), z: Math.sin(theta)};
    const dirRef = {x: -Math.cos(theta), z: Math.sin(theta)};
    const dirTrn = {x: Math.cos(theta), z: Math.sin(theta)};

    // mapping: x -> horizontal, z -> vertical (up is negative y)
    function mapPoint(px,pz){
      return {X: xBS + px, Y: oy - pz};
    }

    const origin = mapPoint(0,0);

    // incident start point
    const L = 220;
    const incStart = mapPoint(-L*dirInc.x, -L*dirInc.z);
    const refEnd  = mapPoint(+L*dirRef.x, +L*dirRef.z);
    const trnEnd  = mapPoint(+L*dirTrn.x, +L*dirTrn.z);

    // draw rays
    arrow(ctx, incStart.X, incStart.Y, origin.X, origin.Y, "rgba(124,240,200,0.95)", 2.4);
    arrow(ctx, origin.X, origin.Y, trnEnd.X, trnEnd.Y, "rgba(124,184,255,0.95)", 2.4);
    arrow(ctx, origin.X, origin.Y, refEnd.X, refEnd.Y, "rgba(255,209,102,0.95)", 2.4);

    drawText(ctx, "incident pᵢ", lerp(incStart.X, origin.X, 0.55), lerp(incStart.Y, origin.Y, 0.55)-10, "rgba(200,255,240,0.95)", 12);
    drawText(ctx, "transmitted pₜ", lerp(origin.X, trnEnd.X, 0.55)+2, lerp(origin.Y, trnEnd.Y, 0.55)-10, "rgba(184,210,255,0.95)", 12);
    drawText(ctx, "reflected pᵣ", lerp(origin.X, refEnd.X, 0.55)-2, lerp(origin.Y, refEnd.Y, 0.55)-10, "rgba(255,230,165,0.95)", 12, "right");

    // angle arc at origin
    const arcR = 42;
    const startAng = 0;         // along +x
    const endAng = -theta;      // rotate toward incident ray (which comes from left; direction into origin is +dirInc)
    // The ray direction at origin is +dirInc, which makes +theta above +x. In screen y is down, so use -theta.
    ctx.save();
    ctx.strokeStyle = "rgba(233,236,255,0.65)";
    ctx.lineWidth = 1.6;
    ctx.beginPath();
    ctx.arc(origin.X, origin.Y, arcR, startAng, endAng, true);
    ctx.stroke();
    ctx.restore();
    drawText(ctx, "θ", origin.X + arcR*0.8, origin.Y - arcR*0.28, "rgba(233,236,255,0.85)", 14, "left", "middle");

    // probabilities label
    const boxX = x0 + 0.02*w;
    const boxY = y0 + 0.10*h;
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.20)";
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    roundRect(ctx, boxX, boxY, 240, 78, 14);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    drawText(ctx, `R = ${st.R.toFixed(2)}   (reflect)`, boxX+12, boxY+28, "rgba(255,230,165,0.95)", 12, "left", "middle");
    drawText(ctx, `T = ${st.T.toFixed(2)}   (transmit)`, boxX+12, boxY+52, "rgba(184,210,255,0.95)", 12, "left", "middle");

    // small numeric momentum readout
    const pStr = (st.p0).toExponential(2);
    drawText(ctx, `|p| = h/λ = ${pStr} kg·m/s (example)`, x0+10, y0+h-10, "rgba(184,192,255,0.92)", 12, "left", "bottom");

    // helper: rounded rectangle path
    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
  }

  // ---------- Main plot: <Δp_BS> vs θ ----------
  function drawMainPlot(st){
    const {ctx, wCSS, hCSS} = setupCanvas(dom.mainPlot);
    ctx.clearRect(0,0,wCSS,hCSS);

    // Layout
    const padL = 58, padR = 16, padT = 34, padB = 48;
    const x0 = padL, y0 = padT;
    const w = wCSS - padL - padR;
    const h = hCSS - padT - padB;

    drawText(ctx, "Average Normal Momentum Transfer per Photon", 14, 18, "rgba(233,236,255,0.92)", 14);

    // Plot region grid + axes
    drawGrid(ctx, x0, y0, w, h, 8, 6);
    drawAxes(ctx, {x0,y0,w,h});

    // Data: Δp = 2 R p0 cosθ
    const thetaMax = 80 * Math.PI/180;
    const yMax = 2 * Math.max(0.001, st.R) * st.p0 * Math.cos(0); // at θ=0
    const yMin = 0;

    function xMap(thetaDeg){
      return x0 + (thetaDeg/80) * w;
    }
    function yMap(val){
      const t = (val - yMin) / (yMax - yMin + 1e-40);
      return y0 + h * (1 - clamp(t,0,1));
    }

    // ticks
    ctx.save();
    ctx.fillStyle = "rgba(233,236,255,0.85)";
    ctx.font = "12px system-ui";

    // x ticks
    for(let i=0;i<=8;i++){
      const td = i*10; // degrees
      const x = xMap(td);
      ctx.strokeStyle = "rgba(233,236,255,0.35)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, y0+h);
      ctx.lineTo(x, y0+h+6);
      ctx.stroke();
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(String(td), x, y0+h+8);
    }

    // y ticks
    for(let j=0;j<=6;j++){
      const frac = j/6;
      const val = lerp(yMin, yMax, 1-frac);
      const y = y0 + h*frac;
      ctx.strokeStyle = "rgba(233,236,255,0.35)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x0-6, y);
      ctx.lineTo(x0, y);
      ctx.stroke();
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      ctx.fillText(niceNumber(val), x0-8, y);
    }
    ctx.restore();

    // axis labels
    drawText(ctx, "θ (degrees)", x0 + w/2, y0+h+38, "rgba(184,192,255,0.95)", 13, "center", "bottom");
    // rotated y label
    ctx.save();
    ctx.translate(16, y0 + h/2);
    ctx.rotate(-Math.PI/2);
    drawText(ctx, "⟨Δp_BS⟩ along normal (kg·m/s)", 0, 0, "rgba(184,192,255,0.95)", 13, "center", "middle");
    ctx.restore();

    // curve
    ctx.save();
    ctx.strokeStyle = "rgba(124,240,200,0.95)";
    ctx.lineWidth = 2.6;
    ctx.beginPath();
    const N = 400;
    for(let i=0;i<=N;i++){
      const td = 80*i/N;
      const th = td*Math.PI/180;
      const yVal = 2 * st.R * st.p0 * Math.cos(th);
      const X = xMap(td);
      const Y = yMap(yVal);
      if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
    }
    ctx.stroke();
    ctx.restore();

    // highlight current theta point
    const yNow = 2 * st.R * st.p0 * Math.cos(st.theta);
    const xNow = xMap(st.thetaDeg);
    const yNowPx = yMap(yNow);

    ctx.save();
    ctx.fillStyle = "rgba(124,240,200,0.95)";
    ctx.beginPath();
    ctx.arc(xNow, yNowPx, 4.5, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // legend and formula
    const legendX = x0 + 10;
    const legendY = y0 + 12;
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.22)";
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    roundRect(ctx, legendX, legendY, Math.min(340, w-20), 72, 14);
    ctx.fill(); ctx.stroke();
    ctx.restore();

    // legend line
    ctx.save();
    ctx.strokeStyle = "rgba(124,240,200,0.95)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(legendX+14, legendY+24);
    ctx.lineTo(legendX+42, legendY+24);
    ctx.stroke();
    ctx.restore();

    drawText(ctx, "⟨Δp_BS⟩ = 2 R (h/λ) cosθ  (example λ)", legendX+52, legendY+27, "rgba(233,236,255,0.92)", 12, "left", "middle");
    drawText(ctx, `Current: θ=${st.thetaDeg.toFixed(1)}°, R=${st.R.toFixed(2)} ⇒ ⟨Δp_BS⟩=${yNow.toExponential(2)} kg·m/s`,
             legendX+14, legendY+52, "rgba(184,192,255,0.95)", 12, "left", "middle");

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
  }

  // ---------- Secondary plot: probability bars ----------
  function drawProbPlot(st){
    const {ctx, wCSS, hCSS} = setupCanvas(dom.probPlot);
    ctx.clearRect(0,0,wCSS,hCSS);

    drawText(ctx, "Outcome Probabilities (Lossless: R + T = 1)", 14, 18, "rgba(233,236,255,0.92)", 14);

    const padL = 52, padR = 16, padT = 34, padB = 48;
    const x0 = padL, y0 = padT;
    const w = wCSS - padL - padR;
    const h = hCSS - padT - padB;

    drawGrid(ctx, x0, y0, w, h, 6, 5);
    drawAxes(ctx, {x0,y0,w,h});

    // y mapping for probability 0..1
    function yMap(p){ return y0 + h*(1 - clamp(p,0,1)); }
    // x positions
    const barW = w*0.22;
    const gap = w*0.16;
    const xR = x0 + w*0.22;
    const xT = xR + barW + gap;

    // y ticks
    ctx.save();
    ctx.fillStyle = "rgba(233,236,255,0.85)";
    ctx.font = "12px system-ui";
    for(let j=0;j<=5;j++){
      const p = j/5;
      const y = yMap(p);
      ctx.strokeStyle = "rgba(233,236,255,0.35)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x0-6, y);
      ctx.lineTo(x0, y);
      ctx.stroke();
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      ctx.fillText(p.toFixed(1), x0-8, y);
    }
    ctx.restore();

    // axis labels
    drawText(ctx, "Probability", 18, y0 + h/2, "rgba(184,192,255,0.95)", 13, "center", "middle", "system-ui");
    ctx.save();
    ctx.translate(18, y0 + h/2);
    ctx.rotate(-Math.PI/2);
    drawText(ctx, "Probability", 0, 0, "rgba(184,192,255,0.95)", 13, "center", "middle");
    ctx.restore();

    drawText(ctx, "Outcome", x0 + w/2, y0+h+38, "rgba(184,192,255,0.95)", 13, "center", "bottom");

    // Bars
    function bar(x, p, fill, label){
      const y = yMap(p);
      const hBar = (y0+h) - y;
      ctx.save();
      ctx.fillStyle = fill;
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      roundRect(ctx, x, y, barW, hBar, 10);
      ctx.fill(); ctx.stroke();
      ctx.restore();

      drawText(ctx, label, x + barW/2, y0+h+10, "rgba(233,236,255,0.90)", 12, "center", "top");
      drawText(ctx, p.toFixed(2), x + barW/2, y-8, "rgba(233,236,255,0.92)", 12, "center", "bottom", "ui-monospace");
    }

    bar(xR, st.R, "rgba(255,209,102,0.85)", "Reflect (R)");
    bar(xT, st.T, "rgba(124,184,255,0.85)", "Transmit (T)");

    // Short legend / reminder
    const infoX = x0 + 10, infoY = y0 + 10;
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.22)";
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    roundRect(ctx, infoX, infoY, Math.min(320, w-20), 60, 14);
    ctx.fill(); ctx.stroke();
    ctx.restore();

    drawText(ctx, "Lossless condition: R + T = 1", infoX+12, infoY+26, "rgba(233,236,255,0.92)", 12, "left", "middle");
    drawText(ctx, "P(pᵣ)=R,  P(pₜ)=T", infoX+12, infoY+48, "rgba(184,192,255,0.95)", 12, "left", "middle");

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
  }

  // ---------- Render ----------
  function render(){
    const st = getState();
    updateReadouts(st);
    drawDiagram(st);
    drawMainPlot(st);
    drawProbPlot(st);
  }

  // events
  ["input","change"].forEach(ev=>{
    dom.theta.addEventListener(ev, render);
    dom.R.addEventListener(ev, render);
    dom.lambda.addEventListener(ev, render);
  });

  window.addEventListener('resize', render);

  // initial
  render();
})();
</script>
</body>
</html>
