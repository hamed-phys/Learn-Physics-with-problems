<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Mean & Variance of the Doubly Stochastic (Cox) Poisson Distribution</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#111827;
      --card:#0f172a;
      --ink:#e5e7eb;
      --muted:#9ca3af;
      --accent:#60a5fa;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 16px 40px rgba(0,0,0,.35);
      --radius:18px;
      --radius2:22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(96,165,250,.16), transparent 55%),
        radial-gradient(1000px 700px at 80% 25%, rgba(167,139,250,.14), transparent 55%),
        radial-gradient(900px 650px at 50% 90%, rgba(52,211,153,.10), transparent 55%),
        var(--bg);
      line-height:1.55;
    }

    header{
      padding:28px 18px 10px;
      max-width:1200px;
      margin:0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:18px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns:1fr}
    }

    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--radius2);
      padding:20px 18px;
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .titleCard:before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(900px 260px at 30% 0%, rgba(96,165,250,.24), transparent 60%),
        radial-gradient(800px 260px at 80% 10%, rgba(167,139,250,.18), transparent 60%);
      pointer-events:none;
      filter: blur(.2px);
      opacity:.9;
    }
    .titleCard > *{position:relative}
    h1{
      margin:0 0 8px;
      font-size: clamp(1.55rem, 2.3vw, 2.15rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      max-width:70ch;
    }
    .metaRow{
      margin-top:14px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
    }
    .pill{
      font-size:.86rem;
      padding:6px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.06);
      border:1px solid var(--line);
      color:var(--muted);
    }
    .pill b{color:var(--ink); font-weight:650}

    .tocCard{
      background: rgba(17,24,39,.78);
      border:1px solid var(--line);
      border-radius: var(--radius2);
      padding:16px 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      position:sticky;
      top:12px;
      align-self:start;
      max-height: calc(100vh - 24px);
      overflow:auto;
    }
    .tocCard h2{
      font-size:1rem;
      margin:0 0 8px;
      color:var(--ink);
      letter-spacing:.2px;
    }
    .tocCard a{
      display:block;
      color:var(--muted);
      text-decoration:none;
      padding:6px 8px;
      border-radius:10px;
      border:1px solid transparent;
      transition: transform .08s ease, background .2s ease, color .2s ease;
      font-size:.95rem;
    }
    .tocCard a:hover{
      color:var(--ink);
      background:rgba(255,255,255,.06);
      border-color:rgba(255,255,255,.10);
      transform: translateY(-1px);
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding:12px 18px 54px;
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:18px;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
      .tocCard{position:relative; top:auto}
    }

    section{
      background: rgba(15,23,42,.72);
      border:1px solid var(--line);
      border-radius: var(--radius2);
      padding:18px 18px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    section h2{
      margin:0 0 10px;
      font-size:1.25rem;
      letter-spacing:.2px;
    }
    section h3{
      margin:16px 0 8px;
      font-size:1.06rem;
      color:#dbeafe;
      letter-spacing:.2px;
    }
    p{margin:10px 0; color:var(--ink)}
    ul{margin:10px 0 10px 22px; color:var(--ink)}
    li{margin:6px 0}
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 720px){
      .grid2{grid-template-columns:1fr}
    }

    .callout{
      border-radius:16px;
      padding:12px 12px;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      position:relative;
      overflow:hidden;
    }
    .callout:before{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(700px 220px at 15% 0%, rgba(96,165,250,.14), transparent 55%);
      pointer-events:none;
      opacity:.85;
    }
    .callout > *{position:relative}
    .callout .label{
      display:inline-flex;
      gap:8px;
      align-items:center;
      font-weight:700;
      font-size:.92rem;
      color:#e0f2fe;
      margin-bottom:6px;
    }
    .labelDot{
      width:10px; height:10px; border-radius:999px;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(96,165,250,.15);
    }
    .callout.warn:before{background: radial-gradient(700px 220px at 15% 0%, rgba(251,191,36,.16), transparent 55%)}
    .callout.warn .labelDot{background: var(--warn); box-shadow: 0 0 0 4px rgba(251,191,36,.14)}
    .callout.good:before{background: radial-gradient(700px 220px at 15% 0%, rgba(52,211,153,.14), transparent 55%)}
    .callout.good .labelDot{background: var(--good); box-shadow: 0 0 0 4px rgba(52,211,153,.14)}
    .callout.bad:before{background: radial-gradient(700px 220px at 15% 0%, rgba(251,113,133,.14), transparent 55%)}
    .callout.bad .labelDot{background: var(--bad); box-shadow: 0 0 0 4px rgba(251,113,133,.14)}

    .eqCard{
      border-radius:16px;
      padding:12px 12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(2,6,23,.55);
      overflow:hidden;
    }
    .eqRow{
      display:flex; gap:10px; align-items:flex-start; justify-content:space-between;
      flex-wrap:wrap;
    }
    .eq{
      font-family: var(--mono);
      font-size: .98rem;
      color:#e5e7eb;
      white-space: pre-wrap;
      line-height:1.35;
      margin:0;
    }
    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--ink);
      padding:7px 10px;
      border-radius:12px;
      cursor:pointer;
      font-weight:650;
      font-size:.86rem;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
      user-select:none;
    }
    .btn:hover{transform: translateY(-1px); background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.18)}
    .btn:active{transform: translateY(0px)}
    .btn.small{padding:6px 9px; font-size:.84rem}
    .btn.primary{
      border-color: rgba(96,165,250,.35);
      background: rgba(96,165,250,.14);
    }
    .btn.primary:hover{background: rgba(96,165,250,.20)}

    .vizWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .canvasCard{
      background: rgba(2,6,23,.55);
      border:1px solid rgba(255,255,255,.12);
      border-radius: var(--radius2);
      padding:12px;
      overflow:hidden;
    }
    .canvasHead{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:10px;
      margin-bottom:8px;
      flex-wrap:wrap;
    }
    .canvasTitle{
      margin:0;
      font-size:1.02rem;
      letter-spacing:.2px;
      color:#e0f2fe;
    }
    .canvasSub{
      margin:2px 0 0;
      font-size:.88rem;
      color:var(--muted);
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius:16px;
      background: rgba(15,23,42,.55);
      border:1px solid rgba(255,255,255,.08);
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin:10px 0 0;
    }
    @media (max-width: 720px){
      .controls{grid-template-columns:1fr}
    }
    .control{
      padding:10px 10px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-weight:700;
      font-size:.92rem;
      color:#e5e7eb;
      margin-bottom:6px;
    }
    .control .val{
      font-family:var(--mono);
      color:#dbeafe;
      font-weight:750;
    }
    input[type="range"]{width:100%}
    select{
      width:100%;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(2,6,23,.35);
      color: var(--ink);
      font-weight:650;
    }

    .twoCol{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      align-items:start;
    }
    @media (max-width: 980px){
      .twoCol{grid-template-columns:1fr}
    }

    .hr{
      height:1px;
      background: rgba(255,255,255,.10);
      margin:14px 0;
    }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding:0 18px 28px;
      color:var(--muted);
      font-size:.92rem;
    }

    /* Subtle entrance */
    .fadeIn{
      animation: pop .5s ease both;
    }
    @keyframes pop{
      from{opacity:0; transform: translateY(6px)}
      to{opacity:1; transform: translateY(0)}
    }

    /* Print */
    @media print{
      body{background:#fff; color:#000}
      header, main, section, .tocCard, .titleCard{box-shadow:none; backdrop-filter:none}
      .tocCard{position:relative; top:auto}
      .btn, .controls{display:none !important}
      canvas{border:1px solid #999}
      section{background:#fff; border:1px solid #ccc}
      .titleCard{background:#fff; border:1px solid #ccc}
    }
  </style>
</head>
<body>
  <header class="fadeIn">
    <div class="hero">
      <div class="titleCard">
        <h1>Mean &amp; Variance of the Doubly Stochastic Poisson (Cox) Distribution</h1>
        <p class="subtitle">
          In photon counting and many “random-rate” arrival processes, the count <span class="muted">n</span> is Poisson
          only <em>conditional</em> on a random mean <span class="muted">w</span>. We prove the classic results
          <span class="muted">E[n]=E[w]</span> and <span class="muted">Var(n)=E[w]+Var(w)</span>.
        </p>
        <div class="metaRow">
          <span class="pill"><b>Model:</b> n|w ~ Poisson(w)</span>
          <span class="pill"><b>Tool:</b> total expectation/variance</span>
          <span class="pill"><b>Physics lens:</b> intensity fluctuations → excess noise</span>
        </div>
      </div>

      <nav class="tocCard" aria-label="Table of Contents">
        <h2>Table of Contents</h2>
        <a href="#quick">Quick Summary</a>
        <a href="#part0">PART 0 — Concept Primer</a>
        <a href="#part1">PART 1 — Problem Analysis</a>
        <a href="#part2">PART 2 — Strategy &amp; Tips</a>
        <a href="#part3">PART 3 — Full Solution</a>
        <a href="#part4">PART 4 — Deeper Understanding</a>
        <a href="#part5">PART 5 — Visualization Guide</a>
      </nav>
    </div>
  </header>

  <main>
    <!-- Left column: teaching text -->
    <article style="display:grid; gap:18px;">
      <section id="quick" class="fadeIn">
        <h2>Quick Summary</h2>
        <ul>
          <li><b>What this is about:</b> a <em>doubly stochastic Poisson</em> (a.k.a. Cox) model where the Poisson mean is itself random.</li>
          <li><b>Key physics idea:</b> photon arrivals are Poisson <em>given</em> an intensity, but the intensity can fluctuate from realization to realization.</li>
          <li><b>Governing conditional law:</b> <span class="muted">n | w ~ Poisson(w)</span>, where <span class="muted">w</span> is a nonnegative random variable (mean count in the observation window).</li>
          <li><b>Core mathematical tools:</b> law of total expectation and law of total variance.</li>
          <li><b>Main results (symbolic):</b> <span class="muted">E[n] = E[w]</span> and <span class="muted">Var(n) = E[w] + Var(w)</span>.</li>
          <li><b>Physical interpretation:</b> the total count noise is “shot noise” (<span class="muted">E[w]</span>) plus “excess noise” from intensity fluctuations (<span class="muted">Var(w)</span>).</li>
        </ul>

        <div class="twoCol">
          <div class="eqCard">
            <div class="eqRow">
              <pre class="eq" id="eqKey1">Model:  n | w ~ Poisson(w)</pre>
              <button class="btn small" data-copy="#eqKey1">Copy</button>
            </div>
          </div>
          <div class="eqCard">
            <div class="eqRow">
              <pre class="eq" id="eqKey2">Results: E[n] = E[w]
         Var(n) = E[w] + Var(w)</pre>
              <button class="btn small primary" data-copy="#eqKey2">Copy</button>
            </div>
          </div>
        </div>
      </section>

      <section id="part0" class="fadeIn">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <h3>Core definitions (symbols &amp; units)</h3>
        <ul>
          <li><b>Count</b> <span class="muted">n</span> (unit: dimensionless): number of detected events (e.g., photons) in a fixed observation window of duration <span class="muted">T</span>.</li>
          <li><b>Random mean</b> <span class="muted">w</span> (unit: expected counts in the same window; dimensionless): the conditional Poisson mean. In photon counting, one often has
            <span class="muted">w = η ∫<sub>0</sub><sup>T</sup> I(t) dt</span>, where <span class="muted">I(t)</span> is intensity (or photon flux) and <span class="muted">η</span> is an efficiency factor.</li>
          <li><b>Doubly stochastic / Cox process:</b> arrivals are Poisson <em>conditional</em> on a random rate/mean.</li>
          <li><b>Mean and variance:</b> <span class="muted">E[x]</span> and <span class="muted">Var(x)=E[(x−E[x])²]</span>.</li>
          <li><b>Standard deviations:</b> <span class="muted">σ<sub>n</sub></span> and <span class="muted">σ<sub>w</sub></span> where <span class="muted">σ<sub>w</sub>² = Var(w)</span>.</li>
        </ul>

        <h3>Physical meaning</h3>
        <p>
          A plain Poisson model corresponds to an “ideal” shot-noise-limited detection with a fixed mean count.
          But in many optical experiments the intensity fluctuates (classical noise, speckle, source power drift),
          making the mean count <span class="muted">w</span> itself random. The observed count distribution becomes a <em>mixture</em> of Poisson distributions:
          different trials have different Poisson means.
        </p>

        <div class="callout good">
          <div class="label"><span class="labelDot"></span>Key law (conditional Poisson facts)</div>
          <p class="muted" style="margin:0">
            If <span class="muted">n | w ~ Poisson(w)</span>, then for each fixed <span class="muted">w</span>:
            <span class="muted">E[n|w]=w</span> and <span class="muted">Var(n|w)=w</span>.
            This is the essence of “shot noise”: variance equals mean <em>at fixed intensity</em>.
          </p>
        </div>

        <h3>Key principles and validity conditions</h3>
        <ul>
          <li><b>Poisson counting validity:</b> independent arrivals in disjoint time intervals, low probability of more than one event in a sufficiently small interval, and stationary (or known) rate within the conditional model.</li>
          <li><b>Doubly stochastic assumption:</b> the randomness in <span class="muted">w</span> is external/slow compared to the counting granularity or reflects trial-to-trial variations; conditioned on <span class="muted">w</span>, counts follow Poisson.</li>
          <li><b>Nonnegativity:</b> <span class="muted">w ≥ 0</span> almost surely (as a mean count).</li>
        </ul>

        <h3>Common models/approximations (why we use them)</h3>
        <ul>
          <li><b>Gamma-distributed</b> <span class="muted">w</span> → negative binomial (common in speckle/thermal-light counting).</li>
          <li><b>Lognormal</b> <span class="muted">w</span> → multiplicative power fluctuations.</li>
          <li><b>Slow-drift approximation:</b> treat <span class="muted">w</span> as constant within each measurement window, but random across windows.</li>
        </ul>

        <h3>Mini intuition examples (no long algebra)</h3>
        <ul>
          <li><b>Example 1:</b> If the source power is perfectly stable, <span class="muted">Var(w)=0</span>, so you recover Poisson:
            <span class="muted">Var(n)=E[w]</span>.</li>
          <li><b>Example 2:</b> If power jitters significantly (large <span class="muted">Var(w)</span>), the observed variance is larger than Poisson:
            <span class="muted">Var(n) &gt; E[n]</span> (super-Poisson).</li>
        </ul>

        <div class="callout warn">
          <div class="label"><span class="labelDot"></span>What to watch for (pitfalls)</div>
          <ul style="margin:8px 0 0 18px;">
            <li>Confusing <span class="muted">Var(n|w)</span> with <span class="muted">Var(n)</span>. The first equals <span class="muted">w</span>, the second generally does not.</li>
            <li>Forgetting the extra term <span class="muted">Var(w)</span> from fluctuations of the mean (this is the “excess noise”).</li>
            <li>Using a distribution for <span class="muted">w</span> that allows negative values (unphysical).</li>
          </ul>
        </div>
      </section>

      <section id="part1" class="fadeIn">
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

        <h3>Problem restatement (in plain words)</h3>
        <p>
          We consider a random count <span class="muted">n</span> generated as follows:
          first, a nonnegative random variable <span class="muted">w</span> (the Poisson mean count) is drawn;
          then, conditioned on that value, the count <span class="muted">n</span> is Poisson with mean <span class="muted">w</span>.
          Prove the identities:
        </p>

        <div class="eqCard">
          <div class="eqRow">
            <pre class="eq" id="eqProb">Prove:
(1)  E[n] = E[w]
(2)  Var(n) = E[w] + Var(w)</pre>
            <button class="btn small" data-copy="#eqProb">Copy</button>
          </div>
        </div>

        <h3>Given quantities</h3>
        <ul>
          <li>A nonnegative random variable <span class="muted">w</span> with mean <span class="muted">E[w]</span> and variance <span class="muted">Var(w)=σ<sub>w</sub>²</span>.</li>
          <li>A conditional distribution <span class="muted">n|w ~ Poisson(w)</span>.</li>
        </ul>

        <h3>Unknowns / what must be shown</h3>
        <ul>
          <li>Compute <span class="muted">E[n]</span> in terms of moments of <span class="muted">w</span>.</li>
          <li>Compute <span class="muted">Var(n)</span> in terms of moments of <span class="muted">w</span>.</li>
        </ul>

        <h3>Relevant principles (and why they apply)</h3>
        <ul>
          <li><b>Law of total expectation:</b> because <span class="muted">n</span> is generated conditional on <span class="muted">w</span>, we can average in two stages: first over the Poisson randomness (given <span class="muted">w</span>), then over the randomness of <span class="muted">w</span>.</li>
          <li><b>Law of total variance:</b> decomposes total fluctuations into “within-condition” variance plus “between-condition” variance.</li>
          <li><b>Poisson conditional moments:</b> for fixed mean <span class="muted">w</span>, both conditional mean and conditional variance equal <span class="muted">w</span>.</li>
        </ul>

        <div class="callout">
          <div class="label"><span class="labelDot"></span>Assumptions (explicit)</div>
          <ul style="margin:8px 0 0 18px;">
            <li><span class="muted">w ≥ 0</span> (a mean count must be nonnegative).</li>
            <li>Conditioned on <span class="muted">w</span>, the count follows an ideal Poisson law (shot-noise-limited given the mean).</li>
            <li>All required expectations exist: <span class="muted">E[w]</span> and <span class="muted">Var(w)</span> are finite.</li>
          </ul>
        </div>

        <h3>Possible approaches (compare)</h3>
        <ol>
          <li><b>Moment decomposition (best):</b> use total expectation and total variance. Fast, general, and teaches the physics of noise addition.</li>
          <li><b>Generating functions:</b> compute the probability generating function of the mixture, then extract mean/variance. Powerful but more algebra.</li>
          <li><b>Direct mixture sums/integrals:</b> write <span class="muted">P(n)=E[e^{-w}w^n/n!]</span>, then differentiate moment identities. Works, but can be messy.</li>
        </ol>

        <p><b>Chosen approach:</b> the moment decomposition method, because it is short, rigorous, and directly interpretable as “shot noise + intensity noise.”</p>
      </section>

      <section id="part2" class="fadeIn">
        <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>

        <ol>
          <li>
            <b>Write the conditional model.</b><br/>
            <span class="muted">Tool:</span> definition <span class="muted">n|w ~ Poisson(w)</span>.<br/>
            <span class="muted">Meaning:</span> once <span class="muted">w</span> is fixed, the counting is ordinary Poisson.
          </li>
          <li>
            <b>Use known Poisson conditional moments.</b><br/>
            <span class="muted">Tool:</span> <span class="muted">E[n|w]=w</span>, <span class="muted">Var(n|w)=w</span>.<br/>
            <span class="muted">Meaning:</span> shot noise at fixed mean.
          </li>
          <li>
            <b>Compute the unconditional mean.</b><br/>
            <span class="muted">Tool:</span> total expectation <span class="muted">E[n]=E(E[n|w])</span>.<br/>
            <span class="muted">Meaning:</span> average the conditional mean over the randomness in <span class="muted">w</span>.
          </li>
          <li>
            <b>Compute the unconditional variance.</b><br/>
            <span class="muted">Tool:</span> total variance
            <span class="muted">Var(n)=E(Var(n|w))+Var(E[n|w])</span>.<br/>
            <span class="muted">Meaning:</span> total noise = within-trial noise + trial-to-trial mean fluctuations.
          </li>
          <li>
            <b>Substitute the Poisson conditional moments.</b><br/>
            <span class="muted">Tool:</span> plug <span class="muted">Var(n|w)=w</span> and <span class="muted">E[n|w]=w</span> into the decomposition.<br/>
            <span class="muted">Meaning:</span> the extra term is exactly <span class="muted">Var(w)</span>.
          </li>
          <li>
            <b>Sanity-check the result.</b><br/>
            <span class="muted">Tool:</span> check limiting cases (<span class="muted">Var(w)=0</span>) and positivity.<br/>
            <span class="muted">Meaning:</span> if the mean is nonrandom you recover Poisson.
          </li>
        </ol>

        <div class="callout warn">
          <div class="label"><span class="labelDot"></span>Common mistakes &amp; quick tips</div>
          <ul style="margin:8px 0 0 18px;">
            <li>Don’t set <span class="muted">Var(n)=E[w]</span> unless you have proven <span class="muted">Var(w)=0</span>.</li>
            <li>Be explicit about conditioning: write <span class="muted">E[n|w]</span> before taking unconditional expectation.</li>
            <li>Remember: <span class="muted">Var(E[n|w])</span> is a variance of a random mean, not an expectation.</li>
          </ul>
        </div>
      </section>

      <section id="part3" class="fadeIn">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Physical intuition (before math)</h3>
        <p>
          Think of one measurement window as a “trial.” In each trial, the source brightness (or rate) sets
          the expected count <span class="muted">w</span>. Even if detection is ideal, you still get Poisson shot noise
          around that trial’s mean, contributing variance ≈ <span class="muted">w</span>.
          But if the mean itself changes between trials, the collection of all trials spreads out even more—this produces
          an additional variance equal to the variance of the mean, <span class="muted">Var(w)</span>.
        </p>

        <div class="hr"></div>

        <h3>Step 1 — Define the model and symbols</h3>
        <p>
          Let <span class="muted">w</span> be a nonnegative random variable (dimensionless, “mean counts per window”).
          The observed count <span class="muted">n</span> is conditionally Poisson:
        </p>

        <div class="eqCard">
          <div class="eqRow">
            <pre class="eq" id="eqModel">n | w  ~  Poisson(w)
i.e.,  P(n=k | w) = e^{-w} w^k / k!,   k=0,1,2,...</pre>
            <button class="btn small" data-copy="#eqModel">Copy</button>
          </div>
        </div>

        <p class="muted">
          Here <span class="muted">w</span> may arise from an integrated random rate (e.g., fluctuating optical intensity) over the counting window.
        </p>

        <h3>Step 2 — Use Poisson conditional moments</h3>
        <p>
          For a Poisson random variable with mean <span class="muted">w</span>, the mean and variance equal <span class="muted">w</span>. Therefore:
        </p>

        <div class="eqCard">
          <div class="eqRow">
            <pre class="eq" id="eqCondMom">E[n | w]   = w
Var(n | w) = w</pre>
            <button class="btn small" data-copy="#eqCondMom">Copy</button>
          </div>
        </div>

        <p class="muted">
          This captures the shot-noise property “variance = mean” but only at fixed <span class="muted">w</span>.
        </p>

        <h3>Step 3 — Prove the mean identity E[n] = E[w]</h3>
        <p>
          Apply the <b>law of total expectation</b>:
        </p>

        <div class="eqCard">
          <div class="eqRow">
            <pre class="eq" id="eqMeanDeriv">E[n] = E( E[n | w] ).</pre>
            <button class="btn small" data-copy="#eqMeanDeriv">Copy</button>
          </div>
        </div>

        <p>Now substitute <span class="muted">E[n|w]=w</span> from Step 2:</p>

        <div class="eqCard">
          <div class="eqRow">
            <pre class="eq" id="eqMeanDeriv2">E[n] = E( E[n | w] ) = E( w ) = E[w].</pre>
            <button class="btn small" data-copy="#eqMeanDeriv2">Copy</button>
          </div>
        </div>

        <p>
          <b>Interpretation:</b> on average, the count equals the average mean rate—no surprise: averaging over trials just averages the trial means.
        </p>

        <h3>Step 4 — Prove the variance identity Var(n) = E[w] + Var(w)</h3>
        <p>
          Use the <b>law of total variance</b>:
        </p>

        <div class="eqCard">
          <div class="eqRow">
            <pre class="eq" id="eqTotVar">Var(n) = E( Var(n | w) ) + Var( E[n | w] ).</pre>
            <button class="btn small" data-copy="#eqTotVar">Copy</button>
          </div>
        </div>

        <p>
          Substitute the conditional moments from Step 2:
          <span class="muted">Var(n|w)=w</span> and <span class="muted">E[n|w]=w</span>.
        </p>

        <div class="eqCard">
          <div class="eqRow">
            <pre class="eq" id="eqVarDeriv">Var(n) = E(w) + Var(w).</pre>
            <button class="btn small" data-copy="#eqVarDeriv">Copy</button>
          </div>
        </div>

        <p>
          Since Step 3 gave <span class="muted">E[w]=E[n]</span>, we can also write:
        </p>

        <div class="eqCard">
          <div class="eqRow">
            <pre class="eq" id="eqVarAlt">Var(n) = E[n] + Var(w).</pre>
            <button class="btn small" data-copy="#eqVarAlt">Copy</button>
          </div>
        </div>

        <div class="callout good">
          <div class="label"><span class="labelDot"></span>Final Answer (boxed)</div>
          <div class="eqCard" style="margin-top:8px;">
            <div class="eqRow">
              <pre class="eq" id="eqFinal">E[n] = E[w]
Var(n) = E[w] + Var(w) = E[n] + Var(w)</pre>
              <button class="btn small primary" data-copy="#eqFinal">Copy</button>
            </div>
          </div>
        </div>

        <h3>Sanity checks</h3>
        <div class="grid2">
          <div class="callout">
            <div class="label"><span class="labelDot"></span>Units/dimensions</div>
            <p class="muted" style="margin:0">
              <span class="muted">n</span> and <span class="muted">w</span> are counts (dimensionless). Variances are squared counts (still dimensionless).
              The sum <span class="muted">E[w] + Var(w)</span> is consistent.
            </p>
          </div>
          <div class="callout">
            <div class="label"><span class="labelDot"></span>Limiting cases</div>
            <p class="muted" style="margin:0">
              If <span class="muted">Var(w)=0</span> (no intensity fluctuations), then <span class="muted">Var(n)=E[w]</span>, recovering ordinary Poisson.
              If <span class="muted">Var(w)&gt;0</span>, then <span class="muted">Var(n)&gt;E[n]</span> (super-Poisson/excess noise).
            </p>
          </div>
        </div>

        <p>
          <b>Connection to the diagram/plots:</b>
          The diagram shows a random mean <span class="muted">w</span> feeding a Poisson counter. The plots visualize how
          the variance rises above the Poisson baseline by an additive offset <span class="muted">Var(w)</span>, and how the Fano factor
          <span class="muted">F = Var(n)/E[n] = 1 + Var(w)/E[w]</span> increases when fluctuations grow.
        </p>
      </section>

      <section id="part4" class="fadeIn">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpreting the final formula</h3>
        <p>
          The variance decomposition
          <span class="muted">Var(n) = E(Var(n|w)) + Var(E[n|w])</span>
          reads, in words:
        </p>
        <ul>
          <li><b>Shot-noise term:</b> <span class="muted">E(Var(n|w)) = E[w]</span>. Even with a perfectly known mean, Poisson randomness remains.</li>
          <li><b>Excess-noise term:</b> <span class="muted">Var(E[n|w]) = Var(w)</span>. Any trial-to-trial fluctuation of the mean broadens the unconditional distribution.</li>
        </ul>

        <div class="callout warn">
          <div class="label"><span class="labelDot"></span>Key physical takeaway</div>
          <p class="muted" style="margin:0">
            “Variance = mean” is not a universal signature of Poisson counting unless the mean is nonrandom.
            In experiments, excess noise often comes from classical intensity fluctuations, detector gain drift,
            or environmental changes that randomize <span class="muted">w</span>.
          </p>
        </div>

        <h3>How changing parameters affects outcomes (connect to plots)</h3>
        <ul>
          <li>Increasing <span class="muted">E[w]</span> increases both the mean and the shot-noise contribution linearly.</li>
          <li>Increasing <span class="muted">Var(w)</span> shifts <span class="muted">Var(n)</span> upward by the same amount (additive offset), making noise larger at every mean.</li>
          <li>The <b>Fano factor</b> <span class="muted">F = Var(n)/E[n] = 1 + Var(w)/E[w]</span> decreases toward 1 as <span class="muted">E[w]</span> becomes large at fixed <span class="muted">Var(w)</span>, but increases strongly when <span class="muted">Var(w)</span> grows.</li>
        </ul>

        <h3>Alternative derivation idea (brief)</h3>
        <p>
          Using probability generating functions:
          conditional PGF is <span class="muted">G<sub>n|w</sub>(z)=exp(w(z−1))</span>.
          Unconditionally, <span class="muted">G_n(z)=E[exp(w(z−1))]</span>, the moment-generating function of <span class="muted">w</span> evaluated at <span class="muted">z−1</span>.
          Differentiating at <span class="muted">z=1</span> gives the same mean and variance. This path is useful when you want the full distribution (e.g., gamma → negative binomial).
        </p>

        <h3>Concept checks (self-test)</h3>
        <ul>
          <li><b>Q:</b> If you measure <span class="muted">Var(n)≈E[n]</span>, does it prove the process is Poisson? <b>A:</b> Not necessarily; it suggests <span class="muted">Var(w)</span> is small, but other mechanisms can mimic Poisson-like variance in limited regimes.</li>
          <li><b>Q:</b> What term would you try to reduce to reach shot-noise-limited detection? <b>A:</b> Reduce <span class="muted">Var(w)</span> (stabilize intensity/mean rate).</li>
          <li><b>Q:</b> If <span class="muted">Var(w)</span> doubles, what happens to <span class="muted">Var(n)</span>? <b>A:</b> It increases by the same additive amount (doubles the excess-noise contribution).</li>
          <li><b>Q:</b> For fixed <span class="muted">Var(w)</span>, what happens to the Fano factor as <span class="muted">E[w]</span> grows? <b>A:</b> It approaches 1: <span class="muted">F→1</span>.</li>
        </ul>
      </section>

      <section id="part5" class="fadeIn">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

        <h3>What each canvas shows</h3>
        <ul>
          <li><b>Diagram canvas:</b> A block diagram of the measurement: a random mean count <span class="muted">w</span> (set by intensity) feeds an ideal Poisson counter producing <span class="muted">n</span>.</li>
          <li><b>Main plot:</b> <span class="muted">Var(n)</span> versus <span class="muted">E[w]</span> over a sweep of mean values. The Poisson baseline is <span class="muted">Var(n)=E[w]</span>; the Cox result adds an offset <span class="muted">Var(w)</span>.</li>
          <li><b>Secondary plot:</b> The <b>Fano factor</b> <span class="muted">F = Var(n)/E[n]</span> versus <span class="muted">E[w]</span>, showing super-Poisson behavior when <span class="muted">Var(w)&gt;0</span>.</li>
        </ul>

        <h3>Interactive controls</h3>
        <ul>
          <li><b>Slider “Mean E[w] (example)”</b>: sets a highlighted operating point on both plots (a vertical marker in the sweep).</li>
          <li><b>Slider “Variance Var(w)”</b>: changes the amount of intensity/mean fluctuation. You should see:
            <ul>
              <li>Main plot: the Cox variance curve shifts upward by exactly that amount (additive offset).</li>
              <li>Secondary plot: the Fano factor increases, especially at small <span class="muted">E[w]</span>.</li>
            </ul>
          </li>
          <li><b>Select “Example w distribution”</b>: changes how we <em>simulate</em> <span class="muted">w</span> for a Monte Carlo check (gamma or lognormal). The <b>theoretical</b> mean/variance relations remain the same.</li>
          <li><b>Button “Resimulate”</b>: regenerates random samples and updates the empirical markers. Expect small scatter due to finite sample size.</li>
        </ul>

        <div class="callout bad">
          <div class="label"><span class="labelDot"></span>Important note about numbers</div>
          <p class="muted" style="margin:0">
            The plots use <b>example values</b> (since the problem statement is symbolic). The displayed curves are the symbolic formulas
            evaluated at those example parameters; the proofs above are fully general.
          </p>
        </div>
      </section>
    </article>

    <!-- Right column: interactive visualizations -->
    <aside class="vizWrap fadeIn" aria-label="Interactive visualizations">
      <section class="canvasCard">
        <div class="canvasHead">
          <div>
            <h3 class="canvasTitle" style="margin:0;">Diagram: Random mean → Poisson counts</h3>
            <p class="canvasSub">Conceptual setup for a doubly stochastic Poisson (Cox) model.</p>
          </div>
          <button class="btn small" id="btnDownloadPNG" title="Download a PNG snapshot of all canvases">Snapshot</button>
        </div>
        <canvas id="cDiagram" aria-label="Diagram canvas"></canvas>
      </section>

      <section class="canvasCard">
        <div class="canvasHead">
          <div>
            <h3 class="canvasTitle" style="margin:0;">Main Plot: Var(n) vs E[w]</h3>
            <p class="canvasSub">Theory: Var(n)=E[w]+Var(w). Baseline Poisson: Var(n)=E[w].</p>
          </div>
        </div>
        <canvas id="cMain" aria-label="Main plot canvas"></canvas>
      </section>

      <section class="canvasCard">
        <div class="canvasHead">
          <div>
            <h3 class="canvasTitle" style="margin:0;">Secondary Plot: Fano factor F vs E[w]</h3>
            <p class="canvasSub">F = Var(n)/E[n] = 1 + Var(w)/E[w]. Super-Poisson when Var(w)&gt;0.</p>
          </div>
        </div>
        <canvas id="cSecond" aria-label="Secondary plot canvas"></canvas>

        <div class="controls" role="group" aria-label="Interactive controls">
          <div class="control">
            <label for="muSel">Mean E[w] (example) <span class="val" id="muSelVal"></span></label>
            <input id="muSel" type="range" min="1" max="80" value="20" step="1"/>
            <div class="muted" style="font-size:.86rem; margin-top:6px;">
              Highlights an operating point on the sweep.
            </div>
          </div>

          <div class="control">
            <label for="varw">Variance Var(w) <span class="val" id="varwVal"></span></label>
            <input id="varw" type="range" min="0" max="200" value="30" step="1"/>
            <div class="muted" style="font-size:.86rem; margin-top:6px;">
              Controls “excess noise” offset.
            </div>
          </div>

          <div class="control">
            <label for="dist">Example w distribution <span class="val" id="distVal"></span></label>
            <select id="dist">
              <option value="gamma">Gamma (→ negative binomial counts)</option>
              <option value="lognormal">Lognormal (multiplicative fluctuations)</option>
            </select>
            <div class="muted" style="font-size:.86rem; margin-top:6px;">
              Used only for Monte Carlo markers.
            </div>
          </div>

          <div class="control">
            <label>Monte Carlo check <span class="val" id="mcVal"></span></label>
            <button class="btn primary" id="btnResim" style="width:100%;">Resimulate</button>
            <div class="muted" style="font-size:.86rem; margin-top:6px;">
              Finite-sample scatter is expected.
            </div>
          </div>
        </div>
      </section>
    </aside>
  </main>

  <footer class="fadeIn">
    <div class="hr"></div>
    <p style="margin:0">
      Built for learning: conditional Poisson + total expectation/variance ⇒ shot-noise term + excess-noise term.
      Copy buttons provide plain-text equations for notes.
    </p>
  </footer>

  <script>
    // ---------- Utilities ----------
    function $(sel){ return document.querySelector(sel); }
    function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
    function fmt(x){
      // clean formatting for UI
      if (Math.abs(x) >= 100) return x.toFixed(0);
      if (Math.abs(x) >= 10) return x.toFixed(1).replace(/\.0$/,'');
      return x.toFixed(2).replace(/0$/,'').replace(/\.$/,'');
    }

    // Copy buttons
    (function initCopy(){
      document.querySelectorAll("[data-copy]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const target = document.querySelector(btn.getAttribute("data-copy"));
          const text = target ? target.textContent : "";
          try{
            await navigator.clipboard.writeText(text.trim());
            const old = btn.textContent;
            btn.textContent = "Copied";
            setTimeout(()=>btn.textContent = old, 900);
          }catch(e){
            const old = btn.textContent;
            btn.textContent = "Copy failed";
            setTimeout(()=>btn.textContent = old, 900);
          }
        });
      });
    })();

    // HiDPI canvas setup
    function setupCanvas(canvas){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect.width * dpr));
      const h = Math.max(2, Math.floor(rect.height * dpr));
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return ctx;
    }

    // Plot helpers
    function drawAxes(ctx, box, xLabel, yLabel, xMin, xMax, yMin, yMax, opts={}){
      const {grid=true, ticks=6, title=""} = opts;
      const {x,y,w,h} = box;

      // Background
      ctx.save();
      ctx.fillStyle = "rgba(15,23,42,.52)";
      roundRect(ctx, x, y, w, h, 16);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.lineWidth = 1;
      roundRect(ctx, x, y, w, h, 16);
      ctx.stroke();

      // Title
      if (title){
        ctx.fillStyle = "rgba(224,242,254,.95)";
        ctx.font = "700 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.fillText(title, x+12, y+20);
      }

      // Plot area
      const padL = 54, padR = 16, padT = title ? 30 : 14, padB = 44;
      const px = x + padL, py = y + padT, pw = w - padL - padR, ph = h - padT - padB;

      // Grid + ticks
      const n = ticks;
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      ctx.fillStyle = "rgba(156,163,175,.95)";
      ctx.strokeStyle = "rgba(255,255,255,.08)";
      ctx.lineWidth = 1;

      for (let i=0;i<=n;i++){
        const tx = px + (pw*i/n);
        const ty = py + (ph*i/n);

        if (grid){
          ctx.beginPath(); ctx.moveTo(tx, py); ctx.lineTo(tx, py+ph); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(px, ty); ctx.lineTo(px+pw, ty); ctx.stroke();
        }

        const xv = xMin + (xMax-xMin)*(i/n);
        const yv = yMax - (yMax-yMin)*(i/n);

        // x tick labels
        ctx.fillText(fmt(xv), tx-10, py+ph+18);
        // y tick labels
        ctx.fillText(fmt(yv), px-46, ty+4);
      }

      // Axes lines
      ctx.strokeStyle = "rgba(255,255,255,.22)";
      ctx.lineWidth = 1.2;
      ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px, py+ph); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(px, py+ph); ctx.lineTo(px+pw, py+ph); ctx.stroke();

      // Axis labels
      ctx.fillStyle = "rgba(229,231,235,.92)";
      ctx.font = "700 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(xLabel, px + pw/2 - ctx.measureText(xLabel).width/2, py+ph+36);

      // y label rotated
      ctx.save();
      ctx.translate(px-44, py+ph/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
      ctx.restore();

      ctx.restore();

      function toX(xv){ return px + (xv - xMin) * pw / (xMax - xMin); }
      function toY(yv){ return py + (yMax - yv) * ph / (yMax - yMin); }

      return {px,py,pw,ph,toX,toY};
    }

    function roundRect(ctx,x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    function drawLegend(ctx, items, x, y){
      ctx.save();
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      let yy = y;
      items.forEach(it=>{
        ctx.fillStyle = it.color;
        ctx.fillRect(x, yy-9, 14, 3);
        ctx.fillStyle = "rgba(229,231,235,.92)";
        ctx.fillText(it.label, x+20, yy);
        yy += 16;
      });
      ctx.restore();
    }

    // ---------- Monte Carlo for markers ----------
    function randn(){
      // Box-Muller
      let u=0,v=0;
      while(u===0) u=Math.random();
      while(v===0) v=Math.random();
      return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    }

    function sampleW(mu, varw, dist){
      // Ensure nonnegative and match requested mean/variance (approximately for lognormal; exactly for gamma)
      varw = Math.max(0, varw);
      mu = Math.max(1e-9, mu);

      if (varw === 0) return mu;

      if (dist === "gamma"){
        // Gamma(k, theta): mean=kθ=mu, var=kθ^2=varw -> k=mu^2/var, θ=var/mu
        const k = (mu*mu)/varw;
        const theta = varw/mu;
        // Marsaglia-Tsang for k>=1; if k<1 use boost trick
        if (k >= 1){
          return gammaMT(k, theta);
        } else {
          // k<1: sample gamma(k+1, theta) * U^(1/k)
          const g = gammaMT(k+1, theta);
          const u = Math.random();
          return g * Math.pow(u, 1/k);
        }
      } else {
        // Lognormal with parameters (m, s^2): mean=exp(m+s^2/2)=mu, var=(exp(s^2)-1)exp(2m+s^2)=varw
        // Solve: s^2 = ln(1 + var/mu^2), m = ln(mu) - s^2/2
        const s2 = Math.log(1 + varw/(mu*mu));
        const m = Math.log(mu) - s2/2;
        const z = randn();
        return Math.exp(m + Math.sqrt(s2)*z);
      }

      function gammaMT(k, theta){
        // k shape >= 1
        const d = k - 1/3;
        const c = 1/Math.sqrt(9*d);
        while(true){
          let x = randn();
          let v = 1 + c*x;
          if (v <= 0) continue;
          v = v*v*v;
          const u = Math.random();
          if (u < 1 - 0.0331*(x*x)*(x*x)) return theta*d*v;
          if (Math.log(u) < 0.5*x*x + d*(1 - v + Math.log(v))) return theta*d*v;
        }
      }
    }

    function samplePoisson(lambda){
      // Knuth for small, normal approx for large for speed
      lambda = Math.max(0, lambda);
      if (lambda < 30){
        const L = Math.exp(-lambda);
        let k = 0;
        let p = 1;
        do{
          k++;
          p *= Math.random();
        }while(p > L);
        return k-1;
      } else {
        // Normal approximation with continuity correction
        const z = randn();
        const x = lambda + Math.sqrt(lambda)*z;
        return Math.max(0, Math.floor(x + 0.5));
      }
    }

    function mcStats(mu, varw, dist, N=20000){
      let sumN=0, sumN2=0;
      for(let i=0;i<N;i++){
        const w = sampleW(mu, varw, dist);
        const n = samplePoisson(w);
        sumN += n;
        sumN2 += n*n;
      }
      const mean = sumN/N;
      const varN = sumN2/N - mean*mean;
      return {mean, varN, N};
    }

    // ---------- Drawing the diagram ----------
    function drawDiagram(){
      const canvas = $("#cDiagram");
      const ctx = setupCanvas(canvas);
      const rect = canvas.getBoundingClientRect();
      const W = rect.width, H = rect.height;

      ctx.clearRect(0,0,W,H);

      // Soft background
      ctx.save();
      ctx.fillStyle = "rgba(2,6,23,.45)";
      ctx.fillRect(0,0,W,H);
      ctx.restore();

      const cx = 14, cy = 14, cw = W-28, ch = H-28;

      // Title
      ctx.fillStyle = "rgba(224,242,254,.95)";
      ctx.font = "800 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Random mean (intensity) drives Poisson counting", cx+8, cy+18);

      // Blocks
      const blockY = cy + 55;
      const bH = 78;
      const b1X = cx + 28, b1W = (cw-140)*0.46;
      const b2X = b1X + b1W + 84, b2W = (cw-140)*0.46;

      // Draw block helper
      function block(x,y,w,h, title, lines, tint){
        ctx.save();
        ctx.fillStyle = tint;
        roundRect(ctx,x,y,w,h,16);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,.14)";
        ctx.lineWidth = 1;
        roundRect(ctx,x,y,w,h,16);
        ctx.stroke();

        ctx.fillStyle = "rgba(229,231,235,.95)";
        ctx.font = "800 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.fillText(title, x+12, y+22);

        ctx.fillStyle = "rgba(156,163,175,.95)";
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
        let yy = y+42;
        lines.forEach(t=>{
          ctx.fillText(t, x+12, yy);
          yy += 16;
        });
        ctx.restore();
      }

      block(b1X, blockY, b1W, bH, "Random mean w", [
        "w ≥ 0",
        "E[w] = μ",
        "Var(w) = σw²"
      ], "rgba(96,165,250,.14)");

      block(b2X, blockY, b2W, bH, "Poisson counter", [
        "n | w ~ Pois(w)",
        "E[n|w]=w",
        "Var(n|w)=w"
      ], "rgba(167,139,250,.13)");

      // Arrows
      function arrow(x1,y1,x2,y2, label){
        ctx.save();
        ctx.strokeStyle = "rgba(229,231,235,.75)";
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

        // head
        const ang = Math.atan2(y2-y1, x2-x1);
        const L = 10;
        ctx.beginPath();
        ctx.moveTo(x2,y2);
        ctx.lineTo(x2 - L*Math.cos(ang-0.35), y2 - L*Math.sin(ang-0.35));
        ctx.lineTo(x2 - L*Math.cos(ang+0.35), y2 - L*Math.sin(ang+0.35));
        ctx.closePath();
        ctx.fillStyle = "rgba(229,231,235,.85)";
        ctx.fill();

        // label
        if(label){
          ctx.fillStyle = "rgba(156,163,175,.95)";
          ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
          ctx.fillText(label, (x1+x2)/2 - ctx.measureText(label).width/2, (y1+y2)/2 - 10);
        }
        ctx.restore();
      }

      const midY = blockY + bH/2;
      arrow(b1X + b1W, midY, b2X, midY, "condition on w");

      // Output bubble
      const outX = b2X + b2W + 46;
      const outY = midY - 22;
      ctx.save();
      ctx.fillStyle = "rgba(52,211,153,.14)";
      roundRect(ctx, outX-6, outY-6, 100, 64, 16);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,.14)";
      ctx.lineWidth = 1;
      roundRect(ctx, outX-6, outY-6, 100, 64, 16);
      ctx.stroke();

      ctx.fillStyle = "rgba(229,231,235,.95)";
      ctx.font = "900 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Output", outX+16, outY+16);

      ctx.fillStyle = "rgba(156,163,175,.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      ctx.fillText("count n", outX+16, outY+36);
      ctx.restore();

      arrow(b2X + b2W, midY, outX-6, midY, "");

      // Noise decomposition note
      const noteY = blockY + bH + 52;
      ctx.save();
      ctx.fillStyle = "rgba(229,231,235,.92)";
      ctx.font = "800 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Variance decomposition:", cx+10, noteY);

      ctx.fillStyle = "rgba(156,163,175,.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      ctx.fillText("Var(n) = E[w]  +  Var(w)", cx+10, noteY+20);

      // Little bracket labels
      ctx.fillStyle = "rgba(96,165,250,.90)";
      ctx.fillText("shot noise", cx+10, noteY+40);
      ctx.fillStyle = "rgba(167,139,250,.90)";
      ctx.fillText("excess noise", cx+150, noteY+40);
      ctx.restore();
    }

    // ---------- Plot drawing ----------
    function drawMainPlot(state){
      const canvas = $("#cMain");
      const ctx = setupCanvas(canvas);
      const rect = canvas.getBoundingClientRect();
      const W = rect.width, H = rect.height;
      ctx.clearRect(0,0,W,H);

      const muMax = 80;
      const varw = state.varw;

      // yMax based on var formula
      const yMax = muMax + varw + 20;
      const yMin = 0;

      const box = {x:10,y:10,w:W-20,h:H-20};
      const ax = drawAxes(ctx, box, "E[w] = μ (counts)", "Var(n) (counts²)", 0, muMax, yMin, yMax, {
        title: "Variance of counts vs mean (sweep over μ)",
        ticks: 6,
        grid: true
      });

      // Curves
      // Baseline Poisson: Var = μ
      // Cox: Var = μ + varw
      function plotCurve(f, color, dash=[]){
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2.2;
        ctx.setLineDash(dash);
        ctx.beginPath();
        for(let i=0;i<=240;i++){
          const mu = muMax*i/240;
          const y = f(mu);
          const X = ax.toX(mu);
          const Y = ax.toY(y);
          if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
        }
        ctx.stroke();
        ctx.restore();
      }

      plotCurve(mu=>mu, "rgba(96,165,250,.95)", [6,5]);
      plotCurve(mu=>mu+varw, "rgba(167,139,250,.95)", []);

      // Highlight selected operating point
      const muSel = state.muSel;
      const yPois = muSel;
      const yCox = muSel + varw;

      // Vertical marker
      ctx.save();
      ctx.strokeStyle = "rgba(229,231,235,.40)";
      ctx.lineWidth = 1.5;
      ctx.setLineDash([4,4]);
      ctx.beginPath();
      ctx.moveTo(ax.toX(muSel), ax.py);
      ctx.lineTo(ax.toX(muSel), ax.py + ax.ph);
      ctx.stroke();
      ctx.restore();

      // Points
      function dot(x,y,color){
        ctx.save();
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(ax.toX(x), ax.toY(y), 4.2, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      dot(muSel, yPois, "rgba(96,165,250,.95)");
      dot(muSel, yCox, "rgba(167,139,250,.95)");

      // Monte Carlo marker
      if (state.mc){
        const mc = state.mc;
        dot(mc.mean, mc.varN, "rgba(52,211,153,.95)");
        ctx.save();
        ctx.fillStyle = "rgba(52,211,153,.95)";
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
        const label = `MC: mean≈${fmt(mc.mean)}, var≈${fmt(mc.varN)}`;
        ctx.fillText(label, ax.px+10, ax.py+16);
        ctx.restore();
      }

      drawLegend(ctx, [
        {label:"Poisson baseline: Var(n)=μ", color:"rgba(96,165,250,.95)"},
        {label:"Cox theory: Var(n)=μ+Var(w)", color:"rgba(167,139,250,.95)"},
        {label:"Monte Carlo marker (example)", color:"rgba(52,211,153,.95)"}
      ], ax.px+10, ax.py+ax.ph-34);
    }

    function drawSecondPlot(state){
      const canvas = $("#cSecond");
      const ctx = setupCanvas(canvas);
      const rect = canvas.getBoundingClientRect();
      const W = rect.width, H = rect.height;
      ctx.clearRect(0,0,W,H);

      const muMax = 80;
      const varw = state.varw;

      const xMin = 1; // avoid division by zero
      const xMax = muMax;
      const yMin = 0.9;
      const yMax = 1 + (varw / xMin) + 0.6;

      const box = {x:10,y:10,w:W-20,h:H-20};
      const ax = drawAxes(ctx, box, "E[w] = μ (counts)", "Fano factor F (dimensionless)", xMin, xMax, yMin, yMax, {
        title: "Fano factor vs mean (sweep over μ)",
        ticks: 6,
        grid: true
      });

      // Baseline F=1
      ctx.save();
      ctx.strokeStyle = "rgba(96,165,250,.95)";
      ctx.lineWidth = 2.0;
      ctx.setLineDash([6,5]);
      ctx.beginPath();
      ctx.moveTo(ax.toX(xMin), ax.toY(1));
      ctx.lineTo(ax.toX(xMax), ax.toY(1));
      ctx.stroke();
      ctx.restore();

      // Cox: F = 1 + varw/mu
      ctx.save();
      ctx.strokeStyle = "rgba(167,139,250,.95)";
      ctx.lineWidth = 2.2;
      ctx.setLineDash([]);
      ctx.beginPath();
      for(let i=0;i<=240;i++){
        const mu = xMin + (xMax-xMin)*i/240;
        const F = 1 + varw/mu;
        const X = ax.toX(mu);
        const Y = ax.toY(F);
        if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
      }
      ctx.stroke();
      ctx.restore();

      // Selected operating point
      const muSel = clamp(state.muSel, xMin, xMax);
      const Fsel = 1 + varw/muSel;

      // vertical marker
      ctx.save();
      ctx.strokeStyle = "rgba(229,231,235,.40)";
      ctx.lineWidth = 1.5;
      ctx.setLineDash([4,4]);
      ctx.beginPath();
      ctx.moveTo(ax.toX(muSel), ax.py);
      ctx.lineTo(ax.toX(muSel), ax.py + ax.ph);
      ctx.stroke();
      ctx.restore();

      // dot
      ctx.save();
      ctx.fillStyle = "rgba(167,139,250,.95)";
      ctx.beginPath();
      ctx.arc(ax.toX(muSel), ax.toY(Fsel), 4.2, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // label box
      ctx.save();
      const label = `At μ=${fmt(muSel)}:  F=1+Var(w)/μ = ${fmt(Fsel)}`;
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      ctx.fillStyle = "rgba(229,231,235,.92)";
      ctx.fillText(label, ax.px+10, ax.py+16);
      ctx.restore();

      drawLegend(ctx, [
        {label:"Poisson: F=1", color:"rgba(96,165,250,.95)"},
        {label:"Cox: F=1+Var(w)/μ", color:"rgba(167,139,250,.95)"}
      ], ax.px+10, ax.py+ax.ph-18);
    }

    // Snapshot (all canvases)
    function snapshotAll(){
      const c1 = $("#cDiagram"), c2=$("#cMain"), c3=$("#cSecond");
      const w = Math.max(c1.width, c2.width, c3.width);
      const h = c1.height + c2.height + c3.height + 40;
      const out = document.createElement("canvas");
      out.width = w;
      out.height = h;
      const ctx = out.getContext("2d");
      ctx.fillStyle = "#0b0f17";
      ctx.fillRect(0,0,w,h);

      let y = 10;
      [c1,c2,c3].forEach((c, i)=>{
        ctx.drawImage(c, 10, y);
        y += c.height + 10;
      });

      const a = document.createElement("a");
      a.download = "cox-poisson-visuals.png";
      a.href = out.toDataURL("image/png");
      a.click();
    }

    // ---------- State + interactions ----------
    const state = {
      muSel: 20,
      varw: 30,
      dist: "gamma",
      mc: null
    };

    function updateUI(){
      $("#muSelVal").textContent = fmt(state.muSel);
      $("#varwVal").textContent = fmt(state.varw);
      $("#distVal").textContent = state.dist === "gamma" ? "Gamma" : "Lognormal";
      $("#mcVal").textContent = state.mc ? `N=${state.mc.N}` : "N=–";
    }

    function renderAll(){
      updateUI();
      drawDiagram();
      drawMainPlot(state);
      drawSecondPlot(state);
    }

    function resimulate(){
      // Monte Carlo at the selected operating point, using chosen distribution for w
      const mu = Math.max(1, state.muSel);
      const varw = Math.max(0, state.varw);
      const mc = mcStats(mu, varw, state.dist, 15000);
      state.mc = mc;
      updateUI();
      drawMainPlot(state);
      drawSecondPlot(state);
    }

    // Events
    $("#muSel").addEventListener("input", (e)=>{
      state.muSel = parseFloat(e.target.value);
      // For a smoother experience, keep MC marker but update plots
      renderAll();
    });

    $("#varw").addEventListener("input", (e)=>{
      state.varw = parseFloat(e.target.value);
      renderAll();
    });

    $("#dist").addEventListener("change", (e)=>{
      state.dist = e.target.value;
      updateUI();
    });

    $("#btnResim").addEventListener("click", ()=>{
      resimulate();
    });

    $("#btnDownloadPNG").addEventListener("click", snapshotAll);

    // Responsive redraw
    let rAF = null;
    function scheduleRedraw(){
      if (rAF) cancelAnimationFrame(rAF);
      rAF = requestAnimationFrame(()=>renderAll());
    }
    window.addEventListener("resize", scheduleRedraw);

    // Initial draw + initial MC
    renderAll();
    resimulate();

    // Smooth TOC scrolling
    document.querySelectorAll('.tocCard a[href^="#"]').forEach(a=>{
      a.addEventListener("click", (ev)=>{
        ev.preventDefault();
        const id = a.getAttribute("href");
        const el = document.querySelector(id);
        if(el) el.scrollIntoView({behavior:"smooth", block:"start"});
      });
    });
  </script>
</body>
</html>
