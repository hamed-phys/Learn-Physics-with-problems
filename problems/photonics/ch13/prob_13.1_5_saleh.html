<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Photon Energy: Electron Acceleration Voltage & Sum-Frequency Generation</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101a33;
      --panel2:#0f1830;
      --text:#eaf0ff;
      --muted:#b9c6ee;
      --faint:#93a6d8;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --ok:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 12px 40px rgba(0,0,0,.35);
      --radius:18px;
      --radius2:26px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html{ scroll-behavior:smooth; }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 10% 10%, rgba(125,211,252,.14), transparent 60%),
        radial-gradient(1000px 700px at 85% 15%, rgba(167,139,250,.12), transparent 55%),
        radial-gradient(900px 900px at 55% 95%, rgba(52,211,153,.10), transparent 60%),
        linear-gradient(180deg, #070a14, #0b1020 35%, #070a14);
      line-height:1.55;
    }

    header{
      padding: 42px 18px 22px;
      position:relative;
      overflow:hidden;
    }
    header .wrap{
      max-width: 1180px;
      margin: 0 auto;
      display:grid;
      grid-template-columns: 1.6fr 1fr;
      gap: 18px;
      align-items:end;
    }
    @media (max-width: 940px){
      header .wrap{ grid-template-columns:1fr; }
    }
    .titleCard{
      background: linear-gradient(135deg, rgba(125,211,252,.16), rgba(167,139,250,.10));
      border:1px solid var(--line);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      padding: 20px 22px;
    }
    h1{
      margin:0;
      font-size: clamp(1.4rem, 2.5vw, 2.2rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:8px 0 0;
      color:var(--muted);
      font-size: 1rem;
    }
    .meta{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 12px;
    }
    .pill{
      border:1px solid var(--line);
      background: rgba(16,26,51,.55);
      border-radius: 999px;
      padding: 6px 10px;
      color: var(--muted);
      font-size: .9rem;
    }

    .tocCard{
      background: rgba(16,26,51,.52);
      border:1px solid var(--line);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      padding: 16px 16px 12px;
    }
    .tocTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin:0 0 10px;
      font-size: 1rem;
      color: var(--text);
    }
    .tocCard nav a{
      display:block;
      padding: 7px 10px;
      margin: 4px 0;
      border-radius: 12px;
      text-decoration:none;
      color: var(--muted);
      border:1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
    }
    .tocCard nav a:hover{
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.20);
      transform: translateX(2px);
      color: var(--text);
    }

    main{
      max-width: 1180px;
      margin: 0 auto;
      padding: 0 18px 60px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 18px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{ grid-template-columns:1fr; }
    }

    aside.sticky{
      position: sticky;
      top: 14px;
      z-index: 2;
    }
    @media (max-width: 980px){
      aside.sticky{ position:relative; top:auto; }
    }

    .card{
      background: rgba(16,26,51,.52);
      border:1px solid var(--line);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      padding: 18px 18px;
      overflow:hidden;
    }
    .card h2, .card h3{
      margin: 0 0 10px;
      letter-spacing:.2px;
    }
    .card h2{ font-size: 1.15rem; }
    .card h3{ font-size: 1.05rem; color: var(--text); }

    .section{
      margin-bottom: 18px;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 860px){
      .grid2{ grid-template-columns: 1fr; }
    }

    .callout{
      border:1px solid rgba(125,211,252,.22);
      background: rgba(125,211,252,.08);
      border-radius: 16px;
      padding: 12px 12px;
      margin: 10px 0;
    }
    .callout.warn{
      border-color: rgba(251,191,36,.28);
      background: rgba(251,191,36,.08);
    }
    .callout.ok{
      border-color: rgba(52,211,153,.26);
      background: rgba(52,211,153,.08);
    }
    .callout.bad{
      border-color: rgba(251,113,133,.28);
      background: rgba(251,113,133,.08);
    }
    .small{
      color: var(--muted);
      font-size: .95rem;
    }
    ul{ margin: 8px 0 0 20px; }
    li{ margin: 6px 0; }

    .eq{
      font-family: var(--mono);
      font-size: .96rem;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.09);
      border-radius: 12px;
      padding: 2px 8px;
      white-space: nowrap;
    }
    .eqblock{
      margin: 10px 0;
      padding: 12px 12px;
      border-radius: 16px;
      border:1px solid rgba(167,139,250,.22);
      background: rgba(167,139,250,.08);
      overflow:auto;
      position: relative;
    }
    .eqblock code{
      font-family: var(--mono);
      font-size: .95rem;
      color: var(--text);
      display:block;
      white-space: pre;
    }

    .copyBtn{
      position:absolute;
      top: 10px;
      right: 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(16,26,51,.7);
      color: var(--text);
      padding: 6px 10px;
      font-size: .85rem;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(125,211,252,.12);
      border-color: rgba(125,211,252,.28);
    }
    .copyBtn:active{ transform: translateY(0px) scale(.99); }

    .controls{
      display:grid;
      gap: 10px;
      margin-top: 10px;
    }
    .control{
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 10px 10px;
      background: rgba(15,24,48,.55);
    }
    .control label{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap: 10px;
      font-size: .95rem;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .control input[type="range"]{
      width:100%;
    }
    .val{
      font-family: var(--mono);
      color: var(--text);
      font-size: .95rem;
    }
    .btnRow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top: 8px;
    }
    .btn{
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(16,26,51,.7);
      color: var(--text);
      padding: 8px 12px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size: .9rem;
    }
    .btn:hover{
      transform: translateY(-1px);
      background: rgba(52,211,153,.10);
      border-color: rgba(52,211,153,.28);
    }
    .btn:active{ transform: translateY(0px) scale(.99); }

    figure{
      margin: 0;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius: 18px;
      border:1px solid var(--line);
      background: rgba(7,10,20,.55);
    }
    .canvasWrap{
      padding: 10px;
      border-radius: 22px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(15,24,48,.35);
    }
    .figcap{
      margin-top: 10px;
      color: var(--muted);
      font-size: .92rem;
    }

    .answerBox{
      border:1px solid rgba(52,211,153,.26);
      background: rgba(52,211,153,.08);
      border-radius: 18px;
      padding: 12px;
      position:relative;
      overflow:hidden;
    }
    .answerBox h3{ margin:0 0 8px; }
    .answerBox pre{
      margin:0;
      font-family: var(--mono);
      white-space: pre-wrap;
      color: var(--text);
    }

    footer{
      max-width: 1180px;
      margin: 0 auto;
      padding: 0 18px 40px;
      color: var(--faint);
      font-size: .9rem;
    }

    @media print{
      body{ background:#fff; color:#000; }
      header, main, footer{ max-width: 100%; }
      .card, .titleCard, .tocCard{ box-shadow:none; background:#fff; border:1px solid #ddd; }
      .eq{ background:#f6f6f6; border-color:#ddd; }
      canvas{ border:1px solid #bbb; }
      .copyBtn, .btn, input{ display:none !important; }
      aside.sticky{ position:relative; top:auto; }
      a{ color:#000; }
    }
  </style>
</head>

<body>
<header>
  <div class="wrap">
    <div class="titleCard">
      <h1>Photon Energy: Matching Electron Acceleration Energy & Sum-Frequency Generation</h1>
      <p class="subtitle">
        Two classic “energy bookkeeping” problems: (a) equate an electron’s gained kinetic energy to a photon energy,
        (b) add photon energies (equivalently frequencies) in nonlinear optics.
      </p>
      <div class="meta">
        <span class="pill">Topic: Photon energy, eV, accelerating voltage</span>
        <span class="pill">Topic: Sum-frequency generation (SFG)</span>
        <span class="pill">Tools: <span class="eq">E = hc/λ</span>, <span class="eq">K = eV</span>, <span class="eq">ν = c/λ</span></span>
      </div>
    </div>

    <div class="tocCard" aria-label="Table of contents">
      <div class="tocTitle">
        <strong>Table of Contents</strong>
        <span class="pill" style="font-size:.82rem;">sticky</span>
      </div>
      <nav>
        <a href="#quick">Quick Summary</a>
        <a href="#primer">PART 0 — Concept Primer</a>
        <a href="#analysis">PART 1 — Problem Analysis</a>
        <a href="#strategy">PART 2 — Strategy & Tips</a>
        <a href="#solution">PART 3 — Full Solution</a>
        <a href="#deeper">PART 4 — Deeper Understanding</a>
        <a href="#vizguide">PART 5 — Visualization Guide</a>
      </nav>
    </div>
  </div>
</header>

<main>
  <aside class="sticky">
    <div class="card">
      <h2>Interactive Explorer</h2>
      <p class="small">
        One slider (the short wavelength <span class="eq">λ<sub>s</sub></span>) updates <em>all</em> canvases live.
        Use the preset buttons to jump to the problem’s given numbers.
      </p>

      <div class="controls">
        <div class="control">
          <label>
            <span>Short wavelength <span class="eq">λ<sub>s</sub></span> (µm) — used as <span class="eq">λ<sub>0</sub></span> in (a) and <span class="eq">λ<sub>1</sub></span> in (b)</span>
            <span class="val" id="lsVal">1.060</span>
          </label>
          <input id="ls" type="range" min="0.40" max="2.00" step="0.001" value="1.060" />
          <div class="small">Physics: sets photon energy <span class="eq">E=hc/λ</span>, thus voltage <span class="eq">V=E/e</span>, and affects SFG output.</div>
        </div>

        <div class="control">
          <label>
            <span>Long wavelength <span class="eq">λ<sub>2</sub></span> (µm) — SFG second input</span>
            <span class="val" id="l2Val">10.600</span>
          </label>
          <input id="l2" type="range" min="2.00" max="15.00" step="0.010" value="10.600" />
          <div class="small">Physics: changing <span class="eq">λ<sub>2</sub></span> changes the summed frequency and the output <span class="eq">λ<sub>3</sub></span>.</div>
        </div>

        <div class="btnRow">
          <button class="btn" id="presetA">Preset (a): λ₀ = 0.87 µm</button>
          <button class="btn" id="presetB">Preset (b): λ₁ = 1.06 µm, λ₂ = 10.6 µm</button>
        </div>

        <div class="answerBox" style="margin-top:10px;">
          <h3 style="margin:0 0 8px;">Live computed values</h3>
          <pre id="liveReadout">—</pre>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:18px;">
      <h2>Copy-ready results</h2>

      <div class="eqblock" id="eq1">
        <button class="copyBtn" data-copy="eq1">Copy</button>
        <code>Photon energy:  E = hν = hc/λ</code>
      </div>

      <div class="eqblock" id="eq2">
        <button class="copyBtn" data-copy="eq2">Copy</button>
        <code>Electron accelerated through V:  K = eV   (nonrelativistic, electrostatic work)</code>
      </div>

      <div class="eqblock" id="eq3">
        <button class="copyBtn" data-copy="eq3">Copy</button>
        <code>Sum-frequency generation:  ν₃ = ν₁ + ν₂  ⇒  1/λ₃ = 1/λ₁ + 1/λ₂</code>
      </div>

      <div class="answerBox" id="finalBox">
        <button class="copyBtn" data-copy="finalBox">Copy</button>
        <h3>Final numeric answers (problem’s given values)</h3>
        <pre id="finalText">
(a) V ≈ 1.43 V  (for λ₀ = 0.87 µm)

(b) λ₃ ≈ 0.964 µm ≈ 0.96 µm  (for λ₁ = 1.06 µm and λ₂ = 10.6 µm)
        </pre>
      </div>
    </div>
  </aside>

  <article>
    <section class="card section" id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li>We compare a photon’s energy <span class="eq">E = hc/λ</span> to an electron’s gained kinetic energy in an electric potential <span class="eq">K = eV</span>.</li>
        <li>Part (a): set <span class="eq">eV = hc/λ₀</span> to find the required accelerating voltage.</li>
        <li>Part (b): in sum-frequency generation (SFG), photon energies add: <span class="eq">E₃ = E₁ + E₂</span>, equivalently <span class="eq">ν₃ = ν₁ + ν₂</span>.</li>
        <li>Because <span class="eq">ν = c/λ</span>, SFG implies <span class="eq">1/λ₃ = 1/λ₁ + 1/λ₂</span>.</li>
        <li>Numerical results: (a) <span class="eq">V ≈ 1.43 V</span> for <span class="eq">λ₀ = 0.87 µm</span>; (b) <span class="eq">λ₃ ≈ 0.964 µm</span> for <span class="eq">λ₁ = 1.06 µm</span>, <span class="eq">λ₂ = 10.6 µm</span>.</li>
        <li>Visualization: energy–wavelength curve + markers; and a sweep plot of <span class="eq">λ₃</span> vs <span class="eq">λ₂</span>, updated live by the slider.</li>
      </ul>
    </section>

    <section class="card section" id="primer">
      <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

      <h3>Core definitions (symbols & units)</h3>
      <ul>
        <li><span class="eq">h</span> — Planck’s constant (J·s). Governs quantization: photon energy is proportional to frequency.</li>
        <li><span class="eq">c</span> — speed of light in vacuum (m/s).</li>
        <li><span class="eq">λ</span> — wavelength (m, often µm in optics). Related to frequency via <span class="eq">ν = c/λ</span> (vacuum).</li>
        <li><span class="eq">E</span> — photon energy (J or eV). <span class="eq">1 eV = 1.602×10⁻¹⁹ J</span>.</li>
        <li><span class="eq">e</span> — elementary charge magnitude (C). An electron has charge <span class="eq">q = −e</span>.</li>
        <li><span class="eq">V</span> — electric potential difference (volts). Energy gained by charge <span class="eq">q</span> is <span class="eq">ΔU = qV</span> (J).</li>
      </ul>

      <h3>Physical meaning of key quantities</h3>
      <ul>
        <li><span class="eq">E = hc/λ</span> means shorter wavelengths carry higher energy per photon (blue/UV photons are “more energetic”).</li>
        <li><span class="eq">eV</span> is a convenient energy unit in atomic/optical physics: accelerating an electron through 1 volt gives it 1 eV of kinetic energy (if losses are negligible).</li>
        <li>In nonlinear optics, SFG is a process where the medium’s nonlinear polarization can couple two input waves and generate a new wave at the <em>sum</em> frequency.</li>
      </ul>

      <div class="callout ok">
        <strong>Key laws / principles</strong>
        <ul>
          <li><span class="eq">E = hν = hc/λ</span> (photon energy in vacuum).</li>
          <li>Electrostatic work–energy: a particle accelerated across a potential difference gains kinetic energy
            <span class="eq">K = |q|V</span> (for an electron: <span class="eq">K = eV</span>).</li>
          <li>SFG energy conservation (photon picture): <span class="eq">E₃ = E₁ + E₂</span> ⇒ <span class="eq">ν₃ = ν₁ + ν₂</span>.</li>
        </ul>
      </div>

      <h3>Models / approximations (and why they’re used)</h3>
      <ul>
        <li><strong>Nonrelativistic electron</strong>: here energies are ~eV, far below the electron rest energy (511 keV). So <span class="eq">K = eV</span> is sufficient; no relativistic correction needed.</li>
        <li><strong>Vacuum wavelength relations</strong>: the problem states free-space wavelengths. In a medium, <span class="eq">ν</span> stays the same but <span class="eq">λ</span> changes; SFG is most cleanly expressed using frequencies.</li>
        <li><strong>Ideal SFG energy bookkeeping</strong>: we use only energy conservation. Real crystals also require phase matching to get efficient generation, but that’s not needed to compute <span class="eq">λ₃</span>.</li>
      </ul>

      <h3>Mini intuition examples</h3>
      <ul>
        <li>If you halve the wavelength, photon energy doubles (because <span class="eq">E ∝ 1/λ</span>).</li>
        <li>If one SFG input is very long-wavelength (small frequency), it only slightly shifts the output relative to the short-wavelength input.</li>
      </ul>

      <div class="callout warn">
        <strong>What to watch for (pitfalls)</strong>
        <ul>
          <li>Mixing up wavelength addition with frequency addition: in SFG you add <em>frequencies</em>, not wavelengths.</li>
          <li>Unit slips: µm vs nm vs m; eV vs J.</li>
          <li>Sign confusion for electrons: kinetic energy gain depends on <span class="eq">|q|</span>, so use <span class="eq">eV</span> for magnitude.</li>
          <li>For large voltages (keV–MeV), relativistic kinetic energy would matter—here it does not.</li>
        </ul>
      </div>
    </section>

    <section class="card section" id="analysis">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>Problem restatement (in plain language)</h3>
      <ul>
        <li><strong>(a)</strong> Find the potential difference (voltage) needed so an electron starting from rest gains the same energy as a photon with wavelength <span class="eq">λ₀ = 0.87 µm</span>.</li>
        <li><strong>(b)</strong> Two photons with wavelengths <span class="eq">λ₁ = 1.06 µm</span> and <span class="eq">λ₂ = 10.6 µm</span> combine to form one photon whose energy equals the sum. Find the output wavelength <span class="eq">λ₃</span>.</li>
      </ul>

      <h3>Given quantities</h3>
      <ul>
        <li>(a) <span class="eq">λ₀ = 0.87 µm</span>.</li>
        <li>(b) <span class="eq">λ₁ = 1.06 µm</span>, <span class="eq">λ₂ = 10.6 µm</span>.</li>
      </ul>

      <h3>Unknowns</h3>
      <ul>
        <li>(a) Required accelerating voltage <span class="eq">V</span>.</li>
        <li>(b) Resultant wavelength <span class="eq">λ₃</span>.</li>
      </ul>

      <h3>Relevant physical principles (and why they apply)</h3>
      <ul>
        <li><span class="eq">E = hc/λ</span> applies because photon energy depends only on frequency (or wavelength in vacuum).</li>
        <li><span class="eq">K = eV</span> applies because the work done by an electrostatic potential on a charge becomes kinetic energy (neglecting losses).</li>
        <li><span class="eq">E₃ = E₁ + E₂</span> applies because the problem explicitly describes a process producing a photon with the sum energy (SFG).</li>
      </ul>

      <div class="callout">
        <strong>Assumptions (explicit)</strong>
        <ul>
          <li>Electron starts from rest and gains kinetic energy only from the electric field (no radiation loss, collisions, or space-charge effects).</li>
          <li>Voltages are small enough that electron motion is nonrelativistic (true for ~1 eV).</li>
          <li>Wavelengths are free-space values; for SFG we use frequency addition (energy conservation), ignoring phase-matching constraints.</li>
        </ul>
      </div>

      <h3>Possible approaches (pros/cons)</h3>
      <ul>
        <li><strong>Approach 1 (direct energy matching)</strong>: compute photon energy from <span class="eq">E=hc/λ</span> and set equal to <span class="eq">eV</span>. Fast, minimal algebra. ✅ Best here.</li>
        <li><strong>Approach 2 (use “1240 rule”)</strong>: use <span class="eq">E(eV) ≈ 1240 / λ(nm)</span>. Very quick numerically, but easy to mis-handle units.</li>
        <li><strong>Approach 3 (frequency picture for SFG)</strong>: compute <span class="eq">ν=c/λ</span>, add, then invert. Conceptually clean for nonlinear optics. Also straightforward.</li>
      </ul>

      <p class="small">
        We’ll use Approach 1 for (a) and the frequency-based version for (b), which naturally yields the neat relation
        <span class="eq">1/λ₃ = 1/λ₁ + 1/λ₂</span>.
      </p>
    </section>

    <section class="card section" id="strategy">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

      <ol style="margin:8px 0 0 20px;">
        <li>
          <strong>Convert wavelength to photon energy</strong><br/>
          Tool: <span class="eq">E = hc/λ</span><br/>
          Meaning: establishes the energy “budget” per photon.
        </li>
        <li>
          <strong>Relate electron energy gain to voltage</strong><br/>
          Tool: <span class="eq">K = eV</span><br/>
          Meaning: the potential difference sets the electron’s kinetic energy.
        </li>
        <li>
          <strong>Equate energies for part (a)</strong><br/>
          Tool: <span class="eq">eV = hc/λ₀</span><br/>
          Meaning: choose V so the electron matches the photon energy.
        </li>
        <li>
          <strong>Write SFG energy conservation for part (b)</strong><br/>
          Tool: <span class="eq">E₃ = E₁ + E₂</span> or <span class="eq">ν₃ = ν₁ + ν₂</span><br/>
          Meaning: output photon has higher frequency than either input.
        </li>
        <li>
          <strong>Convert frequency sum to wavelength</strong><br/>
          Tool: <span class="eq">ν = c/λ</span> ⇒ <span class="eq">1/λ₃ = 1/λ₁ + 1/λ₂</span><br/>
          Meaning: output wavelength is dominated by the shorter input.
        </li>
        <li>
          <strong>Sanity checks</strong><br/>
          Tools: units, limiting cases (e.g., <span class="eq">λ₂ → ∞</span>)<br/>
          Meaning: verify the result “behaves” physically.
        </li>
      </ol>

      <div class="callout warn">
        <strong>Common mistakes & quick tips</strong>
        <ul>
          <li>Don’t add wavelengths for SFG; add frequencies (or reciprocals of wavelengths).</li>
          <li>Remember: <span class="eq">1 eV</span> corresponds to <span class="eq">1 V</span> for a single electron. So once you have <span class="eq">E</span> in eV, the voltage is the same number in volts.</li>
          <li>Keep wavelength units consistent (µm everywhere is convenient here).</li>
        </ul>
      </div>
    </section>

    <section class="card section" id="solution">
      <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

      <h3>Physical intuition (before calculating)</h3>
      <ul>
        <li>A near-infrared photon (around 1 µm) has energy on the order of ~1 eV. So we expect the required voltage in (a) to be around 1 volt.</li>
        <li>In SFG, adding a small frequency (from a long wavelength) to a larger frequency (from a short wavelength) produces an output that is only slightly higher in frequency than the short-wave input. So <span class="eq">λ₃</span> should be slightly <em>shorter</em> than 1.06 µm.</li>
      </ul>

      <div class="grid2">
        <div>
          <h3>(a) Electron acceleration voltage matching a photon energy</h3>

          <p>
            <strong>Step 1: Photon energy from wavelength.</strong><br/>
            Let <span class="eq">λ₀</span> be the photon wavelength. Photon energy is
            <span class="eq">Eₚ = hc/λ₀</span>.
          </p>

          <div class="eqblock" id="a1">
            <button class="copyBtn" data-copy="a1">Copy</button>
            <code>Eₚ = hν = hc/λ₀</code>
          </div>

          <p class="small">
            Here <span class="eq">h</span> and <span class="eq">c</span> are constants; shorter <span class="eq">λ₀</span> means larger energy.
          </p>

          <p>
            <strong>Step 2: Electron kinetic energy gained from a potential.</strong><br/>
            An electron accelerated from rest across a potential difference <span class="eq">V</span> gains kinetic energy (magnitude)
            <span class="eq">K = eV</span>, where <span class="eq">e</span> is the elementary charge magnitude.
          </p>

          <div class="eqblock" id="a2">
            <button class="copyBtn" data-copy="a2">Copy</button>
            <code>K = eV</code>
          </div>

          <p>
            <strong>Step 3: Match energies.</strong><br/>
            We require <span class="eq">K = Eₚ</span>, so:
          </p>

          <div class="eqblock" id="a3">
            <button class="copyBtn" data-copy="a3">Copy</button>
            <code>eV = hc/λ₀  ⇒  V = (hc/e)·(1/λ₀)</code>
          </div>

          <p>
            <strong>Numerical evaluation.</strong><br/>
            A very handy constant is <span class="eq">hc ≈ 1.23984 eV·µm</span>. Therefore
            <span class="eq">E(eV) = 1.23984 / λ(µm)</span>.
          </p>

          <p>
            For <span class="eq">λ₀ = 0.87 µm</span>:
          </p>

          <div class="eqblock" id="a4">
            <button class="copyBtn" data-copy="a4">Copy</button>
            <code>Eₚ ≈ 1.23984 / 0.87  eV ≈ 1.425  eV
V = Eₚ/e  ⇒  V ≈ 1.425 V</code>
          </div>

          <div class="callout ok">
            <strong>Answer (a)</strong>: <span class="eq">V ≈ 1.43 V</span>.
          </div>

          <h3>Sanity checks (a)</h3>
          <ul>
            <li><strong>Units:</strong> <span class="eq">hc/λ</span> gives energy; dividing by <span class="eq">e</span> gives volts. ✅</li>
            <li><strong>Magnitude:</strong> near-IR photon energies ~1 eV → volt-scale voltage. ✅</li>
            <li><strong>Relativistic?</strong> 1.4 eV ≪ 511,000 eV → safely nonrelativistic. ✅</li>
          </ul>
        </div>

        <div>
          <h3>(b) Wavelength of the photon produced by sum-frequency generation (SFG)</h3>

          <p>
            <strong>Step 1: State energy conservation in photon form.</strong><br/>
            The problem says the output photon energy equals the sum:
            <span class="eq">E₃ = E₁ + E₂</span>.
            Using <span class="eq">E = hν</span>, this becomes
            <span class="eq">hν₃ = hν₁ + hν₂</span> ⇒ <span class="eq">ν₃ = ν₁ + ν₂</span>.
          </p>

          <div class="eqblock" id="b1">
            <button class="copyBtn" data-copy="b1">Copy</button>
            <code>ν₃ = ν₁ + ν₂</code>
          </div>

          <p class="small">
            This is the cleanest way to think about SFG: frequencies add.
          </p>

          <p>
            <strong>Step 2: Convert frequency to wavelength.</strong><br/>
            In vacuum, <span class="eq">ν = c/λ</span>. Substitute into <span class="eq">ν₃ = ν₁ + ν₂</span>:
          </p>

          <div class="eqblock" id="b2">
            <button class="copyBtn" data-copy="b2">Copy</button>
            <code>c/λ₃ = c/λ₁ + c/λ₂
⇒ 1/λ₃ = 1/λ₁ + 1/λ₂</code>
          </div>

          <p>
            <strong>Step 3: Plug in numbers.</strong><br/>
            With <span class="eq">λ₁ = 1.06 µm</span> and <span class="eq">λ₂ = 10.6 µm</span>:
          </p>

          <div class="eqblock" id="b3">
            <button class="copyBtn" data-copy="b3">Copy</button>
            <code>1/λ₃ = 1/1.06 + 1/10.6   (µm⁻¹)
= 0.943396... + 0.0943396...
= 1.0377358...   (µm⁻¹)

λ₃ = 1 / 1.0377358...  µm ≈ 0.9636 µm</code>
          </div>

          <div class="callout ok">
            <strong>Answer (b)</strong>: <span class="eq">λ₃ ≈ 0.964 µm</span> (≈ 0.96 µm).
          </div>

          <h3>Sanity checks (b)</h3>
          <ul>
            <li><strong>Limiting case:</strong> if <span class="eq">λ₂ → ∞</span> (ν₂→0), then <span class="eq">1/λ₃ → 1/λ₁</span> ⇒ <span class="eq">λ₃ → λ₁</span>. Our finite <span class="eq">λ₂</span> makes <span class="eq">λ₃</span> slightly smaller than <span class="eq">λ₁</span>. ✅</li>
            <li><strong>Direction:</strong> ν₃ > ν₁, so λ₃ < λ₁. We got 0.964 µm < 1.06 µm. ✅</li>
            <li><strong>Units:</strong> reciprocal micrometers add; invert gives micrometers. ✅</li>
          </ul>
        </div>
      </div>

      <div class="callout">
        <strong>Connection to the diagram & plots</strong><br/>
        The diagram canvas shows (a) an electron accelerated through a potential <span class="eq">V</span>, and (b) two input photons entering a nonlinear crystal to produce one output at the sum frequency.
        The main plot visualizes how photon energy drops as wavelength increases, while markers show the specific wavelengths/energies used.
        The sweep plot shows how the SFG output wavelength <span class="eq">λ₃</span> moves as you vary the long-wavelength input <span class="eq">λ₂</span>.
      </div>
    </section>

    <section class="card section" id="deeper">
      <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

      <h3>Re-interpreting the final formulas</h3>
      <ul>
        <li>
          <strong>Part (a):</strong> <span class="eq">V = (hc/e)(1/λ₀)</span>.
          The constant <span class="eq">hc/e</span> sets the scale; the <span class="eq">1/λ₀</span> factor means shorter wavelength light corresponds to larger required voltage.
        </li>
        <li>
          <strong>Part (b):</strong> <span class="eq">1/λ₃ = 1/λ₁ + 1/λ₂</span>.
          The shorter wavelength (larger reciprocal) typically dominates. If <span class="eq">λ₂</span> is very large, its contribution is small.
        </li>
      </ul>

      <h3>How parameters affect outcomes (linked to the interactive plots)</h3>
      <ul>
        <li>Move the <span class="eq">λ<sub>s</sub></span> slider to smaller values: the energy markers on the main plot rise, and the computed voltage increases.</li>
        <li>For SFG, decreasing <span class="eq">λ<sub>s</sub></span> (so increasing ν₁) generally makes <span class="eq">λ₃</span> smaller; the sweep curve shifts downward.</li>
        <li>Increasing <span class="eq">λ₂</span> (making ν₂ smaller) pulls <span class="eq">λ₃</span> back toward <span class="eq">λ₁</span>.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p class="small">
        You can derive the SFG wavelength relation by adding photon <em>energies</em> directly:
        <span class="eq">hc/λ₃ = hc/λ₁ + hc/λ₂</span>. Cancel <span class="eq">hc</span> to get the same reciprocal-wavelength sum.
        The frequency viewpoint is often preferred because it remains conceptually correct in media (frequencies stay fixed across boundaries).
      </p>

      <h3>Concept check (quick self-test)</h3>
      <ul>
        <li><strong>Q:</strong> If wavelength halves, what happens to photon energy? <strong>A:</strong> It doubles (since <span class="eq">E ∝ 1/λ</span>).</li>
        <li><strong>Q:</strong> In SFG, do you add wavelengths or frequencies? <strong>A:</strong> Frequencies (or equivalently reciprocals of wavelengths).</li>
        <li><strong>Q:</strong> Why is voltage numerically equal to energy in eV for an electron? <strong>A:</strong> Because <span class="eq">1 eV</span> is the energy gained by charge <span class="eq">e</span> across <span class="eq">1 V</span>.</li>
        <li><strong>Q:</strong> If <span class="eq">λ₂</span> becomes extremely long, what should <span class="eq">λ₃</span> approach? <strong>A:</strong> <span class="eq">λ₃ → λ₁</span>.</li>
      </ul>
    </section>

    <section class="card section" id="vizguide">
      <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

      <div class="grid2">
        <figure class="canvasWrap">
          <canvas id="diag" width="900" height="520" aria-label="Diagram canvas"></canvas>
          <figcaption class="figcap">
            <strong>Diagram:</strong> Left: an electron accelerated through voltage <span class="eq">V</span>. Right: SFG in a nonlinear crystal where <span class="eq">ν₃=ν₁+ν₂</span>.
          </figcaption>
        </figure>

        <figure class="canvasWrap">
          <canvas id="plot1" width="900" height="520" aria-label="Main plot canvas"></canvas>
          <figcaption class="figcap">
            <strong>Main plot:</strong> photon energy <span class="eq">E(λ)=hc/λ</span> (in eV) vs wavelength (µm). Markers show <span class="eq">λ<sub>s</sub></span>, <span class="eq">λ₂</span>, and the SFG output <span class="eq">λ₃</span>.
          </figcaption>
        </figure>
      </div>

      <figure class="canvasWrap" style="margin-top:14px;">
        <canvas id="plot2" width="1100" height="520" aria-label="Secondary sweep plot canvas"></canvas>
        <figcaption class="figcap">
          <strong>Secondary plot (parameter sweep):</strong> output wavelength <span class="eq">λ₃</span> vs the long input <span class="eq">λ₂</span>, using
          <span class="eq">1/λ₃ = 1/λ₁ + 1/λ₂</span> with <span class="eq">λ₁ = λ<sub>s</sub></span>. The dot marks the current <span class="eq">λ₂</span>.
        </figcaption>
      </figure>

      <div class="callout">
        <strong>Interactive controls</strong>
        <ul>
          <li><span class="eq">λ<sub>s</sub></span> slider: updates all canvases by changing photon energy (thus voltage) and the SFG output computed with <span class="eq">λ₁=λ<sub>s</sub></span>.</li>
          <li><span class="eq">λ₂</span> slider: changes the long-wave input and moves the SFG output marker and sweep-dot.</li>
          <li>Preset buttons: jump to the exact values used in the problem for quick comparison.</li>
        </ul>
      </div>
    </section>
  </article>
</main>

<footer>
  <p>
    Built with vanilla HTML/CSS/JS. Canvas plots are devicePixelRatio-aware for crisp rendering.
    Numerical constants used: <span class="eq">hc ≈ 1.239841984 eV·µm</span>.
  </p>
</footer>

<script>
/* =========================
   Utilities: copy buttons
========================= */
(function(){
  function textFromBlock(el){
    // If it's an answerBox, copy its <pre>. If eqblock, copy code.
    const pre = el.querySelector('pre');
    if(pre) return pre.innerText.trim();
    const code = el.querySelector('code');
    if(code) return code.innerText.trim();
    return el.innerText.trim();
  }
  document.querySelectorAll('.copyBtn').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const id = btn.getAttribute('data-copy');
      const el = document.getElementById(id);
      if(!el) return;
      const text = textFromBlock(el);
      try{
        await navigator.clipboard.writeText(text);
        const old = btn.textContent;
        btn.textContent = "Copied!";
        setTimeout(()=>btn.textContent = old, 800);
      }catch(e){
        const old = btn.textContent;
        btn.textContent = "Copy failed";
        setTimeout(()=>btn.textContent = old, 900);
      }
    });
  });
})();

/* =========================
   Physics constants & helpers
========================= */
const HC_eV_um = 1.239841984; // eV·µm
function photonEnergy_eV(lambda_um){
  return HC_eV_um / lambda_um;
}
function sfg_lambda3_um(lambda1_um, lambda2_um){
  // 1/λ3 = 1/λ1 + 1/λ2
  return 1.0 / (1.0/lambda1_um + 1.0/lambda2_um);
}

/* =========================
   Canvas rendering framework
========================= */
function setupHiDPICanvas(canvas){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  const cssW = Math.max(240, rect.width);
  // Keep aspect ratio from attributes:
  const aspect = canvas.height / canvas.width;
  const cssH = Math.max(220, cssW * aspect);

  canvas.style.width = cssW + "px";
  canvas.style.height = cssH + "px";
  canvas.width = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);

  const ctx = canvas.getContext("2d");
  ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  return {ctx, w: cssW, h: cssH, dpr};
}

function clearPanel(ctx,w,h){
  ctx.clearRect(0,0,w,h);
  // soft gradient background
  const g = ctx.createLinearGradient(0,0,w,h);
  g.addColorStop(0, "rgba(7,10,20,0.10)");
  g.addColorStop(1, "rgba(7,10,20,0.55)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,w,h);
}

/* =========================
   Plot primitives (axes, ticks, grid)
========================= */
function niceStep(range){
  // range in data units, return a "nice" tick step
  const raw = range / 6;
  const p = Math.pow(10, Math.floor(Math.log10(raw)));
  const n = raw / p;
  let step;
  if(n < 1.5) step = 1*p;
  else if(n < 3) step = 2*p;
  else if(n < 7) step = 5*p;
  else step = 10*p;
  return step;
}

function drawAxes(ctx, box, xMin,xMax,yMin,yMax, xLabel,yLabel, title){
  const {x,y,w,h} = box;

  // Title
  ctx.save();
  ctx.fillStyle = "rgba(234,240,255,0.95)";
  ctx.font = "600 14px ui-sans-serif, system-ui";
  ctx.fillText(title, x+8, y+18);
  ctx.restore();

  // Plot area padding for labels
  const padL = 56, padR = 18, padT = 28, padB = 44;
  const px = x + padL;
  const py = y + padT;
  const pw = w - padL - padR;
  const ph = h - padT - padB;

  // Frame
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.14)";
  ctx.lineWidth = 1;
  roundRect(ctx, px, py, pw, ph, 14);
  ctx.stroke();
  ctx.restore();

  // Grid + ticks
  const xRange = xMax - xMin;
  const yRange = yMax - yMin;
  const xStep = niceStep(xRange);
  const yStep = niceStep(yRange);

  ctx.save();
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas";
  ctx.fillStyle = "rgba(185,198,238,0.92)";
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.lineWidth = 1;

  // x ticks
  const xStart = Math.ceil(xMin / xStep) * xStep;
  for(let xv = xStart; xv <= xMax + 1e-9; xv += xStep){
    const X = px + (xv - xMin) / xRange * pw;
    // gridline
    ctx.beginPath();
    ctx.moveTo(X, py);
    ctx.lineTo(X, py+ph);
    ctx.stroke();

    // tick label
    const txt = formatTick(xv);
    ctx.fillText(txt, X - ctx.measureText(txt).width/2, py+ph+18);
    // tick mark
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.beginPath();
    ctx.moveTo(X, py+ph);
    ctx.lineTo(X, py+ph+6);
    ctx.stroke();
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
  }

  // y ticks
  const yStart = Math.ceil(yMin / yStep) * yStep;
  for(let yv = yStart; yv <= yMax + 1e-9; yv += yStep){
    const Y = py + ph - (yv - yMin) / yRange * ph;
    ctx.beginPath();
    ctx.moveTo(px, Y);
    ctx.lineTo(px+pw, Y);
    ctx.stroke();

    const txt = formatTick(yv);
    ctx.fillText(txt, px - 8 - ctx.measureText(txt).width, Y + 4);

    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.beginPath();
    ctx.moveTo(px-6, Y);
    ctx.lineTo(px, Y);
    ctx.stroke();
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
  }

  // Axis labels
  ctx.save();
  ctx.fillStyle = "rgba(234,240,255,0.92)";
  ctx.font = "600 12.5px ui-sans-serif, system-ui";
  // x label
  const xlw = ctx.measureText(xLabel).width;
  ctx.fillText(xLabel, px + pw/2 - xlw/2, y + h - 12);
  // y label (rotated)
  ctx.translate(x + 14, py + ph/2);
  ctx.rotate(-Math.PI/2);
  const ylw = ctx.measureText(yLabel).width;
  ctx.fillText(yLabel, -ylw/2, 0);
  ctx.restore();

  ctx.restore();

  return {px,py,pw,ph, xMin,xMax,yMin,yMax};
}

function formatTick(v){
  const av = Math.abs(v);
  if(av >= 100) return v.toFixed(0);
  if(av >= 10) return v.toFixed(1);
  if(av >= 1) return v.toFixed(2);
  if(av >= 0.1) return v.toFixed(3);
  return v.toExponential(1);
}

function toX(frame, xVal){
  return frame.px + (xVal - frame.xMin)/(frame.xMax-frame.xMin)*frame.pw;
}
function toY(frame, yVal){
  return frame.py + frame.ph - (yVal - frame.yMin)/(frame.yMax-frame.yMin)*frame.ph;
}

function roundRect(ctx, x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

function drawLegend(ctx, items, x, y){
  ctx.save();
  ctx.font = "12px ui-sans-serif, system-ui";
  const pad = 10, lineH = 18;
  let w = 0;
  items.forEach(it=>{
    const tw = ctx.measureText(it.label).width;
    w = Math.max(w, 26 + tw);
  });
  const h = pad*2 + items.length*lineH;
  ctx.fillStyle = "rgba(16,26,51,0.72)";
  ctx.strokeStyle = "rgba(255,255,255,0.14)";
  roundRect(ctx, x, y, w + pad*2, h, 14);
  ctx.fill();
  ctx.stroke();

  items.forEach((it,i)=>{
    const yy = y + pad + i*lineH + 12;
    // symbol
    ctx.strokeStyle = it.color;
    ctx.fillStyle = it.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x+pad, yy);
    ctx.lineTo(x+pad+16, yy);
    ctx.stroke();
    if(it.marker){
      ctx.beginPath();
      ctx.arc(x+pad+8, yy, 4, 0, Math.PI*2);
      ctx.fill();
    }
    // text
    ctx.fillStyle = "rgba(234,240,255,0.95)";
    ctx.fillText(it.label, x+pad+22, yy+4);
  });

  ctx.restore();
}

/* =========================
   Diagram canvas
========================= */
function drawDiagram(canvas, state){
  const {ctx, w, h} = setupHiDPICanvas(canvas);
  clearPanel(ctx,w,h);

  const pad = 14;
  const leftW = (w - pad*3)/2;
  const rightW = leftW;
  const boxH = h - pad*2;

  const L = {x:pad, y:pad, w:leftW, h:boxH};
  const R = {x:pad*2 + leftW, y:pad, w:rightW, h:boxH};

  // Boxes
  ctx.save();
  ctx.fillStyle = "rgba(16,26,51,0.55)";
  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.lineWidth = 1;
  roundRect(ctx, L.x, L.y, L.w, L.h, 18); ctx.fill(); ctx.stroke();
  roundRect(ctx, R.x, R.y, R.w, R.h, 18); ctx.fill(); ctx.stroke();
  ctx.restore();

  // Titles
  ctx.save();
  ctx.fillStyle = "rgba(234,240,255,0.95)";
  ctx.font = "700 14px ui-sans-serif, system-ui";
  ctx.fillText("(a) Electron accelerated by voltage V", L.x+14, L.y+24);
  ctx.fillText("(b) Sum-frequency generation (SFG)", R.x+14, R.y+24);
  ctx.restore();

  // Left diagram: plates + electron
  const cx = L.x + L.w*0.52;
  const top = L.y + 70;
  const bottom = L.y + L.h - 70;

  // plates
  ctx.save();
  ctx.fillStyle = "rgba(125,211,252,0.18)";
  ctx.strokeStyle = "rgba(125,211,252,0.35)";
  ctx.lineWidth = 2;
  // left plate
  roundRect(ctx, L.x+40, top, 28, bottom-top, 10); ctx.fill(); ctx.stroke();
  // right plate
  roundRect(ctx, L.x+L.w-68, top, 28, bottom-top, 10); ctx.fill(); ctx.stroke();
  ctx.restore();

  // field arrows
  ctx.save();
  ctx.strokeStyle = "rgba(234,240,255,0.35)";
  ctx.lineWidth = 1.5;
  for(let i=0;i<6;i++){
    const yy = top + (i+0.8)*(bottom-top)/7;
    arrow(ctx, L.x+78, yy, L.x+L.w-78, yy, 8);
  }
  ctx.restore();

  // electron
  const ex0 = L.x + 95;
  const ey0 = (top+bottom)/2;
  const ex1 = L.x + L.w - 95;
  ctx.save();
  ctx.fillStyle = "rgba(167,139,250,0.95)";
  ctx.strokeStyle = "rgba(167,139,250,0.35)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(ex0, ey0, 10, 0, Math.PI*2);
  ctx.fill();
  ctx.stroke();
  ctx.fillStyle = "rgba(10,16,32,0.9)";
  ctx.font = "700 12px ui-sans-serif, system-ui";
  ctx.fillText("e⁻", ex0-8, ey0+4);
  ctx.restore();

  // motion arrow
  ctx.save();
  ctx.strokeStyle = "rgba(52,211,153,0.65)";
  ctx.lineWidth = 2.2;
  arrow(ctx, ex0+16, ey0, ex1-16, ey0, 10);
  ctx.fillStyle = "rgba(234,240,255,0.92)";
  ctx.font = "600 12px ui-sans-serif, system-ui";
  ctx.fillText("accelerates", (ex0+ex1)/2 - 34, ey0 - 14);
  ctx.restore();

  // voltage label
  ctx.save();
  ctx.strokeStyle = "rgba(251,191,36,0.65)";
  ctx.lineWidth = 2;
  const vx1 = L.x+54, vx2 = L.x+L.w-54, vy = bottom + 22;
  ctx.beginPath();
  ctx.moveTo(vx1, vy); ctx.lineTo(vx2, vy);
  ctx.stroke();
  // end ticks
  ctx.beginPath();
  ctx.moveTo(vx1, vy-8); ctx.lineTo(vx1, vy+8);
  ctx.moveTo(vx2, vy-8); ctx.lineTo(vx2, vy+8);
  ctx.stroke();
  ctx.fillStyle = "rgba(234,240,255,0.92)";
  ctx.font = "700 12px ui-sans-serif, system-ui";
  ctx.fillText("V", (vx1+vx2)/2 - 4, vy - 10);
  ctx.fillStyle = "rgba(185,198,238,0.95)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas";
  ctx.fillText(`K = eV`, (vx1+vx2)/2 - 28, vy + 22);
  ctx.restore();

  // Right diagram: two inputs -> crystal -> output
  const ryTop = R.y + 90;
  const ryMid = R.y + R.h/2;
  const ryBot = R.y + R.h - 120;

  // lasers blocks
  ctx.save();
  ctx.fillStyle = "rgba(125,211,252,0.14)";
  ctx.strokeStyle = "rgba(125,211,252,0.30)";
  ctx.lineWidth = 2;
  roundRect(ctx, R.x+34, ryTop-26, 130, 46, 14); ctx.fill(); ctx.stroke();
  roundRect(ctx, R.x+34, ryBot-26, 130, 46, 14); ctx.fill(); ctx.stroke();
  ctx.fillStyle = "rgba(234,240,255,0.94)";
  ctx.font = "700 12px ui-sans-serif, system-ui";
  ctx.fillText("Laser 1", R.x+64, ryTop+2);
  ctx.fillText("Laser 2", R.x+64, ryBot+2);
  ctx.restore();

  // wave arrows to crystal
  const crystX = R.x + R.w*0.56;
  const crystY = ryMid - 70;
  const crystW = 120;
  const crystH = 140;

  ctx.save();
  ctx.strokeStyle = "rgba(167,139,250,0.65)";
  ctx.lineWidth = 2.4;
  arrow(ctx, R.x+170, ryTop, crystX, ryTop, 10);
  ctx.strokeStyle = "rgba(251,191,36,0.65)";
  arrow(ctx, R.x+170, ryBot, crystX, ryBot, 10);
  ctx.restore();

  // labels λ1, λ2
  ctx.save();
  ctx.fillStyle = "rgba(234,240,255,0.92)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas";
  ctx.fillText(`λ₁ = ${state.ls.toFixed(3)} µm`, R.x+182, ryTop-10);
  ctx.fillText(`λ₂ = ${state.l2.toFixed(3)} µm`, R.x+182, ryBot-10);
  ctx.restore();

  // crystal
  ctx.save();
  ctx.fillStyle = "rgba(52,211,153,0.14)";
  ctx.strokeStyle = "rgba(52,211,153,0.34)";
  ctx.lineWidth = 2;
  roundRect(ctx, crystX, crystY, crystW, crystH, 16);
  ctx.fill(); ctx.stroke();
  ctx.fillStyle = "rgba(234,240,255,0.95)";
  ctx.font = "700 12px ui-sans-serif, system-ui";
  ctx.fillText("Nonlinear", crystX+20, crystY+60);
  ctx.fillText("crystal", crystX+34, crystY+80);
  ctx.restore();

  // output arrow
  const outX0 = crystX + crystW;
  const outY = ryMid;
  const outX1 = R.x + R.w - 40;

  ctx.save();
  ctx.strokeStyle = "rgba(125,211,252,0.75)";
  ctx.lineWidth = 3;
  arrow(ctx, outX0, outY, outX1, outY, 12);
  ctx.fillStyle = "rgba(234,240,255,0.92)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas";
  const l3 = state.l3;
  ctx.fillText(`λ₃ = ${l3.toFixed(3)} µm`, outX0+20, outY-12);
  ctx.fillStyle = "rgba(185,198,238,0.92)";
  ctx.font = "12px ui-sans-serif, system-ui";
  ctx.fillText("ν₃ = ν₁ + ν₂", outX0+20, outY+20);
  ctx.restore();

  // footer note
  ctx.save();
  ctx.fillStyle = "rgba(185,198,238,0.82)";
  ctx.font = "12px ui-sans-serif, system-ui";
  ctx.fillText("Diagram is conceptual (not to scale).", R.x+14, R.y+R.h-16);
  ctx.restore();
}

function arrow(ctx, x0,y0,x1,y1, head=10){
  ctx.beginPath();
  ctx.moveTo(x0,y0);
  ctx.lineTo(x1,y1);
  ctx.stroke();

  const ang = Math.atan2(y1-y0, x1-x0);
  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.lineTo(x1 - head*Math.cos(ang - Math.PI/7), y1 - head*Math.sin(ang - Math.PI/7));
  ctx.lineTo(x1 - head*Math.cos(ang + Math.PI/7), y1 - head*Math.sin(ang + Math.PI/7));
  ctx.closePath();
  ctx.fill();
}

/* =========================
   Plot 1: E vs λ with markers
========================= */
function drawEnergyPlot(canvas, state){
  const {ctx, w, h} = setupHiDPICanvas(canvas);
  clearPanel(ctx,w,h);

  const box = {x:14, y:14, w:w-28, h:h-28};

  // Choose axis ranges
  const xMin = 0.4, xMax = 15.0; // µm
  const yMin = 0.0, yMax = 3.4;  // eV (covers near IR nicely)
  const frame = drawAxes(ctx, box, xMin,xMax,yMin,yMax,
    "Wavelength λ (µm)",
    "Photon energy E (eV)",
    "Photon energy vs wavelength: E = hc/λ"
  );

  // Draw curve
  ctx.save();
  ctx.strokeStyle = "rgba(125,211,252,0.90)";
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  let started = false;
  for(let i=0;i<=600;i++){
    const lam = xMin + (xMax-xMin)*i/600;
    const E = photonEnergy_eV(lam);
    const X = toX(frame, lam);
    const Y = toY(frame, Math.min(E, yMax));
    if(!started){ ctx.moveTo(X,Y); started=true; }
    else ctx.lineTo(X,Y);
  }
  ctx.stroke();
  ctx.restore();

  // Markers
  const markers = [
    {lam: state.ls, label:"λs (used as λ0 / λ1)", color:"rgba(167,139,250,0.95)"},
    {lam: state.l2, label:"λ2", color:"rgba(251,191,36,0.95)"},
    {lam: state.l3, label:"λ3 (SFG output)", color:"rgba(52,211,153,0.95)"}
  ];

  ctx.save();
  ctx.font = "12px ui-sans-serif, system-ui";
  markers.forEach((m,idx)=>{
    const E = photonEnergy_eV(m.lam);
    const X = toX(frame, m.lam);
    const Y = toY(frame, Math.min(E, yMax));
    ctx.fillStyle = m.color;
    ctx.strokeStyle = "rgba(0,0,0,0.35)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(X, Y, 5.2, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    // label offset
    const ox = 10;
    const oy = (idx===0? -14 : (idx===1? 16 : -18));
    ctx.fillStyle = "rgba(234,240,255,0.92)";
    ctx.fillText(`${m.label}`, X+ox, Y+oy);
  });
  ctx.restore();

  drawLegend(ctx, [
    {label:"Curve E = hc/λ", color:"rgba(125,211,252,0.90)", marker:false},
    {label:"Markers at λs, λ2, λ3", color:"rgba(234,240,255,0.85)", marker:true}
  ], box.x + box.w - 260, box.y + 34);
}

/* =========================
   Plot 2: Sweep λ3 vs λ2
========================= */
function drawSweepPlot(canvas, state){
  const {ctx, w, h} = setupHiDPICanvas(canvas);
  clearPanel(ctx,w,h);

  const box = {x:14, y:14, w:w-28, h:h-28};

  const xMin = 2.0, xMax = 15.0; // λ2 sweep
  const yMin = 0.3, yMax = 2.1;  // λ3 range across sweep
  const frame = drawAxes(ctx, box, xMin,xMax,yMin,yMax,
    "Long input wavelength λ2 (µm)",
    "SFG output wavelength λ3 (µm)",
    "Parameter sweep: λ3(λ2) with 1/λ3 = 1/λs + 1/λ2"
  );

  // Curve
  ctx.save();
  ctx.strokeStyle = "rgba(52,211,153,0.90)";
  ctx.lineWidth = 2.6;
  ctx.beginPath();
  let started=false;
  for(let i=0;i<=500;i++){
    const l2 = xMin + (xMax-xMin)*i/500;
    const l3 = sfg_lambda3_um(state.ls, l2);
    const X = toX(frame, l2);
    const Y = toY(frame, l3);
    if(!started){ ctx.moveTo(X,Y); started=true; }
    else ctx.lineTo(X,Y);
  }
  ctx.stroke();
  ctx.restore();

  // Current point
  const Xc = toX(frame, state.l2);
  const Yc = toY(frame, state.l3);

  ctx.save();
  ctx.fillStyle = "rgba(167,139,250,0.95)";
  ctx.strokeStyle = "rgba(0,0,0,0.35)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(Xc,Yc,6,0,Math.PI*2);
  ctx.fill();
  ctx.stroke();

  // dashed guides
  ctx.setLineDash([6,6]);
  ctx.strokeStyle = "rgba(185,198,238,0.35)";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(Xc, frame.py);
  ctx.lineTo(Xc, frame.py+frame.ph);
  ctx.moveTo(frame.px, Yc);
  ctx.lineTo(frame.px+frame.pw, Yc);
  ctx.stroke();
  ctx.setLineDash([]);

  // label
  ctx.fillStyle = "rgba(234,240,255,0.92)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas";
  const txt = `λ2=${state.l2.toFixed(3)} µm,  λ3=${state.l3.toFixed(3)} µm`;
  ctx.fillText(txt, Math.min(frame.px+frame.pw-ctx.measureText(txt).width-6, Xc+10), Math.max(frame.py+18, Yc-12));
  ctx.restore();

  drawLegend(ctx, [
    {label:"Sweep curve λ3(λ2)", color:"rgba(52,211,153,0.90)", marker:false},
    {label:"Current selection", color:"rgba(167,139,250,0.90)", marker:true}
  ], box.x + box.w - 240, box.y + 34);
}

/* =========================
   State + UI wiring
========================= */
const ui = {
  ls: document.getElementById('ls'),
  l2: document.getElementById('l2'),
  lsVal: document.getElementById('lsVal'),
  l2Val: document.getElementById('l2Val'),
  live: document.getElementById('liveReadout'),
  presetA: document.getElementById('presetA'),
  presetB: document.getElementById('presetB')
};

const canv = {
  diag: document.getElementById('diag'),
  p1: document.getElementById('plot1'),
  p2: document.getElementById('plot2')
};

function getState(){
  const ls = parseFloat(ui.ls.value);
  const l2 = parseFloat(ui.l2.value);
  const l3 = sfg_lambda3_um(ls, l2);
  const E_ls = photonEnergy_eV(ls);
  const V_ls = E_ls; // in volts, since E in eV for one electron => same numeric value
  const E_l2 = photonEnergy_eV(l2);
  const E_l3 = photonEnergy_eV(l3);
  return {ls, l2, l3, E_ls, V_ls, E_l2, E_l3};
}

function updateReadout(state){
  ui.lsVal.textContent = state.ls.toFixed(3);
  ui.l2Val.textContent = state.l2.toFixed(3);

  ui.live.textContent =
`Using λs = ${state.ls.toFixed(3)} µm
Photon energy at λs: E(λs) = ${state.E_ls.toFixed(3)} eV
Electron voltage to match that energy: V = ${state.V_ls.toFixed(3)} V

SFG with λ1=λs and λ2=${state.l2.toFixed(3)} µm
Output λ3 = ${state.l3.toFixed(3)} µm
E(λ2) = ${state.E_l2.toFixed(3)} eV,   E(λ3) = ${state.E_l3.toFixed(3)} eV`;
}

function render(){
  const state = getState();
  updateReadout(state);
  drawDiagram(canv.diag, state);
  drawEnergyPlot(canv.p1, state);
  drawSweepPlot(canv.p2, state);
}

ui.ls.addEventListener('input', render);
ui.l2.addEventListener('input', render);

ui.presetA.addEventListener('click', ()=>{
  ui.ls.value = "0.870";
  render();
});
ui.presetB.addEventListener('click', ()=>{
  ui.ls.value = "1.060";
  ui.l2.value = "10.600";
  render();
});

// Re-render on resize (responsive)
let resizeTimer = null;
window.addEventListener('resize', ()=>{
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(render, 80);
});

// Initial render
render();
</script>
</body>
</html>
