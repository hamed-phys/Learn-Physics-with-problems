<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>The Donut Beam from Incoherent HG01 + HG10</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#111826;
      --panel2:#0f1520;
      --text:#e7eef8;
      --muted:#a9b7cc;
      --faint:#6f819b;
      --accent:#6ee7ff;
      --accent2:#a78bfa;
      --ok:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --border:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 800px at 20% 0%, rgba(110,231,255,.10), transparent 60%),
                  radial-gradient(900px 700px at 95% 10%, rgba(167,139,250,.10), transparent 55%),
                  linear-gradient(180deg, #070a10 0%, #0b0f14 60%, #070a10 100%);
      color:var(--text);
      line-height:1.55;
    }

    header{
      padding:28px 18px 18px;
      max-width:1200px;
      margin:0 auto;
    }
    .hero{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius: calc(var(--radius) + 6px);
      box-shadow: var(--shadow);
      padding:22px 20px;
      position:relative;
      overflow:hidden;
    }
    .hero::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(600px 250px at 10% 0%, rgba(110,231,255,.18), transparent 55%),
                  radial-gradient(600px 250px at 90% 0%, rgba(167,139,250,.18), transparent 55%);
      filter: blur(10px);
      opacity:.75;
      pointer-events:none;
    }
    .hero > *{ position:relative; }
    h1{
      margin:0 0 10px;
      font-weight:750;
      letter-spacing:.2px;
      font-size: clamp(1.35rem, 2.4vw, 2.15rem);
    }
    .subtitle{
      color:var(--muted);
      max-width: 72ch;
      margin:0 0 14px;
      font-size: 1.02rem;
    }
    .quick{
      display:grid;
      gap:10px;
      grid-template-columns: 1.2fr .8fr;
      align-items:stretch;
    }
    @media (max-width: 900px){
      .quick{ grid-template-columns:1fr; }
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius: var(--radius);
      padding:14px 14px;
      box-shadow: 0 8px 22px rgba(0,0,0,.25);
    }
    .card h3{
      margin:0 0 8px;
      font-size: 1.0rem;
      letter-spacing:.2px;
    }
    ul{
      margin: 8px 0 0 18px;
      color:var(--muted);
    }
    li{ margin: 6px 0; }

    main{
      max-width:1200px;
      margin:0 auto;
      padding: 0 18px 34px;
      display:grid;
      grid-template-columns: 280px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
    }

    nav.toc{
      position: sticky;
      top: 12px;
      align-self:start;
      background: linear-gradient(180deg, rgba(17,24,38,.85), rgba(15,21,32,.75));
      border:1px solid var(--border);
      border-radius: var(--radius);
      padding: 12px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    @media (max-width: 980px){
      nav.toc{ position:relative; top:auto; }
    }

    .toc .toc-title{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-bottom:6px;
    }
    .toc .toc-title strong{
      font-size:.95rem;
      letter-spacing:.2px;
    }
    .pill{
      font-size:.72rem;
      padding:3px 8px;
      border-radius: 999px;
      border:1px solid var(--border);
      color:var(--muted);
      background: rgba(255,255,255,.03);
    }

    .toc a{
      display:block;
      padding: 9px 10px;
      border-radius: 12px;
      color: var(--muted);
      text-decoration:none;
      border:1px solid transparent;
      transition: transform .14s ease, background .14s ease, border-color .14s ease;
      font-size: .92rem;
    }
    .toc a:hover{
      background: rgba(110,231,255,.08);
      border-color: rgba(110,231,255,.22);
      transform: translateY(-1px);
      color: var(--text);
    }

    article{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius: calc(var(--radius) + 6px);
      box-shadow: var(--shadow);
      padding: 18px 18px 20px;
    }

    section{
      margin-top: 18px;
      padding-top: 8px;
      border-top: 1px dashed rgba(255,255,255,.10);
    }
    section:first-of-type{
      margin-top: 0;
      padding-top: 0;
      border-top: none;
    }

    h2{
      margin: 2px 0 10px;
      font-size: 1.25rem;
      letter-spacing:.2px;
    }
    .muted{ color: var(--muted); }
    .note{
      margin-top: 10px;
      border-left: 3px solid rgba(110,231,255,.55);
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(110,231,255,.06);
      color: var(--muted);
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      margin-top: 10px;
    }
    @media (max-width: 900px){ .grid2{ grid-template-columns: 1fr; } }

    .eqbox{
      background: rgba(0,0,0,.22);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px 12px;
      position:relative;
      overflow:hidden;
    }
    .eq{
      margin:0;
      font-family: var(--mono);
      font-size: .95rem;
      color: #dbeafe;
      white-space: pre-wrap;
      word-break: break-word;
      line-height:1.45;
    }
    .copybtn{
      position:absolute;
      top:10px;
      right:10px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      color: var(--text);
      padding: 7px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-size: .82rem;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
    }
    .copybtn:hover{ transform: translateY(-1px); background: rgba(110,231,255,.08); border-color: rgba(110,231,255,.25); }
    .copybtn:active{ transform: translateY(0px); }

    .result{
      border:1px solid rgba(52,211,153,.35);
      background: rgba(52,211,153,.08);
      border-radius: 16px;
      padding: 14px 14px;
      margin-top: 12px;
    }
    .result h3{
      margin:0 0 8px;
      font-size: 1.02rem;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .badge{
      font-size:.75rem;
      padding:4px 10px;
      border-radius: 999px;
      border:1px solid rgba(52,211,153,.35);
      color: #bbf7d0;
      background: rgba(0,0,0,.18);
      white-space:nowrap;
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top: 12px;
    }
    @media (max-width: 900px){ .controls{ grid-template-columns: 1fr; } }

    .control{
      background: rgba(0,0,0,.18);
      border:1px solid var(--border);
      border-radius: 14px;
      padding: 12px 12px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      color: var(--muted);
      font-size: .9rem;
      margin-bottom: 8px;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .tiny{
      color: var(--faint);
      font-size:.85rem;
      margin-top:6px;
    }

    figure{
      margin: 0;
    }
    .canwrap{
      background: rgba(0,0,0,.20);
      border:1px solid var(--border);
      border-radius: 16px;
      padding: 12px 12px 10px;
      margin-top: 10px;
    }
    .canwrap header{
      padding:0;
      margin:0 0 10px;
      max-width:none;
    }
    .canhead{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
    }
    .canhead strong{
      font-size: .98rem;
      letter-spacing:.2px;
    }
    .canhead .muted{
      font-size: .88rem;
      max-width: 70ch;
    }
    canvas{
      width:100%;
      height: 330px;
      display:block;
      border-radius: 14px;
      background: rgba(7,10,16,.55);
    }
    @media (max-width: 900px){
      canvas{ height: 300px; }
    }
    .footer{
      max-width:1200px;
      margin: 18px auto 0;
      padding: 0 18px 26px;
      color: var(--faint);
      font-size: .9rem;
    }

    @media print{
      body{ background:#fff; color:#000; }
      header, main, article, .card, .eqbox, .control, .canwrap, nav.toc { box-shadow:none !important; }
      nav.toc, .copybtn { display:none !important; }
      article, .card, .eqbox, .control, .canwrap, .hero { border:1px solid #bbb !important; background:#fff !important; }
      canvas{ border:1px solid #bbb; background:#fff !important; }
      .muted, .tiny, .footer{ color:#333 !important; }
    }
  </style>
</head>

<body>
<header>
  <div class="hero">
    <h1>3-3-3 The Donut Beam: Incoherent Superposition of HG<sub>01</sub> and HG<sub>10</sub></h1>
    <p class="subtitle">
      Two first-order Hermite–Gaussian modes with equal power but random, independent phases add <em>in intensity</em>.
      The result is a rotationally symmetric “donut” (toroidal) intensity profile.
    </p>

    <div class="quick">
      <div class="card">
        <h3>Quick Summary</h3>
        <ul>
          <li>HG<sub>10</sub> intensity ∝ <span style="font-family:var(--mono)">x² e^{-2r²/w₀²}</span>, HG<sub>01</sub> intensity ∝ <span style="font-family:var(--mono)">y² e^{-2r²/w₀²}</span>.</li>
          <li>Incoherent sum gives <strong>circular symmetry</strong>:
            <span style="font-family:var(--mono)">I(r) ∝ (x²+y²)e^{-2r²/w₀²} = r² e^{-2r²/w₀²}</span>.</li>
          <li>Peak intensity occurs on a ring at <strong>r<sub>peak</sub> = w₀/√2</strong>.</li>
          <li>At the waist, the radii where <span style="font-family:var(--mono)">I = I_peak/e²</span> satisfy <span style="font-family:var(--mono)">ln t − t = −3</span> with <span style="font-family:var(--mono)">t = 2r²/w₀²</span>.</li>
          <li>For <strong>w₀ = 1 mm</strong>: <strong>r<sub>peak</sub> ≈ 0.707 mm</strong>, and <strong>r ≈ 0.162 mm</strong> (inner) and <strong>r ≈ 1.501 mm</strong> (outer) for <span style="font-family:var(--mono)">1/e²</span> of the peak.</li>
        </ul>
      </div>

      <div class="card">
        <h3>Interactive Explorer</h3>
        <p class="muted" style="margin:0 0 10px;">
          Use the sliders to change the beam waist <span style="font-family:var(--mono)">w₀</span> (mm) and the relative modal power ratio
          <span style="font-family:var(--mono)">α = P₁₀ / P₀₁</span>. When α = 1 the donut becomes perfectly circular.
        </p>
        <div class="controls">
          <div class="control">
            <label>
              <span>Beam waist at the waist plane, <span style="font-family:var(--mono)">w₀</span> (mm)</span>
              <span class="pill" id="w0Read">1.00</span>
            </label>
            <input id="w0" type="range" min="0.4" max="2.5" value="1.0" step="0.01"/>
            <div class="tiny">This changes the ring size proportionally: <span style="font-family:var(--mono)">r_peak = w₀/√2</span>.</div>
          </div>
          <div class="control">
            <label>
              <span>Power ratio, <span style="font-family:var(--mono)">α = P₁₀/P₀₁</span></span>
              <span class="pill" id="aRead">1.00</span>
            </label>
            <input id="alpha" type="range" min="0.2" max="5" value="1.0" step="0.01"/>
            <div class="tiny">α ≠ 1 breaks circular symmetry (elliptical intensity); α = 1 recovers the donut.</div>
          </div>
        </div>
      </div>
    </div>

  </div>
</header>

<main>
  <nav class="toc" aria-label="Table of contents">
    <div class="toc-title">
      <strong>Table of Contents</strong>
      <span class="pill">Sticky</span>
    </div>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#viz">Interactive Visualizations</a>
    <a href="#checks">Sanity Checks</a>
  </nav>

  <article>
    <section id="part1">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3 style="margin:10px 0 6px;">Restatement in my own words</h3>
      <p class="muted">
        We combine two first-order Hermite–Gaussian beams at the waist plane: HG<sub>01</sub> and HG<sub>10</sub>.
        They have equal intensities (equal power) but their phases are independent and random, so there is no stable interference.
        We must (i) show that the total intensity becomes a donut-shaped, rotationally symmetric function of radius,
        and (ii) for a waist radius <span style="font-family:var(--mono)">w₀ = 1 mm</span>, find the radius of maximum intensity and the two radii
        where the intensity is <span style="font-family:var(--mono)">1/e²</span> times that peak value.
      </p>

      <div class="grid2">
        <div class="card">
          <h3>Given</h3>
          <ul>
            <li>Two HG modes at the same waist plane: HG<sub>01</sub> and HG<sub>10</sub>.</li>
            <li>Equal power (equal modal intensities) in the two beams.</li>
            <li>Independent random phases → intensities add (no interference term in the time average).</li>
            <li>Beam waist radius at that plane: <span style="font-family:var(--mono)">w₀ = 1 mm</span> (for the numerical part).</li>
          </ul>
        </div>
        <div class="card">
          <h3>Unknowns / Targets</h3>
          <ul>
            <li>Show <strong>circular symmetry</strong> of the summed intensity.</li>
            <li>Show the intensity has a <strong>donut (ring)</strong> maximum away from the axis.</li>
            <li>Find <span style="font-family:var(--mono)">r_peak</span> and the two solutions <span style="font-family:var(--mono)">r</span> where
              <span style="font-family:var(--mono)">I(r) = I_peak/e²</span> at the waist.</li>
          </ul>
        </div>
      </div>

      <h3 style="margin:14px 0 6px;">Relevant principles (and why)</h3>
      <ul>
        <li><strong>Hermite–Gaussian mode structure:</strong> HG<sub>mn</sub> fields at the waist are polynomials (Hermite) times a Gaussian envelope, so we can write explicit dependence on x and y.</li>
        <li><strong>Incoherent superposition:</strong> random relative phase makes the time-averaged cross term vanish, so total intensity is the sum of individual intensities: <span style="font-family:var(--mono)">I_total = I_10 + I_01</span>.</li>
        <li><strong>Radial symmetry test:</strong> if the sum depends only on <span style="font-family:var(--mono)">r = √(x²+y²)</span>, the beam is circularly symmetric. HG<sub>10</sub> and HG<sub>01</sub> are orthogonal but “complementary” in x and y, so their equal-weight sum is a prime candidate for symmetry.</li>
        <li><strong>Optimization and level sets:</strong> ring radius and <span style="font-family:var(--mono)">1/e²</span> radii come from maximizing a radial function and solving an equation for its level sets.</li>
      </ul>

      <h3 style="margin:14px 0 6px;">Possible approaches (compare)</h3>
      <ol class="muted">
        <li><strong>Direct HG formulas at the waist (best):</strong> write HG<sub>10</sub> and HG<sub>01</sub> fields explicitly, square to get intensities, add them, and simplify to a function of r only. Then do calculus for maxima and level sets.</li>
        <li><strong>Use symmetry arguments + dimensional reasoning:</strong> argue the only circularly symmetric combination of x- and y- odd first-order modes with equal weights must yield <span style="font-family:var(--mono)">r²</span> times a Gaussian. Still needs at least one explicit calculation to confirm constants and compute radii.</li>
        <li><strong>Laguerre–Gaussian reinterpretation:</strong> note that a coherent superposition with ±i phase gives LG<sub>0,±1</sub> (a donut). But here we are incoherent, so we should not rely on field interference; we must show intensity symmetry directly.</li>
      </ol>

      <div class="note">
        <strong>Chosen approach:</strong> Use the explicit HG waist-plane expressions and add intensities. This is the most transparent and directly matches the “no interference” condition.
      </div>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

      <ol class="muted">
        <li><strong>Write HG fields at the waist:</strong> Use the standard HG<sub>mn</sub> form with Hermite polynomials and Gaussian envelope.</li>
        <li><strong>Specialize to (m,n)=(1,0) and (0,1):</strong> Use <span style="font-family:var(--mono)">H₁(u)=2u</span> and <span style="font-family:var(--mono)">H₀(u)=1</span> to get the x and y dependence.</li>
        <li><strong>Compute intensities:</strong> Square the magnitudes (ignore global phase factors).</li>
        <li><strong>Apply incoherence:</strong> Set <span style="font-family:var(--mono)">I_total = I_10 + I_01</span> (no cross term).</li>
        <li><strong>Show circular symmetry:</strong> Simplify the sum into a function of <span style="font-family:var(--mono)">r²=x²+y²</span>.</li>
        <li><strong>Find the peak ring:</strong> Maximize <span style="font-family:var(--mono)">f(r)=r² e^{-2r²/w₀²}</span>.</li>
        <li><strong>Find 1/e² radii:</strong> Solve <span style="font-family:var(--mono)">f(r) = f(r_peak)/e²</span>. Express in Lambert W (symbolic) and compute numbers for <span style="font-family:var(--mono)">w₀=1 mm</span>.</li>
      </ol>

      <h3 style="margin:12px 0 6px;">Common mistakes & quick tips</h3>
      <ul class="muted">
        <li><strong>Mixing coherent vs incoherent:</strong> If phases are random, you add intensities, not fields. No interference fringes survive time averaging.</li>
        <li><strong>Forgetting the Gaussian is squared:</strong> Field has <span style="font-family:var(--mono)">e^{-r²/w₀²}</span>; intensity has <span style="font-family:var(--mono)">e^{-2r²/w₀²}</span>.</li>
        <li><strong>Misinterpreting “1/e² times the peak”:</strong> It refers to <em>peak intensity of this donut</em>, not the fundamental Gaussian’s on-axis value.</li>
        <li><strong>Ring has two 1/e² radii:</strong> Because the donut rises from 0 at r=0, peaks, then decays—so a given sub-peak level occurs on both sides of the maximum (inner & outer circles).</li>
      </ul>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution</h2>

      <h3 style="margin:10px 0 6px;">Physical intuition</h3>
      <p class="muted">
        HG<sub>10</sub> has a node line along <span style="font-family:var(--mono)">x=0</span> and two lobes left/right, while HG<sub>01</sub> has a node line along <span style="font-family:var(--mono)">y=0</span> and two lobes up/down.
        If we add them <em>incoherently</em> with equal weight, we “fill in” the missing directions: wherever HG<sub>10</sub> is dark, HG<sub>01</sub> is generally bright, and vice versa.
        The total intensity is zero only at the center (both modes vanish at r=0), grows with distance (because first-order modes scale like x or y),
        and eventually decays due to the Gaussian envelope—so it must peak on a ring: a donut beam.
      </p>

      <h3 style="margin:14px 0 6px;">Step 1: Write the waist-plane HG fields</h3>
      <p class="muted">
        At the beam waist (<span style="font-family:var(--mono)">z=0</span>), ignoring an overall constant and global phase, a Hermite–Gaussian mode can be written as
      </p>

      <div class="eqbox" id="eq1box">
        <button class="copybtn" data-copy-target="eq1">Copy</button>
        <pre class="eq" id="eq1">HG_mn(x,y) ∝ H_m(√2 x / w0) · H_n(√2 y / w0) · exp(−(x²+y²)/w0²)</pre>
      </div>

      <p class="muted">
        Here <span style="font-family:var(--mono)">w₀</span> is the waist radius, and <span style="font-family:var(--mono)">H_m</span> are Hermite polynomials.
        We only need the first two:
        <span style="font-family:var(--mono)">H₀(u)=1</span>, <span style="font-family:var(--mono)">H₁(u)=2u</span>.
      </p>

      <h3 style="margin:14px 0 6px;">Step 2: Specialize to HG<sub>10</sub> and HG<sub>01</sub></h3>
      <p class="muted">
        For HG<sub>10</sub> (m=1,n=0):
      </p>
      <div class="eqbox">
        <button class="copybtn" data-copy-target="eq2">Copy</button>
        <pre class="eq" id="eq2">E_10(x,y) ∝ H_1(√2 x / w0) · H_0(√2 y / w0) · exp(−r²/w0²)
          = (2·√2 x / w0) · exp(−r²/w0²)</pre>
      </div>

      <p class="muted">
        For HG<sub>01</sub> (m=0,n=1):
      </p>
      <div class="eqbox">
        <button class="copybtn" data-copy-target="eq3">Copy</button>
        <pre class="eq" id="eq3">E_01(x,y) ∝ H_0(√2 x / w0) · H_1(√2 y / w0) · exp(−r²/w0²)
          = (2·√2 y / w0) · exp(−r²/w0²)</pre>
      </div>

      <p class="muted">
        where <span style="font-family:var(--mono)">r² = x² + y²</span>.
      </p>

      <h3 style="margin:14px 0 6px;">Step 3: Compute each intensity</h3>
      <p class="muted">
        Intensity is proportional to <span style="font-family:var(--mono)">|E|²</span>. Therefore (absorbing constants into a scale factor),
      </p>

      <div class="eqbox">
        <button class="copybtn" data-copy-target="eq4">Copy</button>
        <pre class="eq" id="eq4">I_10(x,y) ∝ (x² / w0²) · exp(−2r²/w0²)
I_01(x,y) ∝ (y² / w0²) · exp(−2r²/w0²)</pre>
      </div>

      <h3 style="margin:14px 0 6px;">Step 4: Use incoherence to add intensities</h3>
      <p class="muted">
        Because the two beams have independent random phases, the time-averaged interference term vanishes:
        <span style="font-family:var(--mono)">⟨E_10 E_01*</span> + c.c.<span style="font-family:var(--mono)">⟩ = 0</span>.
        Hence,
      </p>

      <div class="eqbox">
        <button class="copybtn" data-copy-target="eq5">Copy</button>
        <pre class="eq" id="eq5">I_total(x,y) = I_10(x,y) + I_01(x,y)</pre>
      </div>

      <p class="muted">
        With equal modal powers (equal weights), their proportionality constants match, so we can combine them directly:
      </p>

      <div class="eqbox">
        <button class="copybtn" data-copy-target="eq6">Copy</button>
        <pre class="eq" id="eq6">I_total(x,y) ∝ (x² + y²)/w0² · exp(−2(x²+y²)/w0²)
            = (r² / w0²) · exp(−2r²/w0²)</pre>
      </div>

      <div class="note">
        <strong>This proves the donut:</strong> the intensity depends only on <span style="font-family:var(--mono)">r</span>, so it is circularly symmetric.
        It also vanishes at <span style="font-family:var(--mono)">r=0</span> (dark center) and decays for large r, implying a ring-shaped maximum.
      </div>

      <h3 style="margin:14px 0 6px;">Step 5: Find the radius of peak intensity</h3>
      <p class="muted">
        Define the radial profile (ignoring constant prefactors) as
        <span style="font-family:var(--mono)">f(r) = r² exp(−2r²/w0²)</span>.
        Maximize by setting <span style="font-family:var(--mono)">df/dr = 0</span>.
      </p>

      <div class="eqbox">
        <button class="copybtn" data-copy-target="eq7">Copy</button>
        <pre class="eq" id="eq7">f(r) = r² e^(−2r²/w0²)
df/dr = 2r e^(−2r²/w0²) + r² e^(−2r²/w0²)·(−4r/w0²)
      = 2r e^(−2r²/w0²) · (1 − 2r²/w0²)</pre>
      </div>

      <p class="muted">
        The factors give critical points at <span style="font-family:var(--mono)">r=0</span> and when
        <span style="font-family:var(--mono)">1 − 2r²/w0² = 0</span>.
        The nonzero maximum occurs at
      </p>

      <div class="eqbox">
        <button class="copybtn" data-copy-target="eq8">Copy</button>
        <pre class="eq" id="eq8">r_peak = w0 / √2</pre>
      </div>

      <h3 style="margin:14px 0 6px;">Step 6: Find the two radii where I = I<sub>peak</sub>/e²</h3>
      <p class="muted">
        Since the profile rises then falls, the level <span style="font-family:var(--mono)">I = I_peak/e²</span> occurs at two radii:
        an inner circle (<span style="font-family:var(--mono)">r &lt; r_peak</span>) and an outer circle (<span style="font-family:var(--mono)">r &gt; r_peak</span>).
      </p>

      <p class="muted">
        First compute the peak value in terms of the same radial function:
      </p>
      <div class="eqbox">
        <button class="copybtn" data-copy-target="eq9">Copy</button>
        <pre class="eq" id="eq9">f(r_peak) = (w0²/2) · exp(−1)   (since r_peak² = w0²/2)</pre>
      </div>

      <p class="muted">
        Now set the ratio:
      </p>
      <div class="eqbox">
        <button class="copybtn" data-copy-target="eq10">Copy</button>
        <pre class="eq" id="eq10">f(r) / f(r_peak) = e^(−2)</pre>
      </div>

      <p class="muted">
        Substitute <span style="font-family:var(--mono)">f(r)=r² e^(−2r²/w0²)</span> and simplify:
      </p>

      <div class="eqbox">
        <button class="copybtn" data-copy-target="eq11">Copy</button>
        <pre class="eq" id="eq11">[r² e^(−2r²/w0²)] / [(w0²/2)e^(−1)] = e^(−2)
(2r²/w0²) · exp(1 − 2r²/w0²) = exp(−2)</pre>
      </div>

      <p class="muted">
        Let <span style="font-family:var(--mono)">t = 2r²/w0²</span>. Then the equation becomes
      </p>

      <div class="eqbox">
        <button class="copybtn" data-copy-target="eq12">Copy</button>
        <pre class="eq" id="eq12">t · exp(1 − t) = exp(−2)
⇒ t · exp(−t) = exp(−3)
⇒ ln t − t = −3</pre>
      </div>

      <p class="muted">
        This transcendental equation has two positive solutions (because <span style="font-family:var(--mono)">t e^(−t)</span> rises then falls).
        In closed form, using the Lambert W function,
      </p>

      <div class="eqbox">
        <button class="copybtn" data-copy-target="eq13">Copy</button>
        <pre class="eq" id="eq13">t = −W_k(−e^(−3))   with k ∈ {0, −1}
r_(1/e²) = (w0/√2) · √t</pre>
      </div>

      <div class="result" id="finalBox">
        <h3>
          Final Results (at the waist plane)
          <span class="badge">Copy-friendly</span>
        </h3>

        <div class="eqbox" style="margin-top:10px;">
          <button class="copybtn" data-copy-target="finalText">Copy</button>
          <pre class="eq" id="finalText">Symbolic:
I_total(r) ∝ (r²/w0²) · exp(−2r²/w0²)    (circularly symmetric donut)
r_peak = w0/√2
r_(1/e²) = (w0/√2) · √( −W_k(−e^(−3)) ),  k = 0 and −1   (inner & outer radii)

For w0 = 1.00 mm:
r_peak ≈ 0.7071 mm
r_inner (I = I_peak/e²) ≈ 0.1620 mm
r_outer (I = I_peak/e²) ≈ 1.5009 mm</pre>
        </div>

        <p class="muted" style="margin:10px 0 0;">
          The two <span style="font-family:var(--mono)">1/e²</span> radii straddle the ring maximum: one inside and one outside.
        </p>
      </div>
    </section>

    <section id="viz">
      <h2>Interactive Visualizations</h2>
      <p class="muted">
        The plots use the same waist-plane model as the derivation:
        <span style="font-family:var(--mono)">I_total(x,y) ∝ (α x² + y²) e^(−2r²/w0²)</span>,
        where the slider parameter <span style="font-family:var(--mono)">α</span> explores power imbalance.
        The problem’s condition is <span style="font-family:var(--mono)">α = 1</span> (equal intensities), which gives perfect circular symmetry.
      </p>

      <figure class="canwrap">
        <header class="canhead">
          <div>
            <strong>1) Labeled Geometry Diagram (waist plane)</strong>
            <div class="muted">Shows the ring at <span style="font-family:var(--mono)">r_peak</span> and the two <span style="font-family:var(--mono)">1/e²</span> circles.</div>
          </div>
          <div class="pill" id="diagLabel">live</div>
        </header>
        <canvas id="cDiagram" aria-label="Diagram canvas"></canvas>
      </figure>

      <figure class="canwrap">
        <header class="canhead">
          <div>
            <strong>2) Main Plot: Radial Intensity Profile</strong>
            <div class="muted">Normalized intensity <span style="font-family:var(--mono)">I(r)/I_peak</span> vs radius r (mm).</div>
          </div>
          <div class="pill" id="mainLabel">live</div>
        </header>
        <canvas id="cRadial" aria-label="Radial plot canvas"></canvas>
      </figure>

      <figure class="canwrap">
        <header class="canhead">
          <div>
            <strong>3) Secondary Plot: 2D Intensity Map (x–y)</strong>
            <div class="muted">Heatmap of <span style="font-family:var(--mono)">I(x,y)</span> over the waist plane. α=1 gives a donut; α≠1 becomes elliptical.</div>
          </div>
          <div class="pill" id="mapLabel">live</div>
        </header>
        <canvas id="cMap" aria-label="2D intensity map canvas"></canvas>
      </figure>
    </section>

    <section id="checks">
      <h2>Sanity Checks</h2>
      <div class="grid2">
        <div class="card">
          <h3>Units</h3>
          <ul>
            <li><span style="font-family:var(--mono)">r</span> and <span style="font-family:var(--mono)">w₀</span> have units of length (mm here).</li>
            <li>Exponent <span style="font-family:var(--mono)">−2r²/w₀²</span> is dimensionless.</li>
            <li><span style="font-family:var(--mono)">I(r) ∝ (r²/w₀²) e^(...)</span> is consistent: prefactor is dimensionless, so intensity scale comes from the omitted constant.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Limiting cases</h3>
          <ul>
            <li><strong>Near the axis:</strong> <span style="font-family:var(--mono)">I(r) ~ r²</span> → dark center (as expected for first-order modes).</li>
            <li><strong>Far from the axis:</strong> Gaussian dominates → <span style="font-family:var(--mono)">I(r) → 0</span>.</li>
            <li><strong>Equal powers (α=1):</strong> perfect circular symmetry (donut).</li>
            <li><strong>Imbalanced powers (α≠1):</strong> still a “hole” at the center, but ring becomes elliptical in x–y (visualized).</li>
          </ul>
        </div>
      </div>

      <div class="note">
        <strong>Physical interpretation:</strong> The donut is not created by phase interference (we assumed incoherence), but by symmetry in the
        <em>sum of two orthogonal intensity lobes</em>. Equal weighting converts the separate x- and y-oriented patterns into a purely radial one.
      </div>
    </section>
  </article>
</main>

<footer class="footer">
  <div>
    Built with vanilla HTML/CSS/JS. Copy buttons copy plain text. Canvases are high-DPI aware and resize responsively.
  </div>
</footer>

<script>
(function(){
  "use strict";

  // ---------- Utilities ----------
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function fmt(x, d=3){ return (Math.round(x*Math.pow(10,d))/Math.pow(10,d)).toFixed(d); }

  // Lambert W via Halley's method (real branches k=0 and k=-1 for z in [-1/e, 0))
  // Returns NaN if out of range.
  function lambertW(z, branch){
    const min = -1/Math.E;
    if(!(z >= min && z < 0)) return NaN;

    let w;
    if(branch === 0){
      // good initial guess near 0: w ~ z
      w = z;
      // improve for moderately negative z
      if(z < -0.05) w = Math.log1p(z); // mild heuristic
    }else if(branch === -1){
      // branch -1 goes to -infty as z->0-, use log approximation
      // w ~ ln(-z) - ln(-ln(-z))
      const L1 = Math.log(-z);
      const L2 = Math.log(-L1);
      w = L1 - L2;
      // ensure w <= -1 for branch -1
      w = Math.min(w, -1.0000001);
    }else{
      return NaN;
    }

    // Halley's iterations
    for(let i=0;i<50;i++){
      const ew = Math.exp(w);
      const f  = w*ew - z;
      const wp1 = w + 1;
      const denom = ew*wp1 - (wp1+1)*f/(2*wp1);
      const dw = f/denom;
      w -= dw;
      if(Math.abs(dw) < 1e-14*(1+Math.abs(w))) break;
    }
    return w;
  }

  // ---------- Model ----------
  // Intensity model (waist plane):
  // I_total(x,y) ∝ (α x^2 + y^2) * exp(-2r^2/w0^2)
  // For α=1 it becomes radial: ∝ r^2 exp(-2r^2/w0^2).
  function intensityXY(x, y, w0, alpha){
    const r2 = x*x + y*y;
    const pref = alpha*x*x + y*y;
    return pref * Math.exp(-2*r2/(w0*w0));
  }

  // Radial profile for the symmetric (alpha=1) case normalized to I_peak:
  function radialNorm(r, w0){
    // f(r)=r^2 exp(-2r^2/w0^2). Normalize by f(r_peak)=(w0^2/2)*exp(-1)
    const f = r*r * Math.exp(-2*r*r/(w0*w0));
    const fpk = (w0*w0/2) * Math.exp(-1);
    return f / fpk;
  }

  function computeRadii(w0){
    const rPeak = w0/Math.sqrt(2);

    // Solve for I = I_peak / e^2 => ln t - t = -3, t=2r^2/w0^2
    // t = -W_k(-e^-3), k=0,-1
    const z = -Math.exp(-3);
    const W0 = lambertW(z, 0);
    const Wm1 = lambertW(z, -1);
    const t0 = -W0;
    const t1 = -Wm1;
    const rInner = (w0/Math.sqrt(2)) * Math.sqrt(t0);
    const rOuter = (w0/Math.sqrt(2)) * Math.sqrt(t1);
    return { rPeak, rInner, rOuter, t0, t1 };
  }

  // ---------- Canvas helpers ----------
  function setupCanvas(canvas){
    const ctx = canvas.getContext("2d");
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(10, Math.floor(rect.width));
      const h = Math.max(10, Math.floor(rect.height));
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {w, h, dpr};
    }
    return {ctx, resize};
  }

  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
    const {x,y,w,h} = box;
    // background
    ctx.save();
    ctx.translate(x,y);

    // Title
    ctx.fillStyle = "rgba(231,238,248,.95)";
    ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(title, 10, 18);

    const padL = 56, padR = 16, padT = 32, padB = 44;
    const px0 = padL, py0 = padT, pw = w - padL - padR, ph = h - padT - padB;

    // grid
    ctx.strokeStyle = "rgba(255,255,255,.08)";
    ctx.lineWidth = 1;

    const nGrid = 6;
    for(let i=0;i<=nGrid;i++){
      const gx = px0 + pw*i/nGrid;
      const gy = py0 + ph*i/nGrid;
      ctx.beginPath(); ctx.moveTo(gx, py0); ctx.lineTo(gx, py0+ph); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(px0, gy); ctx.lineTo(px0+pw, gy); ctx.stroke();
    }

    // axes frame
    ctx.strokeStyle = "rgba(255,255,255,.18)";
    ctx.lineWidth = 1.2;
    ctx.strokeRect(px0, py0, pw, ph);

    // ticks + labels
    ctx.fillStyle = "rgba(169,183,204,.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

    function xToPx(v){ return px0 + (v-xMin)/(xMax-xMin)*pw; }
    function yToPy(v){ return py0 + ph - (v-yMin)/(yMax-yMin)*ph; }

    // x ticks
    const nTick = 6;
    for(let i=0;i<=nTick;i++){
      const v = xMin + (xMax-xMin)*i/nTick;
      const xp = xToPx(v);
      ctx.strokeStyle = "rgba(255,255,255,.22)";
      ctx.beginPath(); ctx.moveTo(xp, py0+ph); ctx.lineTo(xp, py0+ph+6); ctx.stroke();
      const s = (Math.abs(v) < 1e-12) ? "0" : (Math.round(v*1000)/1000).toString();
      ctx.fillText(s, xp-10, py0+ph+20);
    }

    // y ticks
    for(let i=0;i<=nTick;i++){
      const v = yMin + (yMax-yMin)*i/nTick;
      const yp = yToPy(v);
      ctx.strokeStyle = "rgba(255,255,255,.22)";
      ctx.beginPath(); ctx.moveTo(px0-6, yp); ctx.lineTo(px0, yp); ctx.stroke();
      const s = (Math.abs(v) < 1e-12) ? "0" : (Math.round(v*1000)/1000).toString();
      ctx.fillText(s, 10, yp+4);
    }

    // axis labels
    ctx.fillStyle = "rgba(231,238,248,.85)";
    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(xLabel, px0 + pw/2 - ctx.measureText(xLabel).width/2, y + 0 + (py0+ph+36));
    // y label rotated
    ctx.save();
    ctx.translate(18, py0 + ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
    ctx.restore();

    ctx.restore();
    return { padL, padR, padT, padB, px0:x+padL, py0:y+padT, pw:w-padL-16, ph:h-padT-44, xToPx, yToPy, plotBox:{x:x+padL, y:y+padT, w:w-padL-16, h:h-padT-44} };
  }

  // ---------- Plot 1: Diagram ----------
  const cDiagram = document.getElementById("cDiagram");
  const cRadial  = document.getElementById("cRadial");
  const cMap     = document.getElementById("cMap");

  const diag = setupCanvas(cDiagram);
  const rad  = setupCanvas(cRadial);
  const map  = setupCanvas(cMap);

  // ---------- Controls ----------
  const w0Slider = document.getElementById("w0");
  const aSlider  = document.getElementById("alpha");
  const w0Read   = document.getElementById("w0Read");
  const aRead    = document.getElementById("aRead");

  function setReads(){
    w0Read.textContent = fmt(parseFloat(w0Slider.value), 2);
    aRead.textContent  = fmt(parseFloat(aSlider.value), 2);
  }

  // ---------- Draw functions ----------
  function drawDiagram(w0, alpha){
    const {ctx, resize} = diag;
    const {w, h} = resize();
    ctx.clearRect(0,0,w,h);

    // Coordinate setup: draw in a square region
    const margin = 18;
    const side = Math.min(w, h) - 2*margin;
    const ox = (w - side)/2;
    const oy = (h - side)/2;

    // background vignette
    const g = ctx.createRadialGradient(w*0.5,h*0.5, 10, w*0.5,h*0.5, Math.max(w,h)*0.55);
    g.addColorStop(0, "rgba(110,231,255,.06)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // Title
    ctx.fillStyle = "rgba(231,238,248,.95)";
    ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Waist-plane geometry (x–y): ring + reference circles", 14, 18);

    const { rPeak, rInner, rOuter } = computeRadii(w0);

    // Use a plotted coordinate extent tied to w0
    // show +/- 2.2 w0
    const L = 2.2*w0;
    function X(x){ return ox + (x + L)/(2*L) * side; }
    function Y(y){ return oy + (L - y)/(2*L) * side; }

    // axes
    ctx.strokeStyle = "rgba(255,255,255,.20)";
    ctx.lineWidth = 1.2;
    ctx.beginPath(); ctx.moveTo(X(-L), Y(0)); ctx.lineTo(X(L), Y(0)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(X(0), Y(-L)); ctx.lineTo(X(0), Y(L)); ctx.stroke();

    // ticks
    ctx.strokeStyle = "rgba(255,255,255,.16)";
    ctx.fillStyle = "rgba(169,183,204,.9)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    for(let k=-2;k<=2;k++){
      const t = k*w0;
      const xp = X(t);
      const yp = Y(t);
      // x ticks
      ctx.beginPath(); ctx.moveTo(xp, Y(0)-5); ctx.lineTo(xp, Y(0)+5); ctx.stroke();
      // y ticks
      ctx.beginPath(); ctx.moveTo(X(0)-5, yp); ctx.lineTo(X(0)+5, yp); ctx.stroke();
      if(k!==0){
        ctx.fillText((k).toString()+"w0", xp-12, Y(0)+20);
        ctx.fillText((k).toString()+"w0", X(0)+10, yp+4);
      }
    }

    // circles: rInner, rPeak, rOuter
    function circle(r, stroke, dash, label){
      ctx.save();
      ctx.setLineDash(dash || []);
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2;
      ctx.beginPath();
      const cx = X(0), cy = Y(0);
      const pr = (r/L) * (side/2);
      ctx.arc(cx, cy, pr, 0, Math.PI*2);
      ctx.stroke();
      ctx.setLineDash([]);
      // label near +x axis
      ctx.fillStyle = "rgba(231,238,248,.9)";
      ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(label, cx + pr + 6, cy - 6);
      ctx.restore();
    }

    circle(rPeak,  "rgba(52,211,153,.85)", [], "r_peak");
    circle(rInner, "rgba(251,191,36,.85)", [6,6], "r_inner (I=Ipk/e²)");
    circle(rOuter, "rgba(251,191,36,.85)", [6,6], "r_outer (I=Ipk/e²)");

    // Indicate symmetry note depending on alpha
    ctx.fillStyle = "rgba(169,183,204,.95)";
    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const sym = (Math.abs(alpha-1) < 1e-3) ? "Circular symmetry (α=1)" : "Elliptical symmetry (α≠1)";
    ctx.fillText(sym, 14, h-14);
  }

  // ---------- Plot 2: Radial profile ----------
  function drawRadial(w0){
    const {ctx, resize} = rad;
    const {w,h} = resize();
    ctx.clearRect(0,0,w,h);

    const { rPeak, rInner, rOuter } = computeRadii(w0);

    // x range: 0..(2.3 w0)
    const xMin = 0, xMax = 2.3*w0;
    const yMin = 0, yMax = 1.10;

    const plot = drawAxes(ctx, {x:0,y:0,w,h}, xMin, xMax, yMin, yMax, "r (mm)", "I(r)/I_peak (—)", "Radial intensity (donut case: α = 1)");

    // Curve
    ctx.save();
    const pb = plot.plotBox;
    ctx.beginPath();
    ctx.lineWidth = 2.4;
    ctx.strokeStyle = "rgba(110,231,255,.90)";

    const N = 600;
    for(let i=0;i<=N;i++){
      const r = xMin + (xMax-xMin)*i/N;
      const I = radialNorm(r, w0);
      const xp = plot.xToPx(r);
      const yp = plot.yToPy(I);
      if(i===0) ctx.moveTo(xp, yp);
      else ctx.lineTo(xp, yp);
    }
    ctx.stroke();

    // Reference lines: y = 1/e^2
    const yRef = Math.exp(-2);
    ctx.setLineDash([6,6]);
    ctx.strokeStyle = "rgba(251,191,36,.75)";
    ctx.lineWidth = 1.8;
    ctx.beginPath();
    ctx.moveTo(plot.xToPx(xMin), plot.yToPy(yRef));
    ctx.lineTo(plot.xToPx(xMax), plot.yToPy(yRef));
    ctx.stroke();
    ctx.setLineDash([]);

    // Markers
    function marker(r, color, label){
      const x = plot.xToPx(r);
      const y = plot.yToPy(radialNorm(r, w0));
      ctx.fillStyle = color;
      ctx.beginPath(); ctx.arc(x,y,5,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,.35)";
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.fillStyle = "rgba(231,238,248,.9)";
      ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(label, x+8, y-8);
    }
    marker(rPeak,  "rgba(52,211,153,.95)", "r_peak");
    marker(rInner, "rgba(251,191,36,.95)", "r_inner");
    marker(rOuter, "rgba(251,191,36,.95)", "r_outer");

    // Legend
    const lx = pb.x + 10, ly = pb.y + 8;
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(lx, ly, 260, 58, 10);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = "rgba(231,238,248,.9)";
    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Curve: I(r)/I_peak = (2r²/w0²) exp(1−2r²/w0²)", lx+10, ly+18);
    ctx.fillStyle = "rgba(251,191,36,.9)";
    ctx.fillText("Dashed: I/I_peak = e^(−2)", lx+10, ly+38);

    ctx.restore();
  }

  // ---------- Plot 3: 2D intensity map ----------
  function drawMap(w0, alpha){
    const {ctx, resize} = map;
    const {w,h} = resize();
    ctx.clearRect(0,0,w,h);

    // Plot extent: +/- 2.2 w0
    const L = 2.2*w0;

    // axes box using drawAxes
    const xMin = -L, xMax = L;
    const yMin = -L, yMax = L;
    const plot = drawAxes(ctx, {x:0,y:0,w,h}, xMin, xMax, yMin, yMax, "x (mm)", "y (mm)", "2D intensity map at the waist: I(x,y) (scaled)");

    const pb = plot.plotBox;

    // Heatmap resolution (balanced for speed)
    const nx = 180;
    const ny = Math.max(120, Math.round(nx * pb.h / pb.w));
    const img = ctx.createImageData(nx, ny);

    // Find a reference normalization: use maximum along ring approximately
    // For alpha !=1, max changes slightly; we estimate by sampling.
    let Imax = 0;
    for(let k=0;k<600;k++){
      const th = 2*Math.PI*k/600;
      const r = w0/Math.sqrt(2); // donut peak for symmetric; good anchor
      const x = r*Math.cos(th);
      const y = r*Math.sin(th);
      const I = intensityXY(x,y,w0,alpha);
      if(I>Imax) Imax=I;
    }
    // fallback
    if(Imax<=0) Imax = 1;

    function colorMap(v){
      // v in [0,1]
      v = clamp(v,0,1);
      // dark -> cyan -> violet -> white
      const a = v;
      const r = Math.round(20 + 235*Math.pow(a, 1.25));
      const g = Math.round(20 + 220*Math.pow(a, 0.95));
      const b = Math.round(35 + 240*Math.pow(a, 0.75));
      return [r,g,b,255];
    }

    // Fill image
    for(let j=0;j<ny;j++){
      for(let i=0;i<nx;i++){
        const x = xMin + (xMax-xMin)*(i+0.5)/nx;
        const y = yMax - (yMax-yMin)*(j+0.5)/ny; // invert for image coordinates
        const I = intensityXY(x,y,w0,alpha) / Imax;
        // compress dynamic range slightly
        const v = Math.pow(clamp(I,0,1), 0.55);
        const idx = 4*(j*nx + i);
        const c = colorMap(v);
        img.data[idx+0]=c[0];
        img.data[idx+1]=c[1];
        img.data[idx+2]=c[2];
        img.data[idx+3]=c[3];
      }
    }

    // Draw image scaled into plot box
    ctx.save();
    // clip to plot area
    ctx.beginPath();
    ctx.rect(pb.x, pb.y, pb.w, pb.h);
    ctx.clip();
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(imageDataToCanvas(img), pb.x, pb.y, pb.w, pb.h);
    ctx.restore();

    // Overlays: show r_peak circle if alpha ~ 1, else show an ellipse hint
    const { rPeak } = computeRadii(w0);
    ctx.save();
    ctx.strokeStyle = (Math.abs(alpha-1)<1e-3) ? "rgba(52,211,153,.80)" : "rgba(251,191,36,.85)";
    ctx.lineWidth = 2;
    ctx.setLineDash([7,6]);

    // circle at rPeak in physical coords
    ctx.beginPath();
    const cx = plot.xToPx(0);
    const cy = plot.yToPy(0);
    const pr = (rPeak/L) * (pb.w/2);
    // Since axes are square range but plot area may not be square, use min scale to draw visually consistent circle in coords:
    const sx = pb.w/(xMax-xMin);
    const sy = pb.h/(yMax-yMin);
    const rrX = rPeak*sx;
    const rrY = rPeak*sy;
    // draw ellipse representing circle in coordinate scaling
    ctx.ellipse(cx, cy, rrX, rrY, 0, 0, 2*Math.PI);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = "rgba(231,238,248,.90)";
    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Reference: r_peak", cx + rrX + 8, cy - 8);

    // small legend box
    const lx = pb.x + 10, ly = pb.y + pb.h - 56;
    ctx.fillStyle = "rgba(0,0,0,.40)";
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(lx, ly, 290, 46, 10);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = "rgba(231,238,248,.9)";
    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Model: I(x,y) ∝ (αx² + y²) exp(−2r²/w0²)", lx+10, ly+18);
    ctx.fillStyle = "rgba(169,183,204,.95)";
    ctx.fillText("α=1 → circular donut (problem condition)", lx+10, ly+36);

    ctx.restore();
  }

  // helper: ImageData -> offscreen canvas for drawImage
  function imageDataToCanvas(imgData){
    const off = document.createElement("canvas");
    off.width = imgData.width;
    off.height = imgData.height;
    const octx = off.getContext("2d");
    octx.putImageData(imgData, 0, 0);
    return off;
  }

  // ---------- Update all ----------
  function updateAll(){
    setReads();
    const w0 = parseFloat(w0Slider.value);     // mm
    const alpha = parseFloat(aSlider.value);   // ratio

    // Update final box numbers live (consistent with model)
    const { rPeak, rInner, rOuter } = computeRadii(w0);

    // Update the final text block to match current slider (but keep the w0=1mm statement visible)
    // We'll add a short "Current sliders" section appended (still plain text).
    const base = `Symbolic:
I_total(r) ∝ (r²/w0²) · exp(−2r²/w0²)    (circularly symmetric donut)
r_peak = w0/√2
r_(1/e²) = (w0/√2) · √( −W_k(−e^(−3)) ),  k = 0 and −1   (inner & outer radii)

For w0 = 1.00 mm:
r_peak ≈ 0.7071 mm
r_inner (I = I_peak/e²) ≈ 0.1620 mm
r_outer (I = I_peak/e²) ≈ 1.5009 mm

Current sliders (for visualization):
w0 = ${fmt(w0,2)} mm, α = ${fmt(alpha,2)}
r_peak ≈ ${fmt(rPeak,4)} mm
r_inner ≈ ${fmt(rInner,4)} mm
r_outer ≈ ${fmt(rOuter,4)} mm`;
    document.getElementById("finalText").textContent = base;

    drawDiagram(w0, alpha);
    drawRadial(w0);
    drawMap(w0, alpha);
  }

  // ---------- Copy buttons ----------
  function hookCopy(){
    const buttons = document.querySelectorAll(".copybtn");
    buttons.forEach(btn=>{
      btn.addEventListener("click", async ()=>{
        const id = btn.getAttribute("data-copy-target");
        const el = document.getElementById(id);
        const text = (el && el.textContent) ? el.textContent.trim() : "";
        try{
          await navigator.clipboard.writeText(text);
          const old = btn.textContent;
          btn.textContent = "Copied!";
          btn.style.borderColor = "rgba(52,211,153,.55)";
          btn.style.background = "rgba(52,211,153,.10)";
          setTimeout(()=>{
            btn.textContent = old;
            btn.style.borderColor = "";
            btn.style.background = "";
          }, 900);
        }catch(e){
          // fallback: select text
          const range = document.createRange();
          range.selectNodeContents(el);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
          const old = btn.textContent;
          btn.textContent = "Select & Copy";
          setTimeout(()=>{ btn.textContent = old; }, 1200);
        }
      });
    });
  }

  // smooth scrolling for TOC
  function hookTOC(){
    document.querySelectorAll('nav.toc a').forEach(a=>{
      a.addEventListener('click', (e)=>{
        const href = a.getAttribute('href');
        if(!href || href[0] !== '#') return;
        const target = document.querySelector(href);
        if(target){
          e.preventDefault();
          target.scrollIntoView({behavior:'smooth', block:'start'});
        }
      });
    });
  }

  // handle resize
  let resizeTimer = null;
  window.addEventListener("resize", ()=>{
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(updateAll, 60);
  });

  w0Slider.addEventListener("input", updateAll);
  aSlider.addEventListener("input", updateAll);

  // Polyfill roundRect if needed
  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    };
  }

  hookCopy();
  hookTOC();
  updateAll();
})();
</script>
</body>
</html>
