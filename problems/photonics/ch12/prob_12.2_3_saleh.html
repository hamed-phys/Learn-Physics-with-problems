<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Spectrum of a Superposition of Two Waves — When Can a Sum “Shift” Frequency?</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --card:#0f1730;
      --ink:#e9ecff;
      --muted:#b8c0ffcc;
      --faint:#b8c0ff55;
      --accent:#7bdcff;
      --accent2:#a7ff83;
      --warn:#ffd36b;
      --danger:#ff7b9a;
      --line:#2a3a74;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html{ scroll-behavior:smooth; }
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 600px at 20% 10%, #14204a 0%, var(--bg) 55%, #070a14 100%);
      color:var(--ink);
      line-height:1.55;
    }

    header{
      padding: 28px 18px 14px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      position: relative;
      overflow:hidden;
    }
    header::before{
      content:"";
      position:absolute; inset:-80px -120px auto -120px;
      height:280px;
      background: radial-gradient(closest-side at 60% 40%, rgba(123,220,255,.18), rgba(167,255,131,.08), transparent 70%);
      filter: blur(2px);
      pointer-events:none;
    }
    .wrap{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 16px;
    }
    .title{
      display:flex;
      gap:14px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-size: clamp(1.5rem, 2.6vw, 2.3rem);
      letter-spacing: .2px;
    }
    .subtitle{
      margin: 6px 0 0;
      color: var(--muted);
      max-width: 72ch;
      font-size: 1.02rem;
    }

    main{
      padding: 18px 0 56px;
    }

    /* Layout with sticky ToC */
    .grid{
      display:grid;
      grid-template-columns: 290px 1fr;
      gap: 18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
    }

    nav.toc{
      position: sticky;
      top: 12px;
      align-self:start;
      background: linear-gradient(180deg, rgba(17,26,51,.9), rgba(17,26,51,.65));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 12px;
      backdrop-filter: blur(8px);
    }
    nav.toc h2{
      margin: 0 0 8px;
      font-size: .95rem;
      letter-spacing:.4px;
      color: var(--muted);
      text-transform: uppercase;
    }
    nav.toc a{
      display:block;
      padding: 8px 10px;
      border-radius: 12px;
      text-decoration:none;
      color: var(--ink);
      font-size: .95rem;
      border: 1px solid transparent;
    }
    nav.toc a:hover{
      border-color: rgba(123,220,255,.35);
      background: rgba(123,220,255,.08);
    }
    nav.toc .mini{
      margin-top:10px;
      font-size:.86rem;
      color: var(--muted);
      padding: 10px 10px 0;
      border-top: 1px dashed rgba(255,255,255,.12);
    }

    article{
      min-width: 0;
    }

    section{
      margin: 14px 0 18px;
      padding: 16px 16px 14px;
      background: linear-gradient(180deg, rgba(15,23,48,.92), rgba(15,23,48,.72));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      position:relative;
      overflow:hidden;
    }
    section::after{
      content:"";
      position:absolute;
      inset:auto -40px -40px auto;
      width: 220px;
      height: 220px;
      background: radial-gradient(closest-side, rgba(123,220,255,.12), transparent 70%);
      transform: rotate(10deg);
      pointer-events:none;
    }

    h2{
      margin: 0 0 10px;
      font-size: 1.25rem;
      letter-spacing:.2px;
    }
    h3{
      margin: 14px 0 6px;
      font-size: 1.05rem;
      color: #dce2ff;
    }
    p{ margin: 8px 0; color: #e9ecff; }
    ul{ margin: 8px 0 8px 20px; color:#e9ecff; }
    li{ margin: 4px 0; }
    .muted{ color: var(--muted); }

    .cards{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    @media (max-width: 820px){
      .cards{ grid-template-columns:1fr; }
    }

    .callout{
      border-radius: 16px;
      padding: 12px 12px 10px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(17,26,51,.55);
      position:relative;
    }
    .callout strong{
      display:block;
      margin-bottom: 6px;
      letter-spacing:.2px;
    }
    .assumptions{ border-left: 4px solid var(--accent); }
    .keyeq{ border-left: 4px solid var(--accent2); }
    .mistakes{ border-left: 4px solid var(--warn); }
    .final{ border-left: 4px solid var(--danger); }

    .eqbox{
      margin: 10px 0;
      border-radius: 16px;
      padding: 10px 10px 10px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      overflow:auto;
      position:relative;
    }
    .eq{
      font-family: var(--mono);
      font-size: .95rem;
      color: #f3f6ff;
      white-space: pre-wrap;
      margin:0;
    }
    .copybtn{
      position:absolute;
      top:10px;
      right:10px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(123,220,255,.12);
      color: var(--ink);
      padding: 6px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-size: .85rem;
      transition: transform .12s ease, background .12s ease;
      user-select:none;
    }
    .copybtn:hover{ background: rgba(123,220,255,.18); transform: translateY(-1px); }
    .copybtn:active{ transform: translateY(0px) scale(.98); }

    /* Visualization area */
    .vizgrid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap: 12px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .vizgrid{ grid-template-columns:1fr; }
    }
    .vizcard{
      border-radius: 16px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(17,26,51,.45);
      min-width: 0;
    }
    .viztitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 8px;
      margin-bottom: 8px;
    }
    .viztitle h3{ margin:0; font-size: 1rem; }
    canvas{
      width:100%;
      height: 320px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(5,8,18,.55);
      display:block;
    }
    .small canvas{ height: 250px; }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    @media (max-width: 820px){
      .controls{ grid-template-columns: 1fr; }
    }
    .control{
      border-radius: 16px;
      padding: 10px 10px 8px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.16);
    }
    .control label{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      font-size:.92rem;
      color: var(--muted);
    }
    .control input[type="range"]{
      width:100%;
      margin-top: 8px;
      accent-color: var(--accent);
    }
    .control select{
      width:100%;
      margin-top: 8px;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(15,23,48,.8);
      color: var(--ink);
      outline:none;
    }
    .pill{
      font-family: var(--mono);
      color: #f3f6ff;
      background: rgba(123,220,255,.10);
      border: 1px solid rgba(123,220,255,.22);
      padding: 2px 8px;
      border-radius: 999px;
      font-size: .84rem;
      white-space:nowrap;
    }

    footer{
      margin-top: 18px;
      padding: 18px 0 30px;
      color: var(--muted);
      text-align:center;
      font-size: .92rem;
      border-top: 1px solid rgba(255,255,255,.06);
    }

    /* Print-friendly */
    @media print{
      body{ background:#fff; color:#000; }
      nav.toc{ display:none; }
      section{ box-shadow:none; background:#fff; border:1px solid #ddd; }
      canvas{ border:1px solid #bbb; background:#fff; }
      .copybtn{ display:none; }
    }

    /* subtle animation */
    @keyframes floatIn{
      from{ transform: translateY(6px); opacity:0; }
      to{ transform: translateY(0px); opacity:1; }
    }
    section{ animation: floatIn .32s ease both; }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="title">
        <div>
          <h1>Spectrum of a Superposition of Two Waves</h1>
          <p class="subtitle">
            Two optical waves with identical Gaussian spectra are added: <span class="pill">U(t)=U<sub>1</sub>(t)+U<sub>2</sub>(t)</span>.
            The twist: they may be correlated. We derive the resulting power spectral density (PSD) and test whether a “fake Doppler shift”
            (a shifted Gaussian center) can emerge purely from superposition.
          </p>
        </div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <div class="grid">
      <nav class="toc" aria-label="Table of contents">
        <h2>Contents</h2>
        <a href="#qs">Quick Summary</a>
        <a href="#p0">PART 0 — Concept Primer</a>
        <a href="#p1">PART 1 — Problem Analysis</a>
        <a href="#p2">PART 2 — Strategy &amp; Tips</a>
        <a href="#p3">PART 3 — Full Solution</a>
        <a href="#p4">PART 4 — Deeper Understanding</a>
        <a href="#p5">PART 5 — Visualization Guide</a>
        <div class="mini">
          <div><span class="pill">Interactive</span> sliders below update all canvases.</div>
        </div>
      </nav>

      <article>
        <section id="qs">
          <h2>Quick Summary</h2>
          <ul>
            <li><b>Problem:</b> Find the PSD <span class="pill">S(ν)</span> of <span class="pill">U(t)=U<sub>1</sub>(t)+U<sub>2</sub>(t)</span> when each component has the <i>same Gaussian</i> PSD centered at <span class="pill">ν<sub>0</sub></span>, and the waves may be correlated.</li>
            <li><b>Key idea:</b> PSD of a sum is not just the sum of PSDs — a <b>cross-spectral</b> term appears.</li>
            <li><b>Governing relation:</b> <span class="pill">S(ν)=S<sub>1</sub>(ν)+S<sub>2</sub>(ν)+2Re{S<sub>12</sub>(ν)}</span>, where <span class="pill">S<sub>12</sub></span> is the cross power spectral density.</li>
            <li><b>Use coherence:</b> If <span class="pill">S<sub>1</sub>=S<sub>2</sub></span>, then <span class="pill">S(ν)=2S<sub>1</sub>(ν)[1+Re{γ<sub>12</sub>(ν)}]</span>, with <span class="pill">γ<sub>12</sub>(ν)=S<sub>12</sub>(ν)/S<sub>1</sub>(ν)</span>.</li>
            <li><b>Constraint:</b> Cauchy–Schwarz implies <span class="pill">|S<sub>12</sub>(ν)|² ≤ S<sub>1</sub>(ν)S<sub>2</sub>(ν)</span> ⇒ <span class="pill">|γ<sub>12</sub>(ν)| ≤ 1</span>.</li>
            <li><b>Main conclusion:</b> The output spectrum can be <b>distorted</b> (fringes, ripples, narrowing in special cases), but it <b>cannot become a purely shifted Gaussian</b> centered at <span class="pill">ν<sub>1</sub>≠ν<sub>0</sub></span> without violating <span class="pill">|γ<sub>12</sub>|≤1</span> (except the trivial case <span class="pill">ν<sub>1</sub>=ν<sub>0</sub></span>).</li>
            <li><b>Result type:</b> Fully <b>symbolic</b> formula for <span class="pill">S(ν)</span> with physical interpretation; plots use <b>example values</b>.</li>
          </ul>
        </section>

        <section id="p0">
          <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

          <h3>Core definitions (symbols &amp; units)</h3>
          <ul>
            <li><b>Optical field / wave (complex envelope):</b> <span class="pill">U(t)</span> (e.g., volts, or normalized field amplitude). In optics we often treat the field as a complex analytic signal to focus on positive frequencies.</li>
            <li><b>Autocorrelation:</b> <span class="pill">R<sub>UU</sub>(τ)=⟨U(t)U*(t+τ)⟩</span> (units: |U|²). Angle brackets denote time/ensemble average for a wide-sense stationary process.</li>
            <li><b>Power spectral density (PSD):</b> <span class="pill">S(ν)</span> (units: |U|²/Hz). It is the Fourier transform of the autocorrelation (Wiener–Khinchin).</li>
            <li><b>Cross-correlation:</b> <span class="pill">R<sub>12</sub>(τ)=⟨U<sub>1</sub>(t)U<sub>2</sub>*(t+τ)⟩</span>.</li>
            <li><b>Cross power spectral density (CPSD):</b> <span class="pill">S<sub>12</sub>(ν)=∫R<sub>12</sub>(τ)e<sup>-i2πντ</sup>dτ</span>.</li>
            <li><b>Complex degree of spectral coherence:</b> <span class="pill">γ<sub>12</sub>(ν)=S<sub>12</sub>(ν)/√(S<sub>1</sub>(ν)S<sub>2</sub>(ν))</span>, dimensionless, with <span class="pill">|γ<sub>12</sub>(ν)|≤1</span>.</li>
          </ul>

          <h3>Physical meaning</h3>
          <ul>
            <li><b>PSD</b> tells you how the wave’s power is distributed across frequency.</li>
            <li><b>Cross-spectrum</b> measures how much the two waves share <i>phase-linked</i> content at each frequency — it is the frequency-domain signature of correlation.</li>
            <li><b>Coherence</b> acts like a “contrast knob”: if the waves are uncorrelated, interference averages away; if correlated, interference reshapes the measured spectrum.</li>
          </ul>

          <h3>Key laws/principles (and validity)</h3>
          <div class="cards">
            <div class="callout keyeq">
              <strong>Wiener–Khinchin (wide-sense stationary)</strong>
              <p class="muted">PSD is the Fourier transform of the autocorrelation. Requires stationarity (statistics depend only on time differences) and finite second moments.</p>
            </div>
            <div class="callout keyeq">
              <strong>Cauchy–Schwarz (coherence bound)</strong>
              <p class="muted">For any two random processes, the magnitude of cross-correlation/cross-spectrum is bounded, leading to <span class="pill">|γ<sub>12</sub>(ν)|≤1</span>.</p>
            </div>
          </div>

          <h3>Common models/approximations (why we use them)</h3>
          <ul>
            <li><b>Gaussian spectrum:</b> Many broadened optical sources (e.g., due to random phase noise) are well-approximated by a Gaussian line shape near the carrier.</li>
            <li><b>“Delayed copy” model:</b> Often <span class="pill">U<sub>2</sub>(t)</span> can be approximated as a scaled, delayed, phase-shifted version of <span class="pill">U<sub>1</sub>(t)</span>, which produces a simple frequency-dependent phase factor in the cross-spectrum.</li>
            <li><b>Narrowband optics:</b> We focus on frequencies near <span class="pill">ν<sub>0</sub></span> (hundreds of THz) and examine spectral structure within a few THz around it.</li>
          </ul>

          <h3>Mini intuition examples</h3>
          <ul>
            <li><b>Uncorrelated addition:</b> If the waves have unrelated phases, their powers add: the spectrum doubles, but the shape stays the same.</li>
            <li><b>Perfectly coherent addition:</b> If <span class="pill">U<sub>2</sub>=U<sub>1</sub></span>, then <span class="pill">U=2U<sub>1</sub></span> and the PSD becomes four times larger (power scales as amplitude squared).</li>
          </ul>

          <div class="callout mistakes">
            <strong>What to watch for (pitfalls)</strong>
            <ul>
              <li>Forgetting the <b>cross term</b> when adding signals.</li>
              <li>Thinking “interference” must shift the line center — it typically creates <b>ripples</b>, not a clean translation of the envelope.</li>
              <li>Ignoring the <b>coherence bound</b> <span class="pill">|γ|≤1</span>, which forbids arbitrary spectral reshaping.</li>
            </ul>
          </div>
        </section>

        <section id="p1">
          <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

          <h3>Problem restatement (in plain words)</h3>
          <p>
            Two optical waves <span class="pill">U<sub>1</sub>(t)</span> and <span class="pill">U<sub>2</sub>(t)</span> are added.
            Each has the same Gaussian PSD centered at <span class="pill">ν<sub>0</sub></span> with spectral width <span class="pill">Δν</span>.
            The waves may be correlated. Find the PSD <span class="pill">S(ν)</span> of <span class="pill">U(t)=U<sub>1</sub>(t)+U<sub>2</sub>(t)</span>.
            Then investigate whether <span class="pill">S(ν)</span> itself could also be Gaussian but centered at a different frequency <span class="pill">ν<sub>1</sub>≠ν<sub>0</sub></span>.
          </p>

          <h3>Given</h3>
          <ul>
            <li><span class="pill">S<sub>1</sub>(ν)=S<sub>2</sub>(ν)</span>, Gaussian, centered at <span class="pill">ν<sub>0</sub></span> with width <span class="pill">Δν</span>.</li>
            <li><span class="pill">U(t)=U<sub>1</sub>(t)+U<sub>2</sub>(t)</span>.</li>
            <li>Correlation between waves is not specified (could range from none to perfect coherence).</li>
          </ul>

          <h3>Unknowns</h3>
          <ul>
            <li>Expression for <span class="pill">S(ν)</span> in terms of <span class="pill">S<sub>1</sub>(ν)</span> and cross-spectral information.</li>
            <li>Whether a <b>pure Gaussian</b> with shifted center can arise from superposition alone.</li>
          </ul>

          <h3>Relevant principles (and why)</h3>
          <ul>
            <li><b>Linearity:</b> The spectrum of a linear sum is determined by second-order statistics of the components.</li>
            <li><b>Wiener–Khinchin:</b> PSD comes from autocorrelation; for a sum, the autocorrelation expands into auto- and cross-correlations.</li>
            <li><b>Cauchy–Schwarz:</b> Provides a hard bound on how large the cross-spectrum can be relative to the auto-spectra, crucial for ruling out impossible “fake shifts.”</li>
          </ul>

          <div class="cards">
            <div class="callout assumptions">
              <strong>Assumptions (explicit)</strong>
              <ul>
                <li>Wide-sense stationarity (so PSDs are well-defined via correlations).</li>
                <li>We work with complex analytic signals (optics: positive-frequency description).</li>
                <li>Gaussian auto-spectra are given; cross-spectrum is unconstrained except by physics/mathematics (coherence bounds).</li>
              </ul>
            </div>
            <div class="callout assumptions">
              <strong>What we are <i>not</i> assuming</strong>
              <ul>
                <li>Not assuming independence (uncorrelated) unless stated.</li>
                <li>Not assuming a particular physical interferometer; the math holds for any linear addition.</li>
              </ul>
            </div>
          </div>

          <h3>Possible approaches (pros/cons)</h3>
          <ul>
            <li><b>Correlation expansion (best):</b> Expand <span class="pill">R<sub>UU</sub></span> in terms of <span class="pill">R<sub>11</sub>, R<sub>22</sub>, R<sub>12</sub>, R<sub>21</sub></span>, then Fourier transform. <span class="muted">Pros: general, transparent; Cons: requires comfort with correlations.</span></li>
            <li><b>Frequency-domain random phasors:</b> Treat each frequency component as a random complex amplitude and add; PSD uses expected squared magnitude. <span class="muted">Pros: intuitive; Cons: easy to accidentally assume independence.</span></li>
            <li><b>Specific model (delayed copy):</b> Assume <span class="pill">U<sub>2</sub>(t)=e^{iφ}U<sub>1</sub>(t-τ)</span> and compute directly. <span class="muted">Pros: shows interference fringes clearly; Cons: not fully general.</span></li>
          </ul>
          <p><b>Choice:</b> We use the <b>general correlation expansion</b>, then interpret with the coherence function and (optionally) a delayed-copy model for visualization.</p>
        </section>

        <section id="p2">
          <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>

          <ol>
            <li>
              <b>Goal:</b> Write the autocorrelation of the sum.
              <br><span class="muted">Tool:</span> Expand <span class="pill">R<sub>UU</sub>(τ)=⟨U(t)U*(t+τ)⟩</span>.
              <br><span class="muted">Meaning:</span> Reveals auto-terms + cross-terms.
            </li>
            <li>
              <b>Goal:</b> Fourier transform to get PSD.
              <br><span class="muted">Tool:</span> Wiener–Khinchin: PSD is FT of correlation.
              <br><span class="muted">Meaning:</span> Cross-correlations become cross-spectra.
            </li>
            <li>
              <b>Goal:</b> Simplify using <span class="pill">S<sub>1</sub>=S<sub>2</sub></span>.
              <br><span class="muted">Tool:</span> Define <span class="pill">γ<sub>12</sub>(ν)</span>.
              <br><span class="muted">Meaning:</span> Output PSD = Gaussian envelope × coherence factor.
            </li>
            <li>
              <b>Goal:</b> Test the “shifted Gaussian” hypothesis.
              <br><span class="muted">Tool:</span> Compare functional forms; apply <span class="pill">|γ|≤1</span>.
              <br><span class="muted">Meaning:</span> Show a clean shift cannot be faked by superposition alone.
            </li>
            <li>
              <b>Goal:</b> Sanity checks and limiting cases.
              <br><span class="muted">Tool:</span> Check μ=0, μ=1, and phase/delay extremes.
              <br><span class="muted">Meaning:</span> Confirm correct physics (power addition vs interference).
            </li>
          </ol>

          <div class="callout mistakes">
            <strong>Common mistakes &amp; quick tips</strong>
            <ul>
              <li><b>Mistake:</b> writing <span class="pill">S=S<sub>1</sub>+S<sub>2</sub></span> always. <b>Tip:</b> add <span class="pill">2Re{S<sub>12</sub>}</span>.</li>
              <li><b>Mistake:</b> letting cross-terms make the PSD negative. <b>Tip:</b> enforce <span class="pill">|γ|≤1</span> (then <span class="pill">1+Re{γ}</span> stays ≥0 if your model is physically consistent for equal powers).</li>
              <li><b>Mistake:</b> confusing “fringes” with “shift.” <b>Tip:</b> a shift changes the <i>envelope center</i>; fringes oscillate around the same center.</li>
            </ul>
          </div>
        </section>

        <section id="p3">
          <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

          <h3>Physical intuition (before math)</h3>
          <p>
            Adding two waves can do two things:
            (1) add power (always), and (2) interfere (only if correlated).
            Interference typically creates <b>frequency-dependent modulation</b> (ripples or fringes) on top of the underlying spectral envelope.
            A true Doppler shift moves the entire envelope in frequency.
            So we expect: the sum spectrum may get bigger and may get “wavy,” but its natural center should remain tied to the original center <span class="pill">ν<sub>0</sub></span>.
          </p>

          <h3>Step 1 — Expand the autocorrelation</h3>
          <p>Define the total field:</p>
          <div class="eqbox">
            <button class="copybtn" data-copy="U(t)=U1(t)+U2(t)">Copy</button>
            <pre class="eq">U(t) = U1(t) + U2(t)</pre>
          </div>

          <p>Define autocorrelation for a (wide-sense) stationary complex process:</p>
          <div class="eqbox">
            <button class="copybtn" data-copy="RUU(τ)=⟨U(t)U*(t+τ)⟩">Copy</button>
            <pre class="eq">R_UU(τ) = ⟨ U(t) U*(t+τ) ⟩</pre>
          </div>

          <p>Substitute the sum and expand (define each symbol as we go):</p>
          <div class="eqbox">
            <button class="copybtn" data-copy="RUU(τ)=R11(τ)+R22(τ)+R12(τ)+R21(τ), where Rij(τ)=⟨Ui(t)Uj*(t+τ)⟩">Copy</button>
            <pre class="eq">R_UU(τ)
= ⟨(U1(t)+U2(t)) (U1*(t+τ)+U2*(t+τ))⟩
= ⟨U1(t)U1*(t+τ)⟩ + ⟨U2(t)U2*(t+τ)⟩
  + ⟨U1(t)U2*(t+τ)⟩ + ⟨U2(t)U1*(t+τ)⟩

Define:
R_11(τ)=⟨U1(t)U1*(t+τ)⟩
R_22(τ)=⟨U2(t)U2*(t+τ)⟩
R_12(τ)=⟨U1(t)U2*(t+τ)⟩
R_21(τ)=⟨U2(t)U1*(t+τ)⟩

So:
R_UU(τ)=R_11(τ)+R_22(τ)+R_12(τ)+R_21(τ)</pre>
          </div>

          <p class="muted">
            What did we do? We used linearity of expectation. This is the precise way “interference” appears: in the cross-correlations.
          </p>

          <h3>Step 2 — Fourier transform to get the PSD</h3>
          <p>Wiener–Khinchin (for stationary processes):</p>
          <div class="eqbox">
            <button class="copybtn" data-copy="S(ν)=∫ RUU(τ) e^{-i2πντ} dτ">Copy</button>
            <pre class="eq">S(ν) = ∫_{-∞}^{∞} R_UU(τ) e^{-i 2π ν τ} dτ</pre>
          </div>

          <p>Apply it term-by-term (Fourier transform is linear). Define:</p>
          <ul>
            <li><span class="pill">S<sub>1</sub>(ν)=∫R<sub>11</sub>(τ)e^{-i2πντ}dτ</span></li>
            <li><span class="pill">S<sub>2</sub>(ν)=∫R<sub>22</sub>(τ)e^{-i2πντ}dτ</span></li>
            <li><span class="pill">S<sub>12</sub>(ν)=∫R<sub>12</sub>(τ)e^{-i2πντ}dτ</span></li>
            <li><span class="pill">S<sub>21</sub>(ν)=∫R<sub>21</sub>(τ)e^{-i2πντ}dτ</span></li>
          </ul>

          <p>Then:</p>
          <div class="eqbox">
            <button class="copybtn" data-copy="S(ν)=S1(ν)+S2(ν)+S12(ν)+S21(ν)">Copy</button>
            <pre class="eq">S(ν) = S1(ν) + S2(ν) + S12(ν) + S21(ν)</pre>
          </div>

          <p>
            For physically realizable cross-spectra, <span class="pill">S<sub>21</sub>(ν)=S<sub>12</sub>*(ν)</span> (the cross-spectrum matrix is Hermitian).
            Therefore,
          </p>

          <div class="eqbox">
            <button class="copybtn" data-copy="S(ν)=S1(ν)+S2(ν)+2Re{S12(ν)}">Copy</button>
            <pre class="eq">S(ν) = S1(ν) + S2(ν) + 2 Re{ S12(ν) }</pre>
          </div>

          <p class="muted">
            What did we do? We converted correlation structure into frequency-domain structure. The “extra” term is the frequency-resolved interference contribution.
          </p>

          <h3>Step 3 — Use the fact that the two auto-spectra are identical Gaussians</h3>
          <p>The problem states:</p>
          <div class="eqbox">
            <button class="copybtn" data-copy="S1(ν)=S2(ν)=SG(ν), a Gaussian centered at ν0 with width Δν">Copy</button>
            <pre class="eq">S1(ν) = S2(ν) = S_G(ν)</pre>
          </div>

          <p>
            We can write a Gaussian line shape (one convenient parameterization uses the standard deviation <span class="pill">σ</span>):
          </p>
          <div class="eqbox">
            <button class="copybtn" data-copy="SG(ν)=S0 exp(-(ν-ν0)^2/(2σ^2)), with Δν_FWHM=2√(2ln2) σ">Copy</button>
            <pre class="eq">S_G(ν) = S0 · exp( - (ν - ν0)^2 / (2 σ^2) )

Relation to FWHM:
Δν_FWHM = 2 √(2 ln 2) · σ</pre>
          </div>

          <p>Define the complex degree of spectral coherence:</p>
          <div class="eqbox">
            <button class="copybtn" data-copy="γ12(ν)=S12(ν)/sqrt(S1(ν)S2(ν))">Copy</button>
            <pre class="eq">γ12(ν) = S12(ν) / √( S1(ν) S2(ν) )</pre>
          </div>

          <p>Since <span class="pill">S1=S2=S_G</span>, we have <span class="pill">√(S1S2)=S_G</span>, so <span class="pill">S12(ν)=γ12(ν) S_G(ν)</span>. Plug into the PSD:</p>

          <div class="eqbox">
            <button class="copybtn" data-copy="S(ν)=2SG(ν)[1+Re{γ12(ν)}]">Copy</button>
            <pre class="eq">S(ν) = S_G(ν) + S_G(ν) + 2 Re{ γ12(ν) S_G(ν) }
     = 2 S_G(ν) [ 1 + Re{ γ12(ν) } ]</pre>
          </div>

          <div class="callout keyeq">
            <strong>Key equation (general answer)</strong>
            <p class="eq" style="margin:0;">S(ν) = 2 S_G(ν) [ 1 + Re{γ12(ν)} ]</p>
            <p class="muted">All correlation effects are captured by the real part of the spectral coherence γ12(ν).</p>
          </div>

          <h3>Step 4 — The coherence bound (what is mathematically/physically allowed)</h3>
          <p>
            From Cauchy–Schwarz applied to random processes (or equivalently, positive semidefiniteness of the spectral density matrix),
          </p>
          <div class="eqbox">
            <button class="copybtn" data-copy="|S12(ν)|^2 ≤ S1(ν)S2(ν)  ⇒  |γ12(ν)| ≤ 1">Copy</button>
            <pre class="eq">|S12(ν)|^2 ≤ S1(ν) S2(ν)
⇒ |γ12(ν)| ≤ 1</pre>
          </div>

          <p class="muted">
            Interpretation: you cannot “invent” more correlated structure at a frequency than the power available in each wave at that frequency.
          </p>

          <h3>Step 5 — Can S(ν) be a shifted Gaussian?</h3>
          <p>
            Suppose (hypothesis) that the resulting spectrum is also a Gaussian of the same width <span class="pill">σ</span> but centered at <span class="pill">ν1</span>:
          </p>
          <div class="eqbox">
            <button class="copybtn" data-copy="Assume S(ν)=A exp(-(ν-ν1)^2/(2σ^2))">Copy</button>
            <pre class="eq">Assume: S(ν) = A · exp( - (ν - ν1)^2 / (2 σ^2) )</pre>
          </div>

          <p>
            But we already know <span class="pill">S(ν)=2S0 exp(-(ν-ν0)^2/(2σ^2)) · [1+Re{γ12(ν)}]</span>.
            Divide the hypothesis by the known Gaussian envelope:
          </p>

          <div class="eqbox">
            <button class="copybtn" data-copy="1+Re{γ12(ν)} = (A/(2S0)) exp(((ν-ν0)^2-(ν-ν1)^2)/(2σ^2))">Copy</button>
            <pre class="eq">1 + Re{γ12(ν)}
= (A / (2 S0)) · exp( [ (ν-ν0)^2 - (ν-ν1)^2 ] / (2 σ^2) )</pre>
          </div>

          <p>Now expand the exponent carefully:</p>
          <ul>
            <li><span class="pill">(ν-ν0)^2 = ν^2 - 2νν0 + ν0^2</span></li>
            <li><span class="pill">(ν-ν1)^2 = ν^2 - 2νν1 + ν1^2</span></li>
          </ul>
          <p>Subtracting gives:</p>
          <div class="eqbox">
            <button class="copybtn" data-copy="(ν-ν0)^2-(ν-ν1)^2 = 2ν(ν1-ν0) + (ν0^2-ν1^2)">Copy</button>
            <pre class="eq">(ν-ν0)^2 - (ν-ν1)^2
= (ν^2 - 2νν0 + ν0^2) - (ν^2 - 2νν1 + ν1^2)
= 2ν(ν1 - ν0) + (ν0^2 - ν1^2)</pre>
          </div>

          <p>Therefore the required functional form is:</p>
          <div class="eqbox">
            <button class="copybtn" data-copy="1+Re{γ12(ν)} = C exp(κ ν), where κ=(ν1-ν0)/σ^2 and C=(A/(2S0)) exp((ν0^2-ν1^2)/(2σ^2))">Copy</button>
            <pre class="eq">1 + Re{γ12(ν)} = C · exp( κ ν )

where:
κ = (ν1 - ν0) / σ^2
C = (A / (2 S0)) · exp( (ν0^2 - ν1^2) / (2 σ^2) )</pre>
          </div>

          <p>
            Here is the decisive point: <span class="pill">Re{γ12(ν)}</span> must satisfy <span class="pill">-1 ≤ Re{γ12(ν)} ≤ 1</span>, because <span class="pill">|γ12(ν)|≤1</span>.
            But <span class="pill">C·exp(κν)</span> grows (or decays) exponentially with ν unless <span class="pill">κ=0</span>.
            Over any sufficiently wide frequency range, an exponential cannot remain within a fixed bounded interval.
          </p>

          <div class="callout final">
            <strong>Final answer (core conclusion)</strong>
            <div class="eqbox" style="margin:10px 0 6px;">
              <button class="copybtn" data-copy="S(ν)=S1(ν)+S2(ν)+2Re{S12(ν)}. With S1=S2=SG: S(ν)=2SG(ν)[1+Re{γ12(ν)}], |γ12(ν)|≤1. A purely shifted Gaussian center ν1≠ν0 cannot arise from superposition/correlation alone (except the trivial ν1=ν0).">Copy</button>
              <pre class="eq">S(ν)=S1(ν)+S2(ν)+2Re{S12(ν)}.

If S1(ν)=S2(ν)=S_G(ν) (Gaussian centered at ν0):
S(ν)=2 S_G(ν) [1+Re{γ12(ν)}],  where γ12(ν)=S12(ν)/S_G(ν) and |γ12(ν)|≤1.

A spectrum that is exactly Gaussian with a shifted center ν1≠ν0 would require
1+Re{γ12(ν)} ∝ exp(κν),
which cannot satisfy the bound |γ12(ν)|≤1 over a bandwidth unless κ=0 ⇒ ν1=ν0.
So: correlation can modulate/distort the line, but it cannot create a clean false Doppler shift.</pre>
            </div>
          </div>

          <h3>Sanity checks</h3>
          <ul>
            <li><b>Units:</b> <span class="pill">S</span>, <span class="pill">S1</span>, <span class="pill">S2</span>, <span class="pill">S12</span> all have units |U|²/Hz; <span class="pill">γ12</span> is dimensionless.</li>
            <li><b>Uncorrelated case:</b> <span class="pill">γ12=0</span> ⇒ <span class="pill">S=2S_G</span> (power adds).</li>
            <li><b>Perfect coherence, identical waves:</b> <span class="pill">γ12=1</span> ⇒ <span class="pill">S=4S_G</span> (field doubles, power ×4).</li>
            <li><b>Anti-phase coherence:</b> <span class="pill">γ12=-1</span> ⇒ <span class="pill">S=0</span> (complete cancellation, idealized).</li>
          </ul>

          <h3>Connecting to the diagram and plots</h3>
          <p>
            The diagram shows two waves combining at a linear combiner and being measured by a detector/spectrum analyzer.
            The plots visualize how <span class="pill">Re{γ12(ν)}</span> (set by coherence, delay, and phase) modulates the shared Gaussian envelope.
            You will see fringes/ripples appear as you introduce a delay — but the envelope stays centered at <span class="pill">ν0</span>.
          </p>
        </section>

        <section id="p4">
          <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

          <h3>Re-interpreting the final formula</h3>
          <p>
            With identical auto-spectra,
            <span class="pill">S(ν)=2S_G(ν)[1+Re{γ12(ν)}]</span>.
            Think of it as:
          </p>
          <ul>
            <li><b>Envelope:</b> <span class="pill">2S_G(ν)</span> sets the overall line shape scale and center <span class="pill">ν0</span>.</li>
            <li><b>Interference factor:</b> <span class="pill">1+Re{γ12(ν)}</span> reshapes the spectrum but is <b>bounded</b>.</li>
          </ul>

          <h3>Parameter effects (match the interactive plots)</h3>
          <ul>
            <li><b>Coherence magnitude μ:</b> If you model <span class="pill">γ12(ν)=μ e^{i(phase)}</span>, then larger μ makes stronger modulation; μ→0 removes fringes.</li>
            <li><b>Delay τ:</b> A relative time delay produces a frequency-dependent phase <span class="pill">~2πντ</span>, creating oscillations versus ν (spectral fringes). Larger |τ| → faster fringes.</li>
            <li><b>Constant phase φ:</b> Shifts the fringe pattern left/right in frequency but still does not translate the Gaussian envelope.</li>
          </ul>

          <h3>An alternative derivation idea (brief)</h3>
          <p>
            Work directly in the frequency domain: let <span class="pill">U(ν)=U1(ν)+U2(ν)</span>.
            Then
            <span class="pill">S(ν)=⟨|U(ν)|²⟩=⟨|U1|²⟩+⟨|U2|²⟩+⟨U1U2*⟩+⟨U2U1*⟩</span>,
            which is the same result with <span class="pill">S12(ν)=⟨U1(ν)U2*(ν)⟩</span>.
          </p>

          <h3>Concept checks (with answers)</h3>
          <ul>
            <li><b>Q:</b> If two sources are uncorrelated, what happens to the cross term? <b>A:</b> It averages to zero, so <span class="pill">S= S1+S2</span>.</li>
            <li><b>Q:</b> Can interference ever “move” energy from one frequency to another? <b>A:</b> Not for linear superposition of stationary signals with fixed component spectra; it modulates via cross-terms but does not create a clean translation of the Gaussian center.</li>
            <li><b>Q:</b> What mathematical fact blocks a fake Doppler shift? <b>A:</b> The bound <span class="pill">|γ12(ν)|≤1</span> (from Cauchy–Schwarz) forbids the unbounded exponential dependence required for a pure shifted Gaussian.</li>
            <li><b>Q:</b> What does a time delay do in the spectrum? <b>A:</b> It adds a linear phase vs frequency, producing oscillatory <span class="pill">Re{γ}</span> and hence spectral fringes.</li>
          </ul>
        </section>

        <section id="p5">
          <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

          <div class="vizgrid">
            <div class="vizcard">
              <div class="viztitle">
                <h3>Diagram (setup)</h3>
                <span class="pill">canvas</span>
              </div>
              <canvas id="cDiagram" aria-label="Diagram canvas"></canvas>
              <p class="muted" style="margin-top:8px;">
                Two waves combine linearly. A detector/spectrum analyzer measures the PSD of the sum. Delay τ and phase φ control correlation in the cross-term.
              </p>
            </div>

            <div class="vizcard small">
              <div class="viztitle">
                <h3>Secondary plot: spectral centroid vs delay (parameter sweep)</h3>
                <span class="pill">τ-sweep</span>
              </div>
              <canvas id="cSweep" aria-label="Sweep canvas"></canvas>
              <p class="muted" style="margin-top:8px;">
                This plot computes the <b>spectral centroid</b> (first moment) over the displayed frequency window as τ varies.
                You may see small oscillations due to finite-window fringes, but not a stable “Gaussian center shift.”
              </p>
            </div>
          </div>

          <div class="vizcard" style="margin-top:12px;">
            <div class="viztitle">
              <h3>Main plot: PSD of the superposition and the coherence factor</h3>
              <span class="pill">S(ν)</span>
            </div>
            <canvas id="cMain" aria-label="Main plot canvas"></canvas>

            <div class="controls" aria-label="Interactive controls">
              <div class="control">
                <label>
                  Coherence magnitude <span class="pill">μ</span> (0 = uncorrelated, 1 = fully coherent)
                  <span class="pill" id="muVal">0.70</span>
                </label>
                <input id="mu" type="range" min="0" max="1" step="0.01" value="0.70"/>
              </div>

              <div class="control">
                <label>
                  Relative delay <span class="pill">τ</span> (fs)
                  <span class="pill" id="tauVal">25.0</span>
                </label>
                <input id="tau" type="range" min="-80" max="80" step="0.5" value="25"/>
              </div>

              <div class="control">
                <label>
                  Constant phase <span class="pill">φ</span> (rad)
                  <span class="pill" id="phiVal">0.00</span>
                </label>
                <input id="phi" type="range" min="-3.1416" max="3.1416" step="0.01" value="0"/>
              </div>

              <div class="control">
                <label>
                  Display option
                  <span class="pill">overlay</span>
                </label>
                <select id="mode">
                  <option value="psd">PSD only</option>
                  <option value="both" selected>PSD + Re{γ12(ν)} (scaled)</option>
                  <option value="compare">Compare: uncorrelated vs correlated</option>
                </select>
              </div>
            </div>

            <div class="callout assumptions" style="margin-top:12px;">
              <strong>Model used for plots (example, for visualization only)</strong>
              <p class="muted">
                We use <span class="pill">S1=S2=S_G</span> with a Gaussian line centered at <span class="pill">ν0</span>.
                We model the spectral coherence as <span class="pill">γ12(ν)=μ · exp(i(2πντ + φ))</span>, so
                <span class="pill">Re{γ12(ν)} = μ cos(2πντ + φ)</span>.
                This produces realistic spectral fringes while respecting <span class="pill">|γ|≤1</span>.
              </p>
            </div>
          </div>

          <h3>What should change when you move the sliders?</h3>
          <ul>
            <li><b>Increase μ:</b> fringes deepen (cross-term stronger). At μ=0, the spectrum is just <span class="pill">2S_G</span>.</li>
            <li><b>Increase |τ|:</b> fringes become more rapid versus frequency (since delay adds phase that grows with ν).</li>
            <li><b>Change φ:</b> shifts where maxima/minima occur in the fringes, without moving the envelope center <span class="pill">ν0</span>.</li>
            <li><b>Sweep plot:</b> centroid may wiggle slightly due to the finite plotted window, but it does not settle into a new constant center like a Doppler shift would.</li>
          </ul>
        </section>

        <footer>
          Built as a self-contained learning article (vanilla HTML/CSS/JS). Copy buttons grab plain-text equations.
        </footer>
      </article>
    </div>
  </main>

  <script>
    // ---------- Copy buttons ----------
    (function(){
      function copyText(t){
        if(navigator.clipboard && navigator.clipboard.writeText){
          navigator.clipboard.writeText(t).catch(()=>fallbackCopy(t));
        } else fallbackCopy(t);
      }
      function fallbackCopy(t){
        const ta=document.createElement('textarea');
        ta.value=t;
        ta.style.position='fixed';
        ta.style.left='-9999px';
        ta.style.top='-9999px';
        document.body.appendChild(ta);
        ta.select();
        try{ document.execCommand('copy'); }catch(e){}
        document.body.removeChild(ta);
      }
      document.addEventListener('click', (e)=>{
        const b=e.target.closest('.copybtn');
        if(!b) return;
        const t=b.getAttribute('data-copy') || '';
        copyText(t);
        const old=b.textContent;
        b.textContent='Copied ✓';
        setTimeout(()=>b.textContent=old, 900);
      });
    })();

    // ---------- Canvas utilities ----------
    function setupHiDPI(canvas){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect.width * dpr));
      const h = Math.max(2, Math.floor(rect.height * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {ctx, w: rect.width, h: rect.height, dpr};
    }

    function lerp(a,b,t){ return a+(b-a)*t; }
    function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

    // ---------- Plotting primitives ----------
    function drawAxes(ctx, box, xLabel, yLabel, title){
      const {x,y,w,h} = box;
      // background already in canvas
      // title
      ctx.save();
      ctx.fillStyle = "rgba(233,236,255,0.92)";
      ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(title, x+8, y+18);

      // axes
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x+48, y+h-34);
      ctx.lineTo(x+w-14, y+h-34);
      ctx.moveTo(x+48, y+18);
      ctx.lineTo(x+48, y+h-34);
      ctx.stroke();

      // labels
      ctx.fillStyle = "rgba(184,192,255,0.85)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(xLabel, x+w-14-ctx.measureText(xLabel).width, y+h-12);

      // y label (rotated)
      ctx.save();
      ctx.translate(x+14, y+22 + (h-56)/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();

      ctx.restore();
    }

    function drawGridAndTicks(ctx, box, xMin,xMax,yMin,yMax, xTicks, yTicks){
      const {x,y,w,h} = box;
      const x0 = x+48, x1 = x+w-14;
      const y0 = y+18, y1 = y+h-34;

      ctx.save();
      ctx.lineWidth = 1;

      // grid
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      for(let i=0;i<=xTicks;i++){
        const t=i/xTicks;
        const X=lerp(x0,x1,t);
        ctx.beginPath(); ctx.moveTo(X,y0); ctx.lineTo(X,y1); ctx.stroke();
      }
      for(let j=0;j<=yTicks;j++){
        const t=j/yTicks;
        const Y=lerp(y1,y0,t);
        ctx.beginPath(); ctx.moveTo(x0,Y); ctx.lineTo(x1,Y); ctx.stroke();
      }

      // ticks and numbers
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.fillStyle = "rgba(184,192,255,0.85)";
      ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";

      for(let i=0;i<=xTicks;i++){
        const t=i/xTicks;
        const X=lerp(x0,x1,t);
        ctx.beginPath(); ctx.moveTo(X,y1); ctx.lineTo(X,y1+5); ctx.stroke();
        const val=lerp(xMin,xMax,t);
        const s = formatTick(val);
        ctx.fillText(s, X-ctx.measureText(s).width/2, y1+18);
      }
      for(let j=0;j<=yTicks;j++){
        const t=j/yTicks;
        const Y=lerp(y1,y0,t);
        ctx.beginPath(); ctx.moveTo(x0-5,Y); ctx.lineTo(x0,Y); ctx.stroke();
        const val=lerp(yMin,yMax,t);
        const s = formatTick(val);
        ctx.fillText(s, x0-10-ctx.measureText(s).width, Y+4);
      }

      ctx.restore();
    }

    function formatTick(v){
      const av=Math.abs(v);
      if(av>=1000) return (v/1000).toFixed(2)+"k";
      if(av>=10) return v.toFixed(2);
      if(av>=1) return v.toFixed(3);
      return v.toFixed(4);
    }

    function toCanvasX(box, t){
      const x0=box.x+48, x1=box.x+box.w-14;
      return lerp(x0,x1,t);
    }
    function toCanvasY(box, t){
      const y0=box.y+18, y1=box.y+box.h-34;
      return lerp(y1,y0,t);
    }

    function polyline(ctx, box, xs, ys, xMin,xMax,yMin,yMax, strokeStyle, lineWidth){
      const x0 = box.x+48, x1 = box.x+box.w-14;
      const y0 = box.y+18, y1 = box.y+box.h-34;
      const n = Math.min(xs.length, ys.length);
      ctx.save();
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = lineWidth;
      ctx.beginPath();
      for(let i=0;i<n;i++){
        const tx=(xs[i]-xMin)/(xMax-xMin);
        const ty=(ys[i]-yMin)/(yMax-yMin);
        const X=lerp(x0,x1,tx);
        const Y=lerp(y1,y0,ty);
        if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawLegend(ctx, box, items){
      // items: [{label, color}]
      const pad=10;
      let x=box.x+58, y=box.y+28;
      ctx.save();
      ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      for(const it of items){
        ctx.fillStyle=it.color;
        ctx.fillRect(x, y-9, 16, 4);
        ctx.fillStyle="rgba(233,236,255,0.92)";
        ctx.fillText(it.label, x+22, y-6+10);
        y += 18;
      }
      ctx.restore();
    }

    // ---------- Physics model for plots ----------
    // Example values (for visualization only):
    // ν0 = 500 THz, FWHM Δν = 5 THz
    const example = {
      nu0_THz: 500,
      dnuFWHM_THz: 5
    };

    function sigmaFromFWHM(fwhm){
      return fwhm / (2*Math.sqrt(2*Math.log(2)));
    }

    function gaussian(nu, nu0, sigma){
      const z=(nu-nu0)/sigma;
      return Math.exp(-0.5*z*z);
    }

    // coherence model: γ12(ν)=μ exp(i(2πντ + φ)), so Re{γ}=μ cos(2πντ+φ)
    function reGamma(nu_Hz, mu, tau_s, phi){
      return mu * Math.cos(2*Math.PI*nu_Hz*tau_s + phi);
    }

    // PSD result for equal spectra:
    // S(ν)=2 SG(ν) [1 + Re{γ12(ν)}]
    function PSD(nu_THz, params){
      const nu0 = params.nu0_THz;
      const sigma = params.sigma_THz;
      const SG = gaussian(nu_THz, nu0, sigma); // normalized
      const nu_Hz = nu_THz * 1e12;
      const rg = reGamma(nu_Hz, params.mu, params.tau_fs*1e-15, params.phi);
      const S = 2*SG*(1 + rg);
      return Math.max(0, S); // guard against tiny numerical negatives at mu=1
    }

    function SGOnly(nu_THz, params){
      const SG = gaussian(nu_THz, params.nu0_THz, params.sigma_THz);
      return 2*SG;
    }

    function centroid(nus_THz, Svals){
      let num=0, den=0;
      for(let i=0;i<nus_THz.length;i++){
        const s=Svals[i];
        num += nus_THz[i]*s;
        den += s;
      }
      return den>0 ? num/den : NaN;
    }

    // ---------- Rendering ----------
    const cDiagram = document.getElementById('cDiagram');
    const cMain = document.getElementById('cMain');
    const cSweep = document.getElementById('cSweep');

    const muEl = document.getElementById('mu');
    const tauEl = document.getElementById('tau');
    const phiEl = document.getElementById('phi');
    const modeEl = document.getElementById('mode');
    const muVal = document.getElementById('muVal');
    const tauVal = document.getElementById('tauVal');
    const phiVal = document.getElementById('phiVal');

    function getParams(){
      return {
        nu0_THz: example.nu0_THz,
        dnuFWHM_THz: example.dnuFWHM_THz,
        sigma_THz: sigmaFromFWHM(example.dnuFWHM_THz),
        mu: parseFloat(muEl.value),
        tau_fs: parseFloat(tauEl.value),
        phi: parseFloat(phiEl.value)
      };
    }

    function drawDiagram(){
      const {ctx, w, h} = setupHiDPI(cDiagram);
      ctx.clearRect(0,0,w,h);

      // soft background gradient
      const g = ctx.createLinearGradient(0,0,w,h);
      g.addColorStop(0, "rgba(123,220,255,0.08)");
      g.addColorStop(1, "rgba(167,255,131,0.06)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);

      const pad=16;
      const cx=w*0.52, cy=h*0.52;

      // draw two inputs
      function arrow(x1,y1,x2,y2, col){
        ctx.save();
        ctx.strokeStyle = col;
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
        const ang=Math.atan2(y2-y1, x2-x1);
        const L=10;
        ctx.beginPath();
        ctx.moveTo(x2,y2);
        ctx.lineTo(x2-L*Math.cos(ang-Math.PI/7), y2-L*Math.sin(ang-Math.PI/7));
        ctx.lineTo(x2-L*Math.cos(ang+Math.PI/7), y2-L*Math.sin(ang+Math.PI/7));
        ctx.closePath();
        ctx.fillStyle=col;
        ctx.fill();
        ctx.restore();
      }

      // combiner block
      const bx=cx-45, by=cy-35, bw=90, bh=70;
      ctx.save();
      ctx.fillStyle="rgba(17,26,51,0.68)";
      ctx.strokeStyle="rgba(255,255,255,0.16)";
      ctx.lineWidth=1.2;
      roundRect(ctx, bx, by, bw, bh, 14);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle="rgba(233,236,255,0.92)";
      ctx.font="600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Linear", bx+20, by+30);
      ctx.fillText("sum", bx+30, by+50);
      ctx.restore();

      // input arrows
      arrow(pad+10, cy-70, bx, cy-25, "rgba(123,220,255,0.95)");
      arrow(pad+10, cy+70, bx, cy+25, "rgba(167,255,131,0.95)");

      // output arrow
      arrow(bx+bw, cy, w-pad-120, cy, "rgba(233,236,255,0.92)");

      // detector/analyzer
      const dx=w-pad-115, dy=cy-42, dw=100, dh=84;
      ctx.save();
      ctx.fillStyle="rgba(17,26,51,0.55)";
      ctx.strokeStyle="rgba(255,255,255,0.16)";
      ctx.lineWidth=1.2;
      roundRect(ctx, dx, dy, dw, dh, 14);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle="rgba(233,236,255,0.92)";
      ctx.font="600 12.5px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Detector /", dx+10, dy+28);
      ctx.fillText("Spectrum", dx+16, dy+48);
      ctx.fillText("Analyzer", dx+18, dy+68);
      ctx.restore();

      // labels
      ctx.save();
      ctx.fillStyle="rgba(233,236,255,0.92)";
      ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
      ctx.fillText("U1(t)  (Gaussian PSD)", pad+10, cy-84);
      ctx.fillText("U2(t)  (Gaussian PSD)", pad+10, cy+56);
      ctx.fillText("U(t)=U1+U2", bx+bw+12, cy-8);
      ctx.fillStyle="rgba(184,192,255,0.85)";
      ctx.fillText("Correlation enters via S12(ν)", bx-6, by-10);
      ctx.restore();

      // annotate delay/phase on lower path
      const params=getParams();
      ctx.save();
      ctx.fillStyle="rgba(184,192,255,0.92)";
      ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("delay τ, phase φ", pad+40, cy+90);
      ctx.fillStyle="rgba(184,192,255,0.75)";
      ctx.fillText(`τ = ${params.tau_fs.toFixed(1)} fs,  φ = ${params.phi.toFixed(2)} rad`, pad+40, cy+110);
      ctx.restore();
    }

    function roundRect(ctx,x,y,w,h,r){
      const rr=Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    function drawMain(){
      const {ctx, w, h} = setupHiDPI(cMain);
      ctx.clearRect(0,0,w,h);

      const params=getParams();
      const mode=modeEl.value;

      // plot box
      const box={x:10,y:10,w:w-20,h:h-20};
      drawAxes(ctx, box, "Frequency offset (THz) relative to ν0", "Normalized PSD (arb.)", "PSD of U(t)=U1(t)+U2(t)");

      // frequency grid around nu0
      const nu0=params.nu0_THz;
      const sigma=params.sigma_THz;
      const span = 6*params.dnuFWHM_THz; // show +-3 FWHM
      const nuMin = nu0 - span/2;
      const nuMax = nu0 + span/2;

      const N=900;
      const nus=new Array(N);
      const S=new Array(N);
      const Sunc=new Array(N);
      const rgArr=new Array(N);

      let Smax=0;
      for(let i=0;i<N;i++){
        const nu=lerp(nuMin, nuMax, i/(N-1));
        nus[i]=nu;
        const val=PSD(nu, params);
        const u=SGOnly(nu, params);
        const rg = reGamma(nu*1e12, params.mu, params.tau_fs*1e-15, params.phi);
        S[i]=val; Sunc[i]=u; rgArr[i]=rg;
        Smax=Math.max(Smax, val, u);
      }

      // y range
      const yMin=0;
      const yMax= Math.max(1.05, 1.08*Smax);

      // x axis in offset THz
      const xMin = -span/2;
      const xMax = span/2;

      // grid + ticks
      drawGridAndTicks(ctx, box, xMin,xMax, yMin,yMax, 6, 5);

      // convert nus to offsets
      const xOffsets = nus.map(nu => nu-nu0);

      // plot lines
      if(mode === "compare"){
        polyline(ctx, box, xOffsets, Sunc, xMin,xMax, yMin,yMax, "rgba(233,236,255,0.80)", 2.2);
        polyline(ctx, box, xOffsets, S,    xMin,xMax, yMin,yMax, "rgba(123,220,255,0.95)", 2.2);
        drawLegend(ctx, box, [
          {label:"Uncorrelated (μ=0): 2 S_G(ν)", color:"rgba(233,236,255,0.80)"},
          {label:"Correlated: 2 S_G(ν)[1+Re{γ}]", color:"rgba(123,220,255,0.95)"}
        ]);
      } else {
        polyline(ctx, box, xOffsets, S, xMin,xMax, yMin,yMax, "rgba(123,220,255,0.95)", 2.2);
        const items=[{label:"S(ν) of the sum", color:"rgba(123,220,255,0.95)"}];

        if(mode === "both"){
          // scale Re{γ} into visible range: map [-1,1] -> [0, yMax] times 0.45
          const rgScaled = rgArr.map(rg => (0.45*yMax)*(rg+1)/2);
          polyline(ctx, box, xOffsets, rgScaled, xMin,xMax, yMin,yMax, "rgba(167,255,131,0.90)", 1.8);
          items.push({label:"Scaled Re{γ12(ν)} (shape guide)", color:"rgba(167,255,131,0.90)"});
        }
        drawLegend(ctx, box, items);
      }

      // mark ν0 at offset 0
      ctx.save();
      const x0=toCanvasX(box, (0-xMin)/(xMax-xMin));
      const y0=box.y+18, y1=box.y+box.h-34;
      ctx.strokeStyle="rgba(255,255,255,0.18)";
      ctx.setLineDash([5,6]);
      ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x0,y1); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle="rgba(184,192,255,0.85)";
      ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("ν0", x0+6, y0+16);
      ctx.restore();

      // show computed centroid (within window)
      const nuCent = centroid(nus, S);
      const offCent = nuCent - nu0;
      ctx.save();
      const xc=toCanvasX(box, (offCent-xMin)/(xMax-xMin));
      ctx.strokeStyle="rgba(255,211,107,0.85)";
      ctx.setLineDash([3,5]);
      ctx.beginPath(); ctx.moveTo(xc,y0); ctx.lineTo(xc,y1); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle="rgba(255,211,107,0.92)";
      ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("centroid", xc+6, y0+34);
      ctx.fillText(`${offCent.toFixed(3)} THz`, xc+6, y0+50);
      ctx.restore();

      // annotation box
      ctx.save();
      ctx.fillStyle="rgba(0,0,0,0.25)";
      ctx.strokeStyle="rgba(255,255,255,0.12)";
      roundRect(ctx, box.x+58, box.y+box.h-78, 320, 60, 14);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle="rgba(233,236,255,0.92)";
      ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
      const eq1="S(ν)=2 S_G(ν) [1+Re{γ12(ν)}]";
      const eq2=`Re{γ12}= μ cos(2πντ + φ),   μ=${params.mu.toFixed(2)}, τ=${params.tau_fs.toFixed(1)} fs`;
      ctx.fillText(eq1, box.x+70, box.y+box.h-54);
      ctx.fillStyle="rgba(184,192,255,0.85)";
      ctx.fillText(eq2, box.x+70, box.y+box.h-34);
      ctx.restore();
    }

    function drawSweep(){
      const {ctx, w, h} = setupHiDPI(cSweep);
      ctx.clearRect(0,0,w,h);

      const params=getParams();

      const box={x:10,y:10,w:w-20,h:h-20};
      drawAxes(ctx, box, "Delay τ (fs)", "Centroid offset (THz)", "Centroid vs delay (finite window)");

      // frequency window same as main
      const nu0=params.nu0_THz;
      const span = 6*params.dnuFWHM_THz;
      const nuMin = nu0 - span/2;
      const nuMax = nu0 + span/2;

      // prepare frequency grid once
      const Nnu=600;
      const nus=new Array(Nnu);
      for(let i=0;i<Nnu;i++){
        nus[i]=lerp(nuMin,nuMax, i/(Nnu-1));
      }

      // sweep taus
      const tauMin=-80, tauMax=80;
      const Nt=321;
      const taus=new Array(Nt);
      const cents=new Array(Nt);

      let yAbsMax=0;
      for(let k=0;k<Nt;k++){
        const tau=lerp(tauMin,tauMax, k/(Nt-1));
        taus[k]=tau;
        const local={...params, tau_fs:tau};
        const Svals=nus.map(nu=>PSD(nu, local));
        const c=centroid(nus,Svals);
        const off=c-nu0;
        cents[k]=off;
        yAbsMax=Math.max(yAbsMax, Math.abs(off));
      }

      const yMax = Math.max(0.015, 1.2*yAbsMax);
      const yMin = -yMax;

      drawGridAndTicks(ctx, box, tauMin,tauMax, yMin,yMax, 6, 5);

      // plot line
      polyline(ctx, box, taus, cents, tauMin,tauMax, yMin,yMax, "rgba(255,211,107,0.90)", 2.1);
      drawLegend(ctx, box, [{label:"Centroid offset Δνc(τ) over plotted window", color:"rgba(255,211,107,0.90)"}]);

      // zero line
      ctx.save();
      const y0=toCanvasY(box, (0-yMin)/(yMax-yMin));
      const x0=box.x+48, x1=box.x+box.w-14;
      ctx.strokeStyle="rgba(255,255,255,0.18)";
      ctx.setLineDash([5,6]);
      ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y0); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle="rgba(184,192,255,0.85)";
      ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("0", x0-18, y0-6);
      ctx.restore();

      // current tau marker
      ctx.save();
      const tNow=params.tau_fs;
      const xNow=toCanvasX(box, (tNow-tauMin)/(tauMax-tauMin));
      const yTop=box.y+18, yBot=box.y+box.h-34;
      ctx.strokeStyle="rgba(123,220,255,0.85)";
      ctx.setLineDash([3,5]);
      ctx.beginPath(); ctx.moveTo(xNow,yTop); ctx.lineTo(xNow,yBot); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle="rgba(123,220,255,0.92)";
      ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("current τ", xNow+6, yTop+18);
      ctx.restore();

      // note
      ctx.save();
      ctx.fillStyle="rgba(0,0,0,0.22)";
      ctx.strokeStyle="rgba(255,255,255,0.12)";
      roundRect(ctx, box.x+58, box.y+box.h-64, 360, 46, 14);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle="rgba(184,192,255,0.85)";
      ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Centroid wiggles come from fringes + finite plotting window,", box.x+70, box.y+box.h-40);
      ctx.fillText("not from an actual Gaussian envelope shift (Doppler-like).", box.x+70, box.y+box.h-22);
      ctx.restore();
    }

    function renderAll(){
      const params=getParams();
      muVal.textContent = params.mu.toFixed(2);
      tauVal.textContent = params.tau_fs.toFixed(1);
      phiVal.textContent = params.phi.toFixed(2);
      drawDiagram();
      drawMain();
      drawSweep();
    }

    // listeners
    [muEl, tauEl, phiEl, modeEl].forEach(el => {
      el.addEventListener('input', renderAll);
      el.addEventListener('change', renderAll);
    });

    // resize handling
    let resizeTimer=null;
    window.addEventListener('resize', ()=>{
      clearTimeout(resizeTimer);
      resizeTimer=setTimeout(renderAll, 80);
    });

    renderAll();
  </script>
</body>
</html>
