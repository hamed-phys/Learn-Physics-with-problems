<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Light from a Two-Point Incoherent Source — Normalized Mutual Intensity (Fraunhofer)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --ink:#e9ecff;
      --muted:#b8c0ffcc;
      --line:#2a3a77;
      --accent:#7aa2ff;
      --accent2:#7dffcf;
      --warn:#ffd27a;
      --ok:#87ffb5;
      --shadow: 0 16px 40px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    *{ box-sizing:border-box; }
    html{ scroll-behavior:smooth; }
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--ink);
      background:
        radial-gradient(1200px 900px at 20% 5%, rgba(122,162,255,.18), transparent 60%),
        radial-gradient(1000px 900px at 85% 10%, rgba(125,255,207,.12), transparent 55%),
        radial-gradient(900px 700px at 40% 100%, rgba(255,210,122,.10), transparent 60%),
        var(--bg);
      line-height:1.55;
    }

    header{
      padding: 36px 18px 18px;
      max-width: 1200px;
      margin: 0 auto;
    }
    header .title{
      display:grid;
      grid-template-columns: 1.3fr .7fr;
      gap:18px;
      align-items:end;
    }
    h1{
      margin:0;
      font-weight:800;
      letter-spacing:-0.02em;
      font-size: clamp(26px, 3vw, 40px);
    }
    .subtitle{
      margin-top:8px;
      color:var(--muted);
      max-width: 70ch;
      font-size: 1.02rem;
    }
    .meta{
      justify-self:end;
      text-align:right;
      color:var(--muted);
      font-size:.95rem;
      padding:12px 14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(17,26,51,.45);
      border-radius: 14px;
      box-shadow: var(--shadow);
    }

    main{
      max-width:1200px;
      margin: 0 auto;
      padding: 0 18px 60px;
      display:grid;
      grid-template-columns: 280px 1fr;
      gap:18px;
      align-items:start;
    }

    nav#toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: rgba(17,26,51,.55);
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      padding: 14px 14px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    #toc h2{
      margin:0 0 10px;
      font-size: 1.02rem;
      letter-spacing:.02em;
      color: #dfe6ff;
    }
    #toc a{
      display:block;
      color: var(--muted);
      text-decoration:none;
      padding: 7px 8px;
      border-radius: 12px;
      transition: transform .15s ease, background .15s ease, color .15s ease;
      font-size:.95rem;
      border:1px solid transparent;
    }
    #toc a:hover{
      background: rgba(122,162,255,.10);
      border-color: rgba(122,162,255,.25);
      color: #e9ecff;
      transform: translateX(2px);
    }

    article{
      background: rgba(17,26,51,.40);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    section{
      padding: 10px 0 2px;
      border-top: 1px solid rgba(255,255,255,.08);
      margin-top: 14px;
    }
    section:first-of-type{
      border-top:none;
      margin-top:0;
      padding-top:0;
    }
    h2{
      margin: 6px 0 8px;
      font-size: 1.35rem;
      letter-spacing:-0.01em;
    }
    h3{
      margin: 12px 0 8px;
      font-size: 1.08rem;
      color:#dfe6ff;
    }
    p{ margin: 8px 0; color: #eef1ff; }
    ul{ margin: 8px 0 10px 20px; color:#eef1ff; }
    li{ margin: 6px 0; }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
    }

    .callout{
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 12px 12px 10px;
      background: rgba(8,12,25,.35);
      box-shadow: 0 12px 26px rgba(0,0,0,.25);
    }
    .callout strong{ color:#ffffff; }
    .callout.assumptions{ border-color: rgba(125,255,207,.25); }
    .callout.keyeq{ border-color: rgba(122,162,255,.25); }
    .callout.mistakes{ border-color: rgba(255,210,122,.25); }
    .callout.final{ border-color: rgba(135,255,181,.30); }

    .eq{
      font-family: var(--mono);
      font-size: .98rem;
      padding: 10px 10px;
      background: rgba(0,0,0,.30);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      overflow:auto;
      position:relative;
    }
    .eq .label{
      display:inline-block;
      font-family: var(--sans);
      font-size:.85rem;
      color: var(--muted);
      margin-bottom:6px;
    }
    .copyBtn{
      position:absolute;
      top: 10px;
      right: 10px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(122,162,255,.10);
      color: #e9ecff;
      border-radius: 12px;
      padding: 6px 10px;
      cursor:pointer;
      font-size:.85rem;
      transition: transform .12s ease, background .12s ease;
      user-select:none;
    }
    .copyBtn:hover{ transform: translateY(-1px); background: rgba(122,162,255,.16); }
    .copyBtn:active{ transform: translateY(0px) scale(.98); }

    .vizCard{
      margin-top: 12px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(8,12,25,.32);
      padding: 12px;
      box-shadow: 0 14px 30px rgba(0,0,0,.28);
    }
    .vizHeader{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 8px;
    }
    .vizHeader h3{ margin:0; }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin-top: 8px;
    }
    .control{
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 10px 10px 8px;
      background: rgba(17,26,51,.35);
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:.9rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    input[type="range"]{ width:100%; }
    .readout{
      font-family: var(--mono);
      color: #e9ecff;
      font-size:.9rem;
      white-space:nowrap;
    }

    .canvasWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    canvas{
      width:100%;
      height: 320px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }
    .small canvas{ height: 260px; }

    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 18px;
      color: var(--muted);
      font-size: .95rem;
      opacity:.95;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(17,26,51,.35);
      color: var(--muted);
      font-size: .9rem;
    }
    .dot{
      width:10px; height:10px; border-radius:99px;
      background: var(--accent);
      box-shadow: 0 0 18px rgba(122,162,255,.5);
    }

    @media (max-width: 980px){
      header .title{ grid-template-columns: 1fr; }
      .meta{ justify-self:start; text-align:left; }
      main{ grid-template-columns: 1fr; }
      nav#toc{ position:relative; top:auto; }
      .controls{ grid-template-columns: 1fr; }
      .grid2, .grid3{ grid-template-columns: 1fr; }
    }

    /* Subtle motion */
    @media (prefers-reduced-motion: no-preference){
      article{ animation: floatIn .45s ease both; transform-origin: 50% 0%; }
      @keyframes floatIn{
        from{ opacity:0; transform: translateY(10px) scale(.99); }
        to{ opacity:1; transform: translateY(0px) scale(1); }
      }
    }

    /* Print-friendly */
    @media print{
      body{ background:#fff; color:#000; }
      header, main, footer{ max-width: 100%; }
      nav#toc{ display:none; }
      article{ box-shadow:none; border:1px solid #ccc; background:#fff; }
      .vizCard{ page-break-inside: avoid; }
      canvas{ border:1px solid #bbb; background:#fff; }
      .copyBtn{ display:none; }
      .callout{ background:#fff; border:1px solid #ccc; box-shadow:none; }
      .eq{ background:#fff; border:1px solid #ccc; }
    }
  </style>
</head>
<body>
<header>
  <div class="title">
    <div>
      <h1>Light from a Two-Point Incoherent Source</h1>
      <div class="subtitle">
        Using the Fraunhofer (far-field) approximation and the van Cittert–Zernike theorem to compute the
        <em>normalized mutual intensity</em> (a.k.a. complex degree of coherence) at a plane a distance <span class="pill"><span class="dot"></span><span>d</span></span> from a source consisting of two incoherent emitting points separated by <span class="pill"><span class="dot"></span><span>2a</span></span>.
      </div>
    </div>
    <div class="meta">
      <div><strong>Topic:</strong> Statistical optics / spatial coherence</div>
      <div><strong>Model:</strong> quasi-monochromatic, spatially incoherent source</div>
      <div><strong>Regime:</strong> Fraunhofer (far field)</div>
    </div>
  </div>
</header>

<main>
  <nav id="toc" aria-label="Table of contents">
    <h2>Table of Contents</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy &amp; Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
    <a href="#viz">Interactive Visualizations</a>
  </nav>

  <article>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><strong>What this is about:</strong> finding how much two points in the observation plane are mutually coherent when light comes from <em>two spatially incoherent point emitters</em>.</li>
        <li><strong>Key physics idea:</strong> in the far field, spatial coherence is the (normalized) Fourier transform of the source intensity distribution (<em>van Cittert–Zernike</em>).</li>
        <li><strong>Governing object:</strong> mutual intensity (cross-spectral density) <span style="font-family:var(--mono)">J(r1,r2)</span> and its normalized form <span style="font-family:var(--mono)">μ(r1,r2)</span>.</li>
        <li><strong>Fraunhofer mapping:</strong> a transverse separation <span style="font-family:var(--mono)">Δx</span> at distance <span style="font-family:var(--mono)">d</span> corresponds to a spatial frequency factor <span style="font-family:var(--mono)">kΔx/d</span>.</li>
        <li><strong>For two equal point sources at</strong> <span style="font-family:var(--mono)">x=±a</span>: the normalized mutual intensity becomes a simple cosine.</li>
        <li><strong>Final result (symbolic):</strong> <span style="font-family:var(--mono)">μ(Δx)=cos(k a Δx / d)=cos(2π a Δx /(λ d))</span>.</li>
        <li><strong>Interpretation:</strong> larger source separation <span style="font-family:var(--mono)">2a</span> makes coherence oscillate faster with <span style="font-family:var(--mono)">Δx</span> (shorter “coherence width”).</li>
      </ul>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="grid2">
        <div class="callout assumptions">
          <h3>Core definitions</h3>
          <ul>
            <li><strong>Mutual intensity / cross-spectral density</strong> (quasi-monochromatic):<br>
              <span style="font-family:var(--mono)">J(r1,r2) = ⟨U(r1) U*(r2)⟩</span><br>
              Units: field units squared (often proportional to W/m² if scaled appropriately).
            </li>
            <li><strong>Intensity</strong> at a point: <span style="font-family:var(--mono)">I(r)=J(r,r)</span> (e.g., W/m²).</li>
            <li><strong>Normalized mutual intensity</strong> (complex degree of coherence):<br>
              <span style="font-family:var(--mono)">μ(r1,r2)= J(r1,r2) / √(I(r1) I(r2))</span><br>
              Dimensionless, and satisfies <span style="font-family:var(--mono)">|μ|≤1</span>.
            </li>
          </ul>
        </div>

        <div class="callout keyeq">
          <h3>Physical meaning</h3>
          <ul>
            <li><span style="font-family:var(--mono)">J(r1,r2)</span> measures how strongly the complex optical field at <span style="font-family:var(--mono)">r1</span> correlates with that at <span style="font-family:var(--mono)">r2</span>.</li>
            <li><span style="font-family:var(--mono)">μ</span> removes trivial scaling by intensity, leaving a pure “coherence” measure.</li>
            <li>In a two-beam interference experiment, fringe visibility is tied to <span style="font-family:var(--mono)">|μ|</span> (under equal intensities, visibility ≈ <span style="font-family:var(--mono)">|μ|</span>).</li>
          </ul>
        </div>
      </div>

      <div class="grid2" style="margin-top:12px;">
        <div class="callout">
          <h3>Key law: van Cittert–Zernike (VCZ)</h3>
          <p>
            For a <strong>spatially incoherent</strong>, quasi-monochromatic planar source with intensity distribution
            <span style="font-family:var(--mono)">I_s(ξ)</span> along transverse coordinate <span style="font-family:var(--mono)">ξ</span>,
            the far-field (Fraunhofer) normalized mutual intensity between two observation points separated by
            <span style="font-family:var(--mono)">Δx</span> is proportional to the <strong>normalized Fourier transform</strong> of the source intensity:
          </p>
          <div class="eq" id="eq-vcz">
            <div class="label">VCZ (1D scalar form, Fraunhofer)</div>
            <button class="copyBtn" data-copy="mu(Δx)= [∫ I_s(ξ) exp(-i k ξ Δx / d) dξ] / [∫ I_s(ξ) dξ]">Copy</button>
            μ(Δx)= [∫ I_s(ξ) exp(-i k ξ Δx / d) dξ] / [∫ I_s(ξ) dξ]
          </div>
          <p style="color:var(--muted); margin-top:8px;">
            Here <span style="font-family:var(--mono)">k=2π/λ</span> is the wavenumber and <span style="font-family:var(--mono)">d</span> is the propagation distance.
          </p>
        </div>

        <div class="callout assumptions">
          <h3>When is this valid?</h3>
          <ul>
            <li><strong>Quasi-monochromatic:</strong> narrow optical bandwidth so a single <span style="font-family:var(--mono)">λ</span> describes phase factors.</li>
            <li><strong>Spatially incoherent source:</strong> different source points are uncorrelated:
              <span style="font-family:var(--mono)">⟨U_s(ξ1) U_s*(ξ2)⟩ ∝ I_s(ξ1) δ(ξ1-ξ2)</span>.
            </li>
            <li><strong>Fraunhofer region:</strong> far-field approximation: phase from each source point varies approximately linearly with transverse position in the observation plane.</li>
            <li><strong>Scalar/paraxial:</strong> polarization details ignored (fine for many coherence questions).</li>
          </ul>
        </div>
      </div>

      <div class="grid2" style="margin-top:12px;">
        <div class="callout">
          <h3>Mini intuition examples</h3>
          <ul>
            <li><strong>Single point source:</strong> <span style="font-family:var(--mono)">I_s(ξ)=δ(ξ)</span> → Fourier transform is constant → <span style="font-family:var(--mono)">μ(Δx)=1</span> (perfect coherence across the plane).</li>
            <li><strong>Extended source:</strong> wider <span style="font-family:var(--mono)">I_s(ξ)</span> → narrower Fourier transform → coherence drops faster with <span style="font-family:var(--mono)">Δx</span> (“bigger sources are less spatially coherent”).</li>
          </ul>
        </div>

        <div class="callout mistakes">
          <h3>What to watch for (pitfalls)</h3>
          <ul>
            <li><strong>Confusing intensity interference</strong> with <strong>field coherence</strong>. Incoherent sources don’t interfere at the source plane, but they can create partial coherence after propagation.</li>
            <li><strong>Mixing up separations:</strong> source separation is <span style="font-family:var(--mono)">2a</span>; observation-point separation is <span style="font-family:var(--mono)">Δx</span>.</li>
            <li><strong>Forgetting normalization:</strong> <span style="font-family:var(--mono)">μ</span> must satisfy <span style="font-family:var(--mono)">|μ|≤1</span>.</li>
            <li><strong>Fraunhofer condition:</strong> the formula uses linearized phase; too-close planes require Fresnel treatment.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (No solving yet)</h2>

      <h3>Restate the problem</h3>
      <p>
        A spatially incoherent, quasi-monochromatic source emits light only from <strong>two points</strong> separated by a distance
        <span style="font-family:var(--mono)">2a</span> (think of point emitters at transverse positions <span style="font-family:var(--mono)">x=±a</span>).
        Using the <strong>Fraunhofer approximation</strong>, find an expression for the <strong>normalized mutual intensity</strong> at an observation plane a distance
        <span style="font-family:var(--mono)">d</span> from the source.
      </p>

      <div class="grid2">
        <div class="callout">
          <h3>Given</h3>
          <ul>
            <li>Two emitting points at transverse positions <span style="font-family:var(--mono)">x=+a</span> and <span style="font-family:var(--mono)">x=-a</span>.</li>
            <li>Spatial incoherence between the two source points (uncorrelated fields).</li>
            <li>Propagation distance <span style="font-family:var(--mono)">d</span> (far-field / Fraunhofer).</li>
            <li>Quasi-monochromatic wavelength <span style="font-family:var(--mono)">λ</span> (wavenumber <span style="font-family:var(--mono)">k=2π/λ</span>).</li>
          </ul>
        </div>

        <div class="callout">
          <h3>Unknowns / what to find</h3>
          <ul>
            <li>The normalized mutual intensity (complex degree of coherence)
              <span style="font-family:var(--mono)">μ(x1,x2)</span> at the plane <span style="font-family:var(--mono)">z=d</span>.</li>
            <li>Because the setup is shift-invariant in the transverse plane, the answer is naturally expressed versus
              <span style="font-family:var(--mono)">Δx = x1 - x2</span>.</li>
          </ul>
        </div>
      </div>

      <div class="callout assumptions" style="margin-top:12px;">
        <h3>Relevant principles &amp; why they apply</h3>
        <ul>
          <li><strong>VCZ theorem:</strong> the source is stated spatially incoherent and quasi-monochromatic, so far-field coherence is the normalized Fourier transform of source intensity.</li>
          <li><strong>Fraunhofer approximation:</strong> requested explicitly; lets us use a linear phase factor
            <span style="font-family:var(--mono)">exp(-i k ξ x / d)</span>.
          </li>
          <li><strong>Why not other tools?</strong> We don’t need full Fresnel diffraction or mutual coherence propagation integrals because VCZ gives a direct far-field expression for incoherent sources.</li>
        </ul>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ul>
        <li><strong>Approach A: VCZ theorem (best here).</strong> Model source intensity with delta functions and take a normalized Fourier transform. <em>Fast, clean, and matches the problem’s regime.</em></li>
        <li><strong>Approach B: Start from propagation of random fields.</strong> Write field at observation points as a sum of contributions from each source point, take ensemble averages, and normalize. <em>More algebra, but builds intuition explicitly.</em></li>
        <li><strong>Approach C: Treat as a special case of Young’s experiment visibility.</strong> Relate mutual intensity to fringe visibility from two observation points. <em>Conceptually helpful, but still needs μ(Δx) from coherence theory.</em></li>
      </ul>
      <p>
        We will use <strong>Approach A</strong> (VCZ) for the main derivation, and briefly connect it to Approach B for intuition.
      </p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy &amp; Tips (Roadmap only)</h2>

      <ol>
        <li><strong>Goal:</strong> represent the source intensity distribution.<br>
          <em>Tool:</em> delta-function model for two point emitters.<br>
          <em>Meaning:</em> encodes “light only at x=±a”.
        </li>
        <li><strong>Goal:</strong> write the far-field normalized mutual intensity formula.<br>
          <em>Tool:</em> VCZ theorem in 1D: normalized Fourier transform of <span style="font-family:var(--mono)">I_s(ξ)</span>.<br>
          <em>Meaning:</em> coherence is set by source geometry.
        </li>
        <li><strong>Goal:</strong> evaluate the integral for two delta functions.<br>
          <em>Tool:</em> sifting property: <span style="font-family:var(--mono)">∫δ(ξ-a)f(ξ)dξ=f(a)</span>.<br>
          <em>Meaning:</em> turns the Fourier transform into a sum of two phase factors.
        </li>
        <li><strong>Goal:</strong> normalize correctly so <span style="font-family:var(--mono)">μ(0)=1</span>.<br>
          <em>Tool:</em> divide by total source power <span style="font-family:var(--mono)">∫I_s(ξ)dξ</span>.<br>
          <em>Meaning:</em> ensures a dimensionless coherence function.
        </li>
        <li><strong>Goal:</strong> rewrite in a simple trigonometric form and interpret.<br>
          <em>Tool:</em> Euler identity to show cosine dependence.<br>
          <em>Meaning:</em> oscillatory coherence with a scale set by <span style="font-family:var(--mono)">λ d / a</span>.
        </li>
        <li><strong>Sanity checks:</strong> limits (a→0, Δx→0), bounds (|μ|≤1), and units inside the cosine.</li>
      </ol>

      <div class="callout mistakes">
        <h3>Common mistakes &amp; quick tips</h3>
        <ul>
          <li><strong>Tip:</strong> keep two distinct coordinates: source coordinate <span style="font-family:var(--mono)">ξ</span> and observation coordinate <span style="font-family:var(--mono)">x</span>.</li>
          <li><strong>Mistake:</strong> putting <span style="font-family:var(--mono)">2a</span> where <span style="font-family:var(--mono)">a</span> belongs inside the phase. The points are at ±a, so the phase contributions are ±a.</li>
          <li><strong>Tip:</strong> if the two point sources have unequal intensities, the result is no longer a pure cosine; you get a weighted complex average. (We’ll note this later.)</li>
        </ul>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Qualitative expectation (before math)</h3>
      <p>
        A single point source produces a spherical wave; in the far field it looks like a plane wave across the observation plane,
        so any two points are perfectly coherent: <span style="font-family:var(--mono)">μ=1</span>.
        With <strong>two</strong> separated point emitters that are mutually incoherent, you might expect “no coherence,” but propagation mixes
        angular components: in the far field the coherence becomes the Fourier transform of the <em>intensity distribution</em>.
        For two discrete points, the Fourier transform is a sum of two phasors → an oscillatory (cosine) dependence on the separation
        <span style="font-family:var(--mono)">Δx</span> between observation points.
      </p>

      <div class="callout assumptions">
        <h3>Assumptions used</h3>
        <ul>
          <li>Quasi-monochromatic light of wavelength <span style="font-family:var(--mono)">λ</span> (wavenumber <span style="font-family:var(--mono)">k=2π/λ</span>).</li>
          <li>Two source points are <strong>spatially incoherent</strong> (uncorrelated random phases).</li>
          <li>Observation plane is in the <strong>Fraunhofer</strong> region at distance <span style="font-family:var(--mono)">d</span>.</li>
          <li>Scalar, paraxial treatment (adequate for coherence calculation here).</li>
        </ul>
      </div>

      <h3>Step 1 — Model the source intensity</h3>
      <p>
        Let the source plane transverse coordinate be <span style="font-family:var(--mono)">ξ</span>.
        Two identical point emitters at <span style="font-family:var(--mono)">ξ=+a</span> and <span style="font-family:var(--mono)">ξ=-a</span>
        can be modeled (in 1D) by the intensity distribution
      </p>

      <div class="eq" id="eq-source">
        <div class="label">Two-point source intensity model</div>
        <button class="copyBtn" data-copy="I_s(ξ)=I0[δ(ξ-a)+δ(ξ+a)]">Copy</button>
        I_s(ξ)=I0[δ(ξ-a)+δ(ξ+a)]
      </div>

      <p style="color:var(--muted);">
        Here <span style="font-family:var(--mono)">I0</span> is a constant scaling (the two points emit equally on average).
      </p>

      <h3>Step 2 — Write VCZ for the far field</h3>
      <p>
        In the Fraunhofer regime, the normalized mutual intensity between two points in the observation plane,
        with transverse coordinates <span style="font-family:var(--mono)">x1</span> and <span style="font-family:var(--mono)">x2</span>,
        depends only on their separation <span style="font-family:var(--mono)">Δx = x1 - x2</span>.
        VCZ gives:
      </p>

      <div class="eq" id="eq-vcz2">
        <div class="label">VCZ specialized to a 1D source and separation Δx</div>
        <button class="copyBtn" data-copy="μ(Δx)= [∫ I_s(ξ) exp(-i k ξ Δx / d) dξ] / [∫ I_s(ξ) dξ]">Copy</button>
        μ(Δx)= [∫ I_s(ξ) exp(-i k ξ Δx / d) dξ] / [∫ I_s(ξ) dξ]
      </div>

      <p>
        <strong>What we did and why:</strong> we used the far-field coherence theorem appropriate to incoherent sources.
        The factor <span style="font-family:var(--mono)">exp(-i k ξ Δx / d)</span> is the Fraunhofer phase difference for contributions
        from a source point at <span style="font-family:var(--mono)">ξ</span> to two observation points separated by <span style="font-family:var(--mono)">Δx</span>.
      </p>

      <h3>Step 3 — Evaluate the numerator (Fourier transform of two deltas)</h3>
      <p>
        Substitute <span style="font-family:var(--mono)">I_s(ξ)=I0[δ(ξ-a)+δ(ξ+a)]</span> into the numerator:
      </p>

      <div class="eq" id="eq-num">
        <div class="label">Numerator computation</div>
        <button class="copyBtn" data-copy="∫ I_s(ξ) e^{-i k ξ Δx/d} dξ = I0(e^{-i k a Δx/d}+e^{+i k a Δx/d})">Copy</button>
        ∫ I_s(ξ) e<sup>-i k ξ Δx/d</sup> dξ
        = I0(e<sup>-i k a Δx/d</sup> + e<sup>+i k a Δx/d</sup>)
      </div>

      <p>
        <strong>What we did and why:</strong> each delta function “picks out” the phase factor evaluated at its location.
      </p>

      <h3>Step 4 — Evaluate the denominator (normalization)</h3>
      <p>
        The denominator is the total source intensity (in this 1D model):
      </p>
      <div class="eq" id="eq-den">
        <div class="label">Denominator computation</div>
        <button class="copyBtn" data-copy="∫ I_s(ξ) dξ = I0(1+1)=2I0">Copy</button>
        ∫ I_s(ξ) dξ = I0(1+1)=2I0
      </div>

      <p>
        <strong>What we did and why:</strong> normalization guarantees <span style="font-family:var(--mono)">μ(0)=1</span> and keeps <span style="font-family:var(--mono)">|μ|≤1</span>.
      </p>

      <h3>Step 5 — Put it together and simplify</h3>
      <p>
        Combine numerator and denominator:
      </p>

      <div class="eq" id="eq-mu">
        <div class="label">Normalized mutual intensity (complex degree of coherence)</div>
        <button class="copyBtn" data-copy="μ(Δx)= (e^{-i k a Δx/d}+e^{+i k a Δx/d})/2 = cos(k a Δx/d) = cos(2π a Δx/(λ d))">Copy</button>
        μ(Δx)= (e<sup>-i k a Δx/d</sup>+e<sup>+i k a Δx/d</sup>)/2
        = cos(k a Δx/d)
        = cos(2π a Δx/(λ d))
      </div>

      <div class="callout final">
        <h3>Final Answer (boxed)</h3>
        <div class="eq" id="eq-final">
          <div class="label">Result</div>
          <button class="copyBtn" data-copy="For two equal incoherent point emitters at x=±a, in the Fraunhofer plane z=d, the normalized mutual intensity between two observation points separated by Δx is:  μ(Δx)=cos(k a Δx/d)=cos(2π a Δx/(λ d)).">Copy</button>
          <strong>For two equal incoherent point emitters at x=±a, in the Fraunhofer plane z=d:</strong><br>
          μ(Δx)=cos(k a Δx/d)=cos(2π a Δx/(λ d)).
        </div>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><strong>Dimensions:</strong> the cosine argument <span style="font-family:var(--mono)">k a Δx / d</span> is dimensionless (good).</li>
        <li><strong>Limit Δx→0:</strong> <span style="font-family:var(--mono)">μ(0)=cos(0)=1</span> (a field is perfectly coherent with itself).</li>
        <li><strong>Limit a→0:</strong> two points merge into one point source → <span style="font-family:var(--mono)">μ(Δx)=1</span> (perfect spatial coherence).</li>
        <li><strong>Bound:</strong> <span style="font-family:var(--mono)">|μ|=|cos(...)|≤1</span> automatically satisfied.</li>
      </ul>

      <p>
        <strong>Connection to the diagram and plots:</strong> the source consists of two points at ±a.
        In the far field, the correlation between two observation points depends on how the two phasor contributions
        from those source points add when comparing the fields at <span style="font-family:var(--mono)">x1</span> and <span style="font-family:var(--mono)">x2</span>.
        That phasor sum produces the cosine dependence you’ll see in the interactive plot of <span style="font-family:var(--mono)">μ(Δx)</span>.
      </p>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>What the final formula is telling you</h3>
      <p>
        The coherence function
        <span style="font-family:var(--mono)">μ(Δx)=cos(2π a Δx/(λ d))</span>
        is controlled by a single scale:
      </p>

      <div class="eq" id="eq-scale">
        <div class="label">A useful “coherence spacing” scale</div>
        <button class="copyBtn" data-copy="Cosine phase = 2π a Δx/(λ d).  First zero occurs at Δx0 = λ d/(4a).">Copy</button>
        Cosine phase = 2π a Δx/(λ d). &nbsp;&nbsp;First zero: Δx0 = λ d/(4a).
      </div>

      <ul>
        <li><strong>Increase a (wider source):</strong> oscillations get faster → coherence changes rapidly with <span style="font-family:var(--mono)">Δx</span> → smaller “coherence width.”</li>
        <li><strong>Increase d (move farther away):</strong> oscillations slow down → larger coherence scale.</li>
        <li><strong>Increase λ (longer wavelength):</strong> oscillations slow down → larger coherence scale.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        You can also derive this by writing the observation-plane field as a sum of two random contributions:
        <span style="font-family:var(--mono)">U(x)=A_+ e^{-i k a x/d} + A_- e^{+i k a x/d}</span>,
        where <span style="font-family:var(--mono)">A_+</span> and <span style="font-family:var(--mono)">A_-</span> are statistically independent complex random amplitudes (incoherent sources).
        Then
        <span style="font-family:var(--mono)">J(x1,x2)=⟨U(x1)U*(x2)⟩</span>
        keeps only “self” terms because cross terms average to zero, producing the same cosine after normalization.
      </p>

      <h3>Concept checks (quick self-test)</h3>
      <ul>
        <li><strong>Q:</strong> If the two points become one (a→0), what happens to μ?<br><strong>A:</strong> It becomes 1 everywhere (perfect coherence).</li>
        <li><strong>Q:</strong> Does “incoherent source points” mean μ must be zero in the observation plane?<br><strong>A:</strong> No. Propagation converts source intensity structure into far-field coherence (VCZ).</li>
        <li><strong>Q:</strong> Where is μ first zero?<br><strong>A:</strong> At <span style="font-family:var(--mono)">Δx0=λ d/(4a)</span> for equal points.</li>
        <li><strong>Q:</strong> What parameter most strongly reduces the coherence scale?<br><strong>A:</strong> Increasing <span style="font-family:var(--mono)">a</span> (making the source larger/separated more).</li>
      </ul>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="grid2">
        <div class="callout">
          <h3>Diagram canvas</h3>
          <ul>
            <li>Shows two source points at <span style="font-family:var(--mono)">x=±a</span> in the source plane (<span style="font-family:var(--mono)">z=0</span>).</li>
            <li>Shows the observation plane at <span style="font-family:var(--mono)">z=d</span> with two observation points separated by <span style="font-family:var(--mono)">Δx</span>.</li>
            <li>Rays indicate far-field propagation used by the Fraunhofer approximation.</li>
          </ul>
        </div>

        <div class="callout">
          <h3>Main plot canvas</h3>
          <ul>
            <li>Plots <span style="font-family:var(--mono)">μ(Δx)</span> vs <span style="font-family:var(--mono)">Δx</span> (example range) using the derived formula.</li>
            <li>The oscillation period is set by <span style="font-family:var(--mono)">λ d / a</span>.</li>
            <li>Gridlines, ticks, and labels help estimate where μ crosses zero and how fast it varies.</li>
          </ul>
        </div>
      </div>

      <div class="callout" style="margin-top:12px;">
        <h3>Secondary plot canvas + interactivity</h3>
        <ul>
          <li>The secondary plot sweeps <span style="font-family:var(--mono)">a</span> and shows the <strong>first-zero separation</strong>
            <span style="font-family:var(--mono)">Δx0=λ d/(4a)</span>.</li>
          <li><strong>Sliders:</strong> change <span style="font-family:var(--mono)">a</span>, <span style="font-family:var(--mono)">d</span>, and <span style="font-family:var(--mono)">λ</span>.
            All canvases update live so you can see how geometry and wavelength control coherence.</li>
        </ul>
      </div>
    </section>

    <section id="viz">
      <h2>Interactive Visualizations</h2>

      <div class="vizCard">
        <div class="vizHeader">
          <h3 style="margin:0;">Controls (updates diagram + both plots)</h3>
          <span class="pill" title="All plots update live">
            <span class="dot"></span> Live update
          </span>
        </div>

        <div class="controls" role="group" aria-label="Interactive controls">
          <div class="control">
            <label>
              <span>Half-separation <span style="font-family:var(--mono)">a</span> (mm)</span>
              <span class="readout" id="aOut">0.25</span>
            </label>
            <input id="aSlider" type="range" min="0.05" max="1.00" step="0.01" value="0.25" />
          </div>
          <div class="control">
            <label>
              <span>Distance <span style="font-family:var(--mono)">d</span> (m)</span>
              <span class="readout" id="dOut">1.00</span>
            </label>
            <input id="dSlider" type="range" min="0.20" max="3.00" step="0.01" value="1.00" />
          </div>
          <div class="control">
            <label>
              <span>Wavelength <span style="font-family:var(--mono)">λ</span> (nm)</span>
              <span class="readout" id="lOut">633</span>
            </label>
            <input id="lSlider" type="range" min="400" max="900" step="1" value="633" />
          </div>
        </div>

        <div class="canvasWrap" style="margin-top:12px;">
          <canvas id="diag" aria-label="Geometry diagram canvas"></canvas>
          <canvas id="plotMain" aria-label="Main plot canvas"></canvas>
          <div class="small">
            <canvas id="plotSweep" aria-label="Secondary sweep plot canvas"></canvas>
          </div>
        </div>

        <div class="callout final" style="margin-top:12px;">
          <h3 style="margin-top:0;">Live computed quantities (from current sliders)</h3>
          <ul>
            <li><strong>Formula:</strong> <span style="font-family:var(--mono)">μ(Δx)=cos(2π a Δx/(λ d))</span></li>
            <li><strong>First zero:</strong> <span style="font-family:var(--mono)">Δx0=λ d/(4a)</span> = <span style="font-family:var(--mono)" id="dx0Out">—</span></li>
            <li><strong>Cosine period in Δx:</strong> <span style="font-family:var(--mono)">P = λ d / a</span> = <span style="font-family:var(--mono)" id="perOut">—</span></li>
          </ul>
        </div>
      </div>
    </section>
  </article>
</main>

<footer>
  <div>
    Built with vanilla HTML/CSS/JS. Equations are plain text (no MathJax). Canvases are high-DPI aware and responsive.
  </div>
</footer>

<script>
/* ---------- Copy buttons ---------- */
(function(){
  const btns = document.querySelectorAll('.copyBtn');
  btns.forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const txt = btn.getAttribute('data-copy') || '';
      try{
        await navigator.clipboard.writeText(txt);
        const old = btn.textContent;
        btn.textContent = 'Copied!';
        setTimeout(()=>btn.textContent = old, 900);
      }catch(e){
        // Fallback
        const ta = document.createElement('textarea');
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        ta.remove();
        const old = btn.textContent;
        btn.textContent = 'Copied!';
        setTimeout(()=>btn.textContent = old, 900);
      }
    });
  });
})();

/* ---------- Math helpers ---------- */
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function lerp(a,b,t){ return a + (b-a)*t; }

/* ---------- Canvas utilities (HiDPI + resize) ---------- */
function setupHiDPICanvas(canvas){
  const ctx = canvas.getContext('2d');
  function resize(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(2, Math.floor(rect.width * dpr));
    const h = Math.max(2, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
    }
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return {width: rect.width, height: rect.height, dpr};
  }
  return {ctx, resize};
}

/* ---------- Plotting primitives ---------- */
function drawAxes(ctx, W, H, opts){
  const padL = opts.padL ?? 56;
  const padR = opts.padR ?? 18;
  const padT = opts.padT ?? 34;
  const padB = opts.padB ?? 46;

  const x0 = padL, y0 = H - padB;
  const x1 = W - padR, y1 = padT;

  // Background
  ctx.clearRect(0,0,W,H);

  // Title
  ctx.save();
  ctx.fillStyle = 'rgba(233,236,255,0.95)';
  ctx.font = '600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(opts.title ?? '', padL, 18);
  ctx.restore();

  // Plot area border
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.rect(x0, y1, x1-x0, y0-y1);
  ctx.stroke();
  ctx.restore();

  // Gridlines + ticks
  const nx = opts.nx ?? 6;
  const ny = opts.ny ?? 5;

  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  for(let i=0;i<=nx;i++){
    const x = lerp(x0,x1,i/nx);
    ctx.beginPath(); ctx.moveTo(x,y1); ctx.lineTo(x,y0); ctx.stroke();
  }
  for(let j=0;j<=ny;j++){
    const y = lerp(y0,y1,j/ny);
    ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke();
  }
  ctx.restore();

  // Axis labels
  ctx.save();
  ctx.fillStyle = 'rgba(184,192,255,0.95)';
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';

  if(opts.xLabel){
    ctx.fillText(opts.xLabel, (x0+x1)/2 - ctx.measureText(opts.xLabel).width/2, H - 12);
  }
  if(opts.yLabel){
    ctx.translate(14, (y0+y1)/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(opts.yLabel, -ctx.measureText(opts.yLabel).width/2, 0);
    ctx.setTransform(1,0,0,1,0,0);
  }
  ctx.restore();

  return {x0,y0,x1,y1,padL,padR,padT,padB};
}

function drawTicks(ctx, frame, xMin, xMax, yMin, yMax, nx=6, ny=5){
  const {x0,y0,x1,y1} = frame;
  ctx.save();
  ctx.fillStyle = 'rgba(184,192,255,0.95)';
  ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

  for(let i=0;i<=nx;i++){
    const t=i/nx;
    const x=lerp(x0,x1,t);
    const val=lerp(xMin,xMax,t);
    const label = formatNumber(val);
    ctx.fillText(label, x - ctx.measureText(label).width/2, y0+18);
  }
  for(let j=0;j<=ny;j++){
    const t=j/ny;
    const y=lerp(y0,y1,t);
    const val=lerp(yMin,yMax,t);
    const label = formatNumber(val);
    ctx.fillText(label, x0 - 10 - ctx.measureText(label).width, y + 4);
  }
  ctx.restore();
}

function formatNumber(x){
  const ax = Math.abs(x);
  if(ax >= 1000) return x.toFixed(0);
  if(ax >= 100) return x.toFixed(1);
  if(ax >= 10) return x.toFixed(2);
  if(ax >= 1) return x.toFixed(3);
  return x.toExponential(2).replace('e','×10^');
}

function mapX(frame, x, xMin, xMax){
  const {x0,x1} = frame;
  return x0 + (x - xMin) * (x1-x0)/(xMax-xMin);
}
function mapY(frame, y, yMin, yMax){
  const {y0,y1} = frame;
  return y0 - (y - yMin) * (y0-y1)/(yMax-yMin);
}

function drawLine(ctx, points){
  if(points.length<2) return;
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for(let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
  ctx.stroke();
}

function drawLegend(ctx, W, H, items){
  ctx.save();
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  let x = 16, y = 30;
  items.forEach(it=>{
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    const w = ctx.measureText(it.text).width + 40;
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.fillRect(x-8,y-14,w,22);
    ctx.strokeRect(x-8,y-14,w,22);

    ctx.strokeStyle = it.color;
    ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.moveTo(x, y-4); ctx.lineTo(x+20, y-4); ctx.stroke();
    ctx.fillStyle = 'rgba(233,236,255,0.95)';
    ctx.fillText(it.text, x+26, y);
    y += 26;
  });
  ctx.restore();
}

/* ---------- Physics model ---------- */
/*
μ(Δx) = cos( 2π a Δx /(λ d) )
Units:
  a in meters, Δx in meters, λ in meters, d in meters.
In UI:
  a in mm, Δx in mm (plot), λ in nm, d in m.
*/
function muOfDx(dx_m, a_m, lambda_m, d_m){
  const phase = 2*Math.PI * a_m * dx_m / (lambda_m * d_m);
  return Math.cos(phase);
}
function firstZeroDx0(a_m, lambda_m, d_m){
  // cos(2π a Δx/(λ d)) = 0 => 2π a Δx/(λ d) = π/2 => Δx0 = λ d/(4a)
  return (lambda_m * d_m) / (4 * a_m);
}
function periodDx(a_m, lambda_m, d_m){
  // cos(2π a Δx/(λ d)) period P = λ d / a
  return (lambda_m * d_m) / a_m;
}

/* ---------- Diagram rendering ---------- */
function drawDiagram(ctx, W, H, params){
  const {a_mm, d_m} = params;

  // Canvas space in CSS pixels
  ctx.clearRect(0,0,W,H);

  // Background gradient panel
  const grd = ctx.createLinearGradient(0,0,W,H);
  grd.addColorStop(0,'rgba(122,162,255,0.10)');
  grd.addColorStop(1,'rgba(125,255,207,0.07)');
  ctx.fillStyle = grd;
  ctx.fillRect(0,0,W,H);

  // Layout: source plane left, observation plane right
  const pad = 18;
  const xS = pad + 70;
  const xO = W - pad - 70;
  const yMid = H/2;

  // Planes
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.20)';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(xS, pad); ctx.lineTo(xS, H-pad); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(xO, pad); ctx.lineTo(xO, H-pad); ctx.stroke();
  ctx.restore();

  // Labels
  ctx.save();
  ctx.fillStyle = 'rgba(233,236,255,0.95)';
  ctx.font = '600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('Source plane (z=0)', xS-52, pad-2);
  ctx.fillText('Observation plane (z=d)', xO-78, pad-2);
  ctx.restore();

  // Source points at ±a (scaled in diagram)
  const yScale = (H - 2*pad) / 6; // arbitrary
  const ya = clamp(a_mm, 0.05, 1.0) * 6; // use slider to vary separation visually
  const yPlus = yMid - ya * (yScale/6) * 2.2;
  const yMinus= yMid + ya * (yScale/6) * 2.2;

  // Draw source points
  function dot(x,y,color){
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fill();
    ctx.shadowColor = color; ctx.shadowBlur = 16;
    ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  dot(xS, yPlus, 'rgba(122,162,255,0.95)');
  dot(xS, yMinus,'rgba(122,162,255,0.95)');

  // Label ±a
  ctx.save();
  ctx.fillStyle = 'rgba(184,192,255,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillText('+a', xS-24, yPlus-10);
  ctx.fillText('-a', xS-24, yMinus+18);
  ctx.restore();

  // Observation points x1, x2 (separated by Δx) - show a fixed representative separation relative to first zero
  const dx0_m = firstZeroDx0(params.a_m, params.lambda_m, d_m);
  const dx_vis_m = dx0_m * 0.9;
  const dx_vis_mm = dx_vis_m * 1e3;

  const y1 = yMid - 32;
  const y2 = yMid + 32;
  dot(xO, y1, 'rgba(125,255,207,0.92)');
  dot(xO, y2, 'rgba(125,255,207,0.92)');

  ctx.save();
  ctx.fillStyle = 'rgba(184,192,255,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillText('x1', xO+10, y1+4);
  ctx.fillText('x2', xO+10, y2+4);
  ctx.restore();

  // Rays
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.14)';
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(xS, yPlus); ctx.lineTo(xO, y1); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(xS, yPlus); ctx.lineTo(xO, y2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(xS, yMinus); ctx.lineTo(xO, y1); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(xS, yMinus); ctx.lineTo(xO, y2); ctx.stroke();
  ctx.restore();

  // Distance d arrow
  ctx.save();
  ctx.strokeStyle = 'rgba(255,210,122,0.75)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(xS, H-pad-10);
  ctx.lineTo(xO, H-pad-10);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(xO-10, H-pad-15);
  ctx.lineTo(xO, H-pad-10);
  ctx.lineTo(xO-10, H-pad-5);
  ctx.stroke();
  ctx.fillStyle = 'rgba(255,210,122,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  const dTxt = `d = ${d_m.toFixed(2)} m`;
  ctx.fillText(dTxt, (xS+xO)/2 - ctx.measureText(dTxt).width/2, H-pad-18);
  ctx.restore();

  // Δx bracket
  ctx.save();
  ctx.strokeStyle = 'rgba(125,255,207,0.75)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(xO+28, y1);
  ctx.lineTo(xO+28, y2);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(xO+24, y1);
  ctx.lineTo(xO+32, y1);
  ctx.moveTo(xO+24, y2);
  ctx.lineTo(xO+32, y2);
  ctx.stroke();
  ctx.fillStyle = 'rgba(125,255,207,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  const dxTxt = `Δx (example) ≈ ${dx_vis_mm.toFixed(2)} mm`;
  ctx.fillText(dxTxt, xO - ctx.measureText(dxTxt).width/2, y2+42);
  ctx.restore();

  // Title inside diagram
  ctx.save();
  ctx.fillStyle = 'rgba(233,236,255,0.95)';
  ctx.font = '600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('Geometry (two incoherent point emitters)', 18, 22);
  ctx.restore();
}

/* ---------- Main plot: μ(Δx) ---------- */
function drawMainPlot(ctx, W, H, params){
  const {a_m, lambda_m, d_m} = params;

  // Set x-range based on period so we see a few oscillations but not too many
  const P = periodDx(a_m, lambda_m, d_m); // meters
  const xMax = clamp(2.2*P, 0.5e-3, 12e-3); // meters, clamp to reasonable display
  const xMin = -xMax;

  const yMin = -1.2, yMax = 1.2;

  const frame = drawAxes(ctx, W, H, {
    title: 'Main plot: normalized mutual intensity  μ(Δx)',
    xLabel: 'Δx (mm)',
    yLabel: 'μ (dimensionless)',
    nx: 6, ny: 6,
    padL: 62, padR: 18, padT: 34, padB: 48
  });

  // Ticks in mm for x
  const xMin_mm = xMin*1e3, xMax_mm = xMax*1e3;
  drawTicks(ctx, frame, xMin_mm, xMax_mm, yMin, yMax, 6, 6);

  // Draw μ curve
  const pts = [];
  const N = 700;
  for(let i=0;i<=N;i++){
    const t=i/N;
    const dx = lerp(xMin,xMax,t);
    const mu = muOfDx(dx, a_m, lambda_m, d_m);
    pts.push({
      x: mapX(frame, dx*1e3, xMin_mm, xMax_mm),
      y: mapY(frame, mu, yMin, yMax)
    });
  }

  ctx.save();
  ctx.strokeStyle = 'rgba(122,162,255,0.95)';
  ctx.lineWidth = 2.5;
  drawLine(ctx, pts);
  ctx.restore();

  // Zero line
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1.5;
  const y0 = mapY(frame, 0, yMin, yMax);
  ctx.beginPath(); ctx.moveTo(frame.x0, y0); ctx.lineTo(frame.x1, y0); ctx.stroke();
  ctx.restore();

  // Mark first zero ±Δx0
  const dx0 = firstZeroDx0(a_m, lambda_m, d_m); // meters
  if(dx0>0 && dx0 < xMax){
    const xz1 = mapX(frame, dx0*1e3, xMin_mm, xMax_mm);
    const xz2 = mapX(frame, -dx0*1e3, xMin_mm, xMax_mm);
    ctx.save();
    ctx.strokeStyle = 'rgba(125,255,207,0.85)';
    ctx.lineWidth = 1.75;
    [xz1,xz2].forEach(xz=>{
      ctx.beginPath(); ctx.moveTo(xz, frame.y1); ctx.lineTo(xz, frame.y0); ctx.stroke();
    });
    ctx.fillStyle = 'rgba(125,255,207,0.92)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    const tag = 'first zero';
    ctx.fillText(tag, xz1 - ctx.measureText(tag).width/2, frame.y1 + 14);
    ctx.restore();
  }

  // Legend
  drawLegend(ctx, W, H, [
    {text:'μ(Δx)=cos(2π a Δx/(λ d))', color:'rgba(122,162,255,0.95)'},
    {text:'±Δx0 (first zero)', color:'rgba(125,255,207,0.85)'}
  ]);
}

/* ---------- Secondary plot: Δx0 vs a sweep ---------- */
function drawSweepPlot(ctx, W, H, params){
  const {lambda_m, d_m, a_m} = params;

  const aMin_mm = 0.05, aMax_mm = 1.0;
  const aMin_m = aMin_mm*1e-3, aMax_m = aMax_mm*1e-3;

  const yMin_mm = 0.0;
  const yMax_mm = firstZeroDx0(aMin_m, lambda_m, d_m)*1e3; // at smallest a, largest dx0
  const yMax_mm_clamped = clamp(yMax_mm, 1.0, 40.0);

  const frame = drawAxes(ctx, W, H, {
    title: 'Secondary plot: first-zero separation  Δx0 = λ d/(4a)  vs  a',
    xLabel: 'a (mm)',
    yLabel: 'Δx0 (mm)',
    nx: 6, ny: 5,
    padL: 68, padR: 18, padT: 34, padB: 48
  });

  drawTicks(ctx, frame, aMin_mm, aMax_mm, yMin_mm, yMax_mm_clamped, 6, 5);

  // Curve
  const pts = [];
  const N=600;
  for(let i=0;i<=N;i++){
    const t=i/N;
    const a_mm = lerp(aMin_mm,aMax_mm,t);
    const dx0_mm = firstZeroDx0(a_mm*1e-3, lambda_m, d_m)*1e3;
    const dx0c = clamp(dx0_mm, yMin_mm, yMax_mm_clamped);
    pts.push({
      x: mapX(frame, a_mm, aMin_mm, aMax_mm),
      y: mapY(frame, dx0c, yMin_mm, yMax_mm_clamped)
    });
  }
  ctx.save();
  ctx.strokeStyle = 'rgba(255,210,122,0.95)';
  ctx.lineWidth = 2.5;
  drawLine(ctx, pts);
  ctx.restore();

  // Marker at current a
  const dx0_now_mm = firstZeroDx0(a_m, lambda_m, d_m)*1e3;
  const dx0_now_c = clamp(dx0_now_mm, yMin_mm, yMax_mm_clamped);

  const xNow = mapX(frame, a_m*1e3, aMin_mm, aMax_mm);
  const yNow = mapY(frame, dx0_now_c, yMin_mm, yMax_mm_clamped);

  ctx.save();
  ctx.fillStyle = 'rgba(125,255,207,0.92)';
  ctx.strokeStyle = 'rgba(125,255,207,0.92)';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(xNow,yNow,5,0,Math.PI*2); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(xNow, frame.y0); ctx.lineTo(xNow, frame.y1);
  ctx.strokeStyle = 'rgba(125,255,207,0.25)';
  ctx.stroke();
  ctx.restore();

  drawLegend(ctx, W, H, [
    {text:'Δx0(a)=λ d/(4a)', color:'rgba(255,210,122,0.95)'},
    {text:'current a', color:'rgba(125,255,207,0.92)'}
  ]);
}

/* ---------- Wiring + responsiveness ---------- */
const aSlider = document.getElementById('aSlider');
const dSlider = document.getElementById('dSlider');
const lSlider = document.getElementById('lSlider');
const aOut = document.getElementById('aOut');
const dOut = document.getElementById('dOut');
const lOut = document.getElementById('lOut');
const dx0Out = document.getElementById('dx0Out');
const perOut = document.getElementById('perOut');

const diag = setupHiDPICanvas(document.getElementById('diag'));
const plotMain = setupHiDPICanvas(document.getElementById('plotMain'));
const plotSweep = setupHiDPICanvas(document.getElementById('plotSweep'));

function getParams(){
  const a_mm = parseFloat(aSlider.value);
  const d_m = parseFloat(dSlider.value);
  const lambda_nm = parseFloat(lSlider.value);

  return {
    a_mm,
    d_m,
    lambda_nm,
    a_m: a_mm*1e-3,
    lambda_m: lambda_nm*1e-9
  };
}

function updateReadouts(params){
  aOut.textContent = params.a_mm.toFixed(2);
  dOut.textContent = params.d_m.toFixed(2);
  lOut.textContent = params.lambda_nm.toFixed(0);

  const dx0 = firstZeroDx0(params.a_m, params.lambda_m, params.d_m); // meters
  const P = periodDx(params.a_m, params.lambda_m, params.d_m); // meters
  dx0Out.textContent = `${(dx0*1e3).toFixed(3)} mm`;
  perOut.textContent = `${(P*1e3).toFixed(3)} mm`;
}

function renderAll(){
  const params = getParams();
  updateReadouts(params);

  const rD = diag.resize();
  drawDiagram(diag.ctx, rD.width, rD.height, params);

  const rM = plotMain.resize();
  drawMainPlot(plotMain.ctx, rM.width, rM.height, params);

  const rS = plotSweep.resize();
  drawSweepPlot(plotSweep.ctx, rS.width, rS.height, params);
}

[aSlider, dSlider, lSlider].forEach(el=>{
  el.addEventListener('input', renderAll);
});

window.addEventListener('resize', ()=>{
  // Throttle with rAF to avoid jank
  window.requestAnimationFrame(renderAll);
});

renderAll();
</script>
</body>
</html>
