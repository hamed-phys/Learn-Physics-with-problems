<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Proof of the Wiener–Khinchin Theorem (Optics / Random Processes)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --card:#111c3a;
      --ink:#eaf0ff;
      --muted:#b9c6ffcc;
      --faint:#b9c6ff66;
      --accent:#8ee6ff;
      --accent2:#b8ffb0;
      --danger:#ff7aa2;
      --warn:#ffd27a;
      --ok:#a0ffcf;
      --line:#2a3a73;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--ink);
      background:
        radial-gradient(1000px 700px at 10% 0%, rgba(142,230,255,.10), transparent 60%),
        radial-gradient(900px 650px at 95% 20%, rgba(184,255,176,.08), transparent 60%),
        radial-gradient(700px 450px at 50% 105%, rgba(255,210,122,.08), transparent 55%),
        linear-gradient(180deg, var(--bg), #070b16 60%, #050713);
      line-height:1.55;
    }

    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}

    header{
      padding: 38px 20px 16px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .hero{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 18px;
      align-items: start;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns: 1fr}
    }

    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid rgba(185,198,255,.14);
      border-radius: var(--radius);
      padding: 22px 22px 18px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
      isolation:isolate;
    }
    .titleCard:before{
      content:"";
      position:absolute; inset:-80px -120px auto auto;
      width: 280px; height: 280px;
      background: radial-gradient(circle at 30% 30%, rgba(142,230,255,.25), transparent 65%);
      filter: blur(2px);
      transform: rotate(15deg);
      z-index:-1;
    }
    h1{
      margin:0 0 10px;
      font-size: clamp(22px, 2.4vw, 34px);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color: var(--muted);
      font-size: 14.5px;
    }
    .metaRow{
      margin-top: 14px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
    }
    .pill{
      font-size: 12px;
      color: var(--ink);
      border: 1px solid rgba(185,198,255,.18);
      background: rgba(17,28,58,.55);
      padding: 6px 10px;
      border-radius: 999px;
      backdrop-filter: blur(6px);
      display:inline-flex;
      gap:8px;
      align-items:center;
      white-space:nowrap;
    }
    .dot{
      width:8px;height:8px;border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 18px rgba(142,230,255,.55);
    }

    .toc{
      position: sticky;
      top: 12px;
      align-self:start;
      background: rgba(15,23,48,.62);
      border: 1px solid rgba(185,198,255,.14);
      border-radius: var(--radius);
      padding: 14px 14px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .toc h2{
      margin:0 0 10px;
      font-size: 13px;
      letter-spacing: .14em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .toc a{
      display:block;
      padding: 7px 10px;
      border-radius: 12px;
      font-size: 13.5px;
      color: var(--ink);
      border: 1px solid transparent;
    }
    .toc a:hover{
      background: rgba(142,230,255,.10);
      border-color: rgba(142,230,255,.24);
      text-decoration:none;
    }

    main{
      max-width: 1200px;
      margin: 0 auto;
      padding: 6px 20px 60px;
    }

    section{
      margin-top: 22px;
      scroll-margin-top: 78px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    .card{
      background: rgba(17,28,58,.62);
      border: 1px solid rgba(185,198,255,.14);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 18px 16px;
      backdrop-filter: blur(10px);
    }

    .card h3{
      margin:0 0 10px;
      font-size: 18px;
      letter-spacing:.2px;
    }

    .lead{
      color: var(--muted);
      margin-top: 0;
    }

    .twoCol{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 860px){
      .twoCol{grid-template-columns: 1fr}
    }

    .callouts{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
      margin-top: 12px;
    }
    .callout{
      grid-column: span 6;
      border-radius: 16px;
      border: 1px solid rgba(185,198,255,.14);
      background: rgba(17,28,58,.38);
      padding: 12px 12px 10px;
    }
    .callout strong{
      display:flex;
      align-items:center;
      gap:8px;
    }
    .callout strong::before{
      content:"";
      width:10px;height:10px;border-radius:50%;
      background: var(--accent2);
      box-shadow: 0 0 16px rgba(184,255,176,.40);
    }
    .callout.warn strong::before{background: var(--warn); box-shadow:0 0 16px rgba(255,210,122,.42)}
    .callout.danger strong::before{background: var(--danger); box-shadow:0 0 16px rgba(255,122,162,.42)}
    .callout.ok strong::before{background: var(--ok); box-shadow:0 0 16px rgba(160,255,207,.42)}
    .callout p{margin:8px 0 0; color: var(--muted); font-size: 13.5px}
    @media (max-width: 860px){
      .callout{grid-column: span 12}
    }

    .eq{
      font-family: var(--mono);
      font-size: 13.2px;
      color: #e9fbff;
      background: rgba(142,230,255,.10);
      border: 1px solid rgba(142,230,255,.18);
      border-radius: 12px;
      padding: 10px 10px;
      overflow:auto;
      position:relative;
      margin: 10px 0;
      white-space: pre;
    }
    .eq .mini{color: var(--faint); font-family: var(--sans); font-size: 12px; margin-bottom: 8px; white-space: normal;}
    .copyBtn{
      position:absolute;
      top: 8px;
      right: 8px;
      border: 1px solid rgba(185,198,255,.18);
      background: rgba(17,28,58,.65);
      color: var(--ink);
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 10px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease;
      user-select:none;
    }
    .copyBtn:hover{background: rgba(142,230,255,.14); transform: translateY(-1px)}
    .copyBtn:active{transform: translateY(0px) scale(.98)}
    .copyToast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(15,23,48,.86);
      border: 1px solid rgba(185,198,255,.18);
      border-radius: 999px;
      padding: 10px 14px;
      box-shadow: var(--shadow);
      color: var(--ink);
      font-size: 13px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .25s ease, transform .25s ease;
      z-index: 9999;
    }
    .copyToast.show{opacity: 1; transform: translateX(-50%) translateY(-2px)}

    ul{margin: 10px 0 0 22px}
    li{margin: 6px 0}

    .controls{
      display:flex;
      flex-wrap:wrap;
      gap: 10px 14px;
      align-items: center;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(185,198,255,.12);
    }
    label{
      font-size: 13px;
      color: var(--muted);
      display:flex;
      gap: 8px;
      align-items:center;
      flex-wrap:wrap;
    }
    input[type="range"]{
      width: 240px;
      accent-color: var(--accent);
    }
    select, button.small{
      background: rgba(17,28,58,.65);
      color: var(--ink);
      border: 1px solid rgba(185,198,255,.16);
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 13px;
      cursor:pointer;
    }
    button.small:hover{background: rgba(142,230,255,.12)}
    .readout{
      font-family: var(--mono);
      font-size: 12.5px;
      color: #e9fbff;
      padding: 6px 8px;
      border-radius: 12px;
      border: 1px solid rgba(142,230,255,.18);
      background: rgba(142,230,255,.10);
      min-width: 130px;
      text-align:center;
    }

    figure{margin: 12px 0 0}
    canvas{
      width: 100%;
      height: 360px;
      border-radius: 16px;
      border: 1px solid rgba(185,198,255,.16);
      background: rgba(10,15,30,.55);
      display:block;
    }
    @media (max-width: 860px){
      canvas{height: 320px}
    }
    .canvasCaption{
      color: var(--muted);
      font-size: 13px;
      margin: 10px 2px 0;
    }

    .finalBox{
      border: 1px solid rgba(184,255,176,.22);
      background: rgba(184,255,176,.08);
    }
    .finalBox strong::before{
      background: var(--accent2);
      box-shadow: 0 0 16px rgba(184,255,176,.46);
    }

    .hr{
      height:1px;
      background: linear-gradient(90deg, transparent, rgba(185,198,255,.16), transparent);
      margin: 14px 0;
    }

    footer{
      max-width: 1200px;
      margin: 0 auto;
      padding: 18px 20px 44px;
      color: var(--faint);
      font-size: 13px;
    }

    /* subtle entrance */
    .fadeIn{
      animation: rise .55s ease both;
    }
    @keyframes rise{
      from{opacity:0; transform: translateY(8px)}
      to{opacity:1; transform: translateY(0)}
    }

    /* Print-friendly */
    @media print{
      body{background:#fff; color:#000}
      .toc{display:none}
      .card, .titleCard{box-shadow:none; background:#fff; border:1px solid #ddd; backdrop-filter:none}
      canvas{border:1px solid #ddd; background:#fff}
      .eq{background:#f6fbff; border:1px solid #cfe9ff; color:#000}
      .copyBtn, .copyToast{display:none}
    }
  </style>
</head>

<body>
  <header class="fadeIn">
    <div class="hero">
      <div class="titleCard">
        <h1>Proof of the Wiener–Khinchin Theorem (Autocorrelation ⇄ Spectrum)</h1>
        <p class="subtitle">
          We prove that the (power) spectral density <span class="eq" style="display:inline; padding:2px 6px; border-radius:10px;">S(ν)</span>
          is the Fourier transform of the autocorrelation <span class="eq" style="display:inline; padding:2px 6px; border-radius:10px;">G(τ)</span>,
          starting from the definitions shown in the prompt. We also show that the average intensity equals the integral of the spectrum.
        </p>
        <div class="metaRow">
          <span class="pill"><span class="dot"></span> Stationary complex random process</span>
          <span class="pill"><span class="dot" style="background:var(--accent2)"></span> Optics / temporal coherence</span>
          <span class="pill"><span class="dot" style="background:var(--warn)"></span> Vanilla HTML/CSS/JS, interactive plots</span>
        </div>
      </div>

      <nav class="toc" aria-label="Table of contents">
        <h2>Contents</h2>
        <a href="#quick">Quick Summary</a>
        <a href="#primer">PART 0 — Concept Primer</a>
        <a href="#analysis">PART 1 — Problem Analysis</a>
        <a href="#strategy">PART 2 — Strategy & Tips</a>
        <a href="#solution">PART 3 — Full Solution</a>
        <a href="#deeper">PART 4 — Deeper Understanding</a>
        <a href="#viz">PART 5 — Visualization Guide</a>
      </nav>
    </div>
  </header>

  <main>
    <!-- QUICK SUMMARY -->
    <section id="quick" class="fadeIn">
      <div class="card">
        <h3>Quick Summary</h3>
        <ul>
          <li><b>What this is about:</b> connecting <b>time-domain coherence</b> (autocorrelation) to the <b>frequency-domain spectrum</b>.</li>
          <li><b>Key physics idea:</b> a stationary field’s frequency content is encoded in how quickly it “forgets” itself in time.</li>
          <li><b>Autocorrelation definition:</b> <span class="eq" style="display:inline; padding:2px 6px; border-radius:10px;">G(τ)=⟨U*(t)U(t+τ)⟩</span> (units: intensity/power).</li>
          <li><b>Finite-time Fourier transform:</b> <span class="eq" style="display:inline; padding:2px 6px; border-radius:10px;">V_T(ν)=∫_{-T/2}^{T/2}U(t)e^{-j2πνt}dt</span>.</li>
          <li><b>PSD definition (time-average limit):</b> <span class="eq" style="display:inline; padding:2px 6px; border-radius:10px;">S(ν)=lim_{T→∞}(1/T)⟨|V_T(ν)|²⟩</span>.</li>
          <li><b>Final theorem (Fourier pair):</b> <span class="eq" style="display:inline; padding:2px 6px; border-radius:10px;">S(ν)=∫_{-∞}^{∞}G(τ)e^{-j2πντ}dτ</span> (two-sided).</li>
          <li><b>Intensity from spectrum:</b> <span class="eq" style="display:inline; padding:2px 6px; border-radius:10px;">I=G(0)=∫_{-∞}^{∞}S(ν)dν</span> (or <span class="eq" style="display:inline; padding:2px 6px; border-radius:10px;">I=∫_0^{∞}S(ν)dν</span> for a one-sided optical spectrum).</li>
        </ul>
      </div>
    </section>

    <!-- PART 0 -->
    <section id="primer" class="fadeIn">
      <div class="card">
        <h3>PART 0 — Concept Primer (Theory Before Solving)</h3>
        <p class="lead">
          In coherence theory and random processes, we often measure a field in time but care about how its power is distributed in frequency.
          The Wiener–Khinchin theorem is the bridge between these views.
        </p>

        <div class="twoCol">
          <div>
            <h4 style="margin:0 0 8px">Core definitions (symbols & units)</h4>

            <div class="eq" data-copy="G(τ)=⟨U*(t)U(t+τ)⟩">
              <div class="mini"><b>Autocorrelation</b> of a stationary complex random process <b>U(t)</b></div>
              G(τ)=⟨U*(t)U(t+τ)⟩
              <button class="copyBtn" type="button">Copy</button>
            </div>

            <ul>
              <li><b>U(t)</b>: complex analytic signal (optics: complex field envelope). If defined so that <b>|U|²</b> is power per area, then <b>G(τ)</b> has the same units as intensity (e.g., W/cm²).</li>
              <li><b>⟨·⟩</b>: ensemble average (or time average under ergodicity).</li>
              <li><b>Stationary</b>: statistics do not change with absolute time, so <b>G</b> depends only on delay <b>τ</b>, not on <b>t</b>.</li>
              <li><b>ν</b>: ordinary frequency in Hz (not angular frequency). The Fourier kernel uses <b>e^{-j2πνt}</b>.</li>
            </ul>
          </div>

          <div>
            <h4 style="margin:0 0 8px">Physical meaning</h4>
            <ul>
              <li><b>G(τ)</b> tells you how similar the field is to itself after delay <b>τ</b>. Fast decay → short coherence time → broad spectrum.</li>
              <li><b>S(ν)</b> (power spectral density) tells you how much average power lies in frequencies near <b>ν</b> (units: intensity per Hz, e.g., W/cm²/Hz).</li>
              <li>The theorem says: <b>spectral distribution is the Fourier transform of temporal similarity.</b></li>
            </ul>

            <div class="callouts">
              <div class="callout ok">
                <strong>When it’s valid</strong>
                <p>
                  Needs (i) wide-sense stationarity (at least second-order), (ii) integrability/finite power conditions so limits exist,
                  and (iii) usual Fourier-transform assumptions (or distributional interpretation in more advanced settings).
                </p>
              </div>
              <div class="callout warn">
                <strong>Common models</strong>
                <p>
                  Gaussian correlation <span class="eq" style="display:inline; padding:2px 6px">G(τ)∝e^{-(τ/τc)²}</span> → Gaussian spectrum.
                  Exponential correlation <span class="eq" style="display:inline; padding:2px 6px">G(τ)∝e^{-|τ|/τc}</span> → Lorentzian spectrum.
                </p>
              </div>
            </div>
          </div>
        </div>

        <div class="hr"></div>

        <h4 style="margin:0 0 8px">Mini intuition examples (no long algebra)</h4>
        <ul>
          <li><b>Perfect monochromatic wave:</b> If the field is perfectly periodic forever, it correlates strongly for all delays → <b>G(τ)</b> does not decay → the spectrum becomes a sharp line.</li>
          <li><b>No memory noise:</b> If the field loses correlation almost immediately, <b>G(τ)</b> is narrow near <b>τ=0</b> → its Fourier transform is broad → wide spectrum.</li>
        </ul>

        <div class="callouts" style="margin-top:14px">
          <div class="callout danger">
            <strong>What to watch for (pitfalls)</strong>
            <p>
              (1) One-sided vs two-sided spectra (factors of 2). (2) Where the ensemble average belongs in the PSD definition.
              (3) Mixing ν (Hz) with ω (rad/s) changes 2π factors. (4) Forgetting that stationarity makes ⟨U(t)U*(t')⟩ depend only on τ=t−t'.
            </p>
          </div>
          <div class="callout">
            <strong>Why windowing appears</strong>
            <p>
              The PSD is defined via a finite observation window T and then taking T→∞. A triangular window factor naturally appears and then disappears in the limit.
            </p>
          </div>
        </div>
      </div>
    </section>

    <!-- PART 1 -->
    <section id="analysis" class="fadeIn">
      <div class="card">
        <h3>PART 1 — Problem Analysis (No Solving Yet)</h3>

        <p class="lead">
          You are given three definitions (numbering as in the prompt) and asked to prove (i) Wiener–Khinchin:
          <b>S(ν) is the Fourier transform of G(τ)</b>, and (ii) the average intensity equals the integral of S(ν).
        </p>

        <h4 style="margin:0 0 8px">Restate the problem in plain words</h4>
        <p>
          For a stationary complex random field <b>U(t)</b>, define an autocorrelation <b>G(τ)</b>, define a finite-time Fourier transform <b>V_T(ν)</b>,
          and define the power spectral density <b>S(ν)</b> as a time-window-normalized limit of |V_T|². Show that the resulting S(ν) equals the
          Fourier transform of G(τ), and deduce that the total average power (intensity) equals the integral of S(ν).
        </p>

        <div class="twoCol">
          <div>
            <h4 style="margin:0 0 8px">Given quantities</h4>
            <ul>
              <li><b>U(t)</b>: stationary complex random process (optical field envelope).</li>
              <li><b>G(τ)=⟨U*(t)U(t+τ)⟩</b> (12.1-4).</li>
              <li><b>V_T(ν)=∫_{-T/2}^{T/2}U(t)e^{-j2πνt}dt</b> (12.1-14).</li>
              <li><b>S(ν)=lim_{T→∞}(1/T)⟨|V_T(ν)|²⟩</b> (12.1-15) (ensemble averaging is the standard interpretation).</li>
            </ul>
          </div>
          <div>
            <h4 style="margin:0 0 8px">Unknowns / What must be proven</h4>
            <ul>
              <li><b>Wiener–Khinchin:</b> <span class="eq" style="display:inline; padding:2px 6px">S(ν)=∫_{-∞}^{∞}G(τ)e^{-j2πντ}dτ</span> (two-sided).</li>
              <li><b>Intensity as spectral area:</b> <span class="eq" style="display:inline; padding:2px 6px">I=G(0)=∫ S(ν)dν</span>, with limits depending on one- vs two-sided convention.</li>
            </ul>
          </div>
        </div>

        <div class="callouts">
          <div class="callout ok">
            <strong>Relevant principles (and why they apply)</strong>
            <p>
              Use (i) stationarity to turn ⟨U(t)U*(t')⟩ into a function of τ=t−t', (ii) expand |V_T|² as a double integral, and (iii) take the large-T limit.
            </p>
          </div>
          <div class="callout warn">
            <strong>Assumptions (explicit)</strong>
            <p>
              Wide-sense stationarity; finite average power so G(0)=⟨|U|²⟩ is finite; exchanging limits and integrals is allowed (standard in this derivation).
            </p>
          </div>
        </div>

        <h4 style="margin:14px 0 8px">Possible approaches (compare briefly)</h4>
        <ul>
          <li><b>Direct double-integral method (best here):</b> expand ⟨|V_T|²⟩, change variables to τ, obtain a triangular window, then let T→∞. <i>Pros:</i> uses exactly the given definitions. <i>Cons:</i> requires careful bookkeeping.</li>
          <li><b>Convolution / Fourier operator method:</b> view time windowing as multiplying by a rectangle; spectrum involves convolution with sinc; then take the limit. <i>Pros:</i> strong signal-processing intuition. <i>Cons:</i> slightly more abstract.</li>
          <li><b>Distributional/measure-theoretic proof:</b> most general form of Wiener–Khinchin. <i>Pros:</i> most rigorous. <i>Cons:</i> beyond typical optics text level.</li>
        </ul>

        <p>
          <b>Chosen approach:</b> the direct double-integral derivation, because it maps one-to-one onto (12.1-4), (12.1-14), (12.1-15)
          and cleanly produces the Fourier-transform relationship.
        </p>
      </div>
    </section>

    <!-- PART 2 -->
    <section id="strategy" class="fadeIn">
      <div class="card">
        <h3>PART 2 — Strategy & Tips (Roadmap Only)</h3>

        <ol style="margin:10px 0 0 22px">
          <li>
            <b>Goal:</b> express ⟨|V_T(ν)|²⟩ in terms of U(t) correlations.<br/>
            <b>Tool:</b> expand magnitude square as product with complex conjugate.<br/>
            <b>Meaning:</b> power in frequency ν comes from time-domain pairings.
          </li>
          <li>
            <b>Goal:</b> rewrite as a double integral over t and t′.<br/>
            <b>Tool:</b> algebra + integral definitions.<br/>
            <b>Meaning:</b> spectrum is built from all time pairs within the window.
          </li>
          <li>
            <b>Goal:</b> apply stationarity to replace ⟨U(t)U*(t′)⟩ with G(t−t′).<br/>
            <b>Tool:</b> G(τ)=⟨U*(t′)U(t′+τ)⟩.<br/>
            <b>Meaning:</b> only the time difference matters.
          </li>
          <li>
            <b>Goal:</b> change variables from (t,t′) to (τ=t−t′, t′) and identify the triangular factor.<br/>
            <b>Tool:</b> geometry of the integration region in the (t,t′) plane.<br/>
            <b>Meaning:</b> finite observation time “weights” long delays less.
          </li>
          <li>
            <b>Goal:</b> divide by T and take T→∞ to remove the triangular factor.<br/>
            <b>Tool:</b> limit argument: (1−|τ|/T)→1 for fixed τ as T→∞.<br/>
            <b>Meaning:</b> infinite observation sees all delays equally.
          </li>
          <li>
            <b>Goal:</b> deduce intensity formula by evaluating inverse transform at τ=0.<br/>
            <b>Tool:</b> Fourier inversion (or use δ identity).<br/>
            <b>Meaning:</b> total spectral area equals average power.
          </li>
        </ol>

        <div class="callouts">
          <div class="callout danger">
            <strong>Common mistakes</strong>
            <p>
              Dropping the ensemble average; mixing ν and ω; forgetting that ⟨U(t)U*(t′)⟩ = G(t−t′) (not G(t′−t) unless conjugated);
              and using 0..∞ limits without stating one-sided convention.
            </p>
          </div>
          <div class="callout">
            <strong>Quick tips</strong>
            <p>
              Draw the square window in the (t,t′) plane. The length of the intersection at fixed τ is exactly (T−|τ|), giving the triangular factor.
            </p>
          </div>
        </div>
      </div>
    </section>

    <!-- PART 3 -->
    <section id="solution" class="fadeIn">
      <div class="card">
        <h3>PART 3 — Full Solution (Detailed + Teaching)</h3>

        <h4 style="margin:0 0 8px">Physical intuition before the math</h4>
        <p>
          If the field stays correlated for a long time (large coherence time), it has a well-defined frequency → a narrow spectrum.
          If it decorrelates quickly, it contains many frequencies → a broad spectrum. Mathematically, “long in time” ↔ “narrow in frequency”
          is exactly the Fourier-transform duality that the theorem formalizes.
        </p>

        <div class="hr"></div>

        <h4 style="margin:0 0 8px">Step 1 — Write down the given definitions</h4>

        <div class="eq" data-copy="G(τ)=⟨U*(t)U(t+τ)⟩">
          <div class="mini">(12.1-4) Autocorrelation of stationary U(t)</div>
          G(τ)=⟨U*(t)U(t+τ)⟩
          <button class="copyBtn" type="button">Copy</button>
        </div>

        <div class="eq" data-copy="V_T(ν)=∫_{-T/2}^{T/2} U(t) e^{-j2πνt} dt">
          <div class="mini">(12.1-14) Finite-time Fourier transform over window length T</div>
          V_T(ν)=∫_{-T/2}^{T/2} U(t) e^{-j2πνt} dt
          <button class="copyBtn" type="button">Copy</button>
        </div>

        <div class="eq" data-copy="S(ν)=lim_{T→∞} (1/T) ⟨|V_T(ν)|²⟩">
          <div class="mini">(12.1-15) Power spectral density (PSD) via time-window limit</div>
          S(ν)=lim_{T→∞} (1/T) ⟨|V_T(ν)|²⟩
          <button class="copyBtn" type="button">Copy</button>
        </div>

        <p>
          <b>Note on averaging:</b> Many optics texts write <span class="eq" style="display:inline; padding:2px 6px">S(ν)=lim (1/T)|V_T|²</span>
          with the understanding that an ensemble/time average is implied for random fields. We will keep ⟨·⟩ explicitly because the proof uses it.
        </p>

        <div class="hr"></div>

        <h4 style="margin:0 0 8px">Step 2 — Expand the squared magnitude as a double integral</h4>
        <p>
          Start from <span class="eq" style="display:inline; padding:2px 6px">|V_T(ν)|² = V_T(ν) V_T*(ν)</span>. Using the definition of <b>V_T</b>:
        </p>

        <div class="eq" data-copy="|V_T(ν)|² = ∫_{-T/2}^{T/2}∫_{-T/2}^{T/2} U(t) U*(t') e^{-j2πν(t-t')} dt dt'">
          |V_T(ν)|²
          = \n  (∫_{-T/2}^{T/2} U(t)e^{-j2πνt}dt)\n  (∫_{-T/2}^{T/2} U*(t')e^{+j2πνt'}dt')\n
          = ∫_{-T/2}^{T/2}∫_{-T/2}^{T/2} U(t) U*(t') e^{-j2πν(t-t')} dt dt'
          <button class="copyBtn" type="button">Copy</button>
        </div>

        <p>
          <b>What we did:</b> multiplied the integral by its conjugate and combined them into a double integral.
          <b>Why:</b> this makes the correlation ⟨U(t)U*(t′)⟩ appear naturally.
        </p>

        <div class="hr"></div>

        <h4 style="margin:0 0 8px">Step 3 — Take the ensemble average and use stationarity</h4>
        <p>
          Take ⟨·⟩ of both sides:
        </p>

        <div class="eq" data-copy="⟨|V_T(ν)|²⟩ = ∫∫ ⟨U(t)U*(t')⟩ e^{-j2πν(t-t')} dt dt'">
          ⟨|V_T(ν)|²⟩
          = ∫_{-T/2}^{T/2}∫_{-T/2}^{T/2} ⟨U(t)U*(t')⟩ e^{-j2πν(t-t')} dt dt'
          <button class="copyBtn" type="button">Copy</button>
        </div>

        <p>
          Now relate ⟨U(t)U*(t′)⟩ to <b>G(τ)</b>. From the definition
          <span class="eq" style="display:inline; padding:2px 6px">G(τ)=⟨U*(t′)U(t′+τ)⟩</span>,
          choose <span class="eq" style="display:inline; padding:2px 6px">τ=t−t′</span>, so <span class="eq" style="display:inline; padding:2px 6px">t=t′+τ</span>. Then:
        </p>

        <div class="eq" data-copy="⟨U(t)U*(t')⟩ = G(t-t')">
          ⟨U(t)U*(t')⟩ = ⟨U*(t')U(t'+(t-t'))⟩ = G(t-t')
          <button class="copyBtn" type="button">Copy</button>
        </div>

        <p>
          <b>What we did:</b> used stationarity to assert dependence only on time difference.
          <b>Why:</b> Wiener–Khinchin is fundamentally a stationarity result (second-order).
        </p>

        <div class="hr"></div>

        <h4 style="margin:0 0 8px">Step 4 — Change variables and expose the triangular window</h4>
        <p>
          Substitute ⟨U(t)U*(t′)⟩ = G(t−t′) and define the delay variable
          <span class="eq" style="display:inline; padding:2px 6px">τ=t−t′</span>. Then:
        </p>

        <div class="eq" data-copy="⟨|V_T(ν)|²⟩ = ∫_{-T/2}^{T/2}∫_{-T/2}^{T/2} G(t-t') e^{-j2πν(t-t')} dt dt'">
          ⟨|V_T(ν)|²⟩
          = ∫_{-T/2}^{T/2}∫_{-T/2}^{T/2} G(t-t') e^{-j2πν(t-t')} dt dt'
          <button class="copyBtn" type="button">Copy</button>
        </div>

        <p>
          Think geometrically in the (t,t′) plane: the integration region is a square of side T.
          For a fixed delay τ=t−t′, the set of points in the square with that τ is a diagonal line segment whose length is (T−|τ|).
          Therefore, the double integral reduces to a single integral:
        </p>

        <div class="eq" data-copy="⟨|V_T(ν)|²⟩ = ∫_{-T}^{T} (T-|τ|) G(τ) e^{-j2πντ} dτ">
          ⟨|V_T(ν)|²⟩ = ∫_{-T}^{T} (T-|τ|)\, G(τ)\, e^{-j2πντ} dτ
          <button class="copyBtn" type="button">Copy</button>
        </div>

        <p>
          <b>What we did:</b> replaced the square-domain double integral with an integral over delays weighted by the available overlap time.
          <b>Why:</b> finite windows cannot “see” correlations at very large |τ| because there is less overlap between U(t) and U(t+τ).
        </p>

        <div class="callouts">
          <div class="callout">
            <strong>Where (T−|τ|) comes from</strong>
            <p>
              For a given τ, valid t′ values must satisfy both t′∈[−T/2,T/2] and t=t′+τ ∈[−T/2,T/2].
              The intersection interval has length T−|τ| (for |τ|≤T), and zero otherwise.
            </p>
          </div>
          <div class="callout warn">
            <strong>Triangular window factor</strong>
            <p>
              Dividing by T gives (1−|τ|/T), a triangle that tends to 1 pointwise as T→∞. This is the key limit step.
            </p>
          </div>
        </div>

        <div class="hr"></div>

        <h4 style="margin:0 0 8px">Step 5 — Divide by T and take the limit to obtain the Fourier transform</h4>
        <p>
          From the PSD definition:
        </p>

        <div class="eq" data-copy="S(ν)=lim_{T→∞} (1/T) ⟨|V_T(ν)|²⟩ = lim_{T→∞} ∫_{-T}^{T} (1-|τ|/T) G(τ) e^{-j2πντ} dτ">
          S(ν)=lim_{T→∞} (1/T) ⟨|V_T(ν)|²⟩\n
          = lim_{T→∞} ∫_{-T}^{T} (1-|τ|/T)\, G(τ)\, e^{-j2πντ} dτ
          <button class="copyBtn" type="button">Copy</button>
        </div>

        <p>
          As T→∞, for each fixed τ we have (1−|τ|/T)→1, and the integration range expands to all τ.
          Under standard finite-power assumptions, we can pass to the limit to obtain:
        </p>

        <div class="eq" data-copy="S(ν)=∫_{-∞}^{∞} G(τ) e^{-j2πντ} dτ">
          <div class="mini"><b>Wiener–Khinchin (two-sided frequency)</b></div>
          S(ν)=∫_{-∞}^{∞} G(τ)\, e^{-j2πντ}\, dτ
          <button class="copyBtn" type="button">Copy</button>
        </div>

        <p>
          <b>Interpretation:</b> the PSD is the Fourier transform of the autocorrelation.
          If G(τ) is real and even (common for many optical field models of stationary fluctuations),
          then S(ν) is also real and nonnegative.
        </p>

        <div class="hr"></div>

        <h4 style="margin:0 0 8px">Step 6 — Show that intensity equals the integral of the spectrum</h4>
        <p>
          The average intensity (average power per area) is:
        </p>

        <div class="eq" data-copy="I=⟨|U(t)|²⟩=G(0)">
          I=⟨|U(t)|²⟩ = ⟨U*(t)U(t)⟩ = G(0)
          <button class="copyBtn" type="button">Copy</button>
        </div>

        <p>
          Use the inverse Fourier relation for the pair (with the same 2π convention):
        </p>

        <div class="eq" data-copy="G(τ)=∫_{-∞}^{∞} S(ν) e^{+j2πντ} dν">
          G(τ)=∫_{-∞}^{∞} S(ν)\, e^{+j2πντ}\, dν
          <button class="copyBtn" type="button">Copy</button>
        </div>

        <p>
          Set τ=0:
        </p>

        <div class="eq" data-copy="G(0)=∫_{-∞}^{∞} S(ν) dν  ⇒  I=∫_{-∞}^{∞} S(ν) dν">
          G(0)=∫_{-∞}^{∞} S(ν)\, dν \n
          ⇒ I=∫_{-∞}^{∞} S(ν)\, dν
          <button class="copyBtn" type="button">Copy</button>
        </div>

        <p>
          <b>One-sided convention (as in many optics texts):</b>
          if S(ν) is defined only for ν≥0 as the “intensity spectral density,” then:
          <span class="eq" style="display:inline; padding:2px 6px">I=∫_0^{∞} S(ν)\, dν</span>.
          This matches the prompt’s equation (12.1-16).
        </p>

        <div class="callouts">
          <div class="callout finalBox">
            <strong>Final Answer (boxed)</strong>
            <p>
              <span class="eq" data-copy="S(ν)=∫_{-∞}^{∞}G(τ)e^{-j2πντ}dτ;   I=G(0)=∫ S(ν)dν (two-sided) or I=∫_0^∞ S(ν)dν (one-sided).">S(ν)=∫_{-∞}^{∞}G(τ)e^{-j2πντ}dτ
I=G(0)=∫_{-∞}^{∞}S(ν)dν  (two-sided)
or  I=∫_0^{∞}S(ν)dν  (one-sided)</span>
            </p>
          </div>
          <div class="callout ok">
            <strong>Sanity checks</strong>
            <p>
              <b>Units:</b> G has units of intensity; S has units intensity/Hz; integrating S over Hz returns intensity. <br/>
              <b>Limits:</b> longer coherence (slower decay of G) → narrower S (seen in the interactive plots below).
            </p>
          </div>
        </div>

        <p style="margin-top:12px">
          <b>Connection to the diagrams and plots:</b>
          The diagram shows the finite observation window T that leads to the overlap factor (T−|τ|).
          The main plot numerically compares G(τ) and its Fourier transform S(ν) for a chosen correlation model; the secondary plot shows how changing coherence time τc reshapes the spectrum (time–frequency duality).
        </p>
      </div>
    </section>

    <!-- VISUALIZATION SECTION (still part of solution learning flow) -->
    <section class="fadeIn" aria-label="Interactive visualizations">
      <div class="card">
        <h3>Interactive Visualizations</h3>
        <p class="lead">
          The plots use <b>example values</b> (dimensionless intensity scale I₀=1) to visualize the theorem.
          The mathematics in the proof above remains fully symbolic.
        </p>

        <div class="controls" role="group" aria-label="Controls for plots">
          <label>
            Coherence time
            <span class="eq" style="display:inline; padding:2px 6px; border-radius:10px;">τc</span>
            <input id="tauSlider" type="range" min="0.2" max="5.0" value="1.2" step="0.05" />
            <span id="tauRead" class="readout">τc = 1.20 s</span>
          </label>

          <label>
            Correlation model
            <select id="modelSel" aria-label="Correlation model">
              <option value="gauss" selected>Gaussian: G(τ)=I₀ exp(-(τ/τc)²)</option>
              <option value="exp">Exponential: G(τ)=I₀ exp(-|τ|/τc)</option>
            </select>
          </label>

          <button id="resetBtn" class="small" type="button">Reset view</button>

          <span id="consistency" class="readout" title="Numerical check of I ≈ ∫ S(ν) dν">I check: …</span>
        </div>

        <figure>
          <canvas id="diagramCanvas" aria-label="Diagram: finite time window and delay overlap"></canvas>
          <div class="canvasCaption">
            <b>Diagram:</b> A stationary field U(t) is observed over a finite time window T; the overlap for delay τ produces the triangular weight (T−|τ|).
          </div>
        </figure>

        <div class="twoCol" style="margin-top:12px">
          <figure>
            <canvas id="mainCanvas" aria-label="Main plot: autocorrelation G(τ) and spectrum S(ν)"></canvas>
            <div class="canvasCaption">
              <b>Main plot:</b> Left axis shows <span class="eq" style="display:inline; padding:2px 6px;">G(τ)</span> vs delay τ (s).
              Right side shows <span class="eq" style="display:inline; padding:2px 6px;">S(ν)</span> vs frequency ν (Hz). (Both normalized to I₀=1.)
            </div>
          </figure>

          <figure>
            <canvas id="secondaryCanvas" aria-label="Secondary plot: bandwidth vs coherence time"></canvas>
            <div class="canvasCaption">
              <b>Secondary plot:</b> Parameter sweep: an estimate of spectral width vs coherence time τc, illustrating “shorter coherence → broader spectrum.”
            </div>
          </figure>
        </div>
      </div>
    </section>

    <!-- PART 4 -->
    <section id="deeper" class="fadeIn">
      <div class="card">
        <h3>PART 4 — Deeper Understanding (Theory Around the Result)</h3>

        <h4 style="margin:0 0 8px">Re-interpreting the final formula</h4>
        <ul>
          <li><b>G(τ)</b> encodes temporal memory; its decay rate sets the scale of frequency spread.</li>
          <li>The Fourier kernel <span class="eq" style="display:inline; padding:2px 6px">e^{-j2πντ}</span> “tests” how much correlation oscillates at frequency ν.</li>
          <li><b>S(ν)≥0</b> (for valid PSDs) because it comes from a squared magnitude in the definition: it is power-per-Hz.</li>
        </ul>

        <h4 style="margin:14px 0 8px">How changing parameters affects the outcome (connect to plots)</h4>
        <ul>
          <li>Increasing <b>τc</b> makes <b>G(τ)</b> broader in τ, so its Fourier transform <b>S(ν)</b> becomes narrower in ν.</li>
          <li>Gaussian vs exponential correlation changes spectral “tails”: exponential correlation produces a Lorentzian spectrum with heavier tails than a Gaussian.</li>
          <li>The numerical readout “I check” verifies <span class="eq" style="display:inline; padding:2px 6px">I=G(0)≈∫S(ν)dν</span> (within numerical truncation error).</li>
        </ul>

        <h4 style="margin:14px 0 8px">Alternative derivation idea (brief)</h4>
        <p>
          A common signal-processing route: define the windowed process <span class="eq" style="display:inline; padding:2px 6px">U_T(t)=U(t)·rect(t/T)</span>.
          Its Fourier transform is V_T(ν). Then ⟨|V_T|²⟩ relates to the convolution of the true PSD with the window spectrum (sinc²).
          As T→∞, the window spectrum narrows to a delta, recovering S(ν) as the transform of G(τ).
        </p>

        <h4 style="margin:14px 0 8px">Concept checks (self-test)</h4>
        <ul>
          <li><b>Q:</b> If G(τ) decays twice as fast, what happens to S(ν)? <b>A:</b> It broadens (roughly doubles its characteristic width).</li>
          <li><b>Q:</b> What is G(0)? <b>A:</b> The mean intensity/power: ⟨|U|²⟩.</li>
          <li><b>Q:</b> Why is S(ν) nonnegative? <b>A:</b> It’s the limit of (1/T)⟨|V_T|²⟩, a squared magnitude average.</li>
          <li><b>Q:</b> Where do “factor of 2” confusions come from? <b>A:</b> One-sided (ν≥0) vs two-sided (ν∈ℝ) definitions of spectral density.</li>
        </ul>
      </div>
    </section>

    <!-- PART 5 -->
    <section id="viz" class="fadeIn">
      <div class="card">
        <h3>PART 5 — Visualization Guide (How to Read the Plots)</h3>

        <h4 style="margin:0 0 8px">What each canvas shows</h4>
        <ul>
          <li><b>Diagram canvas:</b> The finite time window [−T/2, T/2] and how a delay τ reduces overlap length to (T−|τ|). This is the geometric origin of the triangular factor in the proof.</li>
          <li><b>Main plot:</b> The chosen model autocorrelation G(τ) and the numerically computed spectrum S(ν)=∫G(τ)e^{-j2πντ}dτ (displayed for ν≥0). Axes include units (τ in seconds, ν in Hz).</li>
          <li><b>Secondary plot:</b> A sweep over τc showing a bandwidth proxy (RMS frequency width) versus τc. It should decrease approximately like 1/τc.</li>
        </ul>

        <h4 style="margin:14px 0 8px">Interactive controls</h4>
        <ul>
          <li><b>Coherence time slider (τc):</b> updates the model correlation function; all plots update live. Increasing τc broadens G(τ) and narrows S(ν).</li>
          <li><b>Correlation model selector:</b> switches between Gaussian and exponential correlation, changing the spectrum shape (Gaussian vs Lorentzian-like tails).</li>
          <li><b>Reset view:</b> returns τc and model to default values.</li>
        </ul>

        <div class="callouts">
          <div class="callout warn">
            <strong>Numerical note</strong>
            <p>
              The Fourier integral is approximated on a finite τ range and ν range, so the intensity check is approximate.
              Increasing τc requires a larger τ range to keep the same accuracy; the code adapts the range automatically.
            </p>
          </div>
          <div class="callout ok">
            <strong>What you should see</strong>
            <p>
              As you slide τc upward: main-plot spectrum peak stays near ν=0 but the curve tightens (narrower). Secondary plot point moves down (smaller bandwidth).
            </p>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer class="fadeIn">
    Built as a self-contained learning article: proof + intuition + interactive verification (no external libraries).
  </footer>

  <div id="toast" class="copyToast" aria-live="polite">Copied.</div>

  <script>
    // --------------------------
    // Utilities: copy + toast
    // --------------------------
    const toast = document.getElementById('toast');
    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>toast.classList.remove('show'), 1100);
    }
    function copyText(t){
      navigator.clipboard.writeText(t).then(()=>showToast("Copied to clipboard"))
        .catch(()=>showToast("Copy failed (browser permission)"));
    }
    document.querySelectorAll('.eq').forEach(eq=>{
      const btn = eq.querySelector('.copyBtn');
      if(!btn) return;
      btn.addEventListener('click', ()=>{
        const txt = eq.getAttribute('data-copy') || eq.textContent.replace("Copy","").trim();
        copyText(txt);
      });
    });

    // --------------------------
    // Canvas helpers (HiDPI)
    // --------------------------
    function setupCanvas(canvas){
      const ctx = canvas.getContext('2d');
      function resize(){
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        const w = Math.max(1, Math.floor(rect.width * dpr));
        const h = Math.max(1, Math.floor(rect.height * dpr));
        if(canvas.width !== w || canvas.height !== h){
          canvas.width = w; canvas.height = h;
        }
        ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      }
      return {ctx, resize};
    }

    function clear(ctx, w, h){
      ctx.clearRect(0,0,w,h);
    }

    function drawPanelBg(ctx, w, h){
      // subtle grid background
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.fillStyle = 'rgba(10,15,30,.55)';
      ctx.fillRect(0,0,w,h);

      const step = 28;
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(185,198,255,.08)';
      for(let x=0; x<=w; x+=step){
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
      }
      for(let y=0; y<=h; y+=step){
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
      }
      ctx.restore();
    }

    function niceTicks(min, max, target=6){
      const span = max - min;
      if(span <= 0) return {step:1, ticks:[min]};
      const raw = span / target;
      const pow = Math.pow(10, Math.floor(Math.log10(raw)));
      const choices = [1,2,2.5,5,10].map(m=>m*pow);
      let step = choices.reduce((a,b)=>Math.abs(b-raw)<Math.abs(a-raw)?b:a, choices[0]);
      const start = Math.ceil(min/step)*step;
      const ticks=[];
      for(let v=start; v<=max+1e-9; v+=step) ticks.push(v);
      return {step, ticks};
    }

    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
      const {x,y,w,h} = box;

      // Title
      ctx.save();
      ctx.fillStyle = 'rgba(234,240,255,.95)';
      ctx.font = '600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(title, x+10, y+20);

      // Frame
      ctx.strokeStyle = 'rgba(185,198,255,.20)';
      ctx.lineWidth = 1;
      ctx.strokeRect(x,y,w,h);

      // Grid + ticks
      const padL=52, padR=16, padT=30, padB=40;
      const plot = {x:x+padL, y:y+padT, w:w-padL-padR, h:h-padT-padB};

      // grid
      ctx.strokeStyle = 'rgba(185,198,255,.10)';
      ctx.lineWidth = 1;

      const xt = niceTicks(xMin, xMax, 6).ticks;
      const yt = niceTicks(yMin, yMax, 6).ticks;

      for(const xv of xt){
        const px = plot.x + (xv-xMin)/(xMax-xMin)*plot.w;
        ctx.beginPath(); ctx.moveTo(px, plot.y); ctx.lineTo(px, plot.y+plot.h); ctx.stroke();
      }
      for(const yv of yt){
        const py = plot.y + plot.h - (yv-yMin)/(yMax-yMin)*plot.h;
        ctx.beginPath(); ctx.moveTo(plot.x, py); ctx.lineTo(plot.x+plot.w, py); ctx.stroke();
      }

      // axes
      ctx.strokeStyle = 'rgba(185,198,255,.28)';
      ctx.lineWidth = 1.2;
      ctx.beginPath(); ctx.moveTo(plot.x, plot.y); ctx.lineTo(plot.x, plot.y+plot.h); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(plot.x, plot.y+plot.h); ctx.lineTo(plot.x+plot.w, plot.y+plot.h); ctx.stroke();

      // tick labels
      ctx.fillStyle = 'rgba(185,198,255,.85)';
      ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';

      for(const xv of xt){
        const px = plot.x + (xv-xMin)/(xMax-xMin)*plot.w;
        const lbl = formatNum(xv);
        ctx.fillText(lbl, px-ctx.measureText(lbl).width/2, plot.y+plot.h+16);
        ctx.beginPath();
        ctx.moveTo(px, plot.y+plot.h); ctx.lineTo(px, plot.y+plot.h+5);
        ctx.stroke();
      }

      for(const yv of yt){
        const py = plot.y + plot.h - (yv-yMin)/(yMax-yMin)*plot.h;
        const lbl = formatNum(yv);
        ctx.fillText(lbl, plot.x-10-ctx.measureText(lbl).width, py+4);
        ctx.beginPath();
        ctx.moveTo(plot.x-5, py); ctx.lineTo(plot.x, py);
        ctx.stroke();
      }

      // axis labels
      ctx.fillStyle = 'rgba(234,240,255,.90)';
      ctx.font = '600 12.5px ui-sans-serif, system-ui';
      ctx.fillText(xLabel, plot.x + plot.w/2 - ctx.measureText(xLabel).width/2, y + h - 10);

      // y label rotated
      ctx.save();
      ctx.translate(x+14, plot.y + plot.h/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
      ctx.restore();

      ctx.restore();
      return plot;
    }

    function formatNum(v){
      const av = Math.abs(v);
      if(av >= 1000) return v.toFixed(0);
      if(av >= 100) return v.toFixed(0);
      if(av >= 10) return v.toFixed(1);
      if(av >= 1) return v.toFixed(2);
      if(av >= 0.1) return v.toFixed(3);
      return v.toFixed(4);
    }

    function polyline(ctx, plot, xs, ys, xMin, xMax, yMin, yMax, strokeStyle, lineWidth=2){
      ctx.save();
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = lineWidth;
      ctx.beginPath();
      for(let i=0;i<xs.length;i++){
        const px = plot.x + (xs[i]-xMin)/(xMax-xMin)*plot.w;
        const py = plot.y + plot.h - (ys[i]-yMin)/(yMax-yMin)*plot.h;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawLegend(ctx, x, y, items){
      ctx.save();
      ctx.font = '12.5px ui-sans-serif, system-ui';
      let yy = y;
      for(const it of items){
        ctx.strokeStyle = it.color;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(x,yy); ctx.lineTo(x+18,yy); ctx.stroke();
        ctx.fillStyle = 'rgba(234,240,255,.92)';
        ctx.fillText(it.label, x+26, yy+4);
        yy += 18;
      }
      ctx.restore();
    }

    // --------------------------
    // Numerical model: G(τ) and S(ν)
    // --------------------------
    function computeCorrelation(tau, tauC, model, I0=1){
      if(model === 'exp'){
        return I0 * Math.exp(-Math.abs(tau)/tauC);
      }
      // Gaussian
      const u = tau/tauC;
      return I0 * Math.exp(-u*u);
    }

    function trapz(xs, ys){
      let s = 0;
      for(let i=0;i<xs.length-1;i++){
        const dx = xs[i+1]-xs[i];
        s += 0.5*dx*(ys[i]+ys[i+1]);
      }
      return s;
    }

    // Compute one-sided S(ν) (ν>=0) from even real G(τ) via cosine transform:
    // S(ν) = ∫_{-∞}^{∞} G(τ) e^{-j2πντ} dτ = 2∫_0^∞ G(τ) cos(2πντ) dτ
    function computeSpectrumOneSided(tauC, model, I0=1){
      // adaptive ranges
      const tauMax = 10 * tauC;        // capture correlation tail
      const Ntau = 2401;               // odd for symmetric convenience
      const dt = (2*tauMax)/(Ntau-1);
      const tau = new Array(Ntau);
      const G = new Array(Ntau);
      for(let i=0;i<Ntau;i++){
        tau[i] = -tauMax + i*dt;
        G[i] = computeCorrelation(tau[i], tauC, model, I0);
      }

      // frequency range: widen enough so area integral stabilizes
      const nuMax = 20 / tauC;         // Hz
      const Nnu = 900;
      const nu = new Array(Nnu);
      const S = new Array(Nnu);

      // use only τ>=0 for cosine transform
      const half = Math.floor(Ntau/2);
      const tauPos = new Array(half+1);
      const Gpos = new Array(half+1);
      for(let i=0;i<=half;i++){
        tauPos[i] = i*dt;           // from 0 to tauMax
        Gpos[i] = computeCorrelation(tauPos[i], tauC, model, I0);
      }

      for(let k=0;k<Nnu;k++){
        const f = (k/(Nnu-1))*nuMax;
        nu[k] = f;
        // integrate 2∫_0^{tauMax} G(τ) cos(2π f τ) dτ
        let acc = 0;
        for(let i=0;i<tauPos.length-1;i++){
          const t0 = tauPos[i], t1 = tauPos[i+1];
          const g0 = Gpos[i], g1 = Gpos[i+1];
          const c0 = Math.cos(2*Math.PI*f*t0);
          const c1 = Math.cos(2*Math.PI*f*t1);
          const y0 = g0*c0;
          const y1 = g1*c1;
          acc += 0.5*(t1-t0)*(y0+y1);
        }
        S[k] = 2*acc; // one-sided plot uses ν>=0 values of the two-sided transform
        // numerical noise can create tiny negatives; keep visible but clamp very slightly
        if(S[k] < -1e-8) S[k] = S[k]; // leave it
      }

      // intensity check:
      // two-sided identity: I = G(0) = ∫_{-∞}^{∞} S_two(ν) dν
      // if we only compute/plot ν>=0 of S_two, then I ≈ 2∫_0^∞ S_two(ν) dν
      // But many optics texts define one-sided S_1(ν)=2 S_two(ν) for ν>=0, giving I=∫_0^∞ S_1(ν) dν.
      // Here our S array is S_two evaluated for ν>=0 (cosine transform), so:
      const I_fromG0 = computeCorrelation(0, tauC, model, I0);
      const area0inf = trapz(nu, S);
      const I_fromS_twosided = 2*area0inf;

      return {
        tau, G,
        nu, S,
        tauMax, nuMax,
        I_fromG0, I_fromS_twosided
      };
    }

    function rmsBandwidth(nu, S){
      // Use weighted RMS around mean frequency (for nonnegative ν):
      // mu = ∫ ν S dν / ∫ S dν, sigma = sqrt( ∫ (ν-mu)^2 S dν / ∫ S dν )
      const area = trapz(nu, S);
      if(area <= 0) return 0;

      // compute mu
      let num = 0;
      for(let i=0;i<nu.length-1;i++){
        const dx = nu[i+1]-nu[i];
        const y0 = nu[i]*S[i];
        const y1 = nu[i+1]*S[i+1];
        num += 0.5*dx*(y0+y1);
      }
      const mu = num/area;

      // compute second central moment
      let m2 = 0;
      for(let i=0;i<nu.length-1;i++){
        const dx = nu[i+1]-nu[i];
        const y0 = (nu[i]-mu)*(nu[i]-mu)*S[i];
        const y1 = (nu[i+1]-mu)*(nu[i+1]-mu)*S[i+1];
        m2 += 0.5*dx*(y0+y1);
      }
      return Math.sqrt(Math.max(0, m2/area));
    }

    // --------------------------
    // Drawing: Diagram
    // --------------------------
    function drawDiagram(canvas, state){
      const {ctx, resize} = setupCanvas(canvas);
      resize();
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;
      clear(ctx, w, h);
      drawPanelBg(ctx, w, h);

      // Frame
      ctx.save();
      ctx.strokeStyle = 'rgba(185,198,255,.20)';
      ctx.lineWidth = 1;
      ctx.strokeRect(10, 10, w-20, h-20);

      // Title
      ctx.fillStyle = 'rgba(234,240,255,.95)';
      ctx.font = '600 14px ui-sans-serif, system-ui';
      ctx.fillText('Finite window T and overlap length (T−|τ|)', 22, 32);

      const left = 44, right = w-44;
      const midY = h*0.55;

      // Time axis line
      ctx.strokeStyle = 'rgba(185,198,255,.35)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(left, midY);
      ctx.lineTo(right, midY);
      ctx.stroke();

      // window endpoints
      const T = 1; // normalized for drawing
      const x0 = left + (right-left)*0.15;
      const x1 = left + (right-left)*0.85;

      // window rectangle
      ctx.fillStyle = 'rgba(142,230,255,.10)';
      ctx.strokeStyle = 'rgba(142,230,255,.40)';
      ctx.lineWidth = 2;
      ctx.fillRect(x0, midY-34, x1-x0, 68);
      ctx.strokeRect(x0, midY-34, x1-x0, 68);

      // labels -T/2, T/2
      ctx.fillStyle = 'rgba(185,198,255,.90)';
      ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
      ctx.fillText('−T/2', x0-16, midY+56);
      ctx.fillText('+T/2', x1-10, midY+56);

      // Draw delayed window
      const tauDraw = Math.min(0.45, Math.max(-0.45, (state.tauC-1.2)/3)); // just for visual change with τc
      const shift = (x1-x0)*tauDraw;
      const dx = shift;

      ctx.fillStyle = 'rgba(184,255,176,.10)';
      ctx.strokeStyle = 'rgba(184,255,176,.45)';
      ctx.lineWidth = 2;
      ctx.fillRect(x0+dx, midY-90, x1-x0, 40);
      ctx.strokeRect(x0+dx, midY-90, x1-x0, 40);

      // Overlap region
      const ov0 = Math.max(x0, x0+dx);
      const ov1 = Math.min(x1, x1+dx);
      const overlap = Math.max(0, ov1-ov0);

      ctx.fillStyle = 'rgba(255,210,122,.14)';
      ctx.strokeStyle = 'rgba(255,210,122,.55)';
      ctx.lineWidth = 1.5;
      if(overlap>0){
        ctx.fillRect(ov0, midY-90, overlap, 40);
        ctx.strokeRect(ov0, midY-90, overlap, 40);
      }

      // Arrows + τ label
      ctx.strokeStyle = 'rgba(234,240,255,.75)';
      ctx.lineWidth = 2;
      const ax0 = x0 + (x1-x0)*0.55;
      ctx.beginPath();
      ctx.moveTo(ax0, midY-110);
      ctx.lineTo(ax0+dx, midY-110);
      ctx.stroke();
      // arrowheads
      function arrowhead(x,y,dir){
        ctx.beginPath();
        ctx.moveTo(x,y);
        ctx.lineTo(x-8*dir, y-5);
        ctx.lineTo(x-8*dir, y+5);
        ctx.closePath();
        ctx.fillStyle = 'rgba(234,240,255,.75)';
        ctx.fill();
      }
      arrowhead(ax0+dx, midY-110, Math.sign(dx)||1);

      ctx.fillStyle = 'rgba(234,240,255,.92)';
      ctx.font = '600 12.5px ui-sans-serif, system-ui';
      ctx.fillText('delay τ', Math.min(ax0, ax0+dx)+Math.abs(dx)/2 - 18, midY-118);

      // Explanatory text
      ctx.fillStyle = 'rgba(185,198,255,.88)';
      ctx.font = '12.5px ui-sans-serif, system-ui';
      ctx.fillText('Original window: U(t) on [−T/2, T/2]', 22, 56);
      ctx.fillText('Shifted copy: U(t+τ) (overlap length = T−|τ|)', 22, 76);
      ctx.fillText('This overlap weight becomes (1−|τ|/T) after dividing by T.', 22, 96);

      // Overlap value display (normalized)
      ctx.fillStyle = 'rgba(255,210,122,.95)';
      ctx.font = '600 12px ui-monospace, Menlo, Consolas, monospace';
      const frac = (x1-x0)>0 ? overlap/(x1-x0) : 0;
      ctx.fillText(`Overlap fraction ≈ ${(frac).toFixed(2)}  (illustrative)`, 22, h-22);

      ctx.restore();
    }

    // --------------------------
    // Drawing: Main plot (G and S)
    // --------------------------
    function drawMainPlot(canvas, state, data){
      const {ctx, resize} = setupCanvas(canvas);
      resize();
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;
      clear(ctx, w, h);
      drawPanelBg(ctx, w, h);

      // split into two plots side-by-side inside one canvas for clarity
      const margin = 12;
      const gap = 10;
      const boxW = (w - 2*margin - gap)/2;
      const boxH = h - 2*margin;
      const leftBox = {x: margin, y: margin, w: boxW, h: boxH};
      const rightBox = {x: margin + boxW + gap, y: margin, w: boxW, h: boxH};

      // Left: G(τ)
      const tau = data.tau;
      const G = data.G;

      // show limited range around 0 for readability
      const tauView = Math.min(data.tauMax, 6*state.tauC);
      const xMin1 = -tauView, xMax1 = tauView;

      // filter arrays for view
      const xs1=[], ys1=[];
      for(let i=0;i<tau.length;i++){
        if(tau[i] >= xMin1 && tau[i] <= xMax1){
          xs1.push(tau[i]);
          ys1.push(G[i]);
        }
      }
      const yMin1 = 0;
      const yMax1 = 1.05 * Math.max(...ys1);

      const plot1 = drawAxes(ctx, leftBox, xMin1, xMax1, yMin1, yMax1, 'delay τ (s)', 'G(τ) (arb.)', 'Autocorrelation G(τ)');

      polyline(ctx, plot1, xs1, ys1, xMin1, xMax1, yMin1, yMax1, 'rgba(142,230,255,.95)', 2.6);

      // annotate G(0)
      ctx.save();
      ctx.fillStyle = 'rgba(234,240,255,.92)';
      ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
      ctx.fillText(`G(0)=I₀=${data.I_fromG0.toFixed(2)}`, plot1.x+8, plot1.y+18);
      ctx.restore();

      // Right: S(ν) for ν>=0
      const nu = data.nu;
      const S = data.S;

      const nuView = Math.min(data.nuMax, 8/state.tauC);
      const xMin2 = 0, xMax2 = nuView;

      const xs2=[], ys2=[];
      for(let i=0;i<nu.length;i++){
        if(nu[i] >= xMin2 && nu[i] <= xMax2){
          xs2.push(nu[i]);
          ys2.push(S[i]);
        }
      }
      const yMin2 = Math.min(0, Math.min(...ys2));
      const yMax2 = 1.08 * Math.max(...ys2);

      const plot2 = drawAxes(ctx, rightBox, xMin2, xMax2, yMin2, yMax2, 'frequency ν (Hz)', 'S(ν) (arb./Hz)', 'Spectrum (FT of G)');

      polyline(ctx, plot2, xs2, ys2, xMin2, xMax2, yMin2, yMax2, 'rgba(184,255,176,.95)', 2.6);

      // Legend
      drawLegend(ctx, rightBox.x+18, rightBox.y+42, [
        {color:'rgba(142,230,255,.95)', label:'G(τ)'},
        {color:'rgba(184,255,176,.95)', label:'S(ν) from FT'}
      ]);

      // Consistency note
      ctx.save();
      ctx.fillStyle = 'rgba(185,198,255,.90)';
      ctx.font = '12px ui-sans-serif, system-ui';
      const txt = 'Check: I=G(0) ≈ ∫S(ν)dν (with one-/two-sided factors).';
      ctx.fillText(txt, margin+2, h-6);
      ctx.restore();
    }

    // --------------------------
    // Drawing: Secondary plot (bandwidth vs τc sweep)
    // --------------------------
    function drawSecondaryPlot(canvas, state){
      const {ctx, resize} = setupCanvas(canvas);
      resize();
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;
      clear(ctx, w, h);
      drawPanelBg(ctx, w, h);

      const box = {x: 12, y: 12, w: w-24, h: h-24};

      // sweep τc range
      const tauMin = 0.2, tauMax = 5.0;
      const N = 42;
      const taus=[], bw=[];
      for(let i=0;i<N;i++){
        const tc = tauMin + (tauMax - tauMin) * (i/(N-1));
        const d = computeSpectrumOneSided(tc, state.model, 1);
        // Use ν>=0 portion of S_two; RMS bandwidth computed on ν>=0 is fine as a proxy
        const sigma = rmsBandwidth(d.nu, d.S);
        taus.push(tc);
        bw.push(sigma);
      }

      // axes
      const xMin = tauMin, xMax = tauMax;
      const yMin = 0;
      const yMax = 1.1 * Math.max(...bw);

      const plot = drawAxes(ctx, box, xMin, xMax, yMin, yMax, 'coherence time τc (s)', 'RMS bandwidth σν (Hz)', 'Bandwidth vs coherence time (parameter sweep)');

      // curve
      polyline(ctx, plot, taus, bw, xMin, xMax, yMin, yMax, 'rgba(255,210,122,.95)', 2.6);

      // current point
      const tc = state.tauC;
      // find nearest
      let idx = 0;
      for(let i=1;i<taus.length;i++) if(Math.abs(taus[i]-tc) < Math.abs(taus[idx]-tc)) idx = i;
      const px = plot.x + (taus[idx]-xMin)/(xMax-xMin)*plot.w;
      const py = plot.y + plot.h - (bw[idx]-yMin)/(yMax-yMin)*plot.h;

      ctx.save();
      ctx.fillStyle = 'rgba(255,210,122,.95)';
      ctx.beginPath(); ctx.arc(px, py, 5, 0, Math.PI*2); ctx.fill();

      ctx.strokeStyle = 'rgba(255,210,122,.35)';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(px, plot.y); ctx.lineTo(px, plot.y+plot.h); ctx.stroke();

      ctx.fillStyle = 'rgba(234,240,255,.92)';
      ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
      ctx.fillText(`τc=${tc.toFixed(2)} s`, Math.min(plot.x+plot.w-110, px+8), Math.max(plot.y+16, py-10));
      ctx.fillText(`σν≈${bw[idx].toFixed(3)} Hz`, Math.min(plot.x+plot.w-130, px+8), Math.max(plot.y+32, py+6));
      ctx.restore();

      // legend note
      ctx.save();
      ctx.fillStyle = 'rgba(185,198,255,.85)';
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.fillText('Trend: σν roughly scales like 1/τc (time–frequency duality).', plot.x+8, plot.y+plot.h-10);
      ctx.restore();
    }

    // --------------------------
    // State + update loop
    // --------------------------
    const diagramCanvas = document.getElementById('diagramCanvas');
    const mainCanvas = document.getElementById('mainCanvas');
    const secondaryCanvas = document.getElementById('secondaryCanvas');

    const tauSlider = document.getElementById('tauSlider');
    const tauRead = document.getElementById('tauRead');
    const modelSel = document.getElementById('modelSel');
    const resetBtn = document.getElementById('resetBtn');
    const consistency = document.getElementById('consistency');

    const state = {
      tauC: parseFloat(tauSlider.value),
      model: modelSel.value
    };

    function updateReadouts(data){
      tauRead.textContent = `τc = ${state.tauC.toFixed(2)} s`;
      // intensity check: compare I_fromG0 to I_fromS_twosided (since our S is two-sided evaluated on ν>=0)
      const I0 = data.I_fromG0;
      const Iest = data.I_fromS_twosided;
      const rel = (Iest - I0) / (I0 || 1);
      const sign = rel>=0 ? '+' : '−';
      consistency.textContent = `I check: ${I0.toFixed(3)} vs ${Iest.toFixed(3)} (${sign}${Math.abs(rel*100).toFixed(1)}%)`;
    }

    function render(){
      const data = computeSpectrumOneSided(state.tauC, state.model, 1);
      updateReadouts(data);
      drawDiagram(diagramCanvas, state);
      drawMainPlot(mainCanvas, state, data);
      drawSecondaryPlot(secondaryCanvas, state);
    }

    tauSlider.addEventListener('input', ()=>{
      state.tauC = parseFloat(tauSlider.value);
      render();
    });
    modelSel.addEventListener('change', ()=>{
      state.model = modelSel.value;
      render();
    });
    resetBtn.addEventListener('click', ()=>{
      tauSlider.value = "1.2";
      modelSel.value = "gauss";
      state.tauC = 1.2;
      state.model = "gauss";
      render();
    });

    // re-render on resize (responsive)
    let rAF = null;
    window.addEventListener('resize', ()=>{
      cancelAnimationFrame(rAF);
      rAF = requestAnimationFrame(render);
    });

    // Initial render
    render();
  </script>
</body>
</html>
