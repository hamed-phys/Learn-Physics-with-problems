<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Partially Polarized Light: Degree of Polarization, Coherency Matrix, and Polarizer Transmission</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#101724;
      --panel2:#0f1622;
      --text:#e9eef7;
      --muted:#a9b4c4;
      --faint:#6f7c90;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.16);
      --shadow: 0 14px 38px rgba(0,0,0,.45);
      --radius:18px;
      --radius2:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1000px 600px at 12% 10%, rgba(125,211,252,.12), transparent 60%),
        radial-gradient(900px 520px at 86% 18%, rgba(167,139,250,.12), transparent 60%),
        radial-gradient(900px 700px at 50% 110%, rgba(52,211,153,.08), transparent 60%),
        var(--bg);
      line-height:1.6;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:28px 18px 10px;
      position:relative;
    }
    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding:0 14px 40px;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.35fr .65fr;
      gap:16px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns:1fr}
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.045), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .card .pad{padding:18px 18px 16px}
    .title{
      font-size: clamp(1.4rem, 2.2vw, 2.05rem);
      margin:0 0 8px;
      letter-spacing:.2px;
    }
    .subtitle{color:var(--muted); margin:0}
    .meta{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top:12px;
      color:var(--muted);
      font-size:.95rem;
    }
    .pill{
      border:1px solid var(--line2);
      border-radius:999px;
      padding:6px 10px;
      background:rgba(255,255,255,.03);
    }

    main{
      padding:10px 0 60px;
    }

    /* Layout with sticky TOC */
    .grid{
      display:grid;
      grid-template-columns: 290px 1fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }

    nav#toc{
      position:sticky;
      top:14px;
      align-self:start;
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:14px 12px;
    }
    @media (max-width: 980px){
      nav#toc{position:relative; top:auto}
    }
    #toc h3{
      margin:4px 10px 10px;
      font-size:1rem;
      color:var(--text);
      letter-spacing:.25px;
    }
    #toc a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      color:var(--muted);
      font-size:.95rem;
    }
    #toc a:hover{background:rgba(255,255,255,.04); color:var(--text)}
    #toc a.active{background:rgba(125,211,252,.10); color:var(--text); border:1px solid rgba(125,211,252,.22)}
    #toc .small{font-size:.86rem; color:var(--faint); padding:6px 10px 2px}

    section{
      scroll-margin-top: 80px;
    }
    .section-card{
      background:linear-gradient(180deg, rgba(255,255,255,.045), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
      margin-bottom:16px;
    }
    .section-head{
      padding:14px 18px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      background:rgba(255,255,255,.02);
    }
    .section-head h2{
      margin:0;
      font-size:1.15rem;
      letter-spacing:.25px;
    }
    .section-body{padding:16px 18px}
    .two-col{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 860px){
      .two-col{grid-template-columns:1fr}
    }
    .callout{
      border-radius:var(--radius2);
      padding:12px 12px 10px;
      border:1px solid var(--line2);
      background:rgba(255,255,255,.03);
    }
    .callout h4{
      margin:0 0 6px;
      font-size:1rem;
      letter-spacing:.2px;
      display:flex; align-items:center; gap:8px;
    }
    .tag{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      font-size:.78rem;
      border:1px solid var(--line2);
      color:var(--muted);
      background:rgba(0,0,0,.12);
    }
    .assump{border-color:rgba(52,211,153,.25); background:rgba(52,211,153,.06)}
    .keyeq{border-color:rgba(125,211,252,.25); background:rgba(125,211,252,.06)}
    .mist{border-color:rgba(251,191,36,.25); background:rgba(251,191,36,.06)}
    .final{border-color:rgba(167,139,250,.28); background:rgba(167,139,250,.07)}

    .eq{
      font-family:var(--mono);
      font-size:.95rem;
      background:rgba(0,0,0,.22);
      border:1px solid var(--line);
      padding:10px 10px;
      border-radius:12px;
      overflow:auto;
      position:relative;
      margin:10px 0;
      white-space:pre;
    }
    .eqline{white-space:normal}
    .copy-btn{
      position:absolute;
      right:10px;
      top:10px;
      border:1px solid var(--line2);
      background:rgba(255,255,255,.04);
      color:var(--text);
      border-radius:10px;
      padding:6px 10px;
      cursor:pointer;
      font-size:.85rem;
    }
    .copy-btn:hover{background:rgba(255,255,255,.07)}
    .copy-note{
      font-size:.85rem;
      color:var(--faint);
      margin-top:6px;
    }

    ul{margin:10px 0 0 18px}
    li{margin:6px 0}
    .kpi{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 860px){ .kpi{grid-template-columns: repeat(2, 1fr);} }
    .kpi .box{
      border:1px solid var(--line);
      border-radius:16px;
      padding:10px 12px;
      background:rgba(255,255,255,.03);
    }
    .kpi .lab{color:var(--muted); font-size:.82rem}
    .kpi .val{font-family:var(--mono); font-size:1.05rem; margin-top:4px}

    /* Visualization area */
    .viz{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:14px;
      align-items:stretch;
    }
    @media (max-width: 980px){ .viz{grid-template-columns:1fr} }
    .viz .pane{
      padding:14px;
    }
    .controls{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:flex-end;
      margin-top:10px;
      padding:12px;
      border:1px solid var(--line);
      border-radius:16px;
      background:rgba(0,0,0,.18);
    }
    .control{
      min-width:190px;
      flex:1 1 190px;
    }
    .control label{
      display:block;
      font-size:.85rem;
      color:var(--muted);
      margin-bottom:6px;
    }
    input[type="range"]{width:100%}
    select{
      width:100%;
      border:1px solid var(--line2);
      border-radius:12px;
      padding:9px 10px;
      background:rgba(255,255,255,.04);
      color:var(--text);
      outline:none;
    }
    .btnrow{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    button.smallbtn{
      border:1px solid var(--line2);
      background:rgba(255,255,255,.04);
      color:var(--text);
      border-radius:12px;
      padding:9px 12px;
      cursor:pointer;
      font-size:.9rem;
    }
    button.smallbtn:hover{background:rgba(255,255,255,.07)}
    .note{
      color:var(--muted);
      font-size:.92rem;
      margin-top:8px;
    }

    figure{margin:0}
    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius:16px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.20);
    }
    .canvas-title{
      margin:0 0 8px;
      font-size:1rem;
      color:var(--text);
      letter-spacing:.2px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .canvas-sub{
      color:var(--muted);
      font-size:.88rem;
      margin:0 0 10px;
    }

    footer{
      padding:20px 0 40px;
      color:var(--faint);
      text-align:center;
      font-size:.9rem;
    }

    /* subtle animation */
    .fade-in{
      animation: fade .55s ease-out both;
    }
    @keyframes fade{
      from{opacity:0; transform:translateY(6px)}
      to{opacity:1; transform:translateY(0)}
    }

    /* print-friendly */
    @media print{
      body{background:#fff; color:#000}
      .card, .section-card, nav#toc{box-shadow:none}
      nav#toc{position:relative; top:auto}
      canvas{border:1px solid #999; background:#fff}
      .copy-btn, .controls, .note{display:none !important}
      .eq{background:#f5f5f5; border:1px solid #bbb}
    }
  </style>
</head>
<body>
  <header class="wrap">
    <div class="hero">
      <div class="card fade-in">
        <div class="pad">
          <h1 class="title">Partially Polarized Light (2-Component): <span style="color:var(--accent)">p</span>, Coherency Matrix, and Polarizer Transmission</h1>
          <p class="subtitle">
            We analyze a partially polarized optical field with equal component intensities
            <span style="font-family:var(--mono)">I<sub>x</sub> = I<sub>y</sub> = 1/2</span>
            and cross-correlation phase <span style="font-family:var(--mono)">arg(g<sub>xy</sub>) = π/2</span>.
          </p>
          <div class="meta">
            <span class="pill">Topic: statistical polarization optics</span>
            <span class="pill">Tools: coherency matrix, Stokes parameters</span>
            <span class="pill">Key result: for equal intensities, <span style="font-family:var(--mono)">p = |g<sub>xy</sub>|</span></span>
          </div>
        </div>
      </div>
      <div class="card fade-in">
        <div class="pad">
          <h2 style="margin:0 0 8px; font-size:1.15rem;">Interactive sandbox</h2>
          <p style="margin:0; color:var(--muted);">
            Use the slider to change <span style="font-family:var(--mono)">|g<sub>xy</sub>|</span> and the dropdown to change its phase.
            All plots update live.
          </p>
          <div class="kpi" id="kpi">
            <div class="box">
              <div class="lab">Degree of polarization</div>
              <div class="val" id="kpiP">p = 0.00</div>
            </div>
            <div class="box">
              <div class="lab">Total intensity</div>
              <div class="val" id="kpiS0">S0 = 1.00</div>
            </div>
            <div class="box">
              <div class="lab">Normalized Stokes</div>
              <div class="val" id="kpiS">s = (0.00, 0.00, 0.00)</div>
            </div>
            <div class="box">
              <div class="lab">Through x-polarizer</div>
              <div class="val" id="kpiTx">I<sub>out</sub> = 0.50</div>
            </div>
          </div>
          <div class="note">
            Example values for plots only: we sweep <span style="font-family:var(--mono)">|g<sub>xy</sub>| ∈ [0,1]</span> while keeping
            <span style="font-family:var(--mono)">I<sub>x</sub>=I<sub>y</sub>=1/2</span>.
          </div>
        </div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <div class="grid">
      <nav id="toc" aria-label="Table of contents">
        <h3>Table of Contents</h3>
        <div class="small">Jump to a section</div>
        <a href="#quick">Quick Summary</a>
        <a href="#part0">PART 0 — Concept Primer</a>
        <a href="#part1">PART 1 — Problem Analysis</a>
        <a href="#part2">PART 2 — Strategy & Tips</a>
        <a href="#part3">PART 3 — Full Solution</a>
        <a href="#part4">PART 4 — Deeper Understanding</a>
        <a href="#part5">PART 5 — Visualization Guide</a>
      </nav>

      <article>
        <!-- QUICK SUMMARY -->
        <section id="quick" class="section-card fade-in">
          <div class="section-head">
            <h2>Quick Summary</h2>
          </div>
          <div class="section-body">
            <ul>
              <li>We model a partially polarized beam using the <strong>coherency (polarization) matrix</strong> <span style="font-family:var(--mono)">J</span>.</li>
              <li>Given <span style="font-family:var(--mono)">I<sub>x</sub>=I<sub>y</sub>=1/2</span> and <span style="font-family:var(--mono)">arg(g<sub>xy</sub>)=π/2</span>, the off-diagonal element is fixed up to <span style="font-family:var(--mono)">|g<sub>xy</sub>|</span>.</li>
              <li><strong>Governing relation:</strong> normalized cross-correlation <span style="font-family:var(--mono)">g<sub>xy</sub> = J<sub>xy</sub>/√(J<sub>xx</sub>J<sub>yy</sub>)</span>.</li>
              <li><strong>Degree of polarization:</strong> <span style="font-family:var(--mono)">p = √(1 − 4 det(J)/(tr J)²)</span>; for equal intensities this simplifies to <span style="font-family:var(--mono)">p = |g<sub>xy</sub>|</span>.</li>
              <li><strong>(a)</strong> The plot <span style="font-family:var(--mono)">p</span> vs <span style="font-family:var(--mono)">|g<sub>xy</sub>|</span> is a straight line from 0 to 1.</li>
              <li><strong>(b)</strong> For <span style="font-family:var(--mono)">p = 0, 0.5, 1</span> we write <span style="font-family:var(--mono)">J</span> explicitly and interpret the light (unpolarized → partially → fully polarized).</li>
              <li><strong>(c)</strong> An ideal linear polarizer along <span style="font-family:var(--mono)">x</span> transmits intensity <span style="font-family:var(--mono)">I<sub>out</sub> = J<sub>xx</sub> = I<sub>x</sub> = 1/2</span> (independent of <span style="font-family:var(--mono)">g<sub>xy</sub></span>).</li>
            </ul>
          </div>
        </section>

        <!-- PART 0 -->
        <section id="part0" class="section-card fade-in">
          <div class="section-head">
            <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>
          </div>
          <div class="section-body">
            <div class="two-col">
              <div class="callout keyeq">
                <h4>Core definitions <span class="tag">what we measure</span></h4>
                <ul>
                  <li><strong>Field components</strong> (complex analytic signal): <span style="font-family:var(--mono)">E<sub>x</sub>(t)</span>, <span style="font-family:var(--mono)">E<sub>y</sub>(t)</span>.</li>
                  <li><strong>Intensities</strong>: <span style="font-family:var(--mono)">I<sub>x</sub> = ⟨|E<sub>x</sub>|²⟩</span>, <span style="font-family:var(--mono)">I<sub>y</sub> = ⟨|E<sub>y</sub>|²⟩</span> (units: W/m² up to constants).</li>
                  <li><strong>Coherency matrix</strong> (a 2×2 Hermitian PSD matrix):
                    <span style="font-family:var(--mono)">J = ⟨ E E† ⟩</span>, where <span style="font-family:var(--mono)">E = (E<sub>x</sub>, E<sub>y</sub>)ᵀ</span>.
                  </li>
                  <li><strong>Cross-correlation coefficient</strong>:
                    <span style="font-family:var(--mono)">g<sub>xy</sub> = J<sub>xy</sub> / √(J<sub>xx</sub>J<sub>yy</sub>)</span>,
                    so <span style="font-family:var(--mono)">0 ≤ |g<sub>xy</sub>| ≤ 1</span>.
                  </li>
                </ul>
              </div>

              <div class="callout">
                <h4>Physical meaning <span class="tag">what it “means”</span></h4>
                <ul>
                  <li><span style="font-family:var(--mono)">J<sub>xx</sub>, J<sub>yy</sub></span>: average powers in x and y components.</li>
                  <li><span style="font-family:var(--mono)">J<sub>xy</sub></span>: how strongly x and y “move together” (statistical coherence + relative phase).</li>
                  <li><span style="font-family:var(--mono)">|g<sub>xy</sub>|</span>: coherence strength between components (0 = uncorrelated, 1 = perfectly correlated).</li>
                  <li><span style="font-family:var(--mono)">arg(g<sub>xy</sub>)</span>: the relative phase bias of the correlation; it controls *which* polarization state is favored (linear vs elliptical vs circular) when correlation is strong.</li>
                </ul>
              </div>
            </div>

            <div class="two-col" style="margin-top:14px">
              <div class="callout keyeq">
                <h4>Key laws/principles <span class="tag">validity</span></h4>
                <ul>
                  <li><strong>Hermiticity:</strong> <span style="font-family:var(--mono)">J<sub>yx</sub> = J<sub>xy</sub>*</span>.</li>
                  <li><strong>Positive semidefinite:</strong> <span style="font-family:var(--mono)">det(J) ≥ 0</span> and eigenvalues ≥ 0 → enforces <span style="font-family:var(--mono)">|g<sub>xy</sub>| ≤ 1</span>.</li>
                  <li><strong>Stokes parameters:</strong> from <span style="font-family:var(--mono)">J</span> we define:
                    <span style="font-family:var(--mono)">S0 = Jxx + Jyy</span>,
                    <span style="font-family:var(--mono)">S1 = Jxx − Jyy</span>,
                    <span style="font-family:var(--mono)">S2 = Jxy + Jyx = 2Re(Jxy)</span>,
                    <span style="font-family:var(--mono)">S3 = i(Jyx − Jxy) = −2Im(Jxy)</span>.
                  </li>
                </ul>
              </div>

              <div class="callout keyeq">
                <h4>Degree of polarization <span class="tag">single-number summary</span></h4>
                <p style="margin:0 0 8px; color:var(--muted);">
                  The degree of polarization measures how close the beam is to a deterministic (fully polarized) state.
                </p>
                <div class="eq" id="eq-p">
                  <button class="copy-btn" data-copy="p = sqrt(1 - 4 det(J)/(tr(J))^2)">Copy</button>
p = √( 1 − 4 det(J) / (tr J)² )
                </div>
                <p style="margin:0; color:var(--muted);">
                  <span style="font-family:var(--mono)">p = 0</span> → completely unpolarized (in the 2D sense);
                  <span style="font-family:var(--mono)">p = 1</span> → fully polarized.
                </p>
              </div>
            </div>

            <div class="two-col" style="margin-top:14px">
              <div class="callout">
                <h4>Common models/approximations <span class="tag">why we use them</span></h4>
                <ul>
                  <li><strong>Stationary statistics</strong>: averages ⟨·⟩ are time averages (or ensemble averages) that are stable.</li>
                  <li><strong>Quasi-monochromatic</strong>: lets us represent the field as complex amplitudes and use coherency matrices.</li>
                  <li><strong>Ideal polarizers</strong>: linear optical elements represented by Jones matrices acting on the field; intensities follow via <span style="font-family:var(--mono)">J → A J A†</span>.</li>
                </ul>
              </div>
              <div class="callout mist">
                <h4>What to watch for <span class="tag">pitfalls</span></h4>
                <ul>
                  <li>Confusing <span style="font-family:var(--mono)">|g<sub>xy</sub>|</span> (component coherence) with <span style="font-family:var(--mono)">p</span> (polarization purity). They coincide here only because <span style="font-family:var(--mono)">I<sub>x</sub>=I<sub>y</sub></span>.</li>
                  <li>Forgetting Hermiticity: <span style="font-family:var(--mono)">J<sub>yx</sub> = J<sub>xy</sub>*</span>.</li>
                  <li>Dropping the phase <span style="font-family:var(--mono)">arg(g<sub>xy</sub>)</span>: it doesn’t change <span style="font-family:var(--mono)">p</span> in this problem, but it changes the Stokes vector direction (linear vs circular tendency).</li>
                  <li>Assuming a linear polarizer output depends on coherence: for an ideal x-polarizer, the transmitted intensity is simply <span style="font-family:var(--mono)">J<sub>xx</sub></span>.</li>
                </ul>
              </div>
            </div>

            <div class="callout" style="margin-top:14px">
              <h4>Mini intuition examples <span class="tag">fast mental checks</span></h4>
              <ul>
                <li>If <span style="font-family:var(--mono)">g<sub>xy</sub>=0</span>, x and y fluctuate independently → no preferred polarization → <span style="font-family:var(--mono)">p=0</span> (given equal intensities).</li>
                <li>If <span style="font-family:var(--mono)">|g<sub>xy</sub>|=1</span> and the correlation phase is <span style="font-family:var(--mono)">±π/2</span>, the field behaves like equal-amplitude quadrature components → circular (fully) polarized → <span style="font-family:var(--mono)">p=1</span>.</li>
              </ul>
            </div>
          </div>
        </section>

        <!-- PART 1 -->
        <section id="part1" class="section-card fade-in">
          <div class="section-head">
            <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>
          </div>
          <div class="section-body">
            <p>
              <strong>Rewritten problem:</strong> A random optical field has two orthogonal components x and y with equal mean intensities
              <span style="font-family:var(--mono)">I<sub>x</sub> = I<sub>y</sub> = 1/2</span>. The normalized cross-correlation coefficient
              <span style="font-family:var(--mono)">g<sub>xy</sub></span> has phase <span style="font-family:var(--mono)">π/2</span>.
              (a) Plot the degree of polarization <span style="font-family:var(--mono)">p</span> versus <span style="font-family:var(--mono)">|g<sub>xy</sub>|</span>.
              (b) Write the coherency matrix for <span style="font-family:var(--mono)">p = 0, 0.5, 1</span> and interpret each case.
              (c) Find the transmitted intensity through an ideal x-oriented polarizer.
            </p>

            <div class="two-col">
              <div class="callout">
                <h4>Given</h4>
                <ul>
                  <li><span style="font-family:var(--mono)">I<sub>x</sub> = J<sub>xx</sub> = 1/2</span></li>
                  <li><span style="font-family:var(--mono)">I<sub>y</sub> = J<sub>yy</sub> = 1/2</span></li>
                  <li><span style="font-family:var(--mono)">arg(g<sub>xy</sub>) = π/2</span></li>
                  <li><span style="font-family:var(--mono)">0 ≤ |g<sub>xy</sub>| ≤ 1</span> (must hold physically)</li>
                </ul>
              </div>
              <div class="callout">
                <h4>Unknowns / tasks</h4>
                <ul>
                  <li>(a) A function <span style="font-family:var(--mono)">p(|g<sub>xy</sub>|)</span> and its plot.</li>
                  <li>(b) <span style="font-family:var(--mono)">J</span> for specified <span style="font-family:var(--mono)">p</span> values; interpret polarization state.</li>
                  <li>(c) Transmitted intensity after x-polarizer.</li>
                </ul>
              </div>
            </div>

            <div class="callout assump" style="margin-top:14px">
              <h4>Assumptions <span class="tag">explicit</span></h4>
              <ul>
                <li>Quasi-monochromatic stationary field so second-order statistics describe polarization.</li>
                <li>Orthogonal x and y components form a complete transverse basis (2D polarization).</li>
                <li>Ideal linear polarizer (lossless along pass axis, blocks orthogonal component).</li>
              </ul>
            </div>

            <div class="two-col" style="margin-top:14px">
              <div class="callout">
                <h4>Relevant principles (and why)</h4>
                <ul>
                  <li><strong>Coherency matrix formalism</strong>: the problem gives intensities and a correlation coefficient, which are exactly the entries of <span style="font-family:var(--mono)">J</span>.</li>
                  <li><strong>Degree of polarization formula</strong>: <span style="font-family:var(--mono)">p</span> is computed from invariants of <span style="font-family:var(--mono)">J</span> (trace and determinant), so it is robust and basis-independent.</li>
                  <li><strong>Polarizer intensity rule</strong>: for an ideal x-polarizer, output intensity is the x-component power, i.e., the <span style="font-family:var(--mono)">xx</span> element after projection.</li>
                </ul>
              </div>
              <div class="callout mist">
                <h4>Why other approaches aren’t needed</h4>
                <ul>
                  <li>Pure Jones-vector polarization ellipses assume fully polarized light; here we must allow partial polarization → need <span style="font-family:var(--mono)">J</span> (or Stokes + depolarization).</li>
                  <li>Full wave optics (Maxwell boundary problems) is irrelevant: polarization statistics are specified directly.</li>
                </ul>
              </div>
            </div>

            <div class="callout" style="margin-top:14px">
              <h4>Possible approaches (compare)</h4>
              <ol style="margin:8px 0 0 18px">
                <li><strong>Coherency-matrix invariants</strong> (<span style="font-family:var(--mono)">tr</span>, <span style="font-family:var(--mono)">det</span>) → directly yields <span style="font-family:var(--mono)">p</span>. <em>Pros:</em> shortest, cleanest. <em>Cons:</em> less geometric intuition unless you add Stokes interpretation.</li>
                <li><strong>Stokes parameters</strong> from <span style="font-family:var(--mono)">J</span> → <span style="font-family:var(--mono)">p = √(S1²+S2²+S3²)/S0</span>. <em>Pros:</em> geometric on Poincaré sphere. <em>Cons:</em> requires careful conventions for <span style="font-family:var(--mono)">S3</span>.</li>
                <li><strong>Eigenvalue decomposition of</strong> <span style="font-family:var(--mono)">J</span> → polarized + unpolarized mixture. <em>Pros:</em> strong physical interpretation. <em>Cons:</em> a bit more algebra.</li>
              </ol>
              <p style="margin:10px 0 0; color:var(--muted);">
                <strong>Best choice:</strong> Use the coherency matrix + invariants, then interpret with Stokes/eigenvalues.
                This is both efficient and conceptually complete.
              </p>
            </div>
          </div>
        </section>

        <!-- PART 2 -->
        <section id="part2" class="section-card fade-in">
          <div class="section-head">
            <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>
          </div>
          <div class="section-body">
            <ol style="margin:0 0 0 18px">
              <li>
                <strong>Goal:</strong> write <span style="font-family:var(--mono)">J</span> using given intensities and <span style="font-family:var(--mono)">g<sub>xy</sub></span>.<br/>
                <strong>Tool:</strong> <span style="font-family:var(--mono)">J<sub>xx</sub>=I<sub>x</sub>, J<sub>yy</sub>=I<sub>y</sub>, J<sub>xy</sub>=g<sub>xy</sub>√(I<sub>x</sub>I<sub>y</sub>)</span>.<br/>
                <strong>Meaning:</strong> encodes second-order polarization statistics.
              </li>
              <li>
                <strong>Goal:</strong> compute <span style="font-family:var(--mono)">p</span> as a function of <span style="font-family:var(--mono)">|g<sub>xy</sub>|</span>.<br/>
                <strong>Tool:</strong> <span style="font-family:var(--mono)">p = √(1 − 4 det(J)/(tr J)²)</span>.<br/>
                <strong>Meaning:</strong> scalar measure of polarization purity.
              </li>
              <li>
                <strong>Goal:</strong> simplify using <span style="font-family:var(--mono)">I<sub>x</sub>=I<sub>y</sub></span> and show <span style="font-family:var(--mono)">p=|g<sub>xy</sub>|</span>.<br/>
                <strong>Tool:</strong> compute <span style="font-family:var(--mono)">tr</span> and <span style="font-family:var(--mono)">det</span> explicitly.<br/>
                <strong>Meaning:</strong> here “coherence strength” equals degree of polarization.
              </li>
              <li>
                <strong>Goal:</strong> produce (a) plot, (b) matrices for selected <span style="font-family:var(--mono)">p</span>, (c) polarizer output.<br/>
                <strong>Tool:</strong> use relation <span style="font-family:var(--mono)">p=|g|</span> and projection for polarizer.<br/>
                <strong>Meaning:</strong> connect math to physical interpretation (unpolarized vs partially vs fully).
              </li>
              <li>
                <strong>Sanity checks:</strong> ensure <span style="font-family:var(--mono)">0≤p≤1</span>, units are intensity, limiting cases <span style="font-family:var(--mono)">|g|=0</span> and <span style="font-family:var(--mono)">|g|=1</span> match intuition.
              </li>
            </ol>

            <div class="callout mist" style="margin-top:14px">
              <h4>Common mistakes & quick tips</h4>
              <ul>
                <li><strong>Tip:</strong> compute <span style="font-family:var(--mono)">det(J)</span> carefully; the off-diagonal magnitude enters as <span style="font-family:var(--mono)">|J<sub>xy</sub>|²</span>.</li>
                <li><strong>Tip:</strong> an x-polarizer transmits <span style="font-family:var(--mono)">J<sub>xx</sub></span> regardless of the correlation phase.</li>
                <li><strong>Mistake:</strong> thinking <span style="font-family:var(--mono)">arg(g)</span> changes <span style="font-family:var(--mono)">p</span> in this equal-intensity case— it doesn’t.</li>
              </ul>
            </div>
          </div>
        </section>

        <!-- PART 3 -->
        <section id="part3" class="section-card fade-in">
          <div class="section-head">
            <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>
          </div>
          <div class="section-body">
            <div class="callout">
              <h4>Physical intuition (before math)</h4>
              <ul>
                <li>Equal mean powers in x and y means there is no built-in preference for horizontal vs vertical polarization.</li>
                <li>Any polarization “preference” must come from the <em>correlation</em> between x and y.</li>
                <li>If x and y are uncorrelated (<span style="font-family:var(--mono)">|g|=0</span>), there is no stable polarization → <span style="font-family:var(--mono)">p=0</span>.</li>
                <li>If x and y are perfectly correlated (<span style="font-family:var(--mono)">|g|=1</span>), the field behaves deterministically (up to an overall random phase) → <span style="font-family:var(--mono)">p=1</span>. With a correlation phase of <span style="font-family:var(--mono)">π/2</span>, you expect a circular/elliptical tendency.</li>
              </ul>
            </div>

            <h3 style="margin:16px 0 6px; font-size:1.05rem;">Step 1 — Build the coherency matrix from the data</h3>
            <p style="margin:0; color:var(--muted);">
              By definition, <span style="font-family:var(--mono)">J<sub>xx</sub>=I<sub>x</sub></span> and <span style="font-family:var(--mono)">J<sub>yy</sub>=I<sub>y</sub></span>.
              The normalized cross-correlation is <span style="font-family:var(--mono)">g<sub>xy</sub> = J<sub>xy</sub>/√(I<sub>x</sub>I<sub>y</sub>)</span>,
              so <span style="font-family:var(--mono)">J<sub>xy</sub> = g<sub>xy</sub>√(I<sub>x</sub>I<sub>y</sub>)</span>.
            </p>

            <div class="eq" id="eq-Jdef">
              <button class="copy-btn" data-copy="J = [[Ix, g_xy*sqrt(Ix*Iy)], [g_xy_conj*sqrt(Ix*Iy), Iy]]">Copy</button>
J = [ [ Jxx, Jxy ],
      [ Jyx, Jyy ] ]
with  Jxx = Ix,  Jyy = Iy,
and  Jxy = g_xy √(Ix Iy),  Jyx = Jxy* .
            </div>

            <p style="margin:0;">
              Here <span style="font-family:var(--mono)">I<sub>x</sub>=I<sub>y</sub>=1/2</span>, so <span style="font-family:var(--mono)">√(I<sub>x</sub>I<sub>y</sub>) = √(1/4) = 1/2</span>.
              The phase condition <span style="font-family:var(--mono)">arg(g<sub>xy</sub>)=π/2</span> means we can write
              <span style="font-family:var(--mono)">g<sub>xy</sub> = |g| e^{iπ/2} = i|g|</span>,
              where <span style="font-family:var(--mono)">|g| := |g<sub>xy</sub>|</span>.
            </p>

            <div class="eq" id="eq-J">
              <button class="copy-btn" data-copy="J = [[1/2, i|g|/2], [-i|g|/2, 1/2]]">Copy</button>
Given Ix = Iy = 1/2 and g_xy = i|g|,

J = [ [ 1/2,  (i|g|)/2 ],
      [ -(i|g|)/2,  1/2 ] ] .
            </div>

            <p class="copy-note">
              What we did: we translated “intensities + correlation coefficient” directly into the matrix that fully describes second-order polarization statistics.
            </p>

            <h3 style="margin:16px 0 6px; font-size:1.05rem;">Step 2 — Compute the degree of polarization p(|g|)</h3>
            <p style="margin:0; color:var(--muted);">
              Use <span style="font-family:var(--mono)">p = √(1 − 4 det(J)/(tr J)²)</span>, which is basis-independent and applies to any 2×2 coherency matrix.
            </p>

            <div class="callout keyeq" style="margin-top:12px">
              <h4>Compute trace and determinant</h4>
              <ul>
                <li><span style="font-family:var(--mono)">tr(J) = Jxx + Jyy = 1/2 + 1/2 = 1</span></li>
                <li><span style="font-family:var(--mono)">det(J) = Jxx·Jyy − |Jxy|²</span></li>
              </ul>
              <div class="eq" id="eq-det">
                <button class="copy-btn" data-copy="tr(J)=1; det(J)=(1-|g|^2)/4">Copy</button>
|Jxy| = | (i|g|)/2 | = |g|/2

det(J) = (1/2)(1/2) − (|g|/2)^2
       = 1/4 − |g|^2/4
       = (1 − |g|^2)/4 .
              </div>
              <p style="margin:0; color:var(--muted);">
                The determinant decreases as the correlation magnitude increases: stronger coherence makes the state “more pure.”
              </p>
            </div>

            <div class="callout keyeq" style="margin-top:14px">
              <h4>Plug into the p-formula</h4>
              <div class="eq" id="eq-pg">
                <button class="copy-btn" data-copy="p = |g_xy| (when Ix=Iy)">Copy</button>
p = √( 1 − 4 det(J)/(tr J)^2 )
  = √( 1 − 4 * [(1 − |g|^2)/4] / 1^2 )
  = √( 1 − (1 − |g|^2) )
  = √( |g|^2 )
  = |g| .

Therefore:  p = |g_xy|  (for Ix = Iy).
              </div>
              <p style="margin:0; color:var(--muted);">
                This directly answers part (a): it is a straight-line relationship.
              </p>
            </div>

            <h3 style="margin:16px 0 6px; font-size:1.05rem;">(a) Plot p versus |g_xy|</h3>
            <p style="margin:0;">
              Since <span style="font-family:var(--mono)">p = |g<sub>xy</sub>|</span>, the curve is simply <span style="font-family:var(--mono)">p</span> vs <span style="font-family:var(--mono)">|g|</span> with slope 1 and intercept 0 on the interval <span style="font-family:var(--mono)">[0,1]</span>.
              The interactive plot below shows this line and the current operating point.
            </p>

            <h3 style="margin:16px 0 6px; font-size:1.05rem;">(b) Coherency matrix for p = 0, 0.5, 1 and interpretation</h3>
            <p style="margin:0; color:var(--muted);">
              Because we found <span style="font-family:var(--mono)">p=|g|</span> (with the given equal intensities), setting <span style="font-family:var(--mono)">p</span> fixes <span style="font-family:var(--mono)">|g|</span>.
              With <span style="font-family:var(--mono)">arg(g)=π/2</span>, we have <span style="font-family:var(--mono)">g=i p</span>.
            </p>

            <div class="two-col" style="margin-top:12px">
              <div class="callout">
                <h4>Case p = 0</h4>
                <div class="eq eqline" id="eq-p0">
                  <button class="copy-btn" data-copy="p=0 => J=[[1/2,0],[0,1/2]]">Copy</button>
p=0 ⇒ |g|=0 ⇒ J = [ [1/2, 0], [0, 1/2] ].
                </div>
                <p style="margin:0; color:var(--muted);">
                  Interpretation: x and y are equally intense but uncorrelated → no preferred polarization direction → (2D) unpolarized light.
                </p>
              </div>

              <div class="callout">
                <h4>Case p = 0.5</h4>
                <div class="eq eqline" id="eq-p05">
                  <button class="copy-btn" data-copy="p=0.5 => J=[[1/2,i/4],[-i/4,1/2]]">Copy</button>
p=0.5 ⇒ |g|=0.5 ⇒ J = [ [1/2, i/4], [-i/4, 1/2] ].
                </div>
                <p style="margin:0; color:var(--muted);">
                  Interpretation: partially polarized. There is a nonzero quadrature correlation between x and y, biasing the Stokes vector toward the ±S3 axis,
                  but randomness remains (not fully deterministic).
                </p>
              </div>
            </div>

            <div class="callout" style="margin-top:14px">
              <h4>Case p = 1</h4>
              <div class="eq eqline" id="eq-p1">
                <button class="copy-btn" data-copy="p=1 => J=[[1/2,i/2],[-i/2,1/2]]">Copy</button>
p=1 ⇒ |g|=1 ⇒ J = [ [1/2, i/2], [-i/2, 1/2] ].
              </div>
              <p style="margin:0; color:var(--muted);">
                Interpretation: fully polarized (rank-1 coherency matrix). With equal powers and a ±π/2 correlation phase, the state corresponds to a circular polarization state
                (the sign of S3 fixes the handedness under a chosen convention).
              </p>
            </div>

            <div class="callout keyeq" style="margin-top:14px">
              <h4>Sanity checks</h4>
              <ul>
                <li><strong>Units:</strong> entries of <span style="font-family:var(--mono)">J</span> have intensity units; here normalized so <span style="font-family:var(--mono)">S0 = tr(J) = 1</span>.</li>
                <li><strong>Limiting cases:</strong> <span style="font-family:var(--mono)">|g|=0</span> gives diagonal <span style="font-family:var(--mono)">J</span> → unpolarized; <span style="font-family:var(--mono)">|g|=1</span> gives <span style="font-family:var(--mono)">det(J)=0</span> → fully polarized.</li>
                <li><strong>Physical constraint:</strong> <span style="font-family:var(--mono)">det(J)=(1-|g|^2)/4 ≥ 0</span> enforces <span style="font-family:var(--mono)">|g|≤1</span>.</li>
              </ul>
            </div>

            <h3 style="margin:16px 0 6px; font-size:1.05rem;">(c) Intensity through an x-oriented polarizer</h3>
            <p style="margin:0; color:var(--muted);">
              An ideal linear polarizer transmitting the x-component projects the field onto x. In coherency-matrix language, the transmitted intensity equals the
              <span style="font-family:var(--mono)">xx</span> power:
              <span style="font-family:var(--mono)">I<sub>out</sub> = J<sub>xx</sub> = I<sub>x</sub></span>.
            </p>

            <div class="callout final" style="margin-top:12px">
              <h4>Final answers <span class="tag">boxed</span></h4>
              <div class="eq" id="eq-final">
                <button class="copy-btn" data-copy="(a) p = |g_xy| for Ix=Iy. (b) J=[[1/2, i p/2],[-i p/2,1/2]] with p=0,0.5,1. (c) I_out = Ix = 1/2 for x-polarizer.">Copy</button>
(a) With Ix=Iy=1/2 and arg(g_xy)=π/2:  p = |g_xy|.

(b) Coherency matrix (in x,y basis):
    J = [ [1/2,  i|g|/2],
          [-i|g|/2, 1/2] ] = [ [1/2, i p/2], [-i p/2, 1/2] ].
    For p=0:   J=[[1/2,0],[0,1/2]] (unpolarized).
    For p=0.5: J=[[1/2,i/4],[-i/4,1/2]] (partially polarized).
    For p=1:   J=[[1/2,i/2],[-i/2,1/2]] (fully polarized; circular under convention).

(c) Ideal x-polarizer transmits:  I_out = J_xx = Ix = 1/2.
              </div>
            </div>

            <p style="margin:10px 0 0; color:var(--muted);">
              Connection to the diagram/plots: the diagram shows two orthogonal components with a tunable coherence link; the main plot confirms <span style="font-family:var(--mono)">p=|g|</span>;
              the secondary plot shows how the Stokes direction depends on the correlation phase even though <span style="font-family:var(--mono)">p</span> depends only on <span style="font-family:var(--mono)">|g|</span>.
            </p>

            <!-- VISUALS -->
            <div class="section-card" style="margin-top:16px;">
              <div class="section-head">
                <h2>Interactive Visualizations</h2>
              </div>
              <div class="section-body">
                <div class="viz">
                  <div class="pane">
                    <div class="canvas-title">
                      <span>Diagram: two-component partially polarized field + polarizer</span>
                      <span class="tag">canvas</span>
                    </div>
                    <p class="canvas-sub">
                      Schematic: x/y components (equal intensities) and a coherence “link” with tunable magnitude and phase.
                    </p>
                    <figure>
                      <canvas id="cDiagram" aria-label="diagram canvas"></canvas>
                    </figure>
                  </div>

                  <div class="pane">
                    <div class="canvas-title">
                      <span>Main plot: degree of polarization p vs |g<sub>xy</sub>|</span>
                      <span class="tag">canvas</span>
                    </div>
                    <p class="canvas-sub">
                      For <span style="font-family:var(--mono)">I<sub>x</sub>=I<sub>y</sub></span> the relationship is exactly linear: <span style="font-family:var(--mono)">p=|g|</span>.
                    </p>
                    <figure>
                      <canvas id="cMain" aria-label="main plot canvas"></canvas>
                    </figure>
                  </div>
                </div>

                <div class="viz" style="margin-top:14px">
                  <div class="pane">
                    <div class="canvas-title">
                      <span>Secondary plot: normalized Stokes components vs |g| (phase-sensitive)</span>
                      <span class="tag">canvas</span>
                    </div>
                    <p class="canvas-sub">
                      With <span style="font-family:var(--mono)">I<sub>x</sub>=I<sub>y</sub></span>, <span style="font-family:var(--mono)">s1=0</span>. The direction splits between
                      <span style="font-family:var(--mono)">s2=|g|cosφ</span> and <span style="font-family:var(--mono)">s3=−|g|sinφ</span>,
                      where <span style="font-family:var(--mono)">φ=arg(g<sub>xy</sub>)</span>.
                    </p>
                    <figure>
                      <canvas id="cSecondary" aria-label="secondary plot canvas"></canvas>
                    </figure>
                  </div>

                  <div class="pane">
                    <div class="canvas-title">
                      <span>Parameter sweep: eigenvalues of J vs |g|</span>
                      <span class="tag">canvas</span>
                    </div>
                    <p class="canvas-sub">
                      Eigenvalues <span style="font-family:var(--mono)">λ±</span> show the “polarized vs unpolarized” split: with <span style="font-family:var(--mono)">S0=1</span>,
                      <span style="font-family:var(--mono)">λ± = (1 ± |g|)/2</span>.
                    </p>
                    <figure>
                      <canvas id="cEigen" aria-label="eigenvalue plot canvas"></canvas>
                    </figure>
                  </div>
                </div>

                <div class="controls" aria-label="interactive controls">
                  <div class="control">
                    <label for="gmag">Correlation magnitude |g<sub>xy</sub>|</label>
                    <input id="gmag" type="range" min="0" max="1" value="0.5" step="0.01"/>
                    <div class="note" style="margin-top:6px">
                      Current: <span style="font-family:var(--mono)" id="gmagVal">0.50</span>
                    </div>
                  </div>

                  <div class="control">
                    <label for="gphase">Phase φ = arg(g<sub>xy</sub>)</label>
                    <select id="gphase">
                      <option value="0">0</option>
                      <option value="1.5707963267948966" selected>π/2</option>
                      <option value="3.141592653589793">π</option>
                      <option value="-1.5707963267948966">−π/2</option>
                    </select>
                    <div class="note" style="margin-top:6px">
                      Problem uses <span style="font-family:var(--mono)">φ=π/2</span>, but you can vary it to see how Stokes direction changes.
                    </div>
                  </div>

                  <div class="control">
                    <label>Quick set</label>
                    <div class="btnrow">
                      <button class="smallbtn" id="btnP0">p=0</button>
                      <button class="smallbtn" id="btnP05">p=0.5</button>
                      <button class="smallbtn" id="btnP1">p=1</button>
                    </div>
                    <div class="note" style="margin-top:6px">
                      Since <span style="font-family:var(--mono)">p=|g|</span>, these buttons set <span style="font-family:var(--mono)">|g|</span> directly.
                    </div>
                  </div>
                </div>

                <div class="callout" style="margin-top:14px">
                  <h4>Live computed matrix and Stokes parameters</h4>
                  <div class="two-col">
                    <div>
                      <div class="eq" id="liveJ" style="margin-top:8px;">J = ...</div>
                    </div>
                    <div>
                      <div class="eq" id="liveS" style="margin-top:8px;">S = ...</div>
                    </div>
                  </div>
                  <p class="copy-note">
                    The live display uses the same conventions defined in the Theory section:
                    <span style="font-family:var(--mono)">S2 = 2Re(Jxy)</span>,
                    <span style="font-family:var(--mono)">S3 = −2Im(Jxy)</span>.
                  </p>
                </div>
              </div>
            </div>

          </div>
        </section>

        <!-- PART 4 -->
        <section id="part4" class="section-card fade-in">
          <div class="section-head">
            <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>
          </div>
          <div class="section-body">
            <div class="two-col">
              <div class="callout">
                <h4>Re-interpreting p = |g| (why it happens here)</h4>
                <p style="margin:0; color:var(--muted);">
                  When <span style="font-family:var(--mono)">I<sub>x</sub>=I<sub>y</sub></span>, the Stokes component <span style="font-family:var(--mono)">S1=0</span>.
                  The only way to “choose” a polarization state is through cross-correlation, whose magnitude is exactly <span style="font-family:var(--mono)">|g|</span>.
                  That is why the polarization purity collapses to a single parameter: <span style="font-family:var(--mono)">p=|g|</span>.
                </p>
              </div>
              <div class="callout">
                <h4>What each term controls</h4>
                <ul>
                  <li><span style="font-family:var(--mono)">|g|</span>: how far the Stokes point moves away from the origin; sets polarization “strength.”</li>
                  <li><span style="font-family:var(--mono)">φ = arg(g)</span>: rotates the Stokes direction between <span style="font-family:var(--mono)">S2</span> (linear ±45°) and <span style="font-family:var(--mono)">S3</span> (circular).</li>
                  <li><span style="font-family:var(--mono)">I<sub>x</sub>, I<sub>y</sub></span>: control <span style="font-family:var(--mono)">S0</span> and <span style="font-family:var(--mono)">S1</span> (bias toward horizontal/vertical).</li>
                </ul>
              </div>
            </div>

            <div class="callout" style="margin-top:14px">
              <h4>How changing parameters affects outcomes (connect to plots)</h4>
              <ul>
                <li>Increasing <span style="font-family:var(--mono)">|g|</span> raises <span style="font-family:var(--mono)">p</span> linearly (main plot) and increases the split between eigenvalues <span style="font-family:var(--mono)">λ+</span> and <span style="font-family:var(--mono)">λ−</span> (eigenvalue plot).</li>
                <li>Changing phase <span style="font-family:var(--mono)">φ</span> does <em>not</em> change <span style="font-family:var(--mono)">p</span> here, but it moves weight between <span style="font-family:var(--mono)">s2</span> and <span style="font-family:var(--mono)">s3</span> (secondary plot).</li>
                <li>The x-polarizer output remains <span style="font-family:var(--mono)">I<sub>out</sub>=1/2</span> because <span style="font-family:var(--mono)">I<sub>x</sub></span> is fixed; coherence does not alter power already in x.</li>
              </ul>
            </div>

            <div class="two-col" style="margin-top:14px">
              <div class="callout">
                <h4>Alternative derivation idea (brief)</h4>
                <p style="margin:0; color:var(--muted);">
                  Use Stokes parameters directly. From <span style="font-family:var(--mono)">J</span>,
                  <span style="font-family:var(--mono)">S0=1</span>, <span style="font-family:var(--mono)">S1=0</span>,
                  and <span style="font-family:var(--mono)">S2=|g|cosφ</span>, <span style="font-family:var(--mono)">S3=−|g|sinφ</span>.
                  Then
                  <span style="font-family:var(--mono)">p = √(S1²+S2²+S3²)/S0 = √(|g|²)/1 = |g|</span>.
                </p>
              </div>
              <div class="callout">
                <h4>Concept check (self-test)</h4>
                <ul>
                  <li><strong>Q:</strong> If <span style="font-family:var(--mono)">|g|=0</span> but <span style="font-family:var(--mono)">I<sub>x</sub>≠I<sub>y</sub></span>, is the light unpolarized? <br/>
                      <strong>A:</strong> Not fully unpolarized; unequal diagonal elements give <span style="font-family:var(--mono)">S1≠0</span> so <span style="font-family:var(--mono)">p>0</span> even without cross-correlation.</li>
                  <li><strong>Q:</strong> Does changing <span style="font-family:var(--mono)">φ</span> change <span style="font-family:var(--mono)">|J<sub>xy</sub>|</span>? <br/>
                      <strong>A:</strong> No, it changes only the complex argument; magnitude stays fixed.</li>
                  <li><strong>Q:</strong> Why must <span style="font-family:var(--mono)">|g|≤1</span>? <br/>
                      <strong>A:</strong> Because <span style="font-family:var(--mono)">J</span> must be positive semidefinite; equivalently, Cauchy–Schwarz bounds the correlation.</li>
                </ul>
              </div>
            </div>
          </div>
        </section>

        <!-- PART 5 -->
        <section id="part5" class="section-card fade-in">
          <div class="section-head">
            <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>
          </div>
          <div class="section-body">
            <div class="callout">
              <h4>What each canvas shows</h4>
              <ul>
                <li><strong>Diagram canvas:</strong> x and y field components, equal intensities, and the complex correlation link labeled by <span style="font-family:var(--mono)">|g|</span> and <span style="font-family:var(--mono)">φ</span>. Also shows an x-axis polarizer and the transmitted intensity <span style="font-family:var(--mono)">I<sub>out</sub>=I<sub>x</sub></span>.</li>
                <li><strong>Main plot:</strong> <span style="font-family:var(--mono)">p</span> vs <span style="font-family:var(--mono)">|g|</span>. The line is <span style="font-family:var(--mono)">p=|g|</span>; the highlighted point is your current slider value.</li>
                <li><strong>Secondary plot:</strong> normalized Stokes components <span style="font-family:var(--mono)">s2</span> and <span style="font-family:var(--mono)">s3</span> versus <span style="font-family:var(--mono)">|g|</span>. Changing phase rotates the curve between the axes.</li>
                <li><strong>Eigenvalue plot:</strong> <span style="font-family:var(--mono)">λ±=(1±|g|)/2</span>. As <span style="font-family:var(--mono)">|g|</span> increases, the larger eigenvalue approaches 1 and the smaller approaches 0, indicating increasing purity (higher <span style="font-family:var(--mono)">p</span>).</li>
              </ul>
            </div>

            <div class="callout" style="margin-top:14px">
              <h4>Interactive controls (what changes and why)</h4>
              <ul>
                <li><strong>Slider |g<sub>xy</sub>|:</strong> changes the magnitude of cross-correlation. This changes <span style="font-family:var(--mono)">p</span> and the eigenvalue split, and scales the Stokes magnitude.</li>
                <li><strong>Phase dropdown φ:</strong> changes the argument of <span style="font-family:var(--mono)">g<sub>xy</sub></span>. This leaves <span style="font-family:var(--mono)">p</span> unchanged (here) but shifts polarization type tendency:
                  <span style="font-family:var(--mono)">φ=0</span> → linear ±45° tendency (<span style="font-family:var(--mono)">s2</span>),
                  <span style="font-family:var(--mono)">φ=±π/2</span> → circular tendency (<span style="font-family:var(--mono)">s3</span>).
                </li>
                <li><strong>Quick set buttons:</strong> jump to the three part-(b) cases <span style="font-family:var(--mono)">p=0,0.5,1</span>.</li>
              </ul>
            </div>
          </div>
        </section>

      </article>
    </div>
  </main>

  <footer class="wrap">
    <div>
      Built as a self-contained learning article (vanilla HTML/CSS/JS). Tip: print to PDF for a clean handout.
    </div>
  </footer>

  <script>
    // ---------- Utilities ----------
    const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
    const fmt = (x, n=2)=> (Math.abs(x) < 5e-13 ? 0 : x).toFixed(n);
    const fmtSign = (x,n=2)=> (x>=0?"+":"") + fmt(x,n);

    function complex(re, im){ return {re, im}; }
    function cAdd(a,b){ return complex(a.re+b.re, a.im+b.im); }
    function cSub(a,b){ return complex(a.re-b.re, a.im-b.im); }
    function cMul(a,b){ return complex(a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re); }
    function cConj(a){ return complex(a.re, -a.im); }
    function cAbs(a){ return Math.hypot(a.re,a.im); }

    function toClipboard(text){
      navigator.clipboard.writeText(text).then(()=>{
        // subtle feedback
      }).catch(()=>{ /* no-op */ });
    }
    document.querySelectorAll(".copy-btn").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        toClipboard(btn.getAttribute("data-copy") || "");
        btn.textContent = "Copied";
        setTimeout(()=>btn.textContent="Copy", 900);
      });
    });

    // ---------- Sticky TOC active state ----------
    const tocLinks = Array.from(document.querySelectorAll('#toc a[href^="#"]'));
    const sections = tocLinks.map(a => document.querySelector(a.getAttribute('href'))).filter(Boolean);

    const obs = new IntersectionObserver((entries)=>{
      entries.forEach(e=>{
        if(e.isIntersecting){
          tocLinks.forEach(l=>l.classList.remove("active"));
          const id = "#" + e.target.id;
          const active = tocLinks.find(l=>l.getAttribute("href")===id);
          if(active) active.classList.add("active");
        }
      });
    }, {root:null, threshold:0.14});
    sections.forEach(s=>obs.observe(s));

    // ---------- Polarization model (problem constants) ----------
    const Ix = 0.5;
    const Iy = 0.5;

    function coherencyMatrix(gMag, phi){
      // g_xy = gMag * exp(i phi)
      const g = complex(gMag*Math.cos(phi), gMag*Math.sin(phi));
      const s = Math.sqrt(Ix*Iy); // = 0.5
      const Jxy = cMul(g, complex(s,0));
      const Jyx = cConj(Jxy);
      return {
        Jxx: Ix,
        Jyy: Iy,
        Jxy,
        Jyx
      };
    }

    function stokesFromJ(J){
      const S0 = J.Jxx + J.Jyy;
      const S1 = J.Jxx - J.Jyy;
      const S2 = (J.Jxy.re + J.Jyx.re); // 2Re(Jxy)
      const S3 = (J.Jyx.im - J.Jxy.im); // i(Jyx - Jxy) = -2Im(Jxy) because Jyx=Jxy*
      // Wait: Jyx - Jxy is purely imaginary: (a-ib)-(a+ib)=-2ib. Multiply by i => 2b.
      // But we already use "i(Jyx - Jxy)" as real number. Here, b = -Im(Jxy)? Let's compute directly:
      // With Jyx.im = -Jxy.im => Jyx.im - Jxy.im = -2 Jxy.im. That's S3 by the convention i(Jyx-Jxy).
      // So S3 = -2 Im(Jxy). Implemented.
      return {S0,S1,S2,S3};
    }

    function degreeOfPolarization(J){
      // p = sqrt(1 - 4 det(J)/(tr J)^2), det = Jxx*Jyy - |Jxy|^2
      const tr = J.Jxx + J.Jyy;
      const det = J.Jxx*J.Jyy - Math.pow(cAbs(J.Jxy),2);
      const val = 1 - 4*det/(tr*tr);
      return Math.sqrt(clamp(val,0,1));
    }

    function eigenvalues(J){
      // For Hermitian 2x2: eigenvalues = (tr ± sqrt(tr^2 - 4 det))/2
      const tr = J.Jxx + J.Jyy;
      const det = J.Jxx*J.Jyy - Math.pow(cAbs(J.Jxy),2);
      const disc = Math.max(0, tr*tr - 4*det);
      const r = Math.sqrt(disc);
      return {lp:(tr+r)/2, lm:(tr-r)/2};
    }

    // ---------- Canvas drawing helpers ----------
    function setupCanvas(canvas){
      const ctx = canvas.getContext("2d");
      const state = {canvas, ctx, dpr:1, w:0, h:0};
      const resize = ()=>{
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        state.dpr = dpr;
        state.w = Math.max(2, Math.round(rect.width * dpr));
        state.h = Math.max(2, Math.round(rect.height * dpr));
        canvas.width = state.w;
        canvas.height = state.h;
        ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      };
      const ro = new ResizeObserver(resize);
      ro.observe(canvas);
      resize();
      return state;
    }

    function clear(ctx, wCss, hCss){
      ctx.clearRect(0,0,wCss,hCss);
    }

    function drawGrid(ctx, x0,y0,w,h, xTicks, yTicks){
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.lineWidth = 1;
      for(let i=0;i<=xTicks;i++){
        const x = x0 + (w*i)/xTicks;
        ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+h); ctx.stroke();
      }
      for(let j=0;j<=yTicks;j++){
        const y = y0 + (h*j)/yTicks;
        ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+w,y); ctx.stroke();
      }
      ctx.restore();
    }

    function drawAxes(ctx, x0,y0,w,h){
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(x0,y0); ctx.lineTo(x0,y0+h);
      ctx.lineTo(x0+w,y0+h);
      ctx.stroke();
      ctx.restore();
    }

    function tickLabel(ctx, text, x, y, align="center"){
      ctx.save();
      ctx.fillStyle = "rgba(233,238,247,0.85)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
      ctx.textAlign = align;
      ctx.textBaseline = "middle";
      ctx.fillText(text, x, y);
      ctx.restore();
    }

    function titleLabel(ctx, text, x, y){
      ctx.save();
      ctx.fillStyle = "rgba(233,238,247,0.95)";
      ctx.font = "13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textAlign = "left";
      ctx.textBaseline = "alphabetic";
      ctx.fillText(text, x, y);
      ctx.restore();
    }

    function mapLin(x, a,b, A,B){
      return A + (x-a)*(B-A)/(b-a);
    }

    function drawLegend(ctx, items, x, y){
      ctx.save();
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      let yy = y;
      items.forEach(it=>{
        ctx.strokeStyle = it.stroke;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(x,yy); ctx.lineTo(x+18,yy); ctx.stroke();
        ctx.fillStyle = "rgba(233,238,247,0.85)";
        ctx.fillText(it.label, x+24, yy);
        yy += 16;
      });
      ctx.restore();
    }

    // ---------- Plots ----------
    const diag = setupCanvas(document.getElementById("cDiagram"));
    const main = setupCanvas(document.getElementById("cMain"));
    const sec  = setupCanvas(document.getElementById("cSecondary"));
    const eig  = setupCanvas(document.getElementById("cEigen"));

    function drawDiagram(state, gMag, phi){
      const c = state.canvas;
      const ctx = state.ctx;
      const w = c.getBoundingClientRect().width;
      const h = c.getBoundingClientRect().height;
      clear(ctx,w,h);

      // background glow stripes
      ctx.save();
      ctx.globalAlpha = 0.9;
      const grad = ctx.createLinearGradient(0,0,w,h);
      grad.addColorStop(0,"rgba(125,211,252,0.08)");
      grad.addColorStop(0.5,"rgba(167,139,250,0.05)");
      grad.addColorStop(1,"rgba(52,211,153,0.06)");
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,w,h);
      ctx.restore();

      titleLabel(ctx, "Two orthogonal components + complex correlation + x-polarizer", 14, 22);

      // Draw axes
      const cx = 0.17*w, cy = 0.56*h;
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.lineWidth = 1.4;
      ctx.beginPath();
      ctx.moveTo(cx-50, cy); ctx.lineTo(cx+120, cy); // x axis line
      ctx.moveTo(cx, cy+90); ctx.lineTo(cx, cy-120); // y axis line
      ctx.stroke();
      ctx.restore();

      // Labels
      tickLabel(ctx, "x", cx+130, cy, "left");
      tickLabel(ctx, "y", cx, cy-130, "center");

      // component arrows
      function arrow(x1,y1,x2,y2, stroke){
        ctx.save();
        ctx.strokeStyle = stroke;
        ctx.fillStyle = stroke;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
        const ang = Math.atan2(y2-y1,x2-x1);
        const L=10;
        ctx.beginPath();
        ctx.moveTo(x2,y2);
        ctx.lineTo(x2 - L*Math.cos(ang-0.6), y2 - L*Math.sin(ang-0.6));
        ctx.lineTo(x2 - L*Math.cos(ang+0.6), y2 - L*Math.sin(ang+0.6));
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      arrow(cx,cy, cx+90,cy, "rgba(125,211,252,0.95)");
      arrow(cx,cy, cx,cy-90, "rgba(167,139,250,0.95)");

      // intensity labels
      ctx.save();
      ctx.fillStyle="rgba(233,238,247,0.85)";
      ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
      ctx.fillText("Ix = 1/2", cx+52, cy+22);
      ctx.fillText("Iy = 1/2", cx+10, cy-64);
      ctx.restore();

      // correlation link (between tips)
      const xTip = {x:cx+90, y:cy};
      const yTip = {x:cx, y:cy-90};
      ctx.save();
      ctx.strokeStyle="rgba(52,211,153,0.85)";
      ctx.lineWidth=2.5;
      ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(xTip.x, xTip.y); ctx.lineTo(yTip.x, yTip.y); ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();

      // correlation text
      ctx.save();
      ctx.fillStyle="rgba(233,238,247,0.9)";
      ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
      const midx = (xTip.x+yTip.x)/2, midy=(xTip.y+yTip.y)/2;
      const phiLabel = (Math.abs(phi - Math.PI/2) < 1e-6) ? "π/2"
                     : (Math.abs(phi + Math.PI/2) < 1e-6) ? "−π/2"
                     : (Math.abs(phi) < 1e-6) ? "0"
                     : (Math.abs(phi - Math.PI) < 1e-6) ? "π" : phi.toFixed(2);
      ctx.fillText(`|gxy| = ${fmt(gMag,2)},  φ = ${phiLabel}`, midx-66, midy-6);
      ctx.restore();

      // polarizer block on right
      const px = 0.70*w, py = 0.22*h, pw = 0.22*w, ph = 0.56*h;
      ctx.save();
      ctx.fillStyle="rgba(0,0,0,0.18)";
      ctx.strokeStyle="rgba(255,255,255,0.16)";
      ctx.lineWidth=1.2;
      roundRect(ctx, px, py, pw, ph, 16);
      ctx.fill(); ctx.stroke();
      ctx.restore();

      // polarizer slats (vertical, indicating x-pass axis)
      ctx.save();
      ctx.strokeStyle="rgba(125,211,252,0.55)";
      ctx.lineWidth=2;
      for(let i=0;i<9;i++){
        const xx = px + 14 + i*(pw-28)/8;
        ctx.beginPath();
        ctx.moveTo(xx, py+14);
        ctx.lineTo(xx, py+ph-14);
        ctx.stroke();
      }
      ctx.restore();

      // label polarizer
      ctx.save();
      ctx.fillStyle="rgba(233,238,247,0.92)";
      ctx.font="13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Ideal linear polarizer", px+14, py+22);
      ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
      ctx.fillText("Pass axis: x", px+14, py+42);
      ctx.restore();

      // input/output arrows
      arrow(0.46*w, 0.50*h, px-10, 0.50*h, "rgba(233,238,247,0.55)");
      arrow(px+pw+10, 0.50*h, 0.98*w, 0.50*h, "rgba(233,238,247,0.55)");

      // transmitted intensity text
      ctx.save();
      ctx.fillStyle="rgba(233,238,247,0.88)";
      ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
      ctx.fillText("I_out = Jxx = Ix = 1/2", px+14, py+ph-18);
      ctx.restore();

      // small note
      ctx.save();
      ctx.fillStyle="rgba(169,180,196,0.85)";
      ctx.font="12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Coherence changes polarization state, not the x-power already present.", 14, h-16);
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function drawMainPlot(state, gMag){
      const c = state.canvas;
      const ctx = state.ctx;
      const w = c.getBoundingClientRect().width;
      const h = c.getBoundingClientRect().height;
      clear(ctx,w,h);

      const padL=56, padR=16, padT=18, padB=44;
      const x0=padL, y0=padT, W=w-padL-padR, H=h-padT-padB;

      // grid and axes
      drawGrid(ctx, x0,y0,W,H, 5,5);
      drawAxes(ctx, x0,y0,W,H);

      // labels
      titleLabel(ctx, "p vs |gxy| (Ix=Iy=1/2 ⇒ p=|gxy|)", x0, 14);
      tickLabel(ctx, "|gxy| (dimensionless)", x0 + W/2, y0+H+30, "center");

      // y label (rotated)
      ctx.save();
      ctx.translate(18, y0 + H/2);
      ctx.rotate(-Math.PI/2);
      tickLabel(ctx, "p (dimensionless)", 0, 0, "center");
      ctx.restore();

      // ticks
      for(let i=0;i<=5;i++){
        const x = x0 + W*i/5;
        tickLabel(ctx, (i/5).toFixed(1), x, y0+H+12, "center");
      }
      for(let j=0;j<=5;j++){
        const y = y0 + H*(1-j/5);
        tickLabel(ctx, (j/5).toFixed(1), x0-10, y, "right");
      }

      // line p = |g|
      ctx.save();
      ctx.strokeStyle="rgba(125,211,252,0.95)";
      ctx.lineWidth=3;
      ctx.beginPath();
      for(let i=0;i<=200;i++){
        const xVal=i/200;
        const yVal=xVal;
        const x = mapLin(xVal,0,1,x0,x0+W);
        const y = mapLin(yVal,0,1,y0+H,y0);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();

      // current point
      const xP = mapLin(gMag,0,1,x0,x0+W);
      const yP = mapLin(gMag,0,1,y0+H,y0);
      ctx.save();
      ctx.fillStyle="rgba(251,191,36,0.95)";
      ctx.strokeStyle="rgba(0,0,0,0.35)";
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(xP,yP,6,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.restore();

      // legend
      drawLegend(ctx, [
        {stroke:"rgba(125,211,252,0.95)", label:"p = |gxy|"},
        {stroke:"rgba(251,191,36,0.95)", label:"current value"}
      ], x0+10, y0+20);
    }

    function drawSecondaryPlot(state, phi, gMag){
      const c = state.canvas;
      const ctx = state.ctx;
      const w = c.getBoundingClientRect().width;
      const h = c.getBoundingClientRect().height;
      clear(ctx,w,h);

      const padL=56, padR=16, padT=18, padB=44;
      const x0=padL, y0=padT, W=w-padL-padR, H=h-padT-padB;

      drawGrid(ctx, x0,y0,W,H, 5,6);
      drawAxes(ctx, x0,y0,W,H);

      titleLabel(ctx, "Normalized Stokes vs |g| (s1=0, s2=|g|cosφ, s3=−|g|sinφ)", x0, 14);
      tickLabel(ctx, "|g| (dimensionless)", x0 + W/2, y0+H+30, "center");

      // y label
      ctx.save();
      ctx.translate(18, y0 + H/2);
      ctx.rotate(-Math.PI/2);
      tickLabel(ctx, "s2 and s3 (dimensionless)", 0, 0, "center");
      ctx.restore();

      // y axis range [-1,1]
      const yMin=-1, yMax=1;
      for(let i=0;i<=5;i++){
        const x = x0 + W*i/5;
        tickLabel(ctx, (i/5).toFixed(1), x, y0+H+12, "center");
      }
      for(let j=0;j<=6;j++){
        const yVal = yMin + (yMax-yMin)*j/6;
        const y = mapLin(yVal,yMin,yMax,y0+H,y0);
        tickLabel(ctx, yVal.toFixed(1), x0-10, y, "right");
      }

      // s2 line
      ctx.save();
      ctx.strokeStyle="rgba(167,139,250,0.95)";
      ctx.lineWidth=3;
      ctx.beginPath();
      for(let i=0;i<=200;i++){
        const g=i/200;
        const s2=g*Math.cos(phi);
        const x=mapLin(g,0,1,x0,x0+W);
        const y=mapLin(s2,yMin,yMax,y0+H,y0);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();

      // s3 line
      ctx.save();
      ctx.strokeStyle="rgba(52,211,153,0.95)";
      ctx.lineWidth=3;
      ctx.beginPath();
      for(let i=0;i<=200;i++){
        const g=i/200;
        const s3=-g*Math.sin(phi);
        const x=mapLin(g,0,1,x0,x0+W);
        const y=mapLin(s3,yMin,yMax,y0+H,y0);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();

      // current markers
      const s2c = gMag*Math.cos(phi);
      const s3c = -gMag*Math.sin(phi);
      const xC = mapLin(gMag,0,1,x0,x0+W);

      ctx.save();
      ctx.fillStyle="rgba(167,139,250,0.95)";
      ctx.beginPath(); ctx.arc(xC, mapLin(s2c,yMin,yMax,y0+H,y0), 5, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle="rgba(52,211,153,0.95)";
      ctx.beginPath(); ctx.arc(xC, mapLin(s3c,yMin,yMax,y0+H,y0), 5, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      drawLegend(ctx,[
        {stroke:"rgba(167,139,250,0.95)", label:"s2 = |g| cosφ"},
        {stroke:"rgba(52,211,153,0.95)", label:"s3 = −|g| sinφ"}
      ], x0+10, y0+20);
    }

    function drawEigenPlot(state, gMag){
      const c = state.canvas;
      const ctx = state.ctx;
      const w = c.getBoundingClientRect().width;
      const h = c.getBoundingClientRect().height;
      clear(ctx,w,h);

      const padL=56, padR=16, padT=18, padB=44;
      const x0=padL, y0=padT, W=w-padL-padR, H=h-padT-padB;

      drawGrid(ctx, x0,y0,W,H, 5,5);
      drawAxes(ctx, x0,y0,W,H);

      titleLabel(ctx, "Eigenvalues of J vs |g| (Ix=Iy=1/2 ⇒ λ±=(1±|g|)/2)", x0, 14);
      tickLabel(ctx, "|g| (dimensionless)", x0 + W/2, y0+H+30, "center");

      ctx.save();
      ctx.translate(18, y0 + H/2);
      ctx.rotate(-Math.PI/2);
      tickLabel(ctx, "λ (intensity units, S0=1)", 0, 0, "center");
      ctx.restore();

      // ticks
      for(let i=0;i<=5;i++){
        const x = x0 + W*i/5;
        tickLabel(ctx, (i/5).toFixed(1), x, y0+H+12, "center");
      }
      for(let j=0;j<=5;j++){
        const yVal = j/5;
        const y = mapLin(yVal,0,1,y0+H,y0);
        tickLabel(ctx, yVal.toFixed(1), x0-10, y, "right");
      }

      // lambda plus
      ctx.save();
      ctx.strokeStyle="rgba(125,211,252,0.95)";
      ctx.lineWidth=3;
      ctx.beginPath();
      for(let i=0;i<=200;i++){
        const g=i/200;
        const lp=(1+g)/2;
        const x=mapLin(g,0,1,x0,x0+W);
        const y=mapLin(lp,0,1,y0+H,y0);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();

      // lambda minus
      ctx.save();
      ctx.strokeStyle="rgba(251,191,36,0.95)";
      ctx.lineWidth=3;
      ctx.beginPath();
      for(let i=0;i<=200;i++){
        const g=i/200;
        const lm=(1-g)/2;
        const x=mapLin(g,0,1,x0,x0+W);
        const y=mapLin(lm,0,1,y0+H,y0);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();

      // current markers
      const lpC=(1+gMag)/2, lmC=(1-gMag)/2;
      const xC=mapLin(gMag,0,1,x0,x0+W);
      ctx.save();
      ctx.fillStyle="rgba(125,211,252,0.95)";
      ctx.beginPath(); ctx.arc(xC, mapLin(lpC,0,1,y0+H,y0), 5, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle="rgba(251,191,36,0.95)";
      ctx.beginPath(); ctx.arc(xC, mapLin(lmC,0,1,y0+H,y0), 5, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      drawLegend(ctx,[
        {stroke:"rgba(125,211,252,0.95)", label:"λ+ (dominant polarized mode)"},
        {stroke:"rgba(251,191,36,0.95)", label:"λ− (residual orthogonal part)"}
      ], x0+10, y0+20);
    }

    // ---------- Live text blocks ----------
    function updateLiveText(gMag, phi){
      const J = coherencyMatrix(gMag, phi);
      const S = stokesFromJ(J);
      const p = degreeOfPolarization(J);
      const ev = eigenvalues(J);

      const liveJ = document.getElementById("liveJ");
      const liveS = document.getElementById("liveS");

      const jxy = J.Jxy;
      const phiLabel = (Math.abs(phi - Math.PI/2) < 1e-6) ? "π/2"
                     : (Math.abs(phi + Math.PI/2) < 1e-6) ? "−π/2"
                     : (Math.abs(phi) < 1e-6) ? "0"
                     : (Math.abs(phi - Math.PI) < 1e-6) ? "π" : phi.toFixed(3);

      liveJ.textContent =
`J (x,y basis), with Ix=Iy=1/2:
Jxx = 0.500
Jyy = 0.500
Jxy = ${fmt(jxy.re,3)} ${fmtSign(jxy.im,3)} i
Jyx = ${fmt(J.Jyx.re,3)} ${fmtSign(J.Jyx.im,3)} i

gxy = |g| e^{iφ},  |g|=${fmt(gMag,2)},  φ=${phiLabel}
`;

      const s0=S.S0, s1=S.S1, s2=S.S2, s3=S.S3;
      const sn1 = s1/s0, sn2=s2/s0, sn3=s3/s0;

      liveS.textContent =
`Stokes (using S2=2Re(Jxy), S3=−2Im(Jxy)):
S0 = ${fmt(s0,3)}
S1 = ${fmt(s1,3)}
S2 = ${fmt(s2,3)}
S3 = ${fmt(s3,3)}

Normalized s = (S1,S2,S3)/S0:
s = (${fmt(sn1,3)}, ${fmt(sn2,3)}, ${fmt(sn3,3)})

Degree of polarization:
p = ${fmt(p,3)}  (here p=|g|)

Eigenvalues:
λ+ = ${fmt(ev.lp,3)},  λ− = ${fmt(ev.lm,3)}
`;
    }

    function updateKPIs(gMag, phi){
      const J = coherencyMatrix(gMag, phi);
      const S = stokesFromJ(J);
      const p = degreeOfPolarization(J);

      const s0=S.S0;
      const s = [S.S1/s0, S.S2/s0, S.S3/s0];

      document.getElementById("kpiP").textContent = `p = ${fmt(p,2)}`;
      document.getElementById("kpiS0").textContent = `S0 = ${fmt(S.S0,2)}`;
      document.getElementById("kpiS").textContent = `s = (${fmt(s[0],2)}, ${fmt(s[1],2)}, ${fmt(s[2],2)})`;
      // x polarizer output: Jxx
      document.getElementById("kpiTx").innerHTML = `I<sub>out</sub> = ${fmt(J.Jxx,2)}`;
    }

    // ---------- Control wiring ----------
    const gmagEl = document.getElementById("gmag");
    const gmagValEl = document.getElementById("gmagVal");
    const gphaseEl = document.getElementById("gphase");

    document.getElementById("btnP0").addEventListener("click", ()=>{ gmagEl.value = 0; trigger(); });
    document.getElementById("btnP05").addEventListener("click", ()=>{ gmagEl.value = 0.5; trigger(); });
    document.getElementById("btnP1").addEventListener("click", ()=>{ gmagEl.value = 1; trigger(); });

    function trigger(){
      const gMag = parseFloat(gmagEl.value);
      const phi = parseFloat(gphaseEl.value);
      gmagValEl.textContent = fmt(gMag,2);

      updateKPIs(gMag, phi);
      updateLiveText(gMag, phi);

      drawDiagram(diag, gMag, phi);
      drawMainPlot(main, gMag);
      drawSecondaryPlot(sec, phi, gMag);
      drawEigenPlot(eig, gMag);
    }

    gmagEl.addEventListener("input", trigger);
    gphaseEl.addEventListener("change", trigger);

    // re-render on resize (ResizeObserver already resizes; we just redraw)
    window.addEventListener("resize", ()=>{ trigger(); });

    // initial render
    trigger();
  </script>
</body>
</html>
