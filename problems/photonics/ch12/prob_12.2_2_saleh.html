<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Number of Observable Fringes in Young’s Interferometer (Temporal Coherence)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --card2:#0f1730;
      --text:#eaf0ff;
      --muted:#b8c3ea;
      --faint:#7f8bb8;
      --accent:#7cf3c6;
      --accent2:#89a7ff;
      --warn:#ffd27d;
      --danger:#ff7f9a;
      --shadow: 0 18px 50px rgba(0,0,0,.35);
      --radius: 18px;
      --radius2: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --serif: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: var(--sans);
      background:
        radial-gradient(1200px 800px at 10% -10%, rgba(124,243,198,.18), transparent 55%),
        radial-gradient(900px 700px at 100% 0%, rgba(137,167,255,.18), transparent 55%),
        radial-gradient(900px 700px at 20% 100%, rgba(255,210,125,.10), transparent 60%),
        linear-gradient(180deg, #070b18, var(--bg));
      color: var(--text);
      line-height:1.55;
    }
    a{color:var(--accent2); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding: 28px 18px 10px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap: 16px;
      align-items:stretch;
    }
    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 18px 16px;
      position:relative;
      overflow:hidden;
    }
    .titleCard:before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(500px 200px at 10% 20%, rgba(124,243,198,.16), transparent 60%),
        radial-gradient(400px 220px at 80% 30%, rgba(137,167,255,.16), transparent 65%);
      filter: blur(0px);
      pointer-events:none;
    }
    .titleCard > *{position:relative}
    h1{
      margin: 4px 0 8px;
      font-size: clamp(22px, 2.6vw, 34px);
      letter-spacing: .2px;
      line-height:1.12;
    }
    .subtitle{
      color: var(--muted);
      margin:0;
      max-width: 72ch;
      font-size: 15.5px;
    }
    .metaRow{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top: 12px;
    }
    .pill{
      font-size: 12px;
      color: var(--muted);
      padding: 6px 10px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 999px;
    }
    .tocCard{
      background: rgba(17,26,51,.75);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
      position: sticky;
      top: 10px;
      align-self:start;
      height: fit-content;
    }
    .tocTitle{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      margin: 2px 0 8px;
    }
    .tocTitle strong{font-size: 13.5px; letter-spacing:.25px}
    .tocCard nav a{
      display:block;
      padding: 7px 9px;
      border-radius: 10px;
      color: var(--muted);
      font-size: 13px;
      border: 1px solid transparent;
    }
    .tocCard nav a:hover{
      background: rgba(255,255,255,.05);
      border-color: rgba(255,255,255,.10);
      color: var(--text);
      text-decoration:none;
    }
    main{
      max-width: 1200px;
      margin: 0 auto;
      padding: 6px 18px 46px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    section{
      background: rgba(17,26,51,.68);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px;
      overflow:hidden;
    }
    section h2{
      margin: 0 0 8px;
      font-size: 18px;
      letter-spacing:.2px;
    }
    section h3{
      margin: 14px 0 6px;
      font-size: 15.5px;
      letter-spacing:.15px;
      color: #f3f6ff;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns:1fr}
      .tocCard{position:relative; top:auto}
      .grid2{grid-template-columns:1fr}
    }
    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    @media (max-width: 980px){ .callouts{grid-template-columns:1fr} }
    .callout{
      background: rgba(15,23,48,.72);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius2);
      padding: 12px 12px 10px;
      position:relative;
    }
    .callout .label{
      font-size: 12px;
      color: var(--faint);
      letter-spacing:.25px;
      text-transform: uppercase;
      margin-bottom: 6px;
    }
    .callout ul{margin:6px 0 0 18px; color: var(--muted)}
    .kbox{
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding: 10px 10px 8px;
      margin: 10px 0 12px;
      overflow:auto;
    }
    .eqRow{
      display:flex; gap:10px; align-items:flex-start; justify-content:space-between;
    }
    .eq{
      font-family: var(--mono);
      font-size: 13px;
      white-space: pre-wrap;
      color: #e9f6ff;
      line-height:1.45;
      flex: 1;
      padding-right: 8px;
    }
    .btn{
      appearance:none;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12.5px;
      cursor:pointer;
      transition: transform .08s ease, background .15s ease, border-color .15s ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{background: rgba(255,255,255,.09); border-color: rgba(255,255,255,.22)}
    .btn:active{transform: scale(.98)}
    .note{
      color: var(--muted);
      margin: 8px 0 0;
      font-size: 14px;
    }
    .warn{
      border-left: 4px solid var(--warn);
      padding-left: 10px;
    }
    .danger{
      border-left: 4px solid var(--danger);
      padding-left: 10px;
    }
    .ok{
      border-left: 4px solid var(--accent);
      padding-left: 10px;
    }
    .vizWrap{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 14px;
      align-items: stretch;
    }
    @media (max-width: 980px){ .vizWrap{grid-template-columns:1fr} }
    .canvasCard{
      background: rgba(15,23,48,.75);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      padding: 12px;
      overflow:hidden;
      position:relative;
      min-height: 280px;
    }
    .canvasTitle{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      margin-bottom: 10px;
    }
    .canvasTitle strong{font-size: 13px; color: var(--muted); letter-spacing:.2px}
    canvas{
      width: 100%;
      height: 330px;
      display:block;
      border-radius: 14px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.08);
    }
    .controls{
      background: rgba(15,23,48,.75);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      padding: 12px;
      box-shadow: none;
      height: fit-content;
    }
    .controls h3{margin:0 0 10px; font-size: 14px; color: var(--muted)}
    .ctrl{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items:center;
      padding: 10px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
      margin-bottom: 10px;
    }
    .ctrl label{
      font-size: 13px;
      color: var(--muted);
      display:block;
    }
    .ctrl small{
      color: var(--faint);
      display:block;
      margin-top: 2px;
      font-size: 12px;
    }
    input[type="range"]{width: 100%}
    select{
      width: 100%;
      background: rgba(255,255,255,.06);
      color: var(--text);
      border: 1px solid rgba(255,255,255,.16);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 13px;
    }
    .readout{
      font-family: var(--mono);
      font-size: 12.5px;
      color: #e9f6ff;
      text-align:right;
      min-width: 9ch;
    }
    .resultCard{
      margin-top: 10px;
      padding: 12px;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(124,243,198,.10), rgba(0,0,0,.15));
    }
    .resultCard .big{
      font-size: 18px;
      margin: 0;
      letter-spacing:.2px;
    }
    .resultCard .sub{
      color: var(--muted);
      margin: 6px 0 0;
      font-size: 13.5px;
    }
    footer{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 18px 34px;
      color: var(--faint);
      font-size: 12.5px;
    }
    .fadeIn{
      animation: fadeInUp .5s ease both;
    }
    @keyframes fadeInUp{
      from{opacity:0; transform: translateY(8px)}
      to{opacity:1; transform: translateY(0)}
    }
    @media print{
      body{background:#fff; color:#000}
      section, .titleCard, .tocCard, .canvasCard, .controls{
        box-shadow:none !important;
        background:#fff !important;
        border: 1px solid #bbb !important;
      }
      a{color:#000; text-decoration: underline}
      .btn{display:none !important}
      .tocCard{position:relative; top:auto}
      canvas{border: 1px solid #bbb !important}
    }
  </style>
</head>

<body>
<header class="fadeIn">
  <div class="hero">
    <div class="titleCard">
      <h1>Number of Observable Fringes in Young’s Interferometer (Temporal Coherence)</h1>
      <p class="subtitle">
        We connect <em>finite spectral width</em> to <em>limited temporal coherence</em>, then estimate how many interference
        fringes remain visible before the pattern washes out.
      </p>
      <div class="metaRow">
        <span class="pill">Topic: Interference & coherence</span>
        <span class="pill">Key link: Δν ↔ τ<sub>c</sub> ↔ L<sub>c</sub></span>
        <span class="pill">Result: N<sub>fr</sub> ≈ L<sub>c</sub>/λ</span>
      </div>
      <p class="note warn" style="margin-top:12px;">
        <strong>Important:</strong> Your screenshot references “Table 12.1-2” (the light sources), but that table’s numerical
        values are not included. This article gives the complete method and the final formulas; you can plug in each source’s
        (λ, Δλ or Δν, spectral profile) from your Table 12.1-2. The interactive plots use clearly labeled <em>example values</em>.
      </p>
    </div>

    <aside class="tocCard" aria-label="Table of contents">
      <div class="tocTitle">
        <strong>Table of Contents</strong>
        <button class="btn" id="btnTop" title="Scroll to top">↑ Top</button>
      </div>
      <nav>
        <a href="#quick">Quick Summary</a>
        <a href="#part0">PART 0 — Concept Primer</a>
        <a href="#part1">PART 1 — Problem Analysis</a>
        <a href="#part2">PART 2 — Strategy & Tips</a>
        <a href="#part3">PART 3 — Full Solution</a>
        <a href="#part4">PART 4 — Deeper Understanding</a>
        <a href="#part5">PART 5 — Visualization Guide</a>
      </nav>
    </aside>
  </div>
</header>

<main>
  <!-- Quick Summary -->
  <section id="quick" class="fadeIn">
    <h2>Quick Summary</h2>
    <ul style="margin:8px 0 0 18px; color:var(--muted)">
      <li>We want the <strong>number of visible fringes</strong> in a Young’s (two-beam) interferometer when the source has a <strong>finite linewidth</strong>.</li>
      <li>Finite spectral width Δν (or Δλ) implies a finite <strong>coherence time</strong> τ<sub>c</sub>, hence a <strong>coherence length</strong> L<sub>c</sub> = c τ<sub>c</sub>.</li>
      <li>Interference visibility is governed by the first-order coherence magnitude |g<sup>(1)</sup>(τ)|, evaluated at delay τ = Δ/c (Δ = optical path difference).</li>
      <li>Fringes of order m require Δ ≈ mλ, so fringes persist roughly up to m ≲ L<sub>c</sub>/λ.</li>
      <li><strong>Core estimate:</strong> <span style="color:var(--text)"><strong>N<sub>fr</sub> ≈ L<sub>c</sub>/λ = (c τ<sub>c</sub>)/λ</strong></span> (order-of-magnitude; profile-dependent constants included below).</li>
      <li>Using the provided relation between Δν<sub>FWHM</sub> and τ<sub>c</sub> (Rectangular/Lorentzian/Gaussian), you can compute N<sub>fr</sub> for each source in Table 12.1-2.</li>
      <li>Final result type: <strong>symbolic formulas + plug-in numeric</strong> for each source’s λ and linewidth.</li>
    </ul>

    <div class="callouts">
      <div class="callout">
        <div class="label">Key Equations</div>
        <div class="kbox">
          <div class="eqRow">
            <div class="eq" id="eqKey1">L_c = c τ_c
N_fr ≈ L_c / λ = (c τ_c)/λ</div>
            <button class="btn" data-copy="#eqKey1">Copy</button>
          </div>
        </div>
        <div class="kbox">
          <div class="eqRow">
            <div class="eq" id="eqKey2">Given Δν_FWHM ↔ τ_c (profile-dependent):
Rectangular:   Δν = 1/τ_c
Lorentzian:    Δν = 1/(π τ_c)
Gaussian:      Δν = (√(2 ln2 / π))/τ_c ≈ 0.66/τ_c</div>
            <button class="btn" data-copy="#eqKey2">Copy</button>
          </div>
        </div>
      </div>

      <div class="callout">
        <div class="label">What you’ll compute per source (from Table 12.1-2)</div>
        <ul>
          <li>Central wavelength: λ (meters)</li>
          <li>Linewidth as Δν<sub>FWHM</sub> (Hz) or Δλ<sub>FWHM</sub> (m)</li>
          <li>Spectral profile: Rectangular / Lorentzian / Gaussian</li>
          <li>Then: τ<sub>c</sub> → L<sub>c</sub> → N<sub>fr</sub></li>
        </ul>
        <p class="note ok" style="margin-top:10px;">
          If your table gives Δλ (small compared to λ), use
          Δν ≈ (c/λ²) Δλ.
        </p>
      </div>
    </div>
  </section>

  <!-- PART 0 -->
  <section id="part0" class="fadeIn">
    <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

    <h3>Core definitions (symbols & units)</h3>
    <ul style="margin:6px 0 0 18px; color:var(--muted)">
      <li><strong>Optical path difference (OPD)</strong>: Δ (meters). In a two-beam interferometer, the phase difference is set by Δ.</li>
      <li><strong>Time delay</strong>: τ = Δ/c (seconds), where c is the speed of light.</li>
      <li><strong>Central wavelength / frequency</strong>: λ (m), ν<sub>0</sub> = c/λ (Hz).</li>
      <li><strong>Spectral width (FWHM)</strong>: Δν<sub>FWHM</sub> (Hz) or Δλ<sub>FWHM</sub> (m).</li>
      <li><strong>Coherence time</strong>: τ<sub>c</sub> (s). A characteristic time over which the field remains phase-correlated.</li>
      <li><strong>Coherence length</strong>: L<sub>c</sub> = c τ<sub>c</sub> (m).</li>
      <li><strong>First-order coherence</strong>: g<sup>(1)</sup>(τ) (dimensionless). Its magnitude controls fringe visibility.</li>
      <li><strong>Fringe visibility</strong>: V = (I<sub>max</sub>−I<sub>min</sub>)/(I<sub>max</sub>+I<sub>min</sub>) (dimensionless).</li>
    </ul>

    <h3>Physical meaning</h3>
    <p class="note">
      In Young’s interferometer, two copies of the same optical field meet with a relative delay τ. If the source has a
      perfectly single frequency, the phase relationship never drifts and fringes remain sharp for arbitrarily large Δ.
      Real sources have a spread of frequencies; different frequency components accumulate different phases with delay,
      causing the interference term to average out. The “distance” you can delay one beam before fringes fade is the
      coherence length L<sub>c</sub>.
    </p>

    <h3>Key principles & validity conditions</h3>
    <div class="callouts">
      <div class="callout">
        <div class="label">Interference with partial temporal coherence</div>
        <div class="kbox">
          <div class="eqRow">
            <div class="eq" id="eqI">For equal beam intensities (I1 = I2 = I0):
I(Δ) = 2 I0 [1 + |g^(1)(τ)| cos(2π Δ/λ)]
with τ = Δ/c</div>
            <button class="btn" data-copy="#eqI">Copy</button>
          </div>
        </div>
        <p class="note">
          The envelope |g<sup>(1)</sup>(τ)| reduces the contrast as OPD grows.
        </p>
      </div>

      <div class="callout">
        <div class="label">When this model applies</div>
        <ul>
          <li>Stationary, quasi-monochromatic light (Δν ≪ ν<sub>0</sub>).</li>
          <li>Two-beam interference; polarization matched.</li>
          <li><strong>Full spatial coherence</strong> (as the problem states): the two slits are mutually coherent spatially.</li>
          <li>We focus on <strong>temporal coherence</strong> (spectral width) as the limiting factor for visibility.</li>
        </ul>
      </div>
    </div>

    <h3>Common models (why we use them)</h3>
    <p class="note">
      The precise |g<sup>(1)</sup>(τ)| depends on the spectral shape S(ν) because g<sup>(1)</sup> is essentially the
      normalized Fourier transform of S(ν). Many textbooks use idealized profiles:
      <strong>rectangular</strong> (uniform band), <strong>Lorentzian</strong> (typical of homogeneously broadened lines),
      and <strong>Gaussian</strong> (typical of inhomogeneous broadening). Your provided table links Δν<sub>FWHM</sub>
      to τ<sub>c</sub> with profile-dependent constants.
    </p>

    <h3>Mini intuition examples</h3>
    <ul style="margin:6px 0 0 18px; color:var(--muted)">
      <li><strong>Narrow-line laser:</strong> Δλ tiny ⇒ τ<sub>c</sub> huge ⇒ many thousands/millions of fringes can be visible.</li>
      <li><strong>LED:</strong> Δλ tens of nm ⇒ τ<sub>c</sub> very small ⇒ only a few fringes before washout.</li>
    </ul>

    <h3>What to watch for (pitfalls)</h3>
    <ul style="margin:6px 0 0 18px; color:var(--muted)">
      <li>Mixing Δλ and Δν without converting: Δν ≈ (c/λ²)Δλ for small fractional bandwidth.</li>
      <li>Confusing “fringes across the screen” (set by geometry) with “fringes that remain visible” (set by coherence).</li>
      <li>For Lorentzian/Gaussian, τ<sub>c</sub> differs by constants from 1/Δν; use the correct profile factor.</li>
      <li>Remember: the problem states <strong>full spatial coherence</strong>, so only temporal coherence limits visibility.</li>
    </ul>
  </section>

  <!-- PART 1 -->
  <section id="part1" class="fadeIn">
    <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

    <h3>Restate the problem</h3>
    <p class="note">
      For a Young’s interferometer (two-slit interference), determine how many interference fringes are observable
      when the light source has a given spectral width (as listed for each source in Table 12.1-2).
      Assume full spatial coherence for all sources.
    </p>

    <div class="grid2">
      <div class="callout">
        <div class="label">Given (from your book)</div>
        <ul>
          <li>Each source i has a central wavelength λ<sub>i</sub>.</li>
          <li>Each source i has linewidth Δν<sub>i</sub> (or Δλ<sub>i</sub>), typically FWHM.</li>
          <li>Spectral profile model (rectangular / Lorentzian / Gaussian) determines Δν ↔ τ<sub>c</sub>.</li>
          <li>Full spatial coherence.</li>
        </ul>
      </div>

      <div class="callout">
        <div class="label">Unknowns (per source)</div>
        <ul>
          <li>Coherence time τ<sub>c</sub></li>
          <li>Coherence length L<sub>c</sub></li>
          <li>Number of observable fringes N<sub>fr</sub></li>
        </ul>
      </div>
    </div>

    <h3>Relevant principles (and why)</h3>
    <ul style="margin:6px 0 0 18px; color:var(--muted)">
      <li><strong>Temporal coherence controls fringe visibility</strong>: two waves with delay τ interfere with contrast proportional to |g<sup>(1)</sup>(τ)|.</li>
      <li><strong>Finite bandwidth</strong> → finite coherence time: the field’s phase correlation decays with τ.</li>
      <li><strong>Fringe order relates to OPD</strong>: the m-th bright fringe occurs near Δ ≈ mλ, so increasing m probes larger Δ.</li>
    </ul>

    <div class="callouts">
      <div class="callout">
        <div class="label">Assumptions (explicit)</div>
        <ul>
          <li>Quasi-monochromatic approximation: Δν ≪ ν<sub>0</sub>.</li>
          <li>Equal polarization and stable alignment (no extra visibility loss).</li>
          <li>Spatial coherence is complete (so slit separation is within the spatial coherence area).</li>
          <li>“Observable fringes” interpreted as those within the coherence envelope set by τ<sub>c</sub>.</li>
        </ul>
      </div>

      <div class="callout">
        <div class="label">Approach options</div>
        <ul>
          <li><strong>Coherence-length estimate (best for this problem):</strong> compute τ<sub>c</sub> from Δν, then N<sub>fr</sub> ≈ (c τ<sub>c</sub>)/λ.</li>
          <li><strong>Full visibility-envelope method:</strong> compute |g<sup>(1)</sup>(τ)| from the Fourier transform of S(ν), choose a visibility threshold, and find max m.</li>
          <li><strong>Time-domain wave packet picture:</strong> interpret the source as packets of length L<sub>c</sub>; fringes persist while packets overlap.</li>
        </ul>
        <p class="note">
          The book’s Table 12.1-1 already gives Δν ↔ τ<sub>c</sub>, so the coherence-length estimate is the intended route.
        </p>
      </div>
    </div>
  </section>

  <!-- PART 2 -->
  <section id="part2" class="fadeIn">
    <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

    <ol style="margin:8px 0 0 18px; color:var(--muted)">
      <li><strong>Read source data</strong> (goal: identify λ and linewidth). Use λ and either Δν or Δλ (FWHM).</li>
      <li><strong>If needed, convert Δλ → Δν</strong> using Δν ≈ (c/λ²)Δλ (goal: consistent units in Hz).</li>
      <li><strong>Choose spectral profile</strong> (rectangular/Lorentzian/Gaussian) (goal: pick the correct constant linking Δν and τ<sub>c</sub>).</li>
      <li><strong>Compute coherence time τ<sub>c</sub></strong> from Table 12.1-1 (goal: quantify temporal coherence).</li>
      <li><strong>Compute coherence length L<sub>c</sub> = c τ<sub>c</sub></strong> (goal: distance-scale for interference survival).</li>
      <li><strong>Estimate max observable order</strong> m<sub>max</sub> ≈ L<sub>c</sub>/λ (goal: how many wavelength OPDs fit under the coherence length).</li>
      <li><strong>Report number of fringes</strong>: N<sub>fr</sub> ≈ m<sub>max</sub> (single-sided) or ≈ 2m<sub>max</sub>+1 (both sides + central), depending on convention (goal: match your course/book wording).</li>
      <li><strong>Sanity checks</strong>: larger Δν should reduce N; shorter λ (higher ν<sub>0</sub>) generally increases N for fixed τ<sub>c</sub>.</li>
    </ol>

    <div class="callouts">
      <div class="callout">
        <div class="label">Common mistakes</div>
        <ul>
          <li>Forgetting that Δν is in Hz (not rad/s).</li>
          <li>Using τ<sub>c</sub> = 1/Δν for every profile (wrong for Lorentzian/Gaussian).</li>
          <li>Confusing “coherence length” with geometric path lengths in the setup; L<sub>c</sub> is a property of the source.</li>
        </ul>
      </div>
      <div class="callout">
        <div class="label">Quick tips</div>
        <ul>
          <li>Keep λ in meters and Δλ in meters (nm → 1e−9 m).</li>
          <li>If your table gives Δν directly, you can skip conversion.</li>
          <li>If the book expects “number of observable fringes,” it often means order-of-magnitude N ≈ L<sub>c</sub>/λ.</li>
        </ul>
      </div>
    </div>
  </section>

  <!-- PART 3 -->
  <section id="part3" class="fadeIn">
    <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

    <h3>Physical intuition (before math)</h3>
    <p class="note">
      The m-th bright fringe corresponds to an OPD of about mλ. If the source remains phase-correlated only for delays up to τ<sub>c</sub>,
      then once Δ/c exceeds τ<sub>c</sub>, different frequency components no longer “agree” on the phase and the bright/dark modulation fades.
      Therefore the last clearly visible fringes should occur when Δ is on the order of the coherence length L<sub>c</sub> = cτ<sub>c</sub>.
      That immediately suggests m<sub>max</sub> ≈ L<sub>c</sub>/λ.
    </p>

    <h3>Step 1: Interference intensity with partial temporal coherence</h3>
    <p class="note">
      For two equal-intensity beams (a standard Young’s interferometer idealization), the intensity as a function of OPD Δ is:
    </p>
    <div class="kbox">
      <div class="eqRow">
        <div class="eq" id="eq3_1">Let Δ = optical path difference (m), τ = Δ/c (s).
If I1 = I2 = I0, then:

I(Δ) = 2 I0 [ 1 + |g^(1)(τ)| cos( 2π Δ / λ ) ]</div>
        <button class="btn" data-copy="#eq3_1">Copy</button>
      </div>
    </div>
    <p class="note">
      <strong>What we did & why:</strong> We separated the rapid oscillation (cos term, creating fringes) from the slowly varying envelope
      |g<sup>(1)</sup>(τ)| (reducing contrast with delay). Thus, “how many fringes are visible” is governed by how far in Δ we can go before |g<sup>(1)</sup>| becomes small.
    </p>

    <h3>Step 2: Relate coherence time τ<sub>c</sub> to linewidth Δν<sub>FWHM</sub></h3>
    <p class="note">
      Your Table 12.1-1 provides the convenient empirical relations (for different spectral profiles):
    </p>
    <div class="kbox">
      <div class="eqRow">
        <div class="eq" id="eq3_2">Profile-dependent linewidth–coherence relation (FWHM):

Rectangular:  Δν_FWHM = 1/τ_c        ⇒ τ_c = 1/Δν
Lorentzian:   Δν_FWHM = 1/(π τ_c)    ⇒ τ_c = 1/(π Δν)
Gaussian:     Δν_FWHM = 0.66/τ_c     ⇒ τ_c = 0.66/Δν</div>
        <button class="btn" data-copy="#eq3_2">Copy</button>
      </div>
    </div>
    <p class="note">
      <strong>What we did & why:</strong> We used the book’s mapping so we don’t need to re-derive g<sup>(1)</sup> from S(ν).
      The constants differ because different spectral shapes Fourier-transform to different temporal correlation shapes.
    </p>

    <h3>Step 3: Convert Δλ to Δν (if needed)</h3>
    <p class="note">
      If Table 12.1-2 lists linewidth in wavelength units (Δλ) and the fractional bandwidth is small, then:
    </p>
    <div class="kbox">
      <div class="eqRow">
        <div class="eq" id="eq3_3">ν = c/λ  ⇒  dν/dλ = -c/λ^2

For small widths (FWHM):
Δν ≈ (c/λ^2) Δλ   (use magnitudes)</div>
        <button class="btn" data-copy="#eq3_3">Copy</button>
      </div>
    </div>
    <p class="note">
      <strong>Sanity check:</strong> If Δλ increases, then Δν increases, so τ<sub>c</sub> decreases — exactly what we expect.
    </p>

    <h3>Step 4: Coherence length and maximum fringe order</h3>
    <p class="note">
      Define coherence length:
    </p>
    <div class="kbox">
      <div class="eqRow">
        <div class="eq" id="eq3_4">L_c = c τ_c</div>
        <button class="btn" data-copy="#eq3_4">Copy</button>
      </div>
    </div>

    <p class="note">
      The m-th fringe corresponds to OPD approximately:
    </p>
    <div class="kbox">
      <div class="eqRow">
        <div class="eq" id="eq3_5">Bright fringe order m:  Δ_m ≈ m λ</div>
        <button class="btn" data-copy="#eq3_5">Copy</button>
      </div>
    </div>

    <p class="note">
      Fringes remain visible roughly as long as the OPD stays within the coherence length scale, so set Δ<sub>max</sub> ~ L<sub>c</sub>:
    </p>
    <div class="kbox">
      <div class="eqRow">
        <div class="eq" id="eq3_6">Δ_max ~ L_c  ⇒  m_max ≈ Δ_max/λ ≈ L_c/λ = (c τ_c)/λ</div>
        <button class="btn" data-copy="#eq3_6">Copy</button>
      </div>
    </div>

    <div class="callout" style="margin-top:12px; border-left:4px solid var(--accent);">
      <div class="label">Final Answer (boxed)</div>
      <div class="kbox">
        <div class="eqRow">
          <div class="eq" id="eqFinal">For a source of central wavelength λ and linewidth Δν_FWHM:

N_fr ≈ m_max ≈ (c τ_c)/λ

Using Table 12.1-1:

Rectangular:  N_fr ≈ c/(λ Δν)
Lorentzian:   N_fr ≈ c/(π λ Δν)
Gaussian:     N_fr ≈ 0.66 c/(λ Δν)

If linewidth is given as Δλ (small bandwidth):
Δν ≈ (c/λ^2)Δλ  ⇒

Rectangular:  N_fr ≈ λ/Δλ
Lorentzian:   N_fr ≈ (1/π) (λ/Δλ)
Gaussian:     N_fr ≈ 0.66 (λ/Δλ)</div>
          <button class="btn" data-copy="#eqFinal">Copy</button>
        </div>
      </div>
      <button class="btn" id="btnCopyAnswer">Copy plain-text final answer</button>
      <p class="note" style="margin-top:8px;">
        Convention note: If your book counts fringes on <em>both sides</em> of the central maximum, use
        N<sub>total</sub> ≈ 2⌊m<sub>max</sub>⌋ + 1.
      </p>
    </div>

    <h3>Sanity checks</h3>
    <ul style="margin:6px 0 0 18px; color:var(--muted)">
      <li><strong>Units:</strong> c/(λΔν) → (m/s)/(m·1/s) → dimensionless ✔</li>
      <li><strong>Limiting case:</strong> Δν → 0 ⇒ N → ∞ (perfect monochromaticity gives unlimited fringes) ✔</li>
      <li><strong>Physical meaning:</strong> N is approximately the number of optical wavelengths that fit into one coherence length.</li>
    </ul>

    <h3>Connection to the diagram & plots</h3>
    <p class="note">
      The diagram shows two paths from the source through the two slits to a screen point. Moving along the screen changes the path difference Δ.
      The main plot displays how visibility |g<sup>(1)</sup>(Δ/c)| decays with Δ for different spectral profiles.
      The secondary plot shows how the estimated number of fringes N<sub>fr</sub> changes as the linewidth Δλ is swept.
    </p>
  </section>

  <!-- Visualizations -->
  <section class="fadeIn" aria-label="Interactive visualizations">
    <h2>Interactive Visualizations (Diagram + Plots)</h2>
    <div class="vizWrap">
      <div>
        <div class="canvasCard">
          <div class="canvasTitle">
            <strong>Diagram: Young’s interferometer geometry (conceptual)</strong>
            <button class="btn" id="btnRedraw">Redraw</button>
          </div>
          <canvas id="cvDiagram" aria-label="Young interferometer diagram"></canvas>
          <p class="note">
            The key quantity for temporal coherence is the <strong>optical path difference</strong> Δ between the two arms/slits to a given screen point.
          </p>
        </div>

        <div class="canvasCard" style="margin-top:14px;">
          <div class="canvasTitle">
            <strong>Main plot: Visibility envelope |g<sup>(1)</sup>(Δ/c)| vs OPD Δ</strong>
            <button class="btn" id="btnPNG1" title="Copy plot values (not an image)">Copy curve data</button>
          </div>
          <canvas id="cvMain" aria-label="Visibility vs OPD plot"></canvas>
          <p class="note">
            The vertical marker indicates Δ = L<sub>c</sub>. The oscillatory fringes ride on this envelope; as the envelope falls, fringes become hard to observe.
          </p>
        </div>

        <div class="canvasCard" style="margin-top:14px;">
          <div class="canvasTitle">
            <strong>Secondary plot: Fringe count estimate N<sub>fr</sub> vs linewidth Δλ (sweep)</strong>
            <button class="btn" id="btnPNG2" title="Copy sweep data (not an image)">Copy sweep data</button>
          </div>
          <canvas id="cvSweep" aria-label="Nfr vs linewidth sweep plot"></canvas>
          <p class="note">
            This shows why broadband sources wash out quickly: N<sub>fr</sub> scales roughly as λ/Δλ (up to profile constants).
          </p>
        </div>
      </div>

      <aside class="controls">
        <h3>Interactive controls (example values for plotting)</h3>

        <div class="ctrl">
          <div>
            <label for="selProfile">Spectral profile model</label>
            <small>Matches the constants in Table 12.1-1</small>
            <select id="selProfile">
              <option value="rect">Rectangular</option>
              <option value="lor">Lorentzian</option>
              <option value="gauss" selected>Gaussian</option>
            </select>
          </div>
          <div class="readout" id="rdProfile">Gaussian</div>
        </div>

        <div class="ctrl">
          <div style="width:100%;">
            <label for="rngLambda">Central wavelength λ (nm)</label>
            <small>Use your Table 12.1-2 value when computing final results</small>
            <input type="range" id="rngLambda" min="400" max="1600" step="1" value="632"/>
          </div>
          <div class="readout" id="rdLambda">632 nm</div>
        </div>

        <div class="ctrl">
          <div style="width:100%;">
            <label for="rngLogDL">Linewidth Δλ (nm, logarithmic slider)</label>
            <small>Slide spans ~10<sup>-3</sup> nm (laser-like) to 10<sup>2</sup> nm (broadband)</small>
            <input type="range" id="rngLogDL" min="-3" max="2" step="0.01" value="0.7"/>
          </div>
          <div class="readout" id="rdDL">5.01 nm</div>
        </div>

        <div class="resultCard">
          <p class="big" id="rdNfr">Nfr ≈ 83</p>
          <p class="sub" id="rdLc">Lc ≈ 52.4 μm, τc ≈ 0.175 ps, Δν ≈ 3.77 THz</p>
        </div>

        <div class="callout" style="margin-top:12px;">
          <div class="label">How to use with your Table 12.1-2</div>
          <ol style="margin:6px 0 0 18px; color:var(--muted)">
            <li>Pick the source’s λ and Δλ (or Δν).</li>
            <li>Select the appropriate profile (if specified).</li>
            <li>Compute τ<sub>c</sub> from Table 12.1-1.</li>
            <li>Compute N<sub>fr</sub> from the boxed formula in PART 3.</li>
          </ol>
        </div>
      </aside>
    </div>
  </section>

  <!-- PART 4 -->
  <section id="part4" class="fadeIn">
    <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

    <h3>Re-interpreting the final formula</h3>
    <p class="note">
      The compact estimate
      <strong>N<sub>fr</sub> ≈ (c τ<sub>c</sub>)/λ</strong>
      can be read as:
      <em>“How many optical wavelengths fit into the coherence length.”</em>
      So, anything that increases τ<sub>c</sub> (narrower linewidth) increases the number of visible fringes.
    </p>

    <h3>Parameter dependence (connect to plots)</h3>
    <ul style="margin:6px 0 0 18px; color:var(--muted)">
      <li><strong>Increase Δλ (broaden spectrum):</strong> Δν increases → τ<sub>c</sub> decreases → L<sub>c</sub> decreases → fewer visible fringes (sweep plot drops).</li>
      <li><strong>Increase λ (longer wavelength):</strong> for the same τ<sub>c</sub>, N<sub>fr</sub> decreases because each fringe requires ~λ of OPD.</li>
      <li><strong>Change spectral profile:</strong> Lorentzian gives smaller τ<sub>c</sub> (for same Δν) than rectangular; Gaussian sits in between via the 0.66 factor.</li>
    </ul>

    <h3>Alternative derivation idea (brief)</h3>
    <p class="note">
      Instead of using τ<sub>c</sub> directly, you can compute the visibility envelope from the normalized Fourier transform
      of the spectrum S(ν). For example, a Lorentzian S(ν) produces an exponential coherence decay
      |g<sup>(1)</sup>(τ)| = exp(−πΔν|τ|). Defining “observable” via a threshold (say V ≥ 0.1) gives a specific Δ<sub>max</sub> and hence a specific m<sub>max</sub>.
      The book’s τ<sub>c</sub> approach encodes these ideas into a single characteristic scale.
    </p>

    <h3>Concept checks (with answers)</h3>
    <ul style="margin:6px 0 0 18px; color:var(--muted)">
      <li><strong>Q:</strong> Why does larger bandwidth reduce fringes? <strong>A:</strong> More frequencies dephase faster with delay, so the interference term averages out sooner.</li>
      <li><strong>Q:</strong> If spatial coherence were not “full,” what changes? <strong>A:</strong> Even at Δ≈0 the visibility could be reduced; the pattern may blur or disappear regardless of τ<sub>c</sub>.</li>
      <li><strong>Q:</strong> Does Young’s geometry (slit spacing, screen distance) enter N<sub>fr</sub>? <strong>A:</strong> It sets fringe spacing on the screen, but the *maximum order before washout* is set primarily by temporal coherence L<sub>c</sub>.</li>
      <li><strong>Q:</strong> What does N<sub>fr</sub>≈λ/Δλ mean? <strong>A:</strong> The fractional bandwidth Δλ/λ is roughly the inverse of the number of coherent cycles.</li>
    </ul>
  </section>

  <!-- PART 5 -->
  <section id="part5" class="fadeIn">
    <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

    <h3>Diagram canvas</h3>
    <p class="note">
      The diagram shows a source illuminating two slits separated by distance d, producing interference on a screen at distance L.
      A point on the screen at transverse coordinate x has a path difference approximately
      Δ ≈ d x / L (small-angle). As you move outward (larger |x|), Δ increases.
    </p>

    <h3>Main plot: visibility vs OPD</h3>
    <p class="note">
      The curve is the magnitude of the first-order coherence |g<sup>(1)</sup>(Δ/c)| for the selected spectral profile.
      A vertical line marks Δ = L<sub>c</sub>. Near Δ=0 the visibility is near 1 (high contrast). As |Δ| approaches and exceeds
      L<sub>c</sub>, contrast falls and fringes become difficult to observe.
    </p>

    <h3>Secondary plot: N<sub>fr</sub> vs Δλ sweep</h3>
    <p class="note">
      This plot sweeps Δλ over many decades (log axis) and displays the resulting N<sub>fr</sub> estimate.
      It visualizes the approximate scaling N<sub>fr</sub> ∝ 1/Δλ (or ∝ 1/Δν), with profile-dependent constants.
    </p>

    <h3>Interactive controls</h3>
    <ul style="margin:6px 0 0 18px; color:var(--muted)">
      <li><strong>Spectral profile:</strong> changes the Δν–τ<sub>c</sub> constant and the visibility-envelope shape in the main plot.</li>
      <li><strong>λ slider:</strong> updates conversion Δλ → Δν and rescales N<sub>fr</sub> via N<sub>fr</sub> ≈ (cτ<sub>c</sub>)/λ.</li>
      <li><strong>Δλ slider (log):</strong> strongly changes τ<sub>c</sub> and L<sub>c</sub>; watch the envelope shrink and N<sub>fr</sub> drop.</li>
    </ul>
  </section>
</main>

<footer class="fadeIn">
  <p>
    © Coherence & interference tutorial. Uses only vanilla HTML/CSS/JS. Numerical values in the interactive panel are
    <strong>example values for visualization</strong> unless you set them to match your Table 12.1-2.
  </p>
</footer>

<script>
/* -----------------------------
   Utilities
------------------------------ */
const C = 299792458; // m/s
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function fmtSI(x, unit){
  // Simple SI formatter with a few prefixes
  const abs = Math.abs(x);
  const prefixes = [
    {p:1e-15, s:"f"}, {p:1e-12, s:"p"}, {p:1e-9, s:"n"}, {p:1e-6, s:"µ"},
    {p:1e-3, s:"m"}, {p:1, s:""}, {p:1e3, s:"k"}, {p:1e6, s:"M"}, {p:1e9, s:"G"}, {p:1e12, s:"T"}
  ];
  let best = prefixes[5];
  for(const pr of prefixes){
    if(abs >= pr.p) best = pr;
  }
  const val = x / best.p;
  const digits = (Math.abs(val) >= 100) ? 3 : (Math.abs(val) >= 10) ? 3 : 3;
  return `${val.toPrecision(digits)} ${best.s}${unit}`;
}
function fmtNum(x, digits=3){
  if(!isFinite(x)) return "—";
  return Number(x).toPrecision(digits);
}
function pow10(a){ return Math.pow(10,a); }
function ln(x){ return Math.log(x); }

/* -----------------------------
   Coherence model
   Using Table 12.1-1 mapping: Δν_FWHM = k / τc  -> τc = k / Δν
------------------------------ */
function kProfile(profile){
  if(profile === "rect") return 1.0;      // Δν = 1/τc
  if(profile === "lor")  return 1.0/Math.PI; // Δν = 1/(π τc) => τc = 1/(π Δν) = (1/π)/Δν
  if(profile === "gauss")return 0.66;     // Δν ≈ 0.66/τc => τc = 0.66/Δν
  return 1.0;
}
// Visibility envelopes |g^(1)(τ)| for typical normalized spectra (FWHM = Δν).
function g1abs(profile, deltaNu, tau){
  const t = Math.abs(tau);
  if(deltaNu <= 0) return 1;
  if(profile === "lor"){
    // Lorentzian spectrum -> exponential coherence: exp(-π Δν |τ|)
    return Math.exp(-Math.PI * deltaNu * t);
  }
  if(profile === "gauss"){
    // Gaussian spectrum (FWHM Δν): |g1| = exp(-(π Δν τ)^2/(4 ln2))
    const a = (Math.PI * deltaNu * t);
    return Math.exp(-(a*a)/(4*Math.log(2)));
  }
  // Rectangular spectrum (width Δν): |g1| = |sinc(Δν τ)| where sinc(x)=sin(πx)/(πx)
  const x = deltaNu * t;
  if(Math.abs(x) < 1e-12) return 1;
  return Math.abs(Math.sin(Math.PI * x) / (Math.PI * x));
}

/* -----------------------------
   Canvas helpers (HiDPI crisp + responsive)
------------------------------ */
function setupCanvas(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(10, Math.floor(rect.width));
  const h = Math.max(10, Math.floor(rect.height));
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  const ctx = canvas.getContext("2d");
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return {ctx, w, h, dpr};
}
function clear(ctx, w, h){
  ctx.clearRect(0,0,w,h);
}
function roundRect(ctx, x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}
function drawGrid(ctx, x0,y0,w,h, nx=6, ny=5){
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.lineWidth = 1;
  for(let i=0;i<=nx;i++){
    const x = x0 + (w*i)/nx;
    ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+h); ctx.stroke();
  }
  for(let j=0;j<=ny;j++){
    const y = y0 + (h*j)/ny;
    ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+w,y); ctx.stroke();
  }
  ctx.restore();
}
function axes(ctx, plot){
  const {x0,y0,w,h} = plot;
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(x0,y0); ctx.lineTo(x0,y0+h); ctx.lineTo(x0+w,y0+h);
  ctx.stroke();
  ctx.restore();
}
function ticks(ctx, plot, xTicks, yTicks, xFmt, yFmt){
  const {x0,y0,w,h} = plot;
  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,0.70)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.lineWidth = 1;
  // X ticks
  xTicks.forEach(t=>{
    const x = x0 + t.pos*w;
    const y = y0+h;
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x,y+6); ctx.stroke();
    ctx.fillText(xFmt(t.val), x-14, y+18);
  });
  // Y ticks
  yTicks.forEach(t=>{
    const y = y0 + (1-t.pos)*h;
    const x = x0;
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x-6,y); ctx.stroke();
    ctx.fillText(yFmt(t.val), x-48, y+4);
  });
  ctx.restore();
}
function title(ctx, w, txt){
  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,0.82)";
  ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText(txt, 12, 18);
  ctx.restore();
}
function label(ctx, txt, x, y, align="left"){
  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,0.78)";
  ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.textAlign = align;
  ctx.fillText(txt, x, y);
  ctx.restore();
}

/* -----------------------------
   State + DOM bindings
------------------------------ */
const dom = {
  btnTop: document.getElementById("btnTop"),
  btnRedraw: document.getElementById("btnRedraw"),
  btnCopyAnswer: document.getElementById("btnCopyAnswer"),
  btnPNG1: document.getElementById("btnPNG1"),
  btnPNG2: document.getElementById("btnPNG2"),
  selProfile: document.getElementById("selProfile"),
  rngLambda: document.getElementById("rngLambda"),
  rngLogDL: document.getElementById("rngLogDL"),
  rdProfile: document.getElementById("rdProfile"),
  rdLambda: document.getElementById("rdLambda"),
  rdDL: document.getElementById("rdDL"),
  rdNfr: document.getElementById("rdNfr"),
  rdLc: document.getElementById("rdLc"),
  cvDiagram: document.getElementById("cvDiagram"),
  cvMain: document.getElementById("cvMain"),
  cvSweep: document.getElementById("cvSweep"),
};

const state = {
  profile: dom.selProfile.value,
  lambda_nm: Number(dom.rngLambda.value),
  logDL: Number(dom.rngLogDL.value), // Δλ in nm = 10^logDL
};

function currentParams(){
  const lambda = state.lambda_nm * 1e-9;         // m
  const dLambda = pow10(state.logDL) * 1e-9;     // m
  const deltaNu = (C/(lambda*lambda)) * dLambda; // Hz (approx)
  const k = kProfile(state.profile);
  const tauC = (deltaNu>0) ? (k / deltaNu) : Infinity; // s
  const Lc = C * tauC; // m
  const Nfr = (lambda>0) ? (Lc / lambda) : 0; // dimensionless
  return {lambda, dLambda, deltaNu, tauC, Lc, Nfr, k};
}

/* -----------------------------
   Drawing: Diagram
------------------------------ */
function drawDiagram(){
  const {ctx, w, h} = setupCanvas(dom.cvDiagram);
  clear(ctx,w,h);
  // Background panel
  ctx.save();
  roundRect(ctx, 8, 8, w-16, h-16, 14);
  ctx.fillStyle = "rgba(0,0,0,0.18)";
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.restore();

  title(ctx, w, "Young’s Interferometer: OPD Δ arises from different path lengths");

  // Coordinates
  const pad = 34;
  const xL = pad, xR = w - pad;
  const yTop = 36, yBot = h - pad;

  // Source point
  const sx = xL + 35, sy = yTop + 55;

  // Slits
  const slitX = xL + 170;
  const d = 60; // pixel slit separation
  const s1y = sy - d/2, s2y = sy + d/2;

  // Screen
  const screenX = xR - 40;
  const screenY1 = yTop + 35;
  const screenY2 = yBot - 25;

  // Draw source
  ctx.save();
  ctx.fillStyle = "rgba(124,243,198,0.95)";
  ctx.beginPath(); ctx.arc(sx, sy, 5, 0, Math.PI*2); ctx.fill();
  label(ctx, "Source", sx+10, sy-10);
  ctx.restore();

  // Draw barrier with slits
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.22)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(slitX, yTop+20);
  ctx.lineTo(slitX, yBot-10);
  ctx.stroke();

  // Slit markers
  ctx.fillStyle = "rgba(137,167,255,0.95)";
  ctx.fillRect(slitX-3, s1y-8, 6, 16);
  ctx.fillRect(slitX-3, s2y-8, 6, 16);
  label(ctx, "Slits", slitX-18, yTop+16);
  label(ctx, "d", slitX+12, sy);
  // d arrow
  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  ctx.lineWidth = 1.2;
  ctx.beginPath(); ctx.moveTo(slitX+10, s1y); ctx.lineTo(slitX+10, s2y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(slitX+6, s1y+6); ctx.lineTo(slitX+10, s1y); ctx.lineTo(slitX+14, s1y+6); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(slitX+6, s2y-6); ctx.lineTo(slitX+10, s2y); ctx.lineTo(slitX+14, s2y-6); ctx.stroke();
  ctx.restore();

  // Draw screen
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(screenX, screenY1); ctx.lineTo(screenX, screenY2); ctx.stroke();
  label(ctx, "Screen", screenX-18, screenY1-8, "left");
  ctx.restore();

  // Pick a point on screen (observation point)
  const px = screenX, py = sy + 35;
  ctx.save();
  ctx.fillStyle = "rgba(255,210,125,0.95)";
  ctx.beginPath(); ctx.arc(px, py, 4.5, 0, Math.PI*2); ctx.fill();
  label(ctx, "Point P(x)", px-8, py+18, "right");
  ctx.restore();

  // Rays
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  ctx.lineWidth = 1.4;
  // source to slits
  ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(slitX, s1y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(slitX, s2y); ctx.stroke();

  // slits to P
  ctx.strokeStyle = "rgba(124,243,198,0.55)";
  ctx.beginPath(); ctx.moveTo(slitX, s1y); ctx.lineTo(px, py); ctx.stroke();
  ctx.strokeStyle = "rgba(137,167,255,0.55)";
  ctx.beginPath(); ctx.moveTo(slitX, s2y); ctx.lineTo(px, py); ctx.stroke();
  ctx.restore();

  // OPD annotation
  ctx.save();
  label(ctx, "Δ = (path 2) − (path 1)", w*0.52, h-18, "center");
  ctx.restore();

  // Small fringe sketch on screen
  ctx.save();
  for(let i=-4;i<=4;i++){
    const yy = py + i*14;
    const amp = Math.exp(-(i*i)/10);
    ctx.strokeStyle = `rgba(255,255,255,${0.10 + 0.25*amp})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(screenX, yy);
    ctx.lineTo(screenX+14, yy);
    ctx.stroke();
  }
  ctx.restore();
}

/* -----------------------------
   Drawing: Main plot (visibility vs OPD)
------------------------------ */
function drawMain(){
  const {ctx, w, h} = setupCanvas(dom.cvMain);
  clear(ctx,w,h);

  // Panel
  ctx.save();
  roundRect(ctx, 8, 8, w-16, h-16, 14);
  ctx.fillStyle = "rgba(0,0,0,0.18)";
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.restore();

  const p = currentParams();
  const profile = state.profile;
  const deltaNu = p.deltaNu;
  const tauC = p.tauC;
  const Lc = p.Lc;

  title(ctx, w, "Visibility envelope vs optical path difference");
  // Plot region
  const x0 = 60, y0 = 34, pw = w - 80, ph = h - 74;
  drawGrid(ctx, x0, y0, pw, ph, 6, 5);
  axes(ctx, {x0,y0,w:pw,h:ph});

  // x-axis range: show +/- 2 Lc (or some default if Lc huge)
  let xmax = 2*Lc;
  if(!isFinite(xmax) || xmax <= 0){
    xmax = 0.02; // 2 cm fallback
  }
  // Clamp to a reasonable window for very large coherence lengths (so we still see a curve)
  xmax = clamp(xmax, 1e-6, 0.5); // between 1 µm and 0.5 m
  const xmin = -xmax;

  // y: visibility 0..1
  function X(Delta){ return x0 + (Delta - xmin) * (pw/(xmax-xmin)); }
  function Y(V){ return y0 + (1 - V) * ph; }

  // Draw curve
  ctx.save();
  ctx.lineWidth = 2.2;
  ctx.strokeStyle = "rgba(124,243,198,0.85)";
  ctx.beginPath();
  const N = 600;
  for(let i=0;i<=N;i++){
    const Delta = xmin + (xmax-xmin)*i/N;
    const tau = Delta / C;
    const V = g1abs(profile, deltaNu, tau);
    const x = X(Delta), y = Y(V);
    if(i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.restore();

  // Lc marker
  ctx.save();
  const xLc = X(clamp(Lc, xmin, xmax));
  ctx.strokeStyle = "rgba(255,210,125,0.75)";
  ctx.lineWidth = 1.6;
  ctx.setLineDash([6,6]);
  ctx.beginPath(); ctx.moveTo(xLc,y0); ctx.lineTo(xLc,y0+ph); ctx.stroke();
  ctx.setLineDash([]);
  label(ctx, "Δ = Lc", xLc+6, y0+14, "left");
  ctx.restore();

  // Tick labels
  const xTicks = [
    {pos:0.0, val:xmin},
    {pos:0.25, val:xmin + 0.25*(xmax-xmin)},
    {pos:0.5, val:0},
    {pos:0.75, val:xmin + 0.75*(xmax-xmin)},
    {pos:1.0, val:xmax},
  ];
  const yTicks = [
    {pos:0.0, val:0},
    {pos:0.25, val:0.25},
    {pos:0.5, val:0.5},
    {pos:0.75, val:0.75},
    {pos:1.0, val:1.0},
  ];
  ticks(ctx, {x0,y0,w:pw,h:ph}, xTicks, yTicks,
    (v)=>fmtSI(v, "m"),
    (v)=>fmtNum(v,2)
  );

  // Axis labels
  label(ctx, "Optical path difference Δ (m)", x0 + pw/2, y0 + ph + 38, "center");
  ctx.save();
  ctx.translate(18, y0 + ph/2);
  ctx.rotate(-Math.PI/2);
  label(ctx, "|g¹(Δ/c)|  (visibility)", 0, 0, "center");
  ctx.restore();

  // Legend
  ctx.save();
  const lx = x0 + 10, ly = y0 + 10;
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  roundRect(ctx, lx, ly, 230, 52, 12);
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.stroke();

  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  const profName = profile==="rect"?"Rectangular":profile==="lor"?"Lorentzian":"Gaussian";
  ctx.fillText(`Profile: ${profName}`, lx+12, ly+20);
  ctx.fillText(`Δν ≈ ${fmtSI(deltaNu,"Hz")}`, lx+12, ly+38);

  // mini line sample
  ctx.strokeStyle = "rgba(124,243,198,0.85)";
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(lx+150, ly+18); ctx.lineTo(lx+216, ly+18); ctx.stroke();
  ctx.restore();
}

/* -----------------------------
   Drawing: Sweep plot (Nfr vs Δλ)
------------------------------ */
function drawSweep(){
  const {ctx, w, h} = setupCanvas(dom.cvSweep);
  clear(ctx,w,h);

  // Panel
  ctx.save();
  roundRect(ctx, 8, 8, w-16, h-16, 14);
  ctx.fillStyle = "rgba(0,0,0,0.18)";
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.restore();

  title(ctx, w, "Estimated fringe count Nfr vs linewidth Δλ (log sweep)");

  const p0 = currentParams();
  const lambda = p0.lambda;
  const profile = state.profile;

  // Plot region
  const x0 = 60, y0 = 34, pw = w - 80, ph = h - 74;
  drawGrid(ctx, x0, y0, pw, ph, 6, 5);
  axes(ctx, {x0,y0,w:pw,h:ph});

  // Sweep Δλ from 1e-3 nm to 1e2 nm
  const logMin = -3, logMax = 2;
  // Compute Nfr range to scale y
  const samples = 240;
  let Nmax = 1, Nmin = 1e99;
  const arr = [];
  for(let i=0;i<=samples;i++){
    const lg = logMin + (logMax-logMin)*i/samples;
    const dL = pow10(lg)*1e-9; // m
    const dNu = (C/(lambda*lambda))*dL;
    const k = kProfile(profile);
    const tauC = (dNu>0)? (k/dNu) : Infinity;
    const Lc = C*tauC;
    const Nfr = Lc/lambda;
    arr.push({lg, Nfr});
    if(isFinite(Nfr)){
      Nmax = Math.max(Nmax, Nfr);
      Nmin = Math.min(Nmin, Nfr);
    }
  }
  // Use log y scale for Nfr because it spans decades
  Nmin = Math.max(Nmin, 1e-2);
  const yLogMin = Math.log10(Nmin);
  const yLogMax = Math.log10(Nmax);

  function Xlg(lg){ return x0 + (lg - logMin) * (pw/(logMax-logMin)); }
  function YN(N){ 
    const ylg = Math.log10(Math.max(N, 1e-6));
    return y0 + (1 - (ylg - yLogMin)/(yLogMax-yLogMin)) * ph;
  }

  // Draw curve
  ctx.save();
  ctx.lineWidth = 2.2;
  ctx.strokeStyle = "rgba(137,167,255,0.85)";
  ctx.beginPath();
  arr.forEach((pt, idx)=>{
    const x = Xlg(pt.lg);
    const y = YN(pt.Nfr);
    if(idx===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  });
  ctx.stroke();
  ctx.restore();

  // Current point marker
  const cur = p0;
  const curLg = state.logDL;
  ctx.save();
  const cx = Xlg(curLg);
  const cy = YN(cur.Nfr);
  ctx.fillStyle = "rgba(255,210,125,0.95)";
  ctx.beginPath(); ctx.arc(cx, cy, 4.5, 0, Math.PI*2); ctx.fill();
  label(ctx, "current", cx+8, cy-8, "left");
  ctx.restore();

  // Ticks
  const xTicks = [
    {pos:0, val:logMin},
    {pos:0.2, val:logMin + 0.2*(logMax-logMin)},
    {pos:0.4, val:logMin + 0.4*(logMax-logMin)},
    {pos:0.6, val:logMin + 0.6*(logMax-logMin)},
    {pos:0.8, val:logMin + 0.8*(logMax-logMin)},
    {pos:1.0, val:logMax},
  ];
  const yTicks = [];
  for(let j=0;j<=5;j++){
    const ylg = yLogMin + (yLogMax-yLogMin)*j/5;
    yTicks.push({pos:j/5, val:Math.pow(10, ylg)});
  }

  ticks(ctx, {x0,y0,w:pw,h:ph},
    xTicks,
    yTicks,
    (v)=>`10^${v.toFixed(1)}`,
    (v)=>fmtSI(v,"")
  );

  // Axis labels
  label(ctx, "log10(Δλ / nm)", x0 + pw/2, y0 + ph + 38, "center");
  ctx.save();
  ctx.translate(18, y0 + ph/2);
  ctx.rotate(-Math.PI/2);
  label(ctx, "Nfr (log scale)", 0, 0, "center");
  ctx.restore();

  // Legend box
  ctx.save();
  const lx = x0 + 10, ly = y0 + 10;
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  roundRect(ctx, lx, ly, 250, 52, 12);
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.stroke();

  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  const profName = profile==="rect"?"Rectangular":profile==="lor"?"Lorentzian":"Gaussian";
  ctx.fillText(`λ = ${Math.round(state.lambda_nm)} nm, profile: ${profName}`, lx+12, ly+20);
  ctx.fillText(`Scaling ~ constant × (λ/Δλ)`, lx+12, ly+38);
  ctx.restore();
}

/* -----------------------------
   Update readouts + redraw all
------------------------------ */
function updateReadouts(){
  const p = currentParams();
  const profName = state.profile==="rect"?"Rectangular":state.profile==="lor"?"Lorentzian":"Gaussian";
  dom.rdProfile.textContent = profName;
  dom.rdLambda.textContent = `${state.lambda_nm} nm`;
  const dL_nm = pow10(state.logDL);
  dom.rdDL.textContent = `${fmtNum(dL_nm,3)} nm`;

  // Use floor-ish display for Nfr, but keep meaningful magnitude
  const N = p.Nfr;
  let Ndisp;
  if(N < 1) Ndisp = fmtNum(N,2);
  else if(N < 1000) Ndisp = Math.round(N).toString();
  else Ndisp = fmtSI(N,"").replace(" ","");
  dom.rdNfr.textContent = `Nfr ≈ ${Ndisp}`;

  const s1 = `Lc ≈ ${fmtSI(p.Lc,"m")}, τc ≈ ${fmtSI(p.tauC,"s")}, Δν ≈ ${fmtSI(p.deltaNu,"Hz")}`;
  dom.rdLc.textContent = s1;
}

function redrawAll(){
  updateReadouts();
  drawDiagram();
  drawMain();
  drawSweep();
}

/* -----------------------------
   Clipboard helpers
------------------------------ */
async function copyText(txt){
  try{
    await navigator.clipboard.writeText(txt);
    return true;
  }catch(e){
    // fallback
    const ta = document.createElement("textarea");
    ta.value = txt;
    document.body.appendChild(ta);
    ta.select();
    try{ document.execCommand("copy"); }catch(_){}
    document.body.removeChild(ta);
    return true;
  }
}

document.querySelectorAll("[data-copy]").forEach(btn=>{
  btn.addEventListener("click", async ()=>{
    const sel = btn.getAttribute("data-copy");
    const el = document.querySelector(sel);
    const txt = el ? el.textContent.trim() : "";
    await copyText(txt);
    const old = btn.textContent;
    btn.textContent = "Copied!";
    setTimeout(()=>btn.textContent = old, 900);
  });
});

dom.btnCopyAnswer.addEventListener("click", async ()=>{
  const txt = document.getElementById("eqFinal").textContent.trim();
  await copyText(txt);
  const old = dom.btnCopyAnswer.textContent;
  dom.btnCopyAnswer.textContent = "Copied!";
  setTimeout(()=>dom.btnCopyAnswer.textContent = old, 900);
});

dom.btnTop.addEventListener("click", ()=>{
  window.scrollTo({top:0, behavior:"smooth"});
});

/* Copy curve/sweep data (as CSV-like text) */
dom.btnPNG1.addEventListener("click", async ()=>{
  const p = currentParams();
  const profile = state.profile;
  const deltaNu = p.deltaNu;
  const Lc = p.Lc;
  let xmax = clamp(2*Lc, 1e-6, 0.5);
  const xmin = -xmax;
  const N = 220;
  let out = "Delta_m,Visibility\n";
  for(let i=0;i<=N;i++){
    const D = xmin + (xmax-xmin)*i/N;
    const V = g1abs(profile, deltaNu, D/C);
    out += `${D},${V}\n`;
  }
  await copyText(out);
  const old = dom.btnPNG1.textContent;
  dom.btnPNG1.textContent = "Copied!";
  setTimeout(()=>dom.btnPNG1.textContent = old, 900);
});
dom.btnPNG2.addEventListener("click", async ()=>{
  const p0 = currentParams();
  const lambda = p0.lambda;
  const profile = state.profile;
  const logMin=-3, logMax=2, N=220;
  let out="log10(DeltaLambda_nm),Nfr\n";
  for(let i=0;i<=N;i++){
    const lg = logMin + (logMax-logMin)*i/N;
    const dL = pow10(lg)*1e-9;
    const dNu = (C/(lambda*lambda))*dL;
    const k = kProfile(profile);
    const tauC = (dNu>0)? (k/dNu) : Infinity;
    const Lc = C*tauC;
    const Nfr = Lc/lambda;
    out += `${lg},${Nfr}\n`;
  }
  await copyText(out);
  const old = dom.btnPNG2.textContent;
  dom.btnPNG2.textContent = "Copied!";
  setTimeout(()=>dom.btnPNG2.textContent = old, 900);
});

/* -----------------------------
   Input handlers
------------------------------ */
dom.selProfile.addEventListener("change", ()=>{
  state.profile = dom.selProfile.value;
  redrawAll();
});
dom.rngLambda.addEventListener("input", ()=>{
  state.lambda_nm = Number(dom.rngLambda.value);
  redrawAll();
});
dom.rngLogDL.addEventListener("input", ()=>{
  state.logDL = Number(dom.rngLogDL.value);
  redrawAll();
});
dom.btnRedraw.addEventListener("click", redrawAll);

window.addEventListener("resize", ()=>{
  // Debounced redraw for responsiveness
  clearTimeout(window.__rzT);
  window.__rzT = setTimeout(redrawAll, 120);
});

/* -----------------------------
   Initial render
------------------------------ */
redrawAll();

/* -----------------------------
   Smooth TOC scrolling
------------------------------ */
document.querySelectorAll('.tocCard nav a').forEach(a=>{
  a.addEventListener('click', (e)=>{
    const href = a.getAttribute('href');
    if(href && href.startsWith('#')){
      e.preventDefault();
      const el = document.querySelector(href);
      if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
    }
  });
});
</script>
</body>
</html>
