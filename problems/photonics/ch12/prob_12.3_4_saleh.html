<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Coherence Through a Fourier-Transform Optical System (Slit → Lens → Back Focal Plane)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --ink:#e8eeff;
      --muted:#a9b4da;
      --line:rgba(255,255,255,.10);
      --accent:#7aa7ff;
      --accent2:#7dffcf;
      --warn:#ffcc66;
      --ok:#88ff99;
      --bad:#ff7a8a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    html{scroll-behavior:smooth;}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1200px 600px at 70% 0%, rgba(122,167,255,.18), transparent 65%),
        radial-gradient(900px 500px at 20% 20%, rgba(125,255,207,.10), transparent 60%),
        linear-gradient(180deg, #070a14, var(--bg));
      line-height:1.55;
    }
    header{
      padding: 26px 18px 10px;
      border-bottom: 1px solid var(--line);
      position:relative;
      overflow:hidden;
    }
    header .wrap{
      max-width: 1100px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:18px;
      align-items:center;
    }
    h1{
      margin:0 0 8px;
      font-size: clamp(1.35rem, 2.3vw, 2.1rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size: 0.98rem;
    }
    .badgeRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
      align-items:center;
    }
    .badge{
      padding:8px 10px;
      border:1px solid var(--line);
      border-radius: 999px;
      background: rgba(255,255,255,.04);
      font-size:.86rem;
      color:var(--muted);
      backdrop-filter: blur(8px);
    }

    main{
      max-width: 1100px;
      margin: 0 auto;
      padding: 18px;
      display:grid;
      grid-template-columns: 300px 1fr;
      gap: 18px;
      align-items:start;
    }
    nav#toc{
      position: sticky;
      top: 12px;
      align-self:start;
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(255,255,255,.03);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    nav#toc header{
      padding: 14px 14px 10px;
      border-bottom: 1px solid var(--line);
      background: rgba(122,167,255,.06);
    }
    nav#toc header h2{
      margin:0;
      font-size: 1.0rem;
      letter-spacing:.2px;
    }
    nav#toc ul{
      list-style:none;
      margin:0;
      padding: 10px 12px 14px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    nav#toc a{
      color: var(--ink);
      text-decoration:none;
      font-size:.93rem;
      padding:8px 10px;
      border-radius: 12px;
      border: 1px solid transparent;
      display:block;
    }
    nav#toc a:hover{
      border-color: rgba(122,167,255,.35);
      background: rgba(122,167,255,.08);
    }

    article{
      display:flex;
      flex-direction:column;
      gap: 14px;
      min-width: 0;
    }
    section{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(255,255,255,.03);
      box-shadow: var(--shadow);
      overflow:hidden;
      transform: translateZ(0);
      animation: pop .45s ease both;
    }
    @keyframes pop{from{opacity:0; transform: translateY(6px);} to{opacity:1; transform: translateY(0);} }

    section > header{
      padding: 14px 14px 10px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(90deg, rgba(122,167,255,.10), transparent 70%);
    }
    section > header h2{
      margin:0;
      font-size: 1.08rem;
      letter-spacing:.2px;
    }
    .content{
      padding: 14px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
    }
    .callout{
      border:1px solid var(--line);
      border-left: 4px solid var(--accent);
      border-radius: 14px;
      background: rgba(0,0,0,.18);
      padding: 12px;
    }
    .callout h3{
      margin:0 0 6px;
      font-size:.98rem;
      color: var(--ink);
    }
    .callout p, .callout ul{margin:6px 0 0;}
    .callout ul{padding-left: 18px;}
    .callout.warn{border-left-color: var(--warn);}
    .callout.ok{border-left-color: var(--ok);}
    .callout.bad{border-left-color: var(--bad);}

    .eqbox{
      border:1px dashed rgba(122,167,255,.45);
      border-radius: 14px;
      padding: 10px 10px 8px;
      background: rgba(122,167,255,.07);
      margin: 10px 0;
      position:relative;
    }
    .eq{
      font-family: var(--mono);
      font-size: .95rem;
      white-space: pre-wrap;
      word-break: break-word;
      margin:0;
      color:#eef3ff;
    }
    .copyBtn{
      position:absolute;
      top:8px;
      right:8px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.25);
      color: var(--ink);
      border-radius: 12px;
      padding: 7px 9px;
      font-size: .85rem;
      cursor:pointer;
      transition: transform .08s ease, background .2s ease;
    }
    .copyBtn:hover{background: rgba(122,167,255,.10);}
    .copyBtn:active{transform: scale(.98);}
    .pill{
      display:inline-block;
      padding:2px 8px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      color: var(--muted);
      font-size: .82rem;
      vertical-align: middle;
    }

    .vizGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items: start;
    }
    figure{
      margin:0;
      border:1px solid var(--line);
      border-radius: 16px;
      background: rgba(0,0,0,.18);
      overflow:hidden;
    }
    figure figcaption{
      padding: 10px 12px;
      border-top: 1px solid var(--line);
      color: var(--muted);
      font-size: .9rem;
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin: 10px 0 0;
    }
    .control{
      border:1px solid var(--line);
      border-radius: 14px;
      padding: 10px;
      background: rgba(255,255,255,.03);
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      color: var(--muted);
      font-size: .88rem;
      margin-bottom: 6px;
    }
    .control input[type="range"]{width:100%;}
    .control .val{
      font-family: var(--mono);
      color: var(--ink);
      font-size: .9rem;
    }

    .note{
      color: var(--muted);
      font-size: .92rem;
    }
    .klist{
      margin: 8px 0 0;
      padding-left: 18px;
    }
    .klist li{margin: 4px 0;}
    .hr{
      height:1px;
      background: var(--line);
      margin: 10px 0;
    }
    footer{
      max-width:1100px;
      margin: 0 auto;
      padding: 18px;
      color: var(--muted);
      font-size: .9rem;
      border-top: 1px solid var(--line);
    }

    @media (max-width: 980px){
      header .wrap{grid-template-columns:1fr;}
      .badgeRow{justify-content:flex-start;}
      main{grid-template-columns: 1fr;}
      nav#toc{position:relative; top:auto;}
      .vizGrid{grid-template-columns: 1fr;}
      canvas{height: 300px;}
      .controls{grid-template-columns: 1fr;}
    }
    @media print{
      body{background:white; color:black;}
      section, nav#toc, figure{box-shadow:none; background:white;}
      .copyBtn{display:none;}
      a{color:black;}
    }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div>
      <h1>Coherence of Light Transmitted Through a Fourier-Transform Optical System</h1>
      <p class="subtitle">
        Spatially incoherent, quasi-monochromatic source → thin slit (width <span class="pill">2a</span>) in the front focal plane → lens → back focal plane.
        We derive the <b>normalized mutual intensity</b> (degree of coherence) in the back focal plane.
      </p>
    </div>
    <div class="badgeRow">
      <div class="badge">Topic: Statistical Optics</div>
      <div class="badge">Tool: Fourier optics (front ↔ back focal planes)</div>
      <div class="badge">Result: sinc-shaped coherence vs separation</div>
    </div>
  </div>
</header>

<main>
  <nav id="toc" aria-label="Table of Contents">
    <header><h2>Table of Contents</h2></header>
    <ul>
      <li><a href="#quick">Quick Summary</a></li>
      <li><a href="#part0">PART 0 — Concept Primer</a></li>
      <li><a href="#part1">PART 1 — Problem Analysis</a></li>
      <li><a href="#part2">PART 2 — Strategy & Tips</a></li>
      <li><a href="#part3">PART 3 — Full Solution</a></li>
      <li><a href="#part4">PART 4 — Deeper Understanding</a></li>
      <li><a href="#part5">PART 5 — Visualization Guide</a></li>
      <li><a href="#viz">Interactive Visualizations</a></li>
    </ul>
  </nav>

  <article>
    <section id="quick">
      <header><h2>Quick Summary</h2></header>
      <div class="content">
        <ul class="klist">
          <li>We have <b>quasi-monochromatic</b> light from a <b>spatially incoherent</b> source, clipped by a <b>thin slit</b> of width <b>2a</b>, then propagated from a lens’s <b>front focal plane</b> to its <b>back focal plane</b> (a Fourier-transform plane).</li>
          <li>The key physics idea: for an <b>incoherent field</b> at the slit, the <b>mutual intensity</b> in the Fourier plane depends only on the <b>separation</b> of the two observation points and equals the Fourier transform of the slit’s intensity profile.</li>
          <li>Governing object: the <b>mutual intensity</b> (cross-spectral density) <span class="pill">J</span>, and its normalization (degree of coherence) <span class="pill">μ</span>.</li>
          <li>Key propagation rule (front focal plane → back focal plane): the field is Fourier transformed; therefore <b>J transforms via a double Fourier kernel</b>.</li>
          <li>Because the source is spatially incoherent at the slit: <span class="pill">J_s(x1,x2) ∝ I_s(x1) δ(x1−x2)</span>.</li>
          <li>Final result type: <b>symbolic</b>. The <b>normalized mutual intensity</b> in the back focal plane is a <b>sinc</b> of point separation:
            <span class="pill">μ(ΔX) = sinc( (2πa/λf) ΔX )</span>.</li>
        </ul>
      </div>
    </section>

    <section id="part0">
      <header><h2>PART 0 — Concept Primer (Theory Before Solving)</h2></header>
      <div class="content">
        <div class="grid2">
          <div class="callout">
            <h3>Core Definitions</h3>
            <ul class="klist">
              <li><b>Optical field</b> (quasi-monochromatic): complex envelope <span class="pill">U(x)</span> such that physical field is Re{<span class="pill">U(x) e^{−iωt}</span>}.</li>
              <li><b>Intensity</b>: <span class="pill">I(x) = ⟨|U(x)|²⟩</span> (units: W/m² up to system scaling).</li>
              <li><b>Mutual intensity</b> (cross-spectral density): <span class="pill">J(x1,x2) = ⟨U(x1) U*(x2)⟩</span>.</li>
              <li><b>Normalized mutual intensity</b> (degree of coherence): <span class="pill">μ(x1,x2)=J(x1,x2)/√(I(x1)I(x2))</span>. It is dimensionless and satisfies <span class="pill">|μ|≤1</span>.</li>
            </ul>
          </div>

          <div class="callout ok">
            <h3>Physical Meaning</h3>
            <ul class="klist">
              <li><span class="pill">J(x1,x2)</span> tells how well the field at two points “knows about” each other statistically (fringe visibility in interference experiments).</li>
              <li><span class="pill">μ</span> is the coherence “contrast”: <span class="pill">|μ|=1</span> fully coherent, <span class="pill">|μ|=0</span> completely uncorrelated.</li>
              <li>In Fourier optics, a lens maps position at the back focal plane to <b>spatial frequency / angle</b>, so coherence in that plane reveals how the slit’s intensity distribution sets angular correlations.</li>
            </ul>
          </div>
        </div>

        <div class="hr"></div>

        <div class="grid2">
          <div class="callout">
            <h3>Key Laws / Principles (and Validity)</h3>
            <ul class="klist">
              <li><b>Paraxial scalar diffraction</b>: field propagation modeled with Fresnel integrals (valid for small angles, slowly varying envelopes).</li>
              <li><b>Thin lens Fourier transform</b>: if an input field is in the <b>front focal plane</b>, then (up to a phase and scaling) the field in the <b>back focal plane</b> is its Fourier transform.</li>
              <li><b>Spatial incoherence model</b>: for an ideal spatially incoherent source, <span class="pill">J_s(x1,x2) ∝ I_s(x1) δ(x1−x2)</span>. This is an approximation (finite coherence length in reality).</li>
            </ul>
          </div>

          <div class="callout warn">
            <h3>Common Models / Approximations</h3>
            <ul class="klist">
              <li><b>Quasi-monochromatic</b>: narrow bandwidth so we treat a single wavelength <span class="pill">λ</span> (temporal coherence not the limiting factor here).</li>
              <li><b>Uniform intensity across the slit</b>: <span class="pill">I_s(x)=I0</span> for <span class="pill">|x|&lt;a</span>, zero outside.</li>
              <li><b>Ideal lens & infinite clear aperture</b>: no vignetting; the Fourier mapping holds cleanly.</li>
            </ul>
          </div>
        </div>

        <div class="hr"></div>

        <div class="grid2">
          <div class="callout">
            <h3>Mini Intuition Examples</h3>
            <ul class="klist">
              <li><b>Narrow slit</b> (small <span class="pill">a</span>): many angles are transmitted → Fourier plane correlations extend over larger separations → <b>broader coherence</b> in the back focal plane.</li>
              <li><b>Wide slit</b> (large <span class="pill">a</span>): the intensity distribution is broader → its Fourier transform is narrower → <b>coherence decays faster</b> with separation in the back focal plane.</li>
            </ul>
          </div>

          <div class="callout bad">
            <h3>What to Watch For (Pitfalls)</h3>
            <ul class="klist">
              <li>Mixing up <b>field</b> Fourier transform with <b>intensity</b> Fourier transform: coherence depends on <span class="pill">J</span>, not directly on intensity unless the field is incoherent (delta-correlated) at the input.</li>
              <li>Forgetting the <b>scaling</b> from position in the back focal plane to spatial frequency: <span class="pill">ν = X/(λf)</span>.</li>
              <li>Using the wrong sinc definition. Here we use the physics sinc: <span class="pill">sinc(z)=sin(z)/z</span>.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section id="part1">
      <header><h2>PART 1 — Problem Analysis (No Solving Yet)</h2></header>
      <div class="content">
        <p>
          <b>Restatement:</b> A spatially incoherent, quasi-monochromatic source of uniform intensity illuminates a thin slit of width <b>2a</b>.
          The light then propagates through a lens from its <b>front focal plane</b> to its <b>back focal plane</b> (Fourier-transform system).
          Find an expression for the <b>normalized mutual intensity</b> (degree of coherence) in the back focal plane.
        </p>

        <div class="grid2">
          <div class="callout">
            <h3>Given</h3>
            <ul class="klist">
              <li>Slit width: <span class="pill">2a</span> (meters)</li>
              <li>Lens focal length: <span class="pill">f</span> (meters)</li>
              <li>Wavelength: <span class="pill">λ</span> (meters), quasi-monochromatic</li>
              <li>Input intensity across slit: <span class="pill">I0</span> constant for <span class="pill">|x|&lt;a</span></li>
              <li>Spatial incoherence at the slit plane (idealized)</li>
            </ul>
          </div>

          <div class="callout ok">
            <h3>Unknowns / Target</h3>
            <ul class="klist">
              <li>Mutual intensity in back focal plane: <span class="pill">J_b(X1,X2)</span></li>
              <li>Normalized mutual intensity (degree of coherence): <span class="pill">μ_b(X1,X2)=J_b/√(I_b(X1)I_b(X2))</span></li>
              <li>Preferably expressed as a function of separation <span class="pill">ΔX=X1−X2</span></li>
            </ul>
          </div>
        </div>

        <div class="hr"></div>

        <div class="callout">
          <h3>Relevant Principles (and why they apply)</h3>
          <ul class="klist">
            <li><b>Fourier-transform property of a lens:</b> With input in the front focal plane and observation in the back focal plane, the lens produces (scaled) Fourier transform of the field. This directly links spatial structure at the slit to angular/spatial-frequency structure in the back focal plane.</li>
            <li><b>Statistical propagation of coherence:</b> Mutual intensity propagates linearly via the same kernels that propagate fields (but in a “two-point” form).</li>
            <li><b>Incoherent input model:</b> Because the source is spatially incoherent, correlations at distinct points are negligible: modeled by a delta function in separation.</li>
          </ul>
        </div>

        <div class="callout warn">
          <h3>Assumptions (Explicit)</h3>
          <ul class="klist">
            <li>Scalar, paraxial optics; thin lens; negligible aberrations.</li>
            <li>Slit is “thin” (aperture transmission only; no thickness phase effects).</li>
            <li>Perfect spatial incoherence at the slit plane: <span class="pill">J_s(x1,x2)=I_s(x1)δ(x1−x2)</span>.</li>
            <li>Lens has sufficiently large clear aperture so it does not further truncate the beam.</li>
          </ul>
        </div>

        <div class="callout">
          <h3>Possible Approaches (Compare & Choose)</h3>
          <ol class="klist">
            <li><b>Two-point Fourier propagation (best here):</b> Write the lens Fourier mapping for the field, then transform the mutual intensity with a double integral. <i>Pros:</i> direct, clean, minimal steps. <i>Cons:</i> needs comfort with mutual intensity formalism.</li>
            <li><b>Van Cittert–Zernike viewpoint:</b> Treat the slit intensity as an “incoherent source” for the back focal plane angular field; the degree of coherence is the normalized FT of the source intensity. <i>Pros:</i> strong intuition. <i>Cons:</i> must map coordinates carefully to the lens Fourier plane.</li>
            <li><b>Mode/angle decomposition:</b> Decompose into plane waves and compute correlations of angular components. <i>Pros:</i> physical. <i>Cons:</i> longer than necessary.</li>
          </ol>
          <p class="note"><b>Choice:</b> We use the two-point Fourier propagation because the system is explicitly a Fourier-transform lens setup and the incoherence delta-function collapses the integrals elegantly.</p>
        </div>
      </div>
    </section>

    <section id="part2">
      <header><h2>PART 2 — Strategy & Tips (Roadmap Only)</h2></header>
      <div class="content">
        <ol class="klist">
          <li><b>Goal:</b> Model the slit-plane coherence. <b>Tool:</b> spatial incoherence approximation. <b>Meaning:</b> only same-point correlations survive.</li>
          <li><b>Goal:</b> Write the lens Fourier mapping for the field from front focal plane coordinate <span class="pill">x</span> to back focal coordinate <span class="pill">X</span>. <b>Tool:</b> Fourier optics. <b>Meaning:</b> <span class="pill">X</span> corresponds to spatial frequency.</li>
          <li><b>Goal:</b> Express <span class="pill">J_b(X1,X2)=⟨U_b(X1)U_b*(X2)⟩</span> using the mapping. <b>Tool:</b> linearity of expectation.</li>
          <li><b>Goal:</b> Evaluate the double integral. <b>Tool:</b> delta function <span class="pill">δ(x1−x2)</span> collapses it to one integral over the slit.</li>
          <li><b>Goal:</b> Compute the back focal plane intensity <span class="pill">I_b(X)=J_b(X,X)</span>. <b>Meaning:</b> needed for normalization.</li>
          <li><b>Goal:</b> Form normalized mutual intensity <span class="pill">μ_b=J_b/√(I_bI_b)</span>. <b>Meaning:</b> degree of coherence; should depend only on <span class="pill">ΔX</span>.</li>
          <li><b>Goal:</b> Sanity checks. <b>Tools:</b> units; limits <span class="pill">ΔX→0</span>, <span class="pill">a→0</span>, <span class="pill">a→∞</span>.</li>
        </ol>

        <div class="callout warn">
          <h3>Common Mistakes + Quick Tips</h3>
          <ul class="klist">
            <li><b>Tip:</b> Keep one dimension (slit along y, variation along x). Write everything in <span class="pill">x</span> and <span class="pill">X</span>.</li>
            <li><b>Mistake:</b> Normalizing by the slit-plane intensity instead of back-focal-plane intensity. Always use <span class="pill">I_b(X)=J_b(X,X)</span>.</li>
            <li><b>Tip:</b> Use <span class="pill">k=2π/λ</span> early and define <span class="pill">sinc(z)=sin(z)/z</span> explicitly.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="part3">
      <header><h2>PART 3 — Full Solution (Detailed + Teaching)</h2></header>
      <div class="content">
        <div class="callout">
          <h3>Qualitative Expectation (Before Math)</h3>
          <p>
            The back focal plane is essentially an “angle / spatial-frequency” plane.
            A wider slit passes a broader region of mutually independent points (because the illumination is incoherent), so
            the correlations between two back-focal-plane points should be set by the Fourier transform of the slit’s <b>intensity</b>.
            A rectangular intensity profile Fourier-transforms into a <b>sinc</b>, so we expect
            <span class="pill">μ</span> to look like a sinc in the point separation <span class="pill">ΔX</span>.
          </p>
        </div>

        <div class="hr"></div>

        <h3 style="margin:0 0 6px;">Step 1 — Define Coordinates and Symbols</h3>
        <ul class="klist">
          <li><span class="pill">x</span>: transverse coordinate in the <b>front focal plane</b> (slit plane), units: m.</li>
          <li><span class="pill">X</span>: transverse coordinate in the <b>back focal plane</b>, units: m.</li>
          <li><span class="pill">a</span>: slit half-width, so slit spans <span class="pill">x∈[−a,a]</span>.</li>
          <li><span class="pill">λ</span>: wavelength, <span class="pill">k=2π/λ</span>.</li>
          <li><span class="pill">f</span>: lens focal length.</li>
          <li><span class="pill">U_s(x)</span>, <span class="pill">U_b(X)</span>: complex field envelopes at slit plane and back focal plane.</li>
          <li><span class="pill">J_s(x1,x2)=⟨U_s(x1)U_s*(x2)⟩</span>, similarly <span class="pill">J_b(X1,X2)</span>.</li>
        </ul>

        <div class="hr"></div>

        <h3 style="margin:0 0 6px;">Step 2 — Model the Slit-Plane Mutual Intensity (Spatial Incoherence)</h3>
        <p>
          The illumination is spatially incoherent with uniform intensity across the slit. Ideal spatial incoherence means:
          different points fluctuate independently, so the mutual intensity is delta-correlated:
        </p>

        <div class="eqbox">
          <button class="copyBtn" data-copy="J_s(x1,x2) = I_s(x1) δ(x1−x2),   with   I_s(x)=I0 for |x|<a, else 0.">Copy</button>
          <pre class="eq">J_s(x1,x2) = I_s(x1) δ(x1−x2),
with  I_s(x) = I0 · rect(x/(2a))  (i.e., I0 for |x|&lt;a, 0 otherwise).</pre>
        </div>

        <p class="note">
          <b>What we did:</b> encoded “spatially incoherent” as a delta function in separation.
          This is the key simplification that will collapse the two-point propagation into a single integral.
        </p>

        <div class="hr"></div>

        <h3 style="margin:0 0 6px;">Step 3 — Lens Fourier Mapping (Front Focal Plane → Back Focal Plane)</h3>
        <p>
          For a thin lens, if the input field is specified in the front focal plane, the field in the back focal plane is (up to a
          phase factor and scaling) the Fourier transform:
        </p>

        <div class="eqbox">
          <button class="copyBtn" data-copy="U_b(X) = C ∫ U_s(x) exp[−i (k/f) X x] dx   (Fourier-transform relation).">Copy</button>
          <pre class="eq">U_b(X) = C ∫_{−∞}^{∞} U_s(x) · exp[ −i (k/f) X x ] dx</pre>
        </div>

        <p class="note">
          <b>Meaning:</b> back focal plane position <span class="pill">X</span> corresponds to spatial frequency (or angle),
          with scaling factor <span class="pill">(k/f)</span>.
          The constant <span class="pill">C</span> includes factors like <span class="pill">1/(iλf)</span> and global phases; it will cancel in normalization.
        </p>

        <div class="hr"></div>

        <h3 style="margin:0 0 6px;">Step 4 — Propagate the Mutual Intensity</h3>
        <p>
          Start from the definition:
          <span class="pill">J_b(X1,X2)=⟨U_b(X1)U_b*(X2)⟩</span>.
          Substitute the Fourier integrals for each field:
        </p>

        <div class="eqbox">
          <button class="copyBtn" data-copy="J_b(X1,X2)=|C|^2 ∬ J_s(x1,x2) exp[−i(k/f)(X1 x1 − X2 x2)] dx1 dx2.">Copy</button>
          <pre class="eq">J_b(X1,X2) = ⟨U_b(X1) U_b*(X2)⟩
           = |C|^2 ∬ J_s(x1,x2)
                 · exp[ −i (k/f)(X1 x1 − X2 x2) ] dx1 dx2</pre>
        </div>

        <p class="note">
          <b>What we did:</b> used linearity of propagation and ensemble averaging to move from field propagation to coherence propagation.
          This is the standard “two-point” version of Fourier optics.
        </p>

        <div class="hr"></div>

        <h3 style="margin:0 0 6px;">Step 5 — Use the Incoherence Delta Function to Collapse the Integral</h3>
        <p>
          Insert <span class="pill">J_s(x1,x2)=I_s(x1)δ(x1−x2)</span>:
        </p>

        <div class="eqbox">
          <button class="copyBtn" data-copy="J_b(X1,X2)=|C|^2 ∫ I_s(x) exp[−i(k/f)(X1−X2)x] dx.">Copy</button>
          <pre class="eq">J_b(X1,X2) = |C|^2 ∬ I_s(x1) δ(x1−x2)
                 · exp[ −i (k/f)(X1 x1 − X2 x2) ] dx1 dx2

           = |C|^2 ∫ I_s(x) · exp[ −i (k/f)(X1−X2) x ] dx</pre>
        </div>

        <p class="note">
          <b>Explanation:</b> the delta function forces <span class="pill">x2=x1=x</span>. So the back-focal-plane mutual intensity depends only on the
          difference <span class="pill">ΔX=X1−X2</span>, which is typical of a “shift-invariant” coherence function when the input intensity is uniform across the aperture region.
        </p>

        <div class="hr"></div>

        <h3 style="margin:0 0 6px;">Step 6 — Evaluate the Integral for a Uniform Slit Intensity</h3>
        <p>
          With <span class="pill">I_s(x)=I0</span> for <span class="pill">|x|&lt;a</span> and zero otherwise:
        </p>

        <div class="eqbox">
          <button class="copyBtn" data-copy="J_b(X1,X2)=|C|^2 I0 ∫_{−a}^{a} exp[−i(k/f)(X1−X2)x] dx = |C|^2 I0 · 2a · sinc( (k a / f)(X1−X2) ).">Copy</button>
          <pre class="eq">Let ΔX = X1 − X2 and α = (k/f) ΔX.

J_b(X1,X2) = |C|^2 I0 ∫_{−a}^{a} e^{−i α x} dx
           = |C|^2 I0 · [ 2 sin(α a) / α ]
           = |C|^2 I0 · 2a · sinc( α a )

where sinc(z) = sin(z)/z.</pre>
        </div>

        <p class="note">
          <b>What we did:</b> integrated a complex exponential over a symmetric interval. This produces the sinc function.
          It is the hallmark of a rectangular aperture (or rectangular intensity source).
        </p>

        <div class="hr"></div>

        <h3 style="margin:0 0 6px;">Step 7 — Normalize to Get the Degree of Coherence</h3>
        <p>
          The intensity at a point is <span class="pill">I_b(X)=J_b(X,X)</span>, i.e. set <span class="pill">ΔX=0</span>:
        </p>

        <div class="eqbox">
          <button class="copyBtn" data-copy="I_b(X)=J_b(X,X)=|C|^2 I0 ∫_{−a}^{a} dx = |C|^2 I0·2a (constant).">Copy</button>
          <pre class="eq">I_b(X) = J_b(X,X) = |C|^2 I0 ∫_{−a}^{a} dx
     = |C|^2 I0 · 2a   (independent of X in this ideal model).</pre>
        </div>

        <p>
          Therefore,
          <span class="pill">√(I_b(X1)I_b(X2)) = |C|^2 I0·2a</span>.
          Divide <span class="pill">J_b</span> by this normalization:
        </p>

        <div class="eqbox">
          <button class="copyBtn" data-copy="μ_b(X1,X2)=J_b(X1,X2)/√(I_b(X1)I_b(X2)) = sinc( (k a / f)(X1−X2) ) = sinc( (2π a /(λ f))(X1−X2) ).">Copy</button>
          <pre class="eq">μ_b(X1,X2) = J_b(X1,X2) / √( I_b(X1) I_b(X2) )
          = sinc( (k a / f)(X1−X2) )
          = sinc( (2π a /(λ f)) (X1−X2) ).</pre>
        </div>

        <div class="callout ok">
          <h3>Final Answer (Boxed)</h3>
          <div class="eqbox" style="margin:10px 0 0;">
            <button class="copyBtn" data-copy="Final: μ_b(X1,X2) = sinc( (2π a /(λ f)) (X1−X2) ),  sinc(z)=sin(z)/z.  First zero at |X1−X2|=λ f/(2a).">Copy</button>
            <pre class="eq">μ_b(X1,X2) = sinc( (2π a /(λ f)) (X1−X2) ),   sinc(z)=sin(z)/z.

Equivalently, in spatial-frequency coordinates ν = X/(λ f):
μ_b = sinc( 2π a (ν1−ν2) ).</pre>
          </div>
        </div>

        <div class="hr"></div>

        <h3 style="margin:0 0 6px;">Sanity Checks</h3>
        <div class="grid2">
          <div class="callout">
            <h3>Units / Dimensions</h3>
            <p class="note">
              Argument: <span class="pill">(2π a /(λ f)) (ΔX)</span> is dimensionless because
              <span class="pill">a·ΔX</span> has m² and <span class="pill">λ f</span> has m².
              So <span class="pill">μ</span> is dimensionless as required.
            </p>
          </div>
          <div class="callout">
            <h3>Limiting Cases</h3>
            <ul class="klist">
              <li><span class="pill">ΔX→0</span>: <span class="pill">μ→1</span> (a point is perfectly coherent with itself).</li>
              <li><span class="pill">a→0</span>: slit becomes tiny; coherence becomes broad: <span class="pill">μ≈1</span> over large separations.</li>
              <li><span class="pill">a→∞</span>: very wide uniform region; coherence becomes extremely narrow: <span class="pill">μ</span> approaches a delta-like spike in <span class="pill">ΔX</span>.</li>
            </ul>
          </div>
        </div>

        <p class="note">
          <b>Connection to the geometry:</b> The sinc dependence arises because the back focal plane “adds up” contributions from each slit point with a phase ramp proportional to <span class="pill">X</span>.
          For two points <span class="pill">X1</span> and <span class="pill">X2</span>, only the phase difference ramp proportional to <span class="pill">ΔX</span> matters, producing the Fourier transform of the slit intensity.
        </p>
      </div>
    </section>

    <section id="part4">
      <header><h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2></header>
      <div class="content">
        <div class="grid2">
          <div class="callout">
            <h3>Interpreting the Formula</h3>
            <ul class="klist">
              <li><span class="pill">a</span> controls the <b>coherence width</b>: larger <span class="pill">a</span> → faster decay of <span class="pill">μ</span> vs separation.</li>
              <li><span class="pill">λ</span> and <span class="pill">f</span> scale the mapping: larger <span class="pill">λ f</span> → broader <span class="pill">μ</span>.</li>
              <li><span class="pill">ΔX=X1−X2</span> is the only variable: the coherence is <b>shift-invariant</b> in this idealized setup.</li>
            </ul>
          </div>

          <div class="callout ok">
            <h3>Coherence “Length” (A Useful Marker)</h3>
            <p class="note">
              The first zero of <span class="pill">sinc</span> occurs when its argument equals <span class="pill">π</span>.
              Therefore the separation to the first zero is:
            </p>
            <div class="eqbox">
              <button class="copyBtn" data-copy="First-zero separation: ΔX0 = λ f /(2a).">Copy</button>
              <pre class="eq">ΔX0 = λ f /(2a)   (first zero of μ vs ΔX).</pre>
            </div>
            <p class="note">
              In the plots below, this quantity sets the natural horizontal scale.
            </p>
          </div>
        </div>

        <div class="hr"></div>

        <div class="callout">
          <h3>How Parameter Changes Affect the Outcome (Connect to Plots)</h3>
          <ul class="klist">
            <li>Increase <span class="pill">a</span> (wider slit): <span class="pill">ΔX0</span> shrinks → main plot’s sinc narrows; parameter-sweep curve (coherence width vs <span class="pill">a</span>) drops as <span class="pill">1/a</span>.</li>
            <li>Increase <span class="pill">λ</span>: <span class="pill">ΔX0</span> grows → coherence broadens.</li>
            <li>Increase <span class="pill">f</span>: also broadens coherence linearly (larger Fourier-plane scaling length).</li>
          </ul>
        </div>

        <div class="callout warn">
          <h3>Alternative Derivation Idea (Brief)</h3>
          <p class="note">
            You can view the slit as an incoherent “source” for the angular spectrum at the lens.
            The van Cittert–Zernike theorem states that (under appropriate far-field / Fourier-plane conditions)
            the complex degree of coherence equals the <b>normalized Fourier transform of the source intensity distribution</b>.
            Since the source intensity is rectangular, the result must be a sinc—exactly what we obtained via the two-point Fourier propagation.
          </p>
        </div>

        <div class="callout">
          <h3>Concept Checks (Quick Q&A)</h3>
          <ul class="klist">
            <li><b>Q:</b> Why does <span class="pill">μ</span> depend only on <span class="pill">ΔX</span>? <b>A:</b> The slit intensity is uniform within its support and the system is shift-invariant, so correlations are stationary in the Fourier plane.</li>
            <li><b>Q:</b> Why is it a sinc and not an Airy pattern? <b>A:</b> Airy comes from a circular aperture; a 1D rectangular support Fourier-transforms to sinc.</li>
            <li><b>Q:</b> What would break the “constant intensity” in the back focal plane? <b>A:</b> Finite lens aperture (vignetting), nonuniform slit illumination, aberrations, or non-ideal incoherence.</li>
            <li><b>Q:</b> If the input were fully coherent across the slit, would <span class="pill">μ</span> still be sinc? <b>A:</b> No—then <span class="pill">J_s</span> would not be delta-correlated; you’d propagate the coherent field and correlations could remain high across the Fourier plane.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="part5">
      <header><h2>PART 5 — Visualization Guide (How to Read the Plots)</h2></header>
      <div class="content">
        <ul class="klist">
          <li><b>Diagram canvas:</b> shows the slit in the front focal plane, the lens, and the back focal plane coordinate <span class="pill">X</span>. It highlights that the lens produces a Fourier transform between these planes.</li>
          <li><b>Main plot:</b> <span class="pill">μ(ΔX)</span> vs separation <span class="pill">ΔX</span> (units: mm in the plot). This is the normalized mutual intensity; it starts at 1 and oscillates/decays with zeros at <span class="pill">±ΔX0</span>, <span class="pill">±2ΔX0</span>, ...</li>
          <li><b>Secondary plot (parameter sweep):</b> coherence-width marker <span class="pill">ΔX0=λf/(2a)</span> vs slit half-width <span class="pill">a</span>. The curve is <span class="pill">∝1/a</span>, and a marker shows the current slider setting.</li>
          <li><b>Interactive controls:</b> adjusting <span class="pill">a</span>, <span class="pill">λ</span>, or <span class="pill">f</span> updates <b>all</b> canvases live, changing the sinc width and the coherence-width sweep accordingly.</li>
        </ul>
        <p class="note">
          The plotted numbers are <b>example values</b> for visualization only; the derived formula in PART 3 is fully symbolic and general.
        </p>
      </div>
    </section>

    <section id="viz">
      <header><h2>Interactive Visualizations</h2></header>
      <div class="content">
        <div class="callout">
          <h3>Example Values (for plotting only)</h3>
          <p class="note">
            Use the sliders to explore how the slit half-width <span class="pill">a</span>, wavelength <span class="pill">λ</span>, and focal length <span class="pill">f</span>
            control the coherence in the back focal plane. The symbolic result remains:
            <span class="pill">μ(ΔX)=sinc((2πa/(λf))ΔX)</span>.
          </p>
        </div>

        <div class="controls" role="group" aria-label="Interactive parameters">
          <div class="control">
            <label for="aSlider"><span>Slit half-width <b>a</b> (µm)</span><span class="val" id="aVal">50</span></label>
            <input id="aSlider" type="range" min="10" max="200" value="50" step="1"/>
          </div>
          <div class="control">
            <label for="lamSlider"><span>Wavelength <b>λ</b> (nm)</span><span class="val" id="lamVal">633</span></label>
            <input id="lamSlider" type="range" min="400" max="800" value="633" step="1"/>
          </div>
          <div class="control">
            <label for="fSlider"><span>Focal length <b>f</b> (mm)</span><span class="val" id="fVal">100</span></label>
            <input id="fSlider" type="range" min="50" max="200" value="100" step="1"/>
          </div>
        </div>

        <div class="vizGrid" style="margin-top:12px;">
          <figure>
            <canvas id="diagramCanvas" aria-label="Optical setup diagram"></canvas>
            <figcaption><b>Diagram:</b> slit in the front focal plane → lens → back focal (Fourier) plane coordinate <span class="pill">X</span>.</figcaption>
          </figure>
          <figure>
            <canvas id="mainPlot" aria-label="Main plot of degree of coherence versus separation"></canvas>
            <figcaption><b>Main plot:</b> degree of coherence <span class="pill">μ(ΔX)</span> vs separation <span class="pill">ΔX</span> in the back focal plane.</figcaption>
          </figure>
        </div>

        <div class="vizGrid" style="margin-top:12px;">
          <figure>
            <canvas id="secondaryPlot" aria-label="Parameter sweep coherence width versus slit half-width"></canvas>
            <figcaption><b>Secondary plot:</b> first-zero separation <span class="pill">ΔX0=λf/(2a)</span> vs <span class="pill">a</span>, with current setting marked.</figcaption>
          </figure>
          <figure>
            <canvas id="heatPlot" aria-label="Secondary visualization of mutual intensity magnitude in X1-X2 plane"></canvas>
            <figcaption><b>Secondary visualization:</b> heatmap of <span class="pill">|μ(X1,X2)|</span> over an <span class="pill">(X1,X2)</span> window (depends only on <span class="pill">ΔX</span> → diagonal bands).</figcaption>
          </figure>
        </div>

      </div>
    </section>
  </article>
</main>

<footer>
  <div>
    <b>Key result:</b> For a uniform incoherent slit of width <span class="pill">2a</span>, the back focal plane normalized mutual intensity is
    <span class="pill">μ_b(X1,X2)=sinc((2πa/(λf))(X1−X2))</span>.
    The first zero occurs at <span class="pill">|X1−X2|=λf/(2a)</span>.
  </div>
</footer>

<script>
/* =========================
   Utilities: copy buttons
========================= */
(function setupCopyButtons(){
  function toast(msg){
    const t = document.createElement('div');
    t.textContent = msg;
    t.style.position='fixed';
    t.style.left='50%';
    t.style.top='14px';
    t.style.transform='translateX(-50%)';
    t.style.padding='10px 12px';
    t.style.border='1px solid rgba(255,255,255,.18)';
    t.style.borderRadius='12px';
    t.style.background='rgba(0,0,0,.65)';
    t.style.color='white';
    t.style.zIndex='9999';
    t.style.boxShadow='0 10px 30px rgba(0,0,0,.35)';
    t.style.backdropFilter='blur(8px)';
    document.body.appendChild(t);
    setTimeout(()=>{ t.style.opacity='0'; t.style.transition='opacity .25s ease'; }, 900);
    setTimeout(()=>{ t.remove(); }, 1200);
  }
  document.addEventListener('click', async (e)=>{
    const btn = e.target.closest('.copyBtn');
    if(!btn) return;
    const txt = btn.getAttribute('data-copy') || '';
    try{
      await navigator.clipboard.writeText(txt);
      toast('Copied!');
    }catch(err){
      // fallback
      const ta = document.createElement('textarea');
      ta.value = txt;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      ta.remove();
      toast('Copied!');
    }
  });
})();

/* =========================
   Canvas plotting helpers
========================= */
function fitCanvasToCSS(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(10, Math.floor(rect.width * dpr));
  const h = Math.max(10, Math.floor(rect.height * dpr));
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w;
    canvas.height = h;
  }
  return {w, h, dpr};
}

function drawPanel(ctx, w, h, title){
  ctx.clearRect(0,0,w,h);
  // Background
  ctx.fillStyle = 'rgba(0,0,0,0.0)';
  ctx.fillRect(0,0,w,h);

  // Title
  ctx.save();
  ctx.fillStyle = 'rgba(232,238,255,0.95)';
  ctx.font = `${Math.max(14, Math.round(h*0.05))}px ui-sans-serif, system-ui`;
  ctx.textBaseline='top';
  ctx.fillText(title, 16, 12);
  ctx.restore();
}

function niceTicks(min, max, n=6){
  const span = max - min;
  if(span <= 0) return [min];
  const raw = span / (n-1);
  const pow = Math.pow(10, Math.floor(Math.log10(raw)));
  const base = raw / pow;
  const stepBase = base < 1.5 ? 1 : base < 3.5 ? 2 : base < 7.5 ? 5 : 10;
  const step = stepBase * pow;
  const t0 = Math.ceil(min/step)*step;
  const ticks = [];
  for(let t=t0; t<=max+1e-12; t+=step) ticks.push(t);
  return ticks;
}

function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel){
  const {x, y, w, h} = box;
  ctx.save();
  // grid
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;

  const xTicks = niceTicks(xMin, xMax, 6);
  const yTicks = niceTicks(yMin, yMax, 6);

  // vertical grid + ticks
  for(const xt of xTicks){
    const px = x + (xt - xMin) / (xMax - xMin) * w;
    ctx.beginPath();
    ctx.moveTo(px, y);
    ctx.lineTo(px, y+h);
    ctx.stroke();
  }
  // horizontal grid + ticks
  for(const yt of yTicks){
    const py = y + h - (yt - yMin) / (yMax - yMin) * h;
    ctx.beginPath();
    ctx.moveTo(x, py);
    ctx.lineTo(x+w, py);
    ctx.stroke();
  }

  // axes border
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1.2;
  ctx.strokeRect(x, y, w, h);

  // tick labels
  ctx.fillStyle = 'rgba(169,180,218,0.95)';
  ctx.font = `${Math.max(11, Math.round(h*0.045))}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace`;
  ctx.textAlign='center';
  ctx.textBaseline='top';
  for(const xt of xTicks){
    const px = x + (xt - xMin) / (xMax - xMin) * w;
    ctx.fillText(formatTick(xt), px, y+h+6);
  }
  ctx.textAlign='right';
  ctx.textBaseline='middle';
  for(const yt of yTicks){
    const py = y + h - (yt - yMin) / (yMax - yMin) * h;
    ctx.fillText(formatTick(yt), x-8, py);
  }

  // axis labels
  ctx.fillStyle = 'rgba(232,238,255,0.92)';
  ctx.font = `${Math.max(12, Math.round(h*0.05))}px ui-sans-serif, system-ui`;
  ctx.textAlign='center';
  ctx.textBaseline='bottom';
  ctx.fillText(xLabel, x + w/2, y + h + 40);

  ctx.save();
  ctx.translate(x - 50, y + h/2);
  ctx.rotate(-Math.PI/2);
  ctx.textAlign='center';
  ctx.textBaseline='top';
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  ctx.restore();
}

function formatTick(v){
  const av = Math.abs(v);
  if(av >= 1000) return v.toFixed(0);
  if(av >= 100) return v.toFixed(0);
  if(av >= 10) return v.toFixed(1).replace(/\.0$/,'');
  if(av >= 1) return v.toFixed(2).replace(/0$/,'').replace(/\.$/,'');
  return v.toExponential(1);
}

function mapXY(box, xMin, xMax, yMin, yMax, xVal, yVal){
  const px = box.x + (xVal - xMin) / (xMax - xMin) * box.w;
  const py = box.y + box.h - (yVal - yMin) / (yMax - yMin) * box.h;
  return {px, py};
}

function drawLine(ctx, box, xMin, xMax, yMin, yMax, xs, ys, strokeStyle='rgba(122,167,255,0.95)', width=2){
  ctx.save();
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = width;
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const {px, py} = mapXY(box, xMin, xMax, yMin, yMax, xs[i], ys[i]);
    if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.stroke();
  ctx.restore();
}

function drawLegend(ctx, x, y, items){
  ctx.save();
  ctx.font = `12px ui-sans-serif, system-ui`;
  ctx.textBaseline='middle';
  let yy = y;
  for(const it of items){
    ctx.strokeStyle = it.color;
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(x, yy); ctx.lineTo(x+22, yy); ctx.stroke();
    ctx.fillStyle = 'rgba(232,238,255,0.92)';
    ctx.fillText(it.label, x+28, yy);
    yy += 18;
  }
  ctx.restore();
}

/* =========================
   Physics functions
========================= */
function sinc(z){
  if(Math.abs(z) < 1e-8) return 1;
  return Math.sin(z)/z;
}

// μ(ΔX) = sinc( (2π a /(λ f)) ΔX )
function muDeltaX(deltaX, a, lambda, f){
  const arg = (2*Math.PI*a/(lambda*f)) * deltaX;
  return sinc(arg);
}

/* =========================
   State + UI
========================= */
const state = {
  a_um: 50,      // micrometers
  lam_nm: 633,   // nanometers
  f_mm: 100      // millimeters
};

const els = {
  aSlider: document.getElementById('aSlider'),
  lamSlider: document.getElementById('lamSlider'),
  fSlider: document.getElementById('fSlider'),
  aVal: document.getElementById('aVal'),
  lamVal: document.getElementById('lamVal'),
  fVal: document.getElementById('fVal'),
  diagram: document.getElementById('diagramCanvas'),
  main: document.getElementById('mainPlot'),
  secondary: document.getElementById('secondaryPlot'),
  heat: document.getElementById('heatPlot'),
};

function syncUI(){
  els.aVal.textContent = String(state.a_um);
  els.lamVal.textContent = String(state.lam_nm);
  els.fVal.textContent = String(state.f_mm);
}

function getSI(){
  return {
    a: state.a_um * 1e-6,
    lambda: state.lam_nm * 1e-9,
    f: state.f_mm * 1e-3
  };
}

/* =========================
   Draw: diagram
========================= */
function drawDiagram(){
  const {w, h} = fitCanvasToCSS(els.diagram);
  const ctx = els.diagram.getContext('2d');
  drawPanel(ctx, w, h, 'Fourier-Transform System Geometry');

  // Drawing area
  const padL = 16, padR = 16, padT = 48, padB = 20;
  const x0 = padL, y0 = padT, ww = w - padL - padR, hh = h - padT - padB;

  // Optical axis line
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.22)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x0, y0 + hh*0.55);
  ctx.lineTo(x0+ww, y0 + hh*0.55);
  ctx.stroke();

  // Slit plane (front focal plane)
  const slitX = x0 + ww*0.18;
  ctx.strokeStyle = 'rgba(125,255,207,0.85)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(slitX, y0+hh*0.12);
  ctx.lineTo(slitX, y0+hh*0.92);
  ctx.stroke();

  // Slit opening
  const slitHalf = hh*0.16;
  ctx.strokeStyle = 'rgba(125,255,207,0.85)';
  ctx.lineWidth = 6;
  ctx.beginPath();
  ctx.moveTo(slitX, y0+hh*0.55 - slitHalf);
  ctx.lineTo(slitX, y0+hh*0.55 + slitHalf);
  ctx.stroke();

  // Lens
  const lensX = x0 + ww*0.52;
  ctx.strokeStyle = 'rgba(122,167,255,0.90)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(lensX, y0+hh*0.20);
  ctx.quadraticCurveTo(lensX+ww*0.03, y0+hh*0.55, lensX, y0+hh*0.90);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(lensX, y0+hh*0.20);
  ctx.quadraticCurveTo(lensX-ww*0.03, y0+hh*0.55, lensX, y0+hh*0.90);
  ctx.stroke();

  // Back focal plane
  const bfpX = x0 + ww*0.84;
  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(bfpX, y0+hh*0.12);
  ctx.lineTo(bfpX, y0+hh*0.92);
  ctx.stroke();

  // Rays (schematic)
  ctx.strokeStyle = 'rgba(255,204,102,0.65)';
  ctx.lineWidth = 2;
  const yAx = y0 + hh*0.55;
  const yUp = yAx - slitHalf*0.95;
  const yDn = yAx + slitHalf*0.95;
  // top ray
  ctx.beginPath();
  ctx.moveTo(slitX, yUp);
  ctx.lineTo(lensX, yUp*0.65 + yAx*0.35);
  ctx.lineTo(bfpX, yAx - hh*0.18);
  ctx.stroke();
  // bottom ray
  ctx.beginPath();
  ctx.moveTo(slitX, yDn);
  ctx.lineTo(lensX, yDn*0.65 + yAx*0.35);
  ctx.lineTo(bfpX, yAx + hh*0.18);
  ctx.stroke();
  // axis ray
  ctx.strokeStyle = 'rgba(255,204,102,0.45)';
  ctx.beginPath();
  ctx.moveTo(slitX, yAx);
  ctx.lineTo(lensX, yAx);
  ctx.lineTo(bfpX, yAx);
  ctx.stroke();

  // Labels
  ctx.fillStyle = 'rgba(232,238,255,0.92)';
  ctx.font = `13px ui-sans-serif, system-ui`;
  ctx.textBaseline = 'top';
  ctx.fillText('Front focal plane (slit)', slitX-60, y0+6);
  ctx.fillText('Thin lens', lensX-20, y0+6);
  ctx.fillText('Back focal plane (Fourier plane)', bfpX-110, y0+6);

  // Coordinate annotations
  ctx.fillStyle = 'rgba(169,180,218,0.95)';
  ctx.font = `12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace`;
  ctx.fillText('x (slit coordinate)', slitX-62, y0+hh-18);
  ctx.fillText('X (back focal coordinate)', bfpX-80, y0+hh-18);

  // Slit width marker 2a
  ctx.strokeStyle = 'rgba(125,255,207,0.75)';
  ctx.lineWidth = 1.5;
  const y1 = yAx - slitHalf;
  const y2 = yAx + slitHalf;
  ctx.beginPath();
  ctx.moveTo(slitX-18, y1); ctx.lineTo(slitX-18, y2);
  ctx.moveTo(slitX-24, y1); ctx.lineTo(slitX-12, y1);
  ctx.moveTo(slitX-24, y2); ctx.lineTo(slitX-12, y2);
  ctx.stroke();
  ctx.fillStyle = 'rgba(125,255,207,0.95)';
  ctx.fillText('2a', slitX-38, yAx-6);

  // Fourier mapping note
  ctx.fillStyle = 'rgba(169,180,218,0.95)';
  ctx.font = `12px ui-sans-serif, system-ui`;
  ctx.textBaseline='top';
  ctx.fillText('Lens performs a Fourier transform:', x0+ww*0.25, y0+hh*0.08);
  ctx.font = `12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace`;
  ctx.fillStyle = 'rgba(232,238,255,0.92)';
  ctx.fillText('U_b(X) ∝ ∫ U_s(x) e^{−i(k/f)Xx} dx', x0+ww*0.25, y0+hh*0.14);

  ctx.restore();
}

/* =========================
   Draw: main plot μ(ΔX)
========================= */
function drawMainPlot(){
  const {a, lambda, f} = getSI();
  const {w, h} = fitCanvasToCSS(els.main);
  const ctx = els.main.getContext('2d');

  const deltaX0 = (lambda*f)/(2*a); // first zero separation (m)
  // Plot range: +/- 3.2 * deltaX0 (ensure multiple lobes)
  const xMax = 3.2 * deltaX0;
  const xMin = -xMax;

  // y range
  const yMin = -0.30;
  const yMax = 1.05;

  drawPanel(ctx, w, h, 'Degree of Coherence in Back Focal Plane');

  // Plot box
  const box = {x: 70, y: 64, w: w-92, h: h-120};
  drawAxes(ctx, box, xMin*1e3, xMax*1e3, yMin, yMax, 'Separation ΔX (mm)', 'μ(ΔX) (dimensionless)');

  // Data
  const N = 900;
  const xs = new Array(N);
  const ys = new Array(N);
  for(let i=0;i<N;i++){
    const t = i/(N-1);
    const dx = xMin + t*(xMax-xMin);
    xs[i] = dx*1e3; // mm for axis
    ys[i] = muDeltaX(dx, a, lambda, f);
  }

  // Draw line
  drawLine(ctx, box, xMin*1e3, xMax*1e3, yMin, yMax, xs, ys, 'rgba(122,167,255,0.95)', 2.2);

  // Reference lines at 0 and first zeros
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.20)';
  ctx.lineWidth = 1.2;

  // y=0
  const p0 = mapXY(box, xMin*1e3, xMax*1e3, yMin, yMax, 0, 0);
  ctx.beginPath();
  ctx.moveTo(box.x, p0.py);
  ctx.lineTo(box.x+box.w, p0.py);
  ctx.stroke();

  // ±ΔX0
  const xz = deltaX0*1e3;
  for(const s of [-1,1]){
    const px = mapXY(box, xMin*1e3, xMax*1e3, yMin, yMax, s*xz, 0).px;
    ctx.strokeStyle = 'rgba(125,255,207,0.35)';
    ctx.beginPath();
    ctx.moveTo(px, box.y);
    ctx.lineTo(px, box.y+box.h);
    ctx.stroke();
  }

  // Legend
  drawLegend(ctx, box.x+12, box.y+14, [
    {color:'rgba(122,167,255,0.95)', label:'μ(ΔX) = sinc((2πa/(λf))ΔX)'},
    {color:'rgba(125,255,207,0.65)', label:'first zeros at ±ΔX0'}
  ]);

  // Subtitle with current ΔX0
  ctx.fillStyle = 'rgba(169,180,218,0.95)';
  ctx.font = `12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace`;
  ctx.textBaseline='top';
  ctx.fillText(`ΔX0 = λ f /(2a) = ${(deltaX0*1e3).toFixed(3)} mm`, 16, h-30);

  ctx.restore();
}

/* =========================
   Draw: secondary plot ΔX0 vs a (sweep)
========================= */
function drawSecondaryPlot(){
  const {lambda, f} = getSI();
  const {w, h} = fitCanvasToCSS(els.secondary);
  const ctx = els.secondary.getContext('2d');
  drawPanel(ctx, w, h, 'Parameter Sweep: Coherence Width vs Slit Half-Width');

  const box = {x: 74, y: 64, w: w-96, h: h-120};

  // Sweep range in a (µm) matching slider
  const aMin_um = 10, aMax_um = 200;

  // Compute y range: ΔX0 = λ f /(2a)
  const yAtMinA = (lambda*f)/(2*(aMax_um*1e-6)); // smallest ΔX0 at largest a
  const yAtMaxA = (lambda*f)/(2*(aMin_um*1e-6)); // largest ΔX0 at smallest a
  const yMin = 0.9*yAtMinA*1e3; // mm
  const yMax = 1.1*yAtMaxA*1e3; // mm

  drawAxes(ctx, box, aMin_um, aMax_um, yMin, yMax, 'Slit half-width a (µm)', 'First-zero separation ΔX0 (mm)');

  const N = 500;
  const xs = new Array(N);
  const ys = new Array(N);
  for(let i=0;i<N;i++){
    const t = i/(N-1);
    const a_um = aMin_um + t*(aMax_um-aMin_um);
    const a_m = a_um*1e-6;
    const dx0 = (lambda*f)/(2*a_m); // m
    xs[i] = a_um;
    ys[i] = dx0*1e3; // mm
  }

  drawLine(ctx, box, aMin_um, aMax_um, yMin, yMax, xs, ys, 'rgba(125,255,207,0.90)', 2.2);

  // Current marker
  const a_um = state.a_um;
  const dx0 = (lambda*f)/(2*(a_um*1e-6))*1e3; // mm
  const p = mapXY(box, aMin_um, aMax_um, yMin, yMax, a_um, dx0);

  ctx.save();
  ctx.fillStyle = 'rgba(122,167,255,0.95)';
  ctx.beginPath();
  ctx.arc(p.px, p.py, 6, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.55)';
  ctx.lineWidth = 1.2;
  ctx.stroke();

  // Legend
  drawLegend(ctx, box.x+12, box.y+14, [
    {color:'rgba(125,255,207,0.90)', label:'ΔX0 = λ f /(2a)  (∝ 1/a)'},
    {color:'rgba(122,167,255,0.95)', label:'current slider setting'}
  ]);

  // Note
  ctx.fillStyle = 'rgba(169,180,218,0.95)';
  ctx.font = `12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace`;
  ctx.textBaseline='top';
  ctx.fillText(`Current: a=${a_um} µm → ΔX0=${dx0.toFixed(3)} mm`, 16, h-30);

  ctx.restore();
}

/* =========================
   Draw: heatmap |μ(X1,X2)|
========================= */
function drawHeatPlot(){
  const {a, lambda, f} = getSI();
  const {w, h} = fitCanvasToCSS(els.heat);
  const ctx = els.heat.getContext('2d');
  drawPanel(ctx, w, h, 'Heatmap: |μ(X1,X2)| (Diagonal Bands from ΔX Dependence)');

  const box = {x: 74, y: 64, w: w-96, h: h-120};

  // Choose a window based on ΔX0
  const deltaX0 = (lambda*f)/(2*a);
  const Xmax = 2.2*deltaX0; // m for both axes

  drawAxes(ctx, box, -Xmax*1e3, Xmax*1e3, -Xmax*1e3, Xmax*1e3, 'X1 (mm)', 'X2 (mm)');

  // Heatmap grid
  const nx = 80, ny = 80;
  // We will map |μ(ΔX)| to brightness (white=high)
  for(let j=0;j<ny;j++){
    const y2 = -Xmax + (j+0.5)/ny*(2*Xmax); // m
    for(let i=0;i<nx;i++){
      const x1 = -Xmax + (i+0.5)/nx*(2*Xmax); // m
      const mu = muDeltaX(x1 - y2, a, lambda, f);
      const val = Math.min(1, Math.max(0, Math.abs(mu))); // 0..1

      // Color: blend between dark and accent
      // Keep simple: grayscale-ish with a hint of accent via alpha overlay
      const base = 30 + Math.round(200*val); // 30..230
      ctx.fillStyle = `rgba(${base},${base},${base},0.35)`;
      // draw in plot coordinates
      const px = box.x + i/nx*box.w;
      const py = box.y + j/ny*box.h;
      const cw = box.w/nx + 0.5;
      const ch = box.h/ny + 0.5;
      ctx.fillRect(px, py, cw, ch);
    }
  }

  // Diagonal line X1=X2
  ctx.save();
  ctx.strokeStyle = 'rgba(122,167,255,0.55)';
  ctx.lineWidth = 1.4;
  const pA = mapXY(box, -Xmax*1e3, Xmax*1e3, -Xmax*1e3, Xmax*1e3, -Xmax*1e3, -Xmax*1e3);
  const pB = mapXY(box, -Xmax*1e3, Xmax*1e3, -Xmax*1e3, Xmax*1e3,  Xmax*1e3,  Xmax*1e3);
  ctx.beginPath();
  ctx.moveTo(pA.px, pA.py);
  ctx.lineTo(pB.px, pB.py);
  ctx.stroke();

  // Legend-like note
  ctx.fillStyle = 'rgba(169,180,218,0.95)';
  ctx.font = `12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace`;
  ctx.textBaseline='top';
  ctx.fillText(`Brighter = larger |μ|. Bands are lines of constant ΔX = X1−X2.`, 16, h-30);
  ctx.restore();
}

/* =========================
   Render loop
========================= */
function renderAll(){
  syncUI();
  drawDiagram();
  drawMainPlot();
  drawSecondaryPlot();
  drawHeatPlot();
}

/* =========================
   Event handlers
========================= */
function hookControls(){
  els.aSlider.addEventListener('input', ()=>{
    state.a_um = parseFloat(els.aSlider.value);
    renderAll();
  });
  els.lamSlider.addEventListener('input', ()=>{
    state.lam_nm = parseFloat(els.lamSlider.value);
    renderAll();
  });
  els.fSlider.addEventListener('input', ()=>{
    state.f_mm = parseFloat(els.fSlider.value);
    renderAll();
  });

  // Initial sync from DOM values
  state.a_um = parseFloat(els.aSlider.value);
  state.lam_nm = parseFloat(els.lamSlider.value);
  state.f_mm = parseFloat(els.fSlider.value);

  // Resize
  window.addEventListener('resize', ()=>{
    renderAll();
  }, {passive:true});
}

hookControls();
renderAll();
</script>
</body>
</html>
