<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Effect of Spectral Width on Fringe Visibility (Michelson Interferometer, Lorentzian Line)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --card:#111c3a;
      --text:#e8eeff;
      --muted:#b7c3ffcc;
      --line:#2a3a77;
      --accent:#7aa2ff;
      --accent2:#6ef3c5;
      --warn:#ffcf5a;
      --bad:#ff6b8a;
      --good:#76ff9b;
      --shadow: 0 18px 45px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 10% 5%, rgba(122,162,255,.20), transparent 60%),
        radial-gradient(900px 700px at 85% 10%, rgba(110,243,197,.12), transparent 60%),
        radial-gradient(900px 900px at 30% 85%, rgba(255,207,90,.08), transparent 65%),
        linear-gradient(180deg, var(--bg), #060913 70%);
      line-height:1.55;
      overflow-x:hidden;
    }

    header{
      padding: 34px 18px 18px;
      max-width: 1100px;
      margin: 0 auto;
    }
    .title{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:18px;
      align-items:end;
    }
    h1{
      margin:0;
      font-size: clamp(1.6rem, 2.2vw + 1rem, 2.55rem);
      letter-spacing:.2px;
      line-height:1.15;
    }
    .subtitle{
      margin:.55rem 0 0;
      color:var(--muted);
      font-size:1rem;
      max-width: 65ch;
    }
    .meta{
      text-align:right;
      color:var(--muted);
      font-size:.95rem;
    }
    .meta .pill{
      display:inline-flex;
      gap:.5rem;
      align-items:center;
      padding:.42rem .7rem;
      border:1px solid rgba(122,162,255,.25);
      background: rgba(17,28,58,.55);
      border-radius: 999px;
      box-shadow: 0 10px 25px rgba(0,0,0,.18);
      margin-left:.45rem;
      margin-top:.5rem;
      white-space:nowrap;
    }

    main{
      max-width: 1100px;
      margin: 0 auto;
      padding: 0 18px 48px;
      display:grid;
      grid-template-columns: 290px 1fr;
      gap:18px;
      align-items:start;
    }

    nav#toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: rgba(15,23,48,.72);
      border:1px solid rgba(122,162,255,.18);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
      backdrop-filter: blur(10px);
    }
    #toc h2{
      margin:0 0 10px;
      font-size:1.02rem;
      letter-spacing:.3px;
    }
    #toc a{
      display:block;
      padding:8px 10px;
      margin:4px 0;
      border-radius:12px;
      color: var(--muted);
      text-decoration:none;
      border:1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      font-size:.95rem;
    }
    #toc a:hover{
      background: rgba(122,162,255,.10);
      border-color: rgba(122,162,255,.25);
      transform: translateX(2px);
      color: var(--text);
    }

    .content{
      display:flex;
      flex-direction:column;
      gap:16px;
      min-width:0;
    }

    section{
      background: rgba(15,23,48,.62);
      border: 1px solid rgba(122,162,255,.16);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 18px 16px;
      backdrop-filter: blur(10px);
    }

    section h2{
      margin: 0 0 10px;
      font-size: 1.35rem;
      letter-spacing:.2px;
    }
    section h3{
      margin: 14px 0 8px;
      font-size: 1.1rem;
      color: #d7e1ff;
    }
    p{margin: 10px 0}
    ul{margin: 10px 0 10px 1.1rem}
    li{margin: 6px 0}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:14px;
    }
    .callout{
      background: rgba(17,28,58,.72);
      border:1px solid rgba(110,243,197,.22);
      border-radius: 16px;
      padding: 12px 12px 10px;
    }
    .callout.warn{ border-color: rgba(255,207,90,.35); }
    .callout.bad{ border-color: rgba(255,107,138,.35); }
    .callout.good{ border-color: rgba(118,255,155,.30); }
    .callout h4{
      margin:0 0 6px;
      font-size: 1.02rem;
      display:flex;
      align-items:center;
      gap:.5rem;
    }

    .eq{
      background: rgba(7,10,20,.55);
      border:1px solid rgba(122,162,255,.20);
      border-radius: 14px;
      padding: 10px 10px 10px;
      overflow:auto;
      position:relative;
    }
    .eq pre{
      margin:0;
      font-family: var(--mono);
      font-size: .95rem;
      color: #eaf0ff;
      white-space: pre-wrap;
    }
    .copyBtn{
      position:absolute;
      top:10px;
      right:10px;
      border: 1px solid rgba(122,162,255,.35);
      background: rgba(17,28,58,.65);
      color: var(--text);
      border-radius: 12px;
      padding: 6px 10px;
      font-size: .85rem;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease;
      user-select:none;
    }
    .copyBtn:hover{ transform: translateY(-1px); background: rgba(122,162,255,.16); }
    .copyBtn:active{ transform: translateY(0px) scale(.99); }

    .vizWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .vizRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    figure{
      margin:0;
      padding: 12px;
      background: rgba(17,28,58,.55);
      border:1px solid rgba(122,162,255,.15);
      border-radius: 16px;
      overflow:hidden;
    }
    figcaption{
      margin-top: 8px;
      color: var(--muted);
      font-size: .92rem;
    }
    canvas{
      width: 100%;
      height: 320px;
      display:block;
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    }
    .diagram canvas{ height: 280px; }

    .controls{
      display:grid;
      grid-template-columns: 1.3fr 1fr 1fr;
      gap:12px;
      align-items:end;
      margin-top: 8px;
    }
    .control{
      background: rgba(7,10,20,.35);
      border:1px solid rgba(122,162,255,.18);
      border-radius: 16px;
      padding: 10px 10px 10px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size: .92rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .control .val{
      font-family: var(--mono);
      color: var(--text);
      font-size:.92rem;
      white-space:nowrap;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    select, button.action{
      width:100%;
      border-radius: 12px;
      padding: 9px 10px;
      border:1px solid rgba(122,162,255,.28);
      background: rgba(17,28,58,.55);
      color: var(--text);
      font-size: .92rem;
    }
    button.action{
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    button.action:hover{
      transform: translateY(-1px);
      background: rgba(122,162,255,.14);
      border-color: rgba(122,162,255,.42);
    }

    .kpi{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
      margin-top: 10px;
    }
    .kpi .box{
      background: rgba(7,10,20,.35);
      border:1px solid rgba(110,243,197,.18);
      border-radius: 16px;
      padding: 10px 10px 10px;
    }
    .kpi .label{ color: var(--muted); font-size:.9rem; }
    .kpi .num{
      font-family: var(--mono);
      font-size: 1.05rem;
      margin-top: 4px;
    }

    footer{
      max-width: 1100px;
      margin: 0 auto;
      padding: 18px 18px 40px;
      color: var(--muted);
      font-size:.95rem;
    }

    .small{
      font-size:.95rem;
      color: var(--muted);
    }

    .badge{
      display:inline-block;
      font-family: var(--mono);
      font-size:.85rem;
      padding: .2rem .5rem;
      border-radius:999px;
      border:1px solid rgba(122,162,255,.22);
      background: rgba(17,28,58,.55);
      color: #dfe8ff;
      margin-left:.35rem;
    }

    .hr{
      height:1px;
      background: linear-gradient(90deg, transparent, rgba(122,162,255,.25), transparent);
      margin: 12px 0;
    }

    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
      nav#toc{ position: relative; top:0; }
      .title{ grid-template-columns: 1fr; }
      .meta{ text-align:left; }
      .vizRow{ grid-template-columns: 1fr; }
      .controls{ grid-template-columns: 1fr; }
      .kpi{ grid-template-columns: 1fr; }
    }

    @media print{
      body{ background:#fff; color:#111; }
      header, main, footer{ max-width: 100%; }
      nav#toc{ display:none; }
      section, figure{ box-shadow:none; backdrop-filter:none; background:#fff; border-color:#bbb; }
      .eq{ background:#fff; border-color:#bbb; }
      .copyBtn{ display:none; }
      canvas{ border:1px solid #ccc; background:#fff; }
      a{ color:#111; text-decoration:none; }
    }
  </style>
</head>

<body>
<header>
  <div class="title">
    <div>
      <h1>Effect of Spectral Width on Fringe Visibility (Lorentzian Source)</h1>
      <p class="subtitle">
        Using a sodium lamp with Lorentzian linewidth <span class="badge">Δν = 5×10¹¹ Hz</span> in a Michelson interferometer,
        we find the <em>maximum optical pathlength difference</em> that still produces clearly visible fringes, here defined as
        visibility <span class="badge">V &gt; 1/2</span>.
      </p>
    </div>
    <div class="meta">
      <div class="pill">Topic: Temporal coherence</div>
      <div class="pill">Tool: Michelson interferometer</div>
      <div class="pill">Model: Lorentzian spectrum</div>
    </div>
  </div>
</header>

<main>
  <nav id="toc" aria-label="Table of contents">
    <h2>Table of Contents</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
  </nav>

  <div class="content">

    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li>We want the largest pathlength (optical path) difference in a Michelson interferometer that still gives fringe visibility <strong>V &gt; 1/2</strong>.</li>
        <li>Key idea: <strong>finite spectral linewidth ⇒ finite temporal coherence ⇒ visibility decays with delay</strong>.</li>
        <li>For a <strong>Lorentzian</strong> spectrum with FWHM linewidth <code>Δν</code>, the degree of first-order coherence magnitude is
          <code>|g₁(τ)| = exp(−π Δν |τ|)</code> (standard Lorentzian coherence result).</li>
        <li>For equal beam intensities in a Michelson, fringe visibility equals coherence magnitude: <code>V(τ)=|g₁(τ)|</code>.</li>
        <li>Delay and optical path difference (OPD) are related by <code>τ = OPD / c</code>.</li>
        <li>Condition <code>V &gt; 1/2</code> gives <code>OPD_max = (c/(πΔν)) ln 2</code> (symbolic).</li>
        <li>Numerically (with <code>Δν = 5×10¹¹ Hz</code>): <strong>OPD_max ≈ 1.32×10⁻⁴ m = 0.132 mm</strong>.</li>
      </ul>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

      <div class="grid2">
        <div class="callout">
          <h4>Core definitions</h4>
          <ul>
            <li><strong>Spectral linewidth</strong> <code>Δν</code> (Hz): a measure of how broad the source’s frequency spectrum is (often FWHM).</li>
            <li><strong>Time delay</strong> <code>τ</code> (s): relative arrival-time difference between the two interfering beams.</li>
            <li><strong>Optical path difference</strong> <code>OPD</code> (m): difference in optical pathlength; in vacuum/air, <code>τ = OPD / c</code>.</li>
            <li><strong>Complex degree of coherence</strong> <code>g₁(τ)</code> (dimensionless): normalized field correlation
              <code>g₁(τ)=⟨E*(t)E(t+τ)⟩/⟨|E(t)|²⟩</code>.</li>
            <li><strong>Fringe visibility</strong> <code>V</code> (dimensionless): contrast
              <code>V = (I_max − I_min)/(I_max + I_min)</code>.</li>
          </ul>
        </div>

        <div class="callout good">
          <h4>Physical meaning</h4>
          <p>
            Interference requires the two fields to maintain a predictable phase relationship.
            A finite linewidth source has a phase that “wanders” over time. If the interferometer delays one arm by <code>τ</code> longer than the coherence time,
            the two waves become effectively uncorrelated and fringes wash out (visibility → 0).
          </p>
        </div>
      </div>

      <h3>Key law: Wiener–Khinchin / spectrum–coherence link</h3>
      <p>
        The temporal coherence function is essentially the Fourier transform of the power spectrum.
        For many common spectral shapes, this gives simple decay laws:
      </p>
      <div class="grid2">
        <div class="callout">
          <h4>Common model: Lorentzian spectrum</h4>
          <p class="small">
            A Lorentzian line (often from collision/pressure broadening or certain radiative processes) has long “tails” in frequency.
            Its coherence decays <em>exponentially</em> in time.
          </p>
          <div class="eq" data-copy="|g1(τ)| = exp(-π Δν |τ|)   (Lorentzian, Δν = FWHM)">
            <button class="copyBtn" type="button">Copy</button>
            <pre>|g₁(τ)| = exp(−π Δν |τ|)    (Lorentzian spectrum, Δν = FWHM)</pre>
          </div>
        </div>

        <div class="callout warn">
          <h4>When is this valid?</h4>
          <ul>
            <li>Stationary light (statistics do not change with time).</li>
            <li>Spectrum is well-approximated by a Lorentzian with linewidth <code>Δν</code> given as FWHM.</li>
            <li>Interferometer combines two copies of the same field with delay <code>τ</code>.</li>
          </ul>
        </div>
      </div>

      <h3>Mini intuition examples</h3>
      <ul>
        <li>If you make the source <strong>more monochromatic</strong> (smaller <code>Δν</code>), coherence lasts longer → you can tolerate larger path difference.</li>
        <li>For a Lorentzian, visibility drops as <strong>exp(−const × delay)</strong>: each extra delay multiplies visibility by a fixed factor.</li>
      </ul>

      <div class="callout bad">
        <h4>What to watch for (pitfalls)</h4>
        <ul>
          <li><strong>OPD vs mirror travel:</strong> in a Michelson, moving one mirror by <code>Δx</code> changes OPD by <code>2Δx</code>.</li>
          <li><strong>Definition of linewidth:</strong> the exponential law uses <code>Δν</code> as the <em>FWHM</em> of the Lorentzian. Using HWHM changes factors of 2.</li>
          <li><strong>Unequal intensities:</strong> if arm intensities differ, visibility is reduced by an extra factor; here we assume balanced beams (typical for “maximum visibility”).</li>
        </ul>
      </div>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>Problem restatement (in plain words)</h3>
      <p>
        Light from a sodium lamp has a Lorentzian spectral linewidth <code>Δν = 5×10¹¹ Hz</code>.
        In a Michelson interferometer, as the pathlength difference between the two arms increases, fringe visibility decreases.
        Find the maximum pathlength difference such that the interferogram’s visibility remains greater than <code>1/2</code>.
      </p>

      <div class="grid2">
        <div class="callout">
          <h4>Given</h4>
          <ul>
            <li>Lorentzian linewidth (FWHM): <code>Δν = 5 × 10¹¹ Hz</code></li>
            <li>Visibility threshold: <code>V &gt; 1/2</code></li>
            <li>Speed of light (use): <code>c ≈ 3.00 × 10⁸ m/s</code></li>
          </ul>
        </div>
        <div class="callout">
          <h4>Unknown</h4>
          <ul>
            <li>Maximum optical path difference: <code>OPD_max</code> (m)</li>
            <li>(Optionally) maximum mirror displacement: <code>Δx_max = OPD_max/2</code> (m), if “arm length change” is asked experimentally</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li><strong>Temporal coherence:</strong> finite linewidth implies finite correlation time of the electric field.</li>
        <li><strong>Visibility–coherence link:</strong> for two-beam interference with equal intensities, <code>V = |g₁(τ)|</code>.</li>
        <li><strong>Michelson geometry:</strong> delay is determined by the optical path difference: <code>τ = OPD/c</code>.</li>
      </ul>

      <div class="callout warn">
        <h4>Assumptions</h4>
        <ul>
          <li>Balanced interferometer intensities (maximal contrast): <code>I₁ ≈ I₂</code>.</li>
          <li>Source is stationary and well-described by a single Lorentzian line with FWHM <code>Δν</code>.</li>
          <li>Propagation in air/vacuum so group delay ≈ <code>OPD/c</code>.</li>
          <li>Polarization is matched; no extra decoherence from vibration, turbulence, or detector averaging beyond coherence.</li>
        </ul>
      </div>

      <h3>Possible approaches</h3>
      <ul>
        <li><strong>(A) Coherence-function method (best):</strong> use Lorentzian <code>|g₁(τ)| = exp(−πΔν|τ|)</code>, set <code>V&gt;1/2</code>, convert <code>τ↔OPD</code>. <em>Fast and physically transparent.</em></li>
        <li><strong>(B) Fourier transform explicitly:</strong> start from Lorentzian spectrum <code>S(ν)</code>, compute <code>g₁(τ)</code> by integral. <em>More algebra, same result.</em></li>
        <li><strong>(C) Use “coherence length” heuristics:</strong> estimate <code>L_c ~ c/Δν</code> then refine constants. <em>Quick but risks missing factors like π or ln2.</em></li>
      </ul>
      <p><strong>Chosen:</strong> Approach (A) for accuracy with minimal algebra and clear interpretation.</p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

      <ol>
        <li>
          <strong>Relate visibility to coherence.</strong><br/>
          Tool: two-beam interference formula; use <code>V = |g₁(τ)|</code> for equal intensities.<br/>
          Meaning: fringe contrast directly measures temporal coherence at delay <code>τ</code>.
        </li>
        <li>
          <strong>Insert Lorentzian coherence decay.</strong><br/>
          Tool: Lorentzian spectrum ⇔ exponential coherence: <code>|g₁(τ)|=exp(−πΔν|τ|)</code>.<br/>
          Meaning: larger linewidth causes faster coherence loss with delay.
        </li>
        <li>
          <strong>Apply the threshold condition.</strong><br/>
          Tool: set <code>exp(−πΔν τ) &gt; 1/2</code> and solve for <code>τ</code>.<br/>
          Meaning: the max delay is the “half-visibility” coherence time (with a Lorentzian).
        </li>
        <li>
          <strong>Convert delay to path difference.</strong><br/>
          Tool: <code>τ = OPD/c</code>.<br/>
          Meaning: converts temporal coherence to an experimentally controlled length.
        </li>
        <li>
          <strong>Compute the number.</strong><br/>
          Tool: plug <code>c</code> and <code>Δν</code>; keep track of units.<br/>
          Meaning: final maximum OPD in meters (and optional mirror travel).
        </li>
      </ol>

      <div class="grid2">
        <div class="callout bad">
          <h4>Common mistakes</h4>
          <ul>
            <li>Forgetting the factor <code>π</code> in the Lorentzian coherence decay.</li>
            <li>Using <code>c/Δν</code> directly without the <code>ln 2</code> factor for the <code>V=1/2</code> threshold.</li>
            <li>Confusing OPD with mirror displacement in a Michelson (factor of 2).</li>
          </ul>
        </div>
        <div class="callout good">
          <h4>Quick tips</h4>
          <ul>
            <li>Always solve for <code>τ</code> first; then convert to length.</li>
            <li>Check the exponent is dimensionless: <code>(Hz)×(s)</code>.</li>
            <li>Expect a sub-mm scale here because linewidth is very large (hundreds of GHz).</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

      <h3>Physical intuition before math</h3>
      <p>
        A sodium lamp is not a laser; its spectrum is relatively broad, so its phase coherence time is short.
        In a Michelson interferometer, increasing the path mismatch makes the two recombined waves correspond to field values separated in time by <code>τ</code>.
        If <code>τ</code> is too large, the waves lose correlation and fringes fade. Therefore, the maximum tolerable path difference should be small—typically sub-millimeter for very broad lines.
      </p>

      <div class="hr"></div>

      <h3>Step 1: Visibility in two-beam interference</h3>
      <p>
        When two beams with intensities <code>I₁</code> and <code>I₂</code> interfere, the detected intensity as a function of phase is
      </p>
      <div class="eq" data-copy="I = I1 + I2 + 2 sqrt(I1 I2) Re[g1(τ) e^{iφ}]">
        <button class="copyBtn" type="button">Copy</button>
        <pre>I = I₁ + I₂ + 2 √(I₁ I₂) Re[ g₁(τ) e^{iφ} ]</pre>
      </div>
      <p>
        From this, the standard visibility is
      </p>
      <div class="eq" data-copy="V = (Imax - Imin)/(Imax + Imin) = (2 sqrt(I1 I2)/(I1+I2)) |g1(τ)|">
        <button class="copyBtn" type="button">Copy</button>
        <pre>V = (I_max − I_min)/(I_max + I_min) = (2 √(I₁ I₂)/(I₁+I₂)) |g₁(τ)|</pre>
      </div>
      <p>
        <strong>Explanation:</strong> the factor <code>|g₁(τ)|</code> reduces contrast because imperfect temporal coherence lowers the effective interference term.
      </p>

      <p>
        For maximum visibility we assume balanced intensities (<code>I₁ = I₂</code>), giving
      </p>
      <div class="eq" data-copy="If I1 = I2, then V(τ) = |g1(τ)|">
        <button class="copyBtn" type="button">Copy</button>
        <pre>If I₁ = I₂  ⇒  V(τ) = |g₁(τ)|</pre>
      </div>

      <div class="hr"></div>

      <h3>Step 2: Lorentzian linewidth ⇒ exponential coherence decay</h3>
      <p>
        For a Lorentzian spectrum with full width at half maximum (FWHM) <code>Δν</code>, the magnitude of the degree of coherence is
      </p>
      <div class="eq" data-copy="|g1(τ)| = exp(-π Δν |τ|)   (Δν is FWHM for a Lorentzian line)">
        <button class="copyBtn" type="button">Copy</button>
        <pre>|g₁(τ)| = exp(−π Δν |τ|)   (Lorentzian; Δν is FWHM)</pre>
      </div>
      <p>
        <strong>Explanation:</strong> this is the standard Fourier-transform pair: Lorentzian in frequency ↔ exponential in time.
        A larger linewidth means faster decay with delay.
      </p>

      <div class="hr"></div>

      <h3>Step 3: Impose the visibility requirement</h3>
      <p>
        We require <code>V &gt; 1/2</code>. With balanced beams, <code>V = |g₁(τ)|</code>, so
      </p>
      <div class="eq" data-copy="exp(-π Δν τ) > 1/2  (take τ >= 0)">
        <button class="copyBtn" type="button">Copy</button>
        <pre>exp(−π Δν τ) &gt; 1/2   (take τ ≥ 0)</pre>
      </div>
      <p>
        Take natural logs (noting the exponential is monotonic):
      </p>
      <div class="eq" data-copy="-π Δν τ > ln(1/2) = -ln 2  =>  τ < (ln 2)/(π Δν)">
        <button class="copyBtn" type="button">Copy</button>
        <pre>−π Δν τ &gt; ln(1/2) = −ln 2
⇒  π Δν τ &lt; ln 2
⇒  τ &lt; (ln 2)/(π Δν)</pre>
      </div>
      <p>
        <strong>Explanation:</strong> the “half-visibility” delay for a Lorentzian is <code>τ_{1/2} = (ln 2)/(πΔν)</code>.
      </p>

      <div class="hr"></div>

      <h3>Step 4: Convert delay to optical path difference</h3>
      <p>
        The delay is related to optical path difference by
      </p>
      <div class="eq" data-copy="τ = OPD / c   =>   OPD_max = c τ_max">
        <button class="copyBtn" type="button">Copy</button>
        <pre>τ = OPD / c   ⇒   OPD_max = c τ_max</pre>
      </div>
      <p>
        Therefore,
      </p>
      <div class="eq" data-copy="OPD_max = (c/(π Δν)) ln 2">
        <button class="copyBtn" type="button">Copy</button>
        <pre>OPD_max = (c/(π Δν)) ln 2</pre>
      </div>

      <div class="hr"></div>

      <h3>Step 5: Numerical evaluation</h3>
      <p>
        Use <code>c = 3.00×10⁸ m/s</code> and <code>Δν = 5.00×10¹¹ Hz</code>.
      </p>
      <div class="eq" data-copy="OPD_max = (3.00e8/(π*5.00e11)) ln 2 ≈ 1.32e-4 m = 0.132 mm">
        <button class="copyBtn" type="button">Copy</button>
        <pre>OPD_max = (3.00×10⁸ / (π·5.00×10¹¹)) ln 2
       ≈ (3.00×10⁸ / 1.5708×10¹²) · 0.6931
       ≈ 1.32×10⁻⁴ m
       ≈ 0.132 mm</pre>
      </div>

      <div class="callout good">
        <h4>Final Answer (boxed)</h4>
        <div class="eq" data-copy="Maximum optical path difference for V > 1/2:
OPD_max = (c/(π Δν)) ln 2
For Δν = 5×10^11 Hz: OPD_max ≈ 1.32×10^-4 m ≈ 0.132 mm.
(Michelson mirror displacement equivalent: Δx_max = OPD_max/2 ≈ 0.066 mm.)">
          <button class="copyBtn" type="button">Copy</button>
          <pre>Maximum optical path difference for V &gt; 1/2:
OPD_max = (c/(π Δν)) ln 2

For Δν = 5×10^11 Hz:
OPD_max ≈ 1.32×10^-4 m ≈ 0.132 mm

(Michelson mirror displacement equivalent:
Δx_max = OPD_max/2 ≈ 0.066 mm)</pre>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><strong>Units:</strong> <code>c/(Δν)</code> has units <code>(m/s)/(1/s) = m</code>; multiplying by <code>ln2/π</code> is dimensionless ⇒ meters. Good.</li>
        <li><strong>Limiting case:</strong> if <code>Δν → 0</code> (perfectly monochromatic), then <code>OPD_max → ∞</code> ⇒ fringes never wash out. Makes sense.</li>
        <li><strong>Trend:</strong> doubling linewidth halves <code>OPD_max</code> (inverse proportionality). Matches intuition.</li>
      </ul>

      <p>
        <strong>Connection to the diagram and plots:</strong> the Michelson creates an OPD by having different arm lengths (or by moving a mirror).
        The plots below show how the visibility falls exponentially with OPD for a Lorentzian line, and how changing <code>Δν</code> shifts the allowable OPD.
      </p>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

      <h3>Re-interpreting the final formula</h3>
      <p>
        The threshold OPD for a chosen visibility level comes from solving
        <code>V = exp(−πΔν·OPD/c)</code>.
        The result
        <code>OPD_max = (c/(πΔν)) ln 2</code>
        says:
      </p>
      <ul>
        <li><code>c</code> converts time coherence into length coherence.</li>
        <li><code>Δν</code> controls how quickly phase correlation decays: broader spectrum ⇒ shorter coherence length.</li>
        <li><code>ln 2</code> appears because we specifically asked for the <code>V = 1/2</code> threshold; a different threshold would replace <code>ln 2</code> with <code>ln(1/V)</code>.</li>
        <li><code>π</code> is a signature of the Lorentzian model and the FWHM definition.</li>
      </ul>

      <h3>Parameter effects (connect to interactive plots)</h3>
      <ul>
        <li>Increase <code>Δν</code> (broader line) ⇒ the visibility curve decays faster ⇒ the <code>V=1/2</code> crossing occurs at smaller OPD.</li>
        <li>Choose a stricter visibility threshold (e.g., <code>V&gt;0.8</code>) ⇒ smaller allowable OPD because you require stronger coherence.</li>
      </ul>

      <h3>An alternative derivation idea</h3>
      <p>
        Start from a normalized Lorentzian spectrum,
        <code>S(ν) ∝ 1 / [1 + (2(ν−ν₀)/Δν)²]</code>,
        and compute <code>g₁(τ) = ∫ S(ν) e^{i2πντ} dν / ∫ S(ν) dν</code>.
        Evaluating this Fourier transform yields <code>g₁(τ) = exp(−πΔν|τ|) e^{i2πν₀τ}</code>.
        The magnitude gives the visibility decay used above.
      </p>

      <div class="callout">
        <h4>Concept check (quick self-test)</h4>
        <ul>
          <li><strong>Q:</strong> If linewidth doubles, what happens to <code>OPD_max</code>? <strong>A:</strong> It halves (inverse proportionality).</li>
          <li><strong>Q:</strong> Why doesn’t the center frequency <code>ν₀</code> appear in <code>OPD_max</code>? <strong>A:</strong> Visibility depends on <code>|g₁|</code>, which depends on spectral width, not the carrier.</li>
          <li><strong>Q:</strong> If the arm intensities are unequal, does coherence improve? <strong>A:</strong> No—coherence is a property of the source; unequal intensities reduce measured visibility further via <code>2√(I₁I₂)/(I₁+I₂)</code>.</li>
          <li><strong>Q:</strong> In a Michelson, why is mirror motion half the OPD change? <strong>A:</strong> The beam travels to the mirror and back, so moving the mirror by <code>Δx</code> changes the round-trip path by <code>2Δx</code>.</li>
        </ul>
      </div>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

      <div class="vizWrap">
        <figure class="diagram">
          <canvas id="cDiagram" aria-label="Michelson interferometer diagram"></canvas>
          <figcaption>
            <strong>Diagram:</strong> A Michelson interferometer. The optical path difference (OPD) comes from unequal arm lengths or mirror displacement.
            The time delay is <code>τ = OPD/c</code>.
          </figcaption>
        </figure>

        <div class="controls" aria-label="Interactive controls">
          <div class="control">
            <label for="lw">
              Lorentzian linewidth Δν (FWHM) <span class="val" id="lwVal"></span>
            </label>
            <input id="lw" type="range" min="1e10" max="2e12" step="1e10" value="5e11"/>
            <div class="small">Slide to see how coherence length changes with linewidth.</div>
          </div>

          <div class="control">
            <label for="vth">
              Visibility threshold Vₜₕ <span class="val" id="vthVal"></span>
            </label>
            <input id="vth" type="range" min="0.1" max="0.95" step="0.01" value="0.5"/>
            <div class="small">Changes the “allowed OPD” crossing point.</div>
          </div>

          <div class="control">
            <label for="modeSel">
              X-axis scale <span class="val" id="modeVal"></span>
            </label>
            <select id="modeSel">
              <option value="mm" selected>OPD in millimeters</option>
              <option value="um">OPD in micrometers</option>
              <option value="s">Delay τ in picoseconds</option>
            </select>
            <button class="action" id="resetBtn" type="button" style="margin-top:10px;">Reset to problem values</button>
          </div>
        </div>

        <div class="kpi" aria-label="Computed results">
          <div class="box">
            <div class="label">Computed OPDₘₐₓ (for V &gt; Vₜₕ)</div>
            <div class="num" id="kpiOPD"></div>
          </div>
          <div class="box">
            <div class="label">Equivalent mirror travel Δxₘₐₓ (Michelson)</div>
            <div class="num" id="kpiDX"></div>
          </div>
          <div class="box">
            <div class="label">Half-visibility coherence time τₘₐₓ</div>
            <div class="num" id="kpiTau"></div>
          </div>
        </div>

        <div class="vizRow">
          <figure>
            <canvas id="cPlot1" aria-label="Visibility versus optical path difference plot"></canvas>
            <figcaption>
              <strong>Main plot:</strong> Visibility <code>V(OPD)=exp(−πΔν·OPD/c)</code>.
              The vertical marker shows the maximum OPD where <code>V = Vₜₕ</code>.
            </figcaption>
          </figure>

          <figure>
            <canvas id="cPlot2" aria-label="Parameter sweep: OPD threshold versus linewidth"></canvas>
            <figcaption>
              <strong>Secondary plot (parameter sweep):</strong> The allowable OPD at the chosen threshold versus linewidth:
              <code>OPDₘₐₓ(Δν)= (c/(πΔν)) ln(1/Vₜₕ)</code>. The dot marks the current slider value.
            </figcaption>
          </figure>
        </div>

        <div class="callout">
          <h4>Interactive controls: what changes and why</h4>
          <ul>
            <li><strong>Δν slider:</strong> larger linewidth ⇒ faster exponential decay ⇒ smaller OPD where the curve hits the threshold.</li>
            <li><strong>Vₜₕ slider:</strong> stricter threshold (closer to 1) ⇒ shorter allowed OPD because you demand higher contrast.</li>
            <li><strong>X-axis scale:</strong> switches between OPD (mm/µm) and time delay τ (ps) while keeping physics identical.</li>
          </ul>
        </div>

      </div>
    </section>

  </div>
</main>

<footer>
  <div class="small">
    Note: Many textbooks define linewidth carefully (FWHM vs HWHM). This article uses the common result for a Lorentzian line with <strong>FWHM = Δν</strong>:
    <code>|g₁(τ)| = exp(−πΔν|τ|)</code>. If your course defines Δν differently, constants may shift by a factor of 2.
  </div>
</footer>

<script>
(function(){
  // ---------- Utilities ----------
  const c = 299792458; // m/s
  const PI = Math.PI;

  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

  function fmtSI(x, unit){
    // Simple SI formatting with 3 sig figs + unit
    const ax = Math.abs(x);
    if (ax === 0) return "0 " + unit;
    const prefixes = [
      {p: -12, s: "p"}, {p: -9, s: "n"}, {p: -6, s: "µ"}, {p: -3, s: "m"},
      {p: 0, s: ""}, {p: 3, s: "k"}, {p: 6, s: "M"}, {p: 9, s: "G"}, {p: 12, s: "T"}
    ];
    const exp = Math.floor(Math.log10(ax)/3)*3;
    const pref = prefixes.reduce((best,cur)=> Math.abs(cur.p-exp) < Math.abs(best.p-exp) ? cur : best, prefixes[4]);
    const scaled = x / Math.pow(10, pref.p);
    const s = (Math.round(scaled*1000)/1000).toString();
    return s + " " + pref.s + unit;
  }

  function setCanvasHiDPI(canvas){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(2, Math.floor(rect.width * dpr));
    const h = Math.max(2, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w;
      canvas.height = h;
    }
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return {ctx, dpr, wCSS: rect.width, hCSS: rect.height};
  }

  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
    const {x, y, w, h} = box;
    // Background
    ctx.save();
    ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
    ctx.restore();

    ctx.save();
    ctx.translate(0.5,0.5); // crisp-ish lines
    // Plot panel background
    ctx.fillStyle = "rgba(255,255,255,0.02)";
    ctx.fillRect(x, y, w, h);

    // Grid + ticks
    const nGrid = 6;
    ctx.strokeStyle = "rgba(122,162,255,0.16)";
    ctx.lineWidth = 1;

    function tx(u){ return x + (u - xMin) * (w/(xMax-xMin)); }
    function ty(v){ return y + h - (v - yMin) * (h/(yMax-yMin)); }

    // Grid lines
    for(let i=0;i<=nGrid;i++){
      const gx = x + i*w/nGrid;
      const gy = y + i*h/nGrid;
      ctx.beginPath(); ctx.moveTo(gx,y); ctx.lineTo(gx,y+h); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x,gy); ctx.lineTo(x+w,gy); ctx.stroke();
    }

    // Border
    ctx.strokeStyle = "rgba(122,162,255,0.32)";
    ctx.strokeRect(x,y,w,h);

    // Title
    ctx.fillStyle = "rgba(232,238,255,0.95)";
    ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(title, x+8, y-10);

    // Axes labels
    ctx.fillStyle = "rgba(183,195,255,0.95)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(xLabel, x + w - 4 - ctx.measureText(xLabel).width, y + h + 22);

    // y label rotated
    ctx.save();
    ctx.translate(x - 34, y + 10);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    // Tick labels
    ctx.fillStyle = "rgba(183,195,255,0.90)";
    ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    for(let i=0;i<=nGrid;i++){
      const u = xMin + i*(xMax-xMin)/nGrid;
      const v = yMin + i*(yMax-yMin)/nGrid;
      const gx = tx(u);
      const gy = ty(v);

      const xu = niceNum(u);
      const yv = niceNum(v);

      ctx.fillText(xu, gx-10, y+h+14);
      ctx.fillText(yv, x-34, gy+4);
    }

    ctx.restore();

    return {tx, ty};
  }

  function niceNum(v){
    // small formatting for tick labels
    const av = Math.abs(v);
    if(av >= 1000 || (av > 0 && av < 0.01)){
      return v.toExponential(1);
    }
    const s = (Math.round(v*100)/100).toString();
    return s;
  }

  function plotLine(ctx, map, data, strokeStyle, lineWidth){
    ctx.save();
    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    for(let i=0;i<data.length;i++){
      const px = map.tx(data[i].x);
      const py = map.ty(data[i].y);
      if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawLegend(ctx, box, items){
    const {x,y} = box;
    ctx.save();
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    let lx = x + 10;
    let ly = y + 10;
    items.forEach(it=>{
      ctx.fillStyle = it.color;
      ctx.fillRect(lx, ly-9, 14, 8);
      ctx.fillStyle = "rgba(232,238,255,0.95)";
      ctx.fillText(it.label, lx+20, ly);
      ly += 18;
    });
    ctx.restore();
  }

  function drawMarkerVLine(ctx, map, xVal, yMin, yMax, label){
    const x = map.tx(xVal);
    ctx.save();
    ctx.strokeStyle = "rgba(110,243,197,0.9)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,4]);
    ctx.beginPath();
    ctx.moveTo(x, map.ty(yMin));
    ctx.lineTo(x, map.ty(yMax));
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = "rgba(110,243,197,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    const text = label;
    ctx.fillText(text, x+6, map.ty(yMax) + 16);
    ctx.restore();
  }

  function drawMarkerHLine(ctx, map, yVal, xMin, xMax, label){
    const y = map.ty(yVal);
    ctx.save();
    ctx.strokeStyle = "rgba(255,207,90,0.9)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,4]);
    ctx.beginPath();
    ctx.moveTo(map.tx(xMin), y);
    ctx.lineTo(map.tx(xMax), y);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = "rgba(255,207,90,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(label, map.tx(xMin)+6, y-6);
    ctx.restore();
  }

  function drawDot(ctx, map, xVal, yVal, color){
    ctx.save();
    ctx.fillStyle = color;
    const x = map.tx(xVal), y = map.ty(yVal);
    ctx.beginPath();
    ctx.arc(x,y,4.5,0,2*Math.PI);
    ctx.fill();
    ctx.restore();
  }

  // ---------- Problem Physics ----------
  function visibilityFromOPD(opd, dNu){
    // Lorentzian (FWHM): |g1| = exp(-π Δν τ), τ=opd/c
    const tau = Math.abs(opd)/c;
    return Math.exp(-PI*dNu*tau);
  }

  function opdMaxForThreshold(dNu, Vth){
    // Solve exp(-π Δν opd/c) = Vth -> opd = (c/(πΔν)) ln(1/Vth)
    Vth = clamp(Vth, 1e-6, 0.999999);
    return (c/(PI*dNu))*Math.log(1.0/Vth);
  }

  // ---------- DOM ----------
  const lw = document.getElementById("lw");
  const vth = document.getElementById("vth");
  const modeSel = document.getElementById("modeSel");
  const resetBtn = document.getElementById("resetBtn");

  const lwVal = document.getElementById("lwVal");
  const vthVal = document.getElementById("vthVal");
  const modeVal = document.getElementById("modeVal");

  const kpiOPD = document.getElementById("kpiOPD");
  const kpiDX = document.getElementById("kpiDX");
  const kpiTau = document.getElementById("kpiTau");

  const cDiagram = document.getElementById("cDiagram");
  const cPlot1 = document.getElementById("cPlot1");
  const cPlot2 = document.getElementById("cPlot2");

  function updateLabels(){
    const dNu = Number(lw.value);
    const Vth = Number(vth.value);
    lwVal.textContent = fmtSI(dNu, "Hz");
    vthVal.textContent = Vth.toFixed(2);
    modeVal.textContent = modeSel.options[modeSel.selectedIndex].textContent;
  }

  function updateKPIs(){
    const dNu = Number(lw.value);
    const Vth = Number(vth.value);
    const opdMax = opdMaxForThreshold(dNu, Vth);
    const dxMax = opdMax/2;
    const tauMax = opdMax / c;

    // Display in friendly units
    kpiOPD.textContent = fmtSI(opdMax, "m") + " (" + fmtSI(opdMax*1e3, "mm") + ")";
    kpiDX.textContent  = fmtSI(dxMax, "m") + " (" + fmtSI(dxMax*1e3, "mm") + ")";
    kpiTau.textContent = fmtSI(tauMax, "s") + " (" + fmtSI(tauMax*1e12, "ps") + ")";
  }

  // ---------- Diagram ----------
  function drawDiagram(){
    const {ctx, wCSS, hCSS} = setCanvasHiDPI(cDiagram);

    const W = wCSS, H = hCSS;
    ctx.clearRect(0,0,W,H);

    // Soft background
    ctx.fillStyle = "rgba(255,255,255,0.02)";
    ctx.fillRect(10, 10, W-20, H-20);

    // Title
    ctx.fillStyle = "rgba(232,238,255,0.95)";
    ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Michelson Interferometer Geometry (OPD creates delay τ = OPD/c)", 18, 26);

    // Coordinate layout
    const cx = W*0.46, cy = H*0.57;
    const beamW = 3;

    // Draw beams with arrows
    function arrow(x1,y1,x2,y2, color){
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = beamW;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
      ctx.stroke();

      // Arrow head
      const ang = Math.atan2(y2-y1, x2-x1);
      const ah = 10;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(x2,y2);
      ctx.lineTo(x2 - ah*Math.cos(ang-0.6), y2 - ah*Math.sin(ang-0.6));
      ctx.lineTo(x2 - ah*Math.cos(ang+0.6), y2 - ah*Math.sin(ang+0.6));
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    // Elements
    const src = {x: W*0.18, y: cy};
    const bs  = {x: cx, y: cy};
    const m1  = {x: W*0.78, y: cy-90};
    const m2  = {x: W*0.78, y: cy+90};
    const det = {x: W*0.20, y: cy-120};

    // Source
    ctx.save();
    ctx.fillStyle = "rgba(122,162,255,0.22)";
    ctx.strokeStyle = "rgba(122,162,255,0.55)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(src.x, src.y, 14, 0, 2*Math.PI);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = "rgba(232,238,255,0.95)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Source (sodium lamp)", src.x-46, src.y+34);
    ctx.restore();

    // Beam splitter
    ctx.save();
    ctx.translate(bs.x, bs.y);
    ctx.rotate(-Math.PI/4);
    ctx.fillStyle = "rgba(110,243,197,0.14)";
    ctx.strokeStyle = "rgba(110,243,197,0.5)";
    ctx.lineWidth = 2;
    ctx.fillRect(-16,-16,32,32);
    ctx.strokeRect(-16,-16,32,32);
    ctx.restore();
    ctx.fillStyle = "rgba(232,238,255,0.95)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Beam splitter", bs.x-40, bs.y-24);

    // Mirrors
    function mirror(m, label){
      ctx.save();
      ctx.strokeStyle = "rgba(255,207,90,0.65)";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(m.x-18, m.y-18);
      ctx.lineTo(m.x+18, m.y+18);
      ctx.stroke();
      ctx.fillStyle = "rgba(232,238,255,0.95)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(label, m.x-20, m.y-26);
      ctx.restore();
    }
    mirror(m1, "M1");
    mirror(m2, "M2");

    // Detector
    ctx.save();
    ctx.fillStyle = "rgba(255,107,138,0.16)";
    ctx.strokeStyle = "rgba(255,107,138,0.55)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(det.x-22, det.y-14, 44, 28, 8);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = "rgba(232,238,255,0.95)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Detector", det.x-24, det.y-20);
    ctx.restore();

    // Beams: source -> BS
    arrow(src.x+14, src.y, bs.x-18, bs.y, "rgba(122,162,255,0.85)");

    // BS -> M1 and back
    arrow(bs.x+10, bs.y-10, m1.x-20, m1.y+20, "rgba(110,243,197,0.85)");
    arrow(m1.x-24, m1.y+24, bs.x+6, bs.y-6, "rgba(110,243,197,0.55)");

    // BS -> M2 and back
    arrow(bs.x+10, bs.y+10, m2.x-20, m2.y-20, "rgba(110,243,197,0.85)");
    arrow(m2.x-24, m2.y-24, bs.x+6, bs.y+6, "rgba(110,243,197,0.55)");

    // Output to detector
    arrow(bs.x-10, bs.y-10, det.x+22, det.y+14, "rgba(255,107,138,0.85)");

    // Annotate OPD concept
    const dNu = Number(lw.value);
    const Vth = Number(vth.value);
    const opdMax = opdMaxForThreshold(dNu, Vth);

    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1;
    ctx.setLineDash([4,4]);
    ctx.beginPath();
    ctx.moveTo(bs.x+50, bs.y-55);
    ctx.lineTo(bs.x+190, bs.y-120);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(bs.x+50, bs.y+55);
    ctx.lineTo(bs.x+190, bs.y+120);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = "rgba(183,195,255,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText("OPD = |(arm 1) − (arm 2)|", bs.x+60, bs.y-78);
    ctx.fillText("τ = OPD / c", bs.x+60, bs.y-60);

    ctx.fillStyle = "rgba(110,243,197,0.95)";
    ctx.fillText("Current OPD_max ≈ " + (opdMax*1e3).toFixed(3) + " mm", bs.x+60, bs.y-40);
    ctx.restore();
  }

  // ---------- Plots ----------
  function drawPlot1(){
    const {ctx, wCSS, hCSS} = setCanvasHiDPI(cPlot1);
    const dNu = Number(lw.value);
    const Vth = Number(vth.value);

    // Choose x axis based on mode
    const mode = modeSel.value;
    let xMin=0, xMax, xLabel, xToOPD, opdToX;

    // Determine a useful plotting range around the threshold
    const opdMax = opdMaxForThreshold(dNu, Vth);
    const opdRange = Math.max(opdMax*2.6, 3e-6); // ensure nonzero
    const opdMaxPlot = clamp(opdRange, 5e-6, 8e-3); // 5 µm to 8 mm

    if(mode === "mm"){
      xMax = opdMaxPlot*1e3;
      xLabel = "Optical Path Difference OPD (mm)";
      xToOPD = (x)=> x*1e-3;
      opdToX = (opd)=> opd*1e3;
    }else if(mode === "um"){
      xMax = opdMaxPlot*1e6;
      xLabel = "Optical Path Difference OPD (µm)";
      xToOPD = (x)=> x*1e-6;
      opdToX = (opd)=> opd*1e6;
    }else{ // "s" -> plot delay in ps
      const tauMaxPlot = opdMaxPlot/c;
      xMax = tauMaxPlot*1e12;
      xLabel = "Delay τ (ps)";
      xToOPD = (x)=> (x*1e-12)*c;
      opdToX = (opd)=> (opd/c)*1e12;
    }

    const yMin=0, yMax=1.02;
    const box = {x: 52, y: 44, w: wCSS-72, h: hCSS-86};
    const map = drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, "Visibility V (dimensionless)", "Visibility vs OPD for a Lorentzian Source");

    // Curve data
    const N = 260;
    const data = [];
    for(let i=0;i<=N;i++){
      const x = xMin + (xMax-xMin)*i/N;
      const opd = xToOPD(x);
      const V = visibilityFromOPD(opd, dNu);
      data.push({x, y: V});
    }

    plotLine(ctx, map, data, "rgba(122,162,255,0.95)", 2.5);

    // Threshold line
    drawMarkerHLine(ctx, map, Vth, xMin, xMax, "V_th = " + Vth.toFixed(2));

    // OPD_max marker
    const xStar = opdToX(opdMax);
    drawMarkerVLine(ctx, map, xStar, yMin, yMax, (mode==="s" ? "τ_max" : "OPD_max") + " at V_th");

    // Legend
    drawLegend(ctx, box, [
      {color:"rgba(122,162,255,0.95)", label:"V(OPD)=exp(−πΔν·OPD/c)"},
      {color:"rgba(255,207,90,0.95)", label:"Threshold V_th"},
      {color:"rgba(110,243,197,0.95)", label:"Crossing point"}
    ]);

    // Annotate numeric near curve end
    ctx.save();
    ctx.fillStyle = "rgba(232,238,255,0.92)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    const txt = "Δν=" + fmtSI(dNu,"Hz") + "  →  " + (mode==="s" ? "τ_max" : "OPD_max") + "≈" +
                (mode==="s" ? (opdMax/c*1e12).toFixed(3)+" ps" : (opdMax*1e3).toFixed(3)+" mm");
    ctx.fillText(txt, box.x+10, box.y+box.h-10);
    ctx.restore();
  }

  function drawPlot2(){
    const {ctx, wCSS, hCSS} = setCanvasHiDPI(cPlot2);
    const dNuNow = Number(lw.value);
    const Vth = Number(vth.value);

    // Sweep linewidth
    const dNuMin = 1e10;
    const dNuMax = 2e12;

    // y range based on endpoints (in mm)
    const opdMaxLow = opdMaxForThreshold(dNuMax, Vth);
    const opdMaxHigh = opdMaxForThreshold(dNuMin, Vth);

    const yMin = 0;
    const yMax = clamp(opdMaxHigh*1e3*1.05, 0.02, 12); // mm

    const box = {x: 58, y: 44, w: wCSS-80, h: hCSS-86};
    const map = drawAxes(ctx, box, dNuMin/1e11, dNuMax/1e11, yMin, yMax,
      "Linewidth Δν (×10¹¹ Hz)", "OPD_max (mm)", "Parameter Sweep: OPD_max vs Linewidth");

    // Build sweep
    const N = 280;
    const data = [];
    for(let i=0;i<=N;i++){
      const dNu = dNuMin + (dNuMax-dNuMin)*i/N;
      const opd = opdMaxForThreshold(dNu, Vth);
      data.push({x: dNu/1e11, y: opd*1e3});
    }

    plotLine(ctx, map, data, "rgba(110,243,197,0.95)", 2.5);

    // Current point
    const yNow = opdMaxForThreshold(dNuNow, Vth)*1e3;
    drawDot(ctx, map, dNuNow/1e11, yNow, "rgba(255,107,138,0.95)");

    // Legend
    drawLegend(ctx, box, [
      {color:"rgba(110,243,197,0.95)", label:"OPD_max=(c/(πΔν)) ln(1/V_th)"},
      {color:"rgba(255,107,138,0.95)", label:"Current slider value"}
    ]);

    // Annotate
    ctx.save();
    ctx.fillStyle = "rgba(232,238,255,0.92)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText("V_th=" + Vth.toFixed(2) + "  |  current OPD_max≈" + yNow.toFixed(3) + " mm", box.x+10, box.y+box.h-10);
    ctx.restore();
  }

  function redrawAll(){
    updateLabels();
    updateKPIs();
    drawDiagram();
    drawPlot1();
    drawPlot2();
  }

  // ---------- Copy buttons ----------
  function setupCopyButtons(){
    const blocks = document.querySelectorAll(".eq");
    blocks.forEach(eq=>{
      const btn = eq.querySelector(".copyBtn");
      if(!btn) return;
      btn.addEventListener("click", async ()=>{
        const txt = eq.getAttribute("data-copy") || eq.innerText;
        try{
          await navigator.clipboard.writeText(txt.trim());
          const old = btn.textContent;
          btn.textContent = "Copied!";
          setTimeout(()=>btn.textContent = old, 900);
        }catch(e){
          // fallback
          const ta = document.createElement("textarea");
          ta.value = txt.trim();
          document.body.appendChild(ta);
          ta.select();
          try{ document.execCommand("copy"); }catch(_){}
          document.body.removeChild(ta);
          const old = btn.textContent;
          btn.textContent = "Copied!";
          setTimeout(()=>btn.textContent = old, 900);
        }
      });
    });
  }

  // ---------- Smooth scroll for TOC ----------
  function setupTOCScroll(){
    document.querySelectorAll('#toc a').forEach(a=>{
      a.addEventListener('click', (e)=>{
        const href = a.getAttribute('href');
        if(href && href.startsWith('#')){
          e.preventDefault();
          const target = document.querySelector(href);
          if(target){
            target.scrollIntoView({behavior:'smooth', block:'start'});
          }
        }
      });
    });
  }

  // ---------- Events ----------
  lw.addEventListener("input", redrawAll);
  vth.addEventListener("input", redrawAll);
  modeSel.addEventListener("change", redrawAll);

  resetBtn.addEventListener("click", ()=>{
    lw.value = 5e11;
    vth.value = 0.5;
    modeSel.value = "mm";
    redrawAll();
  });

  // Redraw on resize (debounced)
  let rAF = null;
  window.addEventListener("resize", ()=>{
    if(rAF) cancelAnimationFrame(rAF);
    rAF = requestAnimationFrame(()=>redrawAll());
  });

  // Init
  setupCopyButtons();
  setupTOCScroll();
  redrawAll();

})();
</script>
</body>
</html>
