<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Mutual Intensity of a Partially Coherent Optical Wave (Gaussian Schell-model)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --panel2:#0f1730;
      --text:#e9eefc;
      --muted:#b9c4e6;
      --faint:#93a3d6;
      --accent:#7aa2ff;
      --accent2:#7dffcf;
      --warn:#ffd37a;
      --ok:#9bff7a;
      --danger:#ff7aa2;
      --line:rgba(255,255,255,0.10);
      --line2:rgba(255,255,255,0.16);
      --shadow: 0 12px 30px rgba(0,0,0,0.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 10% 10%, rgba(122,162,255,0.18), transparent 60%),
        radial-gradient(900px 600px at 85% 20%, rgba(125,255,207,0.10), transparent 55%),
        radial-gradient(1000px 700px at 40% 95%, rgba(255,211,122,0.10), transparent 60%),
        var(--bg);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:28px 18px 14px;
      max-width:1200px;
      margin:0 auto;
    }
    .title{
      display:flex;
      gap:14px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .title h1{
      margin:0;
      font-size:clamp(1.35rem, 2.2vw, 2.15rem);
      letter-spacing:0.2px;
    }
    .subtitle{
      color:var(--muted);
      margin:8px 0 0;
      max-width:78ch;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding:0 18px 36px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }

    nav.toc{
      position:sticky;
      top:14px;
      background:linear-gradient(180deg, rgba(17,26,51,0.95), rgba(17,26,51,0.78));
      border:1px solid var(--line);
      box-shadow:var(--shadow);
      border-radius:var(--radius);
      padding:14px 14px 12px;
      backdrop-filter: blur(10px);
    }
    nav.toc .toc-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    nav.toc .toc-head strong{
      font-size:0.95rem;
      letter-spacing:0.2px;
    }
    nav.toc ul{
      margin:8px 0 0;
      padding:0;
      list-style:none;
    }
    nav.toc li{
      margin:6px 0;
      padding-left:10px;
      border-left:2px solid rgba(122,162,255,0.30);
    }
    nav.toc a{
      display:block;
      padding:6px 8px;
      border-radius:12px;
      color:var(--text);
      text-decoration:none;
      font-size:0.92rem;
      transition: transform .12s ease, background .12s ease;
    }
    nav.toc a:hover{
      background:rgba(122,162,255,0.10);
      transform: translateX(2px);
    }

    article{
      min-width:0;
    }

    section{
      background:linear-gradient(180deg, rgba(17,26,51,0.86), rgba(15,23,48,0.74));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:18px 18px 14px;
      margin-bottom:16px;
      overflow:hidden;
    }
    section h2{
      margin:0 0 10px;
      font-size:1.1rem;
      letter-spacing:0.2px;
    }
    section h3{
      margin:14px 0 8px;
      font-size:1.0rem;
      color:var(--text);
    }
    p{margin:10px 0; color:var(--text)}
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
      nav.toc{position:relative; top:auto}
      .grid2{grid-template-columns: 1fr}
    }

    .callout{
      border-radius:16px;
      padding:12px 12px 10px;
      border:1px solid var(--line2);
      background:rgba(0,0,0,0.14);
      margin:10px 0;
    }
    .callout strong{display:block; margin-bottom:6px}
    .callout.assumptions{border-left:4px solid var(--warn)}
    .callout.keyeq{border-left:4px solid var(--accent)}
    .callout.mistakes{border-left:4px solid var(--danger)}
    .callout.answer{border-left:4px solid var(--ok)}
    .equation{
      font-family:var(--mono);
      font-size:0.95rem;
      line-height:1.45;
      background:rgba(0,0,0,0.20);
      border:1px dashed rgba(255,255,255,0.18);
      border-radius:14px;
      padding:10px 10px 8px;
      overflow:auto;
      position:relative;
    }
    .eq-row{
      display:flex;
      align-items:flex-start;
      gap:10px;
      flex-wrap:wrap;
    }
    .copybtn{
      cursor:pointer;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(122,162,255,0.10);
      color:var(--text);
      padding:8px 10px;
      border-radius:12px;
      font-size:0.88rem;
      transition: transform .12s ease, background .12s ease;
      user-select:none;
      white-space:nowrap;
    }
    .copybtn:hover{background:rgba(122,162,255,0.18); transform: translateY(-1px)}
    .copybtn:active{transform: translateY(0px)}
    .chips{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin:8px 0 0;
    }
    .chip{
      font-family:var(--mono);
      font-size:0.84rem;
      padding:6px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.16);
      background:rgba(0,0,0,0.16);
      color:var(--muted);
    }

    figure{
      margin:12px 0 8px;
      padding:0;
    }
    .canvasCard{
      border:1px solid var(--line2);
      border-radius:16px;
      overflow:hidden;
      background:rgba(0,0,0,0.12);
    }
    .canvasHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,0.10);
      background:rgba(0,0,0,0.16);
    }
    .canvasHeader .title{
      margin:0;
      font-size:0.95rem;
      font-weight:700;
      letter-spacing:0.15px;
    }
    .canvasHeader .meta{
      color:var(--muted);
      font-size:0.85rem;
      white-space:nowrap;
    }
    canvas{
      width:100%;
      height:340px;
      display:block;
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .control{
      padding:10px 10px 8px;
      border:1px solid rgba(255,255,255,0.14);
      border-radius:16px;
      background:rgba(0,0,0,0.12);
    }
    .control label{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      font-size:0.9rem;
      color:var(--text);
      margin-bottom:6px;
    }
    .control .val{
      font-family:var(--mono);
      color:var(--accent2);
      font-size:0.88rem;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .btnRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    button{
      font-family:var(--sans);
    }
    .btn{
      cursor:pointer;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(0,0,0,0.10);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      transition: transform .12s ease, background .12s ease;
    }
    .btn:hover{background:rgba(255,255,255,0.06); transform: translateY(-1px)}
    .btn:active{transform: translateY(0px)}
    footer{
      max-width:1200px;
      margin:0 auto;
      padding:10px 18px 28px;
      color:var(--muted);
      font-size:0.92rem;
    }
    .printNote{
      display:none;
    }
    @media print{
      body{background:white; color:black}
      nav.toc{display:none}
      section{box-shadow:none; background:white; border:1px solid #ddd}
      .copybtn,.btn,.controls{display:none !important}
      .equation{border:1px solid #bbb; background:#f7f7f7}
      .printNote{display:block; color:#222}
    }
  </style>
</head>
<body>
<header>
  <div class="title">
    <div>
      <h1>Mutual Intensity of an Optical Wave: Intensity Profile &amp; Degree of Coherence</h1>
      <p class="subtitle">
        We are given a <span class="muted">mutual intensity</span> (a spatial correlation function) on the <span class="muted">x</span>-axis:
        a Gaussian envelope in each coordinate multiplied by a Gaussian coherence term in the separation.
        This is the classic <span class="muted">Gaussian Schell-model</span> in 1D.
      </p>
      <div class="chips" aria-label="topic chips">
        <span class="chip">partial coherence</span>
        <span class="chip">mutual intensity</span>
        <span class="chip">Gaussian Schell-model</span>
        <span class="chip">coherence width</span>
      </div>
    </div>
  </div>
</header>

<main>
  <nav class="toc" aria-label="Table of Contents">
    <div class="toc-head">
      <strong>Table of Contents</strong>
      <span class="muted" style="font-size:0.85rem">sticky</span>
    </div>
    <ul>
      <li><a href="#quick" data-scroll>Quick Summary</a></li>
      <li><a href="#part0" data-scroll>PART 0 — Concept Primer</a></li>
      <li><a href="#part1" data-scroll>PART 1 — Problem Analysis</a></li>
      <li><a href="#part2" data-scroll>PART 2 — Strategy &amp; Tips</a></li>
      <li><a href="#part3" data-scroll>PART 3 — Full Solution</a></li>
      <li><a href="#part4" data-scroll>PART 4 — Deeper Understanding</a></li>
      <li><a href="#part5" data-scroll>PART 5 — Visualization Guide</a></li>
    </ul>
  </nav>

  <article>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>What this is about:</b> Given the mutual intensity <span class="muted">G(x₁,x₂)</span>, find the <span class="muted">intensity</span> <span class="muted">I(x)</span> and the <span class="muted">normalized mutual intensity</span> (degree of coherence) <span class="muted">g(x₁,x₂)</span>.</li>
        <li><b>Key physics idea:</b> Intensity is the <b>diagonal</b> of the mutual intensity: <span class="muted">I(x)=G(x,x)</span>. Normalization removes local intensity scaling and isolates <b>coherence vs separation</b>.</li>
        <li><b>Governing equation (given):</b> <span class="muted">G(x₁,x₂)=I₀ exp[−(x₁²+x₂²)/W₀²] exp[−(x₁−x₂)²/ρc²]</span>.</li>
        <li><b>Main results:</b> <span class="muted">I(x)=I₀ exp[−2x²/W₀²]</span> and <span class="muted">g(x₁,x₂)=exp[−(x₁−x₂)²/ρc²]</span>.</li>
        <li><b>Sketches:</b> Both are Gaussians: intensity vs <span class="muted">x</span>, coherence vs separation <span class="muted">Δx=x₁−x₂</span>.</li>
        <li><b>Parameter meanings:</b> <span class="muted">I₀</span> sets peak intensity (scale), <span class="muted">W₀</span> sets beam/spot size, <span class="muted">ρc</span> sets transverse coherence length (coherence width).</li>
      </ul>

      <div class="callout keyeq">
        <strong>Key Equations (copy-ready)</strong>
        <div class="eq-row">
          <div class="equation" id="eqG">
            G(x1,x2) = I0 * exp( -(x1^2 + x2^2)/W0^2 ) * exp( -(x1 - x2)^2 / rhoc^2 )
          </div>
          <div class="equation" id="eqI">
            I(x) = G(x,x) = I0 * exp( -2 x^2 / W0^2 )
          </div>
          <div class="equation" id="eqg">
            g(x1,x2) = G(x1,x2) / sqrt( I(x1) I(x2) ) = exp( -(x1 - x2)^2 / rhoc^2 )
          </div>
        </div>
        <div class="btnRow" style="margin-top:10px">
          <span class="copybtn" data-copy-target="#eqG">Copy G(x1,x2)</span>
          <span class="copybtn" data-copy-target="#eqI">Copy I(x)</span>
          <span class="copybtn" data-copy-target="#eqg">Copy g(x1,x2)</span>
        </div>
      </div>

      <p class="printNote"><b>Print note:</b> Interactive plots and copy buttons are hidden when printing.</p>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

      <h3>Core definitions (symbols &amp; units)</h3>
      <ul>
        <li><b>Optical field (complex analytic signal):</b> <span class="muted">U(x)</span> (units: √intensity, e.g. √(W/m²)).</li>
        <li><b>Mutual intensity (a.k.a. mutual coherence function up to constants):</b>
          <span class="muted">G(x₁,x₂) = ⟨ U(x₁) U*(x₂) ⟩</span>
          (units: intensity, e.g. W/m²). Angle brackets denote an ensemble/time average.
        </li>
        <li><b>Intensity:</b> <span class="muted">I(x)=⟨|U(x)|²⟩</span> (units: W/m²). Importantly, <span class="muted">I(x)=G(x,x)</span>.</li>
        <li><b>Normalized mutual intensity (complex degree of coherence):</b>
          <span class="muted">g(x₁,x₂) = G(x₁,x₂) / √( I(x₁) I(x₂) )</span>.
          It is dimensionless and satisfies <span class="muted">|g|≤1</span>, with <span class="muted">g(x,x)=1</span>.
        </li>
      </ul>

      <h3>Physical meaning</h3>
      <ul>
        <li><b>G(x₁,x₂)</b> tells you how strongly the field at <span class="muted">x₁</span> is correlated with the field at <span class="muted">x₂</span>.</li>
        <li><b>I(x)</b> is just the local average brightness.</li>
        <li><b>g(x₁,x₂)</b> removes brightness variations so that what remains is purely “how coherent are these two points?”</li>
      </ul>

      <h3>Key principle and validity</h3>
      <div class="callout assumptions">
        <strong>When these definitions apply</strong>
        <ul style="margin:0; padding-left:18px">
          <li>Quasi-monochromatic light (narrowband so a single optical frequency description is meaningful).</li>
          <li>Stationary statistics (averages don’t depend on absolute time).</li>
          <li>Scalar, paraxial approximation (field described by a scalar function along one transverse coordinate).</li>
        </ul>
      </div>

      <h3>Common model: Gaussian Schell-model</h3>
      <p>
        A widely used partially coherent beam model is:
        a <b>Gaussian intensity envelope</b> times a <b>Gaussian coherence function</b> in the separation
        <span class="muted">Δx = x₁ − x₂</span>.
        The given form is exactly that, in 1D.
      </p>

      <h3>Mini intuition examples (quick)</h3>
      <ul>
        <li><b>Fully coherent:</b> if the coherence width were extremely large (formally <span class="muted">ρc → ∞</span>), then <span class="muted">g≈1</span> for all separations: any two points interfere with high contrast.</li>
        <li><b>Poorly coherent:</b> if <span class="muted">ρc</span> is small, then <span class="muted">g</span> drops quickly with separation: only nearby points are correlated, so interference fringes wash out for large slit separations.</li>
      </ul>

      <div class="callout mistakes">
        <strong>What to watch for (pitfalls)</strong>
        <ul style="margin:0; padding-left:18px">
          <li>Confusing <span class="muted">W₀</span> as an “intensity width” vs an “amplitude width” — always check whether the exponent is <span class="muted">−x²/W²</span> or <span class="muted">−2x²/W²</span>.</li>
          <li>For the normalized mutual intensity, <span class="muted">g</span> must satisfy <span class="muted">g(x,x)=1</span> — use that as a sanity check.</li>
          <li>Don’t forget: <span class="muted">I(x)=G(x,x)</span> makes the coherence term vanish because <span class="muted">(x−x)=0</span>.</li>
        </ul>
      </div>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <p>
        <b>Restatement in plain words:</b>
        You are given a formula for the mutual intensity <span class="muted">G(x₁,x₂)</span> of an optical wave along the x-axis.
        (1) Find and sketch the intensity <span class="muted">I(x)</span>. (2) Compute the normalized mutual intensity <span class="muted">g(x₁,x₂)</span>,
        show it depends on <span class="muted">x₁−x₂</span>, and sketch it vs that separation. (3) Explain the physical meaning of the parameters
        <span class="muted">I₀</span>, <span class="muted">W₀</span>, and <span class="muted">ρc</span>.
      </p>

      <div class="grid2">
        <div class="callout">
          <strong>Given</strong>
          <ul style="margin:0; padding-left:18px">
            <li><span class="muted">G(x₁,x₂)= I₀ exp[−(x₁²+x₂²)/W₀²] exp[−(x₁−x₂)²/ρc²]</span></li>
            <li><span class="muted">I₀, W₀, ρc</span> are constants.</li>
          </ul>
        </div>
        <div class="callout">
          <strong>Unknowns / tasks</strong>
          <ul style="margin:0; padding-left:18px">
            <li>Intensity <span class="muted">I(x)</span> and sketch vs <span class="muted">x</span>.</li>
            <li>Normalized mutual intensity <span class="muted">g(x₁,x₂)</span> and sketch vs <span class="muted">Δx=x₁−x₂</span>.</li>
            <li>Physical meaning of <span class="muted">I₀, W₀, ρc</span>.</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li><b>Intensity is the diagonal:</b> By definition of mutual intensity, <span class="muted">I(x)=G(x,x)</span>. This applies because mutual intensity is an ensemble average of <span class="muted">U(x₁)U*(x₂)</span>.</li>
        <li><b>Normalization:</b> The standard dimensionless coherence measure is <span class="muted">g=G/√(I(x₁)I(x₂))</span>, which isolates coherence from brightness.</li>
        <li><b>Gaussian algebra:</b> The given model is already Gaussian; evaluation is straightforward by substitution and cancellation.</li>
      </ul>
      <p class="muted">
        We don’t need Maxwell’s equations, boundary conditions, propagation integrals, or diffraction theory here,
        because the problem is purely about interpreting and normalizing a provided correlation function.
      </p>

      <div class="callout assumptions">
        <strong>Assumptions / idealizations (implicit in the model)</strong>
        <ul style="margin:0; padding-left:18px">
          <li>1D transverse coordinate along the x-axis; the statistics are captured by <span class="muted">G(x₁,x₂)</span>.</li>
          <li>Quasi-monochromatic, stationary field so ensemble/time averages are meaningful.</li>
          <li>Gaussian Schell-model form: Gaussian intensity profile and Gaussian spatial coherence in separation.</li>
        </ul>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ol>
        <li><b>Direct definition approach (best):</b> Use <span class="muted">I(x)=G(x,x)</span> and <span class="muted">g=G/√(II)</span>. <span class="muted">Pros:</span> shortest, most transparent. <span class="muted">Cons:</span> none here.</li>
        <li><b>Re-parameterize in mean/difference coordinates:</b> Let <span class="muted">X=(x₁+x₂)/2</span>, <span class="muted">Δx=x₁−x₂</span> to see structure. <span class="muted">Pros:</span> highlights envelope vs coherence. <span class="muted">Cons:</span> extra algebra not required.</li>
        <li><b>Interpret via coherent-mode decomposition:</b> Expand <span class="muted">G</span> in eigenmodes. <span class="muted">Pros:</span> deep theory. <span class="muted">Cons:</span> overkill for this question.</li>
      </ol>

      <p><b>Chosen approach:</b> The direct definition approach is the clearest and aligns exactly with what the problem asks: intensity and normalized mutual intensity.</p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy &amp; Tips (roadmap only)</h2>
      <ol>
        <li>
          <b>Goal:</b> Extract intensity.
          <br><span class="muted">Tool:</span> Set <span class="muted">x₁=x₂=x</span> in <span class="muted">G(x₁,x₂)</span>.
          <br><span class="muted">Meaning:</span> The diagonal correlation is local average power.
        </li>
        <li>
          <b>Goal:</b> Sketch <span class="muted">I(x)</span>.
          <br><span class="muted">Tool:</span> Recognize the Gaussian form and identify its width parameter.
          <br><span class="muted">Meaning:</span> Spatial brightness distribution.
        </li>
        <li>
          <b>Goal:</b> Compute <span class="muted">g(x₁,x₂)</span>.
          <br><span class="muted">Tool:</span> Use <span class="muted">g=G/√(I(x₁)I(x₂))</span>.
          <br><span class="muted">Meaning:</span> Pure coherence independent of intensity scaling.
        </li>
        <li>
          <b>Goal:</b> Simplify and show dependence on <span class="muted">Δx</span>.
          <br><span class="muted">Tool:</span> Cancel common Gaussian envelope factors.
          <br><span class="muted">Meaning:</span> Coherence determined by point separation only.
        </li>
        <li>
          <b>Goal:</b> Sketch <span class="muted">g</span> vs <span class="muted">Δx</span>.
          <br><span class="muted">Tool:</span> Identify Gaussian decay scale <span class="muted">ρc</span>.
          <br><span class="muted">Meaning:</span> Defines transverse coherence length/width.
        </li>
        <li>
          <b>Goal:</b> Interpret parameters <span class="muted">I₀, W₀, ρc</span>.
          <br><span class="muted">Tool:</span> Use “value at origin” and “1/e points” of Gaussians.
          <br><span class="muted">Meaning:</span> amplitude scale, beam size, coherence width.
        </li>
      </ol>

      <div class="callout mistakes">
        <strong>Common mistakes &amp; quick tips</strong>
        <ul style="margin:0; padding-left:18px">
          <li><b>Tip:</b> Always check <span class="muted">g(x,x)=1</span>. If not, your normalization is wrong.</li>
          <li><b>Mistake:</b> Treating <span class="muted">W₀</span> as the intensity 1/e width directly; here the intensity becomes <span class="muted">exp(−2x²/W₀²)</span>, so the 1/e point is at <span class="muted">x=W₀/√2</span>, and the 1/e² point is at <span class="muted">x=W₀</span>.</li>
          <li><b>Tip:</b> For the coherence term <span class="muted">exp(−Δx²/ρc²)</span>, the 1/e coherence separation is <span class="muted">|Δx|=ρc</span>.</li>
        </ul>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

      <h3>Qualitative expectation (before calculating)</h3>
      <p>
        The given <span class="muted">G(x₁,x₂)</span> has two Gaussian factors:
        one depends on <span class="muted">x₁²+x₂²</span> (so it limits the field to a finite “beam” region),
        and the other depends on <span class="muted">(x₁−x₂)²</span> (so correlation decreases as points separate).
        Therefore we expect:
      </p>
      <ul>
        <li><span class="muted">I(x)</span> will be a centered Gaussian in <span class="muted">x</span> (brightest at <span class="muted">x=0</span>).</li>
        <li><span class="muted">g</span> will be a centered Gaussian in <span class="muted">Δx=x₁−x₂</span> with width controlled by <span class="muted">ρc</span>.</li>
      </ul>

      <div class="callout keyeq">
        <strong>Given mutual intensity</strong>
        <div class="equation">
          G(x1,x2) = I0 · exp( −(x1^2 + x2^2)/W0^2 ) · exp( −(x1 − x2)^2 / rhoc^2 )
        </div>
        <p class="muted" style="margin:8px 0 0">
          Here <span class="muted">I₀</span> sets the overall scale, <span class="muted">W₀</span> sets the transverse envelope size,
          and <span class="muted">ρc</span> sets the coherence width in separation.
        </p>
      </div>

      <h3>Step 1 — Intensity distribution I(x)</h3>
      <p>
        By definition, the intensity is the diagonal of the mutual intensity:
      </p>
      <div class="equation">
        I(x) = G(x,x)
      </div>
      <p>
        Substitute <span class="muted">x₁=x₂=x</span> into the given expression:
      </p>
      <div class="equation">
        I(x)
        = I0 · exp( −(x^2 + x^2)/W0^2 ) · exp( −(x − x)^2 / rhoc^2 )
      </div>
      <p>
        Now simplify each factor:
      </p>
      <ul>
        <li><span class="muted">x²+x² = 2x²</span></li>
        <li><span class="muted">(x−x)² = 0</span> so <span class="muted">exp(0)=1</span></li>
      </ul>
      <div class="equation">
        I(x) = I0 · exp( −2x^2 / W0^2 )
      </div>
      <p class="muted">
        What we did: we used the definition <span class="muted">I(x)=G(x,x)</span>. Why it works: mutual intensity is an average of <span class="muted">U(x₁)U*(x₂)</span>,
        so setting <span class="muted">x₁=x₂</span> gives <span class="muted">⟨|U(x)|²⟩</span>.
      </p>

      <div class="callout answer">
        <strong>Intensity (final)</strong>
        <div class="equation" id="finalI">
          I(x) = I0 · exp( −2x^2 / W0^2 )
        </div>
        <div class="btnRow">
          <span class="copybtn" data-copy-target="#finalI">Copy final I(x)</span>
        </div>
      </div>

      <h3>Step 2 — Normalized mutual intensity g(x₁,x₂)</h3>
      <p>
        The normalized mutual intensity is defined as:
      </p>
      <div class="equation">
        g(x1,x2) = G(x1,x2) / sqrt( I(x1) · I(x2) )
      </div>

      <p>
        First compute <span class="muted">I(x₁)</span> and <span class="muted">I(x₂)</span> from the result above:
      </p>
      <div class="equation">
        I(x1) = I0 · exp( −2x1^2 / W0^2 ),  &nbsp;&nbsp;
        I(x2) = I0 · exp( −2x2^2 / W0^2 )
      </div>

      <p>
        Multiply and take the square root:
      </p>
      <div class="equation">
        I(x1)I(x2)
        = I0^2 · exp( −2(x1^2 + x2^2)/W0^2 )
      </div>
      <div class="equation">
        sqrt(I(x1)I(x2))
        = I0 · exp( −(x1^2 + x2^2)/W0^2 )
      </div>

      <p>
        Now divide <span class="muted">G</span> by this normalization:
      </p>
      <div class="equation">
        g(x1,x2)
        = [ I0 · exp( −(x1^2 + x2^2)/W0^2 ) · exp( −(x1 − x2)^2 / rhoc^2 ) ]
          / [ I0 · exp( −(x1^2 + x2^2)/W0^2 ) ]
      </div>
      <p>
        The common factors cancel exactly:
      </p>
      <div class="equation">
        g(x1,x2) = exp( −(x1 − x2)^2 / rhoc^2 )
      </div>
      <p class="muted">
        What we did: normalized by local intensities to remove the beam envelope. Why it matters: coherence is a <b>relative correlation</b>, not an absolute brightness.
      </p>

      <div class="callout answer">
        <strong>Normalized mutual intensity (final)</strong>
        <div class="equation" id="finalg">
          g(x1,x2) = exp( −(x1 − x2)^2 / rhoc^2 )
        </div>
        <p class="muted" style="margin:8px 0 0">
          Therefore <b>g depends only on the separation</b> <span class="muted">Δx=x₁−x₂</span>, and it is a Gaussian vs <span class="muted">Δx</span>.
        </p>
        <div class="btnRow">
          <span class="copybtn" data-copy-target="#finalg">Copy final g(x1,x2)</span>
        </div>
      </div>

      <h3>Step 3 — Sketches (what they look like)</h3>
      <ul>
        <li><b>Intensity:</b> <span class="muted">I(x)=I₀ exp(−2x²/W₀²)</span> is a Gaussian centered at 0. It falls to <span class="muted">I₀/e²</span> at <span class="muted">|x|=W₀</span>.</li>
        <li><b>Coherence:</b> <span class="muted">g(Δx)=exp(−Δx²/ρc²)</span> is a Gaussian centered at 0. It falls to <span class="muted">1/e</span> at <span class="muted">|Δx|=ρc</span>.</li>
      </ul>

      <h3>Sanity checks</h3>
      <ul>
        <li><b>Units:</b> <span class="muted">G</span> and <span class="muted">I</span> have intensity units; exponents are dimensionless since <span class="muted">x/W₀</span> and <span class="muted">Δx/ρc</span> are ratios of lengths.</li>
        <li><b>Normalization:</b> <span class="muted">g(x,x)=exp(0)=1</span> ✔.</li>
        <li><b>Limits:</b> if <span class="muted">ρc→∞</span>, then <span class="muted">g→1</span> (high coherence); if <span class="muted">ρc→0</span>, then <span class="muted">g</span> becomes sharply peaked (only identical points are correlated).</li>
      </ul>

      <h3>Physical meaning of I₀, W₀, and ρc</h3>
      <div class="callout">
        <strong>Parameter interpretations</strong>
        <ul style="margin:0; padding-left:18px">
          <li><b>I₀</b> (intensity scale): <span class="muted">I(0)=I₀</span>. It sets the peak brightness at the beam center (arbitrary units if not specified).</li>
          <li><b>W₀</b> (beam/spot size): controls how quickly intensity decays with <span class="muted">x</span>. Since <span class="muted">I(x)=I₀ e^{-2x²/W₀²}</span>, the intensity is down by <span class="muted">e^{-2}</span> at <span class="muted">|x|=W₀</span> (a common “1/e² radius” convention).</li>
          <li><b>ρc</b> (coherence width / transverse coherence length): controls how quickly correlation decays with point separation. Since <span class="muted">g(Δx)=e^{-Δx²/ρc²}</span>, the degree of coherence drops to <span class="muted">1/e</span> at <span class="muted">|Δx|=ρc</span>.</li>
        </ul>
      </div>

      <div class="callout answer">
        <strong>Final Answer (copy-ready, plain text)</strong>
        <div class="equation" id="finalAll">
I(x) = G(x,x) = I0 exp(-2 x^2 / W0^2)
g(x1,x2) = G(x1,x2) / sqrt(I(x1) I(x2)) = exp(-(x1-x2)^2 / rhoc^2)

Meaning:
I0 = peak intensity scale (I(0)=I0)
W0 = transverse beam radius (I(W0)=I0/e^2)
rhoc = transverse coherence width (g(rhoc)=1/e)
        </div>
        <div class="btnRow">
          <span class="copybtn" data-copy-target="#finalAll">Copy final answer block</span>
        </div>
      </div>

    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

      <h3>Re-interpreting the formulas</h3>
      <p>
        The given mutual intensity is the product of two distinct “controls”:
      </p>
      <ul>
        <li><b>Envelope control (beam shape):</b> <span class="muted">exp[−(x₁²+x₂²)/W₀²]</span> limits the field’s strength away from the center.</li>
        <li><b>Coherence control (correlation vs separation):</b> <span class="muted">exp[−(x₁−x₂)²/ρc²]</span> limits how far correlations persist in space.</li>
      </ul>
      <p>
        After normalization, the envelope factor disappears and only the coherence factor remains:
        that’s why <span class="muted">g</span> depends only on <span class="muted">Δx</span>.
      </p>

      <h3>How changing parameters affects outcomes</h3>
      <ul>
        <li>Increase <span class="muted">I₀</span> → intensity curve scales up; <span class="muted">g</span> is unchanged (it is normalized).</li>
        <li>Increase <span class="muted">W₀</span> → intensity becomes wider (beam broader); coherence curve unchanged (still set by <span class="muted">ρc</span>).</li>
        <li>Increase <span class="muted">ρc</span> → coherence persists over larger separations; intensity curve unchanged.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        Introduce mean and difference coordinates:
        <span class="muted">X=(x₁+x₂)/2</span> and <span class="muted">Δx=x₁−x₂</span>.
        Then the mutual intensity becomes a Gaussian in <span class="muted">X</span> (beam envelope) times a Gaussian in <span class="muted">Δx</span> (coherence).
        The diagonal corresponds to <span class="muted">Δx=0</span>, immediately giving the intensity.
      </p>

      <h3>Concept checks (self-test)</h3>
      <ul>
        <li><b>Q:</b> Why is <span class="muted">g</span> dimensionless? <b>A:</b> Because you divide <span class="muted">G</span> (intensity units) by √(intensity·intensity).</li>
        <li><b>Q:</b> What is <span class="muted">g</span> at <span class="muted">x₁=x₂</span>? <b>A:</b> <span class="muted">g=1</span> by definition and by the derived formula.</li>
        <li><b>Q:</b> If you doubled <span class="muted">W₀</span>, what changes? <b>A:</b> The intensity profile widens; the coherence vs separation stays the same.</li>
        <li><b>Q:</b> If <span class="muted">ρc</span> is very small, what does that imply physically? <b>A:</b> Points separated by more than a tiny distance are essentially uncorrelated; interference visibility is low for large separations.</li>
      </ul>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

      <p class="muted">
        The canvases below use <b>example values for visualization only</b> (you can change them with sliders).
        The symbolic results remain exactly the same.
      </p>

      <figure class="canvasCard">
        <div class="canvasHeader">
          <div class="title">Diagram: Two points on the x-axis and what G(x₁,x₂) measures</div>
          <div class="meta">geometry + labels</div>
        </div>
        <canvas id="diagCanvas" aria-label="Diagram canvas"></canvas>
      </figure>

      <div class="grid2">
        <figure class="canvasCard">
          <div class="canvasHeader">
            <div class="title">Main Plot: Intensity I(x) = I₀ exp(−2x²/W₀²)</div>
            <div class="meta">x in mm, I in arb</div>
          </div>
          <canvas id="intCanvas" aria-label="Intensity plot canvas"></canvas>
        </figure>

        <figure class="canvasCard">
          <div class="canvasHeader">
            <div class="title">Secondary Plot: Degree of coherence g(Δx) = exp(−Δx²/ρc²)</div>
            <div class="meta">Δx in mm, g dimensionless</div>
          </div>
          <canvas id="cohCanvas" aria-label="Coherence plot canvas"></canvas>
        </figure>
      </div>

      <div class="controls" aria-label="Interactive controls">
        <div class="control">
          <label for="I0"><span><b>I₀</b> (peak intensity, arb.)</span><span class="val" id="I0Val"></span></label>
          <input id="I0" type="range" min="0.2" max="3.0" step="0.05" value="1.0"/>
        </div>
        <div class="control">
          <label for="W0"><span><b>W₀</b> (beam radius, mm)</span><span class="val" id="W0Val"></span></label>
          <input id="W0" type="range" min="0.5" max="6.0" step="0.05" value="2.0"/>
        </div>
        <div class="control">
          <label for="rhoc"><span><b>ρc</b> (coherence width, mm)</span><span class="val" id="rhocVal"></span></label>
          <input id="rhoc" type="range" min="0.2" max="6.0" step="0.05" value="0.8"/>
        </div>
        <div class="control">
          <label><span><b>View</b></span><span class="val" id="noteVal">live update</span></label>
          <div class="btnRow" style="margin-top:6px">
            <button class="btn" id="resetBtn" type="button">Reset example values</button>
            <button class="btn" id="toggleMarkersBtn" type="button">Toggle 1/e markers</button>
          </div>
          <p class="muted" style="margin:8px 0 0">
            Sliders update <b>all</b> canvases: the diagram (labels &amp; widths), intensity, and coherence.
          </p>
        </div>
      </div>

      <h3>What each canvas shows</h3>
      <ul>
        <li><b>Diagram:</b> The x-axis with two points <span class="muted">x₁</span> and <span class="muted">x₂</span>. The beam envelope width relates to <span class="muted">W₀</span>, and the coherence depends on separation <span class="muted">Δx</span>.</li>
        <li><b>Main plot:</b> <span class="muted">I(x)</span> vs <span class="muted">x</span> (Gaussian beam intensity profile). Marker lines optionally show the <span class="muted">1/e²</span> point at <span class="muted">|x|=W₀</span>.</li>
        <li><b>Secondary plot:</b> <span class="muted">g(Δx)</span> vs separation <span class="muted">Δx</span>. Marker lines optionally show the <span class="muted">1/e</span> coherence point at <span class="muted">|Δx|=ρc</span>.</li>
      </ul>

      <h3>How the controls change the plots (and why)</h3>
      <ul>
        <li><b>I₀</b> scales the intensity curve vertically but leaves <span class="muted">g</span> unchanged because <span class="muted">g</span> is normalized.</li>
        <li><b>W₀</b> stretches/compresses the intensity Gaussian horizontally (beam size).</li>
        <li><b>ρc</b> stretches/compresses the coherence Gaussian horizontally (coherence length/width).</li>
      </ul>
    </section>
  </article>
</main>

<footer>
  <div style="border-top:1px solid rgba(255,255,255,0.10); padding-top:12px">
    <p style="margin:0">
      Built as a self-contained learning article with interactive canvases. Symbols used consistently: <span class="muted">I₀</span>, <span class="muted">W₀</span>, <span class="muted">ρc</span>, <span class="muted">x</span>, and <span class="muted">Δx=x₁−x₂</span>.
    </p>
  </div>
</footer>

<script>
(function(){
  // ---------- Smooth scroll for TOC ----------
  document.querySelectorAll('[data-scroll]').forEach(a=>{
    a.addEventListener('click', (e)=>{
      e.preventDefault();
      const id = a.getAttribute('href');
      const el = document.querySelector(id);
      if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
    });
  });

  // ---------- Copy buttons ----------
  async function copyText(text){
    try{
      await navigator.clipboard.writeText(text);
      return true;
    }catch(err){
      // fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.style.position = 'fixed';
      ta.style.left = '-9999px';
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      let ok = false;
      try{ ok = document.execCommand('copy'); }catch(e){ ok=false; }
      document.body.removeChild(ta);
      return ok;
    }
  }
  document.querySelectorAll('.copybtn').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const sel = btn.getAttribute('data-copy-target');
      const el = document.querySelector(sel);
      if(!el) return;
      const text = el.innerText.replace(/\u00A0/g,' ').trim();
      const ok = await copyText(text);
      const old = btn.textContent;
      btn.textContent = ok ? 'Copied!' : 'Copy failed';
      setTimeout(()=>btn.textContent = old, 900);
    });
  });

  // ---------- Canvas helpers (HiDPI + responsive) ----------
  function setupHiDPI(canvas){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(2, Math.floor(rect.width));
    const h = Math.max(2, Math.floor(rect.height));
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return {ctx, w, h, dpr};
  }

  function drawAxes(ctx, box, opts){
    const {x0,y0,w,h} = box;
    const {xMin,xMax,yMin,yMax,xLabel,yLabel,title} = opts;

    // background
    ctx.clearRect(x0,y0,w,h);
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0)';
    ctx.fillRect(x0,y0,w,h);

    // plot area margins
    const m = {l:54, r:16, t:34, b:44};
    const px = {x:x0+m.l, y:y0+m.t, w:w-m.l-m.r, h:h-m.t-m.b};

    // grid
    const nx = 10, ny = 8;
    ctx.lineWidth = 1;
    for(let i=0;i<=nx;i++){
      const xx = px.x + (i/nx)*px.w;
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.beginPath(); ctx.moveTo(xx, px.y); ctx.lineTo(xx, px.y+px.h); ctx.stroke();
    }
    for(let j=0;j<=ny;j++){
      const yy = px.y + (j/ny)*px.h;
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.beginPath(); ctx.moveTo(px.x, yy); ctx.lineTo(px.x+px.w, yy); ctx.stroke();
    }

    // axes frame
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1.2;
    ctx.strokeRect(px.x, px.y, px.w, px.h);

    // ticks + labels
    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    for(let i=0;i<=nx;i++){
      const t = i/nx;
      const val = xMin + t*(xMax-xMin);
      const xx = px.x + t*px.w;
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.beginPath(); ctx.moveTo(xx, px.y+px.h); ctx.lineTo(xx, px.y+px.h+5); ctx.stroke();
      ctx.fillText(formatTick(val), xx, px.y+px.h+8);
    }

    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for(let j=0;j<=ny;j++){
      const t = 1 - j/ny;
      const val = yMin + t*(yMax-yMin);
      const yy = px.y + (j/ny)*px.h;
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.beginPath(); ctx.moveTo(px.x-5, yy); ctx.lineTo(px.x, yy); ctx.stroke();
      ctx.fillText(formatTick(val), px.x-8, yy);
    }

    // title
    ctx.textAlign='left';
    ctx.textBaseline='top';
    ctx.font='13px ' + getComputedStyle(document.body).fontFamily;
    ctx.fillStyle='rgba(233,238,252,0.95)';
    ctx.fillText(title, x0+12, y0+10);

    // axis labels
    ctx.font='12px ' + getComputedStyle(document.body).fontFamily;
    ctx.fillStyle='rgba(185,196,230,0.95)';
    ctx.textAlign='center';
    ctx.fillText(xLabel, px.x + px.w/2, y0 + h - 18);

    // y label rotated
    ctx.save();
    ctx.translate(x0+16, px.y + px.h/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign='center';
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    ctx.restore();

    function xToPx(x){ return px.x + (x - xMin)/(xMax-xMin)*px.w; }
    function yToPx(y){ return px.y + (1 - (y - yMin)/(yMax-yMin))*px.h; }
    return {plot:px, xToPx, yToPx};
  }

  function formatTick(v){
    const av = Math.abs(v);
    if(av >= 10) return v.toFixed(0);
    if(av >= 1) return v.toFixed(1);
    if(av >= 0.1) return v.toFixed(2);
    return v.toFixed(3);
  }

  function drawLine(ctx, map, xs, ys, style){
    ctx.save();
    ctx.strokeStyle = style.stroke || 'rgba(122,162,255,0.95)';
    ctx.lineWidth = style.width || 2.0;
    ctx.beginPath();
    for(let i=0;i<xs.length;i++){
      const X = map.xToPx(xs[i]);
      const Y = map.yToPx(ys[i]);
      if(i===0) ctx.moveTo(X,Y);
      else ctx.lineTo(X,Y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawLegend(ctx, box, items){
    // items: [{label, stroke}]
    const x = box.x + box.w - 10;
    const y = box.y + 10;
    ctx.save();
    ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;
    ctx.textAlign='right';
    ctx.textBaseline='top';
    let yy = y;
    items.forEach(it=>{
      ctx.fillStyle = 'rgba(233,238,252,0.92)';
      ctx.fillText(it.label, x, yy);
      // line sample
      const w = 26;
      ctx.strokeStyle = it.stroke;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x - 150, yy+7);
      ctx.lineTo(x - 150 + w, yy+7);
      ctx.stroke();
      yy += 18;
    });
    ctx.restore();
  }

  function drawVMarker(ctx, map, x, label, yTop, yBottom){
    const X = map.xToPx(x);
    ctx.save();
    ctx.strokeStyle = 'rgba(255,211,122,0.80)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([6,4]);
    ctx.beginPath();
    ctx.moveTo(X, yTop);
    ctx.lineTo(X, yBottom);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle='rgba(255,211,122,0.90)';
    ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';
    ctx.textAlign='center';
    ctx.textBaseline='bottom';
    ctx.fillText(label, X, yTop-6);
    ctx.restore();
  }

  // ---------- Problem-specific functions ----------
  function I_of_x(x, I0, W0){ return I0 * Math.exp(-2*x*x/(W0*W0)); }
  function g_of_dx(dx, rhoc){ return Math.exp(-(dx*dx)/(rhoc*rhoc)); }

  // ---------- State ----------
  const state = {
    I0: 1.0,
    W0: 2.0,    // mm
    rhoc: 0.8,  // mm
    showMarkers: true
  };

  // Inputs
  const I0El = document.getElementById('I0');
  const W0El = document.getElementById('W0');
  const rhocEl = document.getElementById('rhoc');
  const I0Val = document.getElementById('I0Val');
  const W0Val = document.getElementById('W0Val');
  const rhocVal = document.getElementById('rhocVal');

  function syncLabels(){
    I0Val.textContent = Number(state.I0).toFixed(2);
    W0Val.textContent = Number(state.W0).toFixed(2) + ' mm';
    rhocVal.textContent = Number(state.rhoc).toFixed(2) + ' mm';
  }

  function bind(){
    I0El.addEventListener('input', ()=>{ state.I0 = parseFloat(I0El.value); syncLabels(); renderAll(); });
    W0El.addEventListener('input', ()=>{ state.W0 = parseFloat(W0El.value); syncLabels(); renderAll(); });
    rhocEl.addEventListener('input', ()=>{ state.rhoc = parseFloat(rhocEl.value); syncLabels(); renderAll(); });

    document.getElementById('resetBtn').addEventListener('click', ()=>{
      state.I0 = 1.0; state.W0 = 2.0; state.rhoc = 0.8;
      I0El.value = state.I0; W0El.value = state.W0; rhocEl.value = state.rhoc;
      syncLabels(); renderAll();
    });

    document.getElementById('toggleMarkersBtn').addEventListener('click', ()=>{
      state.showMarkers = !state.showMarkers;
      renderAll();
    });

    window.addEventListener('resize', ()=>renderAll());
  }

  // ---------- Rendering ----------
  const diagCanvas = document.getElementById('diagCanvas');
  const intCanvas  = document.getElementById('intCanvas');
  const cohCanvas  = document.getElementById('cohCanvas');

  function renderDiagram(){
    const {ctx,w,h} = setupHiDPI(diagCanvas);

    // background subtle
    ctx.clearRect(0,0,w,h);
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0)';
    ctx.fillRect(0,0,w,h);

    // coordinate frame
    const pad = 18;
    const x0 = pad, y0 = pad, W = w - 2*pad, H = h - 2*pad;
    const midY = y0 + H*0.68;

    // axis
    ctx.strokeStyle = 'rgba(255,255,255,0.20)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x0+10, midY);
    ctx.lineTo(x0+W-10, midY);
    ctx.stroke();

    // arrow
    ctx.beginPath();
    ctx.moveTo(x0+W-10, midY);
    ctx.lineTo(x0+W-22, midY-7);
    ctx.lineTo(x0+W-22, midY+7);
    ctx.closePath();
    ctx.fillStyle = 'rgba(255,255,255,0.20)';
    ctx.fill();

    // labels
    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.font = '13px ' + getComputedStyle(document.body).fontFamily;
    ctx.textAlign = 'right';
    ctx.textBaseline = 'bottom';
    ctx.fillText('x (mm)', x0+W-12, midY-10);

    // choose example x1, x2 based on widths (keep within plot)
    const span = Math.max(3.5, 2.2*state.W0);
    const xMin = -span, xMax = span;
    const x1 = -0.9*state.rhoc;
    const x2 =  1.2*state.rhoc;

    function mapX(x){ return x0 + 26 + (x - xMin)/(xMax-xMin)*(W-52); }

    // beam envelope sketch (Gaussian hump above axis)
    const topY = y0 + H*0.18;
    const amp = H*0.34;
    ctx.strokeStyle = 'rgba(122,162,255,0.85)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<=240;i++){
      const t = i/240;
      const x = xMin + t*(xMax-xMin);
      const I = Math.exp(-2*x*x/(state.W0*state.W0)); // normalized
      const X = mapX(x);
      const Y = midY - (I*amp);
      if(i===0) ctx.moveTo(X,Y);
      else ctx.lineTo(X,Y);
    }
    ctx.stroke();

    // points x1, x2
    const X1 = mapX(x1);
    const X2 = mapX(x2);
    ctx.fillStyle = 'rgba(125,255,207,0.90)';
    ctx.beginPath(); ctx.arc(X1, midY, 5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(X2, midY, 5, 0, Math.PI*2); ctx.fill();

    // vertical guides
    ctx.strokeStyle = 'rgba(125,255,207,0.35)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([5,4]);
    ctx.beginPath(); ctx.moveTo(X1, midY); ctx.lineTo(X1, topY); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(X2, midY); ctx.lineTo(X2, topY); ctx.stroke();
    ctx.setLineDash([]);

    // Δx bracket
    const brY = midY + 34;
    ctx.strokeStyle = 'rgba(255,211,122,0.85)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(X1, brY);
    ctx.lineTo(X2, brY);
    ctx.stroke();
    ctx.beginPath(); ctx.moveTo(X1, brY); ctx.lineTo(X1+10, brY-8); ctx.lineTo(X1+10, brY+8); ctx.closePath(); ctx.fillStyle='rgba(255,211,122,0.55)'; ctx.fill();
    ctx.beginPath(); ctx.moveTo(X2, brY); ctx.lineTo(X2-10, brY-8); ctx.lineTo(X2-10, brY+8); ctx.closePath(); ctx.fillStyle='rgba(255,211,122,0.55)'; ctx.fill();

    // text labels
    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText('x1', X1, midY-10);
    ctx.fillText('x2', X2, midY-10);

    ctx.textBaseline = 'top';
    ctx.fillStyle = 'rgba(255,211,122,0.95)';
    ctx.fillText('Δx = x1 − x2', (X1+X2)/2, brY+10);

    // annotations about W0 and rhoc
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.font = '13px ' + getComputedStyle(document.body).fontFamily;
    ctx.fillStyle = 'rgba(185,196,230,0.95)';
    ctx.fillText('Envelope width set by W0 (beam size)', x0+12, y0+10);
    ctx.fillStyle = 'rgba(185,196,230,0.90)';
    ctx.fillText('Correlation between x1 and x2 set by rhoc (coherence width)', x0+12, y0+30);

    // show marker of W0 on axis (where intensity = e^-2)
    if(state.showMarkers){
      const XW = mapX(state.W0);
      const XmW = mapX(-state.W0);
      ctx.strokeStyle = 'rgba(255,211,122,0.55)';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([6,4]);
      ctx.beginPath(); ctx.moveTo(XmW, midY+2); ctx.lineTo(XmW, midY-90); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(XW,  midY+2); ctx.lineTo(XW,  midY-90); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle='rgba(255,211,122,0.90)';
      ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';
      ctx.textAlign='center';
      ctx.textBaseline='bottom';
      ctx.fillText('±W0', (XmW+XW)/2, midY-92);
    }

    ctx.restore();
  }

  function renderIntensity(){
    const {ctx,w,h} = setupHiDPI(intCanvas);
    const box = {x0:0,y0:0,w:w,h:h};

    // choose x-range based on W0 so plot stays informative
    const xSpan = Math.max(3.5, 2.8*state.W0);
    const xMin = -xSpan, xMax = xSpan;

    // y-range (0..I0) with headroom
    const yMin = 0, yMax = Math.max(0.2, state.I0*1.05);

    const map = drawAxes(ctx, box, {
      xMin, xMax, yMin, yMax,
      xLabel: 'x (mm)',
      yLabel: 'I(x) (arb.)',
      title: 'Intensity distribution'
    });

    // sample curve
    const N = 600;
    const xs = new Array(N);
    const ys = new Array(N);
    for(let i=0;i<N;i++){
      const t = i/(N-1);
      const x = xMin + t*(xMax-xMin);
      xs[i]=x;
      ys[i]=I_of_x(x, state.I0, state.W0);
    }
    drawLine(ctx, map, xs, ys, {stroke:'rgba(122,162,255,0.95)', width:2.4});

    // markers
    if(state.showMarkers){
      // I(W0)=I0/e^2 at x=±W0
      const plot = map.plot;
      drawVMarker(ctx, map,  state.W0,  'x = +W0', plot.y, plot.y+plot.h);
      drawVMarker(ctx, map, -state.W0,  'x = −W0', plot.y, plot.y+plot.h);
    }

    // legend
    drawLegend(ctx, map.plot, [
      {label:'I(x)', stroke:'rgba(122,162,255,0.95)'}
    ]);
  }

  function renderCoherence(){
    const {ctx,w,h} = setupHiDPI(cohCanvas);
    const box = {x0:0,y0:0,w:w,h:h};

    // dx-range based on rhoc
    const dSpan = Math.max(2.0, 3.2*state.rhoc);
    const xMin = -dSpan, xMax = dSpan;

    // y-range fixed 0..1.05
    const yMin = 0, yMax = 1.05;

    const map = drawAxes(ctx, box, {
      xMin, xMax, yMin, yMax,
      xLabel: 'Δx = x1 − x2 (mm)',
      yLabel: 'g(Δx) (dimensionless)',
      title: 'Normalized mutual intensity (degree of coherence)'
    });

    const N = 600;
    const xs = new Array(N);
    const ys = new Array(N);
    for(let i=0;i<N;i++){
      const t = i/(N-1);
      const dx = xMin + t*(xMax-xMin);
      xs[i]=dx;
      ys[i]=g_of_dx(dx, state.rhoc);
    }
    drawLine(ctx, map, xs, ys, {stroke:'rgba(125,255,207,0.92)', width:2.4});

    // markers at ±rhoc (g=1/e)
    if(state.showMarkers){
      const plot = map.plot;
      drawVMarker(ctx, map,  state.rhoc, 'Δx = +rhoc', plot.y, plot.y+plot.h);
      drawVMarker(ctx, map, -state.rhoc, 'Δx = −rhoc', plot.y, plot.y+plot.h);

      // horizontal marker at 1/e
      const y1e = 1/Math.E;
      const Y = map.yToPx(y1e);
      ctx.save();
      ctx.strokeStyle='rgba(255,211,122,0.80)';
      ctx.lineWidth=1.5;
      ctx.setLineDash([6,4]);
      ctx.beginPath();
      ctx.moveTo(plot.x, Y);
      ctx.lineTo(plot.x+plot.w, Y);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle='rgba(255,211,122,0.92)';
      ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';
      ctx.textAlign='left';
      ctx.textBaseline='bottom';
      ctx.fillText('g = 1/e', plot.x+6, Y-6);
      ctx.restore();
    }

    drawLegend(ctx, map.plot, [
      {label:'g(Δx)', stroke:'rgba(125,255,207,0.92)'}
    ]);
  }

  function renderAll(){
    renderDiagram();
    renderIntensity();
    renderCoherence();
  }

  // Init
  function init(){
    // set inputs to default
    I0El.value = state.I0;
    W0El.value = state.W0;
    rhocEl.value = state.rhoc;
    syncLabels();
    bind();
    renderAll();
  }

  init();
})();
</script>
</body>
</html>
