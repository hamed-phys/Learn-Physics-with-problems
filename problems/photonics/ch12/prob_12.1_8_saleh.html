<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Coherence Length from Spectral Width (Narrowband and Broadband)</title>
  <style>
    :root{
      --bg:#0b0f17;
      --card:#111827;
      --card2:#0f1a2e;
      --text:#e6edf7;
      --muted:#a8b3c7;
      --line:rgba(255,255,255,.12);
      --accent:#7dd3fc;
      --accent2:#c4b5fd;
      --ok:#86efac;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 800px at 30% 10%, rgba(125,211,252,.10), transparent 60%),
                  radial-gradient(900px 700px at 80% 0%, rgba(196,181,253,.10), transparent 55%),
                  linear-gradient(180deg, #070a10, var(--bg));
      color:var(--text);
      line-height:1.55;
    }
    header{
      padding:48px 18px 22px;
      max-width:1150px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:18px;
      align-items:end;
    }
    h1{
      margin:0;
      font-weight:800;
      letter-spacing:-.02em;
      font-size:clamp(1.6rem, 2.5vw, 2.5rem);
    }
    header p{
      margin:10px 0 0;
      color:var(--muted);
      max-width:70ch;
    }
    .meta{
      justify-self:end;
      text-align:right;
      color:var(--muted);
      font-size:.95rem;
    }

    main{
      max-width:1150px;
      margin:0 auto;
      padding:0 18px 64px;
      display:grid;
      grid-template-columns: 280px 1fr;
      gap:18px;
    }

    nav.toc{
      position:sticky;
      top:14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(17,24,39,.75), rgba(17,24,39,.55));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:14px 14px 10px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .toc h2{
      font-size:1rem;
      margin:0 0 8px;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .toc a{
      display:block;
      padding:7px 8px;
      margin:2px 0;
      border-radius:12px;
      color:var(--muted);
      text-decoration:none;
      border:1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      font-size:.95rem;
    }
    .toc a:hover{
      background: rgba(125,211,252,.08);
      border-color: rgba(125,211,252,.22);
      color:var(--text);
      transform: translateX(2px);
    }

    article{
      background: linear-gradient(180deg, rgba(17,24,39,.65), rgba(17,24,39,.45));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      backdrop-filter: blur(10px);
    }
    section{
      padding:20px 18px;
      border-top:1px solid var(--line);
    }
    section:first-child{border-top:none}
    h2{
      margin:0 0 10px;
      font-size:1.35rem;
      letter-spacing:-.01em;
    }
    h3{
      margin:14px 0 8px;
      font-size:1.08rem;
      color: #dbe7ff;
    }
    p{margin:10px 0}
    ul{margin:8px 0 8px 18px}
    li{margin:6px 0; color:var(--text)}
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      align-items:start;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
      nav.toc{position:relative; top:auto}
      header{grid-template-columns:1fr}
      .meta{justify-self:start; text-align:left}
      .grid2, .grid3{grid-template-columns:1fr}
    }

    .callout{
      background: linear-gradient(180deg, rgba(15,26,46,.75), rgba(15,26,46,.55));
      border:1px solid rgba(255,255,255,.12);
      border-left:4px solid rgba(125,211,252,.65);
      border-radius:16px;
      padding:12px 12px 10px;
      box-shadow: 0 10px 22px rgba(0,0,0,.25);
    }
    .callout strong{color:#eaf2ff}
    .callout.assump{border-left-color: rgba(196,181,253,.8)}
    .callout.mistake{border-left-color: rgba(251,191,36,.85)}
    .callout.final{border-left-color: rgba(134,239,172,.85)}
    .callout.eq{border-left-color: rgba(125,211,252,.85)}
    .kpi{
      display:flex;
      flex-direction:column;
      gap:6px;
      padding:12px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
    }
    .kpi .label{color:var(--muted); font-size:.9rem}
    .kpi .value{font-family:var(--mono); font-size:1.05rem}
    .eqblock{
      margin:10px 0;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      padding:12px;
      position:relative;
      overflow:hidden;
    }
    pre{
      margin:0;
      white-space:pre-wrap;
      word-break:break-word;
      font-family:var(--mono);
      font-size:.95rem;
      color:#eaf2ff;
    }
    .copybar{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:flex-end;
      margin-top:8px;
    }
    button.copy{
      cursor:pointer;
      background: rgba(125,211,252,.12);
      color:var(--text);
      border:1px solid rgba(125,211,252,.28);
      border-radius:12px;
      padding:7px 10px;
      font-size:.9rem;
      transition: transform .15s ease, background .15s ease;
    }
    button.copy:hover{background: rgba(125,211,252,.18); transform: translateY(-1px)}
    .chips{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:10px;
    }
    .chip{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color:var(--muted);
      font-size:.9rem;
    }

    .vizCard{
      background: linear-gradient(180deg, rgba(17,24,39,.55), rgba(17,24,39,.35));
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;
      padding:12px;
      box-shadow: 0 10px 20px rgba(0,0,0,.25);
    }
    .controls{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:12px;
      align-items:center;
      margin:10px 0 0;
    }
    @media (max-width: 980px){
      .controls{grid-template-columns:1fr}
    }
    .controlRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      padding:10px;
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      background: rgba(0,0,0,.18);
    }
    label{
      color:var(--muted);
      font-size:.92rem;
    }
    select, input[type="range"]{
      width:100%;
      accent-color: #7dd3fc;
    }
    .controlInline{
      display:grid;
      grid-template-columns: 140px 1fr 120px;
      gap:10px;
      align-items:center;
      width:100%;
      min-width: 260px;
    }
    .readout{
      font-family:var(--mono);
      font-size:.92rem;
      color:#eaf2ff;
      text-align:right;
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius:14px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
    }
    .smallCanvas canvas{height:280px}
    .foot{
      padding:16px 18px;
      color:var(--muted);
      border-top:1px solid var(--line);
      font-size:.95rem;
    }

    /* print-friendly */
    @media print{
      body{background:#fff; color:#000}
      nav.toc{display:none}
      article, .vizCard, .callout, .eqblock{box-shadow:none; backdrop-filter:none}
      canvas{border:1px solid #ccc}
      .copybar, button.copy, .controls{display:none !important}
      a{color:#000; text-decoration:none}
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Coherence Length from Spectral Width</h1>
      <p>
        We connect <em>how broad a light sourceâ€™s spectrum is</em> to <em>how far an interferometer can delay one copy of the field</em>
        before fringes wash out. You will derive the classic narrowband estimate
        <span class="muted">l<sub>c</sub> â‰ˆ Î»<sub>0</sub><sup>2</sup>/Î”Î»</span> and an instructive broadband result
        for a uniform spectrum spanning Î»<sub>min</sub> to Î»<sub>max</sub> = 2Î»<sub>min</sub>.
      </p>
      <div class="chips">
        <span class="chip">Optics</span>
        <span class="chip">Interference</span>
        <span class="chip">Temporal coherence</span>
        <span class="chip">Fourier transform intuition</span>
      </div>
    </div>
    <div class="meta">
      <div><span class="muted">Format:</span> self-contained tutorial + interactive plots</div>
      <div><span class="muted">Assumes:</span> basic waves, frequencyâ€“wavelength relations</div>
    </div>
  </header>

  <main>
    <nav class="toc" aria-label="Table of contents">
      <h2>ğŸ“Œ Contents</h2>
      <a href="#quick">Quick Summary</a>
      <a href="#part0">PART 0 â€” Concept Primer</a>
      <a href="#part1">PART 1 â€” Problem Analysis</a>
      <a href="#part2">PART 2 â€” Strategy & Tips</a>
      <a href="#part3">PART 3 â€” Full Solution</a>
      <a href="#part4">PART 4 â€” Deeper Understanding</a>
      <a href="#part5">PART 5 â€” Visualization Guide</a>
      <a href="#viz">Interactive Visualizations</a>
    </nav>

    <article>
      <section id="quick">
        <h2>Quick Summary</h2>
        <ul>
          <li><strong>What this is about:</strong> estimating the <strong>coherence length</strong> l<sub>c</sub> (maximum path difference for visible interference) from a sourceâ€™s <strong>spectral width</strong>.</li>
          <li><strong>Key idea:</strong> interference visibility is governed by the <strong>complex degree of temporal coherence</strong> Î³(Ï„), which is (up to normalization) the Fourier transform of the spectrum.</li>
          <li><strong>Governing relation (frequency form):</strong> a broader spectrum in frequency (Î”Î½) gives a shorter coherence time Ï„<sub>c</sub> ~ 1/Î”Î½, hence l<sub>c</sub> ~ cÏ„<sub>c</sub> ~ c/Î”Î½.</li>
          <li><strong>Narrowband conversion to wavelength:</strong> using Î½ = c/Î», small widths satisfy Î”Î½ â‰ˆ (c/Î»<sub>0</sub><sup>2</sup>)Î”Î», giving
            <strong>l<sub>c</sub> â‰ˆ Î»<sub>0</sub><sup>2</sup>/Î”Î»</strong> (order-of-magnitude).</li>
          <li><strong>Broadband uniform spectrum (Î»<sub>min</sub> to Î»<sub>max</sub> = 2Î»<sub>min</sub>):</strong> use the <strong>wavenumber</strong> Ïƒ = 1/Î» bandwidth
            Î”Ïƒ = 1/Î»<sub>min</sub> âˆ’ 1/Î»<sub>max</sub> = 1/Î»<sub>max</sub>, so <strong>l<sub>c</sub> ~ 1/Î”Ïƒ = Î»<sub>max</sub></strong>.</li>
          <li><strong>Final results are symbolic</strong> (plots use example values only).</li>
        </ul>

        <div class="grid2">
          <div class="callout eq">
            <strong>Key equations (copy-ready)</strong>
            <div class="eqblock">
              <pre id="eqKey1">tau_c ~ 1/Delta_nu
l_c ~ c * tau_c ~ c/Delta_nu</pre>
              <div class="copybar">
                <button class="copy" data-copy="eqKey1">Copy</button>
              </div>
            </div>
            <div class="eqblock">
              <pre id="eqKey2">nu = c/lambda
Delta_nu â‰ˆ (c/lambda0^2) * Delta_lambda   (narrowband)
=> l_c â‰ˆ lambda0^2 / Delta_lambda</pre>
              <div class="copybar">
                <button class="copy" data-copy="eqKey2">Copy</button>
              </div>
            </div>
          </div>

          <div class="callout final">
            <strong>Final answers (copy-ready)</strong>
            <div class="eqblock">
              <pre id="eqFinal">Narrow linewidth (in wavelength units):
l_c â‰ˆ lambda0^2 / Delta_lambda.

Broad uniform spectrum between lambda_min and lambda_max = 2*lambda_min:
l_c â‰ˆ lambda_max.</pre>
              <div class="copybar">
                <button class="copy" data-copy="eqFinal">Copy</button>
              </div>
            </div>
            <p class="muted">
              Note: Different textbooks define â€œcoherence lengthâ€ using first zero, 1/e width, or FWHM of |Î³|.
              These differ by factors of order unity; the problem asks for these standard estimates.
            </p>
          </div>
        </div>
      </section>

      <section id="part0">
        <h2>PART 0 â€” Concept Primer (Theory Before Solving)</h2>

        <h3>Core definitions (symbols & units)</h3>
        <ul>
          <li><strong>Wavelength</strong> Î» (meters), <strong>frequency</strong> Î½ (Hz), <strong>speed of light</strong> c (m/s), related by Î½ = c/Î» in vacuum.</li>
          <li><strong>Spectral density</strong> S(Î½) or S(Î»): how optical power (or field variance) is distributed over frequency or wavelength.</li>
          <li><strong>Time delay</strong> Ï„ (seconds) between two copies of a field; in an interferometer Ï„ = Î”L/c where Î”L is the path difference (meters).</li>
          <li><strong>Mutual coherence function</strong> (temporal) G(Ï„): correlation of the field with a delayed version.</li>
          <li><strong>Complex degree of coherence</strong> Î³(Ï„) = G(Ï„)/G(0): dimensionless; |Î³| controls fringe visibility.</li>
          <li><strong>Coherence time</strong> Ï„<sub>c</sub>: characteristic width of |Î³(Ï„)| (seconds).</li>
          <li><strong>Coherence length</strong> l<sub>c</sub> = c Ï„<sub>c</sub> (meters): characteristic path difference over which interference remains visible.</li>
          <li><strong>Wavenumber</strong> Ïƒ = 1/Î» (1/m): convenient because phase over path difference is 2Ï€ÏƒÎ”L.</li>
        </ul>

        <h3>Physical meaning (what these quantities represent)</h3>
        <p>
          Interference fringes require a reasonably stable phase relationship between the two beams.
          A source with a <em>broader</em> spectrum contains many frequencies; as you increase the delay Ï„,
          different frequency components accumulate different phases and the summed interference term averages out.
          The â€œdistanceâ€ over which the field stays self-correlated is the <strong>coherence length</strong>.
        </p>

        <h3>Key principle and validity conditions</h3>
        <div class="callout eq">
          <strong>Wienerâ€“Khinchin idea (optics version)</strong>
          <p class="muted">
            For a stationary, quasi-monochromatic random process, the temporal coherence function is (up to normalization)
            the Fourier transform of the spectrum:
          </p>
          <div class="eqblock">
            <pre id="eqWK">gamma(tau) âˆ âˆ« S(nu) e^{i 2Ï€ nu tau} dnu,
and |gamma(tau)| controls fringe visibility.</pre>
            <div class="copybar">
              <button class="copy" data-copy="eqWK">Copy</button>
            </div>
          </div>
          <p class="muted">
            Assumes stationarity and linear superposition (typical for thermal light, LEDs, many lasers with finite linewidth).
          </p>
        </div>

        <h3>Common models/approximations (why we use them)</h3>
        <ul>
          <li><strong>Narrowband (Î”Î» â‰ª Î»<sub>0</sub>):</strong> you can linearize Î½(Î») around Î»<sub>0</sub>, converting a wavelength width into a frequency width.</li>
          <li><strong>Bandwidthâ€“coherence reciprocity:</strong> Ï„<sub>c</sub> is roughly the inverse of spectral width (in the conjugate variable) regardless of exact lineshape (differences are only numerical factors).</li>
          <li><strong>Wavenumber bandwidth:</strong> because phase is 2Ï€Î”L/Î» = 2Ï€ÏƒÎ”L, itâ€™s often cleanest to think â€œcoherence length ~ 1/(spread in Ïƒ)â€.</li>
        </ul>

        <h3>Mini intuition examples</h3>
        <ul>
          <li><strong>Perfect monochromatic wave:</strong> spectrum is a delta-function â‡’ Î³(Ï„) never decays â‡’ infinite coherence length (idealization).</li>
          <li><strong>Two close frequencies:</strong> interference visibility beats with delay; adding more frequencies makes faster washout â‡’ shorter coherence length.</li>
        </ul>

        <div class="callout mistake">
          <strong>What to watch for (pitfalls)</strong>
          <ul class="muted">
            <li>Confusing Î”Î» with Î”Î½: they are not proportional; they scale like Î”Î½ â‰ˆ (c/Î»<sup>2</sup>)Î”Î» only when Î”Î» â‰ª Î».</li>
            <li>Using the wrong â€œconjugate variableâ€: delay Ï„ is conjugate to frequency Î½; path difference Î”L is conjugate to wavenumber Ïƒ.</li>
            <li>Expecting an exact single number: â€œcoherence lengthâ€ depends on the chosen width criterion (first zero vs 1/e vs FWHM), but estimates agree up to factors ~1.</li>
          </ul>
        </div>
      </section>

      <section id="part1">
        <h2>PART 1 â€” Problem Analysis (No solving yet)</h2>

        <h3>Restate the problem</h3>
        <p>
          (1) Show that light with a <strong>narrow spectral width</strong> Î”Î» (expressed in wavelength units) has coherence length
          <strong>l<sub>c</sub> â‰ˆ Î»<sub>0</sub><sup>2</sup>/Î”Î»</strong>, where Î»<sub>0</sub> is the central wavelength.
        </p>
        <p>
          (2) For light with a <strong>broad, uniform spectrum in wavelength</strong> spanning Î»<sub>min</sub> to Î»<sub>max</sub>, with Î»<sub>max</sub> = 2Î»<sub>min</sub>,
          show that the coherence length is <strong>l<sub>c</sub> = Î»<sub>max</sub></strong> (as an estimate to within factors of order 1).
        </p>

        <div class="grid2">
          <div class="kpi">
            <div class="label">Given</div>
            <div class="value">Î”Î» (narrowband case), Î»min, Î»max = 2Î»min (broadband case)</div>
          </div>
          <div class="kpi">
            <div class="label">Find / Prove</div>
            <div class="value">lc â‰ˆ Î»0^2/Î”Î» and lc â‰ˆ Î»max</div>
          </div>
        </div>

        <h3>Relevant principles (and why they apply)</h3>
        <ul>
          <li><strong>Interferometric visibility â†” coherence:</strong> fringe contrast in a two-beam interferometer is proportional to |Î³(Ï„)|.</li>
          <li><strong>Fourier reciprocity:</strong> Î³(Ï„) is the normalized Fourier transform of the spectrum in frequency Î½ (or equivalently in wavenumber for spatial delay).</li>
          <li><strong>Small-bandwidth linearization (case 1):</strong> when Î”Î» â‰ª Î»<sub>0</sub>, Î½(Î») can be expanded to first order.</li>
        </ul>
        <p class="muted">
          We do <em>not</em> need Maxwell boundary conditions or spatial mode structure: this is purely temporal coherence from spectral width.
        </p>

        <div class="callout assump">
          <strong>Assumptions</strong>
          <ul class="muted">
            <li>Vacuum propagation (replace c by c/n for a medium if desired; the scaling results are unchanged).</li>
            <li>Stationary source statistics; spectrum is well-defined and stable during measurement.</li>
            <li>â€œCoherence lengthâ€ is a characteristic scale (inverse bandwidth), not an exact universal constant.</li>
          </ul>
        </div>

        <h3>Possible approaches (pros/cons)</h3>
        <ul>
          <li><strong>Approach A: Bandwidth heuristic</strong> (Ï„<sub>c</sub> ~ 1/Î”Î½). Fast, gives the requested narrowband formula immediately; best for estimates.</li>
          <li><strong>Approach B: Explicit Fourier transform</strong> for a chosen lineshape (Gaussian/Lorentzian/rectangular). More detailed, shows where order-unity factors come from; requires more algebra.</li>
          <li><strong>Approach C: Wavenumber-bandwidth argument</strong> (l<sub>c</sub> ~ 1/Î”Ïƒ). Extremely clean for the broadband part because phase depends on Ïƒ = 1/Î».</li>
        </ul>

        <p>
          <strong>Choice:</strong> Weâ€™ll combine A + C: use Ï„<sub>c</sub> ~ 1/Î”Î½ and convert Î”Î½ â†” Î”Î» for the narrowband case, and use the wavenumber spread Î”Ïƒ for the broadband uniform spectrum.
          This matches exactly what the problem is asking to â€œshowâ€.
        </p>
      </section>

      <section id="part2">
        <h2>PART 2 â€” Strategy & Tips (Roadmap Only)</h2>
        <ol>
          <li><strong>Define coherence length:</strong> l<sub>c</sub> = c Ï„<sub>c</sub>. (Meaning: path difference scale where visibility decays.)</li>
          <li><strong>Relate Ï„<sub>c</sub> to bandwidth:</strong> Ï„<sub>c</sub> ~ 1/Î”Î½. (Meaning: more bandwidth â†’ faster dephasing.)</li>
          <li><strong>Convert Î”Î½ to Î”Î» (narrowband):</strong> linearize Î½(Î»)=c/Î» about Î»<sub>0</sub>, obtain Î”Î½ â‰ˆ (c/Î»<sub>0</sub><sup>2</sup>)Î”Î».</li>
          <li><strong>Combine for narrowband result:</strong> l<sub>c</sub> ~ c/Î”Î½ â†’ l<sub>c</sub> â‰ˆ Î»<sub>0</sub><sup>2</sup>/Î”Î».</li>
          <li><strong>For broadband uniform wavelength:</strong> use Ïƒ = 1/Î» as the phase-relevant variable; the characteristic scale is l<sub>c</sub> ~ 1/Î”Ïƒ.</li>
          <li><strong>Compute Î”Ïƒ:</strong> Î”Ïƒ = 1/Î»<sub>min</sub> âˆ’ 1/Î»<sub>max</sub>. Plug Î»<sub>max</sub>=2Î»<sub>min</sub> â†’ Î”Ïƒ=1/Î»<sub>max</sub>.</li>
          <li><strong>Conclude:</strong> l<sub>c</sub> ~ 1/Î”Ïƒ = Î»<sub>max</sub>.</li>
          <li><strong>Sanity checks:</strong> dimensions, limits (Î”Î» â†’ 0 gives l<sub>c</sub> â†’ âˆ), and physical meaning.</li>
        </ol>

        <div class="callout mistake">
          <strong>Common mistakes + quick tips</strong>
          <ul class="muted">
            <li><strong>Tip:</strong> If youâ€™re using wavelength bandwidth, always ask: â€œAm I in the narrowband regime?â€ If not, convert carefully or switch to wavenumber.</li>
            <li><strong>Mistake:</strong> Writing l<sub>c</sub> ~ 1/Î”Î» directly. That is dimensionally wrong unless you mean 1/Î”(1/Î»).</li>
            <li><strong>Tip:</strong> Phase accumulation over path difference Î”L is 2Ï€Î”L/Î» = 2Ï€ÏƒÎ”L â‡’ Ïƒ is the natural â€œfrequency-likeâ€ variable for path delays.</li>
          </ul>
        </div>
      </section>

      <section id="part3">
        <h2>PART 3 â€” Full Solution (Detailed + Teaching)</h2>

        <h3>Physical intuition first</h3>
        <p>
          Imagine a Michelson interferometer: one arm is longer by Î”L, so one copy of the field is delayed by Ï„ = Î”L/c.
          Each spectral component accumulates a phase Ï•(Î½)=2Ï€Î½Ï„. If the spectrum contains a range of Î½,
          then as Ï„ grows the phases spread out and the <em>sum</em> of all interference contributions averages down.
          Therefore, larger bandwidth â‡’ shorter delay tolerance â‡’ shorter coherence length.
        </p>

        <h3>Step 1: Coherence length definition</h3>
        <p>
          The coherence time Ï„<sub>c</sub> is the characteristic width of the normalized field autocorrelation |Î³(Ï„)|.
          The coherence length is
        </p>
        <div class="eqblock">
          <pre id="eqLcDef">l_c = c * tau_c</pre>
          <div class="copybar">
            <button class="copy" data-copy="eqLcDef">Copy</button>
          </div>
        </div>
        <p class="muted">
          (In a medium of refractive index n, replace c by c/n; the scaling results are unchanged.)
        </p>

        <h3>Step 2: Bandwidthâ€“coherence reciprocity (frequency domain)</h3>
        <p>
          For a stationary source, Î³(Ï„) is (normalized) the Fourier transform of the spectrum S(Î½):
        </p>
        <div class="eqblock">
          <pre id="eqGammaNu">gamma(tau) = [ âˆ« S(nu) e^{i 2Ï€ nu tau} dnu ] / [ âˆ« S(nu) dnu ]</pre>
          <div class="copybar">
            <button class="copy" data-copy="eqGammaNu">Copy</button>
          </div>
        </div>
        <p>
          A generic consequence of Fourier transforms is: <strong>wide in Î½</strong> â†” <strong>narrow in Ï„</strong>.
          Thus, to order of magnitude,
        </p>
        <div class="eqblock">
          <pre id="eqTauApprox">tau_c ~ 1/Delta_nu</pre>
          <div class="copybar">
            <button class="copy" data-copy="eqTauApprox">Copy</button>
          </div>
        </div>
        <p class="muted">
          Explanation: If S(Î½) is appreciable over a frequency range Î”Î½, then phases 2Ï€Î½Ï„ vary significantly across that range when Ï„ â‰³ 1/Î”Î½, causing cancellation.
        </p>

        <h3>Part (1): Narrow spectral width in wavelength units</h3>

        <h3>Step 3: Convert Î”Î» to Î”Î½ for Î”Î» â‰ª Î»<sub>0</sub></h3>
        <p>
          Let Î»<sub>0</sub> be the central wavelength, and assume a narrow linewidth Î”Î» such that Î”Î» â‰ª Î»<sub>0</sub>.
          Start from the exact relation in vacuum:
        </p>
        <div class="eqblock">
          <pre id="eqNuLambda">nu = c / lambda</pre>
          <div class="copybar">
            <button class="copy" data-copy="eqNuLambda">Copy</button>
          </div>
        </div>
        <p>
          Linearize Î½(Î») about Î»<sub>0</sub>. Compute the derivative:
        </p>
        <div class="eqblock">
          <pre id="eqDeriv">dnu/dlambda = d(c/lambda)/dlambda = -c/lambda^2</pre>
          <div class="copybar">
            <button class="copy" data-copy="eqDeriv">Copy</button>
          </div>
        </div>
        <p>
          For a small wavelength spread Î”Î», the corresponding frequency spread magnitude is
        </p>
        <div class="eqblock">
          <pre id="eqDnApprox">Delta_nu â‰ˆ |dnu/dlambda|_{lambda0} * Delta_lambda = (c/lambda0^2) * Delta_lambda</pre>
          <div class="copybar">
            <button class="copy" data-copy="eqDnApprox">Copy</button>
          </div>
        </div>
        <p class="muted">
          We took the absolute value because bandwidths are positive; the minus sign only indicates Î½ decreases as Î» increases.
        </p>

        <h3>Step 4: Combine to get l<sub>c</sub></h3>
        <p>
          Using Ï„<sub>c</sub> ~ 1/Î”Î½ and l<sub>c</sub> = cÏ„<sub>c</sub>:
        </p>
        <div class="eqblock">
          <pre id="eqLcNarrow">l_c ~ c/Delta_nu â‰ˆ c / [ (c/lambda0^2) * Delta_lambda ] = lambda0^2 / Delta_lambda</pre>
          <div class="copybar">
            <button class="copy" data-copy="eqLcNarrow">Copy</button>
          </div>
        </div>

        <div class="callout final">
          <strong>Result (narrow linewidth)</strong>
          <div class="eqblock">
            <pre id="eqBox1">l_c â‰ˆ lambda0^2 / Delta_lambda   (for Delta_lambda << lambda0)</pre>
            <div class="copybar">
              <button class="copy" data-copy="eqBox1">Copy</button>
            </div>
          </div>
        </div>

        <h3>Sanity checks (narrowband)</h3>
        <ul>
          <li><strong>Units:</strong> Î»<sub>0</sub><sup>2</sup>/Î”Î» has units of meters (mÂ²/m = m) âœ…</li>
          <li><strong>Limiting case:</strong> Î”Î» â†’ 0 â‡’ l<sub>c</sub> â†’ âˆ (perfect monochromatic light) âœ…</li>
          <li><strong>Scaling:</strong> doubling Î»<sub>0</sub> at fixed Î”Î» quadruples l<sub>c</sub> (longer wavelength is â€œmore tolerantâ€ in this wavelength-parametrized linewidth) âœ…</li>
        </ul>

        <h3>Part (2): Broad uniform spectrum from Î»<sub>min</sub> to Î»<sub>max</sub> = 2Î»<sub>min</sub></h3>

        <h3>Step 5: Use the phase-relevant variable Ïƒ = 1/Î»</h3>
        <p>
          For a path difference Î”L, the phase of a component of wavelength Î» is
          Ï•(Î») = 2Ï€Î”L/Î». Define the wavenumber (spatial frequency)
          Ïƒ = 1/Î», so Ï• = 2Ï€ÏƒÎ”L. This mirrors the frequency-domain relation Ï• = 2Ï€Î½Ï„.
        </p>
        <div class="eqblock">
          <pre id="eqSigma">sigma = 1/lambda,   phase = 2Ï€ sigma Î”L</pre>
          <div class="copybar">
            <button class="copy" data-copy="eqSigma">Copy</button>
          </div>
        </div>

        <p>
          The same Fourier-width logic now says: the coherence length (a Î”L scale) is roughly the inverse of the spread in Ïƒ:
        </p>
        <div class="eqblock">
          <pre id="eqLcSigma">l_c ~ 1/Delta_sigma</pre>
          <div class="copybar">
            <button class="copy" data-copy="eqLcSigma">Copy</button>
          </div>
        </div>
        <p class="muted">
          Explanation: if Ïƒ spans a range Î”Ïƒ, then phases 2Ï€ÏƒÎ”L vary by ~2Ï€ when Î”L ~ 1/Î”Ïƒ, causing strong cancellation of the interference term.
        </p>

        <h3>Step 6: Compute Î”Ïƒ from the wavelength endpoints</h3>
        <p>
          The wavelength support is Î» âˆˆ [Î»<sub>min</sub>, Î»<sub>max</sub>]. The corresponding Ïƒ range is
          Ïƒ âˆˆ [1/Î»<sub>max</sub>, 1/Î»<sub>min</sub>]. Therefore,
        </p>
        <div class="eqblock">
          <pre id="eqDeltaSigma">Delta_sigma = (1/lambda_min) - (1/lambda_max)</pre>
          <div class="copybar">
            <button class="copy" data-copy="eqDeltaSigma">Copy</button>
          </div>
        </div>

        <h3>Step 7: Apply Î»<sub>max</sub> = 2Î»<sub>min</sub></h3>
        <p>
          Substitute Î»<sub>max</sub> = 2Î»<sub>min</sub>:
        </p>
        <div class="eqblock">
          <pre id="eqDeltaSigma2">Delta_sigma = 1/lambda_min - 1/(2 lambda_min) = 1/(2 lambda_min) = 1/lambda_max</pre>
          <div class="copybar">
            <button class="copy" data-copy="eqDeltaSigma2">Copy</button>
          </div>
        </div>

        <h3>Step 8: Conclude l<sub>c</sub></h3>
        <p>
          Using l<sub>c</sub> ~ 1/Î”Ïƒ:
        </p>
        <div class="eqblock">
          <pre id="eqLcBroad">l_c ~ 1/Delta_sigma = 1/(1/lambda_max) = lambda_max</pre>
          <div class="copybar">
            <button class="copy" data-copy="eqLcBroad">Copy</button>
          </div>
        </div>

        <div class="callout final">
          <strong>Result (broad uniform spectrum with Î»<sub>max</sub>=2Î»<sub>min</sub>)</strong>
          <div class="eqblock">
            <pre id="eqBox2">l_c â‰ˆ lambda_max</pre>
            <div class="copybar">
              <button class="copy" data-copy="eqBox2">Copy</button>
            </div>
          </div>
          <p class="muted">
            This is the characteristic path difference scale; an exact definition (e.g., first-zero vs 1/e)
            changes only a factor of order unity.
          </p>
        </div>

        <h3>Sanity checks (broadband)</h3>
        <ul>
          <li><strong>Units:</strong> Î»<sub>max</sub> is a length âœ…</li>
          <li><strong>Trend:</strong> making the spectrum broader in Ïƒ (larger Î”Ïƒ) shortens l<sub>c</sub> âœ…</li>
          <li><strong>Interpretation:</strong> a factor-of-2 span in wavelength corresponds to a sizable spread in phase per Î”L, so coherence is only on the scale of the longest wavelength âœ…</li>
        </ul>

        <p>
          <strong>Connection to the diagram and plots:</strong> in a two-path interferometer, visibility drops as Î”L increases.
          In the plots below, you will see |Î³(Î”L)| decaying for a narrow Gaussian spectrum (slowly)
          and oscillatory decay for a broad uniform wavelength band (quickly), with l<sub>c</sub> marked by a vertical guide.
        </p>
      </section>

      <section id="part4">
        <h2>PART 4 â€” Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpreting the formulas</h3>
        <ul>
          <li><strong>Narrowband:</strong> l<sub>c</sub> â‰ˆ Î»<sub>0</sub><sup>2</sup>/Î”Î» says coherence length grows quadratically with central wavelength if Î”Î» is held fixed.
            Thatâ€™s because a fixed Î”Î» corresponds to a smaller relative frequency spread at longer Î».</li>
          <li><strong>Broadband band-limited:</strong> l<sub>c</sub> ~ 1/Î”Ïƒ reminds you that <em>path difference</em> couples to <em>wavenumber spread</em>.</li>
        </ul>

        <h3>Parameter dependence (connect to the interactive plots)</h3>
        <ul>
          <li>In <strong>Narrow Gaussian</strong> mode, increasing Î”Î» increases Î”Î½ and shrinks l<sub>c</sub>; the |Î³(Î”L)| envelope narrows.</li>
          <li>In <strong>Broad uniform Î»</strong> mode, increasing the ratio r = Î»<sub>max</sub>/Î»<sub>min</sub> increases Î”Ïƒ and shrinks the coherence length scale 1/Î”Ïƒ; fringes wash out sooner.</li>
          <li>The secondary plot shows the â€œsweepâ€: l<sub>c</sub> vs Î”Î» (narrow) or l<sub>c</sub> vs r (broad).</li>
        </ul>

        <h3>An alternative derivation idea (brief)</h3>
        <p class="muted">
          If you assume a <strong>Gaussian</strong> spectrum in frequency S(Î½), its Fourier transform is also Gaussian, giving an explicit coherence time Ï„<sub>c</sub> proportional to 1/Î”Î½.
          If you assume a <strong>rectangular</strong> spectrum in Î½, Î³(Ï„) becomes a sinc function with first zero at Ï„ = 1/Î”Î½.
          Both confirm the same scaling, differing only by numerical constants.
        </p>

        <h3>Concept checks (with answers)</h3>
        <ul>
          <li><strong>Q:</strong> Why canâ€™t we generally say l<sub>c</sub> ~ 1/Î”Î»?<br><strong>A:</strong> Because Î”Î» is not conjugate to delay; phase depends on 1/Î» (or Î½), so you need Î”Î½ or Î”(1/Î»).</li>
          <li><strong>Q:</strong> What happens to l<sub>c</sub> as linewidth goes to zero?<br><strong>A:</strong> Î”Î½ â†’ 0 â‡’ Ï„<sub>c</sub> â†’ âˆ â‡’ l<sub>c</sub> â†’ âˆ (ideal monochromatic limit).</li>
          <li><strong>Q:</strong> If light is in glass (nâ‰ˆ1.5), what changes?<br><strong>A:</strong> l<sub>c</sub> in terms of physical path difference uses group velocity â‰ˆ c/n, so l<sub>c</sub> scales down by ~1/n for the same Ï„<sub>c</sub>.</li>
        </ul>
      </section>

      <section id="part5">
        <h2>PART 5 â€” Visualization Guide (How to Read the Plots)</h2>
        <div class="grid2">
          <div class="callout">
            <strong>Diagram canvas</strong>
            <p class="muted">
              Shows a Michelson-type interferometer. The adjustable arm creates a path difference Î”L.
              Visibility of fringes depends on |Î³(Î”L/c)|. When Î”L â‰« l<sub>c</sub>, fringes vanish.
            </p>
          </div>
          <div class="callout">
            <strong>Main plot canvas</strong>
            <p class="muted">
              Plots the magnitude of the complex degree of coherence |Î³(Î”L)| versus path difference Î”L (example units).
              A vertical line marks the estimated coherence length scale (from Î»<sup>2</sup>/Î”Î» or 1/Î”Ïƒ).
            </p>
          </div>
        </div>

        <div class="grid2">
          <div class="callout">
            <strong>Secondary (parameter sweep) canvas</strong>
            <p class="muted">
              Displays how the estimated coherence length changes as you sweep the control parameter:
              Î”Î» for narrowband, or r = Î»<sub>max</sub>/Î»<sub>min</sub> for broadband.
              A highlighted marker shows your current setting.
            </p>
          </div>
          <div class="callout assump">
            <strong>Interactive controls</strong>
            <p class="muted">
              Use the dropdown to choose spectrum type. The slider then changes a meaningful parameter and updates:
              (1) the interferometer diagram labels, (2) the main coherence plot, and (3) the parameter sweep plot.
            </p>
          </div>
        </div>
      </section>

      <section id="viz">
        <h2>Interactive Visualizations</h2>

        <div class="vizCard">
          <div class="controls">
            <div class="controlRow" role="group" aria-label="Spectrum controls">
              <div style="min-width:240px; flex:1;">
                <label for="modeSel"><strong>Spectrum model</strong></label><br/>
                <select id="modeSel">
                  <option value="narrow">Narrow Gaussian spectrum (centered at Î»0)</option>
                  <option value="broad">Broad uniform spectrum in Î» (Î»min to Î»max)</option>
                </select>
              </div>

              <div class="controlInline" style="flex:2;">
                <label id="sliderLabel" for="paramSlider"><strong>Î”Î» (FWHM)</strong></label>
                <input id="paramSlider" type="range" min="0" max="1000" value="200" step="1" />
                <div class="readout" id="sliderReadout"></div>
              </div>
            </div>

            <div class="controlRow" aria-label="Example constants readout">
              <div class="kpi" style="flex:1;">
                <div class="label" id="const1Label">Example Î»0</div>
                <div class="value" id="const1Val"></div>
              </div>
              <div class="kpi" style="flex:1;">
                <div class="label">Estimated l<sub>c</sub></div>
                <div class="value" id="lcVal"></div>
              </div>
              <div class="kpi" style="flex:1;">
                <div class="label" id="const2Label">Bandwidth variable</div>
                <div class="value" id="bwVal"></div>
              </div>
            </div>
          </div>

          <div class="grid2" style="margin-top:12px;">
            <div class="smallCanvas">
              <canvas id="diagCanvas" aria-label="Interferometer diagram"></canvas>
            </div>
            <div class="smallCanvas">
              <canvas id="mainCanvas" aria-label="Main coherence plot"></canvas>
            </div>
          </div>

          <div style="margin-top:12px;">
            <canvas id="sweepCanvas" aria-label="Parameter sweep plot"></canvas>
          </div>

          <p class="muted" style="margin-top:10px;">
            Plots use <strong>example values</strong> (displayed above) to visualize the scaling. The derived results in the text remain symbolic.
          </p>
        </div>
      </section>

      <footer class="foot">
        <div>
          Built with vanilla HTML/CSS/JS. Coherence length is shown as a characteristic scale (order-unity differences depend on the chosen definition and spectral shape).
        </div>
      </footer>
    </article>
  </main>

  <script>
    // ---------- Copy buttons ----------
    (function(){
      const btns = document.querySelectorAll('button.copy');
      btns.forEach(b=>{
        b.addEventListener('click', async ()=>{
          const id = b.getAttribute('data-copy');
          const el = document.getElementById(id);
          const text = el ? el.textContent : '';
          try{
            await navigator.clipboard.writeText(text.trim());
            const old = b.textContent;
            b.textContent = 'Copied âœ“';
            setTimeout(()=>b.textContent = old, 900);
          }catch(e){
            // fallback
            const ta = document.createElement('textarea');
            ta.value = text.trim();
            document.body.appendChild(ta);
            ta.select();
            try{ document.execCommand('copy'); }catch(_){}
            document.body.removeChild(ta);
            const old = b.textContent;
            b.textContent = 'Copied âœ“';
            setTimeout(()=>b.textContent = old, 900);
          }
        });
      });
    })();

    // ---------- Canvas helpers (HiDPI + axes) ----------
    function setupCanvas(canvas){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect.width * dpr));
      const h = Math.max(2, Math.floor(rect.height * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {ctx, w: rect.width, h: rect.height, dpr};
    }

    function clear(ctx, w, h){
      ctx.clearRect(0,0,w,h);
    }

    function roundRect(ctx, x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    function drawPanel(ctx, w, h){
      // subtle panel background
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.fillStyle = 'rgba(0,0,0,0.10)';
      roundRect(ctx, 0.5, 0.5, w-1, h-1, 14);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    }

    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title, opts={}){
      const {x, y, w, h} = box;
      const gridAlpha = opts.gridAlpha ?? 0.10;
      const axisAlpha = opts.axisAlpha ?? 0.35;
      const tickCountX = opts.tickCountX ?? 6;
      const tickCountY = opts.tickCountY ?? 5;

      // Title
      ctx.save();
      ctx.fillStyle = 'rgba(230,237,247,0.95)';
      ctx.font = '600 14px ui-sans-serif, system-ui';
      ctx.fillText(title, x, y-10);
      ctx.restore();

      // Grid + frame
      ctx.save();
      ctx.strokeStyle = `rgba(255,255,255,${gridAlpha})`;
      ctx.lineWidth = 1;

      for(let i=0;i<=tickCountX;i++){
        const t = i/tickCountX;
        const xx = x + t*w;
        ctx.beginPath();
        ctx.moveTo(xx, y);
        ctx.lineTo(xx, y+h);
        ctx.stroke();
      }
      for(let j=0;j<=tickCountY;j++){
        const t = j/tickCountY;
        const yy = y + (1-t)*h;
        ctx.beginPath();
        ctx.moveTo(x, yy);
        ctx.lineTo(x+w, yy);
        ctx.stroke();
      }

      ctx.strokeStyle = `rgba(255,255,255,${axisAlpha})`;
      ctx.lineWidth = 1.2;
      ctx.strokeRect(x, y, w, h);
      ctx.restore();

      // Ticks & labels
      ctx.save();
      ctx.fillStyle = 'rgba(168,179,199,0.95)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

      // x ticks
      for(let i=0;i<=tickCountX;i++){
        const t = i/tickCountX;
        const xx = x + t*w;
        const val = xMin + t*(xMax-xMin);
        const txt = formatTick(val);
        ctx.fillText(txt, xx-ctx.measureText(txt).width/2, y+h+16);
      }
      // y ticks
      for(let j=0;j<=tickCountY;j++){
        const t = j/tickCountY;
        const yy = y + (1-t)*h;
        const val = yMin + t*(yMax-yMin);
        const txt = formatTick(val);
        ctx.fillText(txt, x-8-ctx.measureText(txt).width, yy+4);
      }

      // Axis labels
      ctx.fillStyle = 'rgba(230,237,247,0.92)';
      ctx.font = '600 12px ui-sans-serif, system-ui';
      ctx.fillText(xLabel, x + w - ctx.measureText(xLabel).width, y + h + 34);

      // rotated y label
      ctx.save();
      ctx.translate(x-46, y + h/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
      ctx.restore();

      ctx.restore();

      const xMap = (X)=> x + (X-xMin)/(xMax-xMin)*w;
      const yMap = (Y)=> y + (1-(Y-yMin)/(yMax-yMin))*h;
      return {xMap, yMap};
    }

    function formatTick(v){
      const av = Math.abs(v);
      if(av === 0) return '0';
      if(av >= 1000) return (v/1000).toFixed(1)+'k';
      if(av >= 100) return v.toFixed(0);
      if(av >= 10) return v.toFixed(1);
      if(av >= 1) return v.toFixed(2);
      return v.toFixed(3);
    }

    function drawLine(ctx, pts, strokeStyle, lineWidth=2){
      if(pts.length < 2) return;
      ctx.save();
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = lineWidth;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();
      ctx.restore();
    }

    function drawVLine(ctx, x, y0, y1, style, label){
      ctx.save();
      ctx.strokeStyle = style;
      ctx.lineWidth = 2;
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(x, y0);
      ctx.lineTo(x, y1);
      ctx.stroke();
      ctx.setLineDash([]);
      if(label){
        ctx.fillStyle = style;
        ctx.font = '600 12px ui-sans-serif, system-ui';
        ctx.fillText(label, x+6, y0+14);
      }
      ctx.restore();
    }

    // ---------- Physics numerics for plots ----------
    const c = 299792458;

    function gaussian(x, mu, sigma){
      const z = (x-mu)/sigma;
      return Math.exp(-0.5*z*z);
    }

    // Compute normalized gamma(Î”L) = âˆ« S(Î») e^{i 2Ï€ Î”L/Î»} dÎ» / âˆ« S(Î») dÎ»
    // using discrete sampling in Î» for visualization.
    function computeGammaLambda(deltaLArray, spectrumFn, lambdaMin, lambdaMax, nSamples=2400){
      const dLam = (lambdaMax - lambdaMin)/(nSamples-1);
      const lambdas = new Float64Array(nSamples);
      const weights = new Float64Array(nSamples);

      let norm = 0;
      for(let i=0;i<nSamples;i++){
        const lam = lambdaMin + i*dLam;
        const s = spectrumFn(lam);
        lambdas[i] = lam;
        weights[i] = s;
        norm += s;
      }
      norm *= dLam;

      const outAbs = new Float64Array(deltaLArray.length);
      for(let j=0;j<deltaLArray.length;j++){
        const DL = deltaLArray[j];
        let re = 0, im = 0;
        for(let i=0;i<nSamples;i++){
          const lam = lambdas[i];
          const s = weights[i];
          const phase = 2*Math.PI*DL/lam;
          re += s*Math.cos(phase);
          im += s*Math.sin(phase);
        }
        re *= dLam; im *= dLam;
        re /= norm; im /= norm;
        outAbs[j] = Math.hypot(re, im);
      }
      return outAbs;
    }

    function argMinAbsDiff(arr, target){
      let best = 0, bestd = Infinity;
      for(let i=0;i<arr.length;i++){
        const d = Math.abs(arr[i]-target);
        if(d < bestd){bestd=d; best=i;}
      }
      return best;
    }

    // Estimate coherence length from computed |gamma| curve via 1/e criterion
    function coherenceFromCurve(deltaLArray, gammaAbs){
      const thresh = 1/Math.E;
      // find first crossing below threshold
      for(let i=1;i<gammaAbs.length;i++){
        if(gammaAbs[i] <= thresh){
          // linear interpolate
          const x0 = deltaLArray[i-1], x1 = deltaLArray[i];
          const y0 = gammaAbs[i-1], y1 = gammaAbs[i];
          const t = (thresh - y0)/(y1 - y0);
          return x0 + t*(x1-x0);
        }
      }
      return deltaLArray[deltaLArray.length-1];
    }

    // ---------- State + UI ----------
    const modeSel = document.getElementById('modeSel');
    const slider = document.getElementById('paramSlider');
    const sliderLabel = document.getElementById('sliderLabel');
    const sliderReadout = document.getElementById('sliderReadout');

    const const1Label = document.getElementById('const1Label');
    const const1Val = document.getElementById('const1Val');
    const const2Label = document.getElementById('const2Label');
    const bwVal = document.getElementById('bwVal');
    const lcVal = document.getElementById('lcVal');

    const diagCanvas = document.getElementById('diagCanvas');
    const mainCanvas = document.getElementById('mainCanvas');
    const sweepCanvas = document.getElementById('sweepCanvas');

    // Example values (kept consistent with text & plots)
    const ex = {
      lambda0_nm: 632.8,  // example HeNe-like center for narrowband plots
      lambdaMin_nm: 450,  // example lower bound for broadband plots
    };

    function setModeUI(){
      const mode = modeSel.value;
      if(mode === 'narrow'){
        // slider represents Î”Î»_FWHM in nm
        slider.min = 1;
        slider.max = 10_000; // 0.001 to 10 nm via scale below
        slider.value = 400;  // default
        sliderLabel.textContent = 'Î”Î» (FWHM) â€” narrowband';
        const1Label.textContent = 'Example Î»0';
        const2Label.textContent = 'Approx. Î”Î½';
      }else{
        // slider represents ratio r = Î»max/Î»min from 1.1 to 3.0
        slider.min = 110;
        slider.max = 300;
        slider.value = 200; // corresponds to r=2
        sliderLabel.textContent = 'r = Î»max/Î»min â€” broadband';
        const1Label.textContent = 'Example Î»min';
        const2Label.textContent = 'Î”Ïƒ = 1/Î»min âˆ’ 1/Î»max';
      }
    }

    function nmToM(xnm){ return xnm*1e-9; }
    function mToNm(xm){ return xm*1e9; }

    // Map slider to actual parameter
    function getParams(){
      const mode = modeSel.value;
      if(mode === 'narrow'){
        // logarithmic-ish scale for Î”Î»: value in [1..10000] -> Î”Î» in [0.001..10] nm
        const t = (slider.value - slider.min) / (slider.max - slider.min);
        const dlam_nm = 0.001 * Math.pow(10, 4*t); // 0.001 * 10^(0..4) => 0.001..10
        const lambda0 = nmToM(ex.lambda0_nm);
        const dlam = nmToM(dlam_nm);
        return {mode, lambda0, dlam, dlam_nm};
      }else{
        const r = slider.value/100;
        const lambdaMin = nmToM(ex.lambdaMin_nm);
        const lambdaMax = r*lambdaMin;
        return {mode, r, lambdaMin, lambdaMax};
      }
    }

    // ---------- Drawing: interferometer diagram ----------
    function drawDiagram(params){
      const {ctx, w, h} = setupCanvas(diagCanvas);
      clear(ctx, w, h);
      drawPanel(ctx, w, h);

      // coordinates in CSS pixels
      const pad = 16;
      const cx = pad, cy = pad, cw = w - 2*pad, ch = h - 2*pad;

      // Title
      ctx.save();
      ctx.fillStyle = 'rgba(230,237,247,0.95)';
      ctx.font = '600 14px ui-sans-serif, system-ui';
      ctx.fillText('Diagram: Two-beam interferometer and path difference Î”L', cx, cy+2);
      ctx.restore();

      const x0 = cx + 22, y0 = cy + 46;
      const x1 = cx + cw - 22, y1 = cy + ch - 18;

      // Draw beamsplitter at center
      const bsx = (x0 + x1)*0.48;
      const bsy = (y0 + y1)*0.52;

      // Source and detector
      const sx = x0 + 20, sy = bsy;
      const dx = x1 - 40, dy = bsy;

      ctx.save();
      ctx.strokeStyle = 'rgba(125,211,252,0.85)';
      ctx.lineWidth = 2;

      // incoming beam
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(bsx-22, bsy);
      ctx.stroke();

      // beamsplitter (diagonal)
      ctx.strokeStyle = 'rgba(255,255,255,0.55)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(bsx-12, bsy+12);
      ctx.lineTo(bsx+12, bsy-12);
      ctx.stroke();

      // Arms
      ctx.strokeStyle = 'rgba(196,181,253,0.85)';
      ctx.lineWidth = 2;

      // upper arm
      const m1x = bsx, m1y = y0 + 30;
      ctx.beginPath();
      ctx.moveTo(bsx, bsy);
      ctx.lineTo(m1x, m1y);
      ctx.stroke();

      // lower arm
      const m2x = bsx, m2y = y1 - 24;
      ctx.beginPath();
      ctx.moveTo(bsx, bsy);
      ctx.lineTo(m2x, m2y);
      ctx.stroke();

      // return beams to detector
      ctx.strokeStyle = 'rgba(125,211,252,0.85)';
      ctx.beginPath();
      ctx.moveTo(bsx+10, bsy);
      ctx.lineTo(dx, dy);
      ctx.stroke();

      // Mirrors
      function mirror(x,y,hor=true){
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.65)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        if(hor){
          ctx.moveTo(x-16, y);
          ctx.lineTo(x+16, y);
        }else{
          ctx.moveTo(x, y-16);
          ctx.lineTo(x, y+16);
        }
        ctx.stroke();
        ctx.restore();
      }
      mirror(m1x, m1y, true);
      mirror(m2x, m2y, true);

      // Source icon
      ctx.save();
      ctx.fillStyle = 'rgba(251,191,36,0.85)';
      ctx.beginPath();
      ctx.arc(sx-12, sy, 6, 0, 2*Math.PI);
      ctx.fill();
      ctx.fillStyle = 'rgba(230,237,247,0.92)';
      ctx.font = '600 12px ui-sans-serif, system-ui';
      ctx.fillText('Source', sx-6, sy-10);
      ctx.restore();

      // Detector icon
      ctx.save();
      ctx.strokeStyle = 'rgba(134,239,172,0.85)';
      ctx.lineWidth = 3;
      ctx.strokeRect(dx-10, dy-10, 20, 20);
      ctx.fillStyle = 'rgba(230,237,247,0.92)';
      ctx.font = '600 12px ui-sans-serif, system-ui';
      ctx.fillText('Detector', dx-28, dy-16);
      ctx.restore();

      // Labels: Î”L and lc estimate
      ctx.save();
      ctx.fillStyle = 'rgba(168,179,199,0.95)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

      let lc_m = params.lc_est_m;
      let lc_txt;
      if(lc_m >= 1e-3) lc_txt = (lc_m*1e3).toFixed(2) + ' mm';
      else if(lc_m >= 1e-6) lc_txt = (lc_m*1e6).toFixed(2) + ' Î¼m';
      else lc_txt = (lc_m*1e9).toFixed(2) + ' nm';

      ctx.fillText('Path difference: Î”L = |L1 âˆ’ L2|', x0, y1-28);
      ctx.fillText('Fringes fade when Î”L â‰³ lc', x0, y1-12);
      ctx.fillStyle = 'rgba(134,239,172,0.92)';
      ctx.fillText('Estimated lc â‰ˆ ' + lc_txt, x0, y1-44);
      ctx.restore();

      // Draw a small bracket indicating Î”L on lower arm
      ctx.save();
      ctx.strokeStyle = 'rgba(134,239,172,0.75)';
      ctx.lineWidth = 2;
      const bx = bsx + 46;
      const by0 = m1y + 12, by1 = m2y - 12;
      ctx.beginPath();
      ctx.moveTo(bx, by0);
      ctx.lineTo(bx, by1);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(bx-10, by0);
      ctx.lineTo(bx+10, by0);
      ctx.moveTo(bx-10, by1);
      ctx.lineTo(bx+10, by1);
      ctx.stroke();
      ctx.fillStyle = 'rgba(134,239,172,0.92)';
      ctx.font = '600 12px ui-sans-serif, system-ui';
      ctx.fillText('Î”L', bx+12, (by0+by1)/2+4);
      ctx.restore();

      ctx.restore();
    }

    // ---------- Drawing: main coherence plot ----------
    function drawMainPlot(params){
      const {ctx, w, h} = setupCanvas(mainCanvas);
      clear(ctx, w, h);
      drawPanel(ctx, w, h);

      const padL=54, padR=18, padT=44, padB=46;
      const box = {x:padL, y:padT, w:w-padL-padR, h:h-padT-padB};

      // Set Î”L range based on lc estimate for visibility
      const lc = params.lc_est_m;
      const xMax = Math.max(3*lc, 2e-3); // at least 2 mm in range to see something
      const xMin = 0;
      const yMin = 0;
      const yMax = 1.05;

      const title = '|Î³(Î”L)| vs path difference Î”L (example numerical integral)';
      const axes = drawAxes(ctx, box, xMin*1e3, xMax*1e3, yMin, yMax, 'Î”L (mm)', '|Î³|', title, {tickCountX:6, tickCountY:5});

      // Build Î”L array in meters
      const N = 240;
      const deltaLArray = new Float64Array(N);
      for(let i=0;i<N;i++){
        const t = i/(N-1);
        deltaLArray[i] = xMin + t*(xMax-xMin);
      }

      // Spectrum setup
      let gammaAbs;
      if(params.mode === 'narrow'){
        const lambda0 = params.lambda0;
        const dlam = params.dlam;
        // Convert FWHM to sigma (standard deviation) for Gaussian in Î» for the plot
        const sigma = dlam / (2*Math.sqrt(2*Math.log(2)));
        const lambdaMin = lambda0 - 7*sigma;
        const lambdaMax = lambda0 + 7*sigma;
        const spec = (lam)=> gaussian(lam, lambda0, sigma);
        gammaAbs = computeGammaLambda(deltaLArray, spec, lambdaMin, lambdaMax, 2400);
      }else{
        const lambdaMin = params.lambdaMin;
        const lambdaMax = params.lambdaMax;
        const spec = (_lam)=> 1.0; // uniform in Î»
        gammaAbs = computeGammaLambda(deltaLArray, spec, lambdaMin, lambdaMax, 2400);
      }

      // Draw curve
      const pts = [];
      for(let i=0;i<N;i++){
        const x_mm = deltaLArray[i]*1e3;
        const y = gammaAbs[i];
        pts.push({x: axes.xMap(x_mm), y: axes.yMap(y)});
      }
      drawLine(ctx, pts, 'rgba(125,211,252,0.95)', 2.4);

      // Estimated lc vertical line
      const lc_mm = lc*1e3;
      const xlc = axes.xMap(lc_mm);
      drawVLine(ctx, xlc, box.y, box.y+box.h, 'rgba(134,239,172,0.9)', 'lc (estimate)');

      // Optional: numeric 1/e coherence from curve
      const lc_num = coherenceFromCurve(deltaLArray, gammaAbs);
      const lcnum_mm = lc_num*1e3;
      const xlcnum = axes.xMap(lcnum_mm);
      drawVLine(ctx, xlcnum, box.y, box.y+box.h, 'rgba(196,181,253,0.95)', 'lc (1/e)');

      // Legend
      ctx.save();
      ctx.fillStyle = 'rgba(230,237,247,0.92)';
      ctx.font = '600 12px ui-sans-serif, system-ui';
      const lx = box.x + 10, ly = box.y + 10;
      ctx.fillText('Legend:', lx, ly);
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.fillStyle = 'rgba(125,211,252,0.95)';
      ctx.fillText('â€” |Î³(Î”L)| (numerical)', lx, ly+18);
      ctx.fillStyle = 'rgba(134,239,172,0.95)';
      ctx.fillText('â‹¯ lc estimate', lx, ly+34);
      ctx.fillStyle = 'rgba(196,181,253,0.95)';
      ctx.fillText('â‹¯ lc (1/e from curve)', lx, ly+50);
      ctx.restore();
    }

    // ---------- Drawing: parameter sweep plot ----------
    function drawSweepPlot(params){
      const {ctx, w, h} = setupCanvas(sweepCanvas);
      clear(ctx, w, h);
      drawPanel(ctx, w, h);

      const padL=64, padR=18, padT=44, padB=50;
      const box = {x:padL, y:padT, w:w-padL-padR, h:h-padT-padB};

      if(params.mode === 'narrow'){
        // Sweep Î”Î» from 0.001 to 10 nm, plot lc_est = Î»0^2/Î”Î»
        const lambda0 = nmToM(ex.lambda0_nm);
        const n = 220;
        const xMin = 0.001, xMax = 10; // nm
        const yMin = 0, yMax = 200; // mm (cap for visualization)
        const axes = drawAxes(ctx, box, xMin, xMax, yMin, yMax, 'Î”Î» (nm)', 'lc estimate (mm)', 'Sweep: lc â‰ˆ Î»0Â²/Î”Î» (example Î»0)', {tickCountX:6, tickCountY:5});

        const pts = [];
        for(let i=0;i<n;i++){
          const t = i/(n-1);
          // Log spacing in x
          const x = xMin * Math.pow(xMax/xMin, t);
          const lc = (lambda0*lambda0) / nmToM(x); // meters
          const lc_mm = Math.min(lc*1e3, yMax);
          pts.push({x: axes.xMap(x), y: axes.yMap(lc_mm)});
        }
        drawLine(ctx, pts, 'rgba(196,181,253,0.95)', 2.2);

        // Mark current point
        const xCur = params.dlam_nm;
        const lcCur_mm = Math.min(params.lc_est_m*1e3, yMax);
        const px = axes.xMap(xCur);
        const py = axes.yMap(lcCur_mm);
        ctx.save();
        ctx.fillStyle = 'rgba(134,239,172,0.95)';
        ctx.beginPath(); ctx.arc(px, py, 5, 0, 2*Math.PI); ctx.fill();
        ctx.fillStyle = 'rgba(230,237,247,0.92)';
        ctx.font = '12px ui-sans-serif, system-ui';
        ctx.fillText('current', px+8, py-8);
        ctx.restore();

        // Note about cap
        ctx.save();
        ctx.fillStyle = 'rgba(168,179,199,0.9)';
        ctx.font = '12px ui-sans-serif, system-ui';
        ctx.fillText('Note: y-axis capped for readability', box.x, box.y+box.h+40);
        ctx.restore();
      }else{
        // Sweep r from 1.1 to 3.0, plot lc_est = 1/Î”Ïƒ = 1 / (1/Î»min - 1/(r Î»min)) = (r/(r-1)) Î»min
        const lambdaMin = nmToM(ex.lambdaMin_nm);
        const n = 220;
        const rMin = 1.1, rMax = 3.0;
        const yMin = 0, yMax = 5; // mm
        const axes = drawAxes(ctx, box, rMin, rMax, yMin, yMax, 'r = Î»max/Î»min', 'lc estimate (mm)', 'Sweep: lc â‰ˆ 1/Î”Ïƒ (example Î»min)', {tickCountX:6, tickCountY:5});

        const pts = [];
        for(let i=0;i<n;i++){
          const t = i/(n-1);
          const r = rMin + t*(rMax-rMin);
          const lc = (r/(r-1))*lambdaMin; // meters
          const lc_mm = Math.min(lc*1e3, yMax);
          pts.push({x: axes.xMap(r), y: axes.yMap(lc_mm)});
        }
        drawLine(ctx, pts, 'rgba(196,181,253,0.95)', 2.2);

        // Mark current
        const rCur = params.r;
        const lcCur_mm = Math.min(params.lc_est_m*1e3, yMax);
        const px = axes.xMap(rCur);
        const py = axes.yMap(lcCur_mm);
        ctx.save();
        ctx.fillStyle = 'rgba(134,239,172,0.95)';
        ctx.beginPath(); ctx.arc(px, py, 5, 0, 2*Math.PI); ctx.fill();
        ctx.fillStyle = 'rgba(230,237,247,0.92)';
        ctx.font = '12px ui-sans-serif, system-ui';
        ctx.fillText('current', px+8, py-8);
        ctx.restore();

        ctx.save();
        ctx.fillStyle = 'rgba(168,179,199,0.9)';
        ctx.font = '12px ui-sans-serif, system-ui';
        ctx.fillText('For r=2 (Î»max=2Î»min), lc = Î»max exactly from this estimate', box.x, box.y+box.h+40);
        ctx.restore();
      }
    }

    // ---------- Update readouts + compute estimates ----------
    function formatLength(m){
      if(m >= 1) return m.toFixed(3)+' m';
      if(m >= 1e-3) return (m*1e3).toFixed(3)+' mm';
      if(m >= 1e-6) return (m*1e6).toFixed(3)+' Î¼m';
      return (m*1e9).toFixed(3)+' nm';
    }
    function formatFreq(Hz){
      const a = Math.abs(Hz);
      if(a >= 1e12) return (Hz/1e12).toFixed(3)+' THz';
      if(a >= 1e9) return (Hz/1e9).toFixed(3)+' GHz';
      if(a >= 1e6) return (Hz/1e6).toFixed(3)+' MHz';
      if(a >= 1e3) return (Hz/1e3).toFixed(3)+' kHz';
      return Hz.toFixed(3)+' Hz';
    }
    function formatInvM(x){
      if(Math.abs(x) >= 1e6) return (x/1e6).toFixed(3)+' Ã—10^6 mâ»Â¹';
      if(Math.abs(x) >= 1e3) return (x/1e3).toFixed(3)+' Ã—10^3 mâ»Â¹';
      return x.toFixed(3)+' mâ»Â¹';
    }

    function update(){
      const p0 = getParams();
      let lc_est_m, bwText, constText1, sliderText;

      if(p0.mode === 'narrow'){
        const lambda0 = p0.lambda0;
        const dlam = p0.dlam;
        // Estimate: lc â‰ˆ Î»0^2/Î”Î»
        lc_est_m = (lambda0*lambda0)/dlam;

        // Also show approximate Î”Î½
        const dnu = (c/(lambda0*lambda0))*dlam;
        bwText = 'Î”Î½ â‰ˆ (c/Î»0Â²)Î”Î» = ' + formatFreq(dnu);

        constText1 = ex.lambda0_nm.toFixed(1) + ' nm';
        sliderText = p0.dlam_nm.toFixed(4) + ' nm';
      }else{
        const lambdaMin = p0.lambdaMin;
        const lambdaMax = p0.lambdaMax;
        // Estimate: lc â‰ˆ 1/Î”Ïƒ where Î”Ïƒ = 1/Î»min - 1/Î»max
        const deltaSigma = (1/lambdaMin) - (1/lambdaMax);
        lc_est_m = 1/deltaSigma;

        bwText = 'Î”Ïƒ = ' + formatInvM(deltaSigma);
        constText1 = ex.lambdaMin_nm.toFixed(0) + ' nm';
        sliderText = p0.r.toFixed(2) + '  (Î»max=' + (ex.lambdaMin_nm*p0.r).toFixed(0) + ' nm)';
      }

      // Update readouts
      sliderReadout.textContent = sliderText;
      const1Val.textContent = constText1;
      bwVal.textContent = bwText;
      lcVal.textContent = formatLength(lc_est_m);

      // Store expanded params for drawing
      const params = Object.assign({}, p0, {lc_est_m});

      // Also update labels under constants for broadband
      if(params.mode === 'narrow'){
        const2Label.textContent = 'Approx. Î”Î½';
      }else{
        const2Label.textContent = 'Î”Ïƒ = 1/Î»min âˆ’ 1/Î»max';
      }

      // Draw all canvases
      drawDiagram(params);
      drawMainPlot(params);
      drawSweepPlot(params);
    }

    // ---------- Resize handling ----------
    let resizeTimer = null;
    function scheduleResize(){
      if(resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(()=>update(), 60);
    }
    window.addEventListener('resize', scheduleResize);

    // ---------- Init ----------
    modeSel.addEventListener('change', ()=>{
      setModeUI();
      update();
    });
    slider.addEventListener('input', update);

    setModeUI();
    update();
  </script>
</body>
</html>
