<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Effect of Spectral Width on Spatial Coherence (Lorentzian Spectrum)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101a33;
      --panel2:#0f1730;
      --text:#e9eefc;
      --muted:#a9b4d6;
      --accent:#7aa2ff;
      --accent2:#7cffc7;
      --warn:#ffcc66;
      --bad:#ff6b7a;
      --ok:#7cffc7;
      --grid:rgba(255,255,255,.08);
      --border:rgba(255,255,255,.12);
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 900px at 20% 10%, rgba(122,162,255,.18), transparent 60%),
                  radial-gradient(1200px 900px at 80% 30%, rgba(124,255,199,.12), transparent 55%),
                  var(--bg);
      color:var(--text);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:28px 18px 10px;
      max-width:1200px;
      margin:0 auto;
    }
    .titlebar{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
      padding:18px 18px 20px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .titlebar:before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(700px 200px at 20% 0%, rgba(122,162,255,.25), transparent 55%),
                  radial-gradient(700px 220px at 80% 0%, rgba(124,255,199,.18), transparent 55%);
      pointer-events:none;
      opacity:.8;
    }
    .titlebar > *{position:relative}
    h1{
      margin:0;
      font-size: clamp(1.55rem, 2.2vw, 2.2rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      max-width: 80ch;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding: 10px 18px 60px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:16px;
      align-items:start;
    }

    nav.toc{
      position:sticky;
      top:14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:14px 14px 10px;
    }
    .toc h2{
      font-size:1rem;
      margin:0 0 8px 0;
      color: var(--text);
      letter-spacing:.3px;
    }
    .toc a{
      display:block;
      padding:8px 10px;
      border-radius: 12px;
      color: var(--muted);
      font-size:.95rem;
      border:1px solid transparent;
      transition: .2s ease;
    }
    .toc a:hover{
      background: rgba(122,162,255,.12);
      border-color: rgba(122,162,255,.22);
      color: var(--text);
      text-decoration:none;
    }

    article{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px;
      overflow:hidden;
    }

    section{padding: 6px 0 6px}
    section + section{border-top:1px dashed rgba(255,255,255,.10); margin-top:12px}
    h2{
      margin: 10px 0 6px;
      font-size: 1.25rem;
      letter-spacing:.2px;
    }
    h3{
      margin: 12px 0 6px;
      font-size: 1.05rem;
      color: var(--text);
    }
    p{margin: 8px 0; color: var(--text)}
    ul{margin: 8px 0 8px 18px}
    li{margin: 6px 0; color: var(--text)}
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
      nav.toc{position:relative; top:auto}
      .grid2{grid-template-columns: 1fr}
    }

    .card{
      background: rgba(16,26,51,.65);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 12px 12px 10px;
    }
    .callout{
      border-left: 4px solid var(--accent);
      padding: 12px 12px 12px 12px;
      border-radius: 14px;
      background: rgba(122,162,255,.10);
      border:1px solid rgba(122,162,255,.22);
    }
    .callout.warn{
      border-left-color: var(--warn);
      background: rgba(255,204,102,.10);
      border-color: rgba(255,204,102,.22);
    }
    .callout.bad{
      border-left-color: var(--bad);
      background: rgba(255,107,122,.10);
      border-color: rgba(255,107,122,.22);
    }
    .eqbox{
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding: 12px;
      margin: 10px 0;
      overflow:auto;
    }
    .eq{
      font-family: var(--mono);
      font-size: .95rem;
      white-space: pre;
      line-height:1.45;
      color: #f3f6ff;
      margin:0;
    }
    .copybtn{
      flex: 0 0 auto;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 12px;
      cursor:pointer;
      transition:.15s ease;
      font-weight:600;
      font-size:.85rem;
    }
    .copybtn:hover{transform: translateY(-1px); border-color: rgba(122,162,255,.35)}
    .copybtn:active{transform: translateY(0px)}
    .pillrow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top: 8px;
    }
    .pill{
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(124,255,199,.10);
      border:1px solid rgba(124,255,199,.22);
      color: var(--text);
      font-size:.85rem;
      font-family: var(--mono);
    }

    figure{
      margin: 10px 0 0;
    }
    .vizwrap{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:12px;
      align-items:stretch;
    }
    .vizwrap .card{padding: 10px}
    @media (max-width: 980px){
      .vizwrap{grid-template-columns: 1fr}
    }

    canvas{
      width:100%;
      height: 320px;
      display:block;
      border-radius: 14px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
    }
    .small canvas{height: 270px}
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 640px){
      .controls{grid-template-columns: 1fr}
    }
    label{
      display:block;
      font-size:.88rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    input[type="range"]{width:100%}
    .readout{
      font-family: var(--mono);
      font-size:.92rem;
      color: var(--text);
      margin-top: 4px;
    }
    .btnrow{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
    .btn{
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 9px 12px;
      border-radius: 12px;
      cursor:pointer;
      transition:.15s ease;
      font-weight:700;
      font-size:.9rem;
    }
    .btn:hover{transform: translateY(-1px); border-color: rgba(124,255,199,.35)}
    .btn:active{transform: translateY(0px)}
    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 0 18px 30px;
      color: var(--muted);
      font-size:.95rem;
    }

    /* subtle motion */
    @media (prefers-reduced-motion: no-preference){
      .titlebar, nav.toc, article{animation: floatIn .45s ease both}
      @keyframes floatIn{
        from{opacity:0; transform: translateY(8px)}
        to{opacity:1; transform: translateY(0)}
      }
    }

    /* print */
    @media print{
      body{background:#fff; color:#000}
      nav.toc{display:none}
      header, main, footer{max-width: 100%}
      article, .titlebar{box-shadow:none; border:1px solid #ccc; background:#fff}
      .eqbox{background:#f7f7f7}
      canvas{border:1px solid #bbb}
      .copybtn, .btn{display:none}
    }
  </style>
</head>
<body>
  <header>
    <div class="titlebar">
      <h1>Effect of Spectral Width on Spatial Coherence (Lorentzian Source)</h1>
      <p class="subtitle">
        A point source emits light with a Lorentzian spectrum and coherence time <span class="pill">Ï„<sub>c</sub> = 10 ps</span>.
        We compute the <em>normalized mutual intensity</em> between two observation points at the same plane <span class="pill">z = d</span>,
        separated laterally by <span class="pill">x</span>, and visualize how spectral width limits spatial coherence.
      </p>
      <div class="pillrow">
        <span class="pill">d = 10 cm</span>
        <span class="pill">Pâ‚ = (0,0,d)</span>
        <span class="pill">Pâ‚‚ = (x,0,d)</span>
        <span class="pill">Lorentzian spectrum â†’ exponential coherence</span>
      </div>
    </div>
  </header>

  <main>
    <nav class="toc" aria-label="Table of contents">
      <h2>Table of Contents</h2>
      <a href="#quick-summary">Quick Summary</a>
      <a href="#part0">PART 0 â€” Concept Primer</a>
      <a href="#part1">PART 1 â€” Problem Analysis</a>
      <a href="#part2">PART 2 â€” Strategy &amp; Tips</a>
      <a href="#part3">PART 3 â€” Full Solution</a>
      <a href="#part4">PART 4 â€” Deeper Understanding</a>
      <a href="#part5">PART 5 â€” Visualization Guide</a>
      <a href="#visuals">Interactive Visualizations</a>
    </nav>

    <article>
      <section id="quick-summary">
        <h2>Quick Summary</h2>
        <ul>
          <li>This problem asks how a finite <strong>spectral width</strong> (Lorentzian spectrum) reduces <strong>spatial coherence</strong> between two points.</li>
          <li>Key idea: for a point source, the normalized mutual intensity between two points equals the <strong>temporal degree of coherence</strong> evaluated at the <strong>propagation time delay</strong> Î”t.</li>
          <li>Geometry sets the path lengths: <span class="muted">râ‚ = d</span>, <span class="muted">râ‚‚ = âˆš(dÂ² + xÂ²)</span>, so <span class="muted">Î”t = (râ‚‚ âˆ’ râ‚)/c</span>.</li>
          <li>Lorentzian spectrum â†’ exponential temporal coherence: <span class="muted">g(Ï„) = exp(âˆ’|Ï„|/Ï„<sub>c</sub>)Â·exp(âˆ’iÏ‰â‚€Ï„)</span>.</li>
          <li><strong>Final symbolic result</strong>: normalized mutual intensity (complex degree of coherence)
            <span class="muted">Î¼(x) = exp(âˆ’(âˆš(dÂ² + xÂ²) âˆ’ d)/(cÏ„<sub>c</sub>)) Â· exp(âˆ’ikâ‚€(âˆš(dÂ² + xÂ²) âˆ’ d))</span>.
          </li>
          <li><strong>Magnitude sketch</strong>: <span class="muted">|Î¼(x)| = exp(âˆ’(âˆš(dÂ² + xÂ²) âˆ’ d)/(cÏ„<sub>c</sub>))</span>, which for small x behaves like a Gaussian
            <span class="muted">|Î¼| â‰ˆ exp(âˆ’xÂ²/(2dcÏ„<sub>c</sub>))</span>.
          </li>
          <li>With d = 10 cm and Ï„<sub>c</sub> = 10 ps, the 1/e lateral coherence scale is about <span class="muted">x â‰ˆ 2.5 cm</span> (example numeric evaluation).</li>
        </ul>
      </section>

      <section id="part0">
        <h2>PART 0 â€” Concept Primer (Theory Before Solving)</h2>

        <div class="grid2">
          <div class="card">
            <h3>Core definitions (symbols &amp; units)</h3>
            <ul>
              <li><strong>Mutual intensity</strong> (cross-correlation of optical fields):
                <span class="muted">J(ğ«â‚,ğ«â‚‚) = âŸ¨E(ğ«â‚,t) E*(ğ«â‚‚,t)âŸ©</span> (units: fieldÂ²).
              </li>
              <li><strong>Intensity</strong> at a point:
                <span class="muted">I(ğ«) = J(ğ«,ğ«) = âŸ¨|E(ğ«,t)|Â²âŸ©</span>.
              </li>
              <li><strong>Normalized mutual intensity</strong> (also called the <em>complex degree of coherence</em>):
                <span class="muted">Î¼(ğ«â‚,ğ«â‚‚) = J(ğ«â‚,ğ«â‚‚)/âˆš(I(ğ«â‚)I(ğ«â‚‚))</span> (dimensionless), with <span class="muted">0 â‰¤ |Î¼| â‰¤ 1</span>.
              </li>
              <li><strong>Coherence time</strong> <span class="muted">Ï„<sub>c</sub></span> (seconds): characteristic time over which the field maintains phase memory.</li>
              <li><strong>Speed of light</strong> <span class="muted">c</span> (m/s), <strong>carrier frequency</strong> <span class="muted">Ï‰â‚€</span> (rad/s), <strong>wavenumber</strong> <span class="muted">kâ‚€ = Ï‰â‚€/c</span> (1/m).</li>
            </ul>
          </div>

          <div class="card">
            <h3>Physical meaning</h3>
            <p>
              Think of coherence as â€œhow well two measurements of the wave agreeâ€ after accounting for trivial factors
              like different distances. The quantity <span class="muted">|Î¼|</span> tells you how strong the interference
              fringes would be if you combined the light from ğ«â‚ and ğ«â‚‚.
            </p>
            <p class="muted">
              If |Î¼| = 1, the fields are perfectly correlated (fully coherent). If |Î¼| â‰ˆ 0, the fields have lost mutual phase information and do not produce stable interference.
            </p>
          </div>
        </div>

        <div class="callout" style="margin-top:12px">
          <h3 style="margin-top:0">Key principle: â€œDelay turns temporal coherence into spatial coherenceâ€</h3>
          <p>
            For a <strong>single point source</strong> in free space, the field at different points is essentially the same
            source field, just (i) scaled by distance and (ii) delayed by the propagation time.
            After normalization, the distance scaling cancels, leaving:
          </p>
          <div class="eqbox">
            <pre class="eq" id="eq-vcz">
Î¼(ğ«â‚,ğ«â‚‚) = g(Î”t),   Î”t = (râ‚‚ âˆ’ râ‚)/c</pre>
            <button class="copybtn" data-copy-target="eq-vcz">Copy</button>
          </div>
          <p class="muted">
            Here g(Ï„) is the normalized temporal coherence function (field autocorrelation in time).
          </p>
        </div>

        <h3>Lorentzian spectrum model (why we use it)</h3>
        <p>
          A Lorentzian optical spectrum is a common model for sources whose phase undergoes a random walk (e.g., many lasers
          with phase diffusion). A standard Lorentzian power spectrum centered at Ï‰â‚€ is:
        </p>
        <div class="eqbox">
          <pre class="eq" id="eq-lorentz">
S(Ï‰) âˆ (Î”Ï‰/2) / [ (Ï‰ âˆ’ Ï‰â‚€)Â² + (Î”Ï‰/2)Â² ]</pre>
          <button class="copybtn" data-copy-target="eq-lorentz">Copy</button>
        </div>
        <p>
          The Fourier transform of a Lorentzian is an exponential, so the temporal coherence decays exponentially:
        </p>
        <div class="eqbox">
          <pre class="eq" id="eq-g1">
g(Ï„) = exp(âˆ’|Ï„|/Ï„c) Â· exp(âˆ’i Ï‰â‚€ Ï„)
(typical Lorentzian convention: Ï„c = 2/Î”Ï‰ for a 1/e field-correlation time)</pre>
          <button class="copybtn" data-copy-target="eq-g1">Copy</button>
        </div>

        <div class="grid2">
          <div class="card">
            <h3>Mini intuition example 1</h3>
            <p>
              If two points are the same distance from the source (<span class="muted">Î”t = 0</span>), the normalized
              mutual intensity is <span class="muted">Î¼ = 1</span>. You get full interference visibility.
            </p>
          </div>
          <div class="card">
            <h3>Mini intuition example 2</h3>
            <p>
              If the path difference is <span class="muted">Î”r = cÏ„<sub>c</sub></span>, then
              <span class="muted">|Î¼| = e<sup>âˆ’1</sup></span>. That distance <span class="muted">cÏ„<sub>c</sub></span>
              is the <strong>coherence length</strong> (in the field-correlation sense).
            </p>
          </div>
        </div>

        <div class="callout warn" style="margin-top:12px">
          <h3 style="margin-top:0">What to watch for (pitfalls)</h3>
          <ul>
            <li><strong>Field vs intensity coherence:</strong> Ï„<sub>c</sub> here is tied to the <em>field</em> correlation g(Ï„), not intensity fluctuations.</li>
            <li><strong>Normalization matters:</strong> J(ğ«â‚,ğ«â‚‚) includes 1/(râ‚râ‚‚); Î¼ cancels that out.</li>
            <li><strong>Geometry is subtle:</strong> the relevant delay is from the <em>difference</em> in distances to the source, not simply x/c.</li>
            <li><strong>Phase factor:</strong> Î¼ is complex; its magnitude sets visibility, its phase sets fringe shift.</li>
          </ul>
        </div>
      </section>

      <section id="part1">
        <h2>PART 1 â€” Problem Analysis (No Solving Yet)</h2>

        <h3>Problem restatement</h3>
        <p>
          A point source at the origin emits quasi-monochromatic light whose spectrum is Lorentzian with coherence time
          <span class="muted">Ï„<sub>c</sub> = 10 ps</span>. Find the <strong>normalized mutual intensity</strong>
          between two observation points in the plane <span class="muted">z = d</span>:
          <span class="muted">Pâ‚ = (0,0,d)</span> and <span class="muted">Pâ‚‚ = (x,0,d)</span>, with
          <span class="muted">d = 10 cm</span>. Then sketch <span class="muted">|Î¼|</span> vs <span class="muted">x</span>.
        </p>

        <div class="grid2">
          <div class="card">
            <h3>Given</h3>
            <ul>
              <li>Point source at (0,0,0).</li>
              <li>Lorentzian spectrum.</li>
              <li>Coherence time: <span class="muted">Ï„<sub>c</sub> = 10 ps = 1.0Ã—10<sup>âˆ’11</sup> s</span>.</li>
              <li>Distance to observation plane: <span class="muted">d = 10 cm = 0.10 m</span>.</li>
              <li>Observation points: <span class="muted">Pâ‚=(0,0,d)</span>, <span class="muted">Pâ‚‚=(x,0,d)</span>.</li>
            </ul>
          </div>
          <div class="card">
            <h3>Unknowns / outputs</h3>
            <ul>
              <li>Expression for normalized mutual intensity: <span class="muted">Î¼(x) = Î¼(Pâ‚,Pâ‚‚)</span>.</li>
              <li>Magnitude sketch: <span class="muted">|Î¼(x)|</span> vs <span class="muted">x</span>.</li>
              <li>(Helpful) Identify coherence scale in x using the given numbers.</li>
            </ul>
          </div>
        </div>

        <h3>Relevant principles (and why they apply)</h3>
        <ul>
          <li><strong>Free-space propagation from a point source</strong>: the field at distance r is a delayed, scaled spherical wave.</li>
          <li><strong>Stationary random process</strong>: the source statistics donâ€™t depend on absolute time, so correlations depend on time difference only.</li>
          <li><strong>Wienerâ€“Khinchin relationship</strong>: the temporal coherence function is the Fourier transform of the spectrum; Lorentzian â†’ exponential.</li>
          <li><strong>Normalization to Î¼</strong> removes trivial intensity scaling, leaving only coherence (correlation) effects.</li>
        </ul>

        <div class="callout">
          <h3 style="margin-top:0">Assumptions (explicit)</h3>
          <ul>
            <li>Scalar, paraxial/free-space propagation; polarization effects ignored (they cancel in Î¼ for this setup).</li>
            <li>Quasi-monochromatic: a carrier frequency Ï‰â‚€ exists (but magnitude |Î¼| is independent of Ï‰â‚€).</li>
            <li>Source is spatially a single point: no finite-source spatial incoherenceâ€”only spectral (temporal) effects matter.</li>
            <li>Medium is nondispersive (vacuum/air), so delay = distance/c.</li>
          </ul>
        </div>

        <h3>Possible approaches</h3>
        <ol>
          <li><strong>Propagation-delay approach (best here):</strong> write E(ğ«,t) as delayed source field, compute J, normalize â†’ Î¼ = g(Î”t). Minimal algebra; directly connects to coherence time.</li>
          <li><strong>Spectral integration:</strong> compute Î¼ by integrating the spectrum with an x-dependent phase factor exp(âˆ’iÏ‰Î”t). More general, but heavier math.</li>
          <li><strong>Small-angle expansion:</strong> approximate Î”r for xâ‰ªd to get a simple Gaussian-like |Î¼| profile; good for sketching and scaling but not exact for large x.</li>
        </ol>
        <p class="muted"><strong>Choice:</strong> Use the propagation-delay approach for an exact compact expression, then use the small-angle expansion for an intuitive sketch and coherence width.</p>
      </section>

      <section id="part2">
        <h2>PART 2 â€” Strategy &amp; Tips (Roadmap Only)</h2>
        <ol>
          <li>
            <strong>Compute distances</strong> râ‚ and râ‚‚.
            <div class="muted">Tool: geometry in Cartesian coordinates. Meaning: sets propagation delays.</div>
          </li>
          <li>
            <strong>Write fields as delayed spherical waves</strong> from a point source.
            <div class="muted">Tool: E(ğ«,t) âˆ (1/r)Â·E<sub>s</sub>(t âˆ’ r/c)Â·e<sup>âˆ’iÏ‰â‚€(tâˆ’r/c)</sup>. Meaning: same source field sampled at different retarded times.</div>
          </li>
          <li>
            <strong>Form the mutual intensity</strong> J = âŸ¨Eâ‚Eâ‚‚*âŸ©.
            <div class="muted">Tool: stationarity â†’ correlation depends on time difference Î”t. Meaning: correlation is the temporal coherence function evaluated at Î”t.</div>
          </li>
          <li>
            <strong>Normalize</strong> to get Î¼ = J/âˆš(Iâ‚Iâ‚‚).
            <div class="muted">Tool: intensities Iâ‚, Iâ‚‚. Meaning: removes 1/r factors; isolates coherence.</div>
          </li>
          <li>
            <strong>Insert Lorentzian coherence function</strong> g(Ï„) = exp(âˆ’|Ï„|/Ï„c)exp(âˆ’iÏ‰â‚€Ï„).
            <div class="muted">Meaning: exponential decay with delay; phase gives fringe shift.</div>
          </li>
          <li>
            <strong>Express Î¼ as a function of x</strong> using Î”t = (âˆš(dÂ²+xÂ²)âˆ’d)/c.
            <div class="muted">Meaning: spatial separation causes a path delay; spectral width converts it into reduced coherence.</div>
          </li>
          <li>
            <strong>Sketch |Î¼(x)|</strong>, and optionally use xâ‰ªd expansion to reveal a coherence width scale.
            <div class="muted">Tip: Î”r â‰ˆ xÂ²/(2d) â†’ |Î¼| â‰ˆ exp(âˆ’xÂ²/(2dcÏ„c)).</div>
          </li>
        </ol>

        <div class="callout warn">
          <h3 style="margin-top:0">Common mistakes &amp; quick tips</h3>
          <ul>
            <li><strong>Mistake:</strong> using Î”t â‰ˆ x/c. <strong>Fix:</strong> delay comes from path difference: Î”r = âˆš(dÂ²+xÂ²) âˆ’ d.</li>
            <li><strong>Mistake:</strong> leaving 1/(râ‚râ‚‚) in Î¼. <strong>Fix:</strong> normalization cancels distance scaling for a point source.</li>
            <li><strong>Mistake:</strong> forgetting the absolute value in exp(âˆ’|Ï„|/Ï„c). <strong>Fix:</strong> coherence decays with magnitude of delay.</li>
          </ul>
        </div>
      </section>

      <section id="part3">
        <h2>PART 3 â€” Full Solution (Detailed + Teaching)</h2>

        <h3>Qualitative expectation (before math)</h3>
        <p>
          Both points see light from the <em>same</em> point source, so if the source were perfectly monochromatic,
          the normalized mutual intensity would be <span class="muted">|Î¼| = 1</span> for any x (perfect coherence).
          However, finite spectral width means the phase drifts over time. A larger path difference produces a larger
          time delay between the two received fields, so their correlation decays. Therefore:
        </p>
        <ul>
          <li><span class="muted">|Î¼(x)|</span> should start at 1 when x=0 and decrease as |x| increases.</li>
          <li>The decay scale in x should be set by when the path difference becomes comparable to the coherence length <span class="muted">cÏ„c</span>.</li>
        </ul>

        <h3>Step 1: Geometry (distances and delay)</h3>
        <p>
          The distance from the origin to <span class="muted">Pâ‚ = (0,0,d)</span> is:
        </p>
        <div class="eqbox">
          <pre class="eq" id="eq-r1">râ‚ = âˆš(0Â²+0Â²+dÂ²) = d</pre>
          <button class="copybtn" data-copy-target="eq-r1">Copy</button>
        </div>
        <p>
          The distance to <span class="muted">Pâ‚‚ = (x,0,d)</span> is:
        </p>
        <div class="eqbox">
          <pre class="eq" id="eq-r2">râ‚‚ = âˆš(xÂ² + 0Â² + dÂ²) = âˆš(dÂ² + xÂ²)</pre>
          <button class="copybtn" data-copy-target="eq-r2">Copy</button>
        </div>
        <p>
          Thus the path difference and propagation time delay are:
        </p>
        <div class="eqbox">
          <pre class="eq" id="eq-delay">
Î”r = râ‚‚ âˆ’ râ‚ = âˆš(dÂ² + xÂ²) âˆ’ d
Î”t = Î”r / c = (âˆš(dÂ² + xÂ²) âˆ’ d)/c</pre>
          <button class="copybtn" data-copy-target="eq-delay">Copy</button>
        </div>
        <p class="muted">
          What we did: purely geometry. Why: coherence depends on how much one field is delayed relative to the other.
        </p>

        <h3>Step 2: Field model for a point source (retarded time)</h3>
        <p>
          A point source emitting a quasi-monochromatic random field can be represented (up to a constant factor) as a spherical wave:
        </p>
        <div class="eqbox">
          <pre class="eq" id="eq-field">
E(ğ«,t) = (A/r) Â· u(t âˆ’ r/c) Â· exp[âˆ’i Ï‰â‚€ (t âˆ’ r/c)]</pre>
          <button class="copybtn" data-copy-target="eq-field">Copy</button>
        </div>
        <p>
          Here:
        </p>
        <ul>
          <li><span class="muted">A</span> is a constant amplitude factor (source strength).</li>
          <li><span class="muted">u(t)</span> is a complex random envelope describing the source fluctuations.</li>
          <li>The exponential with Ï‰â‚€ represents a carrier oscillation.</li>
        </ul>
        <p class="muted">
          What we did: wrote the received field as a delayed copy of the source field. Why: all coherence changes here come from time delay and spectral width.
        </p>

        <h3>Step 3: Mutual intensity and normalization</h3>
        <p>
          Let <span class="muted">Eâ‚(t) = E(Pâ‚,t)</span> and <span class="muted">Eâ‚‚(t) = E(Pâ‚‚,t)</span>. Then:
        </p>
        <div class="eqbox">
          <pre class="eq" id="eq-Jdef">J(Pâ‚,Pâ‚‚) = âŸ¨Eâ‚(t) Eâ‚‚*(t)âŸ©</pre>
          <button class="copybtn" data-copy-target="eq-Jdef">Copy</button>
        </div>
        <p>
          Substitute the spherical-wave model:
        </p>
        <div class="eqbox">
          <pre class="eq" id="eq-Jsub">
Eâ‚(t) = (A/râ‚) u(t âˆ’ râ‚/c) e^{âˆ’iÏ‰â‚€(t âˆ’ râ‚/c)}
Eâ‚‚(t) = (A/râ‚‚) u(t âˆ’ râ‚‚/c) e^{âˆ’iÏ‰â‚€(t âˆ’ râ‚‚/c)}</pre>
          <button class="copybtn" data-copy-target="eq-Jsub">Copy</button>
        </div>
        <p>
          Multiply and ensemble-average:
        </p>
        <div class="eqbox">
          <pre class="eq" id="eq-Jcalc">
J = (|A|Â²/(râ‚ râ‚‚)) âŸ¨ u(t âˆ’ râ‚/c) u*(t âˆ’ râ‚‚/c) âŸ© Â· e^{âˆ’iÏ‰â‚€[(t âˆ’ râ‚/c) âˆ’ (t âˆ’ râ‚‚/c)]}
  = (|A|Â²/(râ‚ râ‚‚)) âŸ¨ u(t') u*(t' âˆ’ Î”t) âŸ© Â· e^{âˆ’iÏ‰â‚€(âˆ’Î”t)}
  = (|A|Â²/(râ‚ râ‚‚)) Î“_u(Î”t) Â· e^{âˆ’iÏ‰â‚€Î”t}</pre>
          <button class="copybtn" data-copy-target="eq-Jcalc">Copy</button>
        </div>
        <p>
          where <span class="muted">Î”t = (râ‚‚ âˆ’ râ‚)/c</span> and <span class="muted">Î“_u(Î”t) = âŸ¨u(t)u*(t âˆ’ Î”t)âŸ©</span> is the envelope autocorrelation.
        </p>
        <p class="muted">
          What we did: used stationarity so the correlation depends only on the time difference. Why: the source is assumed statistically steady.
        </p>

        <p>
          The intensities are:
        </p>
        <div class="eqbox">
          <pre class="eq" id="eq-I">
Iâ‚ = âŸ¨|Eâ‚|Â²âŸ© = (|A|Â²/râ‚Â²) âŸ¨|u|Â²âŸ©
Iâ‚‚ = âŸ¨|Eâ‚‚|Â²âŸ© = (|A|Â²/râ‚‚Â²) âŸ¨|u|Â²âŸ©</pre>
          <button class="copybtn" data-copy-target="eq-I">Copy</button>
        </div>
        <p>
          Therefore the normalized mutual intensity (complex degree of coherence) is:
        </p>
        <div class="eqbox">
          <pre class="eq" id="eq-mu-general">
Î¼(Pâ‚,Pâ‚‚) = J/âˆš(Iâ‚ Iâ‚‚)
         = [Î“_u(Î”t)/âŸ¨|u|Â²âŸ©] Â· e^{âˆ’iÏ‰â‚€Î”t}
         â‰¡ g(Î”t)</pre>
          <button class="copybtn" data-copy-target="eq-mu-general">Copy</button>
        </div>
        <p class="muted">
          Key takeaway: for a point source, normalization cancels the 1/r factors, leaving the temporal coherence evaluated at the propagation delay.
        </p>

        <h3>Step 4: Insert the Lorentzian temporal coherence function</h3>
        <p>
          For a Lorentzian spectrum, the normalized temporal coherence function is exponential:
        </p>
        <div class="eqbox">
          <pre class="eq" id="eq-g-lor">
g(Ï„) = exp(âˆ’|Ï„|/Ï„c) Â· exp(âˆ’i Ï‰â‚€ Ï„)</pre>
          <button class="copybtn" data-copy-target="eq-g-lor">Copy</button>
        </div>
        <p>
          Evaluate at <span class="muted">Ï„ = Î”t</span>:
        </p>

        <div class="callout" style="margin-top:10px">
          <h3 style="margin-top:0">Final result (boxed)</h3>
          <div class="eqbox" style="margin:10px 0">
            <pre class="eq" id="eq-final">
Let râ‚ = d,   râ‚‚ = âˆš(dÂ² + xÂ²),   Î”r = râ‚‚ âˆ’ râ‚,   Î”t = Î”r/c.

Normalized mutual intensity (complex degree of coherence):
Î¼(x) = exp(âˆ’|Î”t|/Ï„c) Â· exp(âˆ’i Ï‰â‚€ Î”t)
     = exp(âˆ’(âˆš(dÂ² + xÂ²) âˆ’ d)/(c Ï„c)) Â· exp(âˆ’i kâ‚€(âˆš(dÂ² + xÂ²) âˆ’ d)),

where kâ‚€ = Ï‰â‚€/c.</pre>
            <button class="copybtn" data-copy-target="eq-final">Copy</button>
          </div>

          <div class="eqbox" style="margin:10px 0">
            <pre class="eq" id="eq-mag">
Magnitude (what you sketch):
|Î¼(x)| = exp(âˆ’(âˆš(dÂ² + xÂ²) âˆ’ d)/(c Ï„c)).</pre>
            <button class="copybtn" data-copy-target="eq-mag">Copy</button>
          </div>

          <button class="btn" data-copy-target="eq-final">Copy Final Answer (plain text)</button>
        </div>

        <h3>Sanity checks</h3>
        <div class="grid2">
          <div class="card">
            <h3>Units</h3>
            <ul>
              <li><span class="muted">âˆš(dÂ²+xÂ²)âˆ’d</span> has units of meters.</li>
              <li><span class="muted">cÏ„<sub>c</sub></span> has units of meters (coherence length).</li>
              <li>Exponent is dimensionless â†’ OK. Î¼ is dimensionless â†’ OK.</li>
            </ul>
          </div>
          <div class="card">
            <h3>Limiting cases</h3>
            <ul>
              <li><strong>x = 0:</strong> Î”r = 0 â†’ |Î¼| = 1 (perfectly correlated) â†’ OK.</li>
              <li><strong>Ï„<sub>c</sub> â†’ âˆ (monochromatic):</strong> |Î¼| â†’ 1 for all x â†’ OK.</li>
              <li><strong>Large x:</strong> Î”r increases â†’ |Î¼| decays toward 0 â†’ OK.</li>
            </ul>
          </div>
        </div>

        <h3>Useful approximation for sketching (small-angle / paraxial)</h3>
        <p>
          If <span class="muted">|x| â‰ª d</span>, expand:
        </p>
        <div class="eqbox">
          <pre class="eq" id="eq-approx">
âˆš(dÂ² + xÂ²) = d âˆš(1 + xÂ²/dÂ²) â‰ˆ d [1 + (xÂ²/(2dÂ²))] = d + xÂ²/(2d)

So Î”r â‰ˆ xÂ²/(2d), and

|Î¼(x)| â‰ˆ exp(âˆ’Î”r/(cÏ„c)) = exp(âˆ’xÂ²/(2 d c Ï„c)).</pre>
          <button class="copybtn" data-copy-target="eq-approx">Copy</button>
        </div>
        <p class="muted">
          Interpretation: near x=0 the coherence falls approximately like a Gaussian in x because the path difference grows quadratically with lateral displacement.
        </p>

        <h3>Example numeric scale (for intuition; final formula remains symbolic)</h3>
        <p>
          Using <span class="muted">d = 0.10 m</span>, <span class="muted">Ï„<sub>c</sub> = 10 ps</span>,
          the field coherence length is <span class="muted">cÏ„<sub>c</sub> â‰ˆ 3.0 mm</span>.
          Setting <span class="muted">|Î¼| = e<sup>âˆ’1</sup></span> gives <span class="muted">Î”r = cÏ„<sub>c</sub></span>, so:
        </p>
        <div class="eqbox">
          <pre class="eq" id="eq-x1e">
âˆš(dÂ² + xÂ²) âˆ’ d = cÏ„c
â‡’ x = âˆš[(d + cÏ„c)Â² âˆ’ dÂ²] â‰ˆ âˆš(2 d cÏ„c)  (since cÏ„c â‰ª d)

With d=0.10 m and cÏ„c=0.003 m:
x â‰ˆ âˆš(2Â·0.10Â·0.003) â‰ˆ 0.0245 m â‰ˆ 2.45 cm.</pre>
          <button class="copybtn" data-copy-target="eq-x1e">Copy</button>
        </div>

        <p>
          Connection to the diagram/plots: the geometry canvas shows how two rays from the origin travel to Pâ‚ and Pâ‚‚; the plots then show how
          the resulting delay reduces |Î¼| as x increases.
        </p>
      </section>

      <section id="part4">
        <h2>PART 4 â€” Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpreting the final formula</h3>
        <ul>
          <li><strong>Exponential envelope</strong> <span class="muted">exp(âˆ’Î”r/(cÏ„<sub>c</sub>))</span>:
            spectral width (short Ï„<sub>c</sub>) makes coherence die quickly with path difference.</li>
          <li><strong>Phase term</strong> <span class="muted">exp(âˆ’ikâ‚€Î”r)</span>:
            does not change visibility (|Î¼|) but shifts interference fringes if you combine the beams.</li>
          <li><strong>Geometry coupling</strong> Î”r = âˆš(dÂ² + xÂ²) âˆ’ d:
            coherence vs x depends on how path difference grows with lateral separation at fixed range d.</li>
        </ul>

        <div class="callout">
          <h3 style="margin-top:0">How parameters affect the outcome (connect to the interactive plots)</h3>
          <ul>
            <li>Increase <strong>Ï„<sub>c</sub></strong> (narrower spectrum) â†’ <strong>slower decay</strong> of |Î¼(x)| â†’ more spatial coherence.</li>
            <li>Increase <strong>d</strong> (move the observation plane farther) â†’ Î”r grows more slowly with x â†’ <strong>wider</strong> coherence vs x.</li>
            <li>Change <strong>Î»â‚€</strong> (or Ï‰â‚€) â†’ changes only the <strong>phase</strong> of Î¼, not its magnitude.</li>
          </ul>
        </div>

        <h3>Alternative derivation idea (brief)</h3>
        <p>
          You can also derive Î¼(x) directly from the spectrum by integrating over frequency:
          <span class="muted">Î¼ = âˆ« S(Ï‰) e^{âˆ’iÏ‰Î”t} dÏ‰ / âˆ« S(Ï‰) dÏ‰</span>.
          For Lorentzian S(Ï‰), this integral evaluates to an exponential in |Î”t|, reproducing the same result.
        </p>

        <h3>Concept checks (quick self-test)</h3>
        <ul>
          <li><strong>Q:</strong> If Ï„<sub>c</sub> doubles, what happens to the 1/e coherence width in x (for small x)?<br>
              <strong>A:</strong> It scales like âˆšÏ„<sub>c</sub>, so it increases by âˆš2.</li>
          <li><strong>Q:</strong> Why does |Î¼| depend on x even though the source is a single point (spatially coherent)?<br>
              <strong>A:</strong> Because different points correspond to different propagation delays; finite bandwidth converts delay into reduced correlation.</li>
          <li><strong>Q:</strong> Does the carrier wavelength affect the magnitude |Î¼| here?<br>
              <strong>A:</strong> Noâ€”only the phase term depends on Ï‰â‚€ (or Î»â‚€); the magnitude depends on Î”t/Ï„<sub>c</sub>.</li>
          <li><strong>Q:</strong> What path difference corresponds to |Î¼| = 0.1 for Lorentzian coherence?<br>
              <strong>A:</strong> Solve e^{âˆ’Î”r/(cÏ„c)} = 0.1 â†’ Î”r = (cÏ„c) ln(10).</li>
        </ul>
      </section>

      <section id="part5">
        <h2>PART 5 â€” Visualization Guide (How to Read the Plots)</h2>

        <div class="grid2">
          <div class="card">
            <h3>Canvas 1: Geometry diagram</h3>
            <p class="muted">
              Shows the origin source, the plane z=d, and points Pâ‚ and Pâ‚‚ separated by x.
              It also displays râ‚, râ‚‚, and the path difference Î”r that creates the time delay Î”t.
            </p>
          </div>
          <div class="card">
            <h3>Canvas 2: Main plot â€” |Î¼(x)| vs x</h3>
            <p class="muted">
              This is the requested â€œsketchâ€ made quantitative. The curve starts at 1 and decays with x.
              The 1/e point is marked, where |Î¼| = e<sup>âˆ’1</sup>.
            </p>
          </div>
        </div>

        <div class="grid2" style="margin-top:12px">
          <div class="card">
            <h3>Canvas 3: Secondary plot â€” phase of Î¼(x)</h3>
            <p class="muted">
              Plots the argument of Î¼(x), i.e., the phase shift âˆ’kâ‚€Î”r (wrapped to [âˆ’Ï€, Ï€]).
              It changes with wavelength but does not affect |Î¼| (visibility).
            </p>
          </div>
          <div class="card">
            <h3>Interactive controls</h3>
            <p class="muted">
              Use the sliders to change Ï„<sub>c</sub> (coherence time), d (range), and Î»â‚€ (carrier wavelength).
              All canvases update live. Watch how increasing Ï„<sub>c</sub> broadens |Î¼(x)|, and increasing d also broadens it.
            </p>
          </div>
        </div>
      </section>

      <section id="visuals">
        <h2>Interactive Visualizations</h2>

        <div class="vizwrap">
          <div class="card">
            <h3 style="margin:4px 0 8px">Diagram: Point source â†’ two observation points in plane z=d</h3>
            <canvas id="cDiagram" aria-label="Geometry diagram"></canvas>
            <div class="controls">
              <div>
                <label for="tauSlider">Coherence time Ï„c (ps)</label>
                <input id="tauSlider" type="range" min="1" max="100" step="1" value="10" />
                <div class="readout" id="tauReadout">Ï„c = 10 ps</div>
              </div>
              <div>
                <label for="dSlider">Distance d (cm)</label>
                <input id="dSlider" type="range" min="2" max="100" step="1" value="10" />
                <div class="readout" id="dReadout">d = 10 cm</div>
              </div>
            </div>
            <div class="controls">
              <div>
                <label for="lamSlider">Carrier wavelength Î»0 (nm) â€” affects phase plot only</label>
                <input id="lamSlider" type="range" min="400" max="1600" step="10" value="633" />
                <div class="readout" id="lamReadout">Î»0 = 633 nm</div>
              </div>
              <div>
                <label for="xmaxSlider">Plot span x_max (cm)</label>
                <input id="xmaxSlider" type="range" min="1" max="20" step="1" value="10" />
                <div class="readout" id="xmaxReadout">x_max = 10 cm</div>
              </div>
            </div>
            <div class="btnrow">
              <button class="btn" id="btnReset">Reset to problem values</button>
              <button class="btn" id="btnExampleWide">Example: larger Ï„c</button>
            </div>
            <p class="muted" id="numReadout" style="margin-top:10px"></p>
          </div>

          <div class="card small">
            <h3 style="margin:4px 0 8px">Main plot: magnitude |Î¼(x)|</h3>
            <canvas id="cMain" aria-label="Magnitude plot"></canvas>

            <h3 style="margin:14px 0 8px">Secondary plot: phase arg Î¼(x)</h3>
            <canvas id="cPhase" aria-label="Phase plot"></canvas>
          </div>
        </div>

        <div class="callout warn" style="margin-top:12px">
          <strong>Note:</strong> The problem does not specify the carrier frequency (Ï‰â‚€) or wavelength (Î»â‚€). The magnitude |Î¼|
          is independent of Î»â‚€, so the phase plot uses Î»â‚€ as an <em>example parameter</em> purely for visualization.
        </div>
      </section>
    </article>
  </main>

  <footer>
    <p>
      Built as a self-contained learning article (vanilla HTML/CSS/JS). The key physical link is: spatial separation â†’ path delay â†’ temporal decoherence set by Ï„<sub>c</sub>.
    </p>
  </footer>

  <script>
    // -----------------------------
    // Utilities: copy buttons
    // -----------------------------
    function copyTextFromPre(preId){
      const el = document.getElementById(preId);
      if(!el) return;
      const txt = el.textContent;
      navigator.clipboard.writeText(txt).then(()=>{
        flashToast("Copied!");
      }).catch(()=>{
        // fallback
        const ta = document.createElement("textarea");
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        try{ document.execCommand("copy"); flashToast("Copied!"); }catch(e){ flashToast("Copy failed"); }
        document.body.removeChild(ta);
      });
    }

    let toastTimer = null;
    function flashToast(msg){
      let t = document.getElementById("toast");
      if(!t){
        t = document.createElement("div");
        t.id = "toast";
        t.style.position = "fixed";
        t.style.left = "50%";
        t.style.bottom = "18px";
        t.style.transform = "translateX(-50%)";
        t.style.padding = "10px 14px";
        t.style.borderRadius = "999px";
        t.style.background = "rgba(0,0,0,.78)";
        t.style.color = "#fff";
        t.style.border = "1px solid rgba(255,255,255,.18)";
        t.style.fontFamily = getComputedStyle(document.body).fontFamily;
        t.style.fontWeight = "700";
        t.style.zIndex = "9999";
        t.style.boxShadow = "0 10px 25px rgba(0,0,0,.35)";
        t.style.opacity = "0";
        t.style.transition = "opacity .2s ease, transform .2s ease";
        document.body.appendChild(t);
      }
      t.textContent = msg;
      t.style.opacity = "1";
      t.style.transform = "translateX(-50%) translateY(-2px)";
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=>{
        t.style.opacity = "0";
        t.style.transform = "translateX(-50%) translateY(0px)";
      }, 900);
    }

    document.querySelectorAll("[data-copy-target]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const target = btn.getAttribute("data-copy-target");
        copyTextFromPre(target);
      });
    });

    // -----------------------------
    // Physics functions
    // -----------------------------
    const c = 299792458; // m/s
    function r1(d){ return d; }
    function r2(d, x){ return Math.sqrt(d*d + x*x); }
    function deltaR(d, x){ return r2(d,x) - r1(d); }
    function muMag(d, x, tauC){ // tauC in seconds
      const dr = deltaR(d, x);
      return Math.exp(-Math.abs(dr)/(c*tauC));
    }
    function muPhase(d, x, lambda0){ // lambda0 in meters, phase = -k0 * Î”r
      const k0 = 2*Math.PI/lambda0;
      const dr = deltaR(d, x);
      let ph = -k0*dr;
      // wrap to [-pi, pi]
      ph = ((ph + Math.PI) % (2*Math.PI));
      if(ph < 0) ph += 2*Math.PI;
      ph -= Math.PI;
      return ph;
    }
    function findXforMag(d, tauC, target){ // target in (0,1], solve exp(-Î”r/(cÏ„c))=target
      // Î”r = -c Ï„c ln(target)
      const drTarget = -c*tauC*Math.log(target);
      // Solve âˆš(dÂ²+xÂ²)-d = drTarget => x = âˆš[(d+dr)^2 - d^2]
      const val = (d + drTarget)*(d + drTarget) - d*d;
      return val <= 0 ? 0 : Math.sqrt(val);
    }

    // -----------------------------
    // Canvas drawing helpers (HiDPI + responsive)
    // -----------------------------
    function setupCanvas(canvas){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect.width * dpr));
      const h = Math.max(2, Math.floor(rect.height * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
      const ctx = canvas.getContext("2d");
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(dpr, dpr);
      return {ctx, w: rect.width, h: rect.height, dpr};
    }

    function clear(ctx, w, h){
      ctx.clearRect(0,0,w,h);
      // soft background fill
      ctx.fillStyle = "rgba(0,0,0,0.12)";
      ctx.fillRect(0,0,w,h);
    }

    function drawGridAxes(ctx, w, h, plot, opts){
      const {
        xMin, xMax, yMin, yMax,
        xLabel, yLabel, title,
        xTicks=6, yTicks=5
      } = plot;
      const pad = opts.pad;
      const left = pad.l, right = pad.r, top = pad.t, bottom = pad.b;

      // Title
      ctx.save();
      ctx.fillStyle = "rgba(233,238,252,0.95)";
      ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(title, left, 18);
      ctx.restore();

      // Plot area
      const x0 = left, y0 = top, pw = w - left - right, ph = h - top - bottom;

      // Gridlines & ticks
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;

      // x grid
      for(let i=0;i<=xTicks;i++){
        const t = i/xTicks;
        const x = x0 + t*pw;
        ctx.beginPath(); ctx.moveTo(x, y0); ctx.lineTo(x, y0+ph); ctx.stroke();
      }
      // y grid
      for(let j=0;j<=yTicks;j++){
        const t = j/yTicks;
        const y = y0 + (1-t)*ph;
        ctx.beginPath(); ctx.moveTo(x0, y); ctx.lineTo(x0+pw, y); ctx.stroke();
      }

      // Axes border
      ctx.strokeStyle = "rgba(255,255,255,0.20)";
      ctx.strokeRect(x0, y0, pw, ph);

      // Tick labels
      ctx.fillStyle = "rgba(169,180,214,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";

      for(let i=0;i<=xTicks;i++){
        const t = i/xTicks;
        const xv = xMin + t*(xMax-xMin);
        const x = x0 + t*pw;
        ctx.fillText(formatTick(xv), x-10, y0+ph+18);
      }
      for(let j=0;j<=yTicks;j++){
        const t = j/yTicks;
        const yv = yMin + t*(yMax-yMin);
        const y = y0 + (1-t)*ph;
        ctx.fillText(formatTick(yv), x0-46, y+4);
      }

      // Axis labels
      ctx.save();
      ctx.fillStyle = "rgba(233,238,252,0.92)";
      ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(xLabel, x0 + pw - ctx.measureText(xLabel).width, y0+ph+38);

      ctx.translate(14, y0 + ph/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();

      ctx.restore();

      return {
        x0, y0, pw, ph,
        xToPx: (x)=> x0 + (x - xMin)/(xMax-xMin)*pw,
        yToPx: (y)=> y0 + (1 - (y - yMin)/(yMax-yMin))*ph
      };
    }

    function formatTick(v){
      const av = Math.abs(v);
      if(av >= 100) return v.toFixed(0);
      if(av >= 10) return v.toFixed(1);
      if(av >= 1) return v.toFixed(2);
      if(av >= 0.1) return v.toFixed(2);
      return v.toFixed(3);
    }

    function drawLegend(ctx, w, items){
      if(!items || !items.length) return;
      ctx.save();
      const pad = 10;
      let x = w - 10;
      let y = 28;
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textBaseline = "middle";
      items.slice().reverse().forEach(it=>{
        const tw = ctx.measureText(it.label).width;
        x = Math.min(x, w - (tw + 46));
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.strokeStyle = "rgba(255,255,255,0.14)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        roundRect(ctx, x-8, y-10, tw+44, 20, 10);
        ctx.fill(); ctx.stroke();
        // line swatch
        ctx.strokeStyle = it.stroke;
        ctx.lineWidth = 2.5;
        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x+22, y); ctx.stroke();
        // label
        ctx.fillStyle = "rgba(233,238,252,0.95)";
        ctx.fillText(it.label, x+28, y);
        y += 24;
      });
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    // -----------------------------
    // Draw: Geometry diagram
    // -----------------------------
    function drawDiagram(canvas, params){
      const {ctx, w, h} = setupCanvas(canvas);
      clear(ctx, w, h);

      // Layout coords
      const pad = 16;
      const left = pad, right = w - pad, top = pad, bottom = h - pad;

      // Coordinate mapping: world x in [-xMax, xMax], z in [0, d*1.15]
      const xMax = params.xMax;
      const zMax = params.d * 1.25;

      function X(x){ return left + (x + xMax)/(2*xMax) * (right-left); }
      function Z(z){ return bottom - (z)/(zMax) * (bottom-top); }

      // Axes
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 1.2;
      // x-axis at z=0
      ctx.beginPath(); ctx.moveTo(X(-xMax), Z(0)); ctx.lineTo(X(xMax), Z(0)); ctx.stroke();
      // z-axis at x=0
      ctx.beginPath(); ctx.moveTo(X(0), Z(0)); ctx.lineTo(X(0), Z(zMax)); ctx.stroke();
      ctx.fillStyle = "rgba(169,180,214,0.9)";
      ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText("x", X(xMax)-10, Z(0)-6);
      ctx.fillText("z", X(0)+6, Z(zMax)+12);
      ctx.restore();

      // Plane z = d
      ctx.save();
      ctx.strokeStyle = "rgba(122,162,255,0.35)";
      ctx.lineWidth = 1.5;
      ctx.setLineDash([6,5]);
      ctx.beginPath(); ctx.moveTo(X(-xMax), Z(params.d)); ctx.lineTo(X(xMax), Z(params.d)); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(122,162,255,0.9)";
      ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("observation plane  z = d", X(-xMax)+6, Z(params.d)-8);
      ctx.restore();

      // Points
      const P0 = {x:0, z:0};
      const P1 = {x:0, z:params.d};
      const P2 = {x:params.xPick, z:params.d};

      // Rays
      ctx.save();
      // to P1
      ctx.strokeStyle = "rgba(124,255,199,0.9)";
      ctx.lineWidth = 2.2;
      ctx.beginPath(); ctx.moveTo(X(P0.x), Z(P0.z)); ctx.lineTo(X(P1.x), Z(P1.z)); ctx.stroke();
      // to P2
      ctx.strokeStyle = "rgba(255,204,102,0.95)";
      ctx.beginPath(); ctx.moveTo(X(P0.x), Z(P0.z)); ctx.lineTo(X(P2.x), Z(P2.z)); ctx.stroke();
      ctx.restore();

      // Markers
      function dot(x, z, color, label){
        ctx.save();
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.arc(X(x), Z(z), 5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.25)";
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.fillStyle = "rgba(233,238,252,0.95)";
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
        ctx.fillText(label, X(x)+8, Z(z)-8);
        ctx.restore();
      }
      dot(0,0,"rgba(233,238,252,0.95)","Source (0,0,0)");
      dot(P1.x,P1.z,"rgba(124,255,199,0.95)","P1 (0,0,d)");
      dot(P2.x,P2.z,"rgba(255,204,102,0.95)","P2 (x,0,d)");

      // Annotate x separation and path difference
      const dr = deltaR(params.d, params.xPick);
      const dt = dr / c;
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 1.2;

      // x bracket between P1 and P2
      const yb = Z(params.d) + 18;
      ctx.beginPath(); ctx.moveTo(X(P1.x), yb); ctx.lineTo(X(P2.x), yb); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(X(P1.x), yb-5); ctx.lineTo(X(P1.x), yb+5); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(X(P2.x), yb-5); ctx.lineTo(X(P2.x), yb+5); ctx.stroke();

      ctx.fillStyle = "rgba(169,180,214,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      ctx.fillText("x", (X(P1.x)+X(P2.x))/2 - 4, yb+16);

      // Text block
      ctx.fillStyle = "rgba(233,238,252,0.95)";
      ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      const lines = [
        `r1 = d`,
        `r2 = âˆš(dÂ² + xÂ²)`,
        `Î”r = r2 âˆ’ r1 = ${ (dr*1000).toFixed(2) } mm`,
        `Î”t = Î”r/c = ${ (dt*1e12).toFixed(2) } ps`,
      ];
      let tx = X(-params.xMax) + 10;
      let ty = Z(params.d*0.55);
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.lineWidth = 1;
      const boxW = 230, boxH = 80;
      ctx.beginPath(); roundRect(ctx, tx-8, ty-16, boxW, boxH, 12);
      ctx.fill(); ctx.stroke();

      ctx.fillStyle = "rgba(233,238,252,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      lines.forEach((s,i)=> ctx.fillText(s, tx, ty + i*16));
      ctx.restore();
    }

    // -----------------------------
    // Draw: Main magnitude plot
    // -----------------------------
    function drawMain(canvas, params){
      const {ctx, w, h} = setupCanvas(canvas);
      clear(ctx, w, h);

      const xMax = params.xMax; // meters
      const plot = {
        xMin: -xMax*100, xMax: xMax*100, // cm
        yMin: 0, yMax: 1.05,
        xLabel: "x (cm)",
        yLabel: "|Î¼(x)| (dimensionless)",
        title: "Magnitude of normalized mutual intensity  |Î¼(x)|"
      };
      const map = drawGridAxes(ctx, w, h, plot, {pad:{l:58,r:16,t:30,b:48}});

      // Data
      const N = 600;
      ctx.save();
      ctx.lineWidth = 2.5;
      ctx.strokeStyle = "rgba(124,255,199,0.95)";
      ctx.beginPath();
      for(let i=0;i<=N;i++){
        const xc = plot.xMin + (plot.xMax-plot.xMin)*i/N; // cm
        const x = xc/100; // m
        const y = muMag(params.d, x, params.tauC);
        const px = map.xToPx(xc);
        const py = map.yToPx(y);
        if(i===0) ctx.moveTo(px,py);
        else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.restore();

      // Mark 1/e point (positive side) based on exact relation
      const x1e = findXforMag(params.d, params.tauC, 1/Math.E); // m
      const x1e_cm = x1e*100;
      const y1e = 1/Math.E;

      ctx.save();
      ctx.strokeStyle = "rgba(255,204,102,0.9)";
      ctx.lineWidth = 1.8;
      ctx.setLineDash([6,5]);
      // vertical line at +x1e and -x1e
      [x1e_cm, -x1e_cm].forEach(xc=>{
        const px = map.xToPx(xc);
        ctx.beginPath(); ctx.moveTo(px, map.yToPx(0)); ctx.lineTo(px, map.yToPx(1.02)); ctx.stroke();
      });
      // horizontal at y=1/e
      ctx.beginPath(); ctx.moveTo(map.xToPx(plot.xMin), map.yToPx(y1e)); ctx.lineTo(map.xToPx(plot.xMax), map.yToPx(y1e)); ctx.stroke();
      ctx.setLineDash([]);

      // label
      ctx.fillStyle = "rgba(255,204,102,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      ctx.fillText("|Î¼| = 1/e", map.xToPx(plot.xMin)+6, map.yToPx(y1e)-6);
      ctx.fillText(`xâ‚/e â‰ˆ ${x1e_cm.toFixed(2)} cm`, map.xToPx(0)+6, map.yToPx(0.06));
      ctx.restore();

      drawLegend(ctx, w, [
        {label:"|Î¼(x)| = exp(âˆ’Î”r/(cÏ„c))", stroke:"rgba(124,255,199,0.95)"},
        {label:"1/e marker", stroke:"rgba(255,204,102,0.9)"}
      ]);
    }

    // -----------------------------
    // Draw: Phase plot
    // -----------------------------
    function drawPhase(canvas, params){
      const {ctx, w, h} = setupCanvas(canvas);
      clear(ctx, w, h);

      const xMax = params.xMax; // meters
      const plot = {
        xMin: -xMax*100, xMax: xMax*100, // cm
        yMin: -Math.PI, yMax: Math.PI,
        xLabel: "x (cm)",
        yLabel: "arg Î¼(x) (rad)",
        title: "Phase of Î¼(x):  arg Î¼(x) = âˆ’kâ‚€Î”r (wrapped)"
      };
      const map = drawGridAxes(ctx, w, h, plot, {pad:{l:58,r:16,t:30,b:48}});

      const N = 700;
      const lambda0 = params.lambda0;
      ctx.save();
      ctx.lineWidth = 2.2;
      ctx.strokeStyle = "rgba(122,162,255,0.95)";

      // Draw as segments to avoid long lines across wrapping jumps
      let first = true;
      let prevY = null;
      for(let i=0;i<=N;i++){
        const xc = plot.xMin + (plot.xMax-plot.xMin)*i/N;
        const x = xc/100;
        const y = muPhase(params.d, x, lambda0);
        if(prevY !== null && Math.abs(y - prevY) > Math.PI*0.9){
          // start a new segment across wrap discontinuity
          first = true;
        }
        const px = map.xToPx(xc);
        const py = map.yToPx(y);
        if(first){
          ctx.beginPath();
          ctx.moveTo(px,py);
          first = false;
        } else {
          ctx.lineTo(px,py);
        }
        ctx.stroke();
        prevY = y;
      }
      ctx.restore();

      // Reference lines at Â±Ï€ and 0
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.setLineDash([5,5]);
      [0, Math.PI, -Math.PI].forEach(yy=>{
        ctx.beginPath();
        ctx.moveTo(map.xToPx(plot.xMin), map.yToPx(yy));
        ctx.lineTo(map.xToPx(plot.xMax), map.yToPx(yy));
        ctx.stroke();
      });
      ctx.setLineDash([]);
      ctx.restore();

      drawLegend(ctx, w, [
        {label:"arg Î¼(x) (wrapped)", stroke:"rgba(122,162,255,0.95)"}
      ]);
    }

    // -----------------------------
    // Wiring controls + responsive redraw
    // -----------------------------
    const cDiagram = document.getElementById("cDiagram");
    const cMain = document.getElementById("cMain");
    const cPhase = document.getElementById("cPhase");

    const tauSlider = document.getElementById("tauSlider");
    const dSlider = document.getElementById("dSlider");
    const lamSlider = document.getElementById("lamSlider");
    const xmaxSlider = document.getElementById("xmaxSlider");

    const tauReadout = document.getElementById("tauReadout");
    const dReadout = document.getElementById("dReadout");
    const lamReadout = document.getElementById("lamReadout");
    const xmaxReadout = document.getElementById("xmaxReadout");
    const numReadout = document.getElementById("numReadout");

    function getParams(){
      const tauC_ps = +tauSlider.value;
      const d_cm = +dSlider.value;
      const lam_nm = +lamSlider.value;
      const xmax_cm = +xmaxSlider.value;

      // For diagram, pick a representative x point: 0.6*xMax
      const xMax_m = xmax_cm/100;
      const xPick = 0.6 * xMax_m;

      return {
        tauC: tauC_ps * 1e-12,
        tauC_ps,
        d: d_cm/100,
        d_cm,
        lambda0: lam_nm*1e-9,
        lam_nm,
        xMax: xMax_m,
        xmax_cm,
        xPick
      };
    }

    function updateReadouts(p){
      tauReadout.textContent = `Ï„c = ${p.tauC_ps} ps`;
      dReadout.textContent = `d = ${p.d_cm} cm`;
      lamReadout.textContent = `Î»0 = ${p.lam_nm} nm`;
      xmaxReadout.textContent = `x_max = ${p.xmax_cm} cm`;

      // Numeric coherence scales
      const Lc = c * p.tauC; // meters
      const x1e = findXforMag(p.d, p.tauC, 1/Math.E); // meters
      const x10 = findXforMag(p.d, p.tauC, 0.1); // meters
      numReadout.innerHTML =
        `Example coherence scales (from current sliders):<br>` +
        `<span class="muted">cÏ„c</span> = ${(Lc*1000).toFixed(2)} mm, ` +
        `<span class="muted">xâ‚/e</span> â‰ˆ ${(x1e*100).toFixed(2)} cm, ` +
        `<span class="muted">x(|Î¼|=0.1)</span> â‰ˆ ${(x10*100).toFixed(2)} cm.`;
    }

    function redraw(){
      const p = getParams();
      updateReadouts(p);
      drawDiagram(cDiagram, p);
      drawMain(cMain, p);
      drawPhase(cPhase, p);
    }

    // Attach listeners
    [tauSlider, dSlider, lamSlider, xmaxSlider].forEach(el=>{
      el.addEventListener("input", redraw);
    });

    // Buttons
    document.getElementById("btnReset").addEventListener("click", ()=>{
      tauSlider.value = 10;
      dSlider.value = 10;
      lamSlider.value = 633;
      xmaxSlider.value = 10;
      redraw();
      flashToast("Reset to problem values");
    });
    document.getElementById("btnExampleWide").addEventListener("click", ()=>{
      tauSlider.value = 50;
      dSlider.value = 10;
      lamSlider.value = 633;
      xmaxSlider.value = 15;
      redraw();
      flashToast("Example set");
    });

    // Redraw on resize
    let rAF = null;
    window.addEventListener("resize", ()=>{
      cancelAnimationFrame(rAF);
      rAF = requestAnimationFrame(redraw);
    });

    // Initial draw
    redraw();

    // Smooth scrolling for TOC
    document.querySelectorAll('a[href^="#"]').forEach(a=>{
      a.addEventListener("click", (e)=>{
        const id = a.getAttribute("href").slice(1);
        const target = document.getElementById(id);
        if(target){
          e.preventDefault();
          target.scrollIntoView({behavior:"smooth", block:"start"});
          history.replaceState(null, "", "#"+id);
        }
      });
    });
  </script>
</body>
</html>
