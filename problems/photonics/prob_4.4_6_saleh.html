<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Two-Point Resolution of a Single-Lens Imaging System (Square Aperture)</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#111827;
      --panel2:#0f172a;
      --text:#e5e7eb;
      --muted:#a7b0c0;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --ok:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 600px at 20% -10%, rgba(125,211,252,.15), transparent 60%),
                  radial-gradient(900px 500px at 90% 0%, rgba(167,139,250,.14), transparent 55%),
                  linear-gradient(180deg, #070a10, #0b0f17);
      color:var(--text);
      line-height:1.55;
    }

    header{
      padding:28px 18px 10px;
    }
    .wrap{
      max-width:1100px;
      margin:0 auto;
      padding:0 14px 40px;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.3fr .7fr;
      gap:16px;
      align-items:stretch;
    }
    @media (max-width: 900px){
      .hero{grid-template-columns:1fr}
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .inner{padding:18px 18px 16px}
    h1{
      font-size: clamp(1.35rem, 2.2vw, 2.1rem);
      margin:0 0 8px;
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      margin:0;
      font-size: 0.98rem;
    }
    .pillrow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:12px;
    }
    .pill{
      font-family:var(--mono);
      font-size:.86rem;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.20);
      color: var(--text);
    }
    .pill strong{color:var(--accent)}
    .quick ul{
      margin:10px 0 0;
      padding-left:18px;
      color:var(--text);
    }
    .quick li{margin:6px 0}
    .quick li span{color:var(--muted)}
    .toc{
      position:sticky;
      top:12px;
      align-self:start;
    }
    .toc .inner{
      padding:14px 14px 10px;
    }
    .toc h2{
      margin:0 0 10px;
      font-size:1rem;
      letter-spacing:.3px;
      color:var(--muted);
      text-transform:uppercase;
    }
    .toc a{
      display:block;
      padding:8px 10px;
      margin:6px 0;
      border-radius:12px;
      text-decoration:none;
      color:var(--text);
      border:1px solid transparent;
      background: rgba(0,0,0,.18);
      transition: transform .18s ease, border-color .18s ease, background .18s ease;
    }
    .toc a:hover{
      transform: translateY(-1px);
      border-color: rgba(125,211,252,.35);
      background: rgba(125,211,252,.10);
    }

    main{padding:12px 0 0}
    section{
      margin:18px 0;
      scroll-margin-top: 86px;
    }
    section .hd{
      padding:16px 18px 0;
    }
    section h2{
      margin:0;
      font-size:1.25rem;
      letter-spacing:.2px;
    }
    section .bd{
      padding:8px 18px 18px;
      color: var(--text);
    }
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 900px){
      .grid2{grid-template-columns:1fr}
    }

    .callout{
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      border-radius: 16px;
      padding:14px 14px 12px;
    }
    .callout h3{
      margin:0 0 6px;
      font-size:1.02rem;
      color:var(--accent);
    }
    .callout.warn h3{color:var(--warn)}
    .callout.ok h3{color:var(--ok)}
    .callout.bad h3{color:var(--bad)}
    .eq{
      font-family: var(--mono);
      font-size: .95rem;
      background: rgba(0,0,0,.28);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding:12px 12px 10px;
      overflow:auto;
      position:relative;
    }
    .eq .copy{
      position:absolute;
      top:8px;
      right:8px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--text);
      border-radius: 12px;
      padding:6px 10px;
      cursor:pointer;
      font-size:.82rem;
      transition: transform .12s ease, background .12s ease;
    }
    .eq .copy:hover{transform: translateY(-1px); background: rgba(125,211,252,.10)}
    code{font-family:var(--mono)}
    .note{font-size:.95rem; color:var(--muted)}
    .steps ol{margin:8px 0 0; padding-left:18px}
    .steps li{margin:8px 0}
    .hr{
      height:1px;
      background: var(--line);
      margin:14px 0;
    }

    figure{
      margin:0;
      padding:0;
    }
    .viz{
      padding:0;
    }
    .vizhead{
      padding:14px 16px 10px;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
      border-bottom:1px solid var(--line);
      background: rgba(0,0,0,.14);
    }
    .vizhead h3{
      margin:0;
      font-size:1.08rem;
    }
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:10px 12px;
      align-items:center;
      justify-content:flex-end;
    }
    .ctrl{
      display:flex;
      gap:8px;
      align-items:center;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      padding:8px 10px;
      border-radius: 14px;
      min-width: 220px;
    }
    .ctrl label{
      font-size:.86rem;
      color:var(--muted);
      white-space:nowrap;
    }
    .ctrl input[type="range"]{width:120px}
    .ctrl output{
      font-family:var(--mono);
      font-size:.86rem;
      color:var(--text);
      min-width: 72px;
      text-align:right;
    }
    .ctrl button{
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--text);
      border-radius: 12px;
      padding:6px 10px;
      cursor:pointer;
    }
    .ctrl button:hover{background: rgba(125,211,252,.10)}
    canvas{
      width:100%;
      height:360px;
      display:block;
    }
    @media (max-width: 900px){
      canvas{height:320px}
    }
    .caption{
      padding:10px 16px 14px;
      color:var(--muted);
      font-size:.92rem;
    }

    .boxed{
      border:1px solid rgba(125,211,252,.35);
      background: rgba(125,211,252,.08);
      border-radius: 16px;
      padding:14px 14px 12px;
    }
    .boxed h3{margin:0 0 6px; color:var(--accent)}
    .boxed .big{
      font-family:var(--mono);
      font-size: 1.02rem;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding:12px 12px 10px;
      position:relative;
      overflow:auto;
    }
    .boxed .big .copy{
      position:absolute;
      top:8px;
      right:8px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--text);
      border-radius: 12px;
      padding:6px 10px;
      cursor:pointer;
      font-size:.82rem;
    }
    .boxed .big .copy:hover{background: rgba(125,211,252,.10)}
    footer{
      padding:22px 14px 36px;
      color:var(--muted);
      text-align:center;
    }

    @media print{
      body{background:#fff; color:#111}
      .card, .eq, .boxed, .callout{box-shadow:none}
      .toc{display:none}
      .pillrow{display:none}
      .vizhead .controls{display:none}
      header{padding-top:0}
      canvas{height:260px}
      a{color:#111}
    }

    /* subtle motion, respectful */
    @keyframes floatIn{
      from{opacity:0; transform: translateY(6px)}
      to{opacity:1; transform: translateY(0)}
    }
    .card{animation: floatIn .35s ease both}
  </style>
</head>

<body>
  <header>
    <div class="wrap">
      <div class="hero">
        <div class="card">
          <div class="inner quick">
            <h1>Two-Point Resolution with a Square Aperture (Single-Lens, Unit Magnification)</h1>
            <p class="subtitle">
              We model the lens as a coherent, linear, shift-invariant system whose impulse response is the Fourier transform of the pupil.
              Then we add two point responses and study when the image shows <em>two peaks</em>.
            </p>
            <div class="pillrow">
              <div class="pill"><strong>Given:</strong> square aperture width <code>D</code></div>
              <div class="pill"><strong>Scale:</strong> <code>w = λ d₂ / D</code></div>
              <div class="pill"><strong>Key PSF:</strong> <code>h(x,y) ∝ sinc(x/w) sinc(y/w)</code></div>
              <div class="pill"><strong>Two points:</strong> <code>g = h + shifted(h)</code></div>
            </div>

            <div class="hr"></div>

            <h2 style="margin:0;font-size:1.15rem;">Quick Summary</h2>
            <ul>
              <li><strong>Impulse response (field)</strong> for a square pupil is a product of sinc functions in <code>x</code> and <code>y</code> (coherent imaging).</li>
              <li>For two equal points separated by <code>b</code>, the image field along <code>y=0</code> is <code>g(x,0)=C[ sinc(x/w)+sinc((x-b)/w) ]</code>.</li>
              <li>With <code>w=λ d₂/D=0.1 mm</code>, you get two clear peaks for <code>b=0.5, 1, 2 mm</code> (all ≫ <code>w</code>).</li>
              <li><strong>“Two peaks” threshold</strong>: the midpoint switches from a maximum to a minimum when <code>f''(a)=0</code>, where <code>a=b/(2w)</code> and <code>f(u)=sinc(u)</code>.</li>
              <li>Smallest positive solution is <code>a ≈ 0.6626</code>, so <strong><code>b_min ≈ 2w·0.6626 ≈ 0.133 mm</code></strong>.</li>
            </ul>
            <p class="note">We use the normalized sinc: <code>sinc(u)=sin(πu)/(πu)</code> (so zeros at integer <code>u</code>).</p>
          </div>
        </div>

        <nav class="card toc" aria-label="Table of Contents">
          <div class="inner">
            <h2>Contents</h2>
            <a href="#part1">PART 1 — Problem Analysis</a>
            <a href="#part2">PART 2 — Strategy &amp; Tips</a>
            <a href="#part3">PART 3 — Full Solution</a>
            <a href="#viz">Interactive Visualizations</a>
            <a href="#final">Final Results</a>
          </div>
        </nav>
      </div>
    </div>
  </header>

  <main class="wrap">
    <!-- PART 1 -->
    <section id="part1" class="card">
      <div class="hd">
        <h2>PART 1 — Problem Analysis (no solving yet)</h2>
      </div>
      <div class="bd">
        <article>
          <p><strong>Restatement (in my own words).</strong> A single thin lens forms an image with unit magnification and perfect focus. The lens has a <em>square aperture</em> of width <code>D</code>. (a) Find the system’s impulse response <code>h(x,y)</code> (point-spread function for the <em>field</em>) at the image plane. (b) For an object made of two point sources separated by distance <code>b</code> along <code>x</code>, compute the image response. (c) With <code>λ d₂ / D = 0.1 mm</code>, sketch <code>|g(x,0)|</code> for <code>b = 0.5, 1, 2 mm</code> and find the minimum <code>b</code> for which the image shows <em>two peaks</em> (two discernible spots).</p>

          <div class="grid2">
            <div class="callout">
              <h3>Given quantities</h3>
              <ul>
                <li>Square aperture of width <code>D</code> (pupil: a square window)</li>
                <li>Unit magnification (<code>M=1</code>) and perfect focus</li>
                <li>Parameter for part (c): <code>w = λ d₂ / D = 0.1 mm</code></li>
                <li>Two-point object: <code>f(x,y)=δ(x)δ(y) + δ(x-b)δ(y)</code></li>
              </ul>
            </div>
            <div class="callout">
              <h3>Unknowns</h3>
              <ul>
                <li>(a) Impulse response <code>h(x,y)</code></li>
                <li>(b) Image response <code>g(x,y)</code></li>
                <li>(c) Sketch of <code>|g(x,0)|</code> and minimum separation <code>b_min</code> for two peaks</li>
              </ul>
            </div>
          </div>

          <div class="callout ok" style="margin-top:14px;">
            <h3>Relevant physics (and why it applies)</h3>
            <ul>
              <li><strong>Scalar diffraction + Fourier optics.</strong> A finite aperture limits spatial frequencies and produces diffraction blur; the coherent impulse response is (up to phase/scale) the Fourier transform of the pupil.</li>
              <li><strong>Linear shift-invariant (LSI) model.</strong> Under paraxial conditions and perfect focus, the imaging system is approximately LSI in the transverse coordinates, so <code>g = f * h</code> (convolution).</li>
              <li><strong>Superposition.</strong> Two point inputs produce an output that is the sum of two shifted impulse responses (for coherent fields).</li>
            </ul>
          </div>

          <div class="callout warn" style="margin-top:14px;">
            <h3>Possible approaches</h3>
            <ol>
              <li><strong>Direct Fourier transform of the square pupil</strong> → yields a product of sinc functions (fastest and cleanest).</li>
              <li><strong>Start from optical transfer function (OTF)</strong> and invert to PSF (more work; best for incoherent imaging).</li>
              <li><strong>Use Fraunhofer diffraction of a square aperture</strong> then map angles to image-plane coordinates (equivalent to (1), but with more geometry bookkeeping).</li>
            </ol>
            <p class="muted" style="margin:8px 0 0;">
              Best choice here is (1): it gives <code>h(x,y)</code> immediately and keeps the scaling consistent with the given parameter <code>λ d₂ / D</code>.
            </p>
          </div>
        </article>
      </div>
    </section>

    <!-- PART 2 -->
    <section id="part2" class="card steps">
      <div class="hd">
        <h2>PART 2 — Strategy &amp; Tips (roadmap only)</h2>
      </div>
      <div class="bd">
        <div class="grid2">
          <div class="callout">
            <h3>Roadmap (5–10 steps)</h3>
            <ol>
              <li><strong>Model the pupil:</strong> write the square aperture as <code>P(ξ,η)=rect(ξ/D) rect(η/D)</code>.</li>
              <li><strong>Use Fourier-optics result:</strong> coherent impulse response in the image plane is proportional to the FT of <code>P</code> with spatial-frequency variables set by geometry (here summarized by <code>w=λ d₂/D</code>).</li>
              <li><strong>Compute FT:</strong> FT of a rectangle is a sinc → the square becomes a product of sincs.</li>
              <li><strong>Write <code>h(x,y)</code>:</strong> express it using <code>sinc(u)=sin(πu)/(πu)</code>.</li>
              <li><strong>Convolve with two deltas:</strong> <code>g(x,y)=h(x,y)+h(x-b,y)</code>.</li>
              <li><strong>Restrict to <code>y=0</code>:</strong> simplify to a 1D sum.</li>
              <li><strong>Two-peak criterion:</strong> by symmetry, check whether the midpoint is a max or min using the second derivative.</li>
              <li><strong>Insert numbers:</strong> set <code>w=0.1 mm</code> and evaluate <code>b=0.5,1,2 mm</code>; compute <code>b_min</code>.</li>
            </ol>
          </div>
          <div class="callout warn">
            <h3>Common mistakes &amp; quick tips</h3>
            <ul>
              <li><strong>Coherent vs. incoherent.</strong> Here we treat the impulse response as a <em>field</em> response; the two points add in amplitude. (If it were incoherent, intensities would add and the criterion changes.)</li>
              <li><strong>Sinc convention.</strong> Decide whether <code>sinc(u)=sin(πu)/(πu)</code> or <code>sin(u)/u</code> and stick to it. We use the π-normalized form.</li>
              <li><strong>Scaling.</strong> Keep the same <code>w = λ d₂ / D</code> in algebra and plots.</li>
              <li><strong>“Two spots” definition.</strong> The problem explicitly asks: “has two peaks,” so use a peak-count criterion (midpoint becomes a minimum).</li>
            </ul>
          </div>
        </div>
        <p class="note" style="margin-top:12px;">
          Below, we’ll keep the derivation symbolic and only plug in <code>w=0.1 mm</code> for the sketches and the numeric <code>b_min</code>.
        </p>
      </div>
    </section>

    <!-- PART 3 -->
    <section id="part3" class="card">
      <div class="hd">
        <h2>PART 3 — Full Solution</h2>
      </div>
      <div class="bd">
        <article>
          <div class="callout ok">
            <h3>Physical intuition</h3>
            <p style="margin:0;">
              A finite aperture truncates the wavefront, so a point object cannot image to a perfect point.
              Instead, the image becomes a diffraction pattern. For a <em>square</em> aperture, diffraction separates into
              independent x- and y-directions, producing a product of sinc-like lobes.
              Two nearby points produce two overlapping diffraction patterns; if the overlap is strong enough, the two maxima
              merge into one.
            </p>
          </div>

          <div class="hr"></div>

          <h3 style="margin:0 0 6px;">(a) Impulse response <code>h(x,y)</code> for a square aperture</h3>
          <p>
            Let the pupil (aperture) coordinates be <code>(ξ,η)</code> in the lens plane. A square aperture of width <code>D</code> is modeled as
          </p>

          <div class="eq" id="eq-pupil">
            <button class="copy" data-copy-target="eq-pupil">Copy</button>
            <div>
              P(ξ,η) = rect(ξ/D) · rect(η/D),
              where rect(u)=1 for |u|≤1/2 and 0 otherwise.
            </div>
          </div>

          <p>
            In coherent Fourier optics (paraxial, perfect focus), the image-plane field impulse response is proportional to the
            Fourier transform of the pupil:
          </p>

          <div class="eq" id="eq-ft">
            <button class="copy" data-copy-target="eq-ft">Copy</button>
            <div>
              h(x,y) ∝ ∬ P(ξ,η) · exp[-i 2π ( x ξ + y η ) / (λ d₂) ] dξ dη
            </div>
          </div>

          <p class="muted">
            The proportionality constant can include phase factors and overall scaling; for resolution and peak locations, the
            <em>shape</em> matters most. The given parameter <code>λ d₂ / D</code> tells us the natural transverse scale.
          </p>

          <p>
            Because <code>P(ξ,η)</code> factors into x and y parts, the double integral separates:
          </p>

          <div class="eq" id="eq-sep">
            <button class="copy" data-copy-target="eq-sep">Copy</button>
            <div>
              h(x,y) ∝ ( ∫ rect(ξ/D) e^{-i 2π x ξ/(λ d₂)} dξ ) · ( ∫ rect(η/D) e^{-i 2π y η/(λ d₂)} dη )
            </div>
          </div>

          <p>
            The Fourier transform of a rectangle is a sinc. Using the π-normalized sinc
            <code>sinc(u)=sin(πu)/(πu)</code>, define the transverse scale
            <code>w = λ d₂ / D</code> (units of length). Then each 1D factor becomes proportional to <code>D · sinc(x/w)</code>.
            Therefore the coherent impulse response (field PSF) can be written as
          </p>

          <div class="eq" id="eq-hxy">
            <button class="copy" data-copy-target="eq-hxy">Copy</button>
            <div>
              h(x,y) = C · sinc(x/w) · sinc(y/w),  with  w = λ d₂ / D  and  sinc(u)=sin(πu)/(πu).
            </div>
          </div>

          <p class="note">
            <strong>Units check:</strong> <code>w</code> has units of length, so <code>x/w</code>, <code>y/w</code> are dimensionless and sinc is valid.
            The constant <code>C</code> carries the field amplitude scaling (not needed for the peak-count criterion).
          </p>

          <div class="hr"></div>

          <h3 style="margin:0 0 6px;">(b) Response to two points separated by <code>b</code></h3>
          <p>
            The object is
            <code>f(x,y)=δ(x)δ(y)+δ(x-b)δ(y)</code>. For an LSI system, the image field is a convolution:
            <code>g = f * h</code>. Convolving with a delta simply shifts:
          </p>

          <div class="eq" id="eq-conv">
            <button class="copy" data-copy-target="eq-conv">Copy</button>
            <div>
              g(x,y) = h(x,y) + h(x-b,y).
            </div>
          </div>

          <p>
            Along the line <code>y=0</code>, use <code>sinc(0)=1</code>:
          </p>

          <div class="eq" id="eq-gx0">
            <button class="copy" data-copy-target="eq-gx0">Copy</button>
            <div>
              g(x,0) = C[ sinc(x/w) + sinc((x-b)/w) ].
            </div>
          </div>

          <p>
            Since the expression is real (with our choice of phase reference), the magnitude is simply
            <code>|g(x,0)| = |C| · |sinc(x/w) + sinc((x-b)/w)|</code>.
          </p>

          <div class="hr"></div>

          <h3 style="margin:0 0 6px;">(c) Sketches for <code>w=λ d₂/D = 0.1 mm</code> and minimum separation for two peaks</h3>
          <p>
            For the requested sketches, we set <code>w=0.1 mm</code> and plot <code>|g(x,0)|</code> for <code>b=0.5, 1, 2 mm</code>.
            Qualitatively, these separations are <code>b/w = 5, 10, 20</code>, so the two sinc lobes overlap weakly and two peaks are obvious.
          </p>

          <p>
            To find the <em>minimum</em> separation where the image shows <strong>two peaks</strong>, exploit symmetry:
            the two equal points imply the profile is symmetric about the midpoint <code>x=b/2</code>.
            Define <code>t = x - b/2</code> and <code>a = b/(2w)</code>. Then
          </p>

          <div class="eq" id="eq-even">
            <button class="copy" data-copy-target="eq-even">Copy</button>
            <div>
              g(t,0)/C = sinc((t/w)+a) + sinc((t/w)-a),
              where a = b/(2w).
            </div>
          </div>

          <p>
            This is an even function of <code>t</code>, so the midpoint (<code>t=0</code>) always satisfies <code>dg/dt=0</code>.
            Whether the midpoint is a <em>maximum</em> (single merged spot) or a <em>minimum</em> (two separated peaks)
            is decided by the second derivative at <code>t=0</code>.
          </p>

          <div class="callout">
            <h3>Two-peak criterion (as asked: “has two peaks”)</h3>
            <p style="margin:0;">
              The image shows two peaks when the midpoint becomes a local <strong>minimum</strong>:
              <code>d²|g|/dt² &gt; 0</code> at <code>t=0</code>.
              Since <code>g</code> is real and typically positive near the threshold, we can use the sign of <code>d²g/dt²</code> at the midpoint.
              The threshold occurs when <code>d²g/dt² = 0</code> at <code>t=0</code>.
            </p>
          </div>

          <p>
            Differentiating (details omitted only for the algebraic length, but the result is straightforward chain rule),
            one finds
          </p>

          <div class="eq" id="eq-gpp">
            <button class="copy" data-copy-target="eq-gpp">Copy</button>
            <div>
              d²g/dt² |_{t=0} = (2C/w²) · sinc''(a),
              where sinc'' is the second derivative of sinc(u)=sin(πu)/(πu).
            </div>
          </div>

          <p>
            Therefore, the <strong>threshold</strong> between one peak and two peaks is
            <code>sinc''(a)=0</code> with the smallest positive root <code>a=a₀</code>.
            Solving this numerically gives
            <code>a₀ ≈ 0.6626</code>, hence
          </p>

          <div class="eq" id="eq-bmin">
            <button class="copy" data-copy-target="eq-bmin">Copy</button>
            <div>
              b_min = 2 w a₀ ≈ 2 w (0.6626) ≈ 1.325×w.
            </div>
          </div>

          <p>
            With <code>w = 0.1 mm</code>:
            <code>b_min ≈ 0.1325 mm</code>.
          </p>

          <div class="callout ok">
            <h3>Sanity checks</h3>
            <ul style="margin:0; padding-left:18px;">
              <li><strong>Units:</strong> <code>b_min</code> scales with <code>w</code>, which has units of length → consistent.</li>
              <li><strong>Limiting case:</strong> if <code>D → ∞</code>, then <code>w=λ d₂/D → 0</code>, so <code>b_min → 0</code> (perfect resolution) → makes sense.</li>
              <li><strong>Physical meaning:</strong> <code>w</code> is the diffraction blur scale set by wavelength and aperture size; two points must be separated by a bit more than ~1.3 blur widths to form two maxima (for this coherent “two peaks” criterion).</li>
            </ul>
          </div>
        </article>
      </div>
    </section>

    <!-- VIZ -->
    <section id="viz" class="card viz" aria-label="Interactive Visualizations">
      <div class="vizhead">
        <div>
          <h3>Interactive Visualizations</h3>
          <div class="muted" style="font-size:.95rem;margin-top:3px;">
            Uses the same model as the derivation: <code>h(x,y)=C·sinc(x/w)sinc(y/w)</code>, <code>g(x,0)=C[sinc(x/w)+sinc((x-b)/w)]</code>, with <code>w=λd₂/D</code>.
          </div>
        </div>

        <div class="controls" role="group" aria-label="Interactive controls">
          <div class="ctrl">
            <label for="bSlider">Separation b (mm)</label>
            <input id="bSlider" type="range" min="0" max="2.5" step="0.01" value="1.00" />
            <output id="bOut">1.00</output>
          </div>
          <div class="ctrl">
            <label for="wSlider">Scale w=λd₂/D (mm)</label>
            <input id="wSlider" type="range" min="0.03" max="0.30" step="0.005" value="0.10" />
            <output id="wOut">0.100</output>
          </div>
          <div class="ctrl" style="min-width:170px;justify-content:space-between;">
            <label style="min-width:auto;">Presets</label>
            <button id="preset05">b=0.5</button>
            <button id="preset10">b=1</button>
            <button id="preset20">b=2</button>
          </div>
        </div>
      </div>

      <figure>
        <canvas id="canvasDiagram" aria-label="Labeled diagram of the imaging setup"></canvas>
        <div class="caption">
          <strong>Diagram:</strong> Two object points separated by <code>b</code> are imaged by a lens with square aperture width <code>D</code>.
          Diffraction from the finite aperture creates a sinc-like impulse response in the image plane with scale <code>w=λd₂/D</code>.
        </div>
      </figure>

      <figure>
        <canvas id="canvasMain" aria-label="Main plot of |g(x,0)|"></canvas>
        <div class="caption">
          <strong>Main plot:</strong> The magnitude profile <code>|g(x,0)|</code> (normalized by <code>|C|</code>) for the current <code>b</code> and <code>w</code>.
        </div>
      </figure>

      <figure>
        <canvas id="canvasSweep" aria-label="Secondary plot: midpoint curvature and two-peak threshold"></canvas>
        <div class="caption">
          <strong>Secondary plot:</strong> Parameter sweep over <code>b</code>: sign of the midpoint curvature
          <code>g''(x=b/2)</code> (scaled) indicates whether the midpoint is a maximum (single peak) or minimum (two peaks).
          The threshold is where the curve crosses zero.
        </div>
      </figure>
    </section>

    <!-- FINAL -->
    <section id="final" class="card">
      <div class="hd">
        <h2>Final Results</h2>
      </div>
      <div class="bd">
        <div class="boxed">
          <h3>Answer (symbolic)</h3>
          <div class="big" id="ans-symbolic">
            <button class="copy" data-copy-target="ans-symbolic">Copy</button>
            <div>
              Define sinc(u)=sin(πu)/(πu) and w=λ d₂/D.
              <br><br>
              (a) h(x,y)=C·sinc(x/w)·sinc(y/w).
              <br>
              (b) For f(x,y)=δ(x)δ(y)+δ(x-b)δ(y):
              g(x,y)=h(x,y)+h(x-b,y),
              so g(x,0)=C[ sinc(x/w)+sinc((x-b)/w) ] and |g(x,0)|=|C|·|sinc(x/w)+sinc((x-b)/w)|.
              <br>
              (c) Two peaks appear when the midpoint becomes a minimum; threshold satisfies sinc''(a)=0 with a=b/(2w).
              Smallest positive root a₀≈0.6626 ⇒ b_min≈2wa₀≈1.325w.
            </div>
          </div>
        </div>

        <div class="boxed" style="margin-top:14px;">
          <h3>Answer (numerical for λ d₂/D = 0.1 mm)</h3>
          <div class="big" id="ans-numeric">
            <button class="copy" data-copy-target="ans-numeric">Copy</button>
            <div>
              With w=0.1 mm:
              <br>
              b_min ≈ 1.325·w ≈ 0.1325 mm.
              <br><br>
              For b=0.5, 1, 2 mm (i.e., b/w=5,10,20), the plot |g(x,0)| clearly shows two separated peaks.
            </div>
          </div>
        </div>

        <p class="note" style="margin-top:12px;">
          If you want, you can use the sliders above to see how changing the aperture scale <code>w</code> shifts the two-peak threshold.
        </p>
      </div>
    </section>

    <footer>
      Built with vanilla HTML/CSS/JS. Copy buttons copy plain text equations/results.
    </footer>
  </main>

  <script>
    // ---------- Utilities ----------
    function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

    function sinc(u){
      // sinc(u) = sin(pi u)/(pi u) with safe u=0
      const pu = Math.PI*u;
      if (Math.abs(pu) < 1e-12) return 1.0;
      return Math.sin(pu)/pu;
    }

    // Numerical derivatives of sinc for sweep plot (stable enough for visualization)
    function sinc2(u){
      // second derivative via central difference
      const h = 1e-4;
      return (sinc(u+h) - 2*sinc(u) + sinc(u-h)) / (h*h);
    }

    // HiDPI canvas setup
    function setupCanvas(canvas){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(10, Math.floor(rect.width));
      const h = Math.max(10, Math.floor(rect.height));
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {ctx, w, h, dpr};
    }

    function clear(ctx, w, h){
      ctx.clearRect(0,0,w,h);
      // soft background tint for plot area is drawn later
    }

    function drawPanelBG(ctx, x,y,w,h){
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.18)';
      ctx.strokeStyle = 'rgba(255,255,255,0.10)';
      ctx.lineWidth = 1;
      roundRect(ctx, x,y,w,h,14);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
      const {x,y,w,h, padL, padR, padT, padB} = box;
      const px0 = x+padL, px1 = x+w-padR;
      const py0 = y+padT, py1 = y+h-padB;

      // background
      drawPanelBG(ctx, x,y,w,h);

      // title
      ctx.save();
      ctx.fillStyle = 'rgba(229,231,235,0.95)';
      ctx.font = '600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText(title, x+14, y+20);
      ctx.restore();

      // grid and ticks
      const nXTicks = 6;
      const nYTicks = 5;

      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;

      // vertical grid
      for(let i=0;i<=nXTicks;i++){
        const t = i/nXTicks;
        const X = px0 + t*(px1-px0);
        ctx.beginPath();
        ctx.moveTo(X, py0);
        ctx.lineTo(X, py1);
        ctx.stroke();
      }
      // horizontal grid
      for(let j=0;j<=nYTicks;j++){
        const t = j/nYTicks;
        const Y = py1 - t*(py1-py0);
        ctx.beginPath();
        ctx.moveTo(px0, Y);
        ctx.lineTo(px1, Y);
        ctx.stroke();
      }
      ctx.restore();

      // axes lines
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.22)';
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(px0, py1);
      ctx.lineTo(px1, py1);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(px0, py0);
      ctx.lineTo(px0, py1);
      ctx.stroke();
      ctx.restore();

      // tick labels
      ctx.save();
      ctx.fillStyle = 'rgba(167,176,192,0.95)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';

      for(let i=0;i<=nXTicks;i++){
        const t = i/nXTicks;
        const xv = xMin + t*(xMax-xMin);
        const X = px0 + t*(px1-px0);
        const s = formatTick(xv);
        ctx.fillText(s, X-ctx.measureText(s).width/2, py1+18);
      }
      for(let j=0;j<=nYTicks;j++){
        const t = j/nYTicks;
        const yv = yMin + t*(yMax-yMin);
        const Y = py1 - t*(py1-py0);
        const s = formatTick(yv);
        ctx.fillText(s, px0-8-ctx.measureText(s).width, Y+4);
      }

      // labels
      ctx.fillStyle = 'rgba(229,231,235,0.92)';
      ctx.font = '13px system-ui, -apple-system, Segoe UI, Roboto, Arial';

      // x label
      const xlw = ctx.measureText(xLabel).width;
      ctx.fillText(xLabel, px0 + (px1-px0)/2 - xlw/2, y+h-10);

      // y label rotated
      ctx.save();
      ctx.translate(x+12, py0 + (py1-py0)/2);
      ctx.rotate(-Math.PI/2);
      const ylw = ctx.measureText(yLabel).width;
      ctx.fillText(yLabel, -ylw/2, 0);
      ctx.restore();

      ctx.restore();

      // Return mapping functions
      const Xmap = (xv)=> px0 + (xv-xMin)*(px1-px0)/(xMax-xMin);
      const Ymap = (yv)=> py1 - (yv-yMin)*(py1-py0)/(yMax-yMin);
      return {px0,px1,py0,py1,Xmap,Ymap};
    }

    function formatTick(v){
      const av = Math.abs(v);
      if (av >= 10) return v.toFixed(0);
      if (av >= 1) return v.toFixed(2);
      if (av >= 0.1) return v.toFixed(3);
      return v.toFixed(4);
    }

    function plotLine(ctx, map, xs, ys, style){
      ctx.save();
      ctx.strokeStyle = style.stroke || 'rgba(125,211,252,0.95)';
      ctx.lineWidth = style.width || 2;
      ctx.beginPath();
      for(let i=0;i<xs.length;i++){
        const X = map.Xmap(xs[i]);
        const Y = map.Ymap(ys[i]);
        if(i===0) ctx.moveTo(X,Y);
        else ctx.lineTo(X,Y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawLegend(ctx, x, y, items){
      ctx.save();
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';
      const pad = 10;
      let w = 0;
      items.forEach(it=>{
        const tw = ctx.measureText(it.text).width;
        w = Math.max(w, tw);
      });
      const boxW = w + 54;
      const boxH = items.length*18 + pad*2 - 4;
      ctx.fillStyle = 'rgba(0,0,0,0.28)';
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      roundRect(ctx, x, y, boxW, boxH, 12);
      ctx.fill();
      ctx.stroke();

      items.forEach((it, i)=>{
        const yy = y + pad + i*18 + 2;
        // line swatch
        ctx.strokeStyle = it.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x+12, yy+4);
        ctx.lineTo(x+28, yy+4);
        ctx.stroke();
        ctx.fillStyle = 'rgba(229,231,235,0.92)';
        ctx.fillText(it.text, x+34, yy+8);
      });
      ctx.restore();
    }

    // ---------- Diagram ----------
    function drawDiagram(canvas, params){
      const {ctx, w, h} = setupCanvas(canvas);
      clear(ctx,w,h);

      // base card background
      drawPanelBG(ctx, 10, 10, w-20, h-20);

      // coordinate system
      ctx.save();
      const left = 40, right = w-40, top = 46, bottom = h-44;
      const midY = (top+bottom)/2;

      // labels
      ctx.fillStyle = 'rgba(229,231,235,0.92)';
      ctx.font = '600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Imaging geometry (unit magnification, perfect focus)', left, 34);

      // object plane, lens plane, image plane positions
      const xObj = left+40;
      const xLens = (left+right)/2;
      const xImg  = right-40;

      // planes
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 1.2;

      // object plane line
      ctx.beginPath(); ctx.moveTo(xObj, top); ctx.lineTo(xObj, bottom); ctx.stroke();
      // lens plane line
      ctx.beginPath(); ctx.moveTo(xLens, top); ctx.lineTo(xLens, bottom); ctx.stroke();
      // image plane line
      ctx.beginPath(); ctx.moveTo(xImg, top); ctx.lineTo(xImg, bottom); ctx.stroke();

      // plane labels
      ctx.fillStyle = 'rgba(167,176,192,0.95)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';
      ctx.fillText('Object plane', xObj-36, bottom+18);
      ctx.fillText('Lens plane', xLens-30, bottom+18);
      ctx.fillText('Image plane', xImg-34, bottom+18);

      // two object points separated by b
      const b = params.b;
      // map b (mm) to pixels for diagram (purely illustrative)
      const bPx = clamp((b/2.5) * 110, 10, 110);
      const yP1 = midY - bPx/2;
      const yP2 = midY + bPx/2;

      // points
      function drawPoint(x,y,color){
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.arc(x, y, 4.2, 0, Math.PI*2); ctx.fill();
      }
      drawPoint(xObj, yP1, 'rgba(125,211,252,0.95)');
      drawPoint(xObj, yP2, 'rgba(125,211,252,0.95)');

      // separation bracket
      ctx.strokeStyle = 'rgba(125,211,252,0.85)';
      ctx.lineWidth = 1.4;
      ctx.beginPath();
      ctx.moveTo(xObj-14, yP1); ctx.lineTo(xObj-22, yP1);
      ctx.moveTo(xObj-14, yP2); ctx.lineTo(xObj-22, yP2);
      ctx.moveTo(xObj-22, yP1); ctx.lineTo(xObj-22, yP2);
      ctx.stroke();
      ctx.fillStyle = 'rgba(125,211,252,0.95)';
      ctx.fillText('b', xObj-32, midY+4);

      // lens aperture: square
      const Dbox = 46;
      ctx.strokeStyle = 'rgba(167,139,250,0.95)';
      ctx.lineWidth = 2;
      ctx.strokeRect(xLens - Dbox/2, midY - Dbox/2, Dbox, Dbox);
      ctx.fillStyle = 'rgba(167,139,250,0.95)';
      ctx.fillText('Square aperture (width D)', xLens - 80, top+18);

      // rays (stylized)
      ctx.strokeStyle = 'rgba(255,255,255,0.16)';
      ctx.lineWidth = 1.2;
      const yImg1 = midY - bPx/2;
      const yImg2 = midY + bPx/2;
      // from each point to lens edges, then to image plane
      function drawRay(y0, yL, y1){
        ctx.beginPath();
        ctx.moveTo(xObj, y0);
        ctx.lineTo(xLens, yL);
        ctx.lineTo(xImg, y1);
        ctx.stroke();
      }
      drawRay(yP1, midY - Dbox/2, yImg1);
      drawRay(yP1, midY + Dbox/2, yImg1);
      drawRay(yP2, midY - Dbox/2, yImg2);
      drawRay(yP2, midY + Dbox/2, yImg2);

      // blur note
      ctx.fillStyle = 'rgba(229,231,235,0.92)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Diffraction blur scale:  w = λ d₂ / D', xImg - 190, top+18);

      // small PSF sketch on image plane
      ctx.strokeStyle = 'rgba(125,211,252,0.75)';
      ctx.lineWidth = 2;
      // draw two overlapping sinc-like lobes (schematic)
      function drawSincSketch(cx, cy, amp){
        const L = 60;
        ctx.beginPath();
        for(let i=0;i<=160;i++){
          const t = (i/160)*2 - 1; // -1..1
          const x = cx + t*L;
          const u = t*3;
          const y = cy - amp*sinc(u);
          if(i===0) ctx.moveTo(x,y);
          else ctx.lineTo(x,y);
        }
        ctx.stroke();
      }
      drawSincSketch(xImg, yImg1, 18);
      drawSincSketch(xImg, yImg2, 18);

      ctx.restore();
    }

    // ---------- Main plot: |g(x,0)| ----------
    function drawMainPlot(canvas, params){
      const {ctx, w, h} = setupCanvas(canvas);
      clear(ctx,w,h);

      const box = {x:10,y:10,w:w-20,h:h-20,padL:60,padR:18,padT:36,padB:46};

      const b = params.b;      // mm
      const W = params.w;      // mm (w scale)

      // choose x-range to show both peaks clearly
      const margin = Math.max(0.6, 6*W);
      const xMin = -margin;
      const xMax = b + margin;

      // compute samples
      const N = 900;
      const xs = new Array(N);
      const ys = new Array(N);
      let yMax = 0;

      for(let i=0;i<N;i++){
        const x = xMin + (xMax-xMin)*i/(N-1);
        const g = sinc(x/W) + sinc((x-b)/W);
        const mag = Math.abs(g); // normalized by |C|
        xs[i]=x;
        ys[i]=mag;
        if(mag>yMax) yMax=mag;
      }

      // y bounds
      const yMin = 0;
      const yTop = Math.max(1.2, yMax*1.08);

      const map = drawAxes(
        ctx, box,
        xMin, xMax, yMin, yTop,
        'x (mm)', '|g(x,0)| / |C|',
        'Main: Two-point image magnitude profile'
      );

      // plot
      plotLine(ctx, map, xs, ys, {stroke:'rgba(125,211,252,0.95)', width:2.2});

      // midpoint marker
      ctx.save();
      const xm = b/2;
      const gm = Math.abs(sinc(xm/W) + sinc((xm-b)/W)); // same
      const X = map.Xmap(xm);
      const Y = map.Ymap(gm);
      ctx.fillStyle = 'rgba(167,139,250,0.95)';
      ctx.beginPath(); ctx.arc(X, Y, 4.2, 0, Math.PI*2); ctx.fill();

      // vertical line at midpoint
      ctx.strokeStyle = 'rgba(167,139,250,0.35)';
      ctx.lineWidth = 1.4;
      ctx.beginPath();
      ctx.moveTo(X, map.py0);
      ctx.lineTo(X, map.py1);
      ctx.stroke();

      ctx.restore();

      // legend
      drawLegend(ctx, box.x + box.w - 210, box.y + 46, [
        {text:`b=${b.toFixed(2)} mm`, color:'rgba(125,211,252,0.95)'},
        {text:`w=${W.toFixed(3)} mm`, color:'rgba(167,139,250,0.95)'}
      ]);
    }

    // ---------- Secondary sweep plot: midpoint curvature vs b ----------
    function drawSweep(canvas, params){
      const {ctx, w, h} = setupCanvas(canvas);
      clear(ctx,w,h);

      const box = {x:10,y:10,w:w-20,h:h-20,padL:60,padR:18,padT:36,padB:46};

      const W = params.w; // mm
      const bNow = params.b;

      // sweep b from 0 to 2.5 mm (matches slider max)
      const bMin = 0;
      const bMax = 2.5;

      const N = 550;
      const bs = new Array(N);
      const ks = new Array(N);

      // We plot K(b) = sinc''(a) with a=b/(2w), scaled (sign matters)
      // Midpoint curvature: g''(mid) ∝ sinc''(a). Two peaks when this is >0 (midpoint minimum).
      let kAbsMax = 0;
      for(let i=0;i<N;i++){
        const b = bMin + (bMax-bMin)*i/(N-1);
        const a = b/(2*W);
        const k = sinc2(a);
        bs[i]=b;
        ks[i]=k;
        kAbsMax = Math.max(kAbsMax, Math.abs(k));
      }

      const yLim = Math.max(0.5, kAbsMax*1.08);
      const map = drawAxes(
        ctx, box,
        bMin, bMax, -yLim, yLim,
        'b (mm)', 'Scaled midpoint curvature  ~ sinc\'\'(b/(2w))',
        'Secondary: Two-peak threshold (sign change at midpoint)'
      );

      // zero line
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.22)';
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(map.px0, map.Ymap(0));
      ctx.lineTo(map.px1, map.Ymap(0));
      ctx.stroke();
      ctx.restore();

      // curve
      plotLine(ctx, map, bs, ks, {stroke:'rgba(167,139,250,0.95)', width:2.2});

      // highlight current b
      const aNow = bNow/(2*W);
      const kNow = sinc2(aNow);

      ctx.save();
      const X = map.Xmap(bNow);
      const Y = map.Ymap(kNow);

      // vertical marker
      ctx.strokeStyle = 'rgba(125,211,252,0.35)';
      ctx.lineWidth = 1.4;
      ctx.beginPath();
      ctx.moveTo(X, map.py0);
      ctx.lineTo(X, map.py1);
      ctx.stroke();

      // point marker
      ctx.fillStyle = 'rgba(125,211,252,0.95)';
      ctx.beginPath(); ctx.arc(X, Y, 4.2, 0, Math.PI*2); ctx.fill();

      // region labels: one peak vs two peaks based on sign
      ctx.fillStyle = 'rgba(229,231,235,0.90)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Midpoint is a MAX → single peak', map.px0 + 10, map.py0 + 18);
      ctx.fillText('Midpoint is a MIN → two peaks', map.px0 + 10, map.py1 - 10);

      ctx.restore();

      // Estimate threshold root for this W by scanning for first sign change from negative to positive
      let bThresh = null;
      for(let i=1;i<N;i++){
        if(ks[i-1] < 0 && ks[i] >= 0){
          // linear interpolation near crossing
          const b1 = bs[i-1], b2 = bs[i];
          const k1 = ks[i-1], k2 = ks[i];
          const t = (0 - k1) / (k2 - k1 + 1e-15);
          bThresh = b1 + t*(b2-b1);
          break;
        }
      }

      // annotate threshold
      if(bThresh !== null){
        ctx.save();
        const XT = map.Xmap(bThresh);
        ctx.strokeStyle = 'rgba(251,191,36,0.55)';
        ctx.lineWidth = 1.6;
        ctx.beginPath();
        ctx.moveTo(XT, map.py0);
        ctx.lineTo(XT, map.py1);
        ctx.stroke();
        ctx.fillStyle = 'rgba(251,191,36,0.95)';
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';
        const txt = `b_min≈${bThresh.toFixed(4)} mm`;
        const tw = ctx.measureText(txt).width;
        ctx.fillText(txt, clamp(XT - tw/2, map.px0+6, map.px1-tw-6), map.py0 + 36);
        ctx.restore();
      }

      // legend
      const status = (kNow > 0) ? 'two peaks' : 'single peak';
      drawLegend(ctx, box.x + box.w - 260, box.y + 46, [
        {text:`current: ${status}`, color:'rgba(125,211,252,0.95)'},
        {text:`w=${W.toFixed(3)} mm`, color:'rgba(167,139,250,0.95)'}
      ]);
    }

    // ---------- Copy buttons ----------
    function attachCopyHandlers(){
      const btns = document.querySelectorAll('button.copy');
      btns.forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          const id = btn.getAttribute('data-copy-target');
          const el = document.getElementById(id);
          if(!el) return;
          // get plain text from the content div
          const text = el.innerText.replace(/\s+\n/g,"\n").trim();
          try{
            await navigator.clipboard.writeText(text);
            const old = btn.textContent;
            btn.textContent = 'Copied!';
            setTimeout(()=>btn.textContent = old, 900);
          }catch(e){
            // fallback
            const ta = document.createElement('textarea');
            ta.value = text;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
            const old = btn.textContent;
            btn.textContent = 'Copied!';
            setTimeout(()=>btn.textContent = old, 900);
          }
        });
      });
    }

    // ---------- State + render loop ----------
    const state = {
      b: 1.00,   // mm
      w: 0.10    // mm
    };

    const els = {
      bSlider: document.getElementById('bSlider'),
      wSlider: document.getElementById('wSlider'),
      bOut: document.getElementById('bOut'),
      wOut: document.getElementById('wOut'),
      preset05: document.getElementById('preset05'),
      preset10: document.getElementById('preset10'),
      preset20: document.getElementById('preset20'),
      cDiag: document.getElementById('canvasDiagram'),
      cMain: document.getElementById('canvasMain'),
      cSweep: document.getElementById('canvasSweep'),
    };

    function renderAll(){
      // update outputs
      els.bOut.textContent = Number(state.b).toFixed(2);
      els.wOut.textContent = Number(state.w).toFixed(3);

      // draw
      drawDiagram(els.cDiag, state);
      drawMainPlot(els.cMain, state);
      drawSweep(els.cSweep, state);
    }

    function setB(v){
      state.b = clamp(Number(v), 0, 2.5);
      els.bSlider.value = state.b;
      renderAll();
    }
    function setW(v){
      state.w = clamp(Number(v), 0.03, 0.30);
      els.wSlider.value = state.w;
      renderAll();
    }

    // events
    els.bSlider.addEventListener('input', (e)=> setB(e.target.value));
    els.wSlider.addEventListener('input', (e)=> setW(e.target.value));
    els.preset05.addEventListener('click', ()=> setB(0.5));
    els.preset10.addEventListener('click', ()=> setB(1.0));
    els.preset20.addEventListener('click', ()=> setB(2.0));

    // resize
    let resizeTimer = null;
    window.addEventListener('resize', ()=>{
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(renderAll, 80);
    });

    // TOC smooth scroll
    document.querySelectorAll('.toc a').forEach(a=>{
      a.addEventListener('click', (e)=>{
        e.preventDefault();
        const id = a.getAttribute('href').slice(1);
        const target = document.getElementById(id);
        if(target) target.scrollIntoView({behavior:'smooth', block:'start'});
      });
    });

    // init
    attachCopyHandlers();
    renderAll();
  </script>
</body>
</html>
