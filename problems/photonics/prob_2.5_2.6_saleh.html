<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="color-scheme" content="dark" />
  <meta name="theme-color" content="#07090c" />
  <title>Michelson Misalignment & Pulsed Spherical Wave — Full Worked Solution (Interactive)</title>
  <style>
    :root{
      --bg0:#07090c; --bg1:#0b0f16; --card:#0e1522; --card2:#0c121e;
      --txt:#e9edf6; --muted:#aab6cc; --faint:#6f7d98;
      --acc:#7dd3fc; --acc2:#a78bfa; --good:#34d399; --warn:#fbbf24;
      --line:rgba(255,255,255,.10); --line2:rgba(255,255,255,.16);
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 600px at 15% 0%, rgba(125,211,252,.10), transparent 60%),
                  radial-gradient(1000px 700px at 90% 10%, rgba(167,139,250,.10), transparent 55%),
                  linear-gradient(180deg, var(--bg0), var(--bg1));
      color:var(--txt);
      line-height:1.55;
    }
    a{color:var(--acc); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding: clamp(18px, 3vw, 28px);
      border-bottom:1px solid var(--line);
      position:relative;
      overflow:hidden;
    }
    header::after{
      content:"";
      position:absolute; inset:-60px -80px auto auto;
      width:280px; height:280px;
      background: radial-gradient(circle at 30% 30%, rgba(125,211,252,.25), transparent 55%);
      filter: blur(2px);
      transform: rotate(12deg);
      pointer-events:none;
    }
    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding: 0 clamp(16px, 3vw, 26px) 80px;
    }
    .title{
      display:grid;
      grid-template-columns: 1.35fr .65fr;
      gap:18px;
      align-items:end;
    }
    @media (max-width: 920px){
      .title{grid-template-columns:1fr}
    }
    h1{
      margin: 10px 0 8px;
      font-size: clamp(1.4rem, 2.8vw, 2.2rem);
      letter-spacing: .2px;
    }
    .subtitle{color:var(--muted); margin:0 0 4px; max-width:72ch}
    .pillrow{display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:flex-end}
    .pill{
      display:inline-flex; gap:8px; align-items:center;
      padding:8px 10px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      border-radius:999px;
      font-size:.9rem;
      color:var(--muted);
    }
    .pill b{color:var(--txt); font-weight:700}
    main{margin-top:18px}
    .grid{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }
    nav.toc{
      position:sticky;
      top:14px;
      align-self:start;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.015));
      border-radius:16px;
      padding:14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }
    nav.toc h2{
      font-size:1rem; margin:0 0 10px;
      display:flex; align-items:center; justify-content:space-between;
      color:var(--txt);
    }
    .toc small{color:var(--faint)}
    .toc a{
      display:block;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid transparent;
      color:var(--muted);
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
    }
    .toc a:hover{
      background: rgba(125,211,252,.08);
      border-color: rgba(125,211,252,.20);
      transform: translateX(2px);
      text-decoration:none;
      color:var(--txt);
    }
    .content{
      display:flex;
      flex-direction:column;
      gap:16px;
      min-width:0;
    }
    section, article{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.012));
      border-radius:18px;
      padding: clamp(14px, 2.2vw, 18px);
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    section::before{
      content:"";
      position:absolute; inset:0 0 auto 0;
      height:1px;
      background: linear-gradient(90deg, transparent, rgba(125,211,252,.35), transparent);
      opacity:.55;
    }
    h2{
      margin: 0 0 10px;
      font-size: 1.15rem;
      letter-spacing:.2px;
    }
    h3{
      margin: 14px 0 8px;
      font-size: 1.02rem;
      color:var(--txt);
    }
    p{margin: 8px 0; color:var(--txt)}
    ul{margin: 8px 0 8px 18px; color:var(--txt)}
    li{margin: 6px 0}
    .muted{color:var(--muted)}
    .callouts{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap:12px;
      margin-top:10px;
    }
    @media (max-width: 920px){
      .callouts{grid-template-columns:1fr}
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.012));
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px;
      min-width:0;
    }
    .card h4{margin:0 0 6px; font-size:.95rem}
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line2);
      background: rgba(255,255,255,.03);
      color:var(--muted);
      font-size:.9rem;
      margin-bottom:10px;
    }
    .badge .dot{width:8px; height:8px; border-radius:50%;}
    .dot.acc{background:var(--acc)}
    .dot.acc2{background:var(--acc2)}
    .dot.good{background:var(--good)}
    .eq{
      font-family: var(--mono);
      font-size: .95rem;
      background: rgba(0,0,0,.24);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px 12px;
      overflow:auto;
      margin:10px 0;
      position:relative;
    }
    .eq .copybtn{
      position:absolute; top:8px; right:8px;
      border:1px solid var(--line2);
      background: rgba(255,255,255,.04);
      color:var(--txt);
      border-radius:10px;
      padding:6px 10px;
      font-size:.82rem;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease;
    }
    .eq .copybtn:hover{transform: translateY(-1px); background: rgba(125,211,252,.10)}
    .box{
      border:1px solid rgba(52,211,153,.35);
      background: radial-gradient(700px 240px at 25% 0%, rgba(52,211,153,.12), transparent 55%),
                  rgba(0,0,0,.18);
      border-radius:16px;
      padding:12px;
      margin:12px 0;
    }
    .box h3{margin-top:0}
    .kpi{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 920px){
      .kpi{grid-template-columns:1fr}
    }
    .kpi .k{
      border:1px solid var(--line);
      background: rgba(255,255,255,.02);
      border-radius:14px;
      padding:10px;
    }
    .k .label{color:var(--muted); font-size:.86rem}
    .k .value{font-size:1.08rem; font-weight:800; margin-top:2px}
    .visgrid{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:12px;
      align-items:stretch;
      margin-top:10px;
    }
    @media (max-width: 980px){
      .visgrid{grid-template-columns:1fr}
    }
    figure{
      margin:0;
      border:1px solid var(--line);
      border-radius:16px;
      background: rgba(0,0,0,.18);
      overflow:hidden;
      min-width:0;
      display:flex;
      flex-direction:column;
    }
    figcaption{
      padding:10px 12px;
      border-top:1px solid var(--line);
      color:var(--muted);
      font-size:.9rem;
    }
    canvas{display:block; width:100%; height:340px}
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 920px){ .controls{grid-template-columns:1fr} }
    .ctl{
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px 12px;
      background: rgba(255,255,255,.02);
    }
    .ctl label{display:flex; justify-content:space-between; gap:10px; color:var(--muted); font-size:.9rem}
    .ctl label b{color:var(--txt)}
    input[type="range"]{width:100%}
    .note{
      color:var(--muted);
      font-size:.92rem;
      border-left: 3px solid rgba(125,211,252,.5);
      padding-left:10px;
      margin:10px 0;
    }
    .split{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 980px){ .split{grid-template-columns:1fr} }
    footer{
      margin-top:18px;
      color:var(--faint);
      font-size:.9rem;
      text-align:center;
      padding:18px 0 0;
    }
    .hr{height:1px; background: var(--line); margin:14px 0}
    .toast{
      position:fixed;
      bottom:16px; left:50%;
      transform: translateX(-50%);
      background: rgba(15,23,42,.92);
      border:1px solid var(--line2);
      color:var(--txt);
      padding:10px 12px;
      border-radius:12px;
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      font-size:.92rem;
      z-index:99;
      backdrop-filter: blur(8px);
    }
    .toast.show{opacity:1; transform: translateX(-50%) translateY(-2px)}
    @media print{
      nav.toc{position:static; box-shadow:none}
      section, article{box-shadow:none}
      .toast{display:none}
      .eq .copybtn{display:none}
      header::after{display:none}
      body{background:#fff; color:#000}
      section, article, nav.toc, figure{background:#fff}
      .muted, .note, figcaption{color:#333}
      a{color:#000; text-decoration:underline}
    }
  </style>
</head>

<body>
<header>
  <div class="wrap title">
    <div>
      <p class="subtitle">Expert physics tutor solution with interactive diagrams and plots (vanilla HTML/CSS/JS).</p>
      <h1>Michelson Interferometer Misalignment & Pulsed Spherical Wave</h1>
      <p class="subtitle muted">Covers: (1) fringe shape under a small mirror tilt and how fringes move when the other mirror translates; (2) outgoing pulsed spherical-wave solutions and ultrashort-pulse spatial intensity at a fixed time.</p>
    </div>
    <div class="pillrow">
      <span class="pill"><b>Interactive</b> canvas plots</span>
      <span class="pill"><b>Copy</b> equations & final results</span>
      <span class="pill"><b>Print</b>-friendly</span>
    </div>
  </div>
</header>

<div class="wrap">
  <main class="grid">
    <nav class="toc" aria-label="Table of contents">
      <h2>Contents <small>sticky</small></h2>
      <a href="#quick">Quick Summary</a>
      <a href="#part1">PART 1 — Problem Analysis</a>
      <a href="#part2">PART 2 — Strategy & Tips</a>
      <a href="#part3">PART 3 — Full Solution</a>
      <a href="#viz">Interactive Visualizations</a>
      <a href="#final">Final Answers (copy)</a>
    </nav>

    <div class="content">
      <section id="quick">
        <span class="badge"><span class="dot acc"></span>Quick Summary</span>
        <ul>
          <li><b>Michelson + small mirror tilt Δθ:</b> recombining beams have a small crossing angle, producing <b>straight, parallel fringes</b> (equal-thickness / Fizeau-type) in the detector plane.</li>
          <li><b>Fringe spacing:</b> for crossing angle β, spacing is <span class="muted">p = λ / (2 sin(β/2))</span>. In a Michelson, a mirror tilt Δθ makes β ≈ 2Δθ, so <b>p ≈ λ / (2Δθ)</b> (small-angle).</li>
          <li><b>Moving the other mirror:</b> changes the uniform phase offset, so the whole fringe system <b>slides</b>; at a fixed point intensity oscillates as fringes pass by.</li>
          <li><b>Pulsed spherical wave:</b> the 3D wave equation admits <b>U(r,t) = (1/r) a(t − r/c)</b> for an outgoing pulse (arbitrary waveform <i>a</i>).</li>
          <li><b>Cycles in a 6 fs RMS Gaussian at λ₀=585 nm:</b> about <b>~3.1 optical cycles per RMS width</b> (and ~7.2 per FWHM).</li>
          <li><b>At t = 1 ps:</b> intensity is a <b>thin spherical shell</b> centered near <b>r = ct</b> with thickness ~ <b>cσ<sub>t</sub></b>, and amplitude decays as <b>1/r</b> (intensity ∝ 1/r²).</li>
        </ul>
      </section>

      <!-- PART 1 -->
      <section id="part1">
        <h2>PART 1 — Problem Analysis (no solving yet)</h2>

        <h3>1) Rewrite the problem (in clear words)</h3>
        <p>
          <b>(A) Michelson interferometer:</b> If one Michelson mirror is slightly tilted by a small angle Δθ, describe what the interference pattern looks like on the detector plane. Then explain what happens to this pattern when the other mirror translates (moves along its normal).
        </p>
        <p>
          <b>(B) Pulsed spherical wave:</b><br/>
          (a) Show that an outgoing pulsed spherical wave can be written as <span class="muted">(1/r) a(t − r/c)</span> for arbitrary waveform <i>a</i>.<br/>
          (b) For an ultrashort optical pulse with λ₀ = 585 nm and Gaussian RMS duration σ<sub>t</sub> = 6 fs: (i) estimate how many optical cycles fit into the pulse width, and (ii) if the pulse propagates as an outgoing spherical wave from the origin at t=0, describe the spatial intensity distribution versus radius at time t=1 ps.
        </p>

        <div class="split">
          <div class="card">
            <h4>Given quantities</h4>
            <ul>
              <li>Michelson: one mirror tilt Δθ (small).</li>
              <li>Pulsed wave: λ₀ = 585 nm, Gaussian envelope with RMS duration σ<sub>t</sub> = 6 fs, free-space speed c, time t = 1 ps.</li>
            </ul>
          </div>
          <div class="card">
            <h4>Unknowns / what to find</h4>
            <ul>
              <li>Michelson: <b>fringe shape</b> in detector plane; <b>how fringes move</b> as the other mirror translates.</li>
              <li>Spherical wave: prove the <b>outgoing solution form</b>; compute <b>optical cycles</b> in the pulse; describe <b>I(r,t=1 ps)</b>.</li>
            </ul>
          </div>
        </div>

        <h3>Relevant principles (and why they apply)</h3>
        <div class="callouts">
          <div class="card">
            <h4>Interference of two plane waves</h4>
            <p class="muted">
              A small tilt makes the recombined beams propagate at a slight angle relative to each other → phase difference varies linearly across the detector → straight fringes.
            </p>
          </div>
          <div class="card">
            <h4>Michelson phase (round trip)</h4>
            <p class="muted">
              Translating a mirror changes optical path by twice the displacement (round trip), shifting the overall phase and moving fringes.
            </p>
          </div>
          <div class="card">
            <h4>3D wave equation</h4>
            <p class="muted">
              Spherical symmetry reduces the 3D wave equation to a 1D wave equation in the variable ψ(r,t)=rU(r,t), giving traveling-wave solutions.
            </p>
          </div>
        </div>

        <h3>Possible approaches (compare briefly)</h3>
        <ol>
          <li><b>Geometric plane-wave interference (Michelson):</b> treat the output as two plane waves crossing at small angle β, derive fringe spacing and motion. <span class="muted">Fast and directly yields fringe shape.</span></li>
          <li><b>Wavefront / equal-thickness reasoning:</b> view tilt as creating a wedge-like optical path difference, giving straight equal-thickness fringes. <span class="muted">Very physical, less algebra.</span></li>
          <li><b>Full field propagation through interferometer:</b> track beams and phases through the beamsplitter, then compute intensity. <span class="muted">More detailed than necessary for “shape + motion”.</span></li>
        </ol>

        <p class="note">
          Best approach: <b>plane-wave interference</b> for Michelson (gives spacing and motion cleanly) + <b>spherical-symmetry reduction</b> for the wave equation (most direct proof).
        </p>
      </section>

      <!-- PART 2 -->
      <section id="part2">
        <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

        <h3>Minimal plan (5–10 steps)</h3>
        <ol>
          <li><b>Goal:</b> model the Michelson output. <b>Tool:</b> treat the two recombined beams as plane waves with small crossing angle β.</li>
          <li><b>Goal:</b> compute phase difference across detector. <b>Tool:</b> Δφ(x) = (k₂ − k₁)·r + φ₀, with k=2π/λ.</li>
          <li><b>Goal:</b> infer fringe shape. <b>Tool:</b> constant-phase loci (Δφ = const) → straight lines for linear Δφ.</li>
          <li><b>Goal:</b> relate β to mirror tilt Δθ. <b>Tool:</b> reflection doubles angle → beam deflection ~2Δθ → β≈2Δθ.</li>
          <li><b>Goal:</b> describe mirror translation effect. <b>Tool:</b> Michelson round trip gives φ₀ = (2π/λ)(2ΔL) = 4πΔL/λ.</li>
          <li><b>Goal:</b> prove spherical pulse form. <b>Tool:</b> set ψ=rU, reduce 3D wave equation to 1D wave equation in ψ.</li>
          <li><b>Goal:</b> compute cycles in pulse. <b>Tool:</b> optical period T = λ/c, then N ≈ (duration)/T.</li>
          <li><b>Goal:</b> describe I(r,t) at t=1 ps. <b>Tool:</b> |U|² ∝ (1/r²)|a(t−r/c)|² → shell centered at r=ct with width ~cσ<sub>t</sub>.</li>
        </ol>

        <h3>Common mistakes & quick tips</h3>
        <ul>
          <li><b>Angle doubling:</b> mirror tilt Δθ produces a reflected beam tilt of <b>2Δθ</b>.</li>
          <li><b>Round-trip factor:</b> moving a Michelson mirror by ΔL changes optical path by <b>2ΔL</b> (there and back), so phase offset is <b>4πΔL/λ</b>.</li>
          <li><b>Pulse “width” definition:</b> RMS σ differs from FWHM by <b>FWHM = 2√(2 ln2) σ ≈ 2.355 σ</b>.</li>
          <li><b>Spherical decay:</b> amplitude ∝ 1/r, intensity ∝ 1/r² (energy conservation over spheres).</li>
        </ul>
      </section>

      <!-- PART 3 -->
      <section id="part3">
        <h2>PART 3 — Full Solution</h2>

        <article>
          <h3>A) Michelson interferometer with one mirror tilted</h3>
          <p>
            <b>Physical intuition:</b> If the two beams recombine with a slight relative angle, their wavefronts intersect like two sets of nearly parallel planes.
            The phase difference changes steadily across the detector, so the bright/dark bands are <b>straight and equally spaced</b>.
          </p>

          <h3>Model the recombined beams as plane waves</h3>
          <p>
            Let the detector plane be perpendicular to the average propagation direction. Suppose the two returning beams are (locally) plane waves:
          </p>

          <div class="eq" data-copy="E1(r,t) = E0 cos( k·r - ωt ),    E2(r,t) = E0 cos( k'·r - ωt + φ0 )">
            <button class="copybtn" type="button">Copy</button>
            E1(r,t) = E0 cos( k·r − ωt )<br/>
            E2(r,t) = E0 cos( k'·r − ωt + φ0 )
          </div>

          <p>
            The time-averaged intensity (assuming equal amplitudes and good coherence) is proportional to
          </p>
          <div class="eq" data-copy="I(r) = I0 [1 + cos( Δφ(r) ) ] / 2,   with Δφ(r)= (k' - k)·r + φ0">
            <button class="copybtn" type="button">Copy</button>
            I(r) = I0 [1 + cos(Δφ(r))]/2<br/>
            Δφ(r) = (k′ − k)·r + φ0
          </div>

          <h3>Small-angle geometry → linear phase across the screen</h3>
          <p>
            Let the two beams cross with a small angle β in the x–z plane. Then their transverse wavevector difference is approximately
          </p>
          <div class="eq" data-copy="Δk_x ≈ k sinβ  (for small β), with k = 2π/λ">
            <button class="copybtn" type="button">Copy</button>
            Δk<sub>x</sub> ≈ k sinβ, &nbsp; k = 2π/λ
          </div>

          <p>
            On the detector plane (take coordinate x across the screen), the phase difference becomes
          </p>
          <div class="eq" data-copy="Δφ(x) = Δk_x x + φ0 ≈ (2π/λ) sinβ · x + φ0">
            <button class="copybtn" type="button">Copy</button>
            Δφ(x) = Δk<sub>x</sub> x + φ0 ≈ (2π/λ) sinβ · x + φ0
          </div>

          <p>
            Bright fringes satisfy Δφ(x)=2πm (integer m). Since Δφ depends linearly on x, the loci of constant phase are <b>straight lines</b>
            (parallel to the y-axis in this setup): <b>straight, equally spaced fringes</b>.
          </p>

          <h3>Fringe spacing</h3>
          <p>
            Adjacent bright fringes correspond to m→m+1, meaning Δφ increases by 2π when x increases by one spacing p:
          </p>
          <div class="eq" data-copy="2π = (2π/λ) sinβ · p  ⇒  p = λ / sinβ  (screen-plane model)">
            <button class="copybtn" type="button">Copy</button>
            2π = (2π/λ) sinβ · p &nbsp;⇒&nbsp; p = λ / sinβ
          </div>

          <p class="muted">
            More commonly, for two beams propagating symmetrically about the bisector, the standard fringe spacing is
            p = λ / (2 sin(β/2)). For small β both forms agree to leading order because sinβ ≈ 2 sin(β/2) cos(β/2) ≈ 2 sin(β/2).
            We will use the standard symmetric result below.
          </p>

          <div class="eq" data-copy="p = λ / (2 sin(β/2))  ≈ λ/β   (small β)">
            <button class="copybtn" type="button">Copy</button>
            p = λ / (2 sin(β/2)) &nbsp;≈&nbsp; λ/β &nbsp;&nbsp;(small β)
          </div>

          <h3>Relate β to mirror tilt Δθ in a Michelson</h3>
          <p>
            A mirror tilt by Δθ changes the reflected beam direction by approximately <b>2Δθ</b>. Therefore the two recombining beams differ by
            a small angle
          </p>
          <div class="eq" data-copy="β ≈ 2Δθ  ⇒  p ≈ λ / (2Δθ)  (small Δθ)">
            <button class="copybtn" type="button">Copy</button>
            β ≈ 2Δθ &nbsp;⇒&nbsp; p ≈ λ / (2Δθ) &nbsp;&nbsp;(small Δθ)
          </div>

          <div class="box">
            <h3>Answer (shape):</h3>
            <p>
              With one mirror misaligned by a small angle Δθ, the detector sees <b>straight, parallel, equally spaced interference fringes</b>
              (their orientation is perpendicular to the direction of tilt).
            </p>
          </div>

          <h3>What happens as the <i>other</i> mirror moves?</h3>
          <p>
            Translating a Michelson mirror by ΔL changes that arm’s round-trip optical path length by <b>2ΔL</b>, producing a uniform phase shift
          </p>
          <div class="eq" data-copy="φ0 = (2π/λ)(2ΔL) = 4πΔL/λ">
            <button class="copybtn" type="button">Copy</button>
            φ0 = (2π/λ)(2ΔL) = 4πΔL/λ
          </div>

          <p>
            In the intensity formula I(x) ∝ 1 + cos(Δk_x x + φ0), changing φ0 <b>does not change the spacing</b>; it shifts the phase of the cosine.
            That means the entire fringe pattern <b>slides laterally</b> across the detector. At a fixed point on the detector, the intensity oscillates
            as fringes sweep past.
          </p>

          <div class="box">
            <h3>Answer (motion):</h3>
            <p>
              As the other mirror translates, the pattern keeps the same shape and spacing but <b>moves (translates) across the detector</b>;
              equivalently, the brightness at any fixed pixel oscillates periodically with mirror displacement.
            </p>
          </div>

          <h3>Sanity checks</h3>
          <ul>
            <li><b>Units:</b> p has units of length; λ/(angle) → meters, good.</li>
            <li><b>Limiting case:</b> Δθ→0 ⇒ p→∞, so fringes disappear (uniform field) as expected for perfectly aligned beams.</li>
            <li><b>Physical interpretation:</b> tilt introduces a linear optical path difference across x (a “wedge”), creating straight fringes.</li>
          </ul>
        </article>

        <article>
          <h3>B) Pulsed spherical wave</h3>
          <p>
            <b>Physical intuition:</b> In 3D, an outward-moving disturbance spreads over spheres of area 4πr², so amplitude falls like 1/r.
            The pulse shape simply “rides outward” at speed c, so the waveform depends on the <b>retarded time</b> t − r/c.
          </p>

          <h3>(a) Derive the outgoing pulsed spherical-wave form</h3>
          <p>
            Start from the (scalar) wave equation in free space:
          </p>
          <div class="eq" data-copy="∇^2 U - (1/c^2) ∂^2U/∂t^2 = 0">
            <button class="copybtn" type="button">Copy</button>
            ∇²U − (1/c²) ∂²U/∂t² = 0
          </div>

          <p>
            For spherical symmetry, U = U(r,t) and the Laplacian becomes
          </p>
          <div class="eq" data-copy="∇^2 U = (1/r^2) ∂/∂r ( r^2 ∂U/∂r )">
            <button class="copybtn" type="button">Copy</button>
            ∇²U = (1/r²) ∂/∂r ( r² ∂U/∂r )
          </div>

          <p>
            Define a new function ψ(r,t) = r U(r,t). We now compute derivatives:
          </p>
          <div class="eq" data-copy="U = ψ/r,   ∂U/∂r = (1/r)∂ψ/∂r - ψ/r^2">
            <button class="copybtn" type="button">Copy</button>
            U = ψ/r<br/>
            ∂U/∂r = (1/r) ∂ψ/∂r − ψ/r²
          </div>

          <p>
            Multiply by r²:
          </p>
          <div class="eq" data-copy="r^2 ∂U/∂r = r ∂ψ/∂r - ψ">
            <button class="copybtn" type="button">Copy</button>
            r² ∂U/∂r = r ∂ψ/∂r − ψ
          </div>

          <p>
            Differentiate with respect to r:
          </p>
          <div class="eq" data-copy="∂/∂r (r^2 ∂U/∂r) = ∂/∂r (r ∂ψ/∂r - ψ) = r ∂^2ψ/∂r^2">
            <button class="copybtn" type="button">Copy</button>
            ∂/∂r (r² ∂U/∂r) = ∂/∂r (r ∂ψ/∂r − ψ) = r ∂²ψ/∂r²
          </div>

          <p>
            Therefore
          </p>
          <div class="eq" data-copy="∇^2 U = (1/r^2) [ r ∂^2ψ/∂r^2 ] = (1/r) ∂^2ψ/∂r^2">
            <button class="copybtn" type="button">Copy</button>
            ∇²U = (1/r²) [ r ∂²ψ/∂r² ] = (1/r) ∂²ψ/∂r²
          </div>

          <p>
            Also, since U = ψ/r and r is independent of t:
          </p>
          <div class="eq" data-copy="∂^2U/∂t^2 = (1/r) ∂^2ψ/∂t^2">
            <button class="copybtn" type="button">Copy</button>
            ∂²U/∂t² = (1/r) ∂²ψ/∂t²
          </div>

          <p>
            Substitute into the wave equation and multiply by r:
          </p>
          <div class="eq" data-copy="∂^2ψ/∂r^2 - (1/c^2) ∂^2ψ/∂t^2 = 0">
            <button class="copybtn" type="button">Copy</button>
            ∂²ψ/∂r² − (1/c²) ∂²ψ/∂t² = 0
          </div>

          <p>
            This is exactly the <b>1D wave equation</b> in variable r, whose general solution is
          </p>
          <div class="eq" data-copy="ψ(r,t) = f(t - r/c) + g(t + r/c)">
            <button class="copybtn" type="button">Copy</button>
            ψ(r,t) = f(t − r/c) + g(t + r/c)
          </div>

          <p>
            Therefore
          </p>
          <div class="eq" data-copy="U(r,t) = (1/r)[ f(t - r/c) + g(t + r/c) ]">
            <button class="copybtn" type="button">Copy</button>
            U(r,t) = (1/r) [ f(t − r/c) + g(t + r/c) ]
          </div>

          <p>
            For an <b>outgoing</b> pulse (radiating away from the origin), we set the incoming term g = 0 and rename f → a:
          </p>
          <div class="eq" data-copy="U(r,t) = (1/r) a(t - r/c)">
            <button class="copybtn" type="button">Copy</button>
            <b>U(r,t) = (1/r) a(t − r/c)</b>
          </div>

          <div class="box">
            <h3>Result (b.2-6-2a):</h3>
            <p><b>An outgoing pulsed spherical wave has the form</b> <span style="font-family:var(--mono)">U(r,t) = (1/r) a(t − r/c)</span> for arbitrary waveform <i>a</i>.</p>
          </div>

          <h3>(b) Cycles in the pulse and spatial intensity at t = 1 ps</h3>
          <p>
            The optical period associated with central wavelength λ₀ is
          </p>
          <div class="eq" data-copy="T0 = λ0 / c ,   f0 = c/λ0 ,   ω0 = 2πc/λ0">
            <button class="copybtn" type="button">Copy</button>
            T<sub>0</sub> = λ<sub>0</sub>/c,&nbsp; f<sub>0</sub> = c/λ<sub>0</sub>,&nbsp; ω<sub>0</sub> = 2πc/λ<sub>0</sub>
          </div>

          <p>
            Using the RMS pulse width σ<sub>t</sub> as the “pulse width” measure, an estimate of the number of cycles in one σ is
          </p>
          <div class="eq" data-copy="N_RMS ≈ σt / T0 = σt (c/λ0)">
            <button class="copybtn" type="button">Copy</button>
            N<sub>RMS</sub> ≈ σ<sub>t</sub>/T<sub>0</sub> = σ<sub>t</sub>(c/λ<sub>0</sub>)
          </div>

          <p>
            Plug in σ<sub>t</sub> = 6 fs = 6×10<sup>−15</sup> s, λ₀ = 585 nm = 585×10<sup>−9</sup> m, c ≈ 3.0×10<sup>8</sup> m/s:
          </p>

          <div class="eq" data-copy="N_RMS ≈ (6×10^-15)(3.0×10^8)/(585×10^-9) ≈ 3.08 cycles">
            <button class="copybtn" type="button">Copy</button>
            N<sub>RMS</sub> ≈ (6×10<sup>−15</sup>)(3.0×10<sup>8</sup>)/(585×10<sup>−9</sup>) ≈ <b>3.08 cycles</b>
          </div>

          <p class="muted">
            If you prefer FWHM duration: FWHM = 2.355 σ<sub>t</sub> ≈ 14.1 fs, giving N<sub>FWHM</sub> ≈ 2.355 N<sub>RMS</sub> ≈ 7.25 cycles.
          </p>

          <h3>Spatial intensity distribution at time t = 1 ps</h3>
          <p>
            A convenient complex “carrier + envelope” choice for the outgoing waveform is
          </p>
          <div class="eq" data-copy="a(τ) = exp( -τ^2 / (2σt^2) ) · exp( -i ω0 τ ),  where τ = t - r/c">
            <button class="copybtn" type="button">Copy</button>
            a(τ) = exp( −τ²/(2σ<sub>t</sub>²) ) · exp( −i ω<sub>0</sub> τ ),&nbsp; τ = t − r/c
          </div>

          <p>
            Then the field is
          </p>
          <div class="eq" data-copy="U(r,t) = (1/r) exp( -(t - r/c)^2 / (2σt^2) ) · exp( -i ω0 (t - r/c) )">
            <button class="copybtn" type="button">Copy</button>
            U(r,t) = (1/r) exp( −(t − r/c)²/(2σ<sub>t</sub>²) ) · exp( −i ω<sub>0</sub>(t − r/c) )
          </div>

          <p>
            The intensity is proportional to |U|²:
          </p>
          <div class="eq" data-copy="I(r,t) ∝ |U(r,t)|^2 = (1/r^2) exp( -(t - r/c)^2 / (σt^2) )">
            <button class="copybtn" type="button">Copy</button>
            I(r,t) ∝ |U(r,t)|² = (1/r²) exp( −(t − r/c)² / (σ<sub>t</sub>²) )
          </div>

          <p>
            At a fixed time t, this is a <b>radial Gaussian shell</b> centered where the retarded time is zero:
          </p>
          <ul>
            <li><b>Shell center:</b> t − r/c = 0 ⇒ <b>r = ct</b></li>
            <li><b>Shell thickness (RMS):</b> Δr<sub>RMS</sub> ≈ c σ<sub>t</sub></li>
            <li><b>Amplitude decay:</b> 1/r → intensity decay 1/r²</li>
          </ul>

          <p>
            For t = 1 ps = 10<sup>−12</sup> s, r<sub>0</sub> = ct ≈ (3×10<sup>8</sup>)(10<sup>−12</sup>) = <b>3×10<sup>−4</sup> m = 0.30 mm</b>.
            The RMS shell thickness is cσ<sub>t</sub> ≈ (3×10<sup>8</sup>)(6×10<sup>−15</sup>) = <b>1.8×10<sup>−6</sup> m = 1.8 μm</b>.
          </p>

          <div class="box">
            <h3>Result (2.6-2b):</h3>
            <p>
              The intensity at t = 1 ps is concentrated in a <b>thin spherical shell</b> near <b>r = ct ≈ 0.30 mm</b>, with thickness ~ <b>cσ<sub>t</sub> ≈ 1.8 μm</b>, and it scales as <b>1/r²</b> overall.
            </p>
          </div>

          <h3>Sanity checks</h3>
          <ul>
            <li><b>Units:</b> (t − r/c) has seconds; exponent is dimensionless; 1/r² has 1/m² for intensity scaling—consistent with geometric spreading.</li>
            <li><b>Limiting cases:</b> for fixed t, far from r=ct, intensity → 0 (pulse is localized). For large r at the pulse peak, I ∝ 1/r² (energy conserved over spheres).</li>
            <li><b>Physical interpretation:</b> the waveform is preserved in retarded time; the pulse simply moves outward at c.</li>
          </ul>
        </article>
      </section>

      <!-- VISUALIZATIONS -->
      <section id="viz">
        <h2>Interactive Visualizations</h2>
        <p class="muted">
          Use the sliders below. <b>Wavelength λ</b> updates <i>all</i> visuals (Michelson fringes + pulse carrier), while the other sliders control
          the specific scenario (tilt/mirror motion for Michelson; time/duration for the pulse).
        </p>

        <div class="controls" role="group" aria-label="Interactive controls">
          <div class="ctl">
            <label for="lam"><span>Wavelength <b>λ</b> (nm) — affects <b>all</b> plots</span><span id="lamOut">585</span></label>
            <input id="lam" type="range" min="400" max="800" value="585" step="1" />
            <div class="muted" style="font-size:.85rem;margin-top:6px">Changes fringe spacing and pulse carrier frequency.</div>
          </div>
          <div class="ctl">
            <label for="tilt"><span>Michelson mirror tilt <b>Δθ</b> (mrad)</span><span id="tiltOut">1.00</span></label>
            <input id="tilt" type="range" min="0.05" max="3.00" value="1.00" step="0.01" />
            <div class="muted" style="font-size:.85rem;margin-top:6px">Straight fringes get denser as Δθ increases.</div>
          </div>
          <div class="ctl">
            <label for="dL"><span>Other mirror translation <b>ΔL</b> (µm)</span><span id="dLOut">0.00</span></label>
            <input id="dL" type="range" min="-5.0" max="5.0" value="0.00" step="0.01" />
            <div class="muted" style="font-size:.85rem;margin-top:6px">Shifts the fringe phase → fringes slide across the screen.</div>
          </div>
          <div class="ctl">
            <label for="tps"><span>Pulse observation time <b>t</b> (ps)</span><span id="tpsOut">1.00</span></label>
            <input id="tps" type="range" min="0.2" max="2.0" value="1.00" step="0.01" />
            <div class="muted" style="font-size:.85rem;margin-top:6px">Moves the spherical-shell peak radius r=ct.</div>
          </div>
          <div class="ctl" style="grid-column:1/-1">
            <label for="sig"><span>Pulse RMS duration <b>σ<sub>t</sub></b> (fs)</span><span id="sigOut">6.0</span></label>
            <input id="sig" type="range" min="2.0" max="20.0" value="6.0" step="0.1" />
            <div class="muted" style="font-size:.85rem;margin-top:6px">Controls shell thickness ~ cσ<sub>t</sub> and number of cycles.</div>
          </div>
        </div>

        <div class="kpi" aria-label="Live computed quantities">
          <div class="k">
            <div class="label">Michelson fringe spacing (small-angle)</div>
            <div class="value" id="kFringe">—</div>
          </div>
          <div class="k">
            <div class="label">Pulse cycles per RMS width (≈ σ<sub>t</sub> / T)</div>
            <div class="value" id="kCycles">—</div>
          </div>
          <div class="k">
            <div class="label">Shell peak radius r = ct (at chosen t)</div>
            <div class="value" id="kRadius">—</div>
          </div>
        </div>

        <div class="visgrid">
          <figure>
            <canvas id="diag" aria-label="Labeled Michelson interferometer diagram"></canvas>
            <figcaption><b>Diagram:</b> Michelson interferometer. One mirror is tilted by Δθ, creating a small crossing angle between the two returning beams → straight fringes at the detector.</figcaption>
          </figure>

          <figure>
            <canvas id="michelson" aria-label="Michelson interference pattern plot"></canvas>
            <figcaption><b>Main plot:</b> Detector-plane interference pattern (straight fringes). Δθ sets spacing; ΔL slides the pattern.</figcaption>
          </figure>

          <figure style="grid-column:1/-1">
            <canvas id="pulse" aria-label="Pulsed spherical wave radial distribution plot"></canvas>
            <figcaption><b>Secondary plot:</b> Outgoing spherical pulse at fixed time: field (real part) and envelope versus radius. Peak at r=ct, thickness ~ cσ<sub>t</sub>, amplitude ∝ 1/r.</figcaption>
          </figure>
        </div>

        <p class="note">
          Example values: the visualization assumes ideal visibility and a simplified “two plane waves” recombination for Michelson, which is exactly the regime used to infer fringe <i>shape</i>, spacing, and motion for small misalignment.
        </p>
      </section>

      <!-- FINAL ANSWERS -->
      <section id="final">
        <h2>Final Answers (copy)</h2>

        <div class="eq" data-copy="Michelson (one mirror tilted by Δθ): the detector sees straight, parallel, equally spaced fringes (orientation set by tilt axis). The spacing is p = λ/(2 sin(β/2)) with β ≈ 2Δθ, so for small Δθ: p ≈ λ/(2Δθ). As the other mirror translates by ΔL, the phase offset changes by φ0 = 4πΔL/λ, so the entire fringe pattern shifts (slides) across the detector; at a fixed point the intensity oscillates as fringes pass.">
          <button class="copybtn" type="button">Copy</button>
          <b>Michelson:</b> straight, parallel fringes; <b>p ≈ λ/(2Δθ)</b> (small Δθ). Moving the other mirror changes <b>φ₀ = 4πΔL/λ</b> → fringes <b>slide</b> (spacing unchanged).
        </div>

        <div class="eq" data-copy="Pulsed spherical wave (outgoing): from spherical symmetry, with ψ=rU the 3D wave equation reduces to the 1D wave equation in ψ. Thus ψ(r,t)=f(t-r/c)+g(t+r/c) and U(r,t)=(1/r)[f(t-r/c)+g(t+r/c)]. For an outgoing pulse set g=0: U(r,t)=(1/r)a(t-r/c).">
          <button class="copybtn" type="button">Copy</button>
          <b>Pulsed spherical wave:</b> <b>U(r,t) = (1/r)a(t − r/c)</b> (outgoing), with arbitrary waveform <i>a</i>.
        </div>

        <div class="eq" data-copy="For λ0=585 nm and Gaussian RMS duration σt=6 fs: optical period T0=λ0/c≈1.95 fs, so cycles per RMS width N_RMS≈σt/T0≈3.08. Intensity for outgoing spherical Gaussian-envelope pulse is I(r,t) ∝ (1/r^2) exp(-(t-r/c)^2/σt^2). At t=1 ps the energy is in a thin spherical shell centered at r=ct≈0.30 mm with RMS thickness cσt≈1.8 μm, and it decays overall as 1/r^2.">
          <button class="copybtn" type="button">Copy</button>
          <b>Ultrashort pulse:</b> N<sub>RMS</sub> ≈ <b>3.08 cycles</b> for σ<sub>t</sub>=6 fs at λ₀=585 nm.
          At t=1 ps: <b>I(r,t) ∝ (1/r²) exp(−(t−r/c)²/σ<sub>t</sub>²)</b>, a thin shell near <b>r=ct≈0.30 mm</b>, thickness ≈ <b>cσ<sub>t</sub>≈1.8 μm</b>.
        </div>
      </section>

      <footer>
        Built with vanilla HTML/CSS/JS • Canvas is HiDPI-aware • Copy buttons copy plain text
      </footer>
    </div>
  </main>
</div>

<div class="toast" id="toast" role="status" aria-live="polite">Copied!</div>

<script>
(function(){
  "use strict";

  // --------------------------
  // Copy buttons
  // --------------------------
  const toast = document.getElementById("toast");
  function showToast(msg){
    toast.textContent = msg || "Copied!";
    toast.classList.add("show");
    window.clearTimeout(showToast._t);
    showToast._t = window.setTimeout(()=>toast.classList.remove("show"), 1100);
  }
  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      showToast("Copied to clipboard");
    }catch(e){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      ta.style.position="fixed";
      ta.style.left="-9999px";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      document.body.removeChild(ta);
      showToast("Copied");
    }
  }
  document.querySelectorAll(".eq").forEach(eq=>{
    const btn = eq.querySelector(".copybtn");
    if(!btn) return;
    btn.addEventListener("click", ()=>{
      const txt = eq.getAttribute("data-copy") || eq.innerText.replace(/\s+\n/g,"\n").trim();
      copyText(txt);
    });
  });

  // --------------------------
  // Helpers
  // --------------------------
  const C = 299792458; // m/s
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function fmt(x, unit){
    if(!isFinite(x)) return "—";
    return x.toFixed(2) + (unit ? (" " + unit) : "");
  }
  function fmtSI(x, unit){
    if(!isFinite(x)) return "—";
    const ax = Math.abs(x);
    let v=x, p="", s=unit||"";
    if(ax>=1e-3 && ax<1){ v=x*1e3; p="m"; }
    else if(ax>=1e-6 && ax<1e-3){ v=x*1e6; p="µ"; }
    else if(ax>=1e-9 && ax<1e-6){ v=x*1e9; p="n"; }
    else if(ax>=1 && ax<1e3){ v=x; p=""; }
    else if(ax>=1e3 && ax<1e6){ v=x/1e3; p="k"; }
    else { v=x; p=""; }
    return v.toFixed(3) + " " + p + s;
  }

  // HiDPI canvas setup
  function fitCanvas(canvas, desiredCSSHeight){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const cssW = Math.max(10, rect.width);
    const cssH = desiredCSSHeight || rect.height || 340;
    canvas.style.height = cssH + "px";
    const w = Math.round(cssW * dpr);
    const h = Math.round(cssH * dpr);
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
    }
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return {ctx, w: cssW, h: cssH, dpr};
  }

  // Axes drawing
  function drawAxes(ctx, x0, y0, w, h, opts){
    const {
      title="", xlabel="", ylabel="",
      xMin=0, xMax=1, yMin=0, yMax=1,
      grid=true, ticks=5
    } = opts || {};
    // background
    ctx.save();
    ctx.clearRect(x0,y0,w,h);
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.fillRect(x0,y0,w,h);

    // inner plot area
    const padL=56, padR=16, padT=30, padB=44;
    const px = x0 + padL, py = y0 + padT;
    const pw = w - padL - padR, ph = h - padT - padB;

    // grid + ticks
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    if(grid){
      for(let i=0;i<=ticks;i++){
        const tx = px + (pw*i)/ticks;
        const ty = py + (ph*i)/ticks;
        ctx.moveTo(tx, py); ctx.lineTo(tx, py+ph);
        ctx.moveTo(px, ty); ctx.lineTo(px+pw, ty);
      }
    }
    ctx.stroke();

    // axes box
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.strokeRect(px,py,pw,ph);

    // tick labels
    ctx.fillStyle = "rgba(233,237,246,0.85)";
    ctx.font = "12px " + getComputedStyle(document.documentElement).getPropertyValue("--mono");
    ctx.textAlign="center"; ctx.textBaseline="top";
    for(let i=0;i<=ticks;i++){
      const tx = px + (pw*i)/ticks;
      const xv = lerp(xMin,xMax,i/ticks);
      ctx.fillText(xv.toFixed(2), tx, py+ph+8);
    }
    ctx.textAlign="right"; ctx.textBaseline="middle";
    for(let i=0;i<=ticks;i++){
      const ty = py + ph - (ph*i)/ticks;
      const yv = lerp(yMin,yMax,i/ticks);
      ctx.fillText(yv.toFixed(2), px-8, ty);
    }

    // titles
    ctx.fillStyle = "rgba(233,237,246,0.95)";
    ctx.font = "700 13px " + getComputedStyle(document.documentElement).getPropertyValue("--sans");
    ctx.textAlign="left"; ctx.textBaseline="top";
    ctx.fillText(title, x0+12, y0+10);

    ctx.fillStyle = "rgba(233,237,246,0.78)";
    ctx.font = "12px " + getComputedStyle(document.documentElement).getPropertyValue("--sans");
    ctx.textAlign="center"; ctx.textBaseline="bottom";
    ctx.fillText(xlabel, px + pw/2, y0 + h - 8);

    ctx.save();
    ctx.translate(x0+14, py + ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign="center"; ctx.textBaseline="top";
    ctx.fillText(ylabel, 0, 0);
    ctx.restore();

    ctx.restore();
    return {px,py,pw,ph, xMin,xMax,yMin,yMax};
  }

  function xMap(x, A){ return A.px + (x - A.xMin) * (A.pw) / (A.xMax - A.xMin); }
  function yMap(y, A){ return A.py + A.ph - (y - A.yMin) * (A.ph) / (A.yMax - A.yMin); }

  // --------------------------
  // State & UI
  // --------------------------
  const ui = {
    lam: document.getElementById("lam"),
    tilt: document.getElementById("tilt"),
    dL: document.getElementById("dL"),
    tps: document.getElementById("tps"),
    sig: document.getElementById("sig"),

    lamOut: document.getElementById("lamOut"),
    tiltOut: document.getElementById("tiltOut"),
    dLOut: document.getElementById("dLOut"),
    tpsOut: document.getElementById("tpsOut"),
    sigOut: document.getElementById("sigOut"),

    kFringe: document.getElementById("kFringe"),
    kCycles: document.getElementById("kCycles"),
    kRadius: document.getElementById("kRadius"),

    diag: document.getElementById("diag"),
    mich: document.getElementById("michelson"),
    pulse: document.getElementById("pulse")
  };

  function getState(){
    const lam_nm = parseFloat(ui.lam.value);
    const lam = lam_nm * 1e-9;
    const dtheta_mrad = parseFloat(ui.tilt.value);
    const dtheta = dtheta_mrad * 1e-3; // rad
    const dL_um = parseFloat(ui.dL.value);
    const dL = dL_um * 1e-6; // m
    const t_ps = parseFloat(ui.tps.value);
    const t = t_ps * 1e-12; // s
    const sig_fs = parseFloat(ui.sig.value);
    const sig = sig_fs * 1e-15; // s
    return {lam_nm, lam, dtheta_mrad, dtheta, dL_um, dL, t_ps, t, sig_fs, sig};
  }

  function updateReadouts(s){
    ui.lamOut.textContent = s.lam_nm.toFixed(0);
    ui.tiltOut.textContent = s.dtheta_mrad.toFixed(2);
    ui.dLOut.textContent = s.dL_um.toFixed(2);
    ui.tpsOut.textContent = s.t_ps.toFixed(2);
    ui.sigOut.textContent = s.sig_fs.toFixed(1);

    // computed KPIs
    const p = s.lam / (2 * Math.max(1e-9, s.dtheta)); // small-angle p ≈ λ/(2Δθ)
    ui.kFringe.textContent = fmtSI(p, "m") + " (≈ λ/(2Δθ))";

    const T = s.lam / C;
    const N = s.sig / T;
    ui.kCycles.textContent = N.toFixed(2) + " cycles (per RMS σt)";

    const r0 = C * s.t;
    ui.kRadius.textContent = fmtSI(r0, "m") + " (r = ct)";
  }

  // --------------------------
  // Drawing: Diagram
  // --------------------------
  function drawDiagram(s){
    const {ctx,w,h} = fitCanvas(ui.diag, 340);
    ctx.clearRect(0,0,w,h);

    // background
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.fillRect(0,0,w,h);

    // layout coordinates
    const cx = w*0.46, cy = h*0.52;
    const bs = {x:cx, y:cy};

    // helper
    function line(x1,y1,x2,y2,stroke, width, dash){
      ctx.save();
      ctx.strokeStyle = stroke;
      ctx.lineWidth = width || 2;
      if(dash) ctx.setLineDash(dash); else ctx.setLineDash([]);
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.restore();
    }
    function arrow(x1,y1,x2,y2,stroke){
      line(x1,y1,x2,y2,stroke,2);
      const ang = Math.atan2(y2-y1,x2-x1);
      const ah=8;
      ctx.save();
      ctx.fillStyle=stroke;
      ctx.beginPath();
      ctx.moveTo(x2,y2);
      ctx.lineTo(x2-ah*Math.cos(ang-0.5), y2-ah*Math.sin(ang-0.5));
      ctx.lineTo(x2-ah*Math.cos(ang+0.5), y2-ah*Math.sin(ang+0.5));
      ctx.closePath(); ctx.fill();
      ctx.restore();
    }
    function label(txt,x,y,color,align){
      ctx.save();
      ctx.fillStyle = color || "rgba(233,237,246,0.9)";
      ctx.font = "12px " + getComputedStyle(document.documentElement).getPropertyValue("--sans");
      ctx.textAlign = align || "left";
      ctx.textBaseline = "middle";
      ctx.fillText(txt,x,y);
      ctx.restore();
    }

    // Components positions
    const src = {x:w*0.16, y:cy};
    const det = {x:w*0.80, y:cy};
    const m1  = {x:cx, y:h*0.18}; // top
    const m2  = {x:cx, y:h*0.86}; // bottom (tilted)
    const armLen = Math.min(h*0.30, 110);

    // beamsplitter (a tilted square)
    ctx.save();
    ctx.translate(bs.x, bs.y);
    ctx.rotate(-Math.PI/4);
    ctx.fillStyle = "rgba(125,211,252,0.10)";
    ctx.strokeStyle = "rgba(125,211,252,0.55)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.rect(-18,-18,36,36);
    ctx.fill(); ctx.stroke();
    ctx.restore();
    label("Beam splitter", bs.x+22, bs.y-22, "rgba(170,182,204,0.95)");

    // source & detector
    ctx.fillStyle="rgba(167,139,250,0.18)";
    ctx.strokeStyle="rgba(167,139,250,0.65)";
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(src.x,src.y,14,0,Math.PI*2); ctx.fill(); ctx.stroke();
    label("Source", src.x, src.y-24, "rgba(233,237,246,0.9)", "center");

    ctx.fillStyle="rgba(52,211,153,0.14)";
    ctx.strokeStyle="rgba(52,211,153,0.65)";
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.roundRect(det.x-18,det.y-12,36,24,8); ctx.fill(); ctx.stroke();
    label("Detector", det.x, det.y-26, "rgba(233,237,246,0.9)", "center");

    // mirrors
    function drawMirror(m, tiltRad, name){
      const L=48;
      const ang = tiltRad || 0;
      ctx.save();
      ctx.translate(m.x,m.y);
      ctx.rotate(ang);
      ctx.strokeStyle="rgba(233,237,246,0.7)";
      ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(-L/2,0); ctx.lineTo(L/2,0);
      ctx.stroke();
      // hatch
      ctx.strokeStyle="rgba(233,237,246,0.25)";
      ctx.lineWidth=1;
      for(let i=-20;i<=20;i+=6){
        ctx.beginPath();
        ctx.moveTo(i,-10); ctx.lineTo(i+10,10);
        ctx.stroke();
      }
      ctx.restore();
      label(name, m.x+30, m.y, "rgba(170,182,204,0.95)");
    }
    drawMirror(m1, 0, "Mirror M1");
    // exaggerate tilt for visibility
    const visTilt = clamp(s.dtheta*14, -0.25, 0.25);
    drawMirror(m2, visTilt, "Mirror M2 (tilted)");

    // arms
    line(bs.x, bs.y, m1.x, m1.y, "rgba(255,255,255,0.22)", 2, [6,6]);
    line(bs.x, bs.y, m2.x, m2.y, "rgba(255,255,255,0.22)", 2, [6,6]);

    // incoming beam
    arrow(src.x+14, src.y, bs.x-22, bs.y, "rgba(167,139,250,0.85)");
    label("input", (src.x+bs.x)/2, src.y-14, "rgba(167,139,250,0.85)", "center");

    // split beams (to mirrors)
    arrow(bs.x, bs.y-2, m1.x, m1.y+18, "rgba(125,211,252,0.9)");
    arrow(bs.x, bs.y+2, m2.x, m2.y-18, "rgba(125,211,252,0.9)");
    label("arm 1", bs.x+10, (bs.y+m1.y)/2, "rgba(125,211,252,0.85)");
    label("arm 2", bs.x+10, (bs.y+m2.y)/2, "rgba(125,211,252,0.85)");

    // recombined beams to detector: show two rays with slight angular separation (crossing angle)
    const beta = 2*s.dtheta; // approx
    const sep = clamp(beta*120, 0, 12); // visible separation
    arrow(bs.x+18, bs.y-sep*0.5, det.x-20, det.y-8, "rgba(52,211,153,0.85)");
    arrow(bs.x+18, bs.y+sep*0.5, det.x-20, det.y+8, "rgba(52,211,153,0.85)");
    label("recombined beams", (bs.x+det.x)/2, bs.y-30, "rgba(52,211,153,0.85)", "center");

    // annotate Δθ
    ctx.save();
    const ax = m2.x-56, ay = m2.y-30;
    ctx.strokeStyle="rgba(251,191,36,0.85)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(m2.x, m2.y, 34, -Math.PI/2 - 0.16, -Math.PI/2 + visTilt + 0.16);
    ctx.stroke();
    ctx.fillStyle="rgba(251,191,36,0.9)";
    ctx.font="12px " + getComputedStyle(document.documentElement).getPropertyValue("--sans");
    ctx.fillText("Δθ", m2.x+6, m2.y-44);
    ctx.restore();

    // footer text in diagram
    ctx.save();
    ctx.fillStyle="rgba(170,182,204,0.88)";
    ctx.font="12px " + getComputedStyle(document.documentElement).getPropertyValue("--mono");
    ctx.fillText(`λ = ${s.lam_nm.toFixed(0)} nm   Δθ = ${s.dtheta_mrad.toFixed(2)} mrad   ΔL = ${s.dL_um.toFixed(2)} µm`, 12, h-14);
    ctx.restore();
  }

  // --------------------------
  // Drawing: Michelson pattern (2D straight fringes)
  // --------------------------
  function drawMichelson(s){
    const {ctx,w,h} = fitCanvas(ui.mich, 340);

    const A = drawAxes(ctx, 0,0,w,h,{
      title:"Michelson detector pattern (tilt → straight fringes)",
      xlabel:"x (mm)  [transverse screen coordinate]",
      ylabel:"y (mm)",
      xMin:-2.5, xMax:2.5,
      yMin:-2.0, yMax:2.0,
      ticks:5
    });

    // compute phase: Δφ(x)= (4πΔL/λ) + (4πΔθ/λ) x (small-angle, β≈2Δθ)
    // x in meters.
    const phi0 = (4*Math.PI*s.dL)/s.lam;
    const kx = (4*Math.PI*s.dtheta)/s.lam;

    // Render a fast raster intensity map in plot area
    const pw = Math.floor(A.pw), ph = Math.floor(A.ph);
    const img = ctx.createImageData(pw, ph);
    const data = img.data;

    for(let j=0;j<ph;j++){
      const y_mm = lerp(A.yMax, A.yMin, j/(ph-1)); // not used (fringes straight)
      (void)y_mm;
      for(let i=0;i<pw;i++){
        const x_mm = lerp(A.xMin, A.xMax, i/(pw-1));
        const x = x_mm*1e-3; // m
        const phase = phi0 + kx*x;
        const I = 0.5*(1 + Math.cos(phase)); // 0..1
        // map to grayscale with slight tint
        const g = Math.floor(30 + 205*I);
        const idx = 4*(j*pw+i);
        data[idx+0] = g;
        data[idx+1] = Math.floor(g*0.98 + 6);
        data[idx+2] = Math.floor(g*1.02);
        data[idx+3] = 255;
      }
    }
    ctx.putImageData(img, A.px, A.py);

    // overlay a cross-section line and legend
    ctx.save();
    ctx.strokeStyle = "rgba(125,211,252,0.75)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);
    const y0 = yMap(0, A);
    ctx.beginPath();
    ctx.moveTo(A.px, y0);
    ctx.lineTo(A.px+A.pw, y0);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle="rgba(233,237,246,0.86)";
    ctx.font="12px " + getComputedStyle(document.documentElement).getPropertyValue("--sans");
    ctx.fillText("y = 0 mm cross-section", A.px+10, y0-10);

    // small legend box
    const lx = A.px + A.pw - 168, ly = A.py + 10;
    ctx.fillStyle="rgba(0,0,0,0.35)";
    ctx.strokeStyle="rgba(255,255,255,0.16)";
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.roundRect(lx,ly,158,62,12);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle="rgba(233,237,246,0.90)";
    ctx.font="700 12px " + getComputedStyle(document.documentElement).getPropertyValue("--sans");
    ctx.fillText("Parameters", lx+10, ly+18);
    ctx.font="12px " + getComputedStyle(document.documentElement).getPropertyValue("--mono");
    ctx.fillText(`Δθ=${s.dtheta_mrad.toFixed(2)} mrad`, lx+10, ly+36);
    ctx.fillText(`ΔL=${s.dL_um.toFixed(2)} µm`, lx+10, ly+52);
    ctx.restore();
  }

  // --------------------------
  // Drawing: Pulse radial plot (field + envelope)
  // --------------------------
  function drawPulse(s){
    const {ctx,w,h} = fitCanvas(ui.pulse, 360);

    // radial window around r0=ct
    const r0 = C*s.t;
    const dr = 5*C*s.sig; // +/- 5 sigma in space
    const rMin = Math.max(1e-9, r0 - dr);
    const rMax = r0 + dr;

    // We'll plot:
    // y1 = Re{U(r,t)} normalized (so it fits nicely)
    // y2 = Envelope amplitude |U| normalized
    // where U=(1/r) exp(-(tau^2)/(2σ^2)) exp(-i ω0 tau), tau=t-r/c.
    const omega0 = 2*Math.PI*C/s.lam;

    // sample
    const N = 900;
    let maxAbs = 1e-12;
    const yRe = new Array(N);
    const yEnv = new Array(N);
    const rr = new Array(N);

    for(let i=0;i<N;i++){
      const r = lerp(rMin,rMax,i/(N-1));
      const tau = s.t - r/C;
      const env = Math.exp(-(tau*tau)/(2*s.sig*s.sig));
      const amp = env / r;
      const re = amp * Math.cos(omega0*tau);
      rr[i]=r;
      yRe[i]=re;
      yEnv[i]=amp;
      maxAbs = Math.max(maxAbs, Math.abs(re), amp);
    }
    // normalize
    for(let i=0;i<N;i++){
      yRe[i] /= maxAbs;
      yEnv[i] /= maxAbs;
    }

    const A = drawAxes(ctx, 0,0,w,h,{
      title:"Outgoing spherical pulse at fixed time (field + envelope)",
      xlabel:"r (mm)",
      ylabel:"normalized amplitude",
      xMin: rMin*1e3, xMax: rMax*1e3,
      yMin: -1.1, yMax: 1.1,
      ticks:5
    });

    // draw envelope
    ctx.save();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(52,211,153,0.85)";
    ctx.beginPath();
    for(let i=0;i<N;i++){
      const x = xMap(rr[i]*1e3, A);
      const y = yMap(yEnv[i], A);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // draw -envelope (for symmetry)
    ctx.strokeStyle = "rgba(52,211,153,0.35)";
    ctx.beginPath();
    for(let i=0;i<N;i++){
      const x = xMap(rr[i]*1e3, A);
      const y = yMap(-yEnv[i], A);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // draw real field
    ctx.strokeStyle = "rgba(125,211,252,0.90)";
    ctx.lineWidth = 1.6;
    ctx.beginPath();
    for(let i=0;i<N;i++){
      const x = xMap(rr[i]*1e3, A);
      const y = yMap(yRe[i], A);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // marker at r0
    const xr0 = xMap(r0*1e3, A);
    ctx.strokeStyle="rgba(251,191,36,0.85)";
    ctx.lineWidth=2;
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(xr0, A.py);
    ctx.lineTo(xr0, A.py + A.ph);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle="rgba(251,191,36,0.9)";
    ctx.font="12px " + getComputedStyle(document.documentElement).getPropertyValue("--sans");
    ctx.textAlign="left"; ctx.textBaseline="top";
    ctx.fillText("r = ct", xr0+6, A.py+6);

    // legend
    const lx = A.px + 12, ly = A.py + 12;
    ctx.fillStyle="rgba(0,0,0,0.35)";
    ctx.strokeStyle="rgba(255,255,255,0.16)";
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.roundRect(lx,ly,238,74,12);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle="rgba(233,237,246,0.92)";
    ctx.font="700 12px " + getComputedStyle(document.documentElement).getPropertyValue("--sans");
    ctx.fillText("Legend", lx+10, ly+18);

    // legend lines
    function legLine(y, color, text){
      ctx.strokeStyle=color;
      ctx.lineWidth=3;
      ctx.beginPath(); ctx.moveTo(lx+12,y); ctx.lineTo(lx+42,y); ctx.stroke();
      ctx.fillStyle="rgba(233,237,246,0.86)";
      ctx.font="12px " + getComputedStyle(document.documentElement).getPropertyValue("--sans");
      ctx.textAlign="left"; ctx.textBaseline="middle";
      ctx.fillText(text, lx+52, y);
    }
    legLine(ly+38, "rgba(125,211,252,0.90)", "Re{U(r,t)} (carrier + envelope)");
    legLine(ly+58, "rgba(52,211,153,0.85)", "|U| envelope  ~ (1/r)exp(-(t-r/c)^2/(2σt^2))");

    // footer annotation
    ctx.fillStyle="rgba(170,182,204,0.90)";
    ctx.font="12px " + getComputedStyle(document.documentElement).getPropertyValue("--mono");
    ctx.textAlign="left"; ctx.textBaseline="bottom";
    const shell = C*s.sig;
    ctx.fillText(`t=${s.t_ps.toFixed(2)} ps,  σt=${s.sig_fs.toFixed(1)} fs,  r0=ct=${(r0*1e3).toFixed(3)} mm,  cσt=${(shell*1e6).toFixed(2)} µm`, A.px, A.py + A.ph + 40);

    ctx.restore();
  }

  // --------------------------
  // Render orchestration
  // --------------------------
  function render(){
    const s = getState();
    updateReadouts(s);
    drawDiagram(s);
    drawMichelson(s);
    drawPulse(s);
  }

  // Events
  ["input","change"].forEach(ev=>{
    ui.lam.addEventListener(ev, render);
    ui.tilt.addEventListener(ev, render);
    ui.dL.addEventListener(ev, render);
    ui.tps.addEventListener(ev, render);
    ui.sig.addEventListener(ev, render);
  });

  // Smooth scroll for TOC
  document.querySelectorAll('a[href^="#"]').forEach(a=>{
    a.addEventListener("click", (e)=>{
      const id = a.getAttribute("href");
      if(!id || id.length<2) return;
      const el = document.querySelector(id);
      if(!el) return;
      e.preventDefault();
      el.scrollIntoView({behavior:"smooth", block:"start"});
      history.pushState(null, "", id);
    });
  });

  // Resize handling
  let rAF = null;
  window.addEventListener("resize", ()=>{
    if(rAF) cancelAnimationFrame(rAF);
    rAF = requestAnimationFrame(render);
  });

  // Initial draw
  render();
})();
</script>
</body>
</html>
