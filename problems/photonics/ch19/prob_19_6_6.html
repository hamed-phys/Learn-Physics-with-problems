<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>SNR for an Analog APD Receiver: Effect of Ionization Ratio k</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --panel2:#0f1730;
      --text:#eaf0ff;
      --muted:#b9c6ff;
      --soft:#93a6ff;
      --accent:#7cf0c2;
      --accent2:#ffcc7a;
      --danger:#ff6b8b;
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.16);
      --shadow: 0 18px 50px rgba(0,0,0,.45);
      --radius: 18px;
      --radius2: 22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{ box-sizing:border-box; }
    html{ scroll-behavior:smooth; }
    body{
      margin:0;
      background: radial-gradient(1200px 800px at 20% 0%, rgba(124,240,194,.10), transparent 55%),
                  radial-gradient(900px 700px at 90% 20%, rgba(255,204,122,.10), transparent 55%),
                  linear-gradient(180deg, #070b16 0%, #0b1020 100%);
      color:var(--text);
      font-family:var(--sans);
      line-height:1.55;
    }
    a{ color:var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }
    header{
      padding: 42px 18px 18px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .title{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
      align-items:start;
    }
    h1{
      margin:0;
      font-weight:800;
      letter-spacing:.2px;
      line-height:1.15;
      font-size: clamp(26px, 3.4vw, 42px);
    }
    .subtitle{
      color:var(--muted);
      max-width: 75ch;
      font-size: 1.04rem;
    }
    .layout{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 18px 60px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 18px;
      align-items:start;
    }
    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(17,26,51,.92), rgba(15,23,48,.88));
      border: 1px solid var(--line);
      border-radius: var(--radius2);
      padding: 14px 14px 10px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    nav.toc h2{
      margin: 0 0 10px;
      font-size: 0.98rem;
      letter-spacing: .3px;
      color: var(--soft);
      text-transform: uppercase;
    }
    nav.toc ul{
      list-style:none;
      padding:0;
      margin:0;
      display:grid;
      gap: 6px;
    }
    nav.toc a{
      display:block;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid transparent;
      color: var(--text);
      font-size: .98rem;
      background: rgba(255,255,255,.03);
    }
    nav.toc a:hover{
      border-color: var(--line2);
      background: rgba(124,240,194,.08);
      text-decoration:none;
    }
    main{
      display:grid;
      gap: 18px;
    }
    section{
      background: linear-gradient(180deg, rgba(17,26,51,.82), rgba(15,23,48,.76));
      border: 1px solid var(--line);
      border-radius: var(--radius2);
      padding: 18px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    section h2{
      margin: 0 0 10px;
      font-size: 1.35rem;
      letter-spacing:.2px;
    }
    section h3{
      margin: 16px 0 8px;
      font-size: 1.10rem;
      color: var(--soft);
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
      nav.toc{ position: relative; top: 0; }
      .grid2,.grid3{ grid-template-columns: 1fr; }
    }
    .callout{
      border: 1px solid var(--line2);
      border-radius: var(--radius);
      padding: 12px 12px 10px;
      background: rgba(255,255,255,.04);
    }
    .callout strong{ color: var(--accent); }
    .callout.warn strong{ color: var(--accent2); }
    .callout.danger strong{ color: var(--danger); }
    .eq{
      font-family: var(--mono);
      font-size: .98rem;
      background: rgba(0,0,0,.28);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 10px 10px;
      overflow:auto;
      position: relative;
    }
    .eq .copy{
      position:absolute;
      top:10px;
      right:10px;
    }
    .btn{
      appearance:none;
      border: 1px solid var(--line2);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:700;
      letter-spacing:.2px;
      transition: transform .08s ease, background .15s ease, border-color .15s ease;
    }
    .btn:hover{
      background: rgba(124,240,194,.10);
      border-color: rgba(124,240,194,.35);
    }
    .btn:active{ transform: translateY(1px); }
    .small{
      color: var(--muted);
      font-size: .96rem;
    }
    ul{ margin: 8px 0 0 18px; }
    li{ margin: 6px 0; }
    .flex{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .controls{
      display:grid;
      gap: 10px;
    }
    .ctrl{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items:center;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.03);
    }
    .ctrl label{
      font-weight:700;
      color: var(--text);
    }
    .ctrl .val{
      font-family: var(--mono);
      color: var(--accent);
      font-weight:800;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .canvasWrap{
      border: 1px solid var(--line2);
      border-radius: var(--radius2);
      overflow:hidden;
      background: radial-gradient(800px 500px at 25% 0%, rgba(124,240,194,.08), transparent 55%),
                  radial-gradient(700px 500px at 85% 10%, rgba(255,204,122,.08), transparent 55%),
                  rgba(0,0,0,.18);
    }
    figure{ margin:0; }
    figcaption{
      padding: 10px 12px 12px;
      color: var(--muted);
      font-size: .95rem;
      border-top: 1px solid var(--line);
      background: rgba(0,0,0,.16);
    }
    .kpiRow{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin-top: 12px;
    }
    .kpi{
      border: 1px solid var(--line2);
      border-radius: 16px;
      padding: 10px 10px 12px;
      background: rgba(255,255,255,.04);
      min-height: 84px;
    }
    .kpi .tag{
      color: var(--muted);
      font-size: .88rem;
    }
    .kpi .big{
      font-family: var(--mono);
      font-weight: 900;
      font-size: 1.08rem;
      margin-top: 6px;
      color: var(--text);
    }
    .kpi .big em{
      font-style: normal;
      color: var(--accent);
    }
    @media (max-width: 980px){
      .kpiRow{ grid-template-columns: 1fr 1fr; }
    }
    footer{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 18px 60px;
      color: var(--muted);
      font-size: .95rem;
    }
    .printHint{
      margin-top: 10px;
      font-size: .92rem;
      color: rgba(255,255,255,.65);
    }
    @media print{
      body{ background:#fff; color:#000; }
      nav.toc{ display:none; }
      section{ box-shadow:none; backdrop-filter:none; border-color:#ddd; background:#fff; }
      .eq{ background:#f6f6f6; border-color:#ddd; }
      .btn{ display:none; }
      .canvasWrap{ border-color:#ddd; }
      figcaption{ background:#fff; border-color:#ddd; color:#333; }
      a{ color:#000; text-decoration:underline; }
    }
  </style>
</head>

<body>
  <header>
    <div class="title">
      <h1>Signal-to-Noise Ratio for an Analog APD Receiver: How Changing <span style="color:var(--accent)">k</span> Changes SNR</h1>
      <div class="subtitle">
        We analyze an avalanche photodiode (APD) receiver when <strong>circuit noise is negligible</strong>. The key physics is that
        APD multiplication increases signal <em>and</em> shot noise, and the ratio is controlled mainly by the <strong>excess noise factor</strong> <code>F(G,k)</code>.
      </div>
    </div>
  </header>

  <div class="layout">
    <nav class="toc" aria-label="Table of contents">
      <h2>Table of Contents</h2>
      <ul>
        <li><a href="#quick">Quick Summary</a></li>
        <li><a href="#p0">PART 0 — Concept Primer</a></li>
        <li><a href="#p1">PART 1 — Problem Analysis</a></li>
        <li><a href="#p2">PART 2 — Strategy &amp; Tips</a></li>
        <li><a href="#p3">PART 3 — Full Solution</a></li>
        <li><a href="#p4">PART 4 — Deeper Understanding</a></li>
        <li><a href="#p5">PART 5 — Visualization Guide</a></li>
      </ul>
      <div class="printHint">Tip: print-friendly styling is built in.</div>
    </nav>

    <main>
      <section id="quick">
        <h2>Quick Summary</h2>
        <ul>
          <li><strong>What this is:</strong> An analog APD receiver SNR comparison when the <em>ionization ratio</em> changes from <code>k=0.1</code> to <code>k=0.2</code> at mean gain <code>G=100</code>.</li>
          <li><strong>Key idea:</strong> APD gain multiplies both signal and shot noise; the remaining penalty is the <strong>excess noise factor</strong> <code>F(G,k)</code>.</li>
          <li><strong>Governing noise model (McIntyre):</strong> <code>F(G,k) = kG + (1-k)(2 - 1/G)</code> (for conventional APDs).</li>
          <li><strong>SNR scaling (circuit noise negligible):</strong> <code>SNR ∝ 1/F(G,k)</code> for fixed primary photocurrent and bandwidth.</li>
          <li><strong>Numeric result at G=100:</strong> <code>F(100,0.1)=11.791</code>, <code>F(100,0.2)=21.592</code>.</li>
          <li><strong>Factor change:</strong> <code>SNR(k=0.2)/SNR(k=0.1) = 11.791/21.592 ≈ 0.546</code> → SNR drops by about <strong>1.83×</strong>.</li>
          <li><strong>Asymptotic proof target:</strong> If <code>G≫1</code> and <code>G≫2(1-k)/k</code>, then <code>F≈kG</code> so <code>SNR ∝ 1/G</code>.</li>
        </ul>
      </section>

      <section id="p0">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <div class="grid2">
          <div class="callout">
            <strong>Core definitions (symbols &amp; units)</strong>
            <ul>
              <li><code>G</code> (dimensionless): mean avalanche multiplication (a.k.a. mean gain, sometimes <code>M</code>).</li>
              <li><code>k</code> (dimensionless): ionization ratio, typically <code>k = β/α</code> where <code>α</code> is electron and <code>β</code> is hole ionization coefficient (or vice versa depending on convention; what matters is <code>0&lt;k≤1</code> and smaller <code>k</code> gives lower noise).</li>
              <li><code>F(G,k)</code> (dimensionless): excess noise factor—how much noisier multiplication is compared with noiseless gain.</li>
              <li><code>I_p</code> (A): primary (unmultiplied) average photocurrent produced by absorbed photons.</li>
              <li><code>B</code> (Hz): receiver noise-equivalent bandwidth.</li>
              <li><code>q</code> (C): electron charge, <code>q = 1.602×10⁻¹⁹</code> C.</li>
            </ul>
          </div>

          <div class="callout warn">
            <strong>Physical meaning</strong>
            <ul>
              <li>Multiplication creates a stochastic “avalanche tree.” The output current fluctuates more than simple Poisson shot noise, and <code>F</code> captures that extra randomness.</li>
              <li><code>k</code> measures how symmetric the ionization process is. If one carrier ionizes much more readily than the other (small <code>k</code>), the avalanche is more “one-sided” and less noisy.</li>
              <li>In analog receivers (not Geiger mode), we treat gain as a random multiplier with mean <code>G</code> and variance related to <code>F</code>.</li>
            </ul>
          </div>
        </div>

        <h3>Key laws / principles (and validity)</h3>
        <ul>
          <li><strong>Shot-noise current spectral density (with APD multiplication):</strong> for primary current <code>I_p</code>,
            the (double-sided) current-noise PSD is modeled as
            <span class="small"><code>S_i ≈ 2 q I_p G² F(G,k)</code></span>.
            This holds when the noise is dominated by carrier discreteness and multiplication statistics, and the APD operates in linear mode.</li>
          <li><strong>Excess noise factor (McIntyre model):</strong> for a “conventional” APD,
            <span class="small"><code>F(G,k) = kG + (1-k)(2 - 1/G)</code></span>.</li>
          <li><strong>When circuit noise is negligible:</strong> thermal/amp noise terms are small compared with multiplied shot noise, so SNR is set primarily by <code>F(G,k)</code>.</li>
        </ul>

        <h3>Common models / approximations and why we use them</h3>
        <ul>
          <li><strong>McIntyre excess-noise model:</strong> gives a simple closed form for <code>F</code> in terms of <code>G</code> and <code>k</code>; widely used for design intuition.</li>
          <li><strong>Large-gain approximation:</strong> when <code>G≫1</code>, the term <code>1/G</code> is negligible, simplifying <code>F</code>.</li>
          <li><strong>Dominant term test:</strong> when <code>kG</code> dominates the constant part of <code>F</code>, then <code>F≈kG</code> and the SNR scales like <code>1/G</code>.</li>
        </ul>

        <h3>Mini intuition examples</h3>
        <ul>
          <li><strong>Example A (fixed k, increasing G):</strong> Signal current rises ∝<code>G</code>, but noise also rises; if <code>F</code> rises roughly ∝<code>G</code>, the net SNR can actually <em>decrease</em> with gain.</li>
          <li><strong>Example B (fixed G, increasing k):</strong> More “two-carrier” ionization randomness → larger <code>F</code> → smaller SNR.</li>
        </ul>

        <div class="callout danger">
          <strong>What to watch for (pitfalls)</strong>
          <ul>
            <li>Mixing up <code>G</code> (mean gain) with a deterministic amplifier gain: APD gain is <em>noisy</em>, and <code>F</code> matters.</li>
            <li>Forgetting that in shot-noise-limited analog detection, many <code>G²</code> factors cancel in SNR; the leftover dependence is mainly through <code>F</code>.</li>
            <li>Using the wrong <code>F</code> formula (there are variants for different structures); the problem explicitly says “conventional APD.”</li>
          </ul>
        </div>
      </section>

      <section id="p1">
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

        <h3>Rewrite the problem in plain words</h3>
        <p>
          We have an analog optical receiver using a conventional APD with mean multiplication <code>G = 100</code>.
          Assume circuit noise is negligible (so shot noise dominates).
          We increase the APD ionization ratio from <code>k = 0.1</code> to <code>k = 0.2</code>.
          Find by what factor the receiver’s signal-to-noise ratio (SNR) changes.
          Also prove that if <code>G ≫ 1</code> and <code>G ≫ 2(1-k)/k</code>, then <code>SNR</code> is approximately inversely proportional to <code>G</code>.
        </p>

        <div class="grid2">
          <div class="callout">
            <strong>Given</strong>
            <ul>
              <li>Mean gain: <code>G = 100</code></li>
              <li>Ionization ratio changes: <code>k: 0.1 → 0.2</code></li>
              <li>Circuit noise negligible (shot-noise-limited)</li>
              <li>Conventional APD excess noise model applies</li>
            </ul>
          </div>
          <div class="callout">
            <strong>Unknowns / tasks</strong>
            <ul>
              <li>Factor: <code>SNR(k=0.2)/SNR(k=0.1)</code> at <code>G=100</code></li>
              <li>Show asymptotic scaling: <code>SNR ∝ 1/G</code> under stated inequalities</li>
            </ul>
          </div>
        </div>

        <h3>Relevant principles and why they apply</h3>
        <ul>
          <li><strong>Shot noise + APD multiplication statistics:</strong> Since circuit noise is negligible, the SNR is controlled by shot noise enhanced by multiplication randomness.</li>
          <li><strong>Excess noise factor <code>F(G,k)</code>:</strong> It directly scales the multiplied shot noise; changing <code>k</code> changes <code>F</code> and thus SNR.</li>
          <li><strong>Why not include thermal/amp noise:</strong> Explicitly excluded by assumption; including it would introduce additional terms (and could create an optimal <code>G</code>), but that’s not this problem.</li>
        </ul>

        <div class="callout warn">
          <strong>Assumptions (explicit)</strong>
          <ul>
            <li>Linear (analog) APD operation; mean gain <code>G</code> well-defined.</li>
            <li>Receiver bandwidth <code>B</code> fixed; optical power (hence primary current <code>I_p</code>) fixed during the comparison.</li>
            <li>Dominant noise is multiplied shot noise governed by <code>F(G,k)</code>.</li>
          </ul>
        </div>

        <h3>Possible approaches (compare briefly)</h3>
        <ul>
          <li><strong>Approach 1: Use the known SNR ∝ 1/F result</strong> (fastest): derive or cite that gain terms cancel, leaving SNR inversely proportional to <code>F</code>, then compute ratio using <code>F(G,k)</code>.</li>
          <li><strong>Approach 2: Start from noise PSD and compute output noise variance</strong> (most transparent): write <code>S_i = 2q I_p G² F</code>, integrate over bandwidth, form SNR, then simplify.</li>
          <li><strong>Approach 3: Use asymptotics first</strong> (good for scaling): show <code>F≈kG</code> under conditions, then compute numeric ratio.</li>
        </ul>
        <p>
          <strong>Chosen approach:</strong> Approach 2 (PSD → SNR) because it shows <em>why</em> the cancellation happens and makes the final ratio unambiguous.
        </p>
      </section>

      <section id="p2">
        <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>

        <ol>
          <li><strong>Goal:</strong> Write the APD multiplied signal current.
            <br><span class="small">Tool:</span> <code>I_s = G I_p</code>.
            <br><span class="small">Meaning:</span> Gain scales the mean signal linearly.</li>
          <li><strong>Goal:</strong> Write the multiplied shot-noise PSD.
            <br><span class="small">Tool:</span> <code>S_i = 2 q I_p G² F(G,k)</code>.
            <br><span class="small">Meaning:</span> Noise rises with <code>G²</code>, plus an extra factor <code>F</code>.</li>
          <li><strong>Goal:</strong> Convert PSD to noise variance in bandwidth <code>B</code>.
            <br><span class="small">Tool:</span> <code>σ_i² = S_i B</code> (noise-equivalent bandwidth).
            <br><span class="small">Meaning:</span> Total mean-square noise current at the output.</li>
          <li><strong>Goal:</strong> Form SNR and simplify.
            <br><span class="small">Tool:</span> <code>SNR = I_s² / σ_i²</code>.
            <br><span class="small">Meaning:</span> Compare mean-square signal to mean-square noise.</li>
          <li><strong>Goal:</strong> Insert <code>F(G,k)=kG+(1-k)(2-1/G)</code> and compute numeric ratio for <code>G=100</code>.
            <br><span class="small">Meaning:</span> Isolate how changing <code>k</code> changes SNR.</li>
          <li><strong>Goal:</strong> Show asymptotic scaling.
            <br><span class="small">Tool:</span> Dominant-term comparison: if <code>kG</code> dominates, then <code>F≈kG</code>.
            <br><span class="small">Meaning:</span> SNR decreases roughly like <code>1/G</code> at high gain.</li>
        </ol>

        <div class="callout danger">
          <strong>Common mistakes &amp; quick tips</strong>
          <ul>
            <li><strong>Mistake:</strong> Forgetting <code>F</code> and concluding “gain doesn’t matter.” <strong>Tip:</strong> In shot-noise-limited APDs, <code>G</code> cancels but <code>F(G,k)</code> does not.</li>
            <li><strong>Mistake:</strong> Using <code>F ≈ kG</code> when it isn’t valid. <strong>Tip:</strong> Check whether <code>kG</code> is much larger than the constant term <code>≈ 2(1-k)</code>.</li>
          </ul>
        </div>
      </section>

      <section id="p3">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Physical intuition first (before math)</h3>
        <p>
          Increasing <code>k</code> makes the avalanche process more “two-sided” (both carrier types contribute comparably),
          which increases randomness of multiplication. That raises <code>F</code> and therefore increases the noise for the same mean signal,
          so we expect SNR to <strong>decrease</strong> when <code>k</code> increases from 0.1 to 0.2.
        </p>

        <h3>Step 1: Define the signal current</h3>
        <p>
          Let <code>I_p</code> be the <em>primary</em> (unmultiplied) average photocurrent produced by absorbed photons (units: A).
          The APD multiplies this current by the mean gain <code>G</code>, producing mean signal current
        </p>

        <div class="eq" id="eq-signal" data-copy="Mean signal current: I_s = G I_p">
          <button class="btn copy" data-copy-target="eq-signal">Copy</button>
          <code>I_s = G I_p</code>
        </div>

        <p class="small">
          What we did: wrote the linear-mode APD mean output current. This is the “useful” signal at the receiver front-end.
        </p>

        <h3>Step 2: Write the multiplied shot-noise PSD</h3>
        <p>
          For a conventional APD, the output shot-noise current spectral density (PSD) is modeled as
        </p>

        <div class="eq" id="eq-psd" data-copy="APD shot-noise PSD (approx.): S_i = 2 q I_p G^2 F(G,k)">
          <button class="btn copy" data-copy-target="eq-psd">Copy</button>
          <code>S_i = 2 q I_p G² F(G,k)</code>
        </div>

        <p class="small">
          What we did: multiplied the primary shot noise by <code>G²</code> because the avalanche multiplies current fluctuations,
          and included <code>F(G,k)</code> to account for the extra multiplication randomness beyond noiseless gain.
        </p>

        <h3>Step 3: Excess noise factor for a conventional APD</h3>
        <p>
          The McIntyre excess noise factor (conventional APD) is
        </p>

        <div class="eq" id="eq-F" data-copy="Excess noise factor (McIntyre): F(G,k) = kG + (1-k)(2 - 1/G)">
          <button class="btn copy" data-copy-target="eq-F">Copy</button>
          <code>F(G,k) = kG + (1-k)(2 - 1/G)</code>
        </div>

        <p class="small">
          What we did: introduced the model that links device physics (via <code>k</code>) and operating point (via <code>G</code>) to noise.
        </p>

        <h3>Step 4: Convert PSD to mean-square noise in bandwidth B</h3>
        <p>
          For an equivalent noise bandwidth <code>B</code> (Hz), the mean-square noise current is approximately
        </p>

        <div class="eq" id="eq-var" data-copy="Noise variance in bandwidth B: σ_i^2 = S_i B = 2 q I_p G^2 F(G,k) B">
          <button class="btn copy" data-copy-target="eq-var">Copy</button>
          <code>σ_i² = S_i B = 2 q I_p G² F(G,k) B</code>
        </div>

        <h3>Step 5: Form the SNR and simplify</h3>
        <p>
          Using the common current-domain definition <code>SNR = (mean signal)² / (noise variance)</code>,
        </p>

        <div class="eq" id="eq-snr-derive" data-copy="SNR = I_s^2/σ_i^2 = (G I_p)^2 / (2 q I_p G^2 F B) = I_p / (2 q F B)">
          <button class="btn copy" data-copy-target="eq-snr-derive">Copy</button>
          <code>
SNR = I_s² / σ_i²
    = (G I_p)² / (2 q I_p G² F(G,k) B)
    = I_p / (2 q F(G,k) B)
          </code>
        </div>

        <p class="small">
          What we did: the <code>G²</code> cancels! This is why, in a purely shot-noise-limited comparison at fixed <code>I_p</code> and <code>B</code>,
          the dependence on <code>G</code> comes mainly through <code>F(G,k)</code>.
        </p>

        <div class="callout">
          <strong>Key takeaway</strong>
          <div class="small">For fixed primary current and bandwidth (and negligible circuit noise),</div>
          <div class="eq" id="eq-snr-prop" data-copy="Shot-noise-limited APD: SNR ∝ 1/F(G,k)">
            <button class="btn copy" data-copy-target="eq-snr-prop">Copy</button>
            <code>SNR ∝ 1 / F(G,k)</code>
          </div>
        </div>

        <h3>Step 6: Compute the SNR change factor when k increases (G = 100)</h3>
        <p>
          Since <code>I_p</code>, <code>B</code>, and <code>q</code> are unchanged, the SNR ratio is just the inverse ratio of <code>F</code>:
        </p>

        <div class="eq" id="eq-ratio" data-copy="SNR2/SNR1 = F(G,k1)/F(G,k2) (with same I_p,B)">
          <button class="btn copy" data-copy-target="eq-ratio">Copy</button>
          <code>SNR(k₂)/SNR(k₁) = F(G,k₁) / F(G,k₂)</code>
        </div>

        <p>Compute <code>F(100,k)</code> using <code>2 - 1/G = 2 - 0.01 = 1.99</code>:</p>

        <div class="eq" id="eq-Fk" data-copy="At G=100: F= k*100 + (1-k)*1.99. For k=0.1: 11.791. For k=0.2: 21.592. Ratio=0.546 (~1/1.83).">
          <button class="btn copy" data-copy-target="eq-Fk">Copy</button>
          <code>
F(100,k) = 100k + (1-k)(1.99)

k=0.1: F = 10 + 0.9×1.99 = 10 + 1.791 = 11.791
k=0.2: F = 20 + 0.8×1.99 = 20 + 1.592 = 21.592

SNR(0.2)/SNR(0.1) = 11.791 / 21.592 ≈ 0.546
          </code>
        </div>

        <div class="callout" style="margin-top:12px;">
          <strong>Final numeric factor (boxed)</strong>
          <div class="eq" id="eq-final" data-copy="With G=100, SNR(k=0.2)/SNR(k=0.1) ≈ 0.546, i.e., SNR decreases by about 1.83×.">
            <button class="btn copy" data-copy-target="eq-final">Copy Final Answer</button>
            <code><strong>SNR(k=0.2)/SNR(k=0.1) ≈ 0.546</strong>  → SNR drops by ≈ <strong>1.83×</strong>.</code>
          </div>
        </div>

        <h3>Sanity checks</h3>
        <ul>
          <li><strong>Units:</strong> <code>F</code> is dimensionless, so the SNR ratio is dimensionless. Good.</li>
          <li><strong>Trend check:</strong> increasing <code>k</code> increased <code>F</code> (11.8 → 21.6), so SNR decreased. Matches intuition.</li>
          <li><strong>Limiting case:</strong> if <code>k</code> were smaller, <code>F</code> would be smaller and SNR larger—consistent with why low-<code>k</code> materials are desirable for APDs.</li>
        </ul>

        <h3>Step 7: Show that under the given conditions, SNR is ~ inversely proportional to G</h3>
        <p>
          Start from the exact <code>F</code> expression:
        </p>
        <div class="eq" id="eq-asym1" data-copy="F(G,k)=kG+(1-k)(2-1/G). If G≫1 then 1/G≈0 so F≈kG+2(1-k). If also G≫2(1-k)/k then kG≫2(1-k) so F≈kG, hence SNR∝1/F≈1/(kG)∝1/G.">
          <button class="btn copy" data-copy-target="eq-asym1">Copy</button>
          <code>
F(G,k)=kG+(1-k)(2-1/G)

If G≫1: 1/G≈0 → F≈kG+2(1-k)

If also G≫2(1-k)/k:
   kG ≫ 2(1-k)  → F≈kG

Since SNR ∝ 1/F:
   SNR ≈ 1/(kG)  ∝ 1/G
          </code>
        </div>

        <p class="small">
          What we did: used a two-step approximation—first remove a small term (<code>1/G</code>), then use a dominance condition to drop the constant part.
          The stated condition <code>G ≫ 2(1-k)/k</code> is exactly the requirement that <code>kG</code> dominates <code>2(1-k)</code>.
        </p>

        <p>
          Connection to the visuals: in the plots below, the “high-G” portion tends toward the <code>1/(kG)</code> behavior, so curves fall roughly like <code>1/G</code>.
        </p>
      </section>

      <section id="p4">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpreting the final formulas</h3>
        <ul>
          <li><strong><code>F(G,k)</code> controls everything here:</strong> With shot noise dominant, <code>SNR ∝ 1/F</code>. So any design step that reduces <code>F</code> increases SNR.</li>
          <li><strong>Term-by-term meaning:</strong>
            <ul>
              <li><code>kG</code>: noise growth from stochastic multiplication when both carrier types can ionize (scaled by <code>k</code>).</li>
              <li><code>(1-k)(2 - 1/G)</code>: residual contribution that stays near <code>2(1-k)</code> at large <code>G</code>.</li>
            </ul>
          </li>
          <li><strong>Why SNR can fall with higher gain:</strong> If <code>F</code> grows roughly linearly with <code>G</code>, then <code>SNR ∝ 1/F</code> falls roughly like <code>1/G</code> once <code>kG</code> dominates.</li>
        </ul>

        <h3>How changing parameters affects the outcome (connect to plots)</h3>
        <ul>
          <li>Increasing <code>k</code> raises <code>F</code> for a given <code>G</code> → SNR decreases (you’ll see the curve shift downward).</li>
          <li>Increasing <code>G</code> at fixed <code>k</code> eventually makes <code>kG</code> dominate → SNR approaches ~<code>1/G</code> behavior.</li>
          <li>If circuit noise were included (not in this problem), SNR could initially improve with <code>G</code> before excess noise dominates, creating an optimal gain.</li>
        </ul>

        <h3>Alternative derivation idea (brief)</h3>
        <p>
          Instead of using PSD, you can derive <code>SNR ∝ 1/F</code> by modeling the APD output charge in a time window as a random sum of multiplied photoelectrons.
          The mean grows as <code>G</code>, the variance grows as <code>G²F</code>, leading to the same cancellation of <code>G²</code> in SNR.
        </p>

        <h3>Concept checks (quick self-test)</h3>
        <ul>
          <li><strong>Q:</strong> If <code>k</code> increases, does <code>F</code> increase or decrease (at fixed <code>G</code>)? <strong>A:</strong> Increase → noisier multiplication.</li>
          <li><strong>Q:</strong> In this shot-noise-limited setup, why doesn’t higher <code>G</code> automatically improve SNR? <strong>A:</strong> Because multiplied shot noise grows too; SNR depends mainly on <code>F(G,k)</code>.</li>
          <li><strong>Q:</strong> What condition makes <code>F≈kG</code>? <strong>A:</strong> <code>G≫1</code> and <code>kG≫2(1-k)</code> ⇔ <code>G≫2(1-k)/k</code>.</li>
          <li><strong>Q:</strong> For fixed <code>G</code>, what is the SNR ratio when only <code>k</code> changes? <strong>A:</strong> <code>SNR₂/SNR₁ = F(G,k₁)/F(G,k₂)</code>.</li>
        </ul>
      </section>

      <section id="p5">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

        <div class="grid2">
          <div class="callout">
            <strong>What each canvas shows</strong>
            <ul>
              <li><strong>Diagram:</strong> optical power → APD (gain <code>G</code>, ratio <code>k</code>) → load; noise labeled as multiplied shot noise scaled by <code>F(G,k)</code>.</li>
              <li><strong>Main plot:</strong> <em>Normalized SNR</em> vs <code>G</code> for the currently selected <code>k</code>, alongside the high-gain approximation <code>~1/(kG)</code> (scaled to match at one point).</li>
              <li><strong>Secondary plot:</strong> SNR ratio vs <code>k</code> at the current <code>G</code>; the points <code>k=0.1</code> and <code>k=0.2</code> are highlighted so you can visually confirm the ~0.546 ratio.</li>
            </ul>
          </div>

          <div class="callout warn">
            <strong>Interactive controls</strong>
            <ul>
              <li><strong><code>k</code> slider:</strong> changes the ionization ratio; increasing it should push SNR curves downward (higher excess noise).</li>
              <li><strong><code>G</code> slider:</strong> changes the mean gain; at large <code>G</code> you should see the main curve approach an ~<code>1/G</code> falloff when conditions are satisfied.</li>
              <li><strong>All plots update live</strong> (and the KPI numbers update too).</li>
            </ul>
          </div>
        </div>

        <div class="grid2" style="margin-top:14px;">
          <article class="callout">
            <div class="flex">
              <strong>Interactive Controls (example values for plotting)</strong>
              <button class="btn" id="btnReset">Reset to Problem Values</button>
            </div>
            <div class="small" style="margin-top:6px;">
              For visualization only, we use example <code>I_p = 100 μA</code> and <code>B = 100 MHz</code> to compute an absolute SNR scale.
              The <em>factor</em> results are independent of these when comparing the same <code>I_p</code> and <code>B</code>.
            </div>

            <div class="controls" style="margin-top:10px;">
              <div class="ctrl">
                <div>
                  <label for="kSlider">Ionization ratio <code>k</code></label>
                  <div class="small">Controls excess noise (smaller is better).</div>
                </div>
                <div class="val" id="kVal">0.10</div>
                <div style="grid-column:1 / -1;">
                  <input id="kSlider" type="range" min="0.02" max="0.50" step="0.01" value="0.10"/>
                </div>
              </div>

              <div class="ctrl">
                <div>
                  <label for="gSlider">Mean gain <code>G</code></label>
                  <div class="small">APD multiplication (analog mode).</div>
                </div>
                <div class="val" id="gVal">100</div>
                <div style="grid-column:1 / -1;">
                  <input id="gSlider" type="range" min="2" max="200" step="1" value="100"/>
                </div>
              </div>

              <div class="ctrl">
                <div>
                  <label for="ipSlider">Example primary photocurrent <code>I_p</code> (μA)</label>
                  <div class="small">Only sets absolute SNR scale in plots.</div>
                </div>
                <div class="val" id="ipVal">100</div>
                <div style="grid-column:1 / -1;">
                  <input id="ipSlider" type="range" min="5" max="500" step="5" value="100"/>
                </div>
              </div>

              <div class="ctrl">
                <div>
                  <label for="bSlider">Example bandwidth <code>B</code> (MHz)</label>
                  <div class="small">Only sets absolute SNR scale in plots.</div>
                </div>
                <div class="val" id="bVal">100</div>
                <div style="grid-column:1 / -1;">
                  <input id="bSlider" type="range" min="10" max="500" step="10" value="100"/>
                </div>
              </div>
            </div>

            <div class="kpiRow" aria-label="Key results">
              <div class="kpi">
                <div class="tag">Excess noise <code>F(G,k)</code></div>
                <div class="big" id="kpiF">—</div>
              </div>
              <div class="kpi">
                <div class="tag">Example SNR</div>
                <div class="big" id="kpiSNR">—</div>
              </div>
              <div class="kpi">
                <div class="tag">Problem ratio <code>SNR(0.2)/SNR(0.1)</code> at <code>G=100</code></div>
                <div class="big"><em id="kpiRatio">0.546</em></div>
              </div>
              <div class="kpi">
                <div class="tag">High-gain test</div>
                <div class="big" id="kpiCond">—</div>
              </div>
            </div>
          </article>

          <article class="canvasWrap">
            <figure>
              <canvas id="cDiagram" style="width:100%; height:260px; display:block;"></canvas>
              <figcaption>
                Labeled setup diagram: optical input, APD gain <code>G</code>, ionization ratio <code>k</code>, and multiplied shot noise scaled by <code>F(G,k)</code>.
              </figcaption>
            </figure>
          </article>
        </div>

        <div class="grid2" style="margin-top:14px;">
          <article class="canvasWrap">
            <figure>
              <canvas id="cMain" style="width:100%; height:360px; display:block;"></canvas>
              <figcaption>
                Main plot: normalized SNR vs <code>G</code> for selected <code>k</code>, plus an aligned <code>~1/(kG)</code> high-gain approximation curve.
              </figcaption>
            </figure>
          </article>

          <article class="canvasWrap">
            <figure>
              <canvas id="cSecondary" style="width:100%; height:360px; display:block;"></canvas>
              <figcaption>
                Secondary plot: SNR ratio relative to <code>k=0.1</code> as <code>k</code> varies (at the current <code>G</code>), highlighting <code>k=0.2</code>.
              </figcaption>
            </figure>
          </article>
        </div>
      </section>
    </main>
  </div>

  <footer>
    <p>
      Built with vanilla HTML/CSS/JS. Models used: shot-noise-limited analog APD and McIntyre excess-noise factor for a conventional APD.
    </p>
  </footer>

  <script>
    // ---------- Copy buttons ----------
    function copyText(t){
      navigator.clipboard.writeText(t).then(()=>{},()=>{});
    }
    document.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-copy-target]');
      if(!btn) return;
      const id = btn.getAttribute('data-copy-target');
      const el = document.getElementById(id);
      if(!el) return;
      const text = el.getAttribute('data-copy') || el.innerText;
      copyText(text.trim());
      const old = btn.textContent;
      btn.textContent = "Copied!";
      setTimeout(()=> btn.textContent = old, 900);
    });

    // ---------- Physics model ----------
    const q = 1.602176634e-19;

    function excessNoiseF(G, k){
      // McIntyre conventional APD
      return k*G + (1-k)*(2 - 1/G);
    }

    function snrAbs(Ip, B, G, k){
      // Shot-noise-limited APD SNR (current-domain): SNR = Ip / (2 q B F)
      const F = excessNoiseF(G,k);
      return Ip / (2*q*B*F);
    }

    // ---------- Canvas helpers (hi-DPI, axes, plotting) ----------
    function setupCanvas(canvas){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {ctx, w: rect.width, h: rect.height, dpr};
    }

    function drawRoundedRect(ctx, x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function niceTicks(min, max, count){
      const span = max - min;
      if(span <= 0) return {step:1, start:min, stop:max};
      const raw = span / Math.max(1, count);
      const pow = Math.pow(10, Math.floor(Math.log10(raw)));
      const norm = raw / pow;
      let step;
      if(norm < 1.5) step = 1*pow;
      else if(norm < 3) step = 2*pow;
      else if(norm < 7) step = 5*pow;
      else step = 10*pow;
      const start = Math.ceil(min/step)*step;
      const stop  = Math.floor(max/step)*step;
      return {step, start, stop};
    }

    function axesPlot(ctx, box, xMin, xMax, yMin, yMax, opts){
      const {
        title="", xLabel="", yLabel="", grid=true,
        tickCountX=6, tickCountY=6
      } = opts || {};

      // background panel
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.14)";
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.lineWidth = 1;
      drawRoundedRect(ctx, box.x, box.y, box.w, box.h, 16);
      ctx.fill();
      ctx.stroke();

      const padL = 54, padR = 16, padT = 42, padB = 46;
      const px = box.x + padL;
      const py = box.y + padT;
      const pw = box.w - padL - padR;
      const ph = box.h - padT - padB;

      // title
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.font = "700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(title, box.x + 16, box.y + 22);

      // mapping
      const X = (x)=> px + (x - xMin) * pw / (xMax - xMin);
      const Y = (y)=> py + ph - (y - yMin) * ph / (yMax - yMin);

      // grid + ticks
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";

      const tx = niceTicks(xMin, xMax, tickCountX);
      const ty = niceTicks(yMin, yMax, tickCountY);

      // y gridlines + labels
      for(let y=ty.start; y<=ty.stop+1e-12; y+=ty.step){
        const yy = Y(y);
        if(grid){
          ctx.beginPath();
          ctx.moveTo(px, yy);
          ctx.lineTo(px+pw, yy);
          ctx.stroke();
        }
        ctx.fillText(formatTick(y), box.x + 10, yy + 4);
      }

      // x gridlines + labels
      for(let x=tx.start; x<=tx.stop+1e-12; x+=tx.step){
        const xx = X(x);
        if(grid){
          ctx.beginPath();
          ctx.moveTo(xx, py);
          ctx.lineTo(xx, py+ph);
          ctx.stroke();
        }
        const lab = formatTick(x);
        const tw = ctx.measureText(lab).width;
        ctx.fillText(lab, xx - tw/2, py+ph + 18);
      }

      // axes
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(px, py+ph);
      ctx.lineTo(px+pw, py+ph);
      ctx.stroke();

      // labels
      ctx.fillStyle = "rgba(255,255,255,0.82)";
      ctx.font = "700 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(xLabel, px + pw/2 - ctx.measureText(xLabel).width/2, box.y + box.h - 14);

      // rotated y label
      ctx.save();
      ctx.translate(box.x + 14, py + ph/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
      ctx.restore();

      ctx.restore();
      return {X,Y, px,py,pw,ph};
    }

    function formatTick(v){
      const av = Math.abs(v);
      if(av >= 1000 || (av > 0 && av < 0.01)) return v.toExponential(1);
      if(av >= 10) return v.toFixed(0);
      if(av >= 1) return v.toFixed(1);
      return v.toFixed(2);
    }

    function plotLine(ctx, map, xs, ys, style){
      ctx.save();
      ctx.strokeStyle = style.stroke || "rgba(124,240,194,0.95)";
      ctx.lineWidth = style.width || 2.0;
      ctx.beginPath();
      for(let i=0;i<xs.length;i++){
        const x = map.X(xs[i]), y = map.Y(ys[i]);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function plotPoints(ctx, map, pts, style){
      ctx.save();
      ctx.fillStyle = style.fill || "rgba(255,204,122,0.95)";
      ctx.strokeStyle = style.stroke || "rgba(0,0,0,0.35)";
      ctx.lineWidth = 1;
      const r = style.r || 4.5;
      for(const p of pts){
        const x = map.X(p.x), y = map.Y(p.y);
        ctx.beginPath();
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.fill();
        ctx.stroke();
      }
      ctx.restore();
    }

    function legend(ctx, box, items){
      ctx.save();
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      let x = box.x + 16, y = box.y + 30;
      for(const it of items){
        ctx.strokeStyle = it.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x+18, y);
        ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,0.86)";
        ctx.fillText(it.label, x+24, y+4);
        y += 18;
      }
      ctx.restore();
    }

    // ---------- Diagram ----------
    function drawDiagram(){
      const canvas = document.getElementById('cDiagram');
      const {ctx, w, h} = setupCanvas(canvas);

      ctx.clearRect(0,0,w,h);

      // Title
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.font = "800 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Physical Setup: Analog APD Receiver (Shot-noise limited)", 14, 20);

      const midY = 140;

      // Optical arrow
      ctx.strokeStyle = "rgba(124,240,194,0.95)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(20, midY);
      ctx.lineTo(160, midY);
      ctx.stroke();
      // arrow head
      ctx.beginPath();
      ctx.moveTo(160, midY);
      ctx.lineTo(148, midY-8);
      ctx.lineTo(148, midY+8);
      ctx.closePath();
      ctx.fillStyle = "rgba(124,240,194,0.95)";
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "12px ui-sans-serif, system-ui";
      ctx.fillText("Optical power → photons", 22, midY-16);
      ctx.fillText("Primary current: I_p", 22, midY+26);

      // APD block
      const apdX = 170, apdY = 82, apdW = 180, apdH = 120;
      ctx.fillStyle = "rgba(255,255,255,0.05)";
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.lineWidth = 1.5;
      drawRoundedRect(ctx, apdX, apdY, apdW, apdH, 18);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.font = "900 14px ui-sans-serif, system-ui";
      ctx.fillText("APD", apdX + 14, apdY + 22);
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillStyle = "rgba(124,240,194,0.95)";
      ctx.fillText("mean gain: G", apdX + 14, apdY + 46);
      ctx.fillStyle = "rgba(255,204,122,0.95)";
      ctx.fillText("ionization ratio: k", apdX + 14, apdY + 66);
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.fillText("excess noise: F(G,k)", apdX + 14, apdY + 86);
      ctx.fillText("signal: I_s = G I_p", apdX + 14, apdY + 106);

      // Electrical output arrow to load
      ctx.strokeStyle = "rgba(255,204,122,0.95)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(apdX + apdW, midY);
      ctx.lineTo(500, midY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(500, midY);
      ctx.lineTo(488, midY-8);
      ctx.lineTo(488, midY+8);
      ctx.closePath();
      ctx.fillStyle = "rgba(255,204,122,0.95)";
      ctx.fill();

      // Load / amplifier box
      const loadX = 510, loadY = 92, loadW = 190, loadH = 100;
      ctx.fillStyle = "rgba(255,255,255,0.05)";
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.lineWidth = 1.5;
      drawRoundedRect(ctx, loadX, loadY, loadW, loadH, 18);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.font = "800 13px ui-sans-serif, system-ui";
      ctx.fillText("Receiver / Load", loadX + 14, loadY + 24);
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "12px ui-sans-serif, system-ui";
      ctx.fillText("Circuit noise ≈ negligible", loadX + 14, loadY + 46);
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.fillText("Noise PSD: S_i ≈ 2 q I_p G^2 F", loadX + 14, loadY + 70);

      // small noise squiggle
      ctx.strokeStyle = "rgba(255,107,139,0.95)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      const sx = loadX + 14, sy = loadY + 84;
      for(let i=0;i<11;i++){
        const x = sx + i*12;
        const y = sy + (i%2===0 ? -6 : 6);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.fillStyle = "rgba(255,107,139,0.95)";
      ctx.font = "12px ui-sans-serif, system-ui";
      ctx.fillText("multiplied shot noise", loadX + 14 + 11*12 + 10, sy+4);
    }

    // ---------- Main plot: SNR vs G ----------
    function drawMainPlot(state){
      const canvas = document.getElementById('cMain');
      const {ctx, w, h} = setupCanvas(canvas);
      ctx.clearRect(0,0,w,h);

      const box = {x: 10, y: 10, w: w-20, h: h-20};

      // Data
      const Gmin = 2, Gmax = 200;
      const n = 220;
      const xs = [];
      const ys = [];
      const ysApprox = [];
      const k = state.k;
      const Ip = state.Ip;
      const B = state.B;

      for(let i=0;i<n;i++){
        const G = Gmin + (Gmax - Gmin)*i/(n-1);
        xs.push(G);
        const snr = snrAbs(Ip,B,G,k);
        ys.push(snr);
      }

      // Normalize for nicer display (divide by value at G=10)
      const Gref = 10;
      const snrRef = snrAbs(Ip,B,Gref,k);
      for(let i=0;i<n;i++){
        ys[i] /= snrRef;
      }

      // Approx curve: ~ 1/(kG), scaled to match exact at a matching point (Gmatch = 80)
      const Gmatch = 80;
      const exactMatch = (snrAbs(Ip,B,Gmatch,k)/snrRef);
      const approxBase = 1/(k*Gmatch);
      const scale = exactMatch / approxBase;
      for(let i=0;i<n;i++){
        const G = xs[i];
        ysApprox.push(scale * (1/(k*G)));
      }

      // y range
      let yMin = 0;
      let yMax = Math.max(...ys.slice(0, 60)) * 1.15; // emphasize low G region
      yMax = Math.max(yMax, 1.1);

      const map = axesPlot(ctx, box, Gmin, Gmax, yMin, yMax, {
        title: `Main Plot — Normalized SNR vs Gain G (selected k = ${k.toFixed(2)})`,
        xLabel: "Mean gain G (dimensionless)",
        yLabel: "Normalized SNR (relative to SNR at G=10)",
        tickCountX: 6,
        tickCountY: 6,
        grid: true
      });

      // plot
      plotLine(ctx, map, xs, ys, {stroke:"rgba(124,240,194,0.95)", width:2.6});
      plotLine(ctx, map, xs, ysApprox, {stroke:"rgba(255,204,122,0.92)", width:2.2});

      // markers at current G
      const Gcur = state.G;
      const snrCurNorm = snrAbs(Ip,B,Gcur,k)/snrRef;
      plotPoints(ctx, map, [{x:Gcur, y:snrCurNorm}], {fill:"rgba(255,107,139,0.95)", stroke:"rgba(0,0,0,0.35)", r:5.5});

      legend(ctx, box, [
        {label:"Exact (SNR ∝ 1/F(G,k))", color:"rgba(124,240,194,0.95)"},
        {label:"High-gain approx (scaled) ~ 1/(kG)", color:"rgba(255,204,122,0.92)"},
        {label:"Current (G slider)", color:"rgba(255,107,139,0.95)"}
      ]);

      // annotations about conditions
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "12px ui-sans-serif, system-ui";
      const cond = state.G > 10 && state.G > (2*(1-k)/k);
      ctx.fillText(`Condition check at current G: G≫1 and G≫2(1-k)/k ?  ${cond ? "approximately yes" : "not strongly"}`, box.x+16, box.y+box.h-18);
      ctx.restore();
    }

    // ---------- Secondary plot: SNR ratio vs k at fixed G ----------
    function drawSecondaryPlot(state){
      const canvas = document.getElementById('cSecondary');
      const {ctx, w, h} = setupCanvas(canvas);
      ctx.clearRect(0,0,w,h);

      const box = {x: 10, y: 10, w: w-20, h: h-20};

      const G = state.G;
      const Ip = state.Ip;
      const B = state.B;

      // compute ratio relative to k0=0.1
      const k0 = 0.10;
      const snr0 = snrAbs(Ip,B,G,k0);

      const kMin = 0.02, kMax = 0.50;
      const n = 200;
      const xs = [];
      const ys = [];
      for(let i=0;i<n;i++){
        const k = kMin + (kMax - kMin)*i/(n-1);
        xs.push(k);
        ys.push(snrAbs(Ip,B,G,k)/snr0);
      }

      // y range
      const yMin = 0;
      const yMax = Math.min(3.0, Math.max(...ys)*1.1);

      const map = axesPlot(ctx, box, kMin, kMax, yMin, yMax, {
        title: `Secondary Plot — SNR ratio vs k at fixed G = ${G}`,
        xLabel: "Ionization ratio k (dimensionless)",
        yLabel: "SNR(k) / SNR(k=0.10)",
        tickCountX: 6,
        tickCountY: 6,
        grid: true
      });

      plotLine(ctx, map, xs, ys, {stroke:"rgba(147,166,255,0.95)", width:2.6});

      // Highlight k=0.1 and k=0.2
      const ratioAt = (kk)=> snrAbs(Ip,B,G,kk)/snr0;
      const p1 = {x:0.10, y:1.0};
      const p2 = {x:0.20, y:ratioAt(0.20)};
      const pSel= {x:state.k, y:ratioAt(state.k)};

      plotPoints(ctx, map, [p1], {fill:"rgba(124,240,194,0.95)", r:5.5});
      plotPoints(ctx, map, [p2], {fill:"rgba(255,204,122,0.95)", r:5.5});
      plotPoints(ctx, map, [pSel], {fill:"rgba(255,107,139,0.95)", r:5.5});

      legend(ctx, box, [
        {label:"Ratio curve (relative to k=0.10)", color:"rgba(147,166,255,0.95)"},
        {label:"k=0.10 reference", color:"rgba(124,240,194,0.95)"},
        {label:"k=0.20 point", color:"rgba(255,204,122,0.95)"},
        {label:"Selected k", color:"rgba(255,107,139,0.95)"}
      ]);

      // annotate numeric ratio at k=0.2 for this G
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      const txt = `At this G: SNR(0.2)/SNR(0.1) = ${ratioAt(0.20).toFixed(3)}`;
      ctx.fillText(txt, box.x+16, box.y+box.h-18);
      ctx.restore();
    }

    // ---------- State & UI ----------
    const state = {
      k: 0.10,
      G: 100,
      Ip: 100e-6, // A
      B: 100e6    // Hz
    };

    function updateUI(){
      document.getElementById('kVal').textContent = state.k.toFixed(2);
      document.getElementById('gVal').textContent = String(state.G);
      document.getElementById('ipVal').textContent = String(Math.round(state.Ip*1e6));
      document.getElementById('bVal').textContent = String(Math.round(state.B*1e-6));

      const F = excessNoiseF(state.G, state.k);
      const snr = snrAbs(state.Ip, state.B, state.G, state.k);

      document.getElementById('kpiF').innerHTML = `<span style="color:var(--accent)">${F.toFixed(3)}</span>`;
      document.getElementById('kpiSNR').innerHTML = `<span style="color:var(--accent)">${formatSNR(snr)}</span>`;

      // High-gain condition check (interpret "≫" loosely as >10×)
      const thresh = 2*(1-state.k)/state.k;
      const ok1 = state.G > 10;
      const ok2 = state.G > 10*thresh;
      const msg = (ok1 && ok2) ? `G is comfortably large (≈ satisfies ≫).` :
                  (ok1 ? `G≫1 yes, but dominance vs 2(1−k)/k is not strong.` :
                         `G is not large; high-gain approximation is weak.`);
      document.getElementById('kpiCond').innerHTML =
        `<span style="color:${(ok1&&ok2)?'var(--accent)':'var(--accent2)'}">${msg}</span>`;

      drawDiagram();
      drawMainPlot(state);
      drawSecondaryPlot(state);
    }

    function formatSNR(v){
      if(v > 1e6) return v.toExponential(2);
      if(v > 1e3) return v.toFixed(0);
      if(v > 10) return v.toFixed(1);
      return v.toFixed(3);
    }

    // sliders
    const kSlider = document.getElementById('kSlider');
    const gSlider = document.getElementById('gSlider');
    const ipSlider = document.getElementById('ipSlider');
    const bSlider = document.getElementById('bSlider');
    const btnReset = document.getElementById('btnReset');

    kSlider.addEventListener('input', ()=>{
      state.k = parseFloat(kSlider.value);
      updateUI();
    });
    gSlider.addEventListener('input', ()=>{
      state.G = parseInt(gSlider.value, 10);
      updateUI();
    });
    ipSlider.addEventListener('input', ()=>{
      state.Ip = parseFloat(ipSlider.value) * 1e-6;
      updateUI();
    });
    bSlider.addEventListener('input', ()=>{
      state.B = parseFloat(bSlider.value) * 1e6;
      updateUI();
    });

    btnReset.addEventListener('click', ()=>{
      state.k = 0.10;
      state.G = 100;
      state.Ip = 100e-6;
      state.B = 100e6;
      kSlider.value = state.k;
      gSlider.value = state.G;
      ipSlider.value = 100;
      bSlider.value = 100;
      updateUI();
    });

    // resize handling
    let resizeTimer = null;
    window.addEventListener('resize', ()=>{
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(updateUI, 80);
    });

    // init KPI ratio (problem statement, fixed at G=100)
    (function initProblemRatio(){
      const F01 = excessNoiseF(100, 0.10);
      const F02 = excessNoiseF(100, 0.20);
      const ratio = F01 / F02;
      document.getElementById('kpiRatio').textContent = ratio.toFixed(3);
    })();

    updateUI();
  </script>
</body>
</html>
