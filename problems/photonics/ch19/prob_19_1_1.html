<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Effect of Reflectance on Quantum Efficiency: Transmission Factor T = 1 − R</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --card2:#0f1730;
      --text:#eaf0ff;
      --muted:#b8c3e6;
      --line:rgba(255,255,255,.12);
      --accent:#7aa7ff;
      --accent2:#7dffcf;
      --warn:#ffcf7d;
      --good:#9dff9d;
      --shadow: 0 12px 40px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:radial-gradient(1200px 700px at 20% -10%, rgba(122,167,255,.25), transparent 60%),
                                         radial-gradient(900px 600px at 110% 10%, rgba(125,255,207,.14), transparent 60%),
                                         var(--bg);
              color:var(--text); font-family:var(--sans); line-height:1.55;}
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding: clamp(18px, 3vw, 28px);
      border-bottom: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), transparent);
      position: relative;
      overflow:hidden;
    }
    header::after{
      content:"";
      position:absolute; inset:-200px -200px auto auto;
      width:420px; height:420px;
      background: radial-gradient(circle at 30% 30%, rgba(122,167,255,.22), transparent 60%);
      transform: rotate(18deg);
      pointer-events:none;
      filter: blur(.2px);
    }
    .title{
      max-width:1100px; margin:0 auto;
      display:grid; gap:10px;
    }
    .title h1{
      margin:0;
      font-size: clamp(22px, 3.2vw, 40px);
      letter-spacing:.2px;
      line-height:1.1;
    }
    .subtitle{
      color:var(--muted);
      font-size: clamp(13px, 1.45vw, 16px);
      max-width: 70ch;
    }

    main{
      max-width: 1100px;
      margin: 0 auto;
      padding: clamp(14px, 2.5vw, 26px);
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 18px;
      align-items:start;
    }

    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 14px 14px 10px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }
    nav.toc h2{
      margin:0 0 10px;
      font-size: 14px;
      color: var(--muted);
      letter-spacing:.4px;
      text-transform: uppercase;
    }
    nav.toc a{
      display:block;
      padding: 8px 10px;
      border-radius: 12px;
      margin: 4px 0;
      color: var(--text);
      border: 1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size: 14px;
    }
    nav.toc a:hover{
      background: rgba(122,167,255,.10);
      border-color: rgba(122,167,255,.22);
      transform: translateX(2px);
      text-decoration:none;
    }

    article{
      min-width:0;
      display:grid;
      gap: 16px;
    }

    section{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: clamp(14px, 2.4vw, 20px);
      box-shadow: var(--shadow);
    }
    section h2{
      margin:0 0 10px;
      font-size: 18px;
      letter-spacing:.2px;
    }
    section h3{
      margin: 14px 0 8px;
      font-size: 16px;
      color: #dbe6ff;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
      nav.toc{position: relative; top:0}
      .grid2{grid-template-columns: 1fr}
    }

    .callout{
      border-radius: 16px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      padding: 12px 12px;
      margin: 10px 0;
      position: relative;
      overflow:hidden;
    }
    .callout::before{
      content:"";
      position:absolute;
      inset:0 auto 0 0;
      width: 4px;
      background: var(--accent);
      opacity:.9;
    }
    .callout.warn::before{background: var(--warn)}
    .callout.good::before{background: var(--good)}
    .callout .label{
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: .4px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .mono{
      font-family: var(--mono);
      font-size: 13px;
      white-space: pre-wrap;
      word-break: break-word;
    }

    ul{margin: 8px 0 0 18px}
    li{margin: 6px 0}
    .eq{
      font-family: var(--mono);
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 10px 12px;
      overflow:auto;
    }

    .btnRow{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top: 10px;
    }
    button.copyBtn{
      appearance:none;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(122,167,255,.14);
      color: var(--text);
      padding: 9px 12px;
      border-radius: 14px;
      cursor:pointer;
      font-weight:600;
      letter-spacing:.2px;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    button.copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(122,167,255,.20);
      border-color: rgba(122,167,255,.30);
    }
    button.copyBtn:active{transform: translateY(0px) scale(.99)}
    .copyHint{color: var(--muted); font-size: 12px}

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      align-items:end;
      margin: 10px 0 2px;
    }
    .controls label{
      display:block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
      letter-spacing:.2px;
    }
    select,input[type="range"]{
      width:100%;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 12px;
      padding: 10px 10px;
      color: var(--text);
      outline: none;
    }
    input[type="range"]{
      padding: 10px 0;
      height: 42px;
    }
    .readout{
      font-family: var(--mono);
      font-size: 13px;
      color: var(--text);
      opacity:.95;
    }

    figure{
      margin: 0;
      display:grid;
      gap:10px;
    }
    canvas{
      width:100%;
      height: 320px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.10));
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.18);
    }
    .canvasTall{height: 360px;}
    .caption{
      color: var(--muted);
      font-size: 12px;
    }

    table{
      width:100%;
      border-collapse: collapse;
      overflow:hidden;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.14);
    }
    th,td{
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      text-align:left;
      font-size: 14px;
    }
    th{
      color: var(--muted);
      font-weight:700;
      background: rgba(255,255,255,.06);
    }
    tr:last-child td{border-bottom:none}
    .kpi{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    .pill{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.16);
      border-radius: 16px;
      padding: 10px 12px;
    }
    .pill .t{color: var(--muted); font-size: 12px; letter-spacing:.3px; text-transform:uppercase}
    .pill .v{font-family: var(--mono); font-size: 14px; margin-top: 6px}
    @media (max-width: 760px){ .kpi{grid-template-columns: 1fr} }

    footer{
      max-width: 1100px;
      margin: 0 auto 20px;
      padding: 0 26px 24px;
      color: var(--muted);
      font-size: 12px;
      opacity:.9;
    }

    /* Print-friendly */
    @media print{
      :root{--bg:#fff; --text:#000; --muted:#333; --card:#fff; --card2:#fff; --line:#ccc}
      body{background:#fff}
      nav.toc{display:none}
      main{grid-template-columns: 1fr}
      section{box-shadow:none}
      canvas{display:none}
      a{color:#000}
    }
  </style>
</head>

<body>
<header>
  <div class="title">
    <h1>Effect of Reflectance on Quantum Efficiency: Transmission Factor <span class="mono">T = 1 − R</span></h1>
    <div class="subtitle">
      We compute the surface-transmission factor that multiplies the photoelectric-detector quantum efficiency
      <span class="mono">η = (1 − R)·ζ·[1 − exp(−αd)]</span> for an unpolarized beam from air into Si, GaAs, and InSb,
      at normal incidence and at 45° incidence, using Fresnel reflectance.
    </div>
  </div>
</header>

<main>
  <nav class="toc" aria-label="Table of contents">
    <h2>On this page</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
  </nav>

  <article>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>Goal:</b> compute the surface transmission factor <span class="mono">T = 1 − R</span> that reduces detector quantum efficiency due to Fresnel reflection at the air–semiconductor interface.</li>
        <li><b>Key idea:</b> at an interface, part of optical power reflects; the remainder enters the semiconductor and can be absorbed to generate carriers.</li>
        <li><b>Governing relation:</b> <span class="mono">η = (1 − R)·ζ·[1 − exp(−αd)]</span> → the requested factor is <span class="mono">1 − R</span>.</li>
        <li><b>Normal incidence:</b> <span class="mono">R = ((n1 − n2)/(n1 + n2))^2</span> for real refractive indices.</li>
        <li><b>Oblique incidence (unpolarized):</b> <span class="mono">R = (Rs + Rp)/2</span>, using Fresnel <span class="mono">Rs(θ)</span>, <span class="mono">Rp(θ)</span> with Snell’s law.</li>
        <li><b>Numerical results (air → material):</b> at 45° incidence, <span class="mono">T ≈ 0.6898 (Si), 0.6796 (GaAs), 0.6234 (InSb)</span>.</li>
        <li><b>Result type:</b> symbolic Fresnel formulas + computed numeric <span class="mono">T</span> at 0° and 45° for the given indices.</li>
      </ul>

      <div class="btnRow">
        <button class="copyBtn" data-copy="eqs">Copy key equations</button>
        <button class="copyBtn" data-copy="final">Copy final numeric answers</button>
        <span class="copyHint" id="copyStatus" aria-live="polite"></span>
      </div>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <h3>Core definitions (symbols & units)</h3>
      <ul>
        <li><b>Quantum efficiency</b> <span class="mono">η</span> (dimensionless): fraction of incident photons that produce collected charge carriers.</li>
        <li><b>Reflectance</b> <span class="mono">R</span> (dimensionless): fraction of incident <i>optical power</i> reflected at the surface.</li>
        <li><b>Transmission factor</b> <span class="mono">T = 1 − R</span> (dimensionless): fraction of incident power that enters the semiconductor (single interface, no multiple reflections).</li>
        <li><b>Refractive index</b> <span class="mono">n</span> (dimensionless): phase velocity ratio; here treated as real (low absorption near bandgap, as in the provided table).</li>
        <li><b>Absorption coefficient</b> <span class="mono">α</span> (m<sup>−1</sup>) and thickness <span class="mono">d</span> (m): set the absorbed fraction <span class="mono">1 − exp(−αd)</span>.</li>
        <li><b>Internal collection factor</b> <span class="mono">ζ</span> (dimensionless): accounts for carrier collection losses (recombination, transport, etc.).</li>
      </ul>

      <h3>Physical meaning</h3>
      <div class="callout">
        <div class="label">Meaning</div>
        <div>
          Even if a semiconductor is an excellent absorber, photons must first <i>enter</i> it. The air–semiconductor index jump is large
          (e.g., air <span class="mono">n≈1</span> to InSb <span class="mono">n≈4.2</span>), so Fresnel reflection can discard a substantial portion of light
          <i>before</i> absorption and carrier generation ever occur.
        </div>
      </div>

      <h3>Key laws / principles (validity & assumptions)</h3>
      <ul>
        <li><b>Maxwell boundary conditions</b> at a planar interface lead to <b>Fresnel coefficients</b> for reflected/transmitted fields.</li>
        <li><b>Snell’s law</b> <span class="mono">n1 sinθi = n2 sinθt</span> links incident and transmitted angles.</li>
        <li>We assume: flat interface, homogeneous isotropic media, no surface roughness, and real refractive indices (negligible extinction coefficient).</li>
        <li>We also use the common detector model where the “surface loss” is captured by <span class="mono">(1 − R)</span> and the “bulk absorption” by <span class="mono">[1 − exp(−αd)]</span>.</li>
      </ul>

      <h3>Common models / approximations and why</h3>
      <ul>
        <li><b>Non-absorbing interface model:</b> treat <span class="mono">n</span> as real → simplifies Fresnel reflectance to real-valued formulas.</li>
        <li><b>Unpolarized light:</b> average reflectance of s and p polarizations: <span class="mono">R = (Rs + Rp)/2</span>.</li>
        <li><b>Single-pass interface:</b> ignore multiple internal reflections (valid when the detector has AR coating, surface texturing, or when subsequent reflections are negligible compared to bulk absorption).</li>
      </ul>

      <h3>Mini intuition examples</h3>
      <ul>
        <li><b>Normal incidence:</b> if <span class="mono">n2 ≫ n1</span>, then <span class="mono">R → 1</span> (strong reflection) and <span class="mono">T → 0</span>. Big index jumps are “mirror-like.”</li>
        <li><b>Oblique incidence:</b> p-polarized reflection can dip near Brewster’s angle (for <span class="mono">n2 &gt; n1</span>), so unpolarized <span class="mono">R</span> can change with angle.</li>
      </ul>

      <h3>What to watch for (pitfalls)</h3>
      <div class="callout warn">
        <div class="label">Common pitfalls</div>
        <ul>
          <li>Mixing up field coefficients vs power reflectance: use <span class="mono">R = |r|^2</span>, not <span class="mono">r</span>.</li>
          <li>For oblique incidence, forgetting Snell’s law to get <span class="mono">θt</span>.</li>
          <li>Using the wrong p-polarization Fresnel formula (note the swapped indices vs s-polarization).</li>
          <li>Assuming <span class="mono">T = 1 − R</span> always equals transmitted power into medium 2 for any angle/polarization—this is okay here because the problem explicitly asks for the factor <span class="mono">1 − R</span> in Eq. (19.1-3), but more detailed radiometry sometimes uses a separate transmittance factor.</li>
        </ul>
      </div>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Problem restatement</h3>
      <p>
        A photoelectric detector has quantum efficiency
        <span class="mono">η = (1 − R)·ζ·[1 − exp(−αd)]</span>.
        Compute the <b>surface transmission factor</b> <span class="mono">T = 1 − R</span> for an <b>unpolarized</b> beam incident from air onto three semiconductors
        (Si, GaAs, InSb) at <b>normal incidence</b> and at <b>45° incidence</b>. Use the refractive indices from the provided table:
        <span class="mono">n(Si)=3.5</span>, <span class="mono">n(GaAs)=3.6</span>, <span class="mono">n(InSb)=4.2</span>, and <span class="mono">n(air)=1</span>.
      </p>

      <div class="grid2">
        <div class="callout">
          <div class="label">Given</div>
          <ul>
            <li>Incident medium: air, <span class="mono">n1 = 1.0</span></li>
            <li>Semiconductors (near bandgap, 300 K): <span class="mono">n2 = 3.5 (Si), 3.6 (GaAs), 4.2 (InSb)</span></li>
            <li>Angles of incidence: <span class="mono">θi = 0°</span> and <span class="mono">θi = 45°</span></li>
            <li>Light: unpolarized</li>
          </ul>
        </div>
        <div class="callout">
          <div class="label">Unknowns / find</div>
          <ul>
            <li>Reflectance <span class="mono">R</span> at the interface for each material and angle</li>
            <li>Transmission factor <span class="mono">T = 1 − R</span> (dimensionless)</li>
          </ul>
        </div>
      </div>

      <h3>Relevant physics and why it applies</h3>
      <ul>
        <li><b>Fresnel reflection</b> applies because we have a planar boundary between two dielectric media with different refractive indices.</li>
        <li><b>Snell’s law</b> applies to determine the transmitted angle in the higher-index semiconductor.</li>
        <li>We do <b>not</b> need absorption (<span class="mono">α</span>) or thickness (<span class="mono">d</span>) because the question isolates the factor <span class="mono">T = 1 − R</span>.</li>
      </ul>

      <div class="callout">
        <div class="label">Assumptions</div>
        <ul>
          <li>Indices are real (no significant absorption at the interface for this calculation).</li>
          <li>Surface is flat; no AR coating; no surface roughness scattering.</li>
          <li>Unpolarized beam ⇒ average of s and p reflectances.</li>
          <li>Use the detector model’s surface factor exactly as stated: <span class="mono">T = 1 − R</span>.</li>
        </ul>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ol>
        <li><b>Normal-incidence shortcut:</b> use <span class="mono">R=((n1−n2)/(n1+n2))^2</span>. <i>Fast</i>, but only valid for <span class="mono">θi=0</span>.</li>
        <li><b>Full Fresnel method:</b> compute <span class="mono">Rs</span>, <span class="mono">Rp</span> with Snell’s law, then average. <i>General</i> and needed for 45°.</li>
        <li><b>Impedance method:</b> derive reflection from wave impedances and boundary conditions. Insightful, but longer than needed for numeric outputs.</li>
      </ol>
      <p><b>Best choice:</b> Use Fresnel formulas (covers both 0° and 45°; simplest consistent workflow).</p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>
      <ol>
        <li>
          <b>Set indices:</b> <span class="mono">n1=1</span>, choose <span class="mono">n2</span> from the material list.
          <div class="caption">Meaning: you’re defining the optical “mismatch” at the interface.</div>
        </li>
        <li>
          <b>Pick incidence angle</b> <span class="mono">θi</span> (0° or 45°).
          <div class="caption">Meaning: controls how boundary conditions split into s and p polarizations.</div>
        </li>
        <li>
          <b>Compute transmitted angle</b> via Snell:
          <span class="mono">n1 sinθi = n2 sinθt</span> → <span class="mono">θt = asin((n1/n2) sinθi)</span>.
          <div class="caption">Meaning: ray bends toward the normal because <span class="mono">n2 &gt; n1</span>.</div>
        </li>
        <li>
          <b>Compute Fresnel field reflection coefficients</b> <span class="mono">rs</span>, <span class="mono">rp</span>.
          <div class="caption">Meaning: how much of the electric-field amplitude reflects.</div>
        </li>
        <li>
          <b>Convert to power reflectance:</b> <span class="mono">Rs = |rs|^2</span>, <span class="mono">Rp = |rp|^2</span>.
          <div class="caption">Meaning: fraction of incident power in each polarization that reflects.</div>
        </li>
        <li>
          <b>Unpolarized average:</b> <span class="mono">R = (Rs + Rp)/2</span>.
          <div class="caption">Meaning: equal mix of s and p components.</div>
        </li>
        <li>
          <b>Requested factor:</b> <span class="mono">T = 1 − R</span>.
          <div class="caption">Meaning: the “surface entry” fraction multiplying the detector QE.</div>
        </li>
      </ol>

      <div class="callout warn">
        <div class="label">Quick tips</div>
        <ul>
          <li>At <span class="mono">θi=0°</span>, s and p are identical, so you should get the normal-incidence formula automatically.</li>
          <li>Because <span class="mono">n2 &gt; n1</span>, there is <b>no</b> total internal reflection for incidence from air into the semiconductor.</li>
          <li>Sanity check: <span class="mono">0 ≤ R ≤ 1</span> and <span class="mono">T = 1 − R</span> should be between 0 and 1.</li>
        </ul>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Physical intuition before calculating</h3>
      <p>
        Air has <span class="mono">n≈1</span>, while these semiconductors have <span class="mono">n≈3.5–4.2</span>.
        Such a large index step behaves like a partial mirror, so we expect a sizable reflectance (tens of percent).
        At 45° incidence, s-polarization typically reflects more strongly than p-polarization, so the unpolarized average
        should differ modestly from the normal-incidence value.
      </p>

      <h3>Step 1 — Write the detector QE surface factor</h3>
      <div class="callout">
        <div class="label">Given detector model</div>
        <div class="eq mono" id="eqModel">η = (1 − R) · ζ · [1 − exp(−α d)]</div>
        <p style="margin:8px 0 0;color:var(--muted);font-size:13px">
          Here we only need the interface entry factor: <span class="mono">T = 1 − R</span>.
        </p>
      </div>

      <h3>Step 2 — Normal incidence reflectance</h3>
      <p>
        For a plane wave at normal incidence from medium 1 to 2 with real indices,
        the (power) reflectance is
      </p>
      <div class="eq mono" id="eqNormal">
R(θi=0) = ((n1 − n2)/(n1 + n2))^2
T(θi=0) = 1 − R
      </div>
      <p>
        We take <span class="mono">n1 = 1</span> (air). Now compute for each material:
      </p>

      <h3>Step 3 — Oblique incidence reflectance (Fresnel) for unpolarized light</h3>
      <p>
        For incidence angle <span class="mono">θi</span>, Snell’s law gives the transmitted angle <span class="mono">θt</span>:
      </p>
      <div class="eq mono" id="eqSnell">
n1 sin(θi) = n2 sin(θt)
θt = asin((n1/n2) sin(θi))
      </div>

      <p>Fresnel <i>field</i> reflection coefficients (real-index case) are:</p>
      <div class="eq mono" id="eqFresnel">
rs = (n1 cosθi − n2 cosθt) / (n1 cosθi + n2 cosθt)
rp = (n2 cosθi − n1 cosθt) / (n2 cosθi + n1 cosθt)

Rs = |rs|^2
Rp = |rp|^2

Unpolarized:  R = (Rs + Rp)/2
Requested factor: T = 1 − R
      </div>

      <div class="callout warn">
        <div class="label">Signpost: what we did and why</div>
        <div>
          We used Snell’s law to connect angles in the two media, then applied Fresnel formulas (from Maxwell boundary conditions)
          to compute the fraction of reflected power for s and p polarizations. Because the beam is unpolarized, we averaged them.
        </div>
      </div>

      <h3>Step 4 — Numerical evaluation (air → Si, GaAs, InSb)</h3>
      <p>
        Using the table values (near bandgap, 300 K): <span class="mono">n(Si)=3.5</span>, <span class="mono">n(GaAs)=3.6</span>, <span class="mono">n(InSb)=4.2</span>.
        The computed <span class="mono">R</span> and <span class="mono">T = 1 − R</span> are:
      </p>

      <table aria-label="Transmission factor results">
        <thead>
          <tr>
            <th>Material</th>
            <th>n2</th>
            <th>Angle θi</th>
            <th>Reflectance R</th>
            <th>Transmission factor T = 1 − R</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Si</td>
            <td class="mono">3.5</td>
            <td class="mono">0°</td>
            <td class="mono">0.3086419753</td>
            <td class="mono">0.6913580247</td>
          </tr>
          <tr>
            <td>Si</td>
            <td class="mono">3.5</td>
            <td class="mono">45°</td>
            <td class="mono">0.3101912842</td>
            <td class="mono">0.6898087158</td>
          </tr>
          <tr>
            <td>GaAs</td>
            <td class="mono">3.6</td>
            <td class="mono">0°</td>
            <td class="mono">0.3194706994</td>
            <td class="mono">0.6805293006</td>
          </tr>
          <tr>
            <td>GaAs</td>
            <td class="mono">3.6</td>
            <td class="mono">45°</td>
            <td class="mono">0.3204271502</td>
            <td class="mono">0.6795728498</td>
          </tr>
          <tr>
            <td>InSb</td>
            <td class="mono">4.2</td>
            <td class="mono">0°</td>
            <td class="mono">0.3786982249</td>
            <td class="mono">0.6213017751</td>
          </tr>
          <tr>
            <td>InSb</td>
            <td class="mono">4.2</td>
            <td class="mono">45°</td>
            <td class="mono">0.3766029613</td>
            <td class="mono">0.6233970387</td>
          </tr>
        </tbody>
      </table>

      <div class="callout good" id="finalBox">
        <div class="label">Final Answer (requested factor)</div>
        <div class="mono" id="finalText">T = 1 − R, with R from Fresnel reflection (unpolarized average).

Normal incidence (θi = 0°):
• Si (n=3.5):   R = 0.3086419753  →  T = 0.6913580247
• GaAs (n=3.6): R = 0.3194706994  →  T = 0.6805293006
• InSb (n=4.2): R = 0.3786982249  →  T = 0.6213017751

45° incidence (θi = 45°, unpolarized):
• Si (n=3.5):   R = 0.3101912842  →  T = 0.6898087158
• GaAs (n=3.6): R = 0.3204271502  →  T = 0.6795728498
• InSb (n=4.2): R = 0.3766029613  →  T = 0.6233970387</div>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><b>Bounds:</b> all <span class="mono">R</span> values lie between 0 and 1, so <span class="mono">T</span> also lies between 0 and 1.</li>
        <li><b>Limiting behavior:</b> InSb has the largest index → largest reflectance at normal incidence → smallest <span class="mono">T</span>, as expected.</li>
        <li><b>Angle effect:</b> Changes from 0° to 45° are modest here because the index contrast dominates; s increases more, p decreases more, averaging to a similar value.</li>
        <li><b>Physical interpretation:</b> Even before absorption, about 31–38% of incident optical power can be lost to surface reflection for these high-index semiconductors.</li>
      </ul>

      <div class="callout">
        <div class="label">Connection to diagram & plots</div>
        <div>
          The diagram shows the incident, reflected, and transmitted rays at the air–semiconductor interface, with angles
          <span class="mono">θi</span>, <span class="mono">θr</span>, and <span class="mono">θt</span>. The plots then quantify how
          <span class="mono">T(θi) = 1 − R(θi)</span> changes with incidence angle and polarization averaging.
        </div>
      </div>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the final formula</h3>
      <p>
        The detector QE model
        <span class="mono">η = (1 − R)·ζ·[1 − exp(−αd)]</span>
        separates the physics into:
      </p>
      <ul>
        <li><span class="mono">(1 − R)</span>: <b>surface entry</b> — controlled mainly by refractive-index mismatch and incidence angle.</li>
        <li><span class="mono">[1 − exp(−αd)]</span>: <b>absorption in the active region</b> — controlled by material absorption and thickness.</li>
        <li><span class="mono">ζ</span>: <b>carrier collection</b> — controlled by device design and recombination.</li>
      </ul>

      <h3>Parameter dependence (connect to plots)</h3>
      <ul>
        <li><b>Increasing semiconductor index <span class="mono">n2</span>:</b> increases reflection, decreases <span class="mono">T</span>. In the main plot, the InSb curve sits lowest.</li>
        <li><b>Changing angle <span class="mono">θi</span>:</b> changes s and p differently; the secondary plot shows <span class="mono">Rs</span> usually above <span class="mono">Rp</span> away from normal incidence.</li>
        <li><b>Unpolarized averaging:</b> smooths polarization extremes into one effective <span class="mono">R</span>, used directly in the QE factor.</li>
      </ul>

      <h3>An alternative derivation idea</h3>
      <p>
        Instead of quoting Fresnel formulas, you can derive them from Maxwell boundary conditions:
        enforce continuity of tangential <span class="mono">E</span> and <span class="mono">H</span> at the interface, write the plane-wave fields for incident,
        reflected, and transmitted waves, and solve the resulting linear system for <span class="mono">rs</span> and <span class="mono">rp</span>.
      </p>

      <h3>Concept checks (self-test)</h3>
      <ul>
        <li><b>Q:</b> Why is reflectance large for air → semiconductor? <b>A:</b> The index mismatch is large, which makes the wave impedance mismatch large, increasing reflection.</li>
        <li><b>Q:</b> At normal incidence, do s and p matter? <b>A:</b> No—polarization is irrelevant at <span class="mono">θi=0</span>, so <span class="mono">Rs=Rp</span>.</li>
        <li><b>Q:</b> Does <span class="mono">T = 1 − R</span> include absorption? <b>A:</b> No—this is only the interface entry factor; absorption is in <span class="mono">[1 − exp(−αd)]</span>.</li>
        <li><b>Q:</b> If we add an anti-reflection coating, what happens? <b>A:</b> Effective <span class="mono">R</span> decreases, increasing <span class="mono">T</span> and thus QE.</li>
      </ul>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="controls" role="group" aria-label="Interactive controls">
        <div>
          <label for="materialSel">Select material (for diagram & secondary plot)</label>
          <select id="materialSel">
            <option value="Si">Si (n = 3.5)</option>
            <option value="GaAs">GaAs (n = 3.6)</option>
            <option value="InSb">InSb (n = 4.2)</option>
          </select>
        </div>
        <div>
          <label for="angleSlider">Incidence angle θi (degrees)</label>
          <input id="angleSlider" type="range" min="0" max="80" step="1" value="45"/>
          <div class="readout" id="angleReadout">θi = 45°</div>
        </div>
      </div>

      <div class="kpi" aria-label="Live numeric readouts">
        <div class="pill">
          <div class="t">Unpolarized reflectance</div>
          <div class="v" id="kpiR">R = …</div>
        </div>
        <div class="pill">
          <div class="t">Transmission factor</div>
          <div class="v" id="kpiT">T = 1 − R = …</div>
        </div>
        <div class="pill">
          <div class="t">Transmitted angle</div>
          <div class="v" id="kpiThetaT">θt = …</div>
        </div>
      </div>

      <div class="grid2" style="margin-top:12px">
        <figure>
          <canvas id="diagCanvas" class="canvasTall" aria-label="Diagram canvas"></canvas>
          <div class="caption">
            <b>Diagram:</b> Incident, reflected, and transmitted rays at an air–semiconductor interface. The slider changes <span class="mono">θi</span>;
            the transmitted angle <span class="mono">θt</span> updates via Snell’s law.
          </div>
        </figure>

        <figure>
          <canvas id="plot2Canvas" class="canvasTall" aria-label="Secondary plot canvas"></canvas>
          <div class="caption">
            <b>Secondary plot:</b> <span class="mono">Rs(θ)</span>, <span class="mono">Rp(θ)</span>, and unpolarized <span class="mono">R(θ)</span> for the selected material.
            A marker shows the current slider angle.
          </div>
        </figure>
      </div>

      <figure style="margin-top:12px">
        <canvas id="plot1Canvas" aria-label="Main plot canvas"></canvas>
        <div class="caption">
          <b>Main plot:</b> Transmission factor <span class="mono">T(θ) = 1 − R(θ)</span> vs incidence angle for Si, GaAs, and InSb (unpolarized).
          A vertical cursor marks the current slider angle.
        </div>
      </figure>

      <div class="callout">
        <div class="label">What changes when you interact?</div>
        <ul>
          <li><b>Angle slider:</b> changes <span class="mono">θi</span> → updates the diagram geometry, the vertical cursor on the main plot, the marker on the secondary plot, and the numeric KPIs.</li>
          <li><b>Material selector:</b> changes <span class="mono">n2</span> for the diagram and secondary plot (and the KPIs), while the main plot always shows all three materials for comparison.</li>
        </ul>
      </div>
    </section>
  </article>
</main>

<footer>
  Computation uses Fresnel reflectance with real refractive indices (air → semiconductor) and unpolarized averaging.
  Indices used: Si 3.5, GaAs 3.6, InSb 4.2 (near bandgap, 300 K as in the provided table).
</footer>

<script>
/* =========================
   Copy buttons
========================= */
(function(){
  const status = document.getElementById('copyStatus');
  const eqText =
`Detector QE model:
η = (1 − R) · ζ · [1 − exp(−α d)]

Normal incidence:
R(0) = ((n1 − n2)/(n1 + n2))^2
T(0) = 1 − R(0)

Oblique incidence (Snell + Fresnel):
n1 sinθi = n2 sinθt
θt = asin((n1/n2) sinθi)

rs = (n1 cosθi − n2 cosθt) / (n1 cosθi + n2 cosθt)
rp = (n2 cosθi − n1 cosθt) / (n2 cosθi + n1 cosθt)

Rs = |rs|^2
Rp = |rp|^2
Unpolarized: R = (Rs + Rp)/2
T = 1 − R`;
  const finalText = document.getElementById('finalText').textContent;

  async function copyToClipboard(txt){
    try{
      await navigator.clipboard.writeText(txt);
      status.textContent = "Copied!";
      setTimeout(()=>status.textContent="", 1200);
    }catch(e){
      status.textContent = "Copy failed (clipboard blocked).";
      setTimeout(()=>status.textContent="", 1600);
    }
  }

  document.querySelectorAll('button.copyBtn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const kind = btn.getAttribute('data-copy');
      if(kind === "eqs") copyToClipboard(eqText);
      if(kind === "final") copyToClipboard(finalText);
    });
  });
})();

/* =========================
   Physics: Fresnel functions
========================= */
const materials = {
  "Si":   { n: 3.5 },
  "GaAs": { n: 3.6 },
  "InSb": { n: 4.2 }
};
const n1 = 1.0;

function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function deg2rad(d){ return d*Math.PI/180; }
function rad2deg(r){ return r*180/Math.PI; }

function fresnelUnpolarized(n2, thetaDeg){
  const th = deg2rad(thetaDeg);
  // Normal incidence shortcut (also avoids tiny numerical issues)
  if(thetaDeg === 0){
    const R = Math.pow((n1 - n2)/(n1 + n2), 2);
    return { Rs:R, Rp:R, R:R, T:1-R, thetaT:0 };
  }

  const sinT = (n1/n2) * Math.sin(th);
  // For air->high-n2, no total internal reflection; still clamp for safety.
  const thetaT = Math.asin(clamp(sinT, -1, 1));
  const ci = Math.cos(th);
  const ct = Math.cos(thetaT);

  const rs = (n1*ci - n2*ct) / (n1*ci + n2*ct);
  const rp = (n2*ci - n1*ct) / (n2*ci + n1*ct);

  const Rs = rs*rs;
  const Rp = rp*rp;
  const R  = 0.5*(Rs + Rp);
  return { Rs, Rp, R, T: 1 - R, thetaT: thetaT };
}

/* =========================
   Canvas helpers (HiDPI)
========================= */
function setupHiDPICanvas(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(240, rect.width);
  const h = Math.max(220, rect.height);
  canvas.width  = Math.round(w * dpr);
  canvas.height = Math.round(h * dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return { ctx, w, h, dpr };
}

function drawPanelTitle(ctx, x, y, title){
  ctx.save();
  ctx.font = "700 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillStyle = "rgba(234,240,255,.95)";
  ctx.fillText(title, x, y);
  ctx.restore();
}

function drawAxes(ctx, box, xLabel, yLabel, xMin, xMax, yMin, yMax){
  const {x,y,w,h} = box;
  // background grid
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 1;

  const nx = 6, ny = 5;
  for(let i=0;i<=nx;i++){
    const xx = x + (w*i/nx);
    ctx.beginPath(); ctx.moveTo(xx,y); ctx.lineTo(xx,y+h); ctx.stroke();
  }
  for(let j=0;j<=ny;j++){
    const yy = y + (h*j/ny);
    ctx.beginPath(); ctx.moveTo(x,yy); ctx.lineTo(x+w,yy); ctx.stroke();
  }

  // axes border
  ctx.strokeStyle = "rgba(255,255,255,.22)";
  ctx.strokeRect(x,y,w,h);

  // ticks + labels
  ctx.fillStyle = "rgba(184,195,230,.95)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";

  for(let i=0;i<=nx;i++){
    const v = xMin + (xMax-xMin)*i/nx;
    const xx = x + (w*i/nx);
    ctx.fillText(v.toFixed(0), xx-8, y+h+18);
  }
  for(let j=0;j<=ny;j++){
    const v = yMax - (yMax-yMin)*j/ny;
    const yy = y + (h*j/ny);
    ctx.fillText(v.toFixed(2), x-44, yy+4);
  }

  // axis labels
  ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillStyle = "rgba(234,240,255,.92)";
  ctx.fillText(xLabel, x+w-60, y+h+36);
  ctx.save();
  ctx.translate(x-56, y+18);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  ctx.restore();
}

function mapToBox(box, xVal, yVal, xMin, xMax, yMin, yMax){
  const {x,y,w,h} = box;
  const xx = x + (xVal - xMin) * (w/(xMax-xMin));
  const yy = y + (yMax - yVal) * (h/(yMax-yMin));
  return {xx, yy};
}

function drawLegend(ctx, items, x, y){
  ctx.save();
  ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  let yy = y;
  for(const it of items){
    ctx.strokeStyle = it.color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x, yy);
    ctx.lineTo(x+18, yy);
    ctx.stroke();
    ctx.fillStyle = "rgba(234,240,255,.92)";
    ctx.fillText(it.label, x+24, yy+4);
    yy += 16;
  }
  ctx.restore();
}

/* =========================
   Data generation
========================= */
function generateCurves(thetaMax=80, step=0.5){
  const thetas = [];
  for(let t=0;t<=thetaMax+1e-9;t+=step) thetas.push(+t.toFixed(3));
  const curves = {};
  for(const key of Object.keys(materials)){
    const n2 = materials[key].n;
    curves[key] = thetas.map(th => fresnelUnpolarized(n2, th));
  }
  return {thetas, curves, thetaMax, step};
}
const DATA = generateCurves(80, 0.5);

/* =========================
   Plot 1: T(theta) for all
========================= */
function drawPlot1(thetaCursor){
  const canvas = document.getElementById('plot1Canvas');
  const {ctx, w, h} = setupHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  drawPanelTitle(ctx, 14, 18, "Main plot: Transmission factor T(θ) = 1 − R(θ) (unpolarized), air → semiconductor");

  const padL=64, padR=18, padT=28, padB=56;
  const box = {x: padL, y: padT+14, w: w - padL - padR, h: h - padT - padB - 10};

  const xMin=0, xMax=DATA.thetaMax;
  // T stays around ~0.55..0.75 here; use full 0..1 for clarity.
  const yMin=0, yMax=1;

  drawAxes(ctx, box, "θi (deg)", "T (unitless)", xMin, xMax, yMin, yMax);

  const colors = {
    "Si":"rgba(122,167,255,.95)",
    "GaAs":"rgba(125,255,207,.90)",
    "InSb":"rgba(255,207,125,.92)"
  };

  // Plot curves
  for(const key of Object.keys(materials)){
    ctx.save();
    ctx.strokeStyle = colors[key];
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    DATA.thetas.forEach((th, i)=>{
      const T = DATA.curves[key][i].T;
      const p = mapToBox(box, th, T, xMin, xMax, yMin, yMax);
      if(i===0) ctx.moveTo(p.xx, p.yy);
      else ctx.lineTo(p.xx, p.yy);
    });
    ctx.stroke();
    ctx.restore();
  }

  // Cursor vertical line
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.45)";
  ctx.lineWidth = 1.5;
  const cx = mapToBox(box, thetaCursor, 0.5, xMin, xMax, yMin, yMax).xx;
  ctx.beginPath();
  ctx.moveTo(cx, box.y);
  ctx.lineTo(cx, box.y + box.h);
  ctx.stroke();
  ctx.restore();

  drawLegend(ctx, [
    {label:"Si (n=3.5)", color:colors["Si"]},
    {label:"GaAs (n=3.6)", color:colors["GaAs"]},
    {label:"InSb (n=4.2)", color:colors["InSb"]}
  ], padL+10, padT+38);
}

/* =========================
   Plot 2: Rs, Rp, R for selected
========================= */
function drawPlot2(materialKey, thetaCursor){
  const canvas = document.getElementById('plot2Canvas');
  const {ctx, w, h} = setupHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  const n2 = materials[materialKey].n;
  drawPanelTitle(ctx, 14, 18, `Secondary plot: Reflectance vs angle for ${materialKey} (n = ${n2})`);

  const padL=64, padR=18, padT=28, padB=56;
  const box = {x: padL, y: padT+14, w: w - padL - padR, h: h - padT - padB - 10};

  const xMin=0, xMax=DATA.thetaMax;
  const yMin=0, yMax=1;
  drawAxes(ctx, box, "θi (deg)", "R (unitless)", xMin, xMax, yMin, yMax);

  const colS = "rgba(122,167,255,.95)";
  const colP = "rgba(125,255,207,.90)";
  const colU = "rgba(255,207,125,.92)";

  const arr = DATA.curves[materialKey];

  function plotLine(getY, color){
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    DATA.thetas.forEach((th,i)=>{
      const yv = getY(arr[i]);
      const p = mapToBox(box, th, yv, xMin, xMax, yMin, yMax);
      if(i===0) ctx.moveTo(p.xx, p.yy);
      else ctx.lineTo(p.xx, p.yy);
    });
    ctx.stroke();
    ctx.restore();
  }

  plotLine(o=>o.Rs, colS);
  plotLine(o=>o.Rp, colP);
  plotLine(o=>o.R , colU);

  // Marker at cursor
  const cur = fresnelUnpolarized(n2, thetaCursor);
  const px = mapToBox(box, thetaCursor, cur.R, xMin, xMax, yMin, yMax).xx;
  const py = mapToBox(box, thetaCursor, cur.R, xMin, xMax, yMin, yMax).yy;

  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,.92)";
  ctx.beginPath();
  ctx.arc(px, py, 4.5, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  drawLegend(ctx, [
    {label:"Rs (s-pol)", color:colS},
    {label:"Rp (p-pol)", color:colP},
    {label:"R = (Rs+Rp)/2", color:colU}
  ], padL+10, padT+38);
}

/* =========================
   Diagram: interface + rays
========================= */
function drawDiagram(materialKey, thetaDeg){
  const canvas = document.getElementById('diagCanvas');
  const {ctx, w, h} = setupHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  const n2 = materials[materialKey].n;
  const phys = fresnelUnpolarized(n2, thetaDeg);
  const thetaT = phys.thetaT;

  drawPanelTitle(ctx, 14, 18, "Diagram: Air → Semiconductor refraction & reflection");

  // Layout
  const cx = w*0.52;
  const cy = h*0.50;
  const interfaceY = cy;
  const normalX = cx;

  // Background regions
  ctx.save();
  ctx.fillStyle = "rgba(122,167,255,.05)";
  ctx.fillRect(0, 0, w, interfaceY);
  ctx.fillStyle = "rgba(125,255,207,.05)";
  ctx.fillRect(0, interfaceY, w, h-interfaceY);
  ctx.restore();

  // Interface line
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.28)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, interfaceY);
  ctx.lineTo(w, interfaceY);
  ctx.stroke();
  ctx.restore();

  // Normal
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.22)";
  ctx.setLineDash([6,6]);
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(normalX, interfaceY-140);
  ctx.lineTo(normalX, interfaceY+140);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();

  // Ray geometry
  const th = deg2rad(thetaDeg);
  const L = Math.min(w,h)*0.36;

  // incident direction: coming from above-left toward interface point (normalX, interfaceY)
  const incDir = {x: -Math.sin(th), y: Math.cos(th)}; // direction in air (downwards)
  const incStart = {x: normalX - incDir.x*L, y: interfaceY - incDir.y*L};
  const P0 = {x: normalX, y: interfaceY};

  // reflected direction: symmetric about normal (upwards)
  const reflDir = {x: -Math.sin(th), y: -Math.cos(th)};
  const reflEnd = {x: P0.x + reflDir.x*L, y: P0.y + reflDir.y*L};

  // transmitted direction: in medium 2, downward bending toward normal
  const trDir = {x: -Math.sin(thetaT), y: Math.cos(thetaT)};
  const trEnd = {x: P0.x + trDir.x*L, y: P0.y + trDir.y*L};

  function drawArrow(from, to, color){
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.stroke();

    // arrow head
    const ang = Math.atan2(to.y-from.y, to.x-from.x);
    const ah = 10;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(to.x, to.y);
    ctx.lineTo(to.x - ah*Math.cos(ang - Math.PI/7), to.y - ah*Math.sin(ang - Math.PI/7));
    ctx.lineTo(to.x - ah*Math.cos(ang + Math.PI/7), to.y - ah*Math.sin(ang + Math.PI/7));
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  drawArrow(incStart, P0, "rgba(122,167,255,.95)");
  drawArrow(P0, reflEnd, "rgba(255,207,125,.92)");
  drawArrow(P0, trEnd, "rgba(125,255,207,.90)");

  // Angle arcs
  function drawAngleArc(center, radius, start, end, color, label, labelPos){
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(center.x, center.y, radius, start, end, false);
    ctx.stroke();
    ctx.fillStyle = "rgba(234,240,255,.92)";
    ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(label, labelPos.x, labelPos.y);
    ctx.restore();
  }

  // Angles measured from normal: normal points upward is negative y direction above interface for θi
  // For drawing, use local coordinate with center at P0 and positive x right, positive y down.
  // Incident ray above interface points toward P0: its direction is (sinθ, -cosθ) from P0 backward.
  // But arc: from normal-up direction (-π/2) to incident-ray direction angle.
  const normalUpAng = -Math.PI/2;
  const incRayAng = Math.atan2(incStart.y - P0.y, incStart.x - P0.x); // from P0 to incStart (up-left)
  // ensure arc small: go from normalUpAng to incRayAng
  drawAngleArc(P0, 36, normalUpAng, incRayAng, "rgba(122,167,255,.75)", `θi=${thetaDeg}°`, {x:P0.x-90, y:P0.y-50});

  const trRayAng = Math.atan2(trEnd.y - P0.y, trEnd.x - P0.x); // down-left
  // normal-down is +π/2
  const normalDownAng = Math.PI/2;
  drawAngleArc(P0, 34, normalDownAng, trRayAng, "rgba(125,255,207,.70)", `θt=${rad2deg(thetaT).toFixed(2)}°`, {x:P0.x-88, y:P0.y+70});

  // Labels
  ctx.save();
  ctx.fillStyle = "rgba(184,195,230,.95)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
  ctx.fillText(`Air: n1 = 1.0`, 14, interfaceY - 12);
  ctx.fillText(`${materialKey}: n2 = ${n2}`, 14, interfaceY + 20);
  ctx.fillStyle = "rgba(234,240,255,.92)";
  ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("incident", incStart.x+6, incStart.y+14);
  ctx.fillText("reflected", reflEnd.x+6, reflEnd.y-6);
  ctx.fillText("transmitted", trEnd.x+6, trEnd.y+14);
  ctx.restore();
}

/* =========================
   UI wiring
========================= */
const materialSel = document.getElementById('materialSel');
const angleSlider = document.getElementById('angleSlider');
const angleReadout = document.getElementById('angleReadout');

const kpiR = document.getElementById('kpiR');
const kpiT = document.getElementById('kpiT');
const kpiThetaT = document.getElementById('kpiThetaT');

function updateAll(){
  const mat = materialSel.value;
  const th = parseFloat(angleSlider.value);
  angleReadout.textContent = `θi = ${th.toFixed(0)}°`;

  // Update KPIs for selected material
  const n2 = materials[mat].n;
  const out = fresnelUnpolarized(n2, th);
  kpiR.textContent = `R = ${(out.R).toFixed(6)}  (Rs=${out.Rs.toFixed(6)}, Rp=${out.Rp.toFixed(6)})`;
  kpiT.textContent = `T = ${(out.T).toFixed(6)}`;
  kpiThetaT.textContent = `θt = ${rad2deg(out.thetaT).toFixed(3)}°`;

  // Redraw
  drawDiagram(mat, th);
  drawPlot2(mat, th);
  drawPlot1(th);
}

materialSel.addEventListener('change', updateAll);
angleSlider.addEventListener('input', updateAll);
window.addEventListener('resize', updateAll);

// Initial render
updateAll();
</script>
</body>
</html>
