<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bandwidth of an RC Circuit (Equivalent Noise Bandwidth) + Thermal Noise Current</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f1620;
      --card:#111c28;
      --ink:#eaf2ff;
      --muted:#b6c2d6;
      --faint:#7f90aa;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --ok:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --radius2:22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html{ scroll-behavior:smooth; }
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 700px at 20% -10%, rgba(125,211,252,.18), transparent 60%),
        radial-gradient(1000px 650px at 90% 10%, rgba(167,139,250,.16), transparent 60%),
        radial-gradient(900px 600px at 50% 110%, rgba(52,211,153,.10), transparent 60%),
        var(--bg);
      color:var(--ink);
      line-height:1.55;
    }

    header{
      padding:28px 18px 12px;
      max-width:1200px;
      margin:0 auto;
    }

    .titlebar{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:16px;
      align-items:end;
    }
    h1{
      font-size: clamp(1.6rem, 2.2vw, 2.4rem);
      margin:0;
      letter-spacing:.2px;
    }
    .subtitle{
      margin:8px 0 0;
      color:var(--muted);
      max-width:70ch;
    }
    .meta{
      justify-self:end;
      text-align:right;
      color:var(--faint);
      font-size:.95rem;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding: 10px 18px 60px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }

    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding:14px 14px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    nav.toc .toc-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-weight:700;
      letter-spacing:.3px;
      margin-bottom:10px;
    }
    .pill{
      font-family:var(--mono);
      font-size:.78rem;
      color: rgba(255,255,255,.85);
      border:1px solid var(--line);
      padding:3px 8px;
      border-radius:999px;
      background: rgba(0,0,0,.25);
    }
    nav.toc a{
      display:block;
      padding:7px 8px;
      border-radius:12px;
      text-decoration:none;
      color: var(--muted);
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:.98rem;
    }
    nav.toc a:hover{
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.20);
      color: var(--ink);
      transform: translateX(2px);
    }

    .content{
      display:flex;
      flex-direction:column;
      gap:16px;
      min-width:0;
    }

    section{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--radius2);
      padding: 16px 16px 14px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    section h2{
      margin:0 0 8px;
      font-size: clamp(1.15rem, 1.5vw, 1.35rem);
      letter-spacing:.2px;
    }
    section h3{
      margin:14px 0 8px;
      font-size: 1.06rem;
      color: rgba(234,242,255,.95);
    }
    p{ margin: 8px 0; color: rgba(234,242,255,.92); }
    ul{ margin: 8px 0 8px 18px; color: rgba(234,242,255,.90); }
    li{ margin: 6px 0; }
    .muted{ color: var(--muted); }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
      align-items:stretch;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1.05fr 1fr 1fr;
      gap:14px;
      align-items:stretch;
    }

    .card{
      background: rgba(0,0,0,.20);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 12px 12px 10px;
      overflow:hidden;
    }
    .card h4{
      margin:0 0 6px;
      font-size: .98rem;
      color: rgba(234,242,255,.92);
      letter-spacing:.2px;
    }

    .callout{
      border-left: 4px solid rgba(125,211,252,.75);
      background: rgba(125,211,252,.08);
      padding: 10px 12px;
      border-radius: 14px;
      margin: 10px 0;
    }
    .callout.warn{ border-left-color: rgba(251,191,36,.85); background: rgba(251,191,36,.10); }
    .callout.ok{ border-left-color: rgba(52,211,153,.85); background: rgba(52,211,153,.10); }
    .callout.bad{ border-left-color: rgba(251,113,133,.85); background: rgba(251,113,133,.10); }

    .eq{
      display:block;
      font-family: var(--mono);
      background: rgba(0,0,0,.28);
      border: 1px solid var(--line);
      padding: 10px 10px;
      border-radius: 14px;
      overflow-x:auto;
      margin: 10px 0 8px;
      position: relative;
    }

    .copyRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-top:6px;
    }
    button.copy{
      appearance:none;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.25);
      color: var(--ink);
      padding: 7px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-family: var(--mono);
      font-size: .85rem;
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
    }
    button.copy:hover{
      transform: translateY(-1px);
      border-color: rgba(125,211,252,.30);
      background: rgba(125,211,252,.10);
    }
    .copyNote{
      color: var(--faint);
      font-size:.9rem;
    }

    figure{
      margin: 10px 0 6px;
      border: 1px solid var(--line);
      border-radius: var(--radius);
      overflow:hidden;
      background: rgba(0,0,0,.22);
    }
    figcaption{
      padding: 10px 12px;
      color: var(--muted);
      border-top: 1px solid var(--line);
      font-size: .95rem;
    }
    canvas{
      width:100%;
      height: 300px;
      display:block;
    }

    .controls{
      display:grid;
      grid-template-columns: 1.2fr 1fr 1fr;
      gap:12px;
      align-items:end;
    }
    .control{
      background: rgba(0,0,0,.20);
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding: 10px 10px 8px;
    }
    .control label{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      color: rgba(234,242,255,.92);
      font-weight:650;
      font-size:.95rem;
      margin-bottom:6px;
    }
    .control .val{
      font-family: var(--mono);
      font-weight:650;
      color: rgba(125,211,252,.95);
    }
    input[type="range"]{
      width:100%;
    }
    select{
      width:100%;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(0,0,0,.30);
      border: 1px solid var(--line);
      color: var(--ink);
      font-family: var(--sans);
    }

    .results{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    .resultBox{
      background: rgba(0,0,0,.20);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 10px 10px 8px;
    }
    .resultBox .k{
      color: var(--muted);
      font-size:.92rem;
      margin-bottom:4px;
    }
    .resultBox .v{
      font-family: var(--mono);
      font-size: 1.05rem;
      color: rgba(234,242,255,.96);
      line-height:1.25;
      word-break: break-word;
    }

    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 18px 18px 40px;
      color: var(--faint);
      font-size:.95rem;
    }

    /* Responsive */
    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
      nav.toc{ position: relative; top:auto; }
      .titlebar{ grid-template-columns:1fr; }
      .meta{ justify-self:start; text-align:left; }
      .grid2{ grid-template-columns:1fr; }
      .grid3{ grid-template-columns:1fr; }
      .controls{ grid-template-columns:1fr; }
      .results{ grid-template-columns:1fr; }
      canvas{ height: 320px; }
    }

    /* Print-friendly */
    @media print{
      body{ background:#fff; color:#000; }
      nav.toc{ display:none; }
      section, .card, figure{ box-shadow:none; background:#fff; border-color:#ddd; }
      .eq{ background:#f6f6f6; border-color:#ddd; }
      button.copy{ display:none; }
    }

    /* Subtle motion */
    @keyframes fadeUp{
      from{ opacity:0; transform: translateY(8px); }
      to{ opacity:1; transform: translateY(0); }
    }
    section{ animation: fadeUp .35s ease both; }
  </style>
</head>

<body>
<header>
  <div class="titlebar">
    <div>
      <h1>Bandwidth of an RC Circuit (Equivalent Noise Bandwidth) & Thermal Noise Current</h1>
      <p class="subtitle">
        We use the <em>equivalent noise bandwidth</em> definition to prove <span style="font-family:var(--mono)">B = 1/(4&tau;)</span>
        for an exponential impulse response, then apply it to an RC network (<span style="font-family:var(--mono)">&tau; = RC</span>)
        to compute the resistor’s thermal noise current.
      </p>
    </div>
    <div class="meta">
      <div class="pill">Vanilla HTML/CSS/JS • Canvas plots</div>
      <div style="margin-top:8px">Symbols consistent across text & plots</div>
    </div>
  </div>
</header>

<main>
  <nav class="toc" aria-label="Table of contents">
    <div class="toc-title">
      <span>Table of Contents</span>
      <span class="pill">sticky</span>
    </div>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
  </nav>

  <div class="content">

    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><strong>What this is:</strong> Find the <em>equivalent noise bandwidth</em> <span style="font-family:var(--mono)">B</span> for a first-order exponential impulse response and apply it to an RC circuit.</li>
        <li><strong>Key physics idea:</strong> White thermal noise passed through a linear filter produces output noise power proportional to the <em>area</em> under <span style="font-family:var(--mono)">|H(f)|²</span> (or equivalently a time-domain ratio of integrals of <span style="font-family:var(--mono)">h(t)</span>).</li>
        <li><strong>Governing definition:</strong> <span style="font-family:var(--mono)">B = ( ∫₀^∞ h²(t) dt ) / ( 2 [∫₀^∞ h(t) dt]² )</span>.</li>
        <li><strong>Impulse response:</strong> <span style="font-family:var(--mono)">h(t) = (e/&tau;) exp(-t/&tau;)</span> (for <span style="font-family:var(--mono)">t ≥ 0</span>).</li>
        <li><strong>Prove:</strong> <span style="font-family:var(--mono)">B = 1/(4&tau;)</span> (scaling like the prefactor <span style="font-family:var(--mono)">e</span> cancels).</li>
        <li><strong>RC bandwidth:</strong> with <span style="font-family:var(--mono)">&tau; = RC</span>, <span style="font-family:var(--mono)">B_RC = 1/(4RC)</span>.</li>
        <li><strong>Thermal noise current (rms):</strong> model resistor as a current noise source with one-sided density <span style="font-family:var(--mono)">S_i = 4kT/R</span>, so <span style="font-family:var(--mono)">i_rms = √(4kTB/R)</span>.</li>
        <li><strong>Numeric result (R=1 kΩ, C=5 pF, T=300 K):</strong> <span style="font-family:var(--mono)">B ≈ 50 MHz</span>, <span style="font-family:var(--mono)">i_rms ≈ 2.88×10⁻⁸ A = 28.8 nA</span>.</li>
      </ul>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="grid2">
        <div class="card">
          <h4>Core definitions (symbols & units)</h4>
          <ul>
            <li><span style="font-family:var(--mono)">h(t)</span>: impulse response of an LTI circuit (units depend on input/output variables).</li>
            <li><span style="font-family:var(--mono)">H(f)</span>: frequency response, Fourier transform of <span style="font-family:var(--mono)">h(t)</span> (dimensionless if input/output same type).</li>
            <li><span style="font-family:var(--mono)">B</span>: <em>equivalent noise bandwidth</em> (ENBW), measured in Hz.</li>
            <li><span style="font-family:var(--mono)">&tau;</span>: time constant (seconds). For an RC circuit, <span style="font-family:var(--mono)">&tau; = RC</span>.</li>
            <li><span style="font-family:var(--mono)">k</span>: Boltzmann constant (<span style="font-family:var(--mono)">1.380649×10⁻²³ J/K</span>).</li>
            <li><span style="font-family:var(--mono)">T</span>: absolute temperature (K).</li>
          </ul>
        </div>

        <div class="card">
          <h4>Physical meaning</h4>
          <p>
            ENBW answers: <em>“A real filter passes noise over a range of frequencies. What width of an ideal
            rectangular (brick-wall) filter at unity gain would pass the same total noise power?”</em>
          </p>
          <p class="muted">
            In other words, ENBW is an <strong>area-equivalence</strong> concept: it turns the curved <span style="font-family:var(--mono)">|H(f)|²</span>
            into an equal-area rectangle.
          </p>
        </div>
      </div>

      <h3>Key principles (and validity conditions)</h3>
      <ul>
        <li><strong>Linear time-invariant (LTI) filtering:</strong> output is convolution <span style="font-family:var(--mono)">y(t)=x(t)*h(t)</span>. ENBW concepts rely on LTI behavior.</li>
        <li><strong>Thermal (Johnson–Nyquist) noise:</strong> a resistor at temperature <span style="font-family:var(--mono)">T</span> generates approximately white noise over frequencies where <span style="font-family:var(--mono)">hf ≪ kT</span>.</li>
        <li><strong>White-noise through filter:</strong> if the input noise spectral density is flat, the output noise is proportional to the area under <span style="font-family:var(--mono)">|H(f)|²</span>.</li>
      </ul>

      <div class="callout">
        <strong>Common model used here:</strong>
        A resistor can be represented either by a series voltage noise source (<span style="font-family:var(--mono)">S_v = 4kTR</span>) or
        an equivalent parallel current noise source (<span style="font-family:var(--mono)">S_i = 4kT/R</span>), for a one-sided spectral density (Hz from 0 to ∞).
      </div>

      <h3>Mini intuition examples</h3>
      <ul>
        <li><strong>Fast RC (small &tau;):</strong> the circuit responds quickly, so it passes higher-frequency content → <span style="font-family:var(--mono)">B</span> increases (since <span style="font-family:var(--mono)">B ∝ 1/&tau;</span>).</li>
        <li><strong>Slow RC (large &tau;):</strong> strong smoothing; high-frequency noise is attenuated → <span style="font-family:var(--mono)">B</span> decreases.</li>
      </ul>

      <div class="callout warn">
        <strong>What to watch for (pitfalls)</strong>
        <ul>
          <li><strong>ENBW is not the same</strong> as the -3 dB bandwidth (<span style="font-family:var(--mono)">f_c</span>). For a first-order RC, ENBW is larger than <span style="font-family:var(--mono)">f_c</span>.</li>
          <li>Be consistent about <strong>one-sided vs two-sided</strong> noise spectral densities (factors of 2 matter).</li>
          <li>Scaling <span style="font-family:var(--mono)">h(t)</span> by a constant does <em>not</em> change ENBW under the given definition (the scale cancels).</li>
        </ul>
      </div>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Problem restatement</h3>
      <p>
        Using the bandwidth definition
        <span style="font-family:var(--mono)">B = ( ∫₀^∞ h²(t) dt ) / ( 2 [∫₀^∞ h(t) dt]² )</span>,
        show that if <span style="font-family:var(--mono)">h(t) = (e/&tau;) exp(-t/&tau;)</span> (for <span style="font-family:var(--mono)">t ≥ 0</span>),
        then <span style="font-family:var(--mono)">B = 1/(4&tau;)</span>. Then identify the bandwidth of an RC circuit and compute the thermal noise current
        for <span style="font-family:var(--mono)">R = 1 kΩ</span>, <span style="font-family:var(--mono)">C = 5 pF</span>, <span style="font-family:var(--mono)">T = 300 K</span>.
      </p>

      <div class="grid3">
        <div class="card">
          <h4>Given</h4>
          <ul>
            <li><span style="font-family:var(--mono)">h(t) = (e/&tau;) e^{-t/&tau;}</span>, <span style="font-family:var(--mono)">t ≥ 0</span></li>
            <li>Definition: <span style="font-family:var(--mono)">B = ∫h² dt / (2 (∫h dt)²)</span></li>
            <li>RC values: <span style="font-family:var(--mono)">R=1 kΩ</span>, <span style="font-family:var(--mono)">C=5 pF</span>, <span style="font-family:var(--mono)">T=300 K</span></li>
          </ul>
        </div>
        <div class="card">
          <h4>Unknowns</h4>
          <ul>
            <li>Show: <span style="font-family:var(--mono)">B = 1/(4&tau;)</span></li>
            <li>For RC: <span style="font-family:var(--mono)">B_RC</span> in terms of <span style="font-family:var(--mono)">R, C</span></li>
            <li>Thermal noise current (rms): <span style="font-family:var(--mono)">i_rms</span></li>
          </ul>
        </div>
        <div class="card">
          <h4>What must be found / proved</h4>
          <ul>
            <li>Compute two integrals: <span style="font-family:var(--mono)">∫h dt</span> and <span style="font-family:var(--mono)">∫h² dt</span></li>
            <li>Substitute into the ENBW definition</li>
            <li>Map <span style="font-family:var(--mono)">&tau;</span> to RC and compute numerically</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li>The ENBW definition provided is explicitly <strong>time-domain</strong>, so we can compute it directly from integrals of <span style="font-family:var(--mono)">h(t)</span>.</li>
        <li>The circuit is modeled as <strong>first-order LTI</strong> with exponential impulse response, so integrals converge and ENBW is well-defined.</li>
        <li>Thermal noise of a resistor is treated as white over the RC bandwidth region at room temperature, enabling <span style="font-family:var(--mono)">i_rms = √(S_i B)</span>.</li>
      </ul>

      <div class="callout ok">
        <strong>Assumptions (explicit)</strong>
        <ul>
          <li>LTI, stable system; <span style="font-family:var(--mono)">h(t)=0</span> for <span style="font-family:var(--mono)">t&lt;0</span> and decays exponentially.</li>
          <li>Noise is approximately white across the effective bandwidth (valid for typical MHz–GHz at 300 K for classical Johnson noise in circuits).</li>
          <li>One-sided noise spectral density convention: integrate over <span style="font-family:var(--mono)">f ∈ [0,∞)</span>.</li>
        </ul>
      </div>

      <h3>Possible approaches</h3>
      <ul>
        <li><strong>Approach A (best here):</strong> Use the provided time-domain ENBW formula. <em>Pros:</em> short, direct, no Fourier transforms. <em>Cons:</em> must be careful with integrals and normalization.</li>
        <li><strong>Approach B:</strong> Compute <span style="font-family:var(--mono)">H(f)</span> and evaluate <span style="font-family:var(--mono)">B = ∫|H(f)|² df</span> (area method). <em>Pros:</em> connects directly to frequency plots. <em>Cons:</em> more algebra, potential factor-of-2 pitfalls.</li>
        <li><strong>Approach C:</strong> Use known ENBW of a 1-pole low-pass and map to RC. <em>Pros:</em> fastest. <em>Cons:</em> doesn’t demonstrate the definition as requested.</li>
      </ul>
      <p><strong>Chosen:</strong> Approach A, because the problem explicitly asks to use the definition and show the result.</p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>
      <ol>
        <li><strong>Goal:</strong> set up ENBW definition.<br>
          <span class="muted">Tool:</span> <span style="font-family:var(--mono)">B = ∫h² dt / (2(∫h dt)²)</span>.<br>
          <span class="muted">Meaning:</span> area-equivalent bandwidth for white noise.</li>
        <li><strong>Goal:</strong> compute <span style="font-family:var(--mono)">A = ∫₀^∞ h(t) dt</span>.<br>
          <span class="muted">Tool:</span> exponential integral <span style="font-family:var(--mono)">∫₀^∞ e^{-t/&tau;} dt = &tau;</span>.<br>
          <span class="muted">Meaning:</span> total impulse-response “area” (DC gain in many contexts).</li>
        <li><strong>Goal:</strong> compute <span style="font-family:var(--mono)">E = ∫₀^∞ h²(t) dt</span>.<br>
          <span class="muted">Tool:</span> same integral with decay rate doubled.<br>
          <span class="muted">Meaning:</span> “energy-like” measure controlling noise power throughput.</li>
        <li><strong>Goal:</strong> substitute into <span style="font-family:var(--mono)">B = E/(2A²)</span> and simplify to <span style="font-family:var(--mono)">1/(4&tau;)</span>.<br>
          <span class="muted">Tip:</span> notice any constant prefactor in <span style="font-family:var(--mono)">h</span> cancels.</li>
        <li><strong>Goal:</strong> identify RC time constant <span style="font-family:var(--mono)">&tau; = RC</span> → <span style="font-family:var(--mono)">B_RC = 1/(4RC)</span>.</li>
        <li><strong>Goal:</strong> compute thermal noise current (rms).<br>
          <span class="muted">Tool:</span> one-sided Norton current noise density <span style="font-family:var(--mono)">S_i = 4kT/R</span> and <span style="font-family:var(--mono)">i_rms = √(S_i B)</span>.</li>
        <li><strong>Goal:</strong> sanity checks (units, limiting behavior).<br>
          <span class="muted">Tip:</span> <span style="font-family:var(--mono)">B</span> must have units of Hz; increasing C should reduce bandwidth and noise.</li>
      </ol>

      <div class="callout warn">
        <strong>Common mistakes</strong>
        <ul>
          <li>Using <span style="font-family:var(--mono)">f_c = 1/(2πRC)</span> as ENBW. ENBW for a 1-pole low-pass is <span style="font-family:var(--mono)">1/(4RC)</span>, which is <em>larger</em> than <span style="font-family:var(--mono)">f_c</span> by a factor <span style="font-family:var(--mono)">π/2</span>.</li>
          <li>Mixing one-sided and two-sided noise spectra without adjusting factors of 2.</li>
          <li>Forgetting that <span style="font-family:var(--mono)">h(t)</span> is defined only for <span style="font-family:var(--mono)">t ≥ 0</span> in causal circuits.</li>
        </ul>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Physical intuition first</h3>
      <p>
        A first-order RC-like response “remembers” its input for a time on the order of <span style="font-family:var(--mono)">&tau;</span>.
        If <span style="font-family:var(--mono)">&tau;</span> is large, the circuit averages over a long time and rejects fast fluctuations (high-frequency noise),
        so the effective bandwidth should shrink. Dimensional reasoning suggests <span style="font-family:var(--mono)">B ∝ 1/&tau;</span>.
        The calculation will pin down the exact factor, <span style="font-family:var(--mono)">1/4</span>.
      </p>

      <div class="callout">
        <strong>Bandwidth definition used (given):</strong>
        <div class="eq" id="eqBdef">
B = ( ∫₀^∞ h²(t) dt ) / ( 2 [ ∫₀^∞ h(t) dt ]² )
        </div>
        <div class="copyRow">
          <button class="copy" data-copy="B = ( ∫_0^∞ h(t)^2 dt ) / ( 2 [ ∫_0^∞ h(t) dt ]^2 )">Copy equation</button>
          <span class="copyNote">Copies plain text</span>
        </div>
      </div>

      <h3>Step 1 — Write down the impulse response and define symbols</h3>
      <p>
        The impulse response is
        <span style="font-family:var(--mono)">h(t) = (e/&tau;) exp(-t/&tau;)</span> for <span style="font-family:var(--mono)">t ≥ 0</span>.
        Here:
      </p>
      <ul>
        <li><span style="font-family:var(--mono)">t</span> is time (s).</li>
        <li><span style="font-family:var(--mono)">&tau;</span> is a positive time constant (s).</li>
        <li><span style="font-family:var(--mono)">e</span> is Euler’s number (≈ 2.71828), a dimensionless constant.</li>
      </ul>

      <h3>Step 2 — Compute A = ∫₀^∞ h(t) dt</h3>
      <div class="eq" id="eqA">
A = ∫₀^∞ h(t) dt
  = ∫₀^∞ (e/&tau;) exp(-t/&tau;) dt
  = (e/&tau;) [ ∫₀^∞ exp(-t/&tau;) dt ].
      </div>
      <p>
        Use the standard integral: for <span style="font-family:var(--mono)">&tau; &gt; 0</span>,
        <span style="font-family:var(--mono)">∫₀^∞ exp(-t/&tau;) dt = &tau;</span>.
        Therefore,
      </p>
      <div class="eq" id="eqA2">
A = (e/&tau;) · &tau; = e.
      </div>
      <p class="muted">
        What we did: we computed the total “area” under the impulse response. For many systems this equals the DC gain.
        Here it is simply <span style="font-family:var(--mono)">e</span> because of the chosen prefactor.
      </p>
      <div class="copyRow">
        <button class="copy" data-copy="A = ∫_0^∞ h(t) dt = e">Copy result</button>
      </div>

      <h3>Step 3 — Compute E = ∫₀^∞ h²(t) dt</h3>
      <p>
        Square the impulse response:
        <span style="font-family:var(--mono)">h²(t) = (e²/&tau;²) exp(-2t/&tau;)</span>.
      </p>
      <div class="eq" id="eqE">
E = ∫₀^∞ h²(t) dt
  = ∫₀^∞ (e²/&tau;²) exp(-2t/&tau;) dt
  = (e²/&tau;²) [ ∫₀^∞ exp(-2t/&tau;) dt ].
      </div>
      <p>
        Use <span style="font-family:var(--mono)">∫₀^∞ exp(-α t) dt = 1/α</span> for <span style="font-family:var(--mono)">α &gt; 0</span>.
        Here <span style="font-family:var(--mono)">α = 2/&tau;</span>, so
        <span style="font-family:var(--mono)">∫₀^∞ exp(-2t/&tau;) dt = &tau;/2</span>.
      </p>
      <div class="eq" id="eqE2">
E = (e²/&tau;²) · (&tau;/2) = e²/(2&tau;).
      </div>
      <p class="muted">
        What we did: we computed an “energy-like” integral. This controls how strongly white noise is transmitted through the filter.
      </p>
      <div class="copyRow">
        <button class="copy" data-copy="E = ∫_0^∞ h(t)^2 dt = e^2/(2 τ)">Copy result</button>
      </div>

      <h3>Step 4 — Substitute into the ENBW definition</h3>
      <p>
        Insert <span style="font-family:var(--mono)">A = e</span> and <span style="font-family:var(--mono)">E = e²/(2&tau;)</span> into
        <span style="font-family:var(--mono)">B = E/(2A²)</span>:
      </p>
      <div class="eq" id="eqB">
B = E / (2A²)
  = [ e²/(2&tau;) ] / [ 2 (e²) ]
  = 1/(4&tau;).
      </div>

      <div class="callout ok">
        <strong>Key result (proved):</strong>
        <div class="eq" id="eqBboxed">B = 1/(4&tau;)</div>
        <div class="copyRow">
          <button class="copy" data-copy="B = 1/(4 τ)">Copy final symbolic result</button>
        </div>
        <p class="muted">
          Notice how the prefactor <span style="font-family:var(--mono)">e</span> cancels. ENBW depends on the <em>shape/time scale</em> of the response, not its overall scaling.
        </p>
      </div>

      <h3>Step 5 — Bandwidth of an RC circuit</h3>
      <p>
        A first-order RC network has time constant <span style="font-family:var(--mono)">&tau; = RC</span>. Therefore:
      </p>
      <div class="eq" id="eqBRC">
B_RC = 1/(4RC).
      </div>
      <div class="copyRow">
        <button class="copy" data-copy="B_RC = 1/(4 R C)">Copy</button>
      </div>

      <h3>Step 6 — Thermal noise current for R in parallel with C</h3>
      <p>
        Model the resistor as a Norton current noise source (one-sided) with spectral density:
      </p>
      <div class="eq" id="eqSi">
S_i = 4kT/R   (A²/Hz).
      </div>
      <p>
        Passing white current noise through the RC impedance produces a filtered current contribution; using ENBW, the rms noise current associated with bandwidth <span style="font-family:var(--mono)">B</span> is:
      </p>
      <div class="eq" id="eqirms">
i_rms = √( S_i · B ) = √( (4kT/R) · B ).
      </div>

      <p>
        With <span style="font-family:var(--mono)">B = 1/(4RC)</span>,
      </p>
      <div class="eq" id="eqirms2">
i_rms = √( (4kT/R) · (1/(4RC)) )
      = √( kT / (R² C) ).
      </div>

      <div class="callout ok">
        <strong>Numeric evaluation (R = 1 kΩ, C = 5 pF, T = 300 K)</strong>
        <ul>
          <li><span style="font-family:var(--mono)">&tau; = RC = (1000)(5×10⁻¹²) = 5×10⁻⁹ s</span></li>
          <li><span style="font-family:var(--mono)">B = 1/(4&tau;) = 1/(4·5×10⁻⁹) = 5.0×10⁷ Hz = 50 MHz</span></li>
          <li><span style="font-family:var(--mono)">i_rms = √(kT/(R²C)) ≈ 2.88×10⁻⁸ A = 28.8 nA</span></li>
        </ul>
        <div class="copyRow">
          <button class="copy" data-copy="For R=1 kΩ, C=5 pF, T=300 K: τ=5e-9 s, B=5.0e7 Hz (50 MHz), i_rms≈2.88e-8 A (28.8 nA).">Copy final numeric answer</button>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><strong>Units:</strong> <span style="font-family:var(--mono)">B = 1/(4&tau;)</span> has units 1/s = Hz. Good. And <span style="font-family:var(--mono)">i_rms</span> comes out in amperes.</li>
        <li><strong>Limiting behavior:</strong> increasing <span style="font-family:var(--mono)">C</span> or <span style="font-family:var(--mono)">R</span> increases <span style="font-family:var(--mono)">&tau;</span> → decreases <span style="font-family:var(--mono)">B</span> → decreases noise. Matches intuition.</li>
        <li><strong>Scaling of h(t):</strong> multiplying <span style="font-family:var(--mono)">h</span> by a constant multiplies numerator and denominator by the same factor squared → <span style="font-family:var(--mono)">B</span> unchanged. Good.</li>
      </ul>

      <p class="muted">
        Connection to the plots below: the main plot shows how a 1-pole filter’s <span style="font-family:var(--mono)">|H(f)|²</span> decays with frequency and how the ENBW rectangle
        of width <span style="font-family:var(--mono)">B = 1/(4RC)</span> matches the total noise-power area.
      </p>
    </section>

    <section id="viz">
      <h2>Interactive Visualizations</h2>

      <div class="controls" role="group" aria-label="Interactive controls">
        <div class="control">
          <label for="rSlider">Resistance R <span class="val" id="rVal"></span></label>
          <input id="rSlider" type="range" min="2" max="6" value="3" step="0.001" />
          <div class="muted" style="font-size:.9rem;margin-top:6px">
            Log scale: <span style="font-family:var(--mono)">R = 10^x Ω</span>
          </div>
        </div>
        <div class="control">
          <label for="cSlider">Capacitance C <span class="val" id="cVal"></span></label>
          <input id="cSlider" type="range" min="-13" max="-9" value="-11.30103" step="0.001" />
          <div class="muted" style="font-size:.9rem;margin-top:6px">
            Log scale: <span style="font-family:var(--mono)">C = 10^x F</span>
          </div>
        </div>
        <div class="control">
          <label for="tSlider">Temperature T <span class="val" id="tVal"></span></label>
          <input id="tSlider" type="range" min="200" max="500" value="300" step="1" />
          <div style="margin-top:8px">
            <label class="muted" for="sweepSel" style="display:block;margin:0 0 6px">Secondary plot sweep:</label>
            <select id="sweepSel">
              <option value="C">i_rms vs C (R fixed)</option>
              <option value="R">i_rms vs R (C fixed)</option>
            </select>
          </div>
        </div>
      </div>

      <div class="results" aria-label="Live computed results">
        <div class="resultBox">
          <div class="k">Time constant</div>
          <div class="v" id="tauOut"></div>
        </div>
        <div class="resultBox">
          <div class="k">Equivalent noise bandwidth</div>
          <div class="v" id="bOut"></div>
        </div>
        <div class="resultBox">
          <div class="k">Thermal noise current (rms)</div>
          <div class="v" id="iOut"></div>
        </div>
      </div>

      <figure>
        <canvas id="cDiagram" aria-label="RC circuit diagram canvas"></canvas>
        <figcaption>
          <strong>Diagram:</strong> Resistor <span style="font-family:var(--mono)">R</span> with thermal noise modeled as a Norton current source
          feeding a capacitor <span style="font-family:var(--mono)">C</span> to ground (a first-order low-pass). Time constant <span style="font-family:var(--mono)">&tau;=RC</span>.
        </figcaption>
      </figure>

      <div class="grid2">
        <figure>
          <canvas id="cMain" aria-label="Main plot canvas"></canvas>
          <figcaption>
            <strong>Main plot:</strong> <span style="font-family:var(--mono)">|H(f)|²</span> for a 1-pole RC low-pass and the equal-area ENBW rectangle of width <span style="font-family:var(--mono)">B=1/(4RC)</span>.
          </figcaption>
        </figure>
        <figure>
          <canvas id="cSecond" aria-label="Secondary plot canvas"></canvas>
          <figcaption>
            <strong>Secondary plot:</strong> Parameter sweep of <span style="font-family:var(--mono)">i_rms</span> versus <span style="font-family:var(--mono)">C</span> or <span style="font-family:var(--mono)">R</span>.
            The marker shows the current slider setting.
          </figcaption>
        </figure>
      </div>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the formulas</h3>
      <ul>
        <li><span style="font-family:var(--mono)">B = 1/(4&tau;)</span>: ENBW is set purely by the response time scale. Faster circuits pass more noise.</li>
        <li><span style="font-family:var(--mono)">&tau; = RC</span>: increasing <span style="font-family:var(--mono)">R</span> or <span style="font-family:var(--mono)">C</span> slows the circuit, shrinking bandwidth.</li>
        <li><span style="font-family:var(--mono)">i_rms = √(kT/(R²C))</span>: noise increases with temperature, decreases with larger capacitance, and decreases with larger resistance (here because the Norton noise density scales as <span style="font-family:var(--mono)">1/R</span> and the bandwidth also shrinks with <span style="font-family:var(--mono)">R</span>).</li>
      </ul>

      <h3>How parameters affect outcomes (connect to the plots)</h3>
      <ul>
        <li><strong>Increase C:</strong> the main plot becomes “narrower” in frequency (smaller <span style="font-family:var(--mono)">B</span>), and the secondary plot shows <span style="font-family:var(--mono)">i_rms</span> decreasing roughly as <span style="font-family:var(--mono)">1/√C</span>.</li>
        <li><strong>Increase R:</strong> <span style="font-family:var(--mono)">B</span> decreases as <span style="font-family:var(--mono)">1/R</span>, and <span style="font-family:var(--mono)">i_rms</span> decreases approximately as <span style="font-family:var(--mono)">1/R</span> when <span style="font-family:var(--mono)">C</span> is fixed (because <span style="font-family:var(--mono)">i_rms ∝ 1/(R√C)</span>).</li>
        <li><strong>Increase T:</strong> bandwidth does not change (circuit unchanged), but <span style="font-family:var(--mono)">i_rms</span> rises as <span style="font-family:var(--mono)">√T</span>.</li>
      </ul>

      <h3>An alternative derivation idea (frequency domain)</h3>
      <p>
        For an RC low-pass, <span style="font-family:var(--mono)">H(jω)=1/(1+jω&tau;)</span>, so
        <span style="font-family:var(--mono)">|H(jω)|² = 1/(1+(ω&tau;)²)</span>.
        The ENBW for unity DC gain is
        <span style="font-family:var(--mono)">B = ∫₀^∞ |H(f)|² df</span> (one-sided). Evaluating this integral yields <span style="font-family:var(--mono)">B = 1/(4&tau;)</span>,
        consistent with the time-domain result (and the equal-area rectangle in the main plot).
      </p>

      <h3>Concept checks (quick self-test)</h3>
      <ul>
        <li><strong>Q:</strong> If <span style="font-family:var(--mono)">&tau;</span> doubles, what happens to <span style="font-family:var(--mono)">B</span>? <strong>A:</strong> It halves (<span style="font-family:var(--mono)">B ∝ 1/&tau;</span>).</li>
        <li><strong>Q:</strong> Is ENBW equal to the -3 dB cutoff <span style="font-family:var(--mono)">f_c</span> for an RC? <strong>A:</strong> No. <span style="font-family:var(--mono)">B = (π/2) f_c</span> for a 1-pole low-pass.</li>
        <li><strong>Q:</strong> Why doesn’t multiplying <span style="font-family:var(--mono)">h(t)</span> by a constant change ENBW here? <strong>A:</strong> Because the definition uses a ratio where the scale cancels.</li>
        <li><strong>Q:</strong> If you cool the resistor from 300 K to 75 K (4× lower), what happens to <span style="font-family:var(--mono)">i_rms</span>? <strong>A:</strong> It drops by <span style="font-family:var(--mono)">√4 = 2</span>.</li>
      </ul>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <h3>What each canvas shows</h3>
      <ul>
        <li><strong>Diagram canvas:</strong> the RC network with a Norton thermal noise current source in parallel with <span style="font-family:var(--mono)">R</span> feeding <span style="font-family:var(--mono)">C</span> to ground. This emphasizes the time constant <span style="font-family:var(--mono)">&tau;=RC</span>.</li>
        <li><strong>Main plot:</strong> the filter power transfer <span style="font-family:var(--mono)">|H(f)|²</span> vs frequency (Hz). A rectangle of height 1 and width <span style="font-family:var(--mono)">B=1/(4RC)</span> is drawn so its <em>area</em> matches the integral of <span style="font-family:var(--mono)">|H(f)|²</span>.</li>
        <li><strong>Secondary plot:</strong> <span style="font-family:var(--mono)">i_rms</span> swept versus <span style="font-family:var(--mono)">C</span> (log axis) or versus <span style="font-family:var(--mono)">R</span> (log axis). The marker indicates your current slider values.</li>
      </ul>

      <h3>Interactive controls (what changes and why)</h3>
      <ul>
        <li><strong>R slider:</strong> changes <span style="font-family:var(--mono)">&tau;=RC</span> and therefore the ENBW <span style="font-family:var(--mono)">B=1/(4RC)</span>; it also changes the noise density <span style="font-family:var(--mono)">S_i=4kT/R</span>.</li>
        <li><strong>C slider:</strong> changes <span style="font-family:var(--mono)">&tau;</span> and thus narrows/widens the frequency response and ENBW; it also affects <span style="font-family:var(--mono)">i_rms</span> through <span style="font-family:var(--mono)">1/√C</span>.</li>
        <li><strong>T slider:</strong> does not change the filter shape, but scales the noise current as <span style="font-family:var(--mono)">√T</span>.</li>
        <li><strong>Sweep dropdown:</strong> switches the secondary plot between sweeping <span style="font-family:var(--mono)">C</span> or <span style="font-family:var(--mono)">R</span> while holding the other at the current slider setting.</li>
      </ul>

      <div class="callout">
        <strong>Tip:</strong> Set <span style="font-family:var(--mono)">R=1 kΩ</span>, <span style="font-family:var(--mono)">C=5 pF</span>, <span style="font-family:var(--mono)">T=300 K</span> (the defaults) to match the book problem’s numeric answer.
      </div>
    </section>

  </div>
</main>

<footer>
  <div>
    Built as a self-contained learning article: no external libraries, no MathJax, and all visuals rendered with Canvas + vanilla JS.
  </div>
</footer>

<script>
(function(){
  "use strict";

  // ---------- Constants ----------
  const kB = 1.380649e-23; // J/K
  const EULER = Math.E;

  // ---------- Helpers ----------
  function fmtSI(x, unit){
    if (!isFinite(x)) return "—";
    const ax = Math.abs(x);
    const prefixes = [
      {p:1e-24,s:"y"},{p:1e-21,s:"z"},{p:1e-18,s:"a"},{p:1e-15,s:"f"},{p:1e-12,s:"p"},
      {p:1e-9,s:"n"},{p:1e-6,s:"µ"},{p:1e-3,s:"m"},{p:1,s:""},
      {p:1e3,s:"k"},{p:1e6,s:"M"},{p:1e9,s:"G"},{p:1e12,s:"T"},{p:1e15,s:"P"},{p:1e18,s:"E"}
    ];
    let best = prefixes[8];
    for (const pr of prefixes){
      if (ax >= pr.p) best = pr;
    }
    const v = x / best.p;
    const digits = (Math.abs(v) >= 100) ? 3 : (Math.abs(v) >= 10 ? 4 : 5);
    return `${v.toPrecision(digits)} ${best.s}${unit}`;
  }

  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function lerp(a,b,t){ return a+(b-a)*t; }
  function log10(x){ return Math.log(x)/Math.LN10; }
  function pow10(x){ return Math.pow(10,x); }

  // ---------- Copy buttons ----------
  function setupCopy(){
    document.querySelectorAll("button.copy").forEach(btn=>{
      btn.addEventListener("click", async ()=>{
        const text = btn.getAttribute("data-copy") || "";
        try{
          await navigator.clipboard.writeText(text);
          const old = btn.textContent;
          btn.textContent = "Copied ✓";
          setTimeout(()=>btn.textContent = old, 900);
        }catch(e){
          // Fallback
          const ta = document.createElement("textarea");
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          try{ document.execCommand("copy"); }catch(_){}
          document.body.removeChild(ta);
          const old = btn.textContent;
          btn.textContent = "Copied ✓";
          setTimeout(()=>btn.textContent = old, 900);
        }
      });
    });
  }

  // ---------- Canvas utilities ----------
  function setupCanvas(canvas){
    const ctx = canvas.getContext("2d");
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(280, rect.width);
      const h = Math.max(220, rect.height);
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {w, h, dpr};
    }
    return {ctx, resize};
  }

  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, opts){
    const {
      xLabel="x", yLabel="y", title="",
      xTicks=5, yTicks=5,
      grid=true,
      xTickFormatter=(v)=>String(v),
      yTickFormatter=(v)=>String(v),
      pad=46
    } = opts || {};

    const x0 = box.x + pad;
    const y0 = box.y + box.h - pad;
    const x1 = box.x + box.w - 14;
    const y1 = box.y + 18;

    // Background
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.10)";
    ctx.fillRect(box.x, box.y, box.w, box.h);

    // Title
    ctx.fillStyle = "rgba(234,242,255,0.95)";
    ctx.font = "700 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(title, box.x + 14, box.y + 18);

    // Plot area frame
    ctx.strokeStyle = "rgba(255,255,255,0.14)";
    ctx.lineWidth = 1;
    ctx.strokeRect(x0, y1, x1-x0, y0-y1);

    // Grid + ticks
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
    ctx.fillStyle = "rgba(182,194,214,0.95)";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";

    for(let i=0;i<=xTicks;i++){
      const t = i/xTicks;
      const x = lerp(x0, x1, t);
      const v = lerp(xMin, xMax, t);
      if(grid){
        ctx.strokeStyle = "rgba(255,255,255,0.08)";
        ctx.beginPath(); ctx.moveTo(x,y1); ctx.lineTo(x,y0); ctx.stroke();
      }
      ctx.fillText(xTickFormatter(v), x, y0 + 6);
    }

    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    for(let j=0;j<=yTicks;j++){
      const t = j/yTicks;
      const y = lerp(y0, y1, t);
      const v = lerp(yMin, yMax, t);
      if(grid){
        ctx.strokeStyle = "rgba(255,255,255,0.08)";
        ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke();
      }
      ctx.fillText(yTickFormatter(v), x0 - 8, y);
    }

    // Axis labels
    ctx.fillStyle = "rgba(234,242,255,0.85)";
    ctx.font = "650 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.fillText(xLabel, (x0+x1)/2, box.y + box.h - 8);

    ctx.save();
    ctx.translate(box.x + 14, (y0+y1)/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    ctx.restore();

    const mapX = (x)=> x0 + (x - xMin) * (x1-x0) / (xMax-xMin);
    const mapY = (y)=> y0 - (y - yMin) * (y0-y1) / (yMax-yMin);
    return {x0,y0,x1,y1, mapX, mapY};
  }

  // ---------- Physics computations ----------
  function compute(R, C, T){
    const tau = R*C;
    const B = 1/(4*tau);
    const Si = 4*kB*T/R;          // A^2/Hz (one-sided)
    const irms = Math.sqrt(Si*B); // A
    const fc = 1/(2*Math.PI*tau); // -3 dB cutoff (Hz), for reference
    return {tau, B, Si, irms, fc};
  }

  // RC low-pass magnitude squared:
  // |H(f)|^2 = 1 / (1 + (2π f τ)^2)
  function H2(f, tau){
    const x = 2*Math.PI*f*tau;
    return 1/(1 + x*x);
  }

  // ---------- Drawing: diagram ----------
  function drawDiagram(ctx, w, h, state){
    ctx.clearRect(0,0,w,h);

    // Title
    ctx.fillStyle = "rgba(234,242,255,0.95)";
    ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText("RC with thermal noise (Norton model)", 14, 22);

    // Layout coordinates
    const pad = 18;
    const midY = Math.round(h*0.56);
    const leftX = pad + 24;
    const rightX = w - pad - 24;

    // Node positions
    const nodeX = Math.round(w*0.55);
    const topY = Math.round(h*0.26);
    const gndY = Math.round(h*0.80);

    // Wires
    ctx.strokeStyle = "rgba(234,242,255,0.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(leftX, midY);
    ctx.lineTo(nodeX, midY);
    ctx.lineTo(nodeX, topY);
    ctx.stroke();

    // Output node
    ctx.fillStyle = "rgba(125,211,252,0.95)";
    ctx.beginPath();
    ctx.arc(nodeX, midY, 4, 0, Math.PI*2);
    ctx.fill();

    // Label V(t)
    ctx.fillStyle = "rgba(234,242,255,0.90)";
    ctx.font = "650 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
    ctx.fillText("node voltage v(t)", nodeX + 10, midY - 8);

    // Ground line
    ctx.strokeStyle = "rgba(234,242,255,0.70)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(nodeX, gndY);
    ctx.lineTo(nodeX, midY);
    ctx.stroke();

    // Ground symbol
    const gx = nodeX, gy = gndY;
    ctx.beginPath();
    ctx.moveTo(gx-16, gy);
    ctx.lineTo(gx+16, gy);
    ctx.moveTo(gx-11, gy+7);
    ctx.lineTo(gx+11, gy+7);
    ctx.moveTo(gx-6, gy+14);
    ctx.lineTo(gx+6, gy+14);
    ctx.stroke();

    // Capacitor from node to ground (right side)
    const capX = Math.round(w*0.78);
    const capTop = midY;
    const capBot = gndY;
    ctx.strokeStyle = "rgba(167,139,250,0.95)";
    ctx.lineWidth = 3;
    // wire to capacitor
    ctx.beginPath();
    ctx.moveTo(nodeX, midY);
    ctx.lineTo(capX-28, midY);
    ctx.stroke();
    // capacitor plates
    ctx.beginPath();
    ctx.moveTo(capX-28, capTop+12);
    ctx.lineTo(capX-28, capTop-12);
    ctx.moveTo(capX-16, capTop+12);
    ctx.lineTo(capX-16, capTop-12);
    ctx.stroke();
    // wire down to ground
    ctx.strokeStyle = "rgba(234,242,255,0.70)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(capX-16, capTop);
    ctx.lineTo(capX-16, capBot);
    ctx.stroke();

    ctx.fillStyle = "rgba(234,242,255,0.92)";
    ctx.font = "650 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
    ctx.fillText(`C = ${fmtSI(state.C,"F")}`, capX-10, capTop-22);

    // Resistor + noise current source (left branch to node)
    const resX = Math.round(w*0.30);
    // wire from left input to resistor
    ctx.strokeStyle = "rgba(234,242,255,0.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(leftX, midY);
    ctx.lineTo(resX-60, midY);
    ctx.stroke();

    // draw resistor zigzag
    const rz0 = resX-60, rz1 = resX+20;
    const zigN = 7;
    const amp = 12;
    ctx.strokeStyle = "rgba(125,211,252,0.95)";
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(rz0, midY);
    for(let i=1;i<=zigN;i++){
      const t = i/zigN;
      const x = lerp(rz0, rz1, t);
      const y = midY + (i%2===0 ? -amp : amp);
      ctx.lineTo(x,y);
    }
    ctx.lineTo(rz1+18, midY);
    ctx.stroke();

    // connect resistor to node
    ctx.strokeStyle = "rgba(234,242,255,0.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(rz1+18, midY);
    ctx.lineTo(nodeX, midY);
    ctx.stroke();

    // Label R
    ctx.fillStyle = "rgba(234,242,255,0.92)";
    ctx.font = "650 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
    ctx.fillText(`R = ${fmtSI(state.R,"Ω")}`, resX-18, midY-26);

    // Norton noise current source to ground at node (symbol)
    const srcX = Math.round(w*0.52);
    const srcTop = midY;
    const srcBot = gndY;
    const circleR = 18;

    // branch wire down a bit
    ctx.strokeStyle = "rgba(234,242,255,0.75)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(srcX, srcTop);
    ctx.lineTo(srcX, srcTop+26);
    ctx.stroke();

    // circle
    const cy = srcTop+26+circleR;
    ctx.strokeStyle = "rgba(251,191,36,0.95)";
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.arc(srcX, cy, circleR, 0, Math.PI*2);
    ctx.stroke();

    // arrow inside (current source)
    ctx.beginPath();
    ctx.moveTo(srcX, cy+10);
    ctx.lineTo(srcX, cy-10);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(srcX-6, cy-2);
    ctx.lineTo(srcX, cy-10);
    ctx.lineTo(srcX+6, cy-2);
    ctx.stroke();

    // wire to ground
    ctx.strokeStyle = "rgba(234,242,255,0.75)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(srcX, cy+circleR);
    ctx.lineTo(srcX, srcBot);
    ctx.stroke();

    // label
    ctx.fillStyle = "rgba(234,242,255,0.92)";
    ctx.font = "650 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
    ctx.fillText("i_n(t) (thermal)", srcX-48, cy-26);

    // time constant note
    ctx.fillStyle = "rgba(182,194,214,0.95)";
    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(`τ = RC = ${fmtSI(state.tau,"s")}`, 14, h-18);
  }

  // ---------- Drawing: main plot |H(f)|^2 + ENBW rectangle ----------
  function drawMain(ctx, w, h, state){
    ctx.clearRect(0,0,w,h);

    const tau = state.tau;
    const B = state.B;
    const fc = state.fc;

    // Choose x range: 0 to fMax (so rectangle visible).
    // Make sure both B and a few cutoffs fit well.
    const fMax = Math.max(6*fc, 3*B);
    const xMin = 0;
    const xMax = fMax;

    // y range: 0..1.05
    const yMin = 0;
    const yMax = 1.05;

    const ax = drawAxes(ctx, {x:0,y:0,w,h}, xMin, xMax, yMin, yMax, {
      title: "|H(f)|² for 1-pole RC low-pass + ENBW rectangle",
      xLabel: "frequency f (Hz)",
      yLabel: "|H(f)|² (dimensionless)",
      xTicks: 6,
      yTicks: 5,
      xTickFormatter: (v)=> {
        if (v===0) return "0";
        return fmtSI(v,"").replace(" ","");
      },
      yTickFormatter: (v)=> v.toFixed(2)
    });

    // Compute curve samples
    const N = 600;
    const pts = [];
    for(let i=0;i<=N;i++){
      const f = lerp(xMin, xMax, i/N);
      pts.push([f, H2(f, tau)]);
    }

    // Shade approximate area under curve (visual aid)
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(ax.mapX(xMin), ax.mapY(0));
    for(const [f,y] of pts){
      ctx.lineTo(ax.mapX(f), ax.mapY(y));
    }
    ctx.lineTo(ax.mapX(xMax), ax.mapY(0));
    ctx.closePath();
    ctx.fillStyle = "rgba(125,211,252,0.10)";
    ctx.fill();
    ctx.restore();

    // Draw curve
    ctx.save();
    ctx.strokeStyle = "rgba(125,211,252,0.95)";
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    let first=true;
    for(const [f,y] of pts){
      const X=ax.mapX(f), Y=ax.mapY(y);
      if(first){ ctx.moveTo(X,Y); first=false; }
      else ctx.lineTo(X,Y);
    }
    ctx.stroke();
    ctx.restore();

    // ENBW rectangle: height = |H(0)|^2 = 1, width = B
    ctx.save();
    const rectW = ax.mapX(Math.min(B, xMax)) - ax.mapX(0);
    const rectH = ax.mapY(0) - ax.mapY(1);
    ctx.fillStyle = "rgba(52,211,153,0.12)";
    ctx.strokeStyle = "rgba(52,211,153,0.85)";
    ctx.lineWidth = 2;
    ctx.fillRect(ax.mapX(0), ax.mapY(1), rectW, rectH);
    ctx.strokeRect(ax.mapX(0), ax.mapY(1), rectW, rectH);

    // Label ENBW rectangle
    ctx.fillStyle = "rgba(234,242,255,0.92)";
    ctx.font = "650 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
    const labelX = ax.mapX(0) + Math.min(rectW, ax.x1-ax.x0)*0.55;
    ctx.fillText(`ENBW: B = ${fmtSI(B,"Hz")}`, labelX, ax.mapY(1) - 10);
    ctx.restore();

    // Mark -3 dB cutoff fc
    ctx.save();
    const y3 = 0.5; // |H|^2 at -3 dB for first-order
    const Xc = ax.mapX(Math.min(fc, xMax));
    ctx.strokeStyle = "rgba(251,191,36,0.85)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(Xc, ax.y1);
    ctx.lineTo(Xc, ax.y0);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(ax.x0, ax.mapY(y3));
    ctx.lineTo(ax.x1, ax.mapY(y3));
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = "rgba(251,191,36,0.95)";
    ctx.font = "650 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
    ctx.fillText(`f_c = ${fmtSI(fc,"Hz")}`, Xc + 6, ax.y1 + 14);
    ctx.fillText("|H|²=0.5 (-3 dB)", ax.x1 - 8, ax.mapY(y3) - 8);
    ctx.restore();

    // Small legend
    ctx.save();
    const lx = ax.x0 + 10, ly = ax.y1 + 8;
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(lx, ly, 250, 58, 12);
    ctx.fill(); ctx.stroke();

    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillStyle = "rgba(234,242,255,0.92)";
    // curve swatch
    ctx.strokeStyle = "rgba(125,211,252,0.95)";
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(lx+12, ly+18); ctx.lineTo(lx+42, ly+18); ctx.stroke();
    ctx.fillText("|H(f)|²", lx+52, ly+22);

    // rectangle swatch
    ctx.fillStyle = "rgba(52,211,153,0.18)";
    ctx.strokeStyle = "rgba(52,211,153,0.85)";
    ctx.lineWidth = 2;
    ctx.fillRect(lx+12, ly+30, 30, 14);
    ctx.strokeRect(lx+12, ly+30, 30, 14);
    ctx.fillStyle = "rgba(234,242,255,0.92)";
    ctx.fillText("ENBW rectangle", lx+52, ly+42);
    ctx.restore();
  }

  // ---------- Drawing: secondary sweep plot ----------
  function drawSecondary(ctx, w, h, state, sweepMode){
    ctx.clearRect(0,0,w,h);

    const R0 = state.R, C0 = state.C, T0 = state.T;

    // Sweep ranges (log)
    const n = 220;
    let xMin, xMax, xLabel, title;
    let makePoint; // function(x)-> {xReal, y}
    let currentX;

    if(sweepMode === "R"){
      xMin = 1.5; // 10^1.5 ~ 31.6 Ω
      xMax = 6.5; // 10^6.5 ~ 3.16 MΩ
      xLabel = "Resistance R (Ω, log scale)";
      title = "Thermal noise current i_rms vs R (C fixed)";
      makePoint = (x)=>{
        const R = pow10(x);
        const st = compute(R, C0, T0);
        return {xReal:R, y:st.irms};
      };
      currentX = log10(R0);
    }else{
      xMin = -14; // 10^-14 F = 0.01 pF
      xMax = -8.5; // 10^-8.5 F ~ 3.16 nF
      xLabel = "Capacitance C (F, log scale)";
      title = "Thermal noise current i_rms vs C (R fixed)";
      makePoint = (x)=>{
        const C = pow10(x);
        const st = compute(R0, C, T0);
        return {xReal:C, y:st.irms};
      };
      currentX = log10(C0);
    }

    // Gather points, and find y-range
    const pts = [];
    let yMin = Infinity, yMax = -Infinity;
    for(let i=0;i<=n;i++){
      const x = lerp(xMin, xMax, i/n);
      const p = makePoint(x);
      pts.push({x, xReal:p.xReal, y:p.y});
      yMin = Math.min(yMin, p.y);
      yMax = Math.max(yMax, p.y);
    }

    // y in log scale too (because spans widely)
    const yMinL = log10(yMin);
    const yMaxL = log10(yMax);

    const ax = drawAxes(ctx, {x:0,y:0,w,h}, xMin, xMax, yMinL, yMaxL, {
      title,
      xLabel,
      yLabel: "i_rms (A, log scale)",
      xTicks: 6,
      yTicks: 5,
      xTickFormatter: (v)=>{
        const real = pow10(v);
        if (sweepMode === "R") return fmtSI(real,"Ω").replace(" ","");
        return fmtSI(real,"F").replace(" ","");
      },
      yTickFormatter: (v)=>{
        const real = pow10(v);
        return fmtSI(real,"A").replace(" ","");
      }
    });

    // Draw curve
    ctx.save();
    ctx.strokeStyle = "rgba(167,139,250,0.95)";
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    let first = true;
    for(const p of pts){
      const X = ax.mapX(p.x);
      const Y = ax.mapY(log10(p.y));
      if(first){ ctx.moveTo(X,Y); first=false; }
      else ctx.lineTo(X,Y);
    }
    ctx.stroke();
    ctx.restore();

    // Marker at current slider value
    const xC = clamp(currentX, xMin, xMax);
    const pC = makePoint(xC);
    const yC = log10(pC.y);

    ctx.save();
    ctx.strokeStyle = "rgba(251,191,36,0.85)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(ax.mapX(xC), ax.y1);
    ctx.lineTo(ax.mapX(xC), ax.y0);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = "rgba(251,191,36,0.95)";
    ctx.beginPath();
    ctx.arc(ax.mapX(xC), ax.mapY(yC), 5, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(234,242,255,0.92)";
    ctx.font = "650 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
    const label = `current: i_rms = ${fmtSI(pC.y,"A")}`;
    ctx.fillText(label, ax.mapX(xC)+8, ax.mapY(yC)-10);
    ctx.restore();

    // Small note about formula
    ctx.save();
    ctx.fillStyle = "rgba(182,194,214,0.95)";
    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText("Model: i_rms = √(4kT B / R), with B = 1/(4RC)", ax.x0, ax.y0 + 20);
    ctx.restore();
  }

  // Add roundRect polyfill-ish (modern browsers have it, but safe)
  if (!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    };
  }

  // ---------- State + UI ----------
  const rSlider = document.getElementById("rSlider");
  const cSlider = document.getElementById("cSlider");
  const tSlider = document.getElementById("tSlider");
  const sweepSel = document.getElementById("sweepSel");

  const rVal = document.getElementById("rVal");
  const cVal = document.getElementById("cVal");
  const tVal = document.getElementById("tVal");

  const tauOut = document.getElementById("tauOut");
  const bOut = document.getElementById("bOut");
  const iOut = document.getElementById("iOut");

  const canvDiagram = setupCanvas(document.getElementById("cDiagram"));
  const canvMain = setupCanvas(document.getElementById("cMain"));
  const canvSecond = setupCanvas(document.getElementById("cSecond"));

  function readInputs(){
    const R = pow10(parseFloat(rSlider.value));
    const C = pow10(parseFloat(cSlider.value));
    const T = parseFloat(tSlider.value);
    return {R,C,T};
  }

  function updateLabels(state){
    rVal.textContent = fmtSI(state.R, "Ω");
    cVal.textContent = fmtSI(state.C, "F");
    tVal.textContent = `${state.T.toFixed(0)} K`;

    tauOut.textContent = `${fmtSI(state.tau, "s")}   (τ = RC)`;
    bOut.textContent = `${fmtSI(state.B, "Hz")}   (B = 1/(4RC))`;
    iOut.textContent = `${fmtSI(state.irms, "A")}   (i_rms = √(4kTB/R))`;
  }

  function render(){
    const {R,C,T} = readInputs();
    const comp = compute(R,C,T);
    const state = {R,C,T, ...comp};

    updateLabels(state);

    // Resize and draw
    const d = canvDiagram.resize();
    drawDiagram(canvDiagram.ctx, d.w, d.h, state);

    const m = canvMain.resize();
    drawMain(canvMain.ctx, m.w, m.h, state);

    const s = canvSecond.resize();
    drawSecondary(canvSecond.ctx, s.w, s.h, state, sweepSel.value);
  }

  // Event listeners
  [rSlider, cSlider, tSlider, sweepSel].forEach(el=>{
    el.addEventListener("input", render);
    el.addEventListener("change", render);
  });
  window.addEventListener("resize", render);

  // Defaults match the problem statement:
  // R=1kΩ => log10=3
  // C=5pF => log10(5e-12) = log10(5) - 12 = -11.30103...
  // T=300K
  setupCopy();
  render();

})();
</script>
</body>
</html>
