<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Photoconductive Detector Circuit: Vp vs Optical Power</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --card:#111c3a;
      --text:#e9eefc;
      --muted:#b9c3e6;
      --faint:#7f8ab8;
      --accent:#7aa2ff;
      --accent2:#7dffb2;
      --warn:#ffd37a;
      --danger:#ff7aa8;
      --border:rgba(255,255,255,.10);
      --shadow: 0 18px 45px rgba(0,0,0,.35);
      --radius:16px;
      --radius2:22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background: radial-gradient(1100px 700px at 18% 10%, rgba(122,162,255,.18), transparent 60%),
                  radial-gradient(900px 650px at 80% 30%, rgba(125,255,178,.10), transparent 55%),
                  linear-gradient(180deg, var(--bg), #070a14 70%, #060811);
      color:var(--text);
      font-family:var(--sans);
      line-height:1.55;
    }
    header{
      padding: 28px 18px 18px;
      border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.04), transparent);
      position: relative;
      overflow:hidden;
    }
    header .wrap{
      max-width: 1200px;
      margin:0 auto;
      display:grid;
      gap:14px;
    }
    h1{
      margin:0;
      font-size: clamp(1.35rem, 2.4vw, 2.2rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      max-width: 78ch;
    }

    main{
      max-width: 1200px;
      margin: 0 auto;
      padding: 18px;
      display:grid;
      grid-template-columns: 290px 1fr;
      gap: 18px;
      align-items:start;
    }

    nav.toc{
      position: sticky;
      top: 14px;
      background: rgba(17,28,58,.65);
      backdrop-filter: blur(10px);
      border:1px solid var(--border);
      border-radius: var(--radius2);
      padding: 14px 14px 10px;
      box-shadow: var(--shadow);
    }
    nav.toc h2{
      font-size: .95rem;
      margin:0 0 10px;
      color: var(--muted);
      letter-spacing:.4px;
      text-transform: uppercase;
    }
    nav.toc a{
      display:block;
      padding:8px 10px;
      margin: 4px 0;
      color: var(--text);
      text-decoration:none;
      border-radius: 12px;
      border:1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      font-size:.95rem;
    }
    nav.toc a:hover{
      background: rgba(122,162,255,.10);
      border-color: rgba(122,162,255,.25);
      transform: translateY(-1px);
    }
    nav.toc .mini{
      margin-top:10px;
      padding-top:10px;
      border-top:1px dashed rgba(255,255,255,.14);
      color: var(--faint);
      font-size: .9rem;
    }

    article{
      display:grid;
      gap: 16px;
      min-width: 0;
    }

    section{
      background: rgba(17,28,58,.55);
      border:1px solid var(--border);
      border-radius: var(--radius2);
      padding: 16px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    section h2{
      margin:0 0 10px;
      font-size: 1.18rem;
      letter-spacing:.2px;
    }
    section h3{
      margin: 14px 0 8px;
      font-size: 1.02rem;
      color: var(--muted);
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
      nav.toc{position: relative; top:0}
      .grid2,.grid3{grid-template-columns: 1fr}
    }

    .callout{
      border:1px solid rgba(255,255,255,.12);
      border-left: 4px solid rgba(122,162,255,.85);
      background: rgba(11,16,32,.55);
      border-radius: 14px;
      padding: 12px 12px 10px;
    }
    .callout.warn{border-left-color: rgba(255,211,122,.95)}
    .callout.danger{border-left-color: rgba(255,122,168,.95)}
    .callout.ok{border-left-color: rgba(125,255,178,.90)}
    .callout h4{
      margin:0 0 6px;
      font-size:.95rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing:.35px;
    }
    ul{margin:8px 0 0 20px}
    li{margin: 6px 0}
    .eq{
      font-family: var(--mono);
      font-size: .96rem;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.12);
      padding: 10px 10px;
      border-radius: 14px;
      overflow:auto;
      position:relative;
    }
    .eq .label{
      font-family: var(--sans);
      font-size: .85rem;
      color: var(--faint);
      margin-bottom: 6px;
    }
    .btnrow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    button.copy{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(122,162,255,.12);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      cursor:pointer;
      font-weight:600;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    button.copy:hover{
      transform: translateY(-1px);
      background: rgba(122,162,255,.18);
      border-color: rgba(122,162,255,.35);
    }
    .hint{
      color: var(--faint);
      font-size: .92rem;
    }

    .viz{
      display:grid;
      gap: 12px;
    }
    .canvasCard{
      background: rgba(11,16,32,.55);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      padding: 12px;
      overflow:hidden;
    }
    .canvasTitle{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .canvasTitle strong{font-size:1.0rem}
    .canvasTitle span{color:var(--faint); font-size:.9rem}
    canvas{
      width: 100%;
      height: 320px;
      display:block;
      border-radius: 14px;
      background: rgba(6,8,17,.55);
      border: 1px solid rgba(255,255,255,.10);
    }
    .controls{
      display:grid;
      gap: 10px;
      padding: 12px;
      background: rgba(11,16,32,.55);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 18px;
    }
    .controls .row{
      display:grid;
      grid-template-columns: 1.2fr 2fr .9fr;
      gap: 10px;
      align-items:center;
    }
    .controls label{
      color: var(--muted);
      font-size: .95rem;
    }
    input[type="range"]{
      width:100%;
    }
    .pill{
      font-family: var(--mono);
      font-size: .92rem;
      color: var(--text);
      padding: 6px 8px;
      border-radius: 12px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      text-align:right;
      white-space:nowrap;
    }
    .toggleRow{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      padding-top:6px;
      border-top:1px dashed rgba(255,255,255,.14);
      margin-top:6px;
    }
    .toggle{
      display:flex;
      gap:8px;
      align-items:center;
      user-select:none;
      color: var(--muted);
      font-size:.95rem;
    }
    .toggle input{transform: translateY(1px);}
    footer{
      max-width: 1200px;
      margin: 0 auto;
      padding: 18px;
      color: var(--faint);
      font-size: .92rem;
      text-align:center;
    }

    /* subtle entrance */
    @media (prefers-reduced-motion: no-preference){
      section{
        animation: pop .35s ease both;
      }
      @keyframes pop{
        from{opacity:0; transform: translateY(6px)}
        to{opacity:1; transform: translateY(0)}
      }
    }
    /* print */
    @media print{
      body{background:#fff; color:#000}
      nav.toc{display:none}
      main{grid-template-columns: 1fr}
      section, .canvasCard, .controls{box-shadow:none; background:#fff; border-color:#ccc}
      canvas{border-color:#ccc}
      .eq{background:#fff; border-color:#bbb}
      button.copy{display:none}
    }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>Photoconductive Detector Circuit: How the Measured Load Voltage Depends on Optical Power</h1>
    <p class="subtitle">
      A photoconductive detector acts like a light-controlled conductance. Placed in series with a load resistor and a DC source, it forms a voltage divider whose output is typically nonlinear in optical power—unless you operate in the right regime.
    </p>
  </div>
</header>

<main>
  <nav class="toc" aria-label="Table of contents">
    <h2>Table of Contents</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
    <div class="mini">
      Interactive plots use <span style="color:var(--accent)">example values</span> for visualization only; the final result is symbolic.
    </div>
  </nav>

  <article>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><strong>What this problem is about:</strong> A photoconductive detector in series with a load resistor <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R</span> across a DC source <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V</span>; we measure the load voltage <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub></span> and relate it to optical power <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span>.</li>
        <li><strong>Key physics idea:</strong> The circuit is a <em>voltage divider</em> where the detector behaves like a resistor whose <em>conductance</em> increases with light.</li>
        <li><strong>Governing model:</strong> Detector conductance is proportional to optical power:
          <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G(P)=G<sub>d</sub>+αP</span>
          (dark conductance <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G<sub>d</sub></span>, sensitivity <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">α</span>).</li>
        <li><strong>Core circuit equation:</strong> <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub>=V·R/(R+R<sub>d</sub>)</span> with <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R<sub>d</sub>=1/G</span>.</li>
        <li><strong>Final result type:</strong> A symbolic function <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub>(P)</span> and clear <em>linearity conditions</em> (small-signal or low-conductance regime).</li>
        <li><strong>Qualitative sketch:</strong> <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub></span> rises with <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span> and saturates toward <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V</span> at high power (because the detector resistance collapses).</li>
      </ul>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

      <div class="grid2">
        <div class="callout">
          <h4>Core definitions</h4>
          <ul>
            <li><strong>Optical power</strong> <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span> [W]: rate of optical energy delivered to the detector.</li>
            <li><strong>Conductance</strong> <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G</span> [S = Ω<sup>−1</sup>]: how easily current flows; <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G = 1/R</span>.</li>
            <li><strong>Detector resistance</strong> <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R<sub>d</sub></span> [Ω]: effective resistance of the photoconductor; <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R<sub>d</sub> = 1/G</span>.</li>
            <li><strong>Load resistor</strong> <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R</span> [Ω]: converts current variations into a measurable voltage.</li>
            <li><strong>Measured voltage</strong> <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub></span> [V]: voltage drop across the load resistor.</li>
          </ul>
        </div>

        <div class="callout ok">
          <h4>Physical meaning</h4>
          <ul>
            <li>Light generates additional carriers in the photoconductor → <strong>conductance increases</strong>.</li>
            <li>In a series circuit, the same current flows through <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R</span> and the detector, so changing the detector’s resistance <em>reshapes the voltage division</em>.</li>
            <li>At very high conductance, the detector becomes nearly a short, so <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub></span> approaches the source voltage <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V</span>.</li>
          </ul>
        </div>
      </div>

      <h3>Key laws/principles (and validity)</h3>
      <ul>
        <li><strong>Ohm’s law:</strong> <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V = IR</span> and <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">I = GV</span> for linear resistive elements.</li>
        <li><strong>Series circuit rule:</strong> Same current through series elements; voltages add to the source voltage.</li>
        <li><strong>Voltage divider:</strong> If two resistances are in series, the voltage across one is a fraction of the total.</li>
        <li><strong>Model assumption:</strong> The photoconductive detector can be modeled as a <em>variable resistor</em> (i.e., quasi-static, no significant capacitance/inductance, and linear I–V at the operating bias).</li>
      </ul>

      <div class="grid2">
        <div class="callout">
          <h4>Common models / approximations</h4>
          <ul>
            <li><strong>Affine conductance model:</strong> <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G(P)=G<sub>d</sub>+αP</span>, where <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G<sub>d</sub></span> is dark conductance and <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">α</span> [S/W] is proportionality (responsivity in conductance form).</li>
            <li><strong>Low-conductance regime:</strong> If <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">RG ≪ 1</span>, the divider behaves nearly like a current-to-voltage converter with <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub> ∝ G</span>.</li>
            <li><strong>Small-signal linearization:</strong> Around a bias power <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P<sub>0</sub></span>, small changes <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">ΔP</span> give <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">ΔV<sub>p</sub> ≈ (dV<sub>p</sub>/dP)|<sub>P0</sub> · ΔP</span>.</li>
          </ul>
        </div>
        <div class="callout warn">
          <h4>What to watch for (pitfalls)</h4>
          <ul>
            <li><strong>Mixing resistance and conductance:</strong> If <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G ∝ P</span>, then <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R = 1/G</span> is <em>not</em> proportional to <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span> (it’s hyperbolic).</li>
            <li><strong>Assuming linear output automatically:</strong> A voltage divider with a variable resistor is generally <em>nonlinear</em> in the control variable.</li>
            <li><strong>Ignoring dark conductance:</strong> If <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G<sub>d</sub></span> is not negligible, the curve does not start from zero at <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P=0</span>.</li>
          </ul>
        </div>
      </div>

      <h3>Mini intuition examples</h3>
      <ul>
        <li><strong>Very dim light:</strong> If the detector is almost an open circuit, current is tiny, so <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub></span> is near zero (if <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G<sub>d</sub></span> is tiny).</li>
        <li><strong>Very bright light:</strong> Detector resistance collapses → almost all the source voltage drops on the load: <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub> → V</span>.</li>
      </ul>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>Restatement in plain words</h3>
      <p>
        A DC source <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V</span> drives a series chain of a load resistor <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R</span> and a photoconductive detector.
        The detector’s conductance increases in proportion to the incident optical power <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span>.
        We measure the voltage across the load resistor, called <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub></span>.
        We must sketch and describe how <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub></span> depends on <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span> and state when the dependence is linear.
      </p>

      <div class="grid2">
        <div class="callout">
          <h4>Given</h4>
          <ul>
            <li>DC source voltage: <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V</span> [V]</li>
            <li>Load resistance: <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R</span> [Ω]</li>
            <li>Detector conductance proportional to optical power: <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G(P) ∝ P</span> (often modeled as <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G(P)=G<sub>d</sub>+αP</span>)</li>
          </ul>
        </div>
        <div class="callout ok">
          <h4>Unknowns / tasks</h4>
          <ul>
            <li>Find <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub>(P)</span> (symbolic).</li>
            <li>Sketch the curve shape (qualitative behavior & limits).</li>
            <li>State conditions for <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub></span> to be (approximately) linear in <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span>.</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (why these apply)</h3>
      <ul>
        <li><strong>Voltage divider / Ohm’s law:</strong> The detector and load are modeled as resistive elements in series, so DC circuit analysis applies.</li>
        <li><strong>Constitutive relation:</strong> The detector’s material response is summarized by <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G(P)</span>; the circuit just translates <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G</span> into a measurable voltage.</li>
        <li><strong>Why not other physics:</strong> No time dependence is requested; we ignore capacitance, carrier transit dynamics, and noise because the problem asks only for a static dependence and a sketch.</li>
      </ul>

      <div class="callout warn">
        <h4>Assumptions (explicit)</h4>
        <ul>
          <li>Quasi-static DC operation (no significant capacitances/inductances).</li>
          <li>Detector behaves as a linear resistor at the applied bias (Ohmic I–V).</li>
          <li>Conductance depends on optical power as <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G(P)=G<sub>d</sub>+αP</span> (includes possible dark conductance).</li>
          <li>Temperature and self-heating effects are neglected.</li>
        </ul>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ul>
        <li><strong>Approach A: Voltage divider using resistances</strong> (<span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R</span> and <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R<sub>d</sub>=1/G</span>) — simple and intuitive; directly yields <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub></span>.</li>
        <li><strong>Approach B: Current-first using conductances</strong> — compute <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">I = V/(R+1/G)</span> then <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub>=IR</span>; algebraically equivalent, sometimes cleaner when <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G(P)</span> is given.</li>
        <li><strong>Approach C: Small-signal linearization</strong> — best when the question emphasizes “when is it linear?” around a chosen operating point.</li>
      </ul>
      <p><strong>Chosen approach:</strong> Use the voltage-divider form in terms of <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G</span> (Approach B), then discuss linearity via low-conductance and small-signal limits.</p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>
      <ol>
        <li>
          <strong>Model the detector</strong> as a resistance <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R<sub>d</sub>=1/G(P)</span>.
          <div class="hint">Meaning: brighter light → larger <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G</span> → smaller <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R<sub>d</sub></span>.</div>
        </li>
        <li>
          <strong>Write the series current</strong> using Ohm’s law:
          <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">I = V/(R + R<sub>d</sub>)</span>.
          <div class="hint">Meaning: current is set by the total series resistance.</div>
        </li>
        <li>
          <strong>Convert to the measured voltage</strong> across the load:
          <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub> = IR</span>.
          <div class="hint">Meaning: the load turns current into an output voltage.</div>
        </li>
        <li>
          <strong>Substitute</strong> <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R<sub>d</sub>=1/G</span> to express <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub></span> directly in terms of <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G</span>.
          <div class="hint">Meaning: we get a compact rational form in <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">RG</span>.</div>
        </li>
        <li>
          <strong>Insert the light-dependence</strong> <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G(P)=G<sub>d</sub>+αP</span> to obtain <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub>(P)</span>.
        </li>
        <li>
          <strong>Sketch using limiting cases</strong> (<span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P→0</span>, <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P→∞</span>) and monotonicity.
        </li>
        <li>
          <strong>Assess linearity</strong> via:
          <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">RG(P) ≪ 1</span> (global low-power regime) and/or small-signal derivative <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">dV<sub>p</sub>/dP</span> around an operating point.
        </li>
      </ol>

      <div class="callout danger">
        <h4>Common mistakes</h4>
        <ul>
          <li>Replacing <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R<sub>d</sub></span> by something proportional to <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span> (it’s proportional to <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">1/P</span> if <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G∝P</span> and dark conductance is ignored).</li>
          <li>Forgetting that <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub></span> cannot exceed <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V</span>.</li>
          <li>Claiming “linear” without stating the regime (low-power or small-signal).</li>
        </ul>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

      <h3>Physical intuition first (qualitative expectation)</h3>
      <p>
        As optical power <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span> increases, the detector’s conductance increases, so its resistance decreases. In a series voltage divider, that means the detector “drops less voltage,” leaving more of the source voltage to drop across the load resistor. Therefore <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub></span> should increase with <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span>, but it should saturate as it approaches the maximum possible value <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V</span>.
      </p>

      <h3>Step-by-step derivation</h3>

      <div class="eq" id="eq1">
        <div class="label">Step 1 — Model the detector</div>
        R_d(P) = 1 / G(P)
      </div>

      <p>
        Here <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R<sub>d</sub></span> [Ω] is the detector’s effective resistance and <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G</span> [S] is its conductance.
      </p>

      <div class="eq" id="eq2">
        <div class="label">Step 2 — Series current through load and detector</div>
        I(P) = V / ( R + R_d(P) )
      </div>

      <p>
        Because the elements are in series, the same current <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">I</span> flows through both.
      </p>

      <div class="eq" id="eq3">
        <div class="label">Step 3 — Output is the voltage across the load resistor</div>
        V_p(P) = I(P) · R
      </div>

      <p>
        This is the key measurement: the load resistor converts the light-dependent current into a measurable voltage.
      </p>

      <div class="eq" id="eq4">
        <div class="label">Step 4 — Substitute R_d(P)=1/G(P) and simplify</div>
        V_p(P) = V · R / ( R + 1/G(P) ) = V · (R G(P)) / ( 1 + R G(P) )
      </div>

      <p>
        The compact form shows that the dimensionless product <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">RG</span> controls the nonlinearity.
      </p>

      <div class="eq" id="eq5">
        <div class="label">Step 5 — Insert conductance proportional to optical power</div>
        G(P) = G_d + α P
      </div>

      <p>
        <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G<sub>d</sub></span> [S] is the dark conductance (at <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P=0</span>) and <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">α</span> [S/W] quantifies how strongly conductance rises with power.
      </p>

      <div class="callout ok">
        <h4>Final symbolic dependence</h4>
        <div class="eq" id="eqFinal">
          V_p(P) = V · R (G_d + αP) / ( 1 + R (G_d + αP) )
        </div>
        <div class="btnrow">
          <button class="copy" data-copy="V_p(P) = V * R * (G_d + α P) / (1 + R * (G_d + α P))">Copy final answer</button>
          <button class="copy" data-copy="V_p(P) = V * (R G(P)) / (1 + R G(P))">Copy key equation</button>
        </div>
        <div class="hint">Sketch: monotonic increase vs <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span>, saturating to <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V</span>.</div>
      </div>

      <h3>Sanity checks</h3>
      <div class="grid2">
        <div class="callout">
          <h4>Units / dimensions</h4>
          <ul>
            <li><span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">RG</span> is dimensionless because <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">Ω · S = 1</span>.</li>
            <li>So <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V·(RG)/(1+RG)</span> has units of volts, as required.</li>
          </ul>
        </div>
        <div class="callout ok">
          <h4>Limiting cases</h4>
          <ul>
            <li><strong>Dark / low power:</strong> <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P→0</span> gives
              <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V_p(0)=V·RG_d/(1+RG_d)</span>.</li>
            <li><strong>Bright light:</strong> <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P→∞</span> makes <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">RG→∞</span>, so
              <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V_p → V</span>.</li>
            <li><strong>If dark conductance negligible:</strong> curve starts near 0 and rises toward <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V</span>.</li>
          </ul>
        </div>
      </div>

      <div class="callout warn">
        <h4>When is Vp(P) linear?</h4>
        <ul>
          <li><strong>Low-conductance (global) regime:</strong> if <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R(G_d+αP) ≪ 1</span> over your power range, then
            <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V_p(P) ≈ V·R(G_d+αP)</span>, which is linear in <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span>.</li>
          <li><strong>Small-signal regime around P0:</strong> for small variations <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">ΔP</span>,
            <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">ΔV_p ≈ (dV_p/dP)|_{P0} · ΔP</span> is linear even if the full curve is not.</li>
        </ul>
      </div>

      <div class="eq" id="eqSlope">
        <div class="label">Useful small-signal slope (connects to nonlinearity)</div>
        dV_p/dP = V · R α / ( 1 + R(G_d + αP) )^2
      </div>

      <p>
        The slope decreases with <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span> as the circuit approaches saturation, which is another way to see why the response becomes nonlinear at higher power.
      </p>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

      <h3>Re-interpreting the final formula</h3>
      <ul>
        <li><strong>Role of V:</strong> sets the maximum possible output (ceiling) <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V_p ≤ V</span>.</li>
        <li><strong>Role of R:</strong> controls the “gain” at low power and the onset of saturation. Larger <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R</span> makes <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">RG</span> reach 1 sooner → earlier nonlinearity.</li>
        <li><strong>Role of Gd:</strong> sets the baseline output at zero light; if large, the detector is never truly “off.”</li>
        <li><strong>Role of α:</strong> sets how quickly the conductance rises with power → steeper response initially.</li>
      </ul>

      <div class="grid2">
        <div class="callout">
          <h4>How parameters affect the curve (as you’ll see in the plots)</h4>
          <ul>
            <li>Increasing <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R</span> raises low-power sensitivity but compresses the linear range.</li>
            <li>Increasing <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">α</span> makes <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V_p</span> rise faster with <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span>, again reaching saturation earlier.</li>
            <li>Turning on nonzero <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G_d</span> shifts the curve upward at <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P=0</span>.</li>
          </ul>
        </div>
        <div class="callout ok">
          <h4>Alternative derivation idea (quick)</h4>
          <ul>
            <li>Write the divider using conductances directly by converting the series pair to an equivalent:
              <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">I = V / (R + 1/G)</span> and <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V_p = IR</span>.</li>
            <li>Or, view the detector as a current-controlled element: <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">I = G(P)·V_d</span> with <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V = V_p + V_d</span>, then solve two equations.</li>
          </ul>
        </div>
      </div>

      <h3>Concept check (self-test)</h3>
      <ul>
        <li><strong>Q:</strong> Why does <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V_p</span> saturate at <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V</span>? <strong>A:</strong> As <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G→∞</span>, the detector drop tends to zero, leaving essentially all the source voltage across <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R</span>.</li>
        <li><strong>Q:</strong> In the low-power limit, what sets the slope vs <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span>? <strong>A:</strong> Approximately <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">dV_p/dP ≈ V R α</span> if <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R(G_d+αP)≪1</span>.</li>
        <li><strong>Q:</strong> Does making <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R</span> very large always help? <strong>A:</strong> It boosts low-power sensitivity but shrinks the linear range and pushes you into saturation earlier.</li>
        <li><strong>Q:</strong> If <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G_d</span> is large, can you still measure small optical powers well? <strong>A:</strong> It’s harder because the baseline output is already significant; you’d likely use small-signal detection around a bias point.</li>
      </ul>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

      <div class="viz">
        <div class="controls" aria-label="Interactive controls">
          <div class="row">
            <label for="rSlider">Load resistor R (log scale)</label>
            <input id="rSlider" type="range" min="0" max="1000" value="650" />
            <div class="pill" id="rVal">R = 100 kΩ</div>
          </div>
          <div class="row">
            <label for="alphaSlider">Sensitivity α</label>
            <input id="alphaSlider" type="range" min="0" max="1000" value="500" />
            <div class="pill" id="alphaVal">α = 5.00e-6 S/mW</div>
          </div>
          <div class="row">
            <label for="gdSlider">Dark conductance Gd</label>
            <input id="gdSlider" type="range" min="0" max="1000" value="200" />
            <div class="pill" id="gdVal">Gd = 1.00e-6 S</div>
          </div>

          <div class="toggleRow">
            <label class="toggle"><input id="showLin" type="checkbox" checked /> Show low-power linear approximation</label>
            <label class="toggle"><input id="includeGd" type="checkbox" checked /> Include dark conductance Gd</label>
            <div class="hint">Example source voltage for plots: <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V = 5 V</span>. Power axis uses mW.</div>
          </div>
        </div>

        <div class="canvasCard">
          <div class="canvasTitle">
            <strong>Diagram: Photoconductive Detector + Load Resistor</strong>
            <span>series circuit, measure V<sub>p</sub> across R</span>
          </div>
          <canvas id="cDiagram" aria-label="Circuit diagram"></canvas>
        </div>

        <div class="canvasCard">
          <div class="canvasTitle">
            <strong>Main Plot: V<sub>p</sub>(P)</strong>
            <span>nonlinear saturation toward V</span>
          </div>
          <canvas id="cMain" aria-label="Main plot Vp vs P"></canvas>
        </div>

        <div class="canvasCard">
          <div class="canvasTitle">
            <strong>Secondary Plot: Local slope dV<sub>p</sub>/dP</strong>
            <span>shows shrinking sensitivity with increasing P</span>
          </div>
          <canvas id="cSecondary" aria-label="Secondary plot slope vs P"></canvas>
        </div>

        <div class="callout">
          <h4>What each canvas shows</h4>
          <ul>
            <li><strong>Diagram:</strong> The DC source <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V</span> drives a series path through the load <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R</span> and the detector (modeled as <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R<sub>d</sub>=1/G(P)</span>). The measured output is <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub></span> across <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R</span>.</li>
            <li><strong>Main plot:</strong> <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V<sub>p</sub></span> vs optical power <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span> using
              <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V_p = V·R(G_d+αP)/(1+R(G_d+αP))</span>.</li>
            <li><strong>Secondary plot:</strong> The slope
              <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">dV_p/dP = V·Rα/(1+R(G_d+αP))^2</span>,
              which decreases as the response saturates.</li>
          </ul>
        </div>

        <div class="callout ok">
          <h4>How to use the controls</h4>
          <ul>
            <li><strong>R slider:</strong> Increasing <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R</span> steepens the low-power part but makes saturation happen at smaller <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P</span>.</li>
            <li><strong>α slider:</strong> Increasing <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">α</span> increases how fast conductance grows with power → curve climbs earlier.</li>
            <li><strong>Gd toggle/slider:</strong> If you include <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">G_d</span>, the output at <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">P=0</span> is not necessarily zero.</li>
            <li><strong>Linear approximation checkbox:</strong> Shows <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">V_p ≈ V·R(G_d+αP)</span> (valid when <span class="eq" style="display:inline;padding:2px 6px;border-radius:10px">R(G_d+αP)≪1</span>) to highlight the linear regime.</li>
          </ul>
        </div>

      </div>
    </section>
  </article>
</main>

<footer>
  Built as a self-contained learning article: circuit model → symbolic dependence → linearity conditions → interactive visualization.
</footer>

<script>
(function(){
  // ----------------------------
  // Clipboard copy buttons
  // ----------------------------
  function flash(btn, text){
    const old = btn.textContent;
    btn.textContent = text;
    btn.style.transform = "translateY(-1px)";
    setTimeout(()=>{ btn.textContent = old; btn.style.transform = ""; }, 900);
  }
  document.querySelectorAll("button.copy").forEach(btn=>{
    btn.addEventListener("click", async ()=>{
      const payload = btn.getAttribute("data-copy") || "";
      try{
        await navigator.clipboard.writeText(payload);
        flash(btn, "Copied!");
      }catch(e){
        // fallback
        const ta = document.createElement("textarea");
        ta.value = payload;
        document.body.appendChild(ta);
        ta.select();
        try{ document.execCommand("copy"); flash(btn, "Copied!"); }
        catch(_){ flash(btn, "Copy failed"); }
        document.body.removeChild(ta);
      }
    });
  });

  // ----------------------------
  // Helpers: DPR canvas sizing
  // ----------------------------
  function fitCanvas(canvas, logicalHeight){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const cssW = Math.max(260, rect.width);
    const cssH = logicalHeight || rect.height || 320;
    canvas.style.height = cssH + "px";
    const pxW = Math.floor(cssW * dpr);
    const pxH = Math.floor(cssH * dpr);
    if(canvas.width !== pxW || canvas.height !== pxH){
      canvas.width = pxW;
      canvas.height = pxH;
    }
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return {ctx, w: cssW, h: cssH, dpr};
  }

  function lerp(a,b,t){ return a + (b-a)*t; }
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

  // ----------------------------
  // Plotting utilities
  // ----------------------------
  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
    const {x,y,w,h} = box;
    // background
    ctx.save();
    ctx.fillStyle = "rgba(6,8,17,0.45)";
    ctx.fillRect(x,y,w,h);

    // margins for ticks/labels
    const mL = 56, mR = 14, mT = 28, mB = 44;
    const px = x + mL, py = y + mT, pw = w - mL - mR, ph = h - mT - mB;

    // title
    ctx.fillStyle = "rgba(233,238,252,0.92)";
    ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(title, x + 12, y + 18);

    // grid + ticks
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;

    const nGrid = 6;
    function niceTicks(min, max, n){
      const span = max - min;
      if(span <= 0) return [min];
      const raw = span / n;
      const pow = Math.pow(10, Math.floor(Math.log10(raw)));
      const frac = raw / pow;
      let step;
      if(frac < 1.5) step = 1*pow;
      else if(frac < 3) step = 2*pow;
      else if(frac < 7) step = 5*pow;
      else step = 10*pow;
      const start = Math.ceil(min/step)*step;
      const ticks = [];
      for(let t=start; t<=max+1e-12; t+=step) ticks.push(t);
      return ticks;
    }

    const xTicks = niceTicks(xMin, xMax, nGrid);
    const yTicks = niceTicks(yMin, yMax, nGrid);

    // grid lines
    xTicks.forEach(t=>{
      const X = px + (t-xMin)/(xMax-xMin)*pw;
      ctx.beginPath();
      ctx.moveTo(X, py);
      ctx.lineTo(X, py+ph);
      ctx.stroke();
    });
    yTicks.forEach(t=>{
      const Y = py+ph - (t-yMin)/(yMax-yMin)*ph;
      ctx.beginPath();
      ctx.moveTo(px, Y);
      ctx.lineTo(px+pw, Y);
      ctx.stroke();
    });

    // axes
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(px, py+ph);
    ctx.lineTo(px+pw, py+ph);
    ctx.stroke();

    // tick labels
    ctx.fillStyle = "rgba(185,195,230,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    xTicks.forEach(t=>{
      const X = px + (t-xMin)/(xMax-xMin)*pw;
      ctx.fillText(formatTick(t), X, py+ph+8);
    });

    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    yTicks.forEach(t=>{
      const Y = py+ph - (t-yMin)/(yMax-yMin)*ph;
      ctx.fillText(formatTick(t), px-8, Y);
    });

    // axis labels
    ctx.save();
    ctx.fillStyle = "rgba(233,238,252,0.80)";
    ctx.font = "600 12.5px system-ui, -apple-system, Segoe UI, Roboto, Arial";

    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText(xLabel, px + pw/2, y + h - 22);

    ctx.translate(x + 16, py + ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    ctx.restore();
    return {plot:{x:px,y:py,w:pw,h:ph}, xMin,xMax,yMin,yMax};
  }

  function formatTick(v){
    const av = Math.abs(v);
    if(av === 0) return "0";
    if(av >= 1000 || av < 0.001) return v.toExponential(1).replace("+","").replace("e","e");
    if(av >= 10) return v.toFixed(0);
    if(av >= 1) return v.toFixed(1);
    return v.toFixed(3);
  }

  function toX(p, axes){ return axes.plot.x + (p-axes.xMin)/(axes.xMax-axes.xMin)*axes.plot.w; }
  function toY(v, axes){ return axes.plot.y + axes.plot.h - (v-axes.yMin)/(axes.yMax-axes.yMin)*axes.plot.h; }

  function drawLine(ctx, axes, xs, ys, strokeStyle, width){
    ctx.save();
    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = width || 2.2;
    ctx.beginPath();
    for(let i=0;i<xs.length;i++){
      const X = toX(xs[i], axes);
      const Y = toY(ys[i], axes);
      if(i===0) ctx.moveTo(X,Y);
      else ctx.lineTo(X,Y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawLegend(ctx, box, items){
    const {x,y,w} = box;
    ctx.save();
    const pad = 10;
    let lx = x + w - 10, ly = y + 10;
    ctx.textAlign = "right";
    ctx.textBaseline = "top";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    items.forEach((it, idx)=>{
      const yy = ly + idx*18;
      ctx.fillStyle = "rgba(233,238,252,0.88)";
      ctx.fillText(it.label, lx, yy);
      ctx.strokeStyle = it.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(lx - 110, yy + 8);
      ctx.lineTo(lx - 78, yy + 8);
      ctx.stroke();
    });
    ctx.restore();
  }

  // ----------------------------
  // Physics model
  // ----------------------------
  const Vsrc = 5.0; // example for plots (V)

  // map sliders to values
  function sliderToR(s){ // s in [0,1000], map to 1k..1M log
    const t = s/1000;
    const Rmin = 1e3, Rmax = 1e6;
    return Rmin * Math.pow(Rmax/Rmin, t);
  }
  function sliderToAlpha(s){ // map to 1e-7..2e-5 S/mW (log-ish but gentler)
    const t = s/1000;
    const amin = 1e-7, amax = 2e-5;
    return amin * Math.pow(amax/amin, t);
  }
  function sliderToGd(s){ // map to 1e-9..1e-4 S (log)
    const t = s/1000;
    const gmin = 1e-9, gmax = 1e-4;
    return gmin * Math.pow(gmax/gmin, t);
  }

  function GofP(PmW, alpha_S_per_mW, Gd_S, includeGd){
    return (includeGd ? Gd_S : 0) + alpha_S_per_mW * PmW;
  }
  function Vp(PmW, R, alpha, Gd, includeGd){
    const G = GofP(PmW, alpha, Gd, includeGd);
    const RG = R * G;
    return Vsrc * (RG) / (1 + RG);
  }
  function dVp_dP(PmW, R, alpha, Gd, includeGd){
    const G = GofP(PmW, alpha, Gd, includeGd);
    const denom = 1 + R*G;
    return Vsrc * R * alpha / (denom*denom); // V per mW
  }

  // Low-power linear approximation (first-order in RG): Vp ≈ V * R * G(P)
  function VpLinear(PmW, R, alpha, Gd, includeGd){
    const G = GofP(PmW, alpha, Gd, includeGd);
    return Vsrc * R * G;
  }

  // ----------------------------
  // Canvases
  // ----------------------------
  const cDiagram = document.getElementById("cDiagram");
  const cMain = document.getElementById("cMain");
  const cSecondary = document.getElementById("cSecondary");

  const rSlider = document.getElementById("rSlider");
  const alphaSlider = document.getElementById("alphaSlider");
  const gdSlider = document.getElementById("gdSlider");
  const showLin = document.getElementById("showLin");
  const includeGd = document.getElementById("includeGd");

  const rVal = document.getElementById("rVal");
  const alphaVal = document.getElementById("alphaVal");
  const gdVal = document.getElementById("gdVal");

  function formatOhms(R){
    if(R >= 1e6) return (R/1e6).toFixed(2) + " MΩ";
    if(R >= 1e3) return (R/1e3).toFixed(2) + " kΩ";
    return R.toFixed(0) + " Ω";
  }
  function formatSci(x, sig=3){
    if(x===0) return "0";
    const e = Math.floor(Math.log10(Math.abs(x)));
    const m = x / Math.pow(10,e);
    return m.toFixed(sig-1) + "e" + (e>=0?"+":"") + e;
  }

  // ----------------------------
  // Draw diagram
  // ----------------------------
  function drawDiagram(R, alpha, Gd, incGd){
    const {ctx,w,h} = fitCanvas(cDiagram, 320);
    ctx.clearRect(0,0,w,h);

    // layout in CSS pixels
    const margin = 18;
    const x0 = margin, y0 = margin, W = w - 2*margin, H = h - 2*margin;

    // soft frame
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 1;
    ctx.strokeRect(x0, y0, W, H);
    ctx.restore();

    // circuit baseline
    const cx = x0 + 40;
    const cy = y0 + H/2;

    // wires
    ctx.save();
    ctx.strokeStyle = "rgba(233,238,252,0.85)";
    ctx.lineWidth = 2;

    // left wire to source
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + 70, cy);
    ctx.stroke();

    // load resistor (zigzag)
    const rx1 = cx + 70, rx2 = rx1 + 140;
    const amp = 14;
    const nZ = 8;
    ctx.beginPath();
    ctx.moveTo(rx1, cy);
    for(let i=1;i<=nZ;i++){
      const t = i/nZ;
      const x = lerp(rx1, rx2, t);
      const y = cy + (i%2===0 ? -amp : amp);
      ctx.lineTo(x, y);
    }
    ctx.lineTo(rx2, cy);
    ctx.stroke();

    // wire to detector block
    const dx1 = rx2, dx2 = dx1 + 90;
    ctx.beginPath();
    ctx.moveTo(dx1, cy);
    ctx.lineTo(dx2, cy);
    ctx.stroke();

    // detector block
    const detW = 120, detH = 70;
    const detX = dx2, detY = cy - detH/2;
    ctx.fillStyle = "rgba(122,162,255,0.12)";
    ctx.strokeStyle = "rgba(122,162,255,0.50)";
    ctx.lineWidth = 2;
    ctx.fillRect(detX, detY, detW, detH);
    ctx.strokeRect(detX, detY, detW, detH);

    // wire to right and loop back
    const rightX = detX + detW + 70;
    ctx.strokeStyle = "rgba(233,238,252,0.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(detX + detW, cy);
    ctx.lineTo(rightX, cy);
    ctx.lineTo(rightX, cy + 90);
    ctx.lineTo(cx, cy + 90);
    ctx.lineTo(cx, cy);
    ctx.stroke();
    ctx.restore();

    // source symbol (battery) on left vertical segment
    const sx = cx, sy1 = cy + 25, sy2 = cy + 65;
    ctx.save();
    ctx.strokeStyle = "rgba(125,255,178,0.85)";
    ctx.lineWidth = 3;
    // long plate
    ctx.beginPath();
    ctx.moveTo(sx - 14, (sy1+sy2)/2 - 10);
    ctx.lineTo(sx + 14, (sy1+sy2)/2 - 10);
    ctx.stroke();
    // short plate
    ctx.beginPath();
    ctx.moveTo(sx - 9, (sy1+sy2)/2 + 10);
    ctx.lineTo(sx + 9, (sy1+sy2)/2 + 10);
    ctx.stroke();
    ctx.restore();

    // labels
    ctx.save();
    ctx.fillStyle = "rgba(233,238,252,0.92)";
    ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("DC source V", cx - 10, cy + 108);
    ctx.fillText("Load R", (rx1+rx2)/2 - 18, cy - 56);
    ctx.fillText("Photoconductor", detX + 10, detY - 10);

    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillStyle = "rgba(185,195,230,0.95)";
    ctx.fillText("R = " + formatOhms(R), (rx1+rx2)/2 - 40, cy - 36);
    ctx.fillText("G(P) = " + (incGd ? "Gd + αP" : "αP"), detX + 12, detY + 22);
    ctx.fillText("Rd = 1/G", detX + 12, detY + 44);
    ctx.restore();

    // Vp measurement bracket across load resistor
    ctx.save();
    ctx.strokeStyle = "rgba(255,211,122,0.90)";
    ctx.lineWidth = 2;
    const bx1 = rx1 + 8, bx2 = rx2 - 8, by = cy - 80;
    ctx.beginPath();
    ctx.moveTo(bx1, by);
    ctx.lineTo(bx1, cy - 10);
    ctx.moveTo(bx2, by);
    ctx.lineTo(bx2, cy - 10);
    ctx.moveTo(bx1, by);
    ctx.lineTo(bx2, by);
    ctx.stroke();
    ctx.fillStyle = "rgba(255,211,122,0.95)";
    ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Vₚ (measured)", bx1 + 10, by - 18);
    ctx.restore();

    // optical power arrow to detector
    ctx.save();
    ctx.strokeStyle = "rgba(255,122,168,0.85)";
    ctx.lineWidth = 2.4;
    const ax1 = detX + detW/2, ay1 = detY - 55;
    const ax2 = detX + detW/2, ay2 = detY + 8;
    ctx.beginPath();
    ctx.moveTo(ax1, ay1);
    ctx.lineTo(ax2, ay2);
    ctx.stroke();
    // arrow head
    ctx.beginPath();
    ctx.moveTo(ax2, ay2);
    ctx.lineTo(ax2 - 8, ay2 - 10);
    ctx.lineTo(ax2 + 8, ay2 - 10);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,122,168,0.85)";
    ctx.fill();
    ctx.fillStyle = "rgba(233,238,252,0.90)";
    ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Optical power P", ax1 - 54, ay1 - 12);
    ctx.restore();
  }

  // ----------------------------
  // Draw plots
  // ----------------------------
  function drawPlots(R, alpha, Gd, incGd, showLinear){
    // power range in mW for visualization
    const Pmax = 5.0;
    const N = 401;
    const Ps = new Array(N);
    const Vps = new Array(N);
    const Vlin = new Array(N);
    const slopes = new Array(N);

    let vMin = Infinity, vMax = -Infinity;
    let sMin = Infinity, sMax = -Infinity;

    for(let i=0;i<N;i++){
      const P = Pmax * i/(N-1);
      Ps[i] = P;
      const vp = Vp(P, R, alpha, Gd, incGd);
      Vps[i] = vp;
      const vL = VpLinear(P, R, alpha, Gd, incGd);
      Vlin[i] = vL;
      const s = dVp_dP(P, R, alpha, Gd, incGd);
      slopes[i] = s;

      vMin = Math.min(vMin, vp, showLinear ? vL : vp);
      vMax = Math.max(vMax, vp, showLinear ? vL : vp);
      sMin = Math.min(sMin, s);
      sMax = Math.max(sMax, s);
    }

    // Clamp plot ranges sensibly
    vMin = Math.min(0, vMin);
    vMax = Math.max(Vsrc, vMax);
    const vPad = 0.06*(vMax - vMin + 1e-9);
    vMin -= vPad; vMax += vPad;

    const sPad = 0.12*(sMax - sMin + 1e-12);
    sMin = Math.max(0, sMin - sPad);
    sMax += sPad;

    // Main plot
    const main = fitCanvas(cMain, 320);
    const ctxM = main.ctx;
    ctxM.clearRect(0,0,main.w,main.h);

    const axesM = drawAxes(ctxM, {x:0,y:0,w:main.w,h:main.h},
      0, Pmax, vMin, vMax,
      "Optical power P (mW)",
      "Load voltage Vₚ (V)",
      "Vₚ vs P (example V = 5 V)"
    );

    // curve colors (no external palette; use rgba)
    drawLine(ctxM, axesM, Ps, Vps, "rgba(122,162,255,0.95)", 2.6);
    if(showLinear){
      drawLine(ctxM, axesM, Ps, Vlin, "rgba(255,211,122,0.92)", 2.0);
    }

    drawLegend(ctxM, {x:0,y:0,w:main.w,h:main.h}, [
      {label:"Exact: Vₚ = V·RG/(1+RG)", color:"rgba(122,162,255,0.95)"},
      ...(showLinear ? [{label:"Low-RG approx: Vₚ ≈ V·R·G(P)", color:"rgba(255,211,122,0.92)"}] : [])
    ]);

    // annotate saturation
    ctxM.save();
    ctxM.strokeStyle = "rgba(125,255,178,0.35)";
    ctxM.lineWidth = 1.5;
    const ySat = toY(Vsrc, axesM);
    ctxM.setLineDash([6,6]);
    ctxM.beginPath();
    ctxM.moveTo(axesM.plot.x, ySat);
    ctxM.lineTo(axesM.plot.x + axesM.plot.w, ySat);
    ctxM.stroke();
    ctxM.setLineDash([]);
    ctxM.fillStyle = "rgba(125,255,178,0.85)";
    ctxM.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctxM.fillText("Ceiling: Vₚ → V", axesM.plot.x + 8, ySat - 18);
    ctxM.restore();

    // Secondary plot (slope)
    const sec = fitCanvas(cSecondary, 320);
    const ctxS = sec.ctx;
    ctxS.clearRect(0,0,sec.w,sec.h);

    const axesS = drawAxes(ctxS, {x:0,y:0,w:sec.w,h:sec.h},
      0, Pmax, sMin, sMax,
      "Optical power P (mW)",
      "Local slope dVₚ/dP (V/mW)",
      "Sensitivity vs P (slope decreases as saturation approaches)"
    );

    drawLine(ctxS, axesS, Ps, slopes, "rgba(125,255,178,0.95)", 2.6);

    // legend-like label
    drawLegend(ctxS, {x:0,y:0,w:sec.w,h:sec.h}, [
      {label:"dVₚ/dP = V·Rα / (1+R(Gd+αP))²", color:"rgba(125,255,178,0.95)"}
    ]);

    // Add a marker for "RG = 1" knee (approx)
    const G0 = GofP(0, alpha, Gd, incGd);
    // solve for P where R(Gd+αP)=1 => P = (1/R - Gd)/α
    let Pknee = (1/R - (incGd?Gd:0)) / alpha;
    if(!isFinite(Pknee)) Pknee = NaN;
    if(Pknee >= 0 && Pknee <= Pmax){
      ctxS.save();
      ctxS.strokeStyle = "rgba(255,122,168,0.55)";
      ctxS.lineWidth = 1.5;
      ctxS.setLineDash([5,6]);
      const Xk = toX(Pknee, axesS);
      ctxS.beginPath();
      ctxS.moveTo(Xk, axesS.plot.y);
      ctxS.lineTo(Xk, axesS.plot.y + axesS.plot.h);
      ctxS.stroke();
      ctxS.setLineDash([]);
      ctxS.fillStyle = "rgba(255,122,168,0.85)";
      ctxS.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctxS.fillText("RG=1 knee", Xk + 6, axesS.plot.y + 10);
      ctxS.restore();
    }
  }

  // ----------------------------
  // Update UI + redraw all
  // ----------------------------
  function update(){
    const R = sliderToR(+rSlider.value);
    const alpha = sliderToAlpha(+alphaSlider.value); // S/mW
    const Gd = sliderToGd(+gdSlider.value); // S
    const incGd = includeGd.checked;
    const lin = showLin.checked;

    rVal.textContent = "R = " + formatOhms(R);
    alphaVal.textContent = "α = " + formatSci(alpha, 3) + " S/mW";
    gdVal.textContent = "Gd = " + formatSci(Gd, 3) + " S";

    drawDiagram(R, alpha, Gd, incGd);
    drawPlots(R, alpha, Gd, incGd, lin);
  }

  // listeners
  [rSlider, alphaSlider, gdSlider, showLin, includeGd].forEach(el=>{
    el.addEventListener("input", update);
    el.addEventListener("change", update);
  });

  // Resize handling
  let resizeTimer = null;
  window.addEventListener("resize", ()=>{
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(update, 60);
  });

  // Initial draw
  update();
})();
</script>
</body>
</html>
