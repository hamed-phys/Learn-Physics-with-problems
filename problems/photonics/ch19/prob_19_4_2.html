<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gain of a Ge APD for k ≈ 1: Why G = 1/(1 − αe w)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --card:#111c3b;
      --text:#eaf0ff;
      --muted:#b7c3e6;
      --faint:rgba(234,240,255,.08);
      --faint2:rgba(234,240,255,.12);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#86efac;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 600px at 12% 10%, rgba(125,211,252,.16), transparent 60%),
        radial-gradient(900px 500px at 85% 15%, rgba(167,139,250,.14), transparent 60%),
        radial-gradient(800px 500px at 50% 100%, rgba(134,239,172,.08), transparent 55%),
        var(--bg);
      color:var(--text);
      line-height:1.55;
    }

    header{
      padding: clamp(22px, 3vw, 38px) 18px 14px;
      max-width:1200px;
      margin:0 auto;
    }
    .titlebar{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
      align-items:end;
    }
    h1{
      font-size:clamp(1.6rem, 2.6vw, 2.4rem);
      margin:0;
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      max-width: 80ch;
      margin:0;
    }

    .layout{
      max-width:1200px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      padding: 0 18px 44px;
      align-items:start;
    }

    nav{
      position:sticky;
      top:14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--faint2);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:14px 14px 10px;
      backdrop-filter: blur(10px);
    }
    nav .toc-title{
      font-weight:700;
      display:flex;
      align-items:center;
      gap:10px;
      margin:0 0 8px;
      letter-spacing:.2px;
    }
    nav .dot{
      width:10px;height:10px;border-radius:999px;
      background: radial-gradient(circle at 30% 30%, var(--accent), var(--accent2));
      box-shadow: 0 0 18px rgba(125,211,252,.35);
      flex:0 0 auto;
    }
    nav a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      color:var(--text);
      text-decoration:none;
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:.95rem;
    }
    nav a:hover{
      background: rgba(255,255,255,.05);
      border-color: rgba(125,211,252,.22);
      transform: translateY(-1px);
    }
    nav .small{
      color:var(--muted);
      font-size:.88rem;
      margin:10px 4px 0;
    }

    main{
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    section{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--faint2);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 18px 16px;
      backdrop-filter: blur(10px);
    }
    section h2{
      margin:0 0 10px;
      font-size:1.25rem;
      letter-spacing:.2px;
    }
    section h3{
      margin:16px 0 8px;
      font-size:1.05rem;
      color: #f1f5ff;
    }
    p{margin:10px 0}
    ul{margin:8px 0 10px 22px}
    li{margin:6px 0}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:14px;
    }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      margin-top:10px;
    }

    .callout{
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(234,240,255,.10);
      border-radius: 16px;
      padding:12px 12px 10px;
      overflow:hidden;
      position:relative;
    }
    .callout:before{
      content:"";
      position:absolute;
      inset:0 0 auto 0;
      height:3px;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      opacity:.9;
    }
    .callout h4{
      margin:0 0 6px;
      font-size:.98rem;
      letter-spacing:.2px;
    }
    .tag{
      display:inline-block;
      font-size:.78rem;
      color: var(--muted);
      border:1px solid rgba(234,240,255,.14);
      padding:2px 8px;
      border-radius:999px;
      margin-left:8px;
      vertical-align:middle;
    }

    .eqbox{
      margin:12px 0;
      border-radius:16px;
      border:1px solid rgba(125,211,252,.22);
      background: rgba(125,211,252,.07);
      padding:12px;
      overflow:auto;
      position:relative;
    }
    pre.equation{
      margin:0;
      font-family: var(--mono);
      font-size: .95rem;
      line-height: 1.45;
      white-space: pre-wrap;
    }
    .copyrow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      margin-top:10px;
    }
    .btn{
      border:1px solid rgba(234,240,255,.18);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:8px 10px;
      border-radius:12px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:.92rem;
      user-select:none;
    }
    .btn:hover{
      background: rgba(255,255,255,.10);
      border-color: rgba(125,211,252,.35);
      transform: translateY(-1px);
    }
    .btn:active{transform: translateY(0)}
    .hint{
      color: var(--muted);
      font-size:.92rem;
      margin: 6px 0 0;
    }
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(234,240,255,.16);
      background: rgba(0,0,0,.12);
      color: var(--muted);
      font-size:.9rem;
    }

    figure{
      margin: 0;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    canvas{
      width:100%;
      height:320px;
      border-radius:16px;
      border:1px solid rgba(234,240,255,.14);
      background: rgba(0,0,0,.15);
    }
    .canvasTall{ height:360px; }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    .control{
      background: rgba(0,0,0,.18);
      border:1px solid rgba(234,240,255,.10);
      border-radius:16px;
      padding:10px 12px 10px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:12px;
      font-size:.92rem;
      color: var(--muted);
      margin-bottom:8px;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .readout{
      font-family: var(--mono);
      color: var(--text);
      font-size:.92rem;
    }

    .final{
      border:1px solid rgba(134,239,172,.28);
      background: rgba(134,239,172,.08);
    }
    .final:before{
      background: linear-gradient(90deg, var(--good), var(--accent));
    }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding: 0 18px 34px;
      color: var(--muted);
      font-size:.92rem;
    }

    .toast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.65);
      border: 1px solid rgba(234,240,255,.18);
      color: var(--text);
      padding:10px 12px;
      border-radius: 14px;
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      backdrop-filter: blur(10px);
      max-width:min(680px, calc(100vw - 24px));
      text-align:center;
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-2px);
    }

    @media (max-width: 980px){
      .layout{grid-template-columns: 1fr}
      nav{position:relative; top:auto}
      canvas{height:300px}
      .grid2, .callouts, .controls{grid-template-columns:1fr}
    }

    @media print{
      body{background:#fff;color:#111}
      nav{display:none}
      section{box-shadow:none; border:1px solid #ddd; background:#fff}
      canvas{border:1px solid #ddd; background:#fff}
      .btn{display:none}
      .toast{display:none}
    }

    /* subtle motion */
    @media (prefers-reduced-motion: no-preference){
      section{animation: fadeIn .35s ease both}
      @keyframes fadeIn{from{opacity:0; transform: translateY(6px)} to{opacity:1; transform: translateY(0)}}
    }
  </style>
</head>

<body>
<header>
  <div class="titlebar">
    <h1>Gain of a Ge Avalanche Photodiode (APD) for <span style="color:var(--accent)">k ≈ 1</span></h1>
    <p class="subtitle">
      We prove that when electron and hole ionization are nearly equal (as in Ge with <b>k = α<sub>h</sub>/α<sub>e</sub> ≈ 1</b>),
      the electron-injected mean multiplication becomes
      <span class="pill"><b>G = 1/(1 − α<sub>e</sub> w)</b></span>,
      and we explain why the standard closed-form gain expression must be handled with care at <b>k = 1</b>.
    </p>
  </div>
</header>

<div class="layout">
  <nav aria-label="Table of contents">
    <div class="toc-title"><span class="dot"></span>Table of Contents</div>
    <a href="#quick">Quick Summary</a>
    <a href="#primer">PART 0 — Concept Primer</a>
    <a href="#analysis">PART 1 — Problem Analysis</a>
    <a href="#strategy">PART 2 — Strategy & Tips</a>
    <a href="#solution">PART 3 — Full Solution</a>
    <a href="#deeper">PART 4 — Deeper Understanding</a>
    <a href="#vizguide">PART 5 — Visualization Guide</a>
    <p class="small">Interactive plots live-update with the controls.</p>
  </nav>

  <main>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>Problem:</b> For a conventional APD with ionization ratio <b>k ≈ 1</b> (e.g., Ge), show the gain is <b>G = 1/(1 − α<sub>e</sub> w)</b>.</li>
        <li><b>Key physics:</b> Avalanche multiplication is a <i>branching process</i>; carriers can create new electron–hole pairs as they drift through the multiplication layer.</li>
        <li><b>Core parameters:</b> Electron ionization coefficient <b>α<sub>e</sub></b> [1/m], hole ionization coefficient <b>α<sub>h</sub></b> [1/m], region width <b>w</b> [m], ratio <b>k = α<sub>h</sub>/α<sub>e</sub></b> [dimensionless].</li>
        <li><b>Governing model:</b> Mean multiplication factors satisfy coupled first-order ODEs derived from “in dx you either ionize or you don’t”.</li>
        <li><b>Standard closed form (uniform field):</b>
          <span class="pill">G(k≠1) = (1 − k) / (exp[−(1−k) α<sub>e</sub> w] − k)</span>.</li>
        <li><b>Why special care at k=1:</b> The above becomes <b>0/0</b>; you must take a limit or solve the k=1 ODE directly.</li>
        <li><b>Final result (symbolic):</b> For <b>k → 1</b>, <b>G → 1/(1 − α<sub>e</sub> w)</b> (valid below breakdown, i.e., α<sub>e</sub>w &lt; 1).</li>
      </ul>
    </section>

    <section id="primer">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="grid2">
        <div>
          <h3>Core definitions (symbols &amp; units)</h3>
          <ul>
            <li><b>α<sub>e</sub></b> — electron impact-ionization coefficient <span class="tag">[m<sup>−1</sup>]</span>: probability per unit length that a drifting electron triggers ionization.</li>
            <li><b>α<sub>h</sub></b> — hole impact-ionization coefficient <span class="tag">[m<sup>−1</sup>]</span>: probability per unit length that a drifting hole triggers ionization.</li>
            <li><b>k = α<sub>h</sub>/α<sub>e</sub></b> <span class="tag">dimensionless</span>: ionization ratio. <b>k≈0</b> means mostly electrons multiply; <b>k≈1</b> means both multiply similarly.</li>
            <li><b>w</b> — multiplication layer width <span class="tag">[m]</span>.</li>
            <li><b>G (or M)</b> — mean avalanche gain <span class="tag">dimensionless</span>: average multiplication of the injected carrier (here: <i>electron injection</i>).</li>
          </ul>
        </div>

        <div>
          <h3>Physical meaning (what these represent)</h3>
          <ul>
            <li><b>α</b> values encode how “violent” the field is: larger α → more frequent ionization events → higher gain.</li>
            <li><b>k</b> controls <i>feedback</i>: if holes ionize too, they create additional electrons which can ionize again, strengthening the cascade.</li>
            <li><b>α<sub>e</sub> w</b> is a key dimensionless “avalanche thickness”: it compares the region length to the electron mean free path for ionization.</li>
          </ul>

          <div class="callout">
            <h4>When is this model valid?<span class="tag">assumptions</span></h4>
            <ul>
              <li>Uniform electric field → <b>constant α<sub>e</sub>, α<sub>h</sub></b> across 0…w.</li>
              <li>Steady-state, 1D drift, negligible diffusion.</li>
              <li>Local ionization (no “dead space” corrections).</li>
              <li>We compute <b>mean gain</b>, not noise (excess noise requires more statistics).</li>
            </ul>
          </div>
        </div>
      </div>

      <h3>Common models/approximations (and why)</h3>
      <ul>
        <li><b>Local (McIntyre) model:</b> treat ionization as a memoryless Poisson process with rate α per unit length. This yields closed-form mean gain in uniform fields.</li>
        <li><b>Single-carrier multiplication (k≈0):</b> simplifies to exponential growth. Useful for Si APDs (often k≪1), but <b>not</b> for Ge where k≈1.</li>
        <li><b>k≈1 special case:</b> symmetry between electron/hole multiplication changes the functional form: the gain becomes <b>rational</b> instead of exponential.</li>
      </ul>

      <h3>Mini intuition examples (no heavy algebra)</h3>
      <ul>
        <li><b>If α<sub>e</sub>w is small</b> (thin/weak multiplication): few ionizations → gain ≈ 1.</li>
        <li><b>If α<sub>e</sub>w approaches a threshold</b>: feedback can make the mean gain rise sharply; the model predicts divergence at breakdown.</li>
      </ul>

      <div class="callouts">
        <div class="callout">
          <h4>What to watch for<span class="tag">pitfalls</span></h4>
          <ul>
            <li>Using the k≠1 closed form at <b>k=1</b> gives <b>0/0</b> (indeterminate), not a usable number.</li>
            <li>For <b>k=1</b>, gain is <b>not exponential</b>; it becomes <b>1/(1−αw)</b>.</li>
            <li>Breakdown condition differs by k; for k=1, the mean gain diverges at <b>α<sub>e</sub>w = 1</b> in this model.</li>
          </ul>
        </div>
        <div class="callout">
          <h4>Key idea<span class="tag">branching process</span></h4>
          <p style="margin:0">
            In a tiny slice <span style="font-family:var(--mono)">dx</span>, a carrier either ionizes (creating one extra e–h pair)
            or it doesn’t. Taking expectations turns this into coupled differential equations for the <i>mean</i> multiplication.
          </p>
        </div>
      </div>
    </section>

    <section id="analysis">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Problem restatement (in plain words)</h3>
      <p>
        Consider a conventional avalanche photodiode whose multiplication layer has width <b>w</b> and (approximately) equal
        electron and hole ionization behavior, so the ionization ratio <b>k = α<sub>h</sub>/α<sub>e</sub> ≈ 1</b>.
        Show that the mean gain for electron injection is
        <b>G = 1/(1 − α<sub>e</sub>w)</b>.
        Also explain why the commonly quoted uniform-field gain formula
        (valid for <b>k≠1</b>) cannot be used directly at <b>k=1</b>.
      </p>

      <div class="grid2">
        <div>
          <h3>Given</h3>
          <ul>
            <li>Uniform multiplication region: width <b>w</b>.</li>
            <li>Electron ionization coefficient <b>α<sub>e</sub></b> (constant).</li>
            <li>Hole ionization coefficient <b>α<sub>h</sub></b> (constant).</li>
            <li>Ionization ratio <b>k = α<sub>h</sub>/α<sub>e</sub> ≈ 1</b> (Ge-like).</li>
          </ul>
        </div>
        <div>
          <h3>Unknowns / what to prove</h3>
          <ul>
            <li>Derive <b>G(k→1) = 1/(1 − α<sub>e</sub>w)</b>.</li>
            <li>Show the k≠1 expression becomes indeterminate at k=1 and must be limiting-cased.</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li><b>Impact ionization as a Poisson process</b> with rate α per unit distance → valid under the local, uniform-field model.</li>
        <li><b>Linearity of expectation</b> → lets us write recursion/ODEs for mean gain without tracking full probability distributions.</li>
        <li><b>Boundary conditions</b> set by the fact that carriers exiting the multiplication region can no longer ionize.</li>
      </ul>

      <div class="callouts">
        <div class="callout">
          <h4>Assumptions used<span class="tag">explicit</span></h4>
          <ul>
            <li>1D drift through a region <span style="font-family:var(--mono)">x ∈ [0, w]</span>.</li>
            <li>Electron injected at <span style="font-family:var(--mono)">x = 0</span>, collected at <span style="font-family:var(--mono)">x = w</span>.</li>
            <li>Constant <b>α<sub>e</sub>, α<sub>h</sub></b>, no dead space, no field variation.</li>
            <li>We compute <b>mean</b> multiplication (not noise).</li>
          </ul>
        </div>
        <div class="callout">
          <h4>Why other approaches are unnecessary here<span class="tag">scope</span></h4>
          <ul>
            <li>Full stochastic simulations (Monte Carlo) are overkill for <i>mean</i> gain in uniform fields.</li>
            <li>Device-level drift–diffusion with field solving is not needed because α’s are taken constant.</li>
          </ul>
        </div>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ul>
        <li><b>(A) Use the known k≠1 closed form and take the limit k→1</b>:
          fast, clean, but you must do the limit carefully because it’s 0/0.</li>
        <li><b>(B) Re-derive mean-gain ODEs and solve directly for k=1</b>:
          more instructive and avoids indeterminate forms.</li>
        <li><b>(C) Series expansion / L’Hôpital’s rule on the closed form</b>:
          essentially (A), but focuses on calculus rather than physics.</li>
      </ul>
      <p><b>Best choice:</b> We’ll do <b>(B)</b> to teach the physics, then confirm by taking the <b>k→1</b> limit of the standard formula (A).</p>
    </section>

    <section id="strategy">
      <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>

      <ol>
        <li><b>Define the two mean multiplication functions</b>:
          <span style="font-family:var(--mono)">M_e(x)</span> for an electron starting at position x, and
          <span style="font-family:var(--mono)">M_h(x)</span> for a hole starting at position x.
          <div class="hint">Physically: these are expected numbers of collected electrons at the cathode due to that single carrier’s future history.</div>
        </li>
        <li><b>Write a small-slice recursion in dx</b> using ionization probabilities
          <span style="font-family:var(--mono)">α_e dx</span> and <span style="font-family:var(--mono)">α_h dx</span>.
          <div class="hint">Tool: expectation over “ionize” vs “no ionize”.</div>
        </li>
        <li><b>Convert the recursion to coupled ODEs</b> by subtracting and dividing by dx, then taking dx→0.
          <div class="hint">Result: first-order linear system in M_e and M_h.</div>
        </li>
        <li><b>Apply boundary conditions</b>:
          at <span style="font-family:var(--mono)">x=w</span>, an electron is already collected (gain 1),
          and at <span style="font-family:var(--mono)">x=0</span>, a hole immediately exits to the anode (contributes 0 electrons to the cathode).
        </li>
        <li><b>Solve for the sum S(x)=M_e(x)+M_h(x)</b> (it decouples nicely), then integrate to get M_e(0)=G.</li>
        <li><b>Specialize to k=1</b> (α_h=α_e) where the system changes character: S becomes constant, leading to a rational gain.</li>
        <li><b>Sanity checks</b>: units, limits (αw→0), and breakdown behavior (denominator → 0).</li>
        <li><b>Confirm</b> by taking the limit k→1 of the standard k≠1 formula (series expansion).</li>
      </ol>

      <div class="callouts">
        <div class="callout">
          <h4>Common mistakes<span class="tag">quick fixes</span></h4>
          <ul>
            <li>Wrong boundary for the hole: for <b>electron-injection gain</b>, a hole reaching x=0 contributes <b>0</b> electrons to the cathode.</li>
            <li>Plugging k=1 into the k≠1 formula directly (0/0). Always take a limit or solve separately.</li>
            <li>Letting α<sub>e</sub>w exceed the breakdown threshold in plots without noting the model predicts divergence.</li>
          </ul>
        </div>
        <div class="callout">
          <h4>Tip<span class="tag">keep it clean</span></h4>
          <p style="margin:0">
            Work with the dimensionless variable <b>A = α<sub>e</sub>w</b>. It’s the natural control knob in uniform-field APD gain.
          </p>
        </div>
      </div>
    </section>

    <section id="solution">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Physical intuition first (what should happen?)</h3>
      <p>
        An injected electron drifts across the multiplication region. Each time it ionizes, it creates an extra electron (which continues drifting)
        and a hole (which drifts the other way). If holes also ionize (k near 1), they can create additional electrons,
        reinforcing the cascade. When electron and hole ionization are equally likely (<b>k=1</b>), the feedback is “symmetric” and
        the mean gain grows more strongly than a simple one-sided exponential—eventually diverging at a finite threshold.
      </p>

      <h3>Step 1 — Define mean multiplication functions</h3>
      <p>
        Let <b>x</b> be the position inside the multiplication region, with <b>x=0</b> at the injection side and <b>x=w</b> at the collection side for electrons.
      </p>

      <div class="eqbox">
        <pre class="equation" id="eq-def">
M_e(x) = mean number of electrons collected at x = w
         produced by a single electron that starts at position x.

M_h(x) = mean number of electrons collected at x = w
         produced by a single hole that starts at position x.</pre>
        <div class="copyrow">
          <button class="btn" data-copy="#eq-def">Copy definitions</button>
          <span class="pill">Units: M_e, M_h are dimensionless</span>
        </div>
      </div>

      <h3>Step 2 — Write the small-slice recursion (electron)</h3>
      <p>
        In a short distance <span style="font-family:var(--mono)">dx</span>, an electron ionizes with probability <span style="font-family:var(--mono)">α_e dx</span>.
        If it does not ionize, it simply moves to <span style="font-family:var(--mono)">x+dx</span>.
        If it does ionize, it creates <b>one extra electron</b> (so there are now two electrons continuing) and <b>one hole</b> starting at x.
      </p>

      <div class="eqbox">
        <pre class="equation" id="eq-rec-e">
M_e(x) =
  (1 − α_e dx) · M_e(x+dx)
+ (α_e dx) · [ 2·M_e(x+dx) + M_h(x) ]</pre>
        <div class="copyrow">
          <button class="btn" data-copy="#eq-rec-e">Copy electron recursion</button>
        </div>
        <p class="hint">
          Explanation: in the ionization case you have two forward-going electrons (each contributes M_e from x+dx) plus one hole (contributes M_h from x).
        </p>
      </div>

      <h3>Step 3 — Convert to a differential equation (electron)</h3>
      <p>
        Expand and keep only first order in dx:
      </p>
      <div class="eqbox">
        <pre class="equation" id="eq-ode-e">
M_e(x) = M_e(x+dx) + α_e dx [ M_e(x+dx) + M_h(x) ].

Rearrange:
(M_e(x+dx) − M_e(x))/dx = −α_e [ M_e(x+dx) + M_h(x) ].

Take dx → 0:
dM_e/dx = −α_e [ M_e(x) + M_h(x) ].</pre>
        <div class="copyrow">
          <button class="btn" data-copy="#eq-ode-e">Copy electron ODE</button>
        </div>
      </div>

      <h3>Step 4 — Do the same for holes</h3>
      <p>
        A hole moves toward decreasing x. In a distance dx, it ionizes with probability <span style="font-family:var(--mono)">α_h dx</span>,
        creating an extra hole (so two holes continue) and one electron starting at x.
      </p>

      <div class="eqbox">
        <pre class="equation" id="eq-ode-h">
By the same expectation-in-dx logic:
dM_h/dx = +α_h [ M_e(x) + M_h(x) ].</pre>
        <div class="copyrow">
          <button class="btn" data-copy="#eq-ode-h">Copy hole ODE</button>
        </div>
        <p class="hint">Sign differs because the hole’s “forward” direction is toward smaller x; the differential form above is in x.</p>
      </div>

      <h3>Step 5 — Boundary conditions (electron injection)</h3>
      <div class="callouts">
        <div class="callout">
          <h4>Electron boundary at x = w</h4>
          <p style="margin:0">
            An electron that is already at the collection edge is collected without further multiplication:
            <span style="font-family:var(--mono)"><b>M_e(w) = 1</b></span>.
          </p>
        </div>
        <div class="callout">
          <h4>Hole boundary at x = 0</h4>
          <p style="margin:0">
            A hole arriving at x=0 exits to the anode; for <b>electron-injection gain</b> (electrons collected at x=w),
            it produces no additional collected electrons:
            <span style="font-family:var(--mono)"><b>M_h(0) = 0</b></span>.
          </p>
        </div>
      </div>

      <h3>Step 6 — Solve using the sum S(x) = M_e(x) + M_h(x)</h3>
      <p>
        Add the two ODEs:
      </p>

      <div class="eqbox">
        <pre class="equation" id="eq-sum">
Let S(x) = M_e(x) + M_h(x).

Then:
dS/dx = dM_e/dx + dM_h/dx
      = (−α_e + α_h) S(x)
      = (α_h − α_e) S(x).</pre>
        <div class="copyrow">
          <button class="btn" data-copy="#eq-sum">Copy sum equation</button>
        </div>
      </div>

      <p>
        This is a simple exponential:
      </p>

      <div class="eqbox">
        <pre class="equation" id="eq-Ssol">
S(x) = S(0) · exp[(α_h − α_e) x].</pre>
        <div class="copyrow">
          <button class="btn" data-copy="#eq-Ssol">Copy S(x)</button>
        </div>
      </div>

      <h3>Step 7 — Obtain the standard uniform-field gain (k ≠ 1)</h3>
      <p>
        Use <span style="font-family:var(--mono)">dM_e/dx = −α_e S(x)</span> and integrate from x=0 to x=w with <span style="font-family:var(--mono)">M_e(w)=1</span>:
      </p>

      <div class="eqbox">
        <pre class="equation" id="eq-int">
M_e(w) − M_e(0) = ∫_0^w dM_e/dx dx = −α_e ∫_0^w S(x) dx

1 − M_e(0) = −α_e S(0) ∫_0^w exp[(α_h − α_e) x] dx.</pre>
        <div class="copyrow">
          <button class="btn" data-copy="#eq-int">Copy integration step</button>
        </div>
      </div>

      <p>
        Evaluate the integral for <b>α_h ≠ α_e</b>:
      </p>

      <div class="eqbox">
        <pre class="equation" id="eq-int2">
∫_0^w exp[(α_h − α_e) x] dx = (exp[(α_h − α_e)w] − 1)/(α_h − α_e).

So:
1 − M_e(0) = −α_e S(0) (exp[(α_h − α_e)w] − 1)/(α_h − α_e).</pre>
        <div class="copyrow">
          <button class="btn" data-copy="#eq-int2">Copy evaluated integral</button>
        </div>
      </div>

      <p>
        Now use <span style="font-family:var(--mono)">S(0)=M_e(0)+M_h(0)=M_e(0)</span> because <span style="font-family:var(--mono)">M_h(0)=0</span>.
        Let the gain for electron injection be <b>G = M_e(0)</b>. Also define <b>k = α_h/α_e</b>.
      </p>

      <div class="eqbox">
        <pre class="equation" id="eq-kneq1">
With G = S(0):

1 − G = −α_e G (exp[(α_h − α_e)w] − 1)/(α_h − α_e)

Rearrange:
G = (α_h − α_e) / (α_h − α_e·exp[(α_h − α_e)w]).

Using α_h = k α_e:
G = (k − 1) / (k − exp[(k − 1) α_e w])
  = (1 − k) / (exp[−(1 − k) α_e w] − k).   (k ≠ 1)</pre>
        <div class="copyrow">
          <button class="btn" data-copy="#eq-kneq1">Copy k≠1 gain</button>
        </div>
      </div>

      <p class="hint">
        This is the familiar uniform-field mean gain expression. Notice that if you set <b>k=1</b> directly, numerator and denominator both go to 0.
      </p>

      <h3>Step 8 — The k = 1 case (Ge-like): solve or take the limit</h3>

      <div class="callout">
        <h4>Why equation above “cannot be used” at k=1<span class="tag">indeterminate</span></h4>
        <p style="margin:0">
          At <b>k=1</b>, the expression
          <span style="font-family:var(--mono)">(1−k)/(exp[−(1−k)α_e w] − k)</span>
          becomes <b>0/0</b>, which is not a value. The correct gain is obtained by either:
          (i) solving the ODEs with α_h=α_e directly, or (ii) taking the limit k→1.
        </p>
      </div>

      <h3>Direct solution when k=1 (α_h = α_e)</h3>
      <p>
        Set <b>α_h = α_e</b>. Then from <span style="font-family:var(--mono)">dS/dx = (α_h−α_e)S</span> we get:
      </p>

      <div class="eqbox">
        <pre class="equation" id="eq-k1S">
If α_h = α_e, then dS/dx = 0  ⇒  S(x) = constant = S(0) = G.</pre>
        <div class="copyrow">
          <button class="btn" data-copy="#eq-k1S">Copy k=1 sum result</button>
        </div>
      </div>

      <p>
        Plug into the electron ODE:
      </p>

      <div class="eqbox">
        <pre class="equation" id="eq-k1ODE">
dM_e/dx = −α_e S(x) = −α_e G   (constant in x).</pre>
        <div class="copyrow">
          <button class="btn" data-copy="#eq-k1ODE">Copy k=1 electron ODE</button>
        </div>
      </div>

      <p>
        Integrate from 0 to w:
      </p>

      <div class="eqbox">
        <pre class="equation" id="eq-k1int">
M_e(w) − M_e(0) = ∫_0^w (−α_e G) dx = −α_e G w.

But M_e(w)=1 and M_e(0)=G, so:
1 − G = −α_e G w
1 = G (1 − α_e w)
⇒  G = 1/(1 − α_e w).</pre>
        <div class="copyrow">
          <button class="btn" data-copy="#eq-k1int">Copy k=1 derivation</button>
        </div>
      </div>

      <div class="eqbox final" aria-label="Final answer box">
        <pre class="equation" id="eq-final">
FINAL RESULT (Ge-like APD, k ≈ 1):

G = 1 / (1 − α_e w)    (valid for α_e w < 1 in the local uniform-field mean-gain model).</pre>
        <div class="copyrow">
          <button class="btn" data-copy="#eq-final">Copy final answer</button>
          <span class="pill">Breakdown (mean divergence) at α<sub>e</sub>w → 1</span>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><b>Units:</b> α<sub>e</sub>w is dimensionless, so G is dimensionless ✔</li>
        <li><b>Weak multiplication:</b> if α<sub>e</sub>w → 0, then G → 1 ✔ (no avalanche)</li>
        <li><b>Approach to breakdown:</b> if α<sub>e</sub>w → 1<sup>−</sup>, then G → ∞ ✔ (model predicts divergence)</li>
      </ul>

      <h3>Connection to the diagram and plots</h3>
      <p>
        In the diagram, ionization events inside the region create additional carriers. For <b>k≈1</b>,
        holes contribute substantially to producing more electrons, boosting feedback. The main plot shows how the gain grows with
        the dimensionless thickness <b>A = α<sub>e</sub>w</b> and how the <b>k→1</b> curve becomes the rational form
        <b>1/(1−A)</b>.
      </p>
    </section>

    <section id="deeper">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the final formula</h3>
      <p>
        The <b>k≈1</b> gain
        <span class="pill"><b>G = 1/(1 − α<sub>e</sub>w)</b></span>
        has a clear control knob: <b>α<sub>e</sub>w</b>.
      </p>
      <ul>
        <li><b>α<sub>e</sub></b> increases with electric field → stronger avalanche per unit length.</li>
        <li><b>w</b> increases interaction distance → more opportunities to ionize.</li>
        <li><b>Denominator (1−α<sub>e</sub>w)</b> reflects feedback: each generated carrier can generate others, producing a geometric-series-like mean.</li>
      </ul>

      <h3>How parameters affect outcome (tie to interactive plots)</h3>
      <ul>
        <li>Increasing <b>A = α<sub>e</sub>w</b> raises gain; near <b>A≈1</b> the k≈1 curve shoots up sharply.</li>
        <li>Changing <b>k</b> changes feedback strength:
          <b>k→0</b> approaches “electron-only” multiplication (more exponential-like),
          while <b>k→1</b> approaches the rational form and a different breakdown threshold in this model.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        Starting from the k≠1 closed form
        <span style="font-family:var(--mono)">G(k) = (1−k)/(exp[−(1−k)α_e w] − k)</span>,
        you can set <span style="font-family:var(--mono)">δ = 1−k</span> and series-expand
        <span style="font-family:var(--mono)">exp(−δ α_e w) ≈ 1 − δ α_e w</span>.
        The leading δ cancels, yielding <span style="font-family:var(--mono)">G → 1/(1−α_e w)</span>.
        This is exactly the limit that is “hidden” by the 0/0 form at k=1.
      </p>

      <h3>Concept checks (with answers)</h3>
      <ul>
        <li><b>Q:</b> Why isn’t the gain exponential when k=1? <b>A:</b> Because the coupled feedback makes the sum S(x) constant, turning the ODE into linear-in-x for M_e, producing a rational result after applying boundary conditions.</li>
        <li><b>Q:</b> What dimensionless quantity controls the growth most directly in uniform fields? <b>A:</b> <b>α<sub>e</sub>w</b>.</li>
        <li><b>Q:</b> Why does the mean gain diverge at α<sub>e</sub>w=1 for k=1? <b>A:</b> The boundary relation becomes <span style="font-family:var(--mono)">1 = G(1−α_e w)</span>; the denominator hits zero.</li>
        <li><b>Q:</b> What does “cannot be used” mean for the k≠1 formula at k=1? <b>A:</b> It becomes indeterminate (0/0), so you must take the limit or re-solve the equations at k=1.</li>
      </ul>
    </section>

    <section id="vizguide">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="grid2">
        <figure>
          <canvas id="diagram" class="canvasTall" aria-label="APD diagram canvas"></canvas>
          <figcaption class="hint">
            <b>Diagram:</b> 1D multiplication region (0 to w). An injected electron drifts to the right; holes drift left.
            Ionization events create extra e–h pairs that feed the avalanche.
          </figcaption>
        </figure>

        <figure>
          <canvas id="plotMain" class="canvasTall" aria-label="Main plot canvas"></canvas>
          <figcaption class="hint">
            <b>Main plot:</b> Gain <span style="font-family:var(--mono)">G</span> vs <span style="font-family:var(--mono)">A = α_e w</span>.
            Shows the general k≠1 formula and the special k=1 limit curve <span style="font-family:var(--mono)">G=1/(1−A)</span>.
          </figcaption>
        </figure>
      </div>

      <figure style="margin-top:14px">
        <canvas id="plotSecondary" aria-label="Secondary plot canvas"></canvas>
        <figcaption class="hint">
          <b>Secondary plot:</b> Gain <span style="font-family:var(--mono)">G</span> vs ionization ratio <span style="font-family:var(--mono)">k</span> at a fixed <span style="font-family:var(--mono)">A</span>
          (chosen by the A slider). The vertical marker shows the current k setting.
        </figcaption>
      </figure>

      <div class="controls" aria-label="Interactive controls">
        <div class="control">
          <label for="kSlider">
            <span>Ionization ratio <b>k = α<sub>h</sub>/α<sub>e</sub></b> (dimensionless)</span>
            <span class="readout" id="kReadout"></span>
          </label>
          <input id="kSlider" type="range" min="0" max="2" step="0.01" value="1.00" />
          <p class="hint">Try k near 1 to see the special-case behavior emerge.</p>
        </div>

        <div class="control">
          <label for="aSlider">
            <span>Dimensionless thickness <b>A = α<sub>e</sub>w</b> (dimensionless)</span>
            <span class="readout" id="aReadout"></span>
          </label>
          <input id="aSlider" type="range" min="0.00" max="0.95" step="0.005" value="0.50" />
          <p class="hint">Keep A &lt; 1 to stay below the k=1 mean-breakdown point in this model.</p>
        </div>
      </div>

      <div class="eqbox" style="margin-top:14px">
        <pre class="equation" id="eq-plotted">
Plotted formulas (uniform field, electron injection):

If k ≠ 1:
G(A,k) = (1 − k) / ( exp( −(1 − k) A ) − k ),   where A = α_e w.

If k = 1:
G(A,1) = 1 / (1 − A).</pre>
        <div class="copyrow">
          <button class="btn" data-copy="#eq-plotted">Copy plotted formulas</button>
        </div>
      </div>
    </section>
  </main>
</div>

<footer>
  <p>
    Notes: This article uses the local, uniform-field mean-gain model (often associated with McIntyre-type APD theory).
    Real devices can deviate due to nonuniform fields, dead-space effects, and carrier heating; those primarily modify the
    quantitative gain near breakdown, while the <b>k→1 limiting logic</b> (indeterminate form → take the limit / solve separately) remains essential.
  </p>
</footer>

<div class="toast" id="toast" role="status" aria-live="polite"></div>

<script>
/* ========= Utility: crisp canvas ========= */
function setupCanvas(canvas){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(2, Math.floor(rect.width * dpr));
  const h = Math.max(2, Math.floor(rect.height * dpr));
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h;
  }
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  return {ctx, wCSS: rect.width, hCSS: rect.height, dpr};
}

function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

function niceTicks(min, max, target=6){
  const span = max - min;
  if(span <= 0) return {step:1, start:min, end:max};
  const raw = span / target;
  const pow = Math.pow(10, Math.floor(Math.log10(raw)));
  const choices = [1,2,5,10].map(c=>c*pow);
  let step = choices[0];
  for(const c of choices){ if(Math.abs(c-raw) < Math.abs(step-raw)) step = c; }
  const start = Math.floor(min/step)*step;
  const end = Math.ceil(max/step)*step;
  return {step, start, end};
}

function showToast(msg){
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  clearTimeout(showToast._timer);
  showToast._timer = setTimeout(()=>t.classList.remove('show'), 1200);
}

/* ========= Copy buttons ========= */
document.addEventListener('click', async (e)=>{
  const btn = e.target.closest('button[data-copy]');
  if(!btn) return;
  const sel = btn.getAttribute('data-copy');
  const node = document.querySelector(sel);
  if(!node) return;
  const text = node.textContent.trim();
  try{
    await navigator.clipboard.writeText(text);
    showToast('Copied to clipboard');
  }catch(err){
    showToast('Copy failed (browser blocked clipboard)');
  }
});

/* ========= Physics formulas ========= */
function gain_kneq1(A, k){
  // G = (1-k)/(exp(-(1-k)A)-k). Handle k ~ 1 with stable limit.
  const dk = 1 - k;
  if(Math.abs(dk) < 1e-4){
    return 1 / (1 - A); // k≈1 limit
  }
  const denom = Math.exp(-dk * A) - k;
  return (1 - k) / denom;
}
function gain_k1(A){ return 1 / (1 - A); }

/* ========= Plot helpers ========= */
function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
  const {x, y, w, h} = box;
  ctx.save();
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);

  // background vignette
  const grad = ctx.createLinearGradient(0, y, 0, y+h);
  grad.addColorStop(0, 'rgba(255,255,255,0.05)');
  grad.addColorStop(1, 'rgba(255,255,255,0.02)');
  ctx.fillStyle = grad;
  ctx.fillRect(x, y, w, h);

  // margins
  const mL=54, mR=16, mT=34, mB=44;
  const px = {x0: x+mL, y0: y+h-mB, x1: x+w-mR, y1: y+mT};

  // helpers
  const X = v => px.x0 + (v - xMin) * (px.x1 - px.x0) / (xMax - xMin);
  const Y = v => px.y0 - (v - yMin) * (px.y0 - px.y1) / (yMax - yMin);

  // grid + ticks
  ctx.lineWidth = 1;

  const xt = niceTicks(xMin, xMax, 7);
  const yt = niceTicks(yMin, yMax, 6);

  // grid
  ctx.strokeStyle = 'rgba(234,240,255,0.10)';
  for(let v=xt.start; v<=xt.end+1e-12; v+=xt.step){
    const xx = X(v);
    ctx.beginPath(); ctx.moveTo(xx, px.y1); ctx.lineTo(xx, px.y0); ctx.stroke();
  }
  for(let v=yt.start; v<=yt.end+1e-12; v+=yt.step){
    const yy = Y(v);
    ctx.beginPath(); ctx.moveTo(px.x0, yy); ctx.lineTo(px.x1, yy); ctx.stroke();
  }

  // axes
  ctx.strokeStyle = 'rgba(234,240,255,0.35)';
  ctx.beginPath();
  ctx.moveTo(px.x0, px.y1); ctx.lineTo(px.x0, px.y0); ctx.lineTo(px.x1, px.y0);
  ctx.stroke();

  // ticks + labels
  ctx.fillStyle = 'rgba(234,240,255,0.85)';
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for(let v=xt.start; v<=xt.end+1e-12; v+=xt.step){
    const xx = X(v);
    ctx.fillRect(xx-0.5, px.y0, 1, 6);
    ctx.fillText((Math.abs(v) < 1e-9 ? "0" : (Math.round(v*1000)/1000).toString()), xx, px.y0+8);
  }
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for(let v=yt.start; v<=yt.end+1e-12; v+=yt.step){
    const yy = Y(v);
    ctx.fillRect(px.x0-6, yy-0.5, 6, 1);
    ctx.fillText((Math.abs(v) < 1e-9 ? "0" : (Math.round(v*1000)/1000).toString()), px.x0-8, yy);
  }

  // title
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.font = '600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillStyle = 'rgba(234,240,255,0.92)';
  ctx.fillText(title, x+14, y+10);

  // axis labels
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillStyle = 'rgba(234,240,255,0.80)';
  ctx.textAlign = 'center';
  ctx.fillText(xLabel, (px.x0+px.x1)/2, y+h-18);

  ctx.save();
  ctx.translate(x+18, (px.y0+px.y1)/2);
  ctx.rotate(-Math.PI/2);
  ctx.textAlign = 'center';
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  // return plot area transforms
  ctx.restore();
  return {px, X, Y};
}

function drawLine(ctx, X, Y, xs, ys, strokeStyle='rgba(125,211,252,0.95)', lineWidth=2){
  ctx.save();
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = lineWidth;
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const xx = X(xs[i]), yy = Y(ys[i]);
    if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
  }
  ctx.stroke();
  ctx.restore();
}

function drawLegend(ctx, items, x, y){
  ctx.save();
  const pad=10, lineLen=22, gap=10, rowH=18;
  ctx.font = '12px ui-sans-serif, system-ui';
  let w=0;
  for(const it of items){
    w = Math.max(w, lineLen+8+ctx.measureText(it.label).width);
  }
  const h = items.length*rowH + pad*2 - 4;
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.strokeStyle = 'rgba(234,240,255,0.14)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  const r=14;
  const W = w + pad*2, H=h;
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+W, y, x+W, y+H, r);
  ctx.arcTo(x+W, y+H, x, y+H, r);
  ctx.arcTo(x, y+H, x, y, r);
  ctx.arcTo(x, y, x+W, y, r);
  ctx.closePath();
  ctx.fill(); ctx.stroke();

  for(let i=0;i<items.length;i++){
    const yy = y+pad + i*rowH;
    ctx.strokeStyle = items[i].color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x+pad, yy+6);
    ctx.lineTo(x+pad+lineLen, yy+6);
    ctx.stroke();

    ctx.fillStyle = 'rgba(234,240,255,0.90)';
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillText(items[i].label, x+pad+lineLen+8, yy);
  }
  ctx.restore();
}

/* ========= Diagram ========= */
function drawDiagram(k, A){
  const canvas = document.getElementById('diagram');
  const {ctx, wCSS:W, hCSS:H} = setupCanvas(canvas);

  ctx.clearRect(0,0,W,H);

  // background panel
  const bg = ctx.createLinearGradient(0,0,0,H);
  bg.addColorStop(0,'rgba(255,255,255,0.06)');
  bg.addColorStop(1,'rgba(255,255,255,0.02)');
  ctx.fillStyle = bg;
  ctx.fillRect(0,0,W,H);

  // region box
  const margin=18;
  const x0=margin, x1=W-margin;
  const yMid=H*0.55;
  const regionTop=H*0.22, regionBot=H*0.72;

  // title
  ctx.fillStyle='rgba(234,240,255,0.92)';
  ctx.font='600 14px ui-sans-serif, system-ui';
  ctx.fillText('APD multiplication region (uniform field)', 14, 10);

  // draw layer
  const layerX0 = x0+30, layerX1 = x1-30;
  ctx.fillStyle='rgba(125,211,252,0.08)';
  ctx.strokeStyle='rgba(125,211,252,0.30)';
  ctx.lineWidth=2;
  roundRect(ctx, layerX0, regionTop, layerX1-layerX0, regionBot-regionTop, 16);
  ctx.fill(); ctx.stroke();

  // boundaries labels
  ctx.fillStyle='rgba(234,240,255,0.80)';
  ctx.font='12px ui-sans-serif, system-ui';
  ctx.fillText('x = 0 (injection side)', layerX0, regionBot+18);
  ctx.textAlign='right';
  ctx.fillText('x = w (electron collection)', layerX1, regionBot+18);
  ctx.textAlign='left';

  // arrows: electron to right, hole to left
  const eY = yMid - 40;
  const hY = yMid + 40;

  // electron injection point
  drawCarrier(ctx, layerX0+18, eY, 'e−', 'rgba(125,211,252,0.95)');
  arrow(ctx, layerX0+32, eY, layerX1-24, eY, 'rgba(125,211,252,0.85)');
  ctx.fillStyle='rgba(234,240,255,0.80)';
  ctx.fillText('electron drift', layerX0+46, eY-18);

  // hole direction
  drawCarrier(ctx, layerX1-18, hY, 'h+', 'rgba(167,139,250,0.95)');
  arrow(ctx, layerX1-32, hY, layerX0+24, hY, 'rgba(167,139,250,0.85)');
  ctx.fillStyle='rgba(234,240,255,0.80)';
  ctx.fillText('hole drift', layerX0+46, hY-18);

  // ionization events: show 3 events; density depends on A and k
  const n = 3;
  const strength = clamp(0.15 + 0.85*(A/0.95), 0, 1);
  const sym = clamp(1 - Math.abs(1-k)/1.0, 0, 1); // near 1 when k near 1
  for(let i=0;i<n;i++){
    const t = (i+1)/(n+1);
    const xx = layerX0 + 40 + t*(layerX1-layerX0-80);
    const yy = yMid + (i%2===0 ? -6 : 10);

    // "spark"
    const r = 9 + 10*strength;
    ctx.save();
    ctx.globalAlpha = 0.55;
    const g = ctx.createRadialGradient(xx,yy,2,xx,yy,r);
    g.addColorStop(0,'rgba(251,191,36,0.95)');
    g.addColorStop(1,'rgba(251,191,36,0)');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(xx,yy,r,0,Math.PI*2); ctx.fill();
    ctx.restore();

    ctx.strokeStyle='rgba(251,191,36,0.65)';
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(xx,yy,6,0,Math.PI*2); ctx.stroke();

    ctx.fillStyle='rgba(234,240,255,0.85)';
    ctx.font='12px ui-sans-serif, system-ui';
    ctx.fillText('ionization', xx+10, yy-18);

    // show pair generation lines
    ctx.strokeStyle='rgba(234,240,255,0.20)';
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(xx,yy);
    ctx.lineTo(xx+28, eY);
    ctx.moveTo(xx,yy);
    ctx.lineTo(xx-28, hY);
    ctx.stroke();

    // extra carriers: intensity depends on k symmetry
    if(sym > 0.25){
      drawCarrier(ctx, xx+28, eY, 'e−', 'rgba(125,211,252,0.95)', 7);
      drawCarrier(ctx, xx-28, hY, 'h+', 'rgba(167,139,250,0.95)', 7);
    }
  }

  // info panel
  const infoY = regionTop+10;
  const infoX = layerX0+12;
  ctx.fillStyle='rgba(0,0,0,0.25)';
  ctx.strokeStyle='rgba(234,240,255,0.14)';
  ctx.lineWidth=1;
  roundRect(ctx, infoX, infoY, 260, 78, 14);
  ctx.fill(); ctx.stroke();

  ctx.fillStyle='rgba(234,240,255,0.92)';
  ctx.font='600 12px ui-sans-serif, system-ui';
  ctx.fillText('Model parameters (dimensionless)', infoX+12, infoY+10);
  ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillStyle='rgba(234,240,255,0.85)';
  ctx.fillText(`k = ${k.toFixed(2)}`, infoX+12, infoY+30);
  ctx.fillText(`A = αe w = ${A.toFixed(3)}`, infoX+12, infoY+48);

  const gNow = (Math.abs(1-k)<1e-4) ? gain_k1(A) : gain_kneq1(A,k);
  ctx.fillText(`G(A,k) ≈ ${isFinite(gNow) ? gNow.toFixed(3) : '∞'}`, infoX+12, infoY+66);
}

function roundRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}
function arrow(ctx, x0,y0,x1,y1, color){
  ctx.save();
  ctx.strokeStyle=color;
  ctx.lineWidth=2.5;
  ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
  const ang = Math.atan2(y1-y0, x1-x0);
  const head=10;
  ctx.fillStyle=color;
  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.lineTo(x1 - head*Math.cos(ang) + 0.55*head*Math.sin(ang), y1 - head*Math.sin(ang) - 0.55*head*Math.cos(ang));
  ctx.lineTo(x1 - head*Math.cos(ang) - 0.55*head*Math.sin(ang), y1 - head*Math.sin(ang) + 0.55*head*Math.cos(ang));
  ctx.closePath(); ctx.fill();
  ctx.restore();
}
function drawCarrier(ctx, x, y, label, color, radius=9){
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.25)';
  ctx.beginPath(); ctx.arc(x+1,y+1,radius+1,0,Math.PI*2); ctx.fill();
  ctx.fillStyle=color;
  ctx.beginPath(); ctx.arc(x,y,radius,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='rgba(11,16,32,0.95)';
  ctx.font='700 10px ui-sans-serif, system-ui';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  ctx.fillText(label, x, y+0.5);
  ctx.restore();
}

/* ========= Main plot: G vs A ========= */
function drawMainPlot(k, A){
  const canvas = document.getElementById('plotMain');
  const {ctx, wCSS:W, hCSS:H} = setupCanvas(canvas);

  // Choose plotting domain
  const xMin = 0.0, xMax = 0.95;
  const yMin = 0.0, yMax = 15.0;

  const box = {x:0,y:0,w:W,h:H};
  const {px, X, Y} = drawAxes(
    ctx, box, xMin, xMax, yMin, yMax,
    'A = αe w (dimensionless)', 'Gain G (dimensionless)',
    'Mean gain vs A (uniform field)'
  );

  // build curves
  const N=260;
  const xs=[];
  const ysK=[];
  const ysK1=[];

  for(let i=0;i<=N;i++){
    const x = xMin + (xMax-xMin)*i/N;
    xs.push(x);
    ysK.push(clamp(gain_kneq1(x, k), yMin, yMax*2));
    ysK1.push(clamp(gain_k1(x), yMin, yMax*2));
  }

  // Draw k=1 limit curve (purple-ish)
  drawLine(ctx, X, Y, xs, ysK1, 'rgba(167,139,250,0.92)', 2.2);

  // Draw current k curve (cyan)
  drawLine(ctx, X, Y, xs, ysK, 'rgba(125,211,252,0.95)', 2.6);

  // highlight current A point
  const gNow = gain_kneq1(A,k);
  const gx = X(A), gy = Y(clamp(gNow, yMin, yMax));
  ctx.save();
  ctx.fillStyle='rgba(251,191,36,0.95)';
  ctx.strokeStyle='rgba(0,0,0,0.35)';
  ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(gx, gy, 5.5, 0, Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.restore();

  // breakdown marker for k=1 at A=1 (outside view), but show near edge
  ctx.save();
  ctx.strokeStyle='rgba(251,113,133,0.55)';
  ctx.setLineDash([6,6]);
  ctx.lineWidth=2;
  const bx = X(0.95);
  ctx.beginPath(); ctx.moveTo(bx, px.y1); ctx.lineTo(bx, px.y0); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle='rgba(234,240,255,0.70)';
  ctx.font='12px ui-sans-serif, system-ui';
  ctx.textAlign='right';
  ctx.fillText('A → 1 (k=1 mean divergence)', px.x1, px.y1+6);
  ctx.restore();

  // legend
  drawLegend(ctx, [
    {label:`Current k = ${k.toFixed(2)} (general k≠1 formula)`, color:'rgba(125,211,252,0.95)'},
    {label:'k = 1 limit: G = 1/(1−A)', color:'rgba(167,139,250,0.92)'}
  ], px.x0+10, px.y1+8);
}

/* ========= Secondary plot: G vs k at fixed A ========= */
function drawSecondaryPlot(k, A){
  const canvas = document.getElementById('plotSecondary');
  const {ctx, wCSS:W, hCSS:H} = setupCanvas(canvas);

  const xMin = 0.0, xMax = 2.0;
  const yMin = 0.0, yMax = 15.0;

  const box = {x:0,y:0,w:W,h:H};
  const {px, X, Y} = drawAxes(
    ctx, box, xMin, xMax, yMin, yMax,
    'k = αh/αe (dimensionless)', 'Gain G (dimensionless)',
    `Gain vs k at fixed A = ${A.toFixed(3)}`
  );

  const N=320;
  const xs=[];
  const ys=[];
  for(let i=0;i<=N;i++){
    const kk = xMin + (xMax-xMin)*i/N;
    xs.push(kk);
    let g = gain_kneq1(A, kk);
    if(!isFinite(g)) g = yMax*2;
    ys.push(clamp(g, yMin, yMax*2));
  }

  drawLine(ctx, X, Y, xs, ys, 'rgba(134,239,172,0.92)', 2.6);

  // vertical marker at current k
  ctx.save();
  ctx.strokeStyle='rgba(251,191,36,0.90)';
  ctx.lineWidth=2.2;
  ctx.beginPath();
  ctx.moveTo(X(k), px.y1);
  ctx.lineTo(X(k), px.y0);
  ctx.stroke();
  ctx.restore();

  // mark point
  const gNow = gain_kneq1(A,k);
  ctx.save();
  ctx.fillStyle='rgba(251,191,36,0.95)';
  ctx.strokeStyle='rgba(0,0,0,0.35)';
  ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(X(k), Y(clamp(gNow,yMin,yMax)), 5.5, 0, Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.restore();

  drawLegend(ctx, [
    {label:'G(k) at fixed A (general formula)', color:'rgba(134,239,172,0.92)'},
    {label:'current k marker', color:'rgba(251,191,36,0.90)'}
  ], px.x0+10, px.y1+8);
}

/* ========= Wiring: controls + redraw ========= */
const kSlider = document.getElementById('kSlider');
const aSlider = document.getElementById('aSlider');
const kReadout = document.getElementById('kReadout');
const aReadout = document.getElementById('aReadout');

function update(){
  const k = parseFloat(kSlider.value);
  const A = parseFloat(aSlider.value);
  kReadout.textContent = k.toFixed(2);
  aReadout.textContent = A.toFixed(3);

  drawDiagram(k, A);
  drawMainPlot(k, A);
  drawSecondaryPlot(k, A);
}

kSlider.addEventListener('input', update);
aSlider.addEventListener('input', update);
window.addEventListener('resize', ()=>{ update(); });

update();
</script>
</body>
</html>
