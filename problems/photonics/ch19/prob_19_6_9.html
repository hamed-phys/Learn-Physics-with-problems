<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Analog Receiver Sensitivity (Shot-Noise Limited Photodiode)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --card:#0f1620;
      --card2:#0c121b;
      --text:#e9eef6;
      --muted:#b7c4d6;
      --faint:#7f93ad;
      --accent:#7cf2c8;
      --accent2:#8ab4ff;
      --warn:#ffd166;
      --danger:#ff6b6b;
      --line:rgba(255,255,255,0.10);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 18px;
      --radius2: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 800px at 20% -10%, rgba(138,180,255,0.18), transparent 60%),
                  radial-gradient(900px 700px at 90% 10%, rgba(124,242,200,0.14), transparent 55%),
                  linear-gradient(180deg, #06080c 0%, #0b0f14 40%, #070a0f 100%);
      color:var(--text);
      line-height:1.55;
    }

    a{color:var(--accent2); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding: 34px 18px 18px;
      max-width: 1180px;
      margin: 0 auto;
    }
    .title-wrap{
      display:grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap:18px;
      align-items:end;
    }
    h1{
      margin:0;
      font-size: clamp(1.6rem, 2.4vw, 2.3rem);
      letter-spacing:0.2px;
    }
    .subtitle{
      color:var(--muted);
      margin-top:10px;
      font-size:1rem;
      max-width: 70ch;
    }

    .meta-card{
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:14px 14px 12px;
      box-shadow: var(--shadow);
    }
    .meta-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:7px 10px;
      border-radius: 999px;
      background: rgba(124,242,200,0.10);
      border:1px solid rgba(124,242,200,0.25);
      color:var(--text);
      font-size: 0.92rem;
      white-space:nowrap;
    }
    .pill b{color:var(--accent)}
    .pill.alt{
      background: rgba(138,180,255,0.10);
      border:1px solid rgba(138,180,255,0.22);
    }

    main{
      max-width:1180px;
      margin:0 auto;
      padding: 10px 18px 56px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }

    /* Sticky TOC */
    nav#toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    #toc h2{
      margin:0 0 10px;
      font-size: 0.95rem;
      color: var(--muted);
      letter-spacing:0.3px;
      text-transform:uppercase;
    }
    #toc a{
      display:block;
      padding:9px 10px;
      border-radius: 12px;
      color: var(--text);
      border: 1px solid transparent;
      font-size:0.97rem;
    }
    #toc a:hover{
      background: rgba(255,255,255,0.05);
      border-color: rgba(255,255,255,0.08);
      text-decoration:none;
    }
    #toc .small{
      color: var(--faint);
      font-size:0.9rem;
      margin-top:10px;
      padding: 8px 10px;
      background: rgba(0,0,0,0.18);
      border:1px dashed rgba(255,255,255,0.12);
      border-radius: 12px;
    }

    article{
      min-width: 0;
    }

    section{
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow);
      margin-bottom: 16px;
      position: relative;
      overflow:hidden;
    }

    section::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(900px 240px at 15% 0%, rgba(124,242,200,0.10), transparent 55%),
                  radial-gradient(900px 240px at 80% 0%, rgba(138,180,255,0.10), transparent 60%);
      opacity:0.7;
      pointer-events:none;
    }
    section > *{position:relative}

    h2{
      margin: 0 0 10px;
      font-size: 1.25rem;
      letter-spacing:0.2px;
    }
    h3{
      margin: 14px 0 8px;
      font-size: 1.05rem;
      color: var(--muted);
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
      nav#toc{position:relative; top:0}
      .title-wrap{grid-template-columns:1fr}
    }
    @media (max-width: 720px){
      .grid2,.grid3{grid-template-columns: 1fr}
    }

    ul{margin: 8px 0 0 20px}
    li{margin: 6px 0}
    .muted{color:var(--muted)}
    .faint{color:var(--faint)}
    .mono{font-family: var(--mono)}
    .kbd{
      font-family: var(--mono);
      padding:2px 6px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.22);
      color: var(--text);
      font-size:0.95em;
    }

    .callout{
      border-radius: var(--radius2);
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.20);
      padding: 12px 12px 10px;
      margin-top: 10px;
    }
    .callout strong{color:var(--accent)}
    .callout.warn strong{color:var(--warn)}
    .callout.danger strong{color:var(--danger)}
    .callout .title{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-bottom:6px;
    }
    .copybtn{
      cursor:pointer;
      border:1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 12px;
      padding: 7px 10px;
      font-size:0.92rem;
      transition: transform 0.08s ease, background 0.15s ease;
      user-select:none;
      white-space:nowrap;
    }
    .copybtn:hover{background: rgba(255,255,255,0.10)}
    .copybtn:active{transform: scale(0.98)}
    .eq{
      font-family: var(--mono);
      font-size: 0.98rem;
      line-height:1.5;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .result{
      display:grid;
      grid-template-columns: 1.05fr 0.95fr;
      gap:14px;
      align-items:stretch;
    }
    @media (max-width: 900px){
      .result{grid-template-columns:1fr}
    }
    .big-number{
      font-size: clamp(1.4rem, 2.2vw, 1.9rem);
      margin: 2px 0 0;
      letter-spacing:0.2px;
    }
    .badge{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:6px 10px;
      border-radius: 999px;
      background: rgba(124,242,200,0.10);
      border:1px solid rgba(124,242,200,0.22);
      color: var(--text);
      font-size:0.92rem;
    }
    .badge b{color:var(--accent)}
    .badge.alt{
      background: rgba(138,180,255,0.10);
      border:1px solid rgba(138,180,255,0.22);
    }

    /* Visualization area */
    .viz-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      align-items:stretch;
    }
    @media (max-width: 900px){
      .viz-grid{grid-template-columns:1fr}
    }
    figure{
      margin:0;
      border-radius: var(--radius2);
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      padding: 10px;
      overflow:hidden;
    }
    figcaption{
      margin: 8px 2px 0;
      color: var(--muted);
      font-size:0.95rem;
    }
    canvas{
      width: 100%;
      height: 320px;
      display:block;
      border-radius: 12px;
      background: rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.10);
    }
    canvas.tall{height: 360px;}
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top: 10px;
    }
    @media (max-width: 720px){
      .controls{grid-template-columns:1fr}
    }
    .control{
      border-radius: var(--radius2);
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.20);
      padding: 10px 10px 8px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      color: var(--muted);
      font-size:0.95rem;
      margin-bottom: 6px;
    }
    .control input[type="range"]{
      width:100%;
    }
    .val{
      font-family: var(--mono);
      color: var(--text);
      font-size:0.95rem;
    }

    footer{
      max-width:1180px;
      margin:0 auto;
      padding: 10px 18px 40px;
      color: var(--faint);
      font-size:0.95rem;
    }

    /* Print friendly */
    @media print{
      body{background:#fff; color:#000}
      section, nav#toc, .meta-card{box-shadow:none}
      nav#toc{position:relative; top:0}
      .copybtn{display:none}
      canvas{border:1px solid #999}
      a{color:#000; text-decoration:underline}
    }

    /* subtle animation */
    @keyframes floatIn{
      from{transform: translateY(6px); opacity:0}
      to{transform: translateY(0); opacity:1}
    }
    section{animation: floatIn 280ms ease both}
  </style>
</head>

<body>
<header>
  <div class="title-wrap">
    <div>
      <h1>Analog Receiver Sensitivity (Shot-Noise Limited Direct Detection)</h1>
      <p class="subtitle">
        We find the <span class="muted">minimum optical power</span> needed so a photodiode current measurement achieves a target
        signal-to-noise ratio when <span class="muted">only photon (shot) noise</span> is present.
      </p>
    </div>

    <div class="meta-card">
      <div class="pill"><span>Mode:</span> <b>Analog</b> (current measurement)</div>
      <div class="meta-grid">
        <div class="pill alt"><span>Noise:</span> <b>Shot only</b></div>
        <div class="pill"><span>Bandwidth:</span> <b id="metaB">100 MHz</b></div>
        <div class="pill alt"><span>λ:</span> <b id="metalambda">1300 nm</b></div>
        <div class="pill"><span>η:</span> <b id="metaeta">0.80</b></div>
      </div>
      <div class="small faint" style="margin-top:10px;">
        Interactive plots below let you sweep parameters and see how required power scales.
      </div>
    </div>
  </div>
</header>

<main>
  <nav id="toc" aria-label="Table of Contents">
    <h2>Table of Contents</h2>
    <a href="#qs">Quick Summary</a>
    <a href="#p0">PART 0 — Concept Primer</a>
    <a href="#p1">PART 1 — Problem Analysis</a>
    <a href="#p2">PART 2 — Strategy & Tips</a>
    <a href="#p3">PART 3 — Full Solution</a>
    <a href="#p4">PART 4 — Deeper Understanding</a>
    <a href="#p5">PART 5 — Visualization Guide</a>
    <div class="small">
      Tip: the key scaling here is <span class="mono">P_req ∝ B · SNR / η</span> (and it also depends on wavelength through responsivity).
    </div>
  </nav>

  <article>
    <section id="qs">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>What this problem is about:</b> minimum optical power (receiver sensitivity) for an analog photodiode receiver to reach a target <span class="mono">SNR</span> in bandwidth <span class="mono">B</span>.</li>
        <li><b>Key physics idea:</b> when circuit noise is absent, the dominant electrical noise is <b>shot noise</b> from the random arrival of photons/electrons.</li>
        <li><b>Photodiode conversion:</b> average photocurrent <span class="mono">I = R·P</span> where responsivity <span class="mono">R = η q/(hν) = η q λ/(hc)</span>.</li>
        <li><b>Shot-noise current (mean-square):</b> <span class="mono">i_n^2 = 2 q I B</span> for bandwidth <span class="mono">B</span>.</li>
        <li><b>Analog current SNR (shot-noise limited):</b> <span class="mono">SNR = I^2 / (2 q I B) = I/(2 q B)</span>.</li>
        <li><b>Required current:</b> <span class="mono">I_req = 2 q B · SNR</span> (linear in bandwidth and SNR).</li>
        <li><b>Required optical power (numeric):</b> for <span class="mono">η=0.8</span>, <span class="mono">λ=1300 nm</span>, <span class="mono">B=100 MHz</span>, <span class="mono">SNR=10^3</span>,
          <b class="mono">P_req ≈ 3.82×10^-8 W = 38.2 nW</b>.</li>
      </ul>
    </section>

    <section id="p0">
      <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

      <h3>Core definitions (symbols & units)</h3>
      <ul>
        <li><span class="mono">P</span> — received optical power (W).</li>
        <li><span class="mono">λ</span> — optical wavelength (m), here around 1300 nm.</li>
        <li><span class="mono">ν = c/λ</span> — optical frequency (Hz).</li>
        <li><span class="mono">η</span> — quantum efficiency (dimensionless): fraction of incident photons that generate collected electron–hole pairs.</li>
        <li><span class="mono">R</span> — photodiode responsivity (A/W): how much average current you get per watt of optical power.</li>
        <li><span class="mono">I</span> — average photocurrent (A).</li>
        <li><span class="mono">B</span> — receiver (electrical) bandwidth (Hz).</li>
        <li><span class="mono">q</span> — elementary charge (C).</li>
        <li><span class="mono">SNR</span> — signal-to-noise ratio (dimensionless) in the measured electrical quantity (here, current).</li>
      </ul>

      <h3>Physical meaning (what these quantities represent)</h3>
      <ul>
        <li><b>Quantum efficiency η</b> tells you how effectively photons become charge carriers. Higher η means more current for the same optical power.</li>
        <li><b>Responsivity R</b> encodes both η and photon energy: at longer λ each photon carries less energy, so per watt you get <i>more</i> photons → potentially more electrons → larger R (for fixed η).</li>
        <li><b>Shot noise</b> comes from the Poisson statistics of discrete electron arrivals. Even with a perfectly stable optical power, the detected current fluctuates.</li>
        <li><b>Bandwidth B</b> sets how much noise you collect: wider B integrates more noise power.</li>
      </ul>

      <div class="callout">
        <div class="title">
          <strong>Key Equations (copy-friendly)</strong>
          <button class="copybtn" data-copy="R = η q λ / (h c)
I = R P
i_n^2 = 2 q I B
SNR = I^2 / i_n^2 = I / (2 q B)
I_req = 2 q B SNR
P_req = I_req / R">Copy</button>
        </div>
        <div class="eq">R = η q λ / (h c)
I = R P
i_n^2 = 2 q I B
SNR = I^2 / i_n^2 = I / (2 q B)
I_req = 2 q B SNR
P_req = I_req / R</div>
      </div>

      <h3>Key laws/principles and when they are valid</h3>
      <ul>
        <li><b>Photoelectric conversion:</b> each absorbed photon (probability η) creates one collected electron (charge q). Valid when the photodiode operates in its linear regime (no saturation) and internal gain is absent (plain PIN photodiode).</li>
        <li><b>Poisson statistics:</b> if arrivals are independent, the variance in counts equals the mean. This yields the shot-noise spectral density.</li>
        <li><b>Shot-noise formula:</b> <span class="mono">i_n^2 = 2 q I B</span> assumes:
          <ul>
            <li>current is DC (or slowly varying compared to the noise band) and noise is white over bandwidth B,</li>
            <li>no excess multiplication noise (not an APD),</li>
            <li>no additional circuit/thermal noise (explicitly given here).</li>
          </ul>
        </li>
      </ul>

      <h3>Common models/approximations (and why we use them)</h3>
      <ul>
        <li><b>Linear responsivity model:</b> <span class="mono">I = R P</span> keeps the receiver analysis simple and is accurate for typical low-to-moderate powers.</li>
        <li><b>White shot noise in band:</b> treating shot noise as flat across B lets us compute total mean-square noise by simple multiplication.</li>
      </ul>

      <h3>Mini intuition examples</h3>
      <ul>
        <li>If you <b>double bandwidth</b> B, you collect √2 more rms noise, so you need <b>double the current</b> to keep SNR fixed → required optical power doubles.</li>
        <li>If you <b>double quantum efficiency</b> η, responsivity doubles, so you need <b>half the optical power</b> to produce the same photocurrent.</li>
      </ul>

      <div class="callout warn">
        <div class="title"><strong>What to watch for (pitfalls)</strong></div>
        <ul>
          <li>Using the wrong SNR definition (power vs amplitude). Here the receiver “measures the electric current <span class="mono">i</span>”, so the natural SNR is <span class="mono">I^2 / ⟨i_n^2⟩</span>.</li>
          <li>Forgetting that shot-noise variance depends on <span class="mono">I</span> itself → SNR scales linearly with <span class="mono">I</span>, not quadratically.</li>
          <li>Mixing bandwidth conventions (one-sided vs two-sided). We use the standard comms convention leading to <span class="mono">i_n^2 = 2 q I B</span>.</li>
          <li>Not converting nm → m when computing responsivity.</li>
        </ul>
      </div>
    </section>

    <section id="p1">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>Restate the problem (in plain words)</h3>
      <p class="muted">
        We have a photodetector with quantum efficiency <span class="mono">η = 0.8</span> at wavelength <span class="mono">λ = 1300 nm</span>.
        The receiver measures the photocurrent in an electrical bandwidth <span class="mono">B = 100 MHz</span>.
        Assuming <b>no circuit noise</b> (so only shot noise remains), find the <b>minimum optical power</b> required so that the
        measured current has <span class="mono">SNR = 10^3</span>.
      </p>

      <div class="grid2">
        <div class="callout">
          <div class="title"><strong>Given</strong></div>
          <ul>
            <li><span class="mono">η = 0.8</span></li>
            <li><span class="mono">λ = 1300 nm</span></li>
            <li><span class="mono">B = 100 MHz</span></li>
            <li><span class="mono">SNR = 10^3</span></li>
            <li>No circuit noise (shot-noise limited)</li>
          </ul>
        </div>
        <div class="callout">
          <div class="title"><strong>Unknowns / What to find</strong></div>
          <ul>
            <li>Required photocurrent <span class="mono">I_req</span> (A)</li>
            <li>Required optical power <span class="mono">P_req</span> (W)</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li><b>Photodiode responsivity:</b> required to map optical power → average current, since the receiver measures current directly.</li>
        <li><b>Shot noise:</b> dominates because the problem explicitly says “no circuit noise”. Thermal noise, amplifier noise, etc., are excluded.</li>
        <li><b>Bandwidth integration:</b> total noise grows with B because we integrate noise spectral density across the measurement band.</li>
      </ul>

      <h3>Assumptions (explicit)</h3>
      <div class="callout">
        <div class="title"><strong>Assumptions used in the solution</strong></div>
        <ul>
          <li>PIN photodiode (no internal gain, no multiplication/excess noise).</li>
          <li>Linear operation: <span class="mono">I = R P</span> (no saturation, no space-charge limits).</li>
          <li>Shot noise is white over bandwidth <span class="mono">B</span> and follows <span class="mono">i_n^2 = 2 q I B</span>.</li>
          <li>“Signal” is the DC (or slowly varying) photocurrent magnitude <span class="mono">I</span> being estimated/used.</li>
        </ul>
      </div>

      <h3>Possible approaches (2–3) and comparison</h3>
      <ul>
        <li><b>Approach A: Electrical-noise approach (best here).</b>
          Use <span class="mono">I = R P</span> and the shot-noise mean-square current <span class="mono">i_n^2 = 2 q I B</span>, then define
          <span class="mono">SNR = I^2/i_n^2</span>.
          <span class="muted">Pros:</span> direct, minimal assumptions, matches “receiver measures current”.</li>
        <li><b>Approach B: Photon-counting viewpoint.</b>
          Convert required SNR to required electron count in time <span class="mono">T ~ 1/(2B)</span>.
          <span class="muted">Pros:</span> good intuition; <span class="muted">Cons:</span> must be careful mapping bandwidth to effective observation time.</li>
        <li><b>Approach C: Noise spectral density integration.</b>
          Start from <span class="mono">S_i(f)=2qI</span> and integrate over B to get noise variance. Equivalent to A but more formal.</li>
      </ul>
      <p class="muted">
        We choose <b>Approach A</b> because it is the most direct and uses the standard receiver definition of SNR for a current measurement.
      </p>
    </section>

    <section id="p2">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

      <ol>
        <li><b>Compute responsivity <span class="mono">R</span></b><br/>
          <span class="muted">Goal:</span> relate optical power to average current.<br/>
          <span class="muted">Tool:</span> <span class="mono">R = η q λ/(h c)</span>.<br/>
          <span class="muted">Meaning:</span> A/W conversion efficiency of the detector.</li>

        <li><b>Write shot-noise variance in bandwidth <span class="mono">B</span></b><br/>
          <span class="muted">Goal:</span> express noise in the same quantity we measure (current).<br/>
          <span class="muted">Tool:</span> <span class="mono">i_n^2 = 2 q I B</span>.<br/>
          <span class="muted">Meaning:</span> more current and more bandwidth both increase noise.</li>

        <li><b>Define the SNR for a current measurement</b><br/>
          <span class="muted">Goal:</span> connect target SNR to required current.<br/>
          <span class="muted">Tool:</span> <span class="mono">SNR = I^2 / i_n^2</span>.<br/>
          <span class="muted">Meaning:</span> compares “signal level” (mean current) to random fluctuations around it.</li>

        <li><b>Solve for required current <span class="mono">I_req</span></b><br/>
          <span class="muted">Tool:</span> algebra on <span class="mono">SNR = I/(2 q B)</span>.<br/>
          <span class="muted">Meaning:</span> shows linear scaling with bandwidth and SNR.</li>

        <li><b>Convert to required optical power <span class="mono">P_req</span></b><br/>
          <span class="muted">Tool:</span> <span class="mono">P_req = I_req / R</span>.<br/>
          <span class="muted">Meaning:</span> your receiver sensitivity.</li>

        <li><b>Sanity-check</b><br/>
          <span class="muted">Check:</span> units, and whether scaling trends make sense (↑B → ↑P, ↑η → ↓P).</li>
      </ol>

      <div class="callout warn">
        <div class="title"><strong>Common mistakes & quick tips</strong></div>
        <ul>
          <li><b>Tip:</b> Keep <span class="mono">B</span> in Hz (100 MHz → <span class="mono">1.0×10^8 Hz</span>).</li>
          <li><b>Tip:</b> Responsivity at 1300 nm with η near 1 is around ~1 A/W; if you get 10 A/W, a unit conversion went wrong.</li>
          <li><b>Mistake:</b> using <span class="mono">SNR = I / i_n</span> (amplitude SNR) instead of <span class="mono">I^2 / i_n^2</span>.</li>
        </ul>
      </div>
    </section>

    <section id="p3">
      <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

      <h3>Physical intuition (before calculating)</h3>
      <p class="muted">
        In a shot-noise-limited photodiode, the noise grows with the square root of the number of detected electrons,
        but the signal (mean current) grows with the number itself. As a result, increasing optical power increases SNR.
        Wider bandwidth collects more noise, so you need more photocurrent (thus more power) to maintain the same SNR.
      </p>

      <h3>Step 1: Responsivity of the photodetector</h3>
      <p>
        Each photon has energy <span class="mono">hν = hc/λ</span>. With quantum efficiency <span class="mono">η</span>,
        the average electron rate is <span class="mono">η</span> times the photon rate. Therefore the average photocurrent is
        proportional to optical power:
      </p>

      <div class="callout">
        <div class="title">
          <strong>Responsivity</strong>
          <button class="copybtn" data-copy="R = η q/(hν) = η q λ/(h c)">Copy</button>
        </div>
        <div class="eq">R = η q/(hν) = η q λ/(h c)</div>
      </div>

      <p class="muted">
        Here <span class="mono">q</span> is the electron charge, <span class="mono">h</span> Planck’s constant, and <span class="mono">c</span> the speed of light.
        The average photocurrent is then:
      </p>
      <div class="callout">
        <div class="title">
          <strong>Power-to-current conversion</strong>
          <button class="copybtn" data-copy="I = R P">Copy</button>
        </div>
        <div class="eq">I = R P</div>
      </div>

      <h3>Step 2: Shot-noise current in bandwidth B</h3>
      <p>
        Shot noise is the fluctuation in the current due to discrete electron arrivals. For an average current <span class="mono">I</span>,
        the mean-square noise current in electrical bandwidth <span class="mono">B</span> is
      </p>

      <div class="callout">
        <div class="title">
          <strong>Shot-noise mean-square current</strong>
          <button class="copybtn" data-copy="⟨i_n^2⟩ = 2 q I B">Copy</button>
        </div>
        <div class="eq">⟨i_n^2⟩ = 2 q I B</div>
      </div>

      <p class="muted">
        This expression is widely used in receiver sensitivity calculations: more current means more electrons per second, hence more fluctuation;
        more bandwidth means more noise frequencies passed to your measurement.
      </p>

      <h3>Step 3: Define SNR for an analog current measurement</h3>
      <p>
        The problem states: “The receiver measures the electric current <span class="mono">i</span>.” In an analog receiver,
        a standard definition is
      </p>

      <div class="callout">
        <div class="title">
          <strong>Current SNR definition</strong>
          <button class="copybtn" data-copy="SNR = I^2 / ⟨i_n^2⟩">Copy</button>
        </div>
        <div class="eq">SNR = I^2 / ⟨i_n^2⟩</div>
      </div>

      <p class="muted">
        Here the “signal” is the mean photocurrent level <span class="mono">I</span>, and the “noise power” is the variance of the current fluctuations.
      </p>

      <h3>Step 4: Substitute shot noise and solve for required current</h3>
      <p>
        Substitute <span class="mono">⟨i_n^2⟩ = 2 q I B</span> into the SNR:
      </p>

      <div class="callout">
        <div class="title">
          <strong>Derivation (step-by-step)</strong>
          <button class="copybtn" data-copy="SNR = I^2 / (2 q I B)
    = I / (2 q B)
⇒ I_req = 2 q B · SNR">Copy</button>
        </div>
        <div class="eq">SNR = I^2 / (2 q I B)
    = I / (2 q B)
⇒ I_req = 2 q B · SNR</div>
      </div>

      <p class="muted">
        Notice how one factor of <span class="mono">I</span> cancels. This is the signature of shot-noise-limited analog detection:
        <b>SNR scales linearly with photocurrent</b>.
      </p>

      <h3>Step 5: Convert required current to required optical power</h3>
      <p>
        Using <span class="mono">I = R P</span>, the required optical power is
      </p>

      <div class="callout">
        <div class="title">
          <strong>Receiver sensitivity (shot-noise limited)</strong>
          <button class="copybtn" data-copy="P_req = I_req / R = (2 q B · SNR) / R
with R = η q λ/(h c)
⇒ P_req = (2 h c B · SNR) / (η λ)">Copy</button>
        </div>
        <div class="eq">P_req = I_req / R = (2 q B · SNR) / R
with R = η q λ/(h c)
⇒ P_req = (2 h c B · SNR) / (η λ)</div>
      </div>

      <p class="muted">
        The last form is especially insightful: the electron charge cancels, and the required optical power depends on
        photon energy (<span class="mono">hc/λ</span>), bandwidth, required SNR, and quantum efficiency.
      </p>

      <h3>Numerical evaluation for the given values</h3>
      <p>
        Constants:
        <span class="mono">q = 1.602176634×10^-19 C</span>,
        <span class="mono">h = 6.62607015×10^-34 J·s</span>,
        <span class="mono">c = 2.99792458×10^8 m/s</span>.
      </p>

      <div class="result">
        <div class="callout">
          <div class="title">
            <strong>Compute responsivity R</strong>
            <button class="copybtn" data-copy="η = 0.8
λ = 1300 nm = 1.300×10^-6 m
R = η q λ/(h c) ≈ 0.839 A/W">Copy</button>
          </div>
          <div class="eq">η = 0.8
λ = 1300 nm = 1.300×10^-6 m
R = η q λ/(h c) ≈ 0.839 A/W</div>
          <p class="faint" style="margin:8px 0 0;">This is a realistic value: ~0.84 A/W at 1300 nm with η=0.8.</p>
        </div>

        <div class="callout">
          <div class="title">
            <strong>Compute required current and power</strong>
            <button class="copybtn" data-copy="B = 100 MHz = 1.0×10^8 Hz
SNR = 10^3

I_req = 2 q B SNR
     ≈ 2(1.602×10^-19)(1.0×10^8)(10^3)
     ≈ 3.20×10^-8 A = 32.0 nA

P_req = I_req / R
     ≈ (3.20×10^-8) / 0.839
     ≈ 3.82×10^-8 W = 38.2 nW">Copy</button>
          </div>
          <div class="eq">B = 100 MHz = 1.0×10^8 Hz
SNR = 10^3

I_req = 2 q B SNR
     ≈ 3.20×10^-8 A = 32.0 nA

P_req = I_req / R
     ≈ 3.82×10^-8 W = 38.2 nW</div>
        </div>
      </div>

      <div class="callout danger" style="margin-top:14px;">
        <div class="title">
          <strong>Final Answer (Receiver Sensitivity)</strong>
          <button class="copybtn" id="copyFinal" data-copy="">Copy</button>
        </div>
        <p class="big-number" style="margin:6px 0 2px;">
          <span class="badge"><b id="Pnum">38.2</b> nW</span>
          <span class="badge alt" style="margin-left:10px;"><b id="Pwatts">3.82×10^-8</b> W</span>
        </p>
        <p class="muted" style="margin:6px 0 0;">
          Shot-noise-limited optical power required for <span class="mono">SNR = 10^3</span> in <span class="mono">B = 100 MHz</span>
          with <span class="mono">η=0.8</span> at <span class="mono">λ=1300 nm</span>.
        </p>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><b>Units:</b> <span class="mono">I_req = 2 q B SNR</span> → (C)(1/s)(dimensionless) = A ✓.
          Then <span class="mono">P_req = I_req/R</span> → A / (A/W) = W ✓.</li>
        <li><b>Limiting cases:</b> If <span class="mono">B → 0</span>, required power → 0 (no noise collected) ✓. If <span class="mono">η → 1</span>, required power decreases ✓.</li>
        <li><b>Scaling intuition:</b> Required power is tiny (tens of nW) because we assumed <b>no circuit noise</b>; real receivers usually need more due to thermal/amplifier noise.</li>
      </ul>

      <p class="muted">
        Connection to the visuals: the diagram shows light producing a DC photocurrent, while the plots show how SNR rises with optical power and how the required power grows with bandwidth and target SNR.
      </p>
    </section>

    <section id="p4">
      <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

      <h3>Re-interpreting the final formula</h3>
      <p>
        A compact sensitivity expression is:
        <span class="mono">P_req = (2 h c B · SNR)/(η λ)</span>.
        Each factor has a clear role:
      </p>
      <ul>
        <li><span class="mono">B</span>: wider bandwidth → more noise collected → <b>higher</b> required power.</li>
        <li><span class="mono">SNR</span>: more stringent SNR → <b>higher</b> required power (linearly).</li>
        <li><span class="mono">η</span>: higher quantum efficiency → more electrons per photon → <b>lower</b> required power (inverse).</li>
        <li><span class="mono">λ</span>: longer wavelength (larger λ) means lower photon energy, so per watt you get more photons;
          for fixed η this makes <span class="mono">R</span> larger and thus <b>reduces</b> required power (inverse in λ).</li>
      </ul>

      <h3>How changing parameters affects the outcome (connect to plots)</h3>
      <ul>
        <li>If you slide <span class="mono">B</span> upward, the SNR-vs-power curve shifts right (you need more power for the same SNR).</li>
        <li>If you increase <span class="mono">η</span>, the curve shifts left (less power needed) because <span class="mono">R</span> increases.</li>
        <li>If you increase target <span class="mono">SNR</span>, required current rises and required power rises proportionally.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p class="muted">
        Photon-counting viewpoint: in an effective observation time <span class="mono">T</span>, the number of detected electrons
        has variance equal to its mean (<span class="mono">σ_N^2 = N</span>). Since <span class="mono">I = qN/T</span>, you can show
        <span class="mono">SNR ∝ N</span> and relate <span class="mono">T</span> to bandwidth. Doing this carefully leads back to
        the same <span class="mono">i_n^2 = 2 q I B</span> result.
      </p>

      <h3>Concept check (quick self-test)</h3>
      <ul>
        <li><b>Q:</b> Why does SNR scale linearly with current in the shot-noise-limited case?<br/>
            <b>A:</b> Because noise variance is proportional to <span class="mono">I</span>, so <span class="mono">SNR = I^2/(const·I) ∝ I</span>.</li>
        <li><b>Q:</b> What happens to required optical power if bandwidth doubles?<br/>
            <b>A:</b> It doubles (<span class="mono">P_req ∝ B</span>).</li>
        <li><b>Q:</b> If η drops from 0.8 to 0.4, what happens to required power?<br/>
            <b>A:</b> It doubles (<span class="mono">P_req ∝ 1/η</span>).</li>
        <li><b>Q:</b> Does the required power depend on the electron charge q in the final simplified formula?<br/>
            <b>A:</b> No; q cancels when you substitute <span class="mono">R</span>.</li>
      </ul>
    </section>

    <section id="p5">
      <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

      <div class="viz-grid">
        <figure>
          <canvas id="setupCanvas" class="tall" aria-label="Photodiode receiver diagram"></canvas>
          <figcaption>
            <b>Diagram:</b> Optical power <span class="mono">P</span> at wavelength <span class="mono">λ</span> hits a photodiode (QE <span class="mono">η</span>),
            producing average photocurrent <span class="mono">I = R P</span>. Shot noise adds fluctuations with variance <span class="mono">2 q I B</span>
            inside bandwidth <span class="mono">B</span>.
          </figcaption>
        </figure>

        <figure>
          <canvas id="mainPlot" class="tall" aria-label="SNR versus optical power plot"></canvas>
          <figcaption>
            <b>Main plot:</b> <span class="mono">SNR(P) = (R P)/(2 q B)</span>. A horizontal line marks the target SNR; its intersection gives <span class="mono">P_req</span>.
          </figcaption>
        </figure>
      </div>

      <div class="viz-grid" style="margin-top:14px;">
        <figure>
          <canvas id="sweepPlot" aria-label="Required optical power versus bandwidth plot"></canvas>
          <figcaption>
            <b>Secondary plot (parameter sweep):</b> Required power <span class="mono">P_req(B)</span> at the selected target SNR and chosen <span class="mono">η</span>, <span class="mono">λ</span>.
          </figcaption>
        </figure>

        <figure>
          <div class="callout" style="margin:0;">
            <div class="title"><strong>Interactive Controls</strong></div>
            <p class="muted" style="margin:6px 0 10px;">
              Adjust one or more parameters. All visuals and the numerical answer update live.
            </p>

            <div class="controls">
              <div class="control">
                <label>
                  Bandwidth <span class="mono">B</span>
                  <span class="val" id="Bval">100 MHz</span>
                </label>
                <input id="Bslider" type="range" min="1" max="1000" value="100" step="1" />
                <div class="faint" style="margin-top:6px;">Range: 1–1000 MHz (example sweep)</div>
              </div>

              <div class="control">
                <label>
                  Quantum efficiency <span class="mono">η</span>
                  <span class="val" id="etaval">0.80</span>
                </label>
                <input id="etaslider" type="range" min="0.05" max="1.00" value="0.80" step="0.01" />
                <div class="faint" style="margin-top:6px;">Range: 0.05–1.00</div>
              </div>

              <div class="control">
                <label>
                  Wavelength <span class="mono">λ</span>
                  <span class="val" id="lamval">1300 nm</span>
                </label>
                <input id="lamslider" type="range" min="800" max="1700" value="1300" step="10" />
                <div class="faint" style="margin-top:6px;">Range: 800–1700 nm (telecom-ish)</div>
              </div>

              <div class="control">
                <label>
                  Target <span class="mono">SNR</span>
                  <span class="val" id="snrval">1.00e3</span>
                </label>
                <input id="snrslider" type="range" min="1" max="6" value="3" step="0.01" />
                <div class="faint" style="margin-top:6px;">Log scale: 10<sup>1</sup> to 10<sup>6</sup></div>
              </div>
            </div>

            <div class="callout warn" style="margin-top:12px;">
              <div class="title"><strong>What should change, and why?</strong></div>
              <ul>
                <li>Increase <span class="mono">B</span> → curves shift to require larger <span class="mono">P</span> (more noise bandwidth).</li>
                <li>Increase <span class="mono">η</span> or <span class="mono">λ</span> → required <span class="mono">P</span> drops (higher responsivity).</li>
                <li>Increase target <span class="mono">SNR</span> → required <span class="mono">P</span> increases proportionally.</li>
              </ul>
            </div>
          </div>
        </figure>
      </div>
    </section>
  </article>
</main>

<footer>
  <div class="faint">
    Constants used: <span class="mono">q = 1.602176634×10^-19 C</span>,
    <span class="mono">h = 6.62607015×10^-34 J·s</span>,
    <span class="mono">c = 2.99792458×10^8 m/s</span>.
    <br/>
    This article assumes a shot-noise-limited PIN photodiode receiver with no circuit (thermal/amplifier) noise.
  </div>
</footer>

<script>
(function(){
  // ---------- Constants ----------
  const q = 1.602176634e-19;   // C
  const h = 6.62607015e-34;    // J*s
  const c = 2.99792458e8;      // m/s

  // ---------- DOM ----------
  const setupCanvas = document.getElementById('setupCanvas');
  const mainPlot = document.getElementById('mainPlot');
  const sweepPlot = document.getElementById('sweepPlot');

  const Bslider = document.getElementById('Bslider');
  const etaslider = document.getElementById('etaslider');
  const lamslider = document.getElementById('lamslider');
  const snrslider = document.getElementById('snrslider');

  const Bval = document.getElementById('Bval');
  const etaval = document.getElementById('etaval');
  const lamval = document.getElementById('lamval');
  const snrval = document.getElementById('snrval');

  const metaB = document.getElementById('metaB');
  const metaeta = document.getElementById('metaeta');
  const metalambda = document.getElementById('metalambda');

  const Pnum = document.getElementById('Pnum');
  const Pwatts = document.getElementById('Pwatts');
  const copyFinal = document.getElementById('copyFinal');

  // ---------- Helpers ----------
  function fmtSI(x, unit){
    // simple engineering formatter
    const abs = Math.abs(x);
    const prefixes = [
      {p:1e-12, s:"p"},
      {p:1e-9,  s:"n"},
      {p:1e-6,  s:"µ"},
      {p:1e-3,  s:"m"},
      {p:1,     s:""},
      {p:1e3,   s:"k"},
      {p:1e6,   s:"M"},
      {p:1e9,   s:"G"}
    ];
    let best = prefixes[4];
    for(const pr of prefixes){
      if(abs >= pr.p && abs < pr.p*1000){ best = pr; break; }
      if(abs === 0){ best = prefixes[4]; break; }
      if(abs >= 1e9){ best = prefixes[prefixes.length-1]; }
      if(abs < 1e-12){ best = prefixes[0]; }
    }
    const v = x / best.p;
    const str = (Math.abs(v) >= 100) ? v.toFixed(0) : (Math.abs(v) >= 10 ? v.toFixed(1) : v.toFixed(2));
    return `${str} ${best.s}${unit}`;
  }

  function fmtExp(x, sig=3){
    if(x === 0) return "0";
    const e = Math.floor(Math.log10(Math.abs(x)));
    const m = x / Math.pow(10,e);
    return `${m.toFixed(sig-1)}×10^${e}`;
  }

  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

  function copyText(text){
    navigator.clipboard.writeText(text).then(()=>{
      // tiny visual feedback
      const old = document.activeElement;
      if(old && old.classList && old.classList.contains('copybtn')){
        old.textContent = "Copied!";
        setTimeout(()=> old.textContent = "Copy", 900);
      }
    }).catch(()=>{});
  }

  document.querySelectorAll('[data-copy]').forEach(btn=>{
    btn.addEventListener('click', ()=> copyText(btn.getAttribute('data-copy')));
  });

  // ---------- Canvas DPR scaling ----------
  function setupHiDPI(canvas){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(2, Math.floor(rect.width * dpr));
    const h = Math.max(2, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
    }
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return ctx;
  }

  // ---------- Plotting utilities ----------
  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
    const {x,y,w,h} = box;
    ctx.save();
    ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);

    // Background subtle
    ctx.fillStyle = "rgba(255,255,255,0.02)";
    ctx.fillRect(x,y,w,h);

    // Title
    ctx.fillStyle = "rgba(233,238,246,0.92)";
    ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(title, x+10, y+18);

    // Plot area
    const pad = {l:56, r:18, t:30, b:44};
    const px = x+pad.l, py = y+pad.t, pw = w-pad.l-pad.r, ph = h-pad.t-pad.b;

    // Grid
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;

    const nGrid = 6;
    for(let i=0;i<=nGrid;i++){
      const gx = px + (pw*i/nGrid);
      const gy = py + (ph*i/nGrid);
      ctx.beginPath(); ctx.moveTo(gx,py); ctx.lineTo(gx,py+ph); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(px,gy); ctx.lineTo(px+pw,gy); ctx.stroke();
    }

    // Axes border
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.strokeRect(px,py,pw,ph);

    // Ticks and labels
    ctx.fillStyle = "rgba(183,196,214,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";

    // x ticks
    for(let i=0;i<=nGrid;i++){
      const t = i/nGrid;
      const xv = xMin + t*(xMax-xMin);
      const gx = px + t*pw;
      ctx.beginPath();
      ctx.moveTo(gx, py+ph);
      ctx.lineTo(gx, py+ph+6);
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.stroke();
      const lbl = (Math.abs(xv) >= 1e6 || Math.abs(xv) < 1e-3) ? fmtExp(xv,2) : xv.toPrecision(3);
      ctx.fillText(lbl, gx-16, py+ph+20);
    }

    // y ticks
    for(let i=0;i<=nGrid;i++){
      const t = 1 - i/nGrid;
      const yv = yMin + t*(yMax-yMin);
      const gy = py + i*ph/nGrid;
      ctx.beginPath();
      ctx.moveTo(px-6, gy);
      ctx.lineTo(px, gy);
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.stroke();
      const lbl = (Math.abs(yv) >= 1e6 || Math.abs(yv) < 1e-3) ? fmtExp(yv,2) : yv.toPrecision(3);
      ctx.fillText(lbl, px-52, gy+4);
    }

    // Axis labels
    ctx.fillStyle = "rgba(233,238,246,0.90)";
    ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(xLabel, px + pw/2 - ctx.measureText(xLabel).width/2, y + h - 12);

    ctx.save();
    ctx.translate(x+14, py+ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
    ctx.restore();

    ctx.restore();

    function xMap(xv){ return px + (xv-xMin)/(xMax-xMin)*pw; }
    function yMap(yv){ return py + (1-(yv-yMin)/(yMax-yMin))*ph; }

    return {px,py,pw,ph,xMap,yMap,pad};
  }

  function drawLine(ctx, map, xs, ys, strokeStyle){
    ctx.save();
    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<xs.length;i++){
      const X = map.xMap(xs[i]);
      const Y = map.yMap(ys[i]);
      if(i===0) ctx.moveTo(X,Y);
      else ctx.lineTo(X,Y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawHLine(ctx, map, yVal, label){
    ctx.save();
    ctx.strokeStyle = "rgba(255,209,102,0.85)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,5]);
    ctx.beginPath();
    ctx.moveTo(map.px, map.yMap(yVal));
    ctx.lineTo(map.px+map.pw, map.yMap(yVal));
    ctx.stroke();
    ctx.setLineDash([]);

    // label
    const txt = label;
    ctx.fillStyle = "rgba(255,209,102,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(txt, map.px+10, map.yMap(yVal)-8);
    ctx.restore();
  }

  function drawVLine(ctx, map, xVal, label){
    ctx.save();
    ctx.strokeStyle = "rgba(124,242,200,0.85)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,5]);
    ctx.beginPath();
    ctx.moveTo(map.xMap(xVal), map.py);
    ctx.lineTo(map.xMap(xVal), map.py+map.ph);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = "rgba(124,242,200,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(label, map.xMap(xVal)+6, map.py+16);
    ctx.restore();
  }

  function drawLegend(ctx, x, y, items){
    ctx.save();
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const pad = 10;
    const lineH = 18;
    let w = 0;
    items.forEach(it => w = Math.max(w, ctx.measureText(it.label).width));
    w += 50;
    const h = pad*2 + lineH*items.length;
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.strokeStyle = "rgba(255,255,255,0.14)";
    ctx.lineWidth = 1;
    roundRect(ctx, x, y, w, h, 12);
    ctx.fill(); ctx.stroke();

    items.forEach((it, i)=>{
      const yy = y + pad + i*lineH + 6;
      ctx.strokeStyle = it.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x+12, yy);
      ctx.lineTo(x+30, yy);
      ctx.stroke();
      ctx.fillStyle = "rgba(233,238,246,0.92)";
      ctx.fillText(it.label, x+36, yy+4);
    });

    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  // ---------- Physics model ----------
  function responsivity(eta, lambda_m){
    return eta * q * lambda_m / (h * c); // A/W
  }

  function snrFromPower(P, eta, lambda_m, B){
    const R = responsivity(eta, lambda_m);
    const I = R * P;
    return I / (2*q*B); // SNR = I/(2 q B)
  }

  function requiredCurrent(B, SNR){
    return 2*q*B*SNR;
  }

  function requiredPower(eta, lambda_m, B, SNR){
    const R = responsivity(eta, lambda_m);
    return requiredCurrent(B,SNR) / R;
  }

  // ---------- Draw diagram ----------
  function drawDiagram(state){
    const ctx = setupHiDPI(setupCanvas);
    const w = setupCanvas.getBoundingClientRect().width;
    const hpx = setupCanvas.getBoundingClientRect().height;

    ctx.clearRect(0,0,w,hpx);

    // Background
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.fillRect(0,0,w,hpx);

    // Title
    ctx.fillStyle = "rgba(233,238,246,0.92)";
    ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Physical Setup (Shot-Noise-Limited Photodiode Receiver)", 12, 20);

    // Draw optical beam arrow
    const x0 = 40, y0 = 110;
    const x1 = w*0.42, y1 = 110;

    ctx.strokeStyle = "rgba(138,180,255,0.9)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(x1,y1);
    ctx.stroke();

    // Arrow head
    ctx.fillStyle = "rgba(138,180,255,0.9)";
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x1-14,y1-7);
    ctx.lineTo(x1-14,y1+7);
    ctx.closePath();
    ctx.fill();

    // Label beam
    ctx.fillStyle = "rgba(183,196,214,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(`Optical input: P (W), λ = ${state.lambda_nm.toFixed(0)} nm`, x0, y0-18);

    // Photodiode block
    const pdx = w*0.42, pdy = 70, pdw = w*0.22, pdh = 80;
    ctx.fillStyle = "rgba(124,242,200,0.10)";
    ctx.strokeStyle = "rgba(124,242,200,0.45)";
    ctx.lineWidth = 2;
    roundRect(ctx, pdx, pdy, pdw, pdh, 16);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = "rgba(233,238,246,0.92)";
    ctx.font = "700 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Photodiode", pdx+14, pdy+26);
    ctx.fillStyle = "rgba(183,196,214,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(`QE η = ${state.eta.toFixed(2)}`, pdx+14, pdy+46);
    ctx.fillText(`R = η q λ/(h c)`, pdx+14, pdy+64);

    // Current arrow out
    const cx0 = pdx+pdw, cy0 = pdy+pdh/2;
    const cx1 = w*0.88,  cy1 = cy0;
    ctx.strokeStyle = "rgba(124,242,200,0.9)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(cx0,cy0);
    ctx.lineTo(cx1,cy1);
    ctx.stroke();
    ctx.fillStyle = "rgba(124,242,200,0.9)";
    ctx.beginPath();
    ctx.moveTo(cx1,cy1);
    ctx.lineTo(cx1-14,cy1-7);
    ctx.lineTo(cx1-14,cy1+7);
    ctx.closePath();
    ctx.fill();

    // Measurement block
    const mx = w*0.70, my = 190, mw = w*0.23, mh = 110;
    ctx.fillStyle = "rgba(255,255,255,0.05)";
    ctx.strokeStyle = "rgba(255,255,255,0.14)";
    ctx.lineWidth = 2;
    roundRect(ctx, mx, my, mw, mh, 16);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = "rgba(233,238,246,0.92)";
    ctx.font = "700 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Current measurement", mx+12, my+26);
    ctx.fillStyle = "rgba(183,196,214,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(`Bandwidth B = ${fmtSI(state.B, "Hz")}`, mx+12, my+48);
    ctx.fillText(`Signal: I = R P`, mx+12, my+66);
    ctx.fillText(`Noise: ⟨i_n^2⟩ = 2 q I B`, mx+12, my+84);
    ctx.fillText(`SNR = I/(2 q B)`, mx+12, my+102);

    // Label current
    const R = responsivity(state.eta, state.lambda_m);
    const Ireq = requiredCurrent(state.B, state.SNR);
    ctx.fillStyle = "rgba(183,196,214,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(`Measured current i(t) = I + noise`, cx0+12, cy0-16);
    ctx.fillText(`(For target SNR: I_req ≈ ${fmtSI(Ireq, "A")})`, cx0+12, cy0+18);

    // Small note
    ctx.fillStyle = "rgba(127,147,173,0.95)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Assumption: no circuit/thermal/amplifier noise → shot noise dominates.", 12, hpx-16);
  }

  // ---------- Draw main plot: SNR vs P ----------
  function drawMainPlot(state){
    const ctx = setupHiDPI(mainPlot);
    const w = mainPlot.getBoundingClientRect().width;
    const hpx = mainPlot.getBoundingClientRect().height;

    // Choose x-range around required power
    const Preq = requiredPower(state.eta, state.lambda_m, state.B, state.SNR);
    const xMin = 0;
    const xMax = Math.max(Preq*3.0, 1e-11);
    const yMin = 0;
    const yMax = Math.max(state.SNR*1.4, 10);

    const map = drawAxes(
      ctx,
      {x:0,y:0,w:w,h:hpx},
      xMin, xMax, yMin, yMax,
      "Optical power P (W)",
      "SNR (dimensionless)",
      "SNR vs Optical Power (Shot-Noise Limited)"
    );

    // Generate curve
    const N = 220;
    const xs = new Array(N);
    const ys = new Array(N);
    for(let i=0;i<N;i++){
      const P = xMin + (xMax-xMin)*i/(N-1);
      xs[i]=P;
      ys[i]=snrFromPower(P, state.eta, state.lambda_m, state.B);
    }

    drawLine(ctx, map, xs, ys, "rgba(138,180,255,0.95)");

    // Target SNR line and required power marker
    drawHLine(ctx, map, state.SNR, `Target SNR = ${state.SNR.toExponential(2)}`);
    drawVLine(ctx, map, Preq, `P_req = ${fmtExp(Preq,3)} W`);

    // Mark intersection point
    const ix = map.xMap(Preq), iy = map.yMap(state.SNR);
    ctx.save();
    ctx.fillStyle = "rgba(124,242,200,0.95)";
    ctx.beginPath();
    ctx.arc(ix, iy, 5, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    drawLegend(ctx, map.px + map.pw - 210, map.py + 10, [
      {label:"SNR(P) curve", color:"rgba(138,180,255,0.95)"},
      {label:"Target / P_req markers", color:"rgba(124,242,200,0.95)"}
    ]);
  }

  // ---------- Draw sweep plot: P_req vs B ----------
  function drawSweepPlot(state){
    const ctx = setupHiDPI(sweepPlot);
    const w = sweepPlot.getBoundingClientRect().width;
    const hpx = sweepPlot.getBoundingClientRect().height;

    // Sweep bandwidth from 1 MHz to 1 GHz (fixed eta, lambda, SNR)
    const Bmin = 1e6, Bmax = 1e9;
    const N = 240;
    const Bs = new Array(N);
    const Ps = new Array(N);
    let Pmax = 0;

    for(let i=0;i<N;i++){
      const t = i/(N-1);
      // log sweep for bandwidth
      const B = Bmin * Math.pow(Bmax/Bmin, t);
      const P = requiredPower(state.eta, state.lambda_m, B, state.SNR);
      Bs[i]=B; Ps[i]=P;
      if(P>Pmax) Pmax=P;
    }

    const xMin = Bmin;
    const xMax = Bmax;
    const yMin = 0;
    const yMax = Pmax*1.10;

    // Custom axes: we'll still label in Hz and W, but ticks will be log-ish in x.
    // We'll implement our own mapping to make x log scale.
    ctx.save();
    ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
    ctx.fillStyle = "rgba(255,255,255,0.02)";
    ctx.fillRect(0,0,w,hpx);

    // Title
    ctx.fillStyle = "rgba(233,238,246,0.92)";
    ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Required Optical Power vs Bandwidth (Sweep)", 10, 18);

    const pad = {l:70, r:18, t:30, b:44};
    const px = pad.l, py = pad.t, pw = w-pad.l-pad.r, ph = hpx-pad.t-pad.b;

    // Grid
    const nGrid = 6;
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;
    for(let i=0;i<=nGrid;i++){
      const gx = px + (pw*i/nGrid);
      const gy = py + (ph*i/nGrid);
      ctx.beginPath(); ctx.moveTo(gx,py); ctx.lineTo(gx,py+ph); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(px,gy); ctx.lineTo(px+pw,gy); ctx.stroke();
    }

    // Border
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.strokeRect(px,py,pw,ph);

    function xMapLog(B){
      const t = Math.log(B/xMin)/Math.log(xMax/xMin);
      return px + t*pw;
    }
    function yMap(P){
      return py + (1-(P-yMin)/(yMax-yMin))*ph;
    }

    // Ticks: x at decades (1e6, 1e7, 1e8, 1e9)
    ctx.fillStyle = "rgba(183,196,214,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    const decades = [1e6, 1e7, 1e8, 1e9];
    decades.forEach(B=>{
      const X = xMapLog(B);
      ctx.beginPath();
      ctx.moveTo(X, py+ph);
      ctx.lineTo(X, py+ph+6);
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.stroke();
      ctx.fillText(fmtExp(B,2)+" Hz", X-30, py+ph+20);
    });

    // y ticks
    for(let i=0;i<=nGrid;i++){
      const t = 1 - i/nGrid;
      const Pv = yMin + t*(yMax-yMin);
      const Y = py + i*ph/nGrid;
      ctx.beginPath();
      ctx.moveTo(px-6, Y);
      ctx.lineTo(px, Y);
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.stroke();
      const lbl = fmtExp(Pv,2);
      ctx.fillText(lbl, px-64, Y+4);
    }

    // Axis labels
    ctx.fillStyle = "rgba(233,238,246,0.90)";
    ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const xLab = "Bandwidth B (Hz, log scale)";
    ctx.fillText(xLab, px + pw/2 - ctx.measureText(xLab).width/2, hpx - 12);

    ctx.save();
    ctx.translate(16, py+ph/2);
    ctx.rotate(-Math.PI/2);
    const yLab = "Required optical power P_req (W)";
    ctx.fillText(yLab, -ctx.measureText(yLab).width/2, 0);
    ctx.restore();

    // Curve
    ctx.strokeStyle = "rgba(124,242,200,0.95)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<N;i++){
      const X = xMapLog(Bs[i]);
      const Y = yMap(Ps[i]);
      if(i===0) ctx.moveTo(X,Y);
      else ctx.lineTo(X,Y);
    }
    ctx.stroke();

    // Marker at current B
    const Pnow = requiredPower(state.eta, state.lambda_m, state.B, state.SNR);
    const Xn = xMapLog(clamp(state.B, xMin, xMax));
    const Yn = yMap(Pnow);
    ctx.fillStyle = "rgba(138,180,255,0.95)";
    ctx.beginPath(); ctx.arc(Xn, Yn, 5, 0, Math.PI*2); ctx.fill();

    // Label marker
    ctx.fillStyle = "rgba(138,180,255,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(`Selected: B=${fmtSI(state.B,"Hz")}, P_req=${fmtExp(Pnow,3)} W`, px+10, py+16);

    // Legend
    drawLegend(ctx, px + pw - 240, py + 10, [
      {label:"P_req(B) sweep", color:"rgba(124,242,200,0.95)"},
      {label:"Current selection", color:"rgba(138,180,255,0.95)"}
    ]);

    ctx.restore();
  }

  // ---------- State + update ----------
  function getState(){
    const B_MHz = parseFloat(Bslider.value);
    const eta = parseFloat(etaslider.value);
    const lambda_nm = parseFloat(lamslider.value);
    const log10SNR = parseFloat(snrslider.value);
    const SNR = Math.pow(10, log10SNR);

    return {
      B: B_MHz * 1e6,
      eta,
      lambda_nm,
      lambda_m: lambda_nm * 1e-9,
      SNR
    };
  }

  function updateUI(state){
    // control readouts
    Bval.textContent = `${state.B/1e6.toFixed ? "" : ""}${(state.B/1e6).toFixed(0)} MHz`;
    etaval.textContent = state.eta.toFixed(2);
    lamval.textContent = `${state.lambda_nm.toFixed(0)} nm`;
    snrval.textContent = state.SNR.toExponential(2);

    // meta pills
    metaB.textContent = `${(state.B/1e6).toFixed(0)} MHz`;
    metaeta.textContent = state.eta.toFixed(2);
    metalambda.textContent = `${state.lambda_nm.toFixed(0)} nm`;

    // final numbers
    const Preq = requiredPower(state.eta, state.lambda_m, state.B, state.SNR);
    const Preq_nW = Preq * 1e9;

    Pnum.textContent = (Preq_nW >= 100 ? Preq_nW.toFixed(0) : (Preq_nW >= 10 ? Preq_nW.toFixed(1) : Preq_nW.toFixed(2)));
    Pwatts.textContent = fmtExp(Preq,3);

    const finalText =
`Shot-noise-limited analog receiver sensitivity (current measurement):
Given η=${state.eta.toFixed(2)}, λ=${state.lambda_nm.toFixed(0)} nm, B=${(state.B/1e6).toFixed(0)} MHz, target SNR=${state.SNR.toExponential(2)}:
P_req = (2 h c B SNR)/(η λ) = ${fmtExp(Preq,3)} W ≈ ${(Preq*1e9).toFixed(2)} nW.`;
    copyFinal.setAttribute('data-copy', finalText);
  }

  function redraw(){
    const state = getState();
    updateUI(state);
    drawDiagram(state);
    drawMainPlot(state);
    drawSweepPlot(state);
  }

  // Resize handling
  const ro = new ResizeObserver(()=> redraw());
  ro.observe(setupCanvas);
  ro.observe(mainPlot);
  ro.observe(sweepPlot);

  // Input listeners
  [Bslider, etaslider, lamslider, snrslider].forEach(el=>{
    el.addEventListener('input', redraw);
  });

  // Copy final button
  copyFinal.addEventListener('click', ()=> copyText(copyFinal.getAttribute('data-copy') || ""));

  // Initial render
  redraw();
})();
</script>
</body>
</html>
