<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Quantum Efficiency & Responsivity of a Photodiode (1550 nm)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:rgba(255,255,255,0.06);
      --panel2:rgba(255,255,255,0.085);
      --text:rgba(255,255,255,0.92);
      --muted:rgba(255,255,255,0.72);
      --faint:rgba(255,255,255,0.55);
      --line:rgba(255,255,255,0.14);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 18px 60px rgba(0,0,0,0.45);
      --radius: 18px;
      --radius2: 22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1100px 700px at 18% 12%, rgba(125,211,252,0.18), transparent 55%),
        radial-gradient(900px 650px at 82% 18%, rgba(167,139,250,0.16), transparent 52%),
        radial-gradient(900px 700px at 60% 88%, rgba(52,211,153,0.10), transparent 52%),
        linear-gradient(180deg, #070a14, #0b1020 40%, #070a14);
      line-height:1.55;
      overflow-x:hidden;
    }

    a{ color:var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }

    header{
      padding: clamp(18px, 2.8vw, 34px);
      padding-bottom: 10px;
      max-width: 1180px;
      margin: 0 auto;
    }

    .hero{
      display:grid;
      grid-template-columns: 1.25fr 0.75fr;
      gap:18px;
      align-items:stretch;
    }

    .titleCard{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.05));
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      padding: 18px 18px 14px;
      position:relative;
      overflow:hidden;
    }
    .titleCard:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(600px 220px at 30% 0%, rgba(125,211,252,0.22), transparent 70%),
                  radial-gradient(520px 220px at 85% 10%, rgba(167,139,250,0.18), transparent 70%);
      opacity:0.9;
      pointer-events:none;
      filter: blur(0px);
    }
    .titleCard > *{ position:relative; }
    h1{
      margin:0 0 8px 0;
      font-size: clamp(22px, 2.3vw, 34px);
      letter-spacing:-0.02em;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size: 0.98rem;
    }
    .metaRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:12px;
    }
    .pill{
      border:1px solid var(--line);
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.86rem;
      display:inline-flex;
      gap:8px;
      align-items:center;
      white-space:nowrap;
    }
    .pill b{ color:var(--text); font-weight:650; }
    .asideCard{
      border:1px solid var(--line);
      background: rgba(255,255,255,0.05);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height: 100%;
    }
    .mini{
      color:var(--muted);
      font-size: 0.92rem;
      margin:0;
    }

    main{
      max-width: 1180px;
      margin: 0 auto;
      padding: 0 clamp(18px, 2.8vw, 34px) 34px;
    }

    .layout{
      display:grid;
      grid-template-columns: 280px 1fr;
      gap: 18px;
      align-items:start;
    }

    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      border:1px solid var(--line);
      background: rgba(255,255,255,0.05);
      border-radius: var(--radius);
      padding: 12px;
      box-shadow: 0 12px 38px rgba(0,0,0,0.32);
      backdrop-filter: blur(8px);
    }
    .toc h2{
      font-size: 0.95rem;
      margin: 0 0 8px 0;
      letter-spacing: 0.01em;
      color: var(--text);
    }
    .toc a{
      display:block;
      padding: 7px 10px;
      border-radius: 12px;
      color: var(--muted);
      font-size: 0.92rem;
      border: 1px solid transparent;
      transition: transform 150ms ease, background 150ms ease, border-color 150ms ease;
    }
    .toc a:hover{
      background: rgba(255,255,255,0.06);
      border-color: rgba(255,255,255,0.12);
      transform: translateX(2px);
    }
    .toc a.active{
      background: rgba(125,211,252,0.12);
      border-color: rgba(125,211,252,0.25);
      color: var(--text);
    }

    section{
      border:1px solid var(--line);
      background: rgba(255,255,255,0.04);
      border-radius: var(--radius2);
      padding: 16px;
      box-shadow: 0 14px 46px rgba(0,0,0,0.32);
      margin-bottom: 18px;
      overflow:hidden;
    }

    section h2{
      margin: 0 0 10px 0;
      font-size: 1.22rem;
      letter-spacing:-0.01em;
    }
    section h3{
      margin: 14px 0 8px 0;
      font-size: 1.05rem;
      color: var(--text);
    }
    p{ margin: 10px 0; color: var(--muted); }
    ul{ margin: 8px 0 10px 22px; color: var(--muted); }
    li{ margin: 6px 0; }
    strong{ color: var(--text); }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      .hero{ grid-template-columns: 1fr; }
      .layout{ grid-template-columns: 1fr; }
      nav.toc{ position:relative; top:0; }
      .grid2, .grid3{ grid-template-columns: 1fr; }
    }

    .callout{
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.055);
      border-radius: var(--radius);
      padding: 12px;
      margin: 10px 0;
    }
    .callout .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size: 0.84rem;
      letter-spacing:0.02em;
      text-transform:uppercase;
      color: var(--faint);
      margin-bottom: 6px;
    }
    .tagDot{
      width:10px;height:10px;border-radius:999px;background: var(--accent);
      box-shadow: 0 0 0 3px rgba(125,211,252,0.18);
    }
    .callout.good .tagDot{ background: var(--good); box-shadow:0 0 0 3px rgba(52,211,153,0.18); }
    .callout.warn .tagDot{ background: var(--warn); box-shadow:0 0 0 3px rgba(251,191,36,0.18); }
    .callout.bad  .tagDot{ background: var(--bad);  box-shadow:0 0 0 3px rgba(251,113,133,0.18); }

    .eq{
      background: rgba(0,0,0,0.28);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 14px;
      padding: 10px 10px;
      font-family: var(--mono);
      color: rgba(255,255,255,0.88);
      overflow:auto;
      position:relative;
    }
    .eq small{
      display:block;
      font-family: var(--sans);
      color: var(--faint);
      margin-top: 6px;
    }
    .copyBtn{
      position:absolute;
      right: 8px; top: 8px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.82rem;
      cursor:pointer;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      user-select:none;
    }
    .copyBtn:hover{
      background: rgba(255,255,255,0.10);
      border-color: rgba(255,255,255,0.22);
      transform: translateY(-1px);
    }
    .copyToast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.75);
      border:1px solid rgba(255,255,255,0.16);
      color: rgba(255,255,255,0.92);
      padding: 10px 12px;
      border-radius: 999px;
      opacity:0;
      pointer-events:none;
      transition: opacity 180ms ease, transform 180ms ease;
      font-size: 0.92rem;
      z-index: 50;
      backdrop-filter: blur(8px);
    }
    .copyToast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-2px);
    }

    figure{
      margin:0;
    }
    .canvasWrap{
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.24);
      border-radius: var(--radius2);
      padding: 10px;
      overflow:hidden;
    }
    .canvasTitleRow{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      margin: 2px 2px 10px;
    }
    .canvasTitleRow h3{
      margin:0;
      font-size: 1.02rem;
    }
    .canvasTitleRow .hint{
      margin:0;
      color: var(--faint);
      font-size: 0.9rem;
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
      border-radius: 14px;
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    @media (max-width: 980px){
      canvas{ height: 300px; }
      .controls{ grid-template-columns: 1fr; }
    }
    .control{
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.05);
      border-radius: 16px;
      padding: 10px 10px 8px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size: 0.92rem;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .control label b{
      color: var(--text);
      font-weight: 650;
    }
    input[type="range"]{ width:100%; }
    .readout{
      font-family: var(--mono);
      color: rgba(255,255,255,0.88);
      font-size: 0.92rem;
    }

    .finalBox{
      border: 1px solid rgba(52,211,153,0.30);
      background: linear-gradient(180deg, rgba(52,211,153,0.13), rgba(255,255,255,0.04));
      border-radius: var(--radius2);
      padding: 12px;
      margin-top: 10px;
      position: relative;
      overflow:hidden;
    }
    .finalBox:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(420px 240px at 18% 10%, rgba(52,211,153,0.22), transparent 70%);
      pointer-events:none;
      opacity:0.9;
    }
    .finalBox > *{ position:relative; }
    .finalBox h3{ margin:0 0 6px 0; }
    .finalGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 8px;
    }
    @media (max-width: 700px){
      .finalGrid{ grid-template-columns: 1fr; }
    }

    footer{
      max-width: 1180px;
      margin: 0 auto;
      padding: 0 clamp(18px, 2.8vw, 34px) 36px;
      color: var(--faint);
      font-size: 0.92rem;
    }

    /* Print-friendly */
    @media print{
      body{ background:#fff; color:#000; }
      header, main, footer{ max-width: 100%; }
      nav.toc{ display:none; }
      section, .titleCard, .asideCard, .canvasWrap, .callout, .eq, .finalBox{
        box-shadow:none !important;
        background:#fff !important;
        border:1px solid #bbb !important;
      }
      .copyBtn, .copyToast, .controls{ display:none !important; }
      p, li{ color:#000 !important; }
      .pill{ background:#fff !important; color:#000 !important; border:1px solid #bbb !important; }
      a{ color:#000 !important; text-decoration:underline; }
      canvas{ height: 260px !important; }
    }
  </style>
</head>

<body>
  <header>
    <div class="hero">
      <div class="titleCard">
        <h1>Quantum Efficiency & Responsivity of a p–i–n Photodiode (1550 nm)</h1>
        <p class="subtitle">
          From a photon-counting perspective: how many collected electrons do you get per incident photon, and what current-per-optical-power results?
        </p>
        <div class="metaRow">
          <span class="pill"><b>Device:</b> p–i–n photodiode</span>
          <span class="pill"><b>Wavelength:</b> 1550 nm</span>
          <span class="pill"><b>Given:</b> 6×10<sup>12</sup> photons → 2×10<sup>12</sup> electrons</span>
        </div>
      </div>

      <div class="asideCard">
        <p class="mini"><strong>What you’ll learn</strong></p>
        <ul>
          <li>How <strong>quantum efficiency</strong> relates carrier collection to photon incidence</li>
          <li>How <strong>responsivity</strong> converts optical power into photocurrent</li>
          <li>Why wavelength matters via <em>photon energy</em> (E = hc/λ)</li>
        </ul>
        <div class="callout good" style="margin:0;">
          <div class="tag"><span class="tagDot"></span>Key takeaway</div>
          <p style="margin:0;">
            For fixed quantum efficiency, responsivity grows <strong>linearly with wavelength</strong>:
            longer λ → lower photon energy → more photons per watt → more electrons per watt.
          </p>
        </div>
      </div>
    </div>
  </header>

  <main>
    <div class="layout">
      <nav class="toc" aria-label="Table of contents">
        <h2>On this page</h2>
        <a href="#quick" class="toclink">Quick Summary</a>
        <a href="#part0" class="toclink">PART 0 — Concept Primer</a>
        <a href="#part1" class="toclink">PART 1 — Problem Analysis</a>
        <a href="#part2" class="toclink">PART 2 — Strategy & Tips</a>
        <a href="#part3" class="toclink">PART 3 — Full Solution</a>
        <a href="#part4" class="toclink">PART 4 — Deeper Understanding</a>
        <a href="#part5" class="toclink">PART 5 — Visualization Guide</a>
      </nav>

      <article>
        <!-- Quick Summary -->
        <section id="quick">
          <h2>Quick Summary</h2>
          <ul>
            <li><strong>Problem:</strong> A p–i–n photodiode receives <span class="readout">6×10<sup>12</sup></span> photons at <span class="readout">1550 nm</span> and yields <span class="readout">2×10<sup>12</sup></span> collected electrons.</li>
            <li><strong>Key idea:</strong> <em>Quantum efficiency</em> is the probability an incident photon produces a collected electron.</li>
            <li><strong>Definition:</strong> <span class="readout">η = N<sub>e</sub>/N<sub>ph</sub></span> (dimensionless).</li>
            <li><strong>Responsivity:</strong> <span class="readout">R = I/P</span> (A/W), with <span class="readout">R = η q / (hν) = η q λ/(hc)</span>.</li>
            <li><strong>Numeric result type:</strong> both η and R are computed <strong>numerically</strong> from the given counts and wavelength.</li>
            <li><strong>Final results (at 1550 nm):</strong> <span class="readout">η ≈ 0.333</span>, <span class="readout">R ≈ 0.417 A/W</span>.</li>
          </ul>
        </section>

        <!-- PART 0 -->
        <section id="part0">
          <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

          <h3>Core definitions (symbols & units)</h3>
          <ul>
            <li><strong>Incident photon number</strong> <span class="readout">N<sub>ph</sub></span> (photons): total photons hitting the detector during the pulse.</li>
            <li><strong>Collected electron number</strong> <span class="readout">N<sub>e</sub></span> (electrons): total electrons that reach the external circuit (terminals).</li>
            <li><strong>Quantum efficiency</strong> <span class="readout">η</span> (dimensionless): fraction/probability that an incident photon results in a collected electron.</li>
            <li><strong>Responsivity</strong> <span class="readout">R</span> (A/W): photocurrent per incident optical power.</li>
            <li><strong>Photon energy</strong> <span class="readout">E<sub>ph</sub> = hν = hc/λ</span> (J): energy carried by one photon.</li>
            <li>Constants: electron charge <span class="readout">q</span> (C), Planck constant <span class="readout">h</span> (J·s), speed of light <span class="readout">c</span> (m/s).</li>
          </ul>

          <h3>Physical meaning: what these quantities represent</h3>
          <p>
            A photodiode converts light into electrical carriers. Each absorbed photon can create (at most) one electron–hole pair in a simple p–i–n photodiode (no internal gain).
            <strong>Quantum efficiency</strong> measures how effectively photons become <em>collected carriers</em> in the external circuit (not just generated carriers inside the material).
          </p>
          <p>
            <strong>Responsivity</strong> answers a practical question: if I shine a certain optical power (watts) on the photodiode, what photocurrent (amps) do I get?
            It combines quantum efficiency with photon energy: fewer joules per photon at longer wavelengths means <em>more photons per watt</em>, so responsivity tends to increase with wavelength (for fixed η).
          </p>

          <div class="callout">
            <div class="tag"><span class="tagDot"></span>Key equations</div>
            <div class="eq" data-copy="eta = Ne / Nph">
              <button class="copyBtn" type="button" data-copy-btn>Copy</button>
              η = N_e / N_ph
              <small>Quantum efficiency: collected electrons per incident photon (dimensionless).</small>
            </div>
            <div class="eq" style="margin-top:10px;" data-copy="R = I / P = eta*q/(h*nu) = eta*q*lambda/(h*c)">
              <button class="copyBtn" type="button" data-copy-btn>Copy</button>
              R = I/P = η q/(hν) = η q λ/(hc)
              <small>Responsivity: current per optical power (A/W). Valid when each absorbed photon yields ≤1 collected electron (no gain).</small>
            </div>
          </div>

          <h3>Key laws/principles & validity conditions</h3>
          <ul>
            <li><strong>Photon energy relation:</strong> <span class="readout">E = hν = hc/λ</span> (always valid for photons).</li>
            <li><strong>Charge from collected electrons:</strong> total collected charge <span class="readout">Q = N<sub>e</sub> q</span>.</li>
            <li><strong>Linear photodetection regime:</strong> assumes the photodiode response is linear (no saturation, no space-charge limitation) and no internal multiplication (p–i–n, not APD).</li>
            <li><strong>Uniform collection concept:</strong> “collected at terminals” already includes internal losses (reflection, incomplete absorption, recombination, transport loss).</li>
          </ul>

          <h3>Common models/approximations (and why we use them)</h3>
          <ul>
            <li><strong>One-photon → one e–h pair</strong> model: simplest photodiode model without gain. Great for p–i–n diodes and many receiver calculations.</li>
            <li><strong>Constant η at a given λ</strong>: we treat quantum efficiency as a single number at 1550 nm, bundling multiple microscopic processes into one effective parameter.</li>
            <li><strong>Steady conversion for responsivity</strong>: responsivity is typically defined for continuous-wave power, but applies to pulses via average power (or energy) as long as linearity holds.</li>
          </ul>

          <h3>Mini intuition examples (conceptual)</h3>
          <ul>
            <li>If <span class="readout">η = 1</span>, then every photon yields one collected electron: maximum “no-gain” conversion. Responsivity is then <span class="readout">R_max = qλ/(hc)</span>.</li>
            <li>If η stays the same but λ increases, photon energy decreases, so one watt contains more photons. That tends to increase R linearly with λ.</li>
          </ul>

          <div class="callout warn">
            <div class="tag"><span class="tagDot"></span>What to watch for (pitfalls)</div>
            <ul style="margin:6px 0 0 18px;">
              <li><strong>Confusing “generated” vs “collected” carriers:</strong> η here uses <em>collected electrons at terminals</em>.</li>
              <li><strong>Mixing units:</strong> λ must be in meters in <span class="readout">R = η q λ/(hc)</span>.</li>
              <li><strong>Assuming η must be 1:</strong> real devices lose photons to reflection, transmission, or recombination → η &lt; 1.</li>
              <li><strong>APD vs p–i–n:</strong> if there were gain, effective “η” could exceed 1; here it should not.</li>
            </ul>
          </div>
        </section>

        <!-- PART 1 -->
        <section id="part1">
          <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

          <h3>Problem restatement (in plain words)</h3>
          <p>
            A p–i–n photodiode is hit by a light pulse containing a known number of photons at wavelength 1550 nm.
            On average, a known number of electrons are collected at the device terminals. We must compute:
            (1) the <strong>quantum efficiency</strong> η and (2) the <strong>responsivity</strong> R at 1550 nm.
          </p>

          <div class="grid2">
            <div class="callout">
              <div class="tag"><span class="tagDot"></span>Given</div>
              <ul style="margin:6px 0 0 18px;">
                <li><span class="readout">N<sub>ph</sub> = 6 × 10<sup>12</sup></span> photons</li>
                <li><span class="readout">λ = 1550 nm</span></li>
                <li><span class="readout">N<sub>e</sub> = 2 × 10<sup>12</sup></span> collected electrons</li>
              </ul>
            </div>

            <div class="callout">
              <div class="tag"><span class="tagDot"></span>Unknowns</div>
              <ul style="margin:6px 0 0 18px;">
                <li><span class="readout">η</span> (dimensionless)</li>
                <li><span class="readout">R</span> (A/W)</li>
              </ul>
            </div>
          </div>

          <h3>Relevant principles (and why they apply)</h3>
          <ul>
            <li><strong>Electron counting definition of η</strong> applies because we are given photon number and collected electron number directly.</li>
            <li><strong>Responsivity relation</strong> applies because responsivity is essentially “electrons per joule,” i.e. it combines η with photon energy <span class="readout">hc/λ</span>.</li>
            <li>We do <strong>not</strong> need semiconductor band-structure details, depletion width, or absorption coefficient because the problem provides the net collected-electron count already (a device-level measurement).</li>
          </ul>

          <div class="callout">
            <div class="tag"><span class="tagDot"></span>Assumptions</div>
            <ul style="margin:6px 0 0 18px;">
              <li><strong>Linear regime:</strong> collected electrons scale proportionally with photon number (no saturation).</li>
              <li><strong>No internal gain:</strong> p–i–n photodiode (not an avalanche photodiode), so typically <span class="readout">0 ≤ η ≤ 1</span>.</li>
              <li><strong>Monochromatic pulse:</strong> wavelength is effectively 1550 nm for all photons.</li>
            </ul>
          </div>

          <h3>Possible approaches (compare briefly)</h3>
          <ul>
            <li><strong>Approach A (counting method):</strong> use η = N<sub>e</sub>/N<sub>ph</sub>, then R = η q λ/(hc). <em>Fast, uses given data directly; best here.</em></li>
            <li><strong>Approach B (energy method):</strong> compute pulse energy E = N<sub>ph</sub>hc/λ, compute collected charge Q = N<sub>e</sub>q, then infer R = Q/E (gives A/W equivalently). <em>Also valid; good for checking.</em></li>
            <li><strong>Approach C (device physics model):</strong> model absorption + reflection + collection probability to predict η. <em>Overkill here because η is directly inferable from counts.</em></li>
          </ul>
          <p>
            <strong>Chosen approach:</strong> Approach A (counting) because it is direct, transparent, and minimizes unnecessary modeling assumptions.
          </p>
        </section>

        <!-- PART 2 -->
        <section id="part2">
          <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

          <ol style="color:var(--muted); margin: 8px 0 10px 22px;">
            <li>
              <strong>Goal:</strong> compute quantum efficiency.<br/>
              <strong>Tool:</strong> definition <span class="readout">η = N<sub>e</sub>/N<sub>ph</sub></span>.<br/>
              <strong>Meaning:</strong> probability a photon yields a collected electron.
            </li>
            <li>
              <strong>Goal:</strong> express responsivity in terms of η and wavelength.<br/>
              <strong>Tool:</strong> <span class="readout">R = η q λ/(hc)</span> derived from photon energy.<br/>
              <strong>Meaning:</strong> amps per watt for monochromatic light.
            </li>
            <li>
              <strong>Goal:</strong> plug in constants and λ (in meters).<br/>
              <strong>Tool:</strong> unit consistency; numeric substitution.<br/>
              <strong>Meaning:</strong> obtain R in A/W at 1550 nm.
            </li>
            <li>
              <strong>Goal:</strong> sanity checks.<br/>
              <strong>Tool:</strong> dimension check (A/W), limiting trends (R ∝ λ, R ∝ η).<br/>
              <strong>Meaning:</strong> verify the result is physically plausible.
            </li>
          </ol>

          <div class="callout warn">
            <div class="tag"><span class="tagDot"></span>Common mistakes & quick tips</div>
            <ul style="margin:6px 0 0 18px;">
              <li><strong>Tip:</strong> Always convert <span class="readout">1550 nm → 1.55×10<sup>−6</sup> m</span> before using <span class="readout">hc</span>.</li>
              <li><strong>Mistake:</strong> Using <span class="readout">R = η q/(hν)</span> but forgetting that <span class="readout">ν = c/λ</span>.</li>
              <li><strong>Tip:</strong> Compute an “ideal” responsivity at η=1, then scale by η. This is a fast self-check.</li>
            </ul>
          </div>
        </section>

        <!-- PART 3 -->
        <section id="part3">
          <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

          <h3>Physical intuition (before math)</h3>
          <p>
            If every photon produced a collected electron, the photodiode would have η = 1.
            Here we get fewer electrons (2×10<sup>12</sup>) than photons (6×10<sup>12</sup>), so η must be less than 1—specifically about one-third.
            Responsivity should then be about one-third of the “ideal” responsivity at 1550 nm.
          </p>

          <h3>Step 1 — Quantum efficiency from electron/photon counts</h3>
          <p>Define symbols:</p>
          <ul>
            <li><span class="readout">N<sub>ph</sub></span> = number of incident photons (photons)</li>
            <li><span class="readout">N<sub>e</sub></span> = number of collected electrons (electrons)</li>
            <li><span class="readout">η</span> = quantum efficiency (dimensionless)</li>
          </ul>

          <div class="eq" data-copy="eta = Ne / Nph">
            <button class="copyBtn" type="button" data-copy-btn>Copy</button>
            η = N_e / N_ph
          </div>

          <p>
            Substitute the given values:
            <span class="readout">N<sub>ph</sub> = 6×10<sup>12</sup></span>,
            <span class="readout">N<sub>e</sub> = 2×10<sup>12</sup></span>.
          </p>

          <div class="eq" data-copy="eta = (2e12) / (6e12) = 1/3 ≈ 0.333">
            <button class="copyBtn" type="button" data-copy-btn>Copy</button>
            η = (2×10^12) / (6×10^12) = 1/3 ≈ 0.333
            <small>We used the definition: “collected electrons per incident photon.”</small>
          </div>

          <h3>Step 2 — Derive responsivity in terms of η and λ</h3>
          <p>
            Responsivity is <span class="readout">R = I/P</span>. For a monochromatic beam:
            optical power <span class="readout">P</span> corresponds to a photon arrival rate
            <span class="readout">Φ = P/E<sub>ph</sub></span>, where photon energy is
            <span class="readout">E<sub>ph</sub> = hν = hc/λ</span>.
          </p>

          <p>
            If the photodiode collects a fraction η of those photons as electrons,
            the electron rate is <span class="readout">ηΦ</span> electrons/s. Multiplying by the electron charge q gives current:
          </p>

          <div class="eq" data-copy="I = (eta*Phi)*q = eta*(P/Eph)*q">
            <button class="copyBtn" type="button" data-copy-btn>Copy</button>
            I = (η Φ) q = η (P / E_ph) q
            <small>Current = (collected electrons per second) × (charge per electron).</small>
          </div>

          <p>
            Divide by P to get responsivity:
          </p>

          <div class="eq" data-copy="R = I/P = eta*q/Eph = eta*q/(h*nu) = eta*q*lambda/(h*c)">
            <button class="copyBtn" type="button" data-copy-btn>Copy</button>
            R = I/P = η q / E_ph = η q/(hν) = η q λ/(h c)
            <small>This is the standard responsivity relation for a photodiode without internal gain.</small>
          </div>

          <h3>Step 3 — Compute R at λ = 1550 nm</h3>
          <p>Convert wavelength to meters:</p>
          <div class="eq" data-copy="lambda = 1550 nm = 1550×10^-9 m = 1.55×10^-6 m">
            <button class="copyBtn" type="button" data-copy-btn>Copy</button>
            λ = 1550 nm = 1.55×10^-6 m
          </div>

          <p>Use constants (SI units):</p>
          <ul>
            <li><span class="readout">q = 1.602176634×10<sup>−19</sup> C</span></li>
            <li><span class="readout">h = 6.62607015×10<sup>−34</sup> J·s</span></li>
            <li><span class="readout">c = 2.99792458×10<sup>8</sup> m/s</span></li>
          </ul>

          <p>
            First compute the “ideal” responsivity at η = 1:
            <span class="readout">R<sub>η=1</sub> = qλ/(hc)</span>, then scale by η.
          </p>

          <div class="eq" data-copy="R_eta1 = q*lambda/(h*c) ≈ 1.25 A/W (at 1550 nm)">
            <button class="copyBtn" type="button" data-copy-btn>Copy</button>
            R_(η=1) = qλ/(hc) ≈ 1.25 A/W  (at 1550 nm)
            <small>Interpretation: if every photon made a collected electron, 1550 nm light would produce ~1.25 A per watt.</small>
          </div>

          <p>Now multiply by η = 1/3:</p>
          <div class="eq" data-copy="R = eta*R_eta1 = (1/3)*1.25 ≈ 0.417 A/W">
            <button class="copyBtn" type="button" data-copy-btn>Copy</button>
            R = η · R_(η=1) = (1/3)·(1.25) ≈ 0.417 A/W
            <small>So the device produces about 0.417 A of photocurrent per watt of 1550 nm optical power.</small>
          </div>

          <div class="finalBox" id="final">
            <h3>Final Answer (boxed)</h3>
            <div class="finalGrid">
              <div class="eq" data-copy="Quantum efficiency: eta = Ne/Nph = (2×10^12)/(6×10^12) = 1/3 ≈ 0.333">
                <button class="copyBtn" type="button" data-copy-btn>Copy</button>
                Quantum efficiency: η = 1/3 ≈ 0.333
              </div>
              <div class="eq" data-copy="Responsivity at 1550 nm: R = eta*q*lambda/(h*c) ≈ 0.417 A/W">
                <button class="copyBtn" type="button" data-copy-btn>Copy</button>
                Responsivity (1550 nm): R ≈ 0.417 A/W
              </div>
            </div>
            <div class="eq" style="margin-top:10px;" data-copy="eta = 0.333; R = 0.417 A/W (at lambda = 1550 nm)">
              <button class="copyBtn" type="button" data-copy-btn>Copy</button>
              Plain-text: η = 0.333;  R = 0.417 A/W  (λ = 1550 nm)
            </div>
          </div>

          <h3>Sanity checks</h3>
          <ul>
            <li><strong>Units:</strong> <span class="readout">qλ/(hc)</span> has units
              <span class="readout">(C·m)/(J·m) = C/J</span>.
              Since <span class="readout">1 W = 1 J/s</span>, <span class="readout">C/J = (C/s)/W = A/W</span>. Good.</li>
            <li><strong>Limiting behavior:</strong> if η → 0 then R → 0; if η → 1 then R → 1.25 A/W at 1550 nm. Makes sense.</li>
            <li><strong>Magnitude check:</strong> Many InGaAs photodiodes near 1550 nm have responsivities on the order of ~0.8–1.0 A/W for high η; our smaller η gives a smaller R, consistent.</li>
            <li><strong>Physical interpretation:</strong> about 1 out of every 3 incident photons results in a collected electron.</li>
          </ul>
        </section>

        <!-- Visualizations -->
        <section aria-label="Interactive visualization">
          <h2>Interactive Visualizations</h2>
          <p>
            Use the controls to explore how quantum efficiency and wavelength affect responsivity and collected electrons.
            Defaults match the problem statement.
          </p>

          <div class="canvasWrap">
            <div class="canvasTitleRow">
              <h3>Diagram: p–i–n photodiode under a photon pulse</h3>
              <p class="hint">Updates with your chosen parameters</p>
            </div>
            <canvas id="cDiagram" aria-label="Photodiode diagram canvas"></canvas>

            <div class="controls" aria-label="Interactive controls">
              <div class="control">
                <label>
                  <span>Incident photons <b>N<sub>ph</sub></b></span>
                  <span class="readout" id="outNph"></span>
                </label>
                <input id="sNph" type="range" min="1e11" max="1e13" step="1e11" value="6e12" />
              </div>

              <div class="control">
                <label>
                  <span>Collected electrons <b>N<sub>e</sub></b></span>
                  <span class="readout" id="outNe"></span>
                </label>
                <input id="sNe" type="range" min="0" max="6e12" step="1e11" value="2e12" />
              </div>

              <div class="control">
                <label>
                  <span>Wavelength <b>λ</b> (nm)</span>
                  <span class="readout" id="outLam"></span>
                </label>
                <input id="sLam" type="range" min="400" max="2000" step="10" value="1550" />
              </div>
            </div>

            <div class="callout" style="margin-top:12px;">
              <div class="tag"><span class="tagDot"></span>Live computed quantities</div>
              <div class="grid3" style="margin-top:8px;">
                <div class="callout" style="margin:0;">
                  <div class="tag"><span class="tagDot"></span>Quantum efficiency</div>
                  <div class="eq" id="liveEtaEq" data-copy="">
                    <button class="copyBtn" type="button" data-copy-btn>Copy</button>
                    η = —
                    <small>Computed as η = N_e / N_ph.</small>
                  </div>
                </div>
                <div class="callout" style="margin:0;">
                  <div class="tag"><span class="tagDot"></span>Responsivity</div>
                  <div class="eq" id="liveREq" data-copy="">
                    <button class="copyBtn" type="button" data-copy-btn>Copy</button>
                    R = —
                    <small>Computed as R = η q λ/(hc).</small>
                  </div>
                </div>
                <div class="callout" style="margin:0;">
                  <div class="tag"><span class="tagDot"></span>Ideal (η = 1)</div>
                  <div class="eq" id="liveR1Eq" data-copy="">
                    <button class="copyBtn" type="button" data-copy-btn>Copy</button>
                    R(η=1) = —
                    <small>Upper bound for no-gain photodiode.</small>
                  </div>
                </div>
              </div>

              <div class="callout warn" id="warnEta" style="display:none; margin-top:12px;">
                <div class="tag"><span class="tagDot"></span>Note</div>
                <p style="margin:0;">
                  Your settings imply <strong>η &gt; 1</strong>. A simple p–i–n photodiode typically has no internal gain, so η should be ≤ 1.
                  Values &gt; 1 can occur in gain devices (e.g., APDs) or if you interpret N<sub>e</sub> as multiplied carriers.
                </p>
              </div>
            </div>
          </div>

          <div class="grid2" style="margin-top:14px;">
            <div class="canvasWrap">
              <div class="canvasTitleRow">
                <h3>Primary plot: Responsivity R vs wavelength λ</h3>
                <p class="hint">Line uses current η (from N<sub>e</sub>/N<sub>ph</sub>)</p>
              </div>
              <canvas id="cPlot1" aria-label="Responsivity vs wavelength plot"></canvas>
            </div>

            <div class="canvasWrap">
              <div class="canvasTitleRow">
                <h3>Secondary plot: Collected electrons N<sub>e</sub> vs quantum efficiency η</h3>
                <p class="hint">Slope set by current N<sub>ph</sub></p>
              </div>
              <canvas id="cPlot2" aria-label="Collected electrons vs quantum efficiency plot"></canvas>
            </div>
          </div>
        </section>

        <!-- PART 4 -->
        <section id="part4">
          <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

          <h3>Re-interpreting the final formulas</h3>
          <p>
            The two key results are:
          </p>
          <div class="eq" data-copy="eta = Ne/Nph; R = eta*q*lambda/(h*c)">
            <button class="copyBtn" type="button" data-copy-btn>Copy</button>
            η = N_e/N_ph;   R = η q λ/(h c)
          </div>
          <ul>
            <li><strong>η controls collection:</strong> reflection + incomplete absorption + recombination + transport losses all reduce η.</li>
            <li><strong>λ controls photons-per-watt:</strong> since photon energy is <span class="readout">hc/λ</span>, longer λ means more photons per watt, so responsivity increases ∝ λ if η stays constant.</li>
            <li><strong>q, h, c are constants:</strong> they simply set the fundamental scale of charge-per-photon-energy conversion.</li>
          </ul>

          <h3>How parameter changes affect outcomes (connect to plots)</h3>
          <ul>
            <li>Increase <span class="readout">N<sub>e</sub></span> while holding <span class="readout">N<sub>ph</sub></span> fixed → η increases → <strong>entire R(λ) line moves upward</strong>.</li>
            <li>Increase <span class="readout">N<sub>ph</sub></span> while holding <span class="readout">N<sub>e</sub></span> fixed → η decreases → <strong>R(λ) line moves downward</strong>.</li>
            <li>Increase <span class="readout">λ</span> while holding η fixed → <strong>R increases linearly</strong> (primary plot) because <span class="readout">R ∝ λ</span>.</li>
          </ul>

          <h3>An alternative derivation idea (quick)</h3>
          <p>
            Instead of using rates, you can use pulse totals:
            pulse optical energy <span class="readout">E = N<sub>ph</sub> hc/λ</span>,
            collected charge <span class="readout">Q = N<sub>e</sub> q</span>,
            then <span class="readout">R = Q/E</span> (same value).
            This is often handy when problems give photon counts per pulse rather than optical power.
          </p>

          <h3>Concept checks (self-test)</h3>
          <ul>
            <li><strong>Q:</strong> If η doubles (with λ fixed), what happens to R? <strong>A:</strong> R doubles, because <span class="readout">R ∝ η</span>.</li>
            <li><strong>Q:</strong> If λ increases by 10% (η fixed), what happens to R? <strong>A:</strong> R increases by 10%, because <span class="readout">R ∝ λ</span>.</li>
            <li><strong>Q:</strong> Why can η be less than 1 even if absorption is strong? <strong>A:</strong> because “collected at terminals” also depends on carrier transport and recombination; not every generated pair is collected.</li>
            <li><strong>Q:</strong> Can a detector have effective “η &gt; 1”? <strong>A:</strong> yes, if there is internal gain (e.g., avalanche multiplication), but a simple p–i–n diode typically does not.</li>
          </ul>
        </section>

        <!-- PART 5 -->
        <section id="part5">
          <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

          <h3>What each canvas shows</h3>
          <ul>
            <li><strong>Diagram canvas:</strong> a labeled p–i–n photodiode with an incident photon pulse (N<sub>ph</sub>, λ) and collected electrons (N<sub>e</sub>). It visually encodes the idea that only a fraction η of photons become collected carriers.</li>
            <li><strong>Primary plot (R vs λ):</strong> the line is <span class="readout">R(λ) = η q λ/(hc)</span> using the currently computed η. A marker shows your selected λ, and a second (dashed) reference indicates the ideal η=1 case.</li>
            <li><strong>Secondary plot (N<sub>e</sub> vs η):</strong> the straight line is <span class="readout">N<sub>e</sub>(η) = η N<sub>ph</sub></span>, showing how collected electrons scale with quantum efficiency for the current N<sub>ph</sub>. A marker indicates the current operating point.</li>
          </ul>

          <h3>Interactive controls</h3>
          <ul>
            <li><strong>N<sub>ph</sub> slider:</strong> changes incident photons. This changes η (because η = N<sub>e</sub>/N<sub>ph</sub>) and changes the slope of the N<sub>e</sub>–η line.</li>
            <li><strong>N<sub>e</sub> slider:</strong> changes collected electrons. This changes η and therefore shifts the responsivity curve up/down.</li>
            <li><strong>λ slider:</strong> changes wavelength. This moves the marker along the responsivity curve and changes the computed responsivity at that point.</li>
          </ul>

          <div class="callout good">
            <div class="tag"><span class="tagDot"></span>Try this</div>
            <ul style="margin:6px 0 0 18px;">
              <li>Keep N<sub>ph</sub> fixed and increase N<sub>e</sub> → watch η rise and the whole R(λ) curve lift.</li>
              <li>Keep η fixed (by scaling N<sub>e</sub> with N<sub>ph</sub>) and increase λ → watch R rise linearly with λ.</li>
            </ul>
          </div>
        </section>
      </article>
    </div>
  </main>

  <footer>
    <p>
      Built as a self-contained learning article (vanilla HTML/CSS/JS). Constants are SI:
      q = 1.602176634×10<sup>−19</sup> C, h = 6.62607015×10<sup>−34</sup> J·s, c = 2.99792458×10<sup>8</sup> m/s.
    </p>
  </footer>

  <div class="copyToast" id="copyToast" role="status" aria-live="polite">Copied.</div>

  <script>
    // ---------- Utilities ----------
    function fmtSci(x, sig=3){
      if (!isFinite(x)) return "—";
      if (x === 0) return "0";
      const exp = Math.floor(Math.log10(Math.abs(x)));
      const m = x / Math.pow(10, exp);
      const mm = m.toFixed(Math.max(0, sig-1));
      // Use ×10^exp with HTML superscripts in rendering contexts
      return {m: mm, e: exp};
    }
    function fmtSciHTML(x, sig=3){
      const o = fmtSci(x, sig);
      if (typeof o === "string") return o;
      if (o.e === 0) return String(Number(x.toFixed(sig)));
      return `${o.m}×10<sup>${o.e}</sup>`;
    }
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    // Crisp canvas helper with devicePixelRatio + responsive resize
    function makeHiDPICanvas(canvas){
      const ctx = canvas.getContext('2d');
      function resize(){
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        const w = Math.max(2, Math.round(rect.width * dpr));
        const h = Math.max(2, Math.round(rect.height * dpr));
        if (canvas.width !== w || canvas.height !== h){
          canvas.width = w;
          canvas.height = h;
        }
        ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      }
      const ro = new ResizeObserver(()=>{ resize(); });
      ro.observe(canvas);
      window.addEventListener('resize', resize);
      resize();
      return {ctx, resize};
    }

    // Plot helpers (axes, ticks, grid)
    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
      const {x,y,w,h} = box;
      // Background
      ctx.save();
      ctx.clearRect(x-2, y-2, w+4, h+4);

      // Title
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(title, x, y-10);

      // Plot background panel
      ctx.fillStyle = "rgba(0,0,0,0.16)";
      roundRect(ctx, x, y, w, h, 12);
      ctx.fill();

      // Grid + axes
      const padL=54, padR=14, padT=14, padB=44;
      const px = x+padL, py = y+padT, pw = w-padL-padR, ph = h-padT-padB;

      // Gridlines
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;

      // Ticks
      const xTicks = 6, yTicks = 5;
      for (let i=0;i<=xTicks;i++){
        const tx = px + (i/xTicks)*pw;
        ctx.beginPath(); ctx.moveTo(tx, py); ctx.lineTo(tx, py+ph); ctx.stroke();
      }
      for (let j=0;j<=yTicks;j++){
        const ty = py + (j/yTicks)*ph;
        ctx.beginPath(); ctx.moveTo(px, ty); ctx.lineTo(px+pw, ty); ctx.stroke();
      }

      // Axis border
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth = 1.2;
      ctx.strokeRect(px, py, pw, ph);

      // Tick labels
      ctx.fillStyle = "rgba(255,255,255,0.72)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";

      for (let i=0;i<=xTicks;i++){
        const val = xMin + (i/xTicks)*(xMax-xMin);
        const tx = px + (i/xTicks)*pw;
        const s = (Math.abs(val) >= 1000 || Math.abs(val) < 0.01) ? (Number(val).toPrecision(3)) : (Number(val).toFixed(0));
        ctx.fillText(s, tx-10, py+ph+18);
        // tick mark
        ctx.strokeStyle = "rgba(255,255,255,0.30)";
        ctx.beginPath(); ctx.moveTo(tx, py+ph); ctx.lineTo(tx, py+ph+5); ctx.stroke();
      }
      for (let j=0;j<=yTicks;j++){
        const val = yMax - (j/yTicks)*(yMax-yMin);
        const ty = py + (j/yTicks)*ph;
        const s = (Math.abs(val) >= 1000 || Math.abs(val) < 0.01) ? (Number(val).toPrecision(3)) : (Number(val).toFixed(3));
        ctx.fillText(s, px-48, ty+4);
        ctx.strokeStyle = "rgba(255,255,255,0.30)";
        ctx.beginPath(); ctx.moveTo(px-5, ty); ctx.lineTo(px, ty); ctx.stroke();
      }

      // Axis labels
      ctx.fillStyle = "rgba(255,255,255,0.82)";
      ctx.font = "13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(xLabel, px + pw/2 - ctx.measureText(xLabel).width/2, y+h-10);

      // y label rotated
      ctx.save();
      ctx.translate(x+16, py+ph/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
      ctx.restore();

      ctx.restore();

      return {px,py,pw,ph, padL,padR,padT,padB};
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function mapX(val, xMin, xMax, px, pw){ return px + (val-xMin)/(xMax-xMin)*pw; }
    function mapY(val, yMin, yMax, py, ph){ return py + (yMax-val)/(yMax-yMin)*ph; }

    // ---------- Physics ----------
    const q = 1.602176634e-19;
    const h = 6.62607015e-34;
    const c = 299792458;

    function etaFromCounts(Ne, Nph){ return (Nph>0) ? (Ne/Nph) : 0; }
    function RfromEtaLam(eta, lam_m){ return eta*q*lam_m/(h*c); }
    function RidealLam(lam_m){ return q*lam_m/(h*c); }

    // ---------- DOM controls ----------
    const sNph = document.getElementById('sNph');
    const sNe  = document.getElementById('sNe');
    const sLam = document.getElementById('sLam');

    const outNph = document.getElementById('outNph');
    const outNe  = document.getElementById('outNe');
    const outLam = document.getElementById('outLam');

    const liveEtaEq = document.getElementById('liveEtaEq');
    const liveREq   = document.getElementById('liveREq');
    const liveR1Eq  = document.getElementById('liveR1Eq');
    const warnEta   = document.getElementById('warnEta');

    // ---------- Canvases ----------
    const diagram = makeHiDPICanvas(document.getElementById('cDiagram'));
    const plot1   = makeHiDPICanvas(document.getElementById('cPlot1'));
    const plot2   = makeHiDPICanvas(document.getElementById('cPlot2'));

    function getState(){
      const Nph = Number(sNph.value);
      // Keep Ne slider max synced to Nph (so η ≤ 1 in typical p-i-n case)
      sNe.max = String(Nph);
      const Ne = Math.min(Number(sNe.value), Nph);
      if (Number(sNe.value) !== Ne) sNe.value = String(Ne);

      const lam_nm = Number(sLam.value);
      const lam_m  = lam_nm * 1e-9;

      const eta = etaFromCounts(Ne, Nph);
      const R = RfromEtaLam(eta, lam_m);
      const R1 = RidealLam(lam_m);

      return {Nph, Ne, lam_nm, lam_m, eta, R, R1};
    }

    function updateReadouts(st){
      outNph.innerHTML = `${fmtSciHTML(st.Nph,3)} photons`;
      outNe.innerHTML  = `${fmtSciHTML(st.Ne,3)} e⁻`;
      outLam.textContent = `${st.lam_nm.toFixed(0)} nm`;

      const etaTxt = st.eta.toFixed(3);
      const RTxt = st.R.toFixed(3);
      const R1Txt = st.R1.toFixed(3);

      liveEtaEq.childNodes.forEach(n=>{ /* noop */ });
      liveEtaEq.firstChild && (liveEtaEq.firstChild.textContent = "");

      // Update equation blocks text (preserve copy button)
      setEqBlock(liveEtaEq, `η = ${etaTxt}`);
      setEqBlock(liveREq,   `R = ${RTxt} A/W`);
      setEqBlock(liveR1Eq,  `R(η=1) = ${R1Txt} A/W`);

      liveEtaEq.setAttribute("data-copy", `eta = Ne/Nph = ${st.Ne}/${st.Nph} = ${etaTxt}`);
      liveREq.setAttribute("data-copy",   `R = eta*q*lambda/(h*c) = ${RTxt} A/W (lambda=${st.lam_nm} nm)`);
      liveR1Eq.setAttribute("data-copy",  `R_eta1 = q*lambda/(h*c) = ${R1Txt} A/W (lambda=${st.lam_nm} nm)`);

      warnEta.style.display = (st.eta > 1.0001) ? "block" : "none";
    }

    function setEqBlock(el, mainText){
      const btn = el.querySelector('[data-copy-btn]');
      const small = el.querySelector('small');
      el.innerHTML = "";
      el.appendChild(btn);
      const txtNode = document.createTextNode(mainText);
      el.appendChild(txtNode);
      if (small) el.appendChild(small);
    }

    // ---------- Drawing: Diagram ----------
    function drawDiagram(st){
      const ctx = diagram.ctx;
      const rect = document.getElementById('cDiagram').getBoundingClientRect();
      const W = rect.width, H = rect.height;

      ctx.clearRect(0,0,W,H);

      // Background softly
      ctx.fillStyle = "rgba(0,0,0,0.10)";
      roundRect(ctx, 10, 10, W-20, H-20, 14);
      ctx.fill();

      // Draw photodiode block
      const x0 = W*0.18, y0 = H*0.22, w0 = W*0.62, h0 = H*0.46;

      // Layers (p, i, n)
      const pW = w0*0.22, iW = w0*0.46, nW = w0*0.32;

      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 1.2;

      // p
      ctx.fillStyle = "rgba(125,211,252,0.14)";
      roundRect(ctx, x0, y0, pW, h0, 14);
      ctx.fill(); ctx.stroke();

      // i
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      roundRect(ctx, x0+pW, y0, iW, h0, 14);
      ctx.fill(); ctx.stroke();

      // n
      ctx.fillStyle = "rgba(167,139,250,0.12)";
      roundRect(ctx, x0+pW+iW, y0, nW, h0, 14);
      ctx.fill(); ctx.stroke();

      // Labels
      ctx.fillStyle = "rgba(255,255,255,0.90)";
      ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("p", x0 + pW*0.5 - 4, y0 + 22);
      ctx.fillText("i", x0 + pW + iW*0.5 - 3, y0 + 22);
      ctx.fillText("n", x0 + pW + iW + nW*0.5 - 4, y0 + 22);

      // Terminals
      const leftT  = {x:x0, y:y0+h0*0.5};
      const rightT = {x:x0+w0, y:y0+h0*0.5};
      ctx.strokeStyle = "rgba(255,255,255,0.30)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(leftT.x-45, leftT.y);
      ctx.lineTo(leftT.x, leftT.y);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(rightT.x, rightT.y);
      ctx.lineTo(rightT.x+45, rightT.y);
      ctx.stroke();

      // External circuit hint
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      ctx.moveTo(leftT.x-45, leftT.y);
      ctx.lineTo(leftT.x-45, leftT.y+70);
      ctx.lineTo(rightT.x+45, rightT.y+70);
      ctx.lineTo(rightT.x+45, rightT.y);
      ctx.stroke();
      ctx.fillStyle = "rgba(255,255,255,0.70)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillText("terminals", x0 + w0*0.42, y0+h0+88);

      // Incident light arrow
      const ax1 = x0 + w0*0.5, ay1 = y0 - 26;
      const ax2 = x0 + w0*0.5, ay2 = y0 + 8;
      ctx.strokeStyle = "rgba(125,211,252,0.85)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(ax1, ay1);
      ctx.lineTo(ax2, ay2);
      ctx.stroke();
      // Arrow head
      ctx.fillStyle = "rgba(125,211,252,0.85)";
      ctx.beginPath();
      ctx.moveTo(ax2, ay2);
      ctx.lineTo(ax2-7, ay2-10);
      ctx.lineTo(ax2+7, ay2-10);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.86)";
      ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("incident photon pulse", x0 + w0*0.25, y0 - 34);
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.fillText(`Nph = ${fmtSciHTML(st.Nph,3)} photons`, x0 + w0*0.22, y0 - 16);
      ctx.fillText(`λ = ${st.lam_nm.toFixed(0)} nm`, x0 + w0*0.22, y0 + 2);

      // Carriers in i-region (dots)
      const cx = x0 + pW + iW*0.5;
      const cy = y0 + h0*0.55;
      const pairs = 14;
      for (let k=0;k<pairs;k++){
        const rx = (Math.random()-0.5)*iW*0.72;
        const ry = (Math.random()-0.5)*h0*0.64;
        // electron (green)
        ctx.fillStyle = "rgba(52,211,153,0.85)";
        ctx.beginPath();
        ctx.arc(cx+rx, cy+ry, 2.6, 0, Math.PI*2);
        ctx.fill();
        // hole (pink)
        ctx.fillStyle = "rgba(251,113,133,0.80)";
        ctx.beginPath();
        ctx.arc(cx+rx+10, cy+ry+6, 2.4, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.fillStyle = "rgba(255,255,255,0.70)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("generated e–h pairs (concept)", x0 + pW + 10, y0 + h0 - 10);

      // Collected electrons annotation
      ctx.fillStyle = "rgba(255,255,255,0.84)";
      ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("collected at terminals", x0 + w0*0.02, y0 + h0 + 22);
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.fillText(`Ne = ${fmtSciHTML(st.Ne,3)} electrons`, x0 + w0*0.02, y0 + h0 + 40);
      ctx.fillText(`η = Ne/Nph = ${st.eta.toFixed(3)}`, x0 + w0*0.02, y0 + h0 + 58);

      // Flow arrows to terminals (conceptual)
      ctx.strokeStyle = "rgba(52,211,153,0.55)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx-30, cy-10);
      ctx.lineTo(x0 + pW*0.4, y0 + h0*0.5);
      ctx.stroke();
      ctx.strokeStyle = "rgba(251,113,133,0.50)";
      ctx.beginPath();
      ctx.moveTo(cx+30, cy+10);
      ctx.lineTo(x0 + pW + iW + nW*0.6, y0 + h0*0.5);
      ctx.stroke();

      // Small legend
      const lx = x0 + w0*0.68, ly = y0 + h0 + 18;
      ctx.fillStyle = "rgba(0,0,0,0.18)";
      roundRect(ctx, lx, ly, 210, 56, 12);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.stroke();
      ctx.fillStyle = "rgba(52,211,153,0.85)";
      ctx.beginPath(); ctx.arc(lx+16, ly+18, 5, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("electron", lx+28, ly+22);
      ctx.fillStyle = "rgba(251,113,133,0.80)";
      ctx.beginPath(); ctx.arc(lx+16, ly+40, 5, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.fillText("hole", lx+28, ly+44);
    }

    // ---------- Drawing: Plot 1 (R vs lambda) ----------
    function drawPlot1(st){
      const ctx = plot1.ctx;
      const rect = document.getElementById('cPlot1').getBoundingClientRect();
      const W = rect.width, H = rect.height;

      const margin = {l:0,t:28,r:0,b:0};
      const box = {x:10, y:34, w:W-20, h:H-52};

      // X range: 400-2000 nm
      const xMin = 400, xMax = 2000;
      // Y range based on eta and max lambda
      const yMaxLine = RfromEtaLam(Math.max(st.eta, 0), xMax*1e-9);
      const yMaxIdeal= RidealLam(xMax*1e-9);
      const yMax = Math.max(0.05, yMaxIdeal*1.05);
      const yMin = 0;

      const ax = drawAxes(
        ctx, box, xMin, xMax, yMin, yMax,
        "Wavelength λ (nm)", "Responsivity R (A/W)",
        "Responsivity vs Wavelength"
      );

      // Legend
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      const lx = ax.px + 10, ly = ax.py + 10;
      // current eta line
      ctx.strokeStyle = "rgba(125,211,252,0.90)";
      ctx.lineWidth = 2.5;
      ctx.beginPath(); ctx.moveTo(lx, ly); ctx.lineTo(lx+26, ly); ctx.stroke();
      ctx.fillText(`R(λ) with η = ${st.eta.toFixed(3)}`, lx+34, ly+4);

      // ideal
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.setLineDash([6,5]);
      ctx.beginPath(); ctx.moveTo(lx, ly+18); ctx.lineTo(lx+26, ly+18); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillText("R(λ) for η = 1 (ideal no-gain)", lx+34, ly+22);
      ctx.restore();

      // Draw lines
      function drawLine(etaVal, dashed, strokeStyle){
        ctx.save();
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = 2.6;
        ctx.setLineDash(dashed ? [7,6] : []);
        ctx.beginPath();
        const N = 250;
        for (let i=0;i<=N;i++){
          const lam = xMin + (i/N)*(xMax-xMin);
          const R = RfromEtaLam(etaVal, lam*1e-9);
          const X = mapX(lam, xMin, xMax, ax.px, ax.pw);
          const Y = mapY(R, yMin, yMax, ax.py, ax.ph);
          if (i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
        }
        ctx.stroke();
        ctx.restore();
      }
      drawLine(st.eta, false, "rgba(125,211,252,0.90)");
      drawLine(1.0, true, "rgba(255,255,255,0.55)");

      // Marker at selected wavelength
      const x0 = st.lam_nm;
      const y0 = st.R;
      const X0 = mapX(x0, xMin, xMax, ax.px, ax.pw);
      const Y0 = mapY(y0, yMin, yMax, ax.py, ax.ph);

      ctx.save();
      // vertical guide
      ctx.strokeStyle = "rgba(52,211,153,0.55)";
      ctx.lineWidth = 1.6;
      ctx.setLineDash([5,6]);
      ctx.beginPath(); ctx.moveTo(X0, ax.py); ctx.lineTo(X0, ax.py+ax.ph); ctx.stroke();
      ctx.setLineDash([]);

      // point
      ctx.fillStyle = "rgba(52,211,153,0.90)";
      ctx.beginPath(); ctx.arc(X0, Y0, 5.2, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 2;
      ctx.stroke();

      // annotation
      const label = `λ=${st.lam_nm.toFixed(0)} nm, R=${st.R.toFixed(3)} A/W`;
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      const tw = ctx.measureText(label).width;
      const bx = clamp(X0 - tw/2 - 8, ax.px+6, ax.px+ax.pw - tw - 16);
      const by = clamp(Y0 - 34, ax.py+8, ax.py+ax.ph - 28);

      ctx.fillStyle = "rgba(0,0,0,0.55)";
      roundRect(ctx, bx, by, tw+16, 22, 10);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      ctx.stroke();
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillText(label, bx+8, by+15);
      ctx.restore();
    }

    // ---------- Drawing: Plot 2 (Ne vs eta) ----------
    function drawPlot2(st){
      const ctx = plot2.ctx;
      const rect = document.getElementById('cPlot2').getBoundingClientRect();
      const W = rect.width, H = rect.height;

      const box = {x:10, y:34, w:W-20, h:H-52};

      const xMin=0, xMax=1.0;
      const yMin=0, yMax=st.Nph*1.05; // at eta=1, Ne = Nph

      const ax = drawAxes(
        ctx, box, xMin, xMax, yMin, yMax,
        "Quantum efficiency η (dimensionless)", "Collected electrons N_e (electrons)",
        "Collected Electrons vs Quantum Efficiency"
      );

      // Draw line Ne = eta*Nph
      ctx.save();
      ctx.strokeStyle = "rgba(167,139,250,0.90)";
      ctx.lineWidth = 2.6;
      ctx.beginPath();
      const N=200;
      for (let i=0;i<=N;i++){
        const eta = xMin + (i/N)*(xMax-xMin);
        const Ne = eta*st.Nph;
        const X = mapX(eta, xMin, xMax, ax.px, ax.pw);
        const Y = mapY(Ne, yMin, yMax, ax.py, ax.ph);
        if (i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
      }
      ctx.stroke();

      // Marker at current eta, Ne
      const X0 = mapX(clamp(st.eta,0,xMax), xMin, xMax, ax.px, ax.pw);
      const Y0 = mapY(st.Ne, yMin, yMax, ax.py, ax.ph);

      // Guides
      ctx.strokeStyle = "rgba(52,211,153,0.55)";
      ctx.lineWidth = 1.5;
      ctx.setLineDash([5,6]);
      ctx.beginPath(); ctx.moveTo(X0, ax.py); ctx.lineTo(X0, ax.py+ax.ph); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ax.px, Y0); ctx.lineTo(ax.px+ax.pw, Y0); ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = "rgba(52,211,153,0.92)";
      ctx.beginPath(); ctx.arc(X0, Y0, 5.2, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Legend
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      const lx = ax.px + 10, ly = ax.py + 10;
      ctx.strokeStyle = "rgba(167,139,250,0.90)";
      ctx.lineWidth = 2.5;
      ctx.beginPath(); ctx.moveTo(lx, ly); ctx.lineTo(lx+26, ly); ctx.stroke();
      ctx.fillText(`N_e = η N_ph  (N_ph = ${fmtSciHTML(st.Nph,3)})`, lx+34, ly+4);

      // Annotation
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      const label = `η=${st.eta.toFixed(3)}, N_e=${fmtSciHTML(st.Ne,3)}`;
      const tw = ctx.measureText(label).width;
      const bx = clamp(X0 - tw/2 - 8, ax.px+6, ax.px+ax.pw - tw - 16);
      const by = clamp(Y0 - 34, ax.py+8, ax.py+ax.ph - 28);

      ctx.fillStyle = "rgba(0,0,0,0.55)";
      roundRect(ctx, bx, by, tw+16, 22, 10);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      ctx.stroke();
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      // label contains HTML superscripts in string in fmtSciHTML; avoid here -> use plain scientific for canvas
      const NeCanvas = (st.Ne === 0) ? "0" : (Number(st.Ne).toExponential(2).replace('e+','e').replace('e','×10^'));
      const labelCanvas = `η=${st.eta.toFixed(3)}, N_e≈${NeCanvas}`;
      ctx.fillText(labelCanvas, bx+8, by+15);

      ctx.restore();
    }

    // ---------- Master render ----------
    function render(){
      const st = getState();
      updateReadouts(st);
      drawDiagram(st);
      drawPlot1(st);
      drawPlot2(st);
    }

    // ---------- Copy buttons ----------
    const toast = document.getElementById('copyToast');
    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>toast.classList.remove('show'), 1100);
    }
    function attachCopyHandlers(){
      document.querySelectorAll('[data-copy-btn]').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const parent = btn.closest('[data-copy]');
          const text = parent ? parent.getAttribute('data-copy') : '';
          if (!text) { showToast("Nothing to copy."); return; }
          navigator.clipboard.writeText(text).then(()=>{
            showToast("Copied to clipboard.");
          }).catch(()=>{
            // fallback
            try{
              const ta = document.createElement('textarea');
              ta.value = text;
              document.body.appendChild(ta);
              ta.select();
              document.execCommand('copy');
              document.body.removeChild(ta);
              showToast("Copied.");
            }catch(e){
              showToast("Copy failed.");
            }
          });
        });
      });
    }

    // ---------- TOC active highlighting ----------
    const tocLinks = Array.from(document.querySelectorAll('.toclink'));
    const sections = tocLinks.map(a => document.querySelector(a.getAttribute('href'))).filter(Boolean);
    const io = new IntersectionObserver((entries)=>{
      entries.forEach(entry=>{
        if(entry.isIntersecting){
          tocLinks.forEach(a=>a.classList.remove('active'));
          const idx = sections.indexOf(entry.target);
          if(idx>=0) tocLinks[idx].classList.add('active');
        }
      });
    }, { root:null, rootMargin:"-30% 0px -62% 0px", threshold:0.02 });
    sections.forEach(s=>io.observe(s));

    // Smooth scroll
    tocLinks.forEach(a=>{
      a.addEventListener('click', (e)=>{
        e.preventDefault();
        const target = document.querySelector(a.getAttribute('href'));
        if(target) target.scrollIntoView({behavior:'smooth', block:'start'});
      });
    });

    // ---------- Events ----------
    [sNph, sNe, sLam].forEach(sl=>{
      sl.addEventListener('input', render);
    });

    // Init
    attachCopyHandlers();
    render();
  </script>
</body>
</html>
