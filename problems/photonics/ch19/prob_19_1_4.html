<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Transit-Time Spread for a Uniformly Illuminated Semiconductor Photodetector</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --card2:#0f1730;
      --ink:#eaf0ff;
      --muted:#b7c3ff;
      --faint:rgba(234,240,255,.12);
      --line:rgba(234,240,255,.18);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#86efac;
      --warn:#fbbf24;
      --bad:#fb7185;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius: 18px;
      --radius2: 14px;
      --maxw: 1120px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1200px 700px at 20% -10%, rgba(125, 211, 252, .20), transparent 60%),
        radial-gradient(900px 600px at 110% 10%, rgba(167, 139, 250, .18), transparent 55%),
        radial-gradient(700px 500px at 40% 120%, rgba(134, 239, 172, .10), transparent 55%),
        linear-gradient(180deg, #070a14 0%, #0b1020 40%, #070a14 100%);
      line-height:1.55;
    }

    header{
      padding:28px 18px 18px;
      position:relative;
      overflow:hidden;
    }
    .wrap{max-width:var(--maxw); margin:0 auto;}
    .hero{
      background: linear-gradient(180deg, rgba(17, 26, 51, .78), rgba(15, 23, 48, .62));
      border:1px solid var(--line);
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      padding: 22px 22px 18px;
      position:relative;
    }
    h1{
      font-size: clamp(1.35rem, 2.2vw, 2.05rem);
      margin: 0 0 8px;
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      margin:0 0 12px;
      max-width: 80ch;
    }
    .meta{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-top: 12px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      color:var(--muted);
      font-size:.9rem;
    }
    .pill b{color:var(--ink); font-weight:600}
    main{
      padding: 0 18px 44px;
    }

    /* Layout with sticky ToC */
    .grid{
      max-width: var(--maxw);
      margin: 0 auto;
      display:grid;
      grid-template-columns: 310px 1fr;
      gap: 16px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr;}
    }

    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(17, 26, 51, .74), rgba(15, 23, 48, .62));
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
    }
    nav.toc h2{
      font-size: 1.02rem;
      margin: 4px 0 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .toc small{color:var(--muted); font-weight:500}
    .toc a{
      display:block;
      color:var(--muted);
      text-decoration:none;
      padding: 8px 10px;
      border-radius: 12px;
      border:1px solid transparent;
      transition: transform .14s ease, background .14s ease, border-color .14s ease;
      font-size:.94rem;
    }
    .toc a:hover{
      background: rgba(255,255,255,.04);
      border-color: var(--faint);
      transform: translateX(2px);
      color: var(--ink);
    }

    article{
      background: linear-gradient(180deg, rgba(17, 26, 51, .70), rgba(15, 23, 48, .55));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 18px 8px;
      overflow:hidden;
    }

    section{padding: 6px 2px 18px;}
    section + section{border-top:1px solid rgba(234,240,255,.08); margin-top: 4px; padding-top: 18px;}
    h2{
      font-size: clamp(1.15rem, 1.6vw, 1.45rem);
      margin: 0 0 10px;
    }
    h3{
      font-size: 1.05rem;
      margin: 14px 0 8px;
      color: var(--ink);
    }
    p{margin: 8px 0; color: rgba(234,240,255,.92);}
    ul{margin: 10px 0 10px 22px; color: rgba(234,240,255,.92);}
    li{margin: 6px 0;}
    .two{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items:start;
    }
    @media (max-width: 780px){ .two{grid-template-columns:1fr;} }

    .card{
      background: rgba(255,255,255,.03);
      border:1px solid rgba(234,240,255,.14);
      border-radius: var(--radius2);
      padding: 12px 12px 10px;
    }
    .callout{
      border-left: 4px solid var(--accent);
      background: rgba(125, 211, 252, .08);
    }
    .assumptions{border-left-color: var(--accent2); background: rgba(167, 139, 250, .08);}
    .mistakes{border-left-color: var(--warn); background: rgba(251, 191, 36, .08);}
    .final{border-left-color: var(--good); background: rgba(134, 239, 172, .08);}
    .eq{
      font-family: var(--mono);
      font-size: .95rem;
      line-height: 1.45;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(234,240,255,.14);
      border-radius: 12px;
      padding: 10px 10px;
      overflow:auto;
      margin: 10px 0 8px;
      white-space: pre;
    }
    .eqrow{
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    button.copy{
      border:1px solid rgba(234,240,255,.18);
      background: rgba(255,255,255,.04);
      color: var(--ink);
      padding: 8px 10px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease;
      font-weight:600;
      font-size:.9rem;
      user-select:none;
    }
    button.copy:hover{background: rgba(255,255,255,.07); transform: translateY(-1px);}
    button.copy:active{transform: translateY(0px);}
    .kpi{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      margin-top: 10px;
    }
    .kpi .pill{background: rgba(0,0,0,.12);}

    /* Viz area */
    .viz{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap: 12px;
      align-items:stretch;
      margin-top: 10px;
    }
    @media (max-width: 980px){ .viz{grid-template-columns:1fr;} }

    figure{
      margin: 0;
      border-radius: var(--radius2);
      overflow:hidden;
      border:1px solid rgba(234,240,255,.14);
      background: rgba(0,0,0,.16);
    }
    figcaption{
      padding: 10px 12px;
      color: var(--muted);
      border-top:1px solid rgba(234,240,255,.10);
      font-size: .92rem;
    }
    canvas{
      width: 100%;
      height: 320px;
      display:block;
      background: rgba(0,0,0,.06);
    }
    .small canvas{height: 280px;}
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap: 12px;
      align-items:center;
      margin: 10px 0 4px;
      padding: 12px;
      border-radius: var(--radius2);
      border: 1px solid rgba(234,240,255,.14);
      background: rgba(255,255,255,.03);
    }
    .ctrl{
      min-width: 240px;
      flex: 1 1 260px;
    }
    .ctrl label{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap: 10px;
      font-weight: 700;
      color: rgba(234,240,255,.95);
      margin-bottom: 6px;
    }
    .ctrl label span{font-weight:600; color: var(--muted);}
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    select{
      width:100%;
      padding:8px 10px;
      border-radius: 12px;
      border:1px solid rgba(234,240,255,.18);
      background: rgba(0,0,0,.18);
      color: var(--ink);
      outline:none;
    }

    footer{
      margin-top: 18px;
      padding: 16px 18px 24px;
      color: var(--muted);
      text-align:center;
    }

    /* subtle animation */
    @media (prefers-reduced-motion: no-preference){
      .hero, article, nav.toc{animation: floatIn .45s ease both;}
      @keyframes floatIn{
        from{opacity:0; transform: translateY(8px);}
        to{opacity:1; transform: translateY(0);}
      }
    }

    /* print-friendly */
    @media print{
      body{background:#fff; color:#000;}
      nav.toc{display:none;}
      .grid{grid-template-columns: 1fr;}
      .hero, article{box-shadow:none; border:1px solid #ccc; background:#fff;}
      .card{background:#fff;}
      .eq{background:#f7f7f7; border-color:#ddd;}
      button.copy{display:none;}
      canvas{display:none;}
      figure{border-color:#ddd;}
      figcaption{border-top:1px solid #ddd;}
    }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="hero">
      <h1>Transit-Time Spread for a Uniformly Illuminated Semiconductor Photodetector</h1>
      <p class="subtitle">
        An impulse of light at <span class="eq" style="display:inline; padding:2px 6px; border-radius:10px;">t = 0</span>
        generates <b>N</b> electron–hole pairs uniformly throughout a slab of thickness <b>w</b>.
        Because carriers start at different positions, they arrive at the contacts at different times—producing a
        <b>spread-out current pulse</b>. We derive the piecewise-linear hole current, electron current, and their sum,
        then verify the total delivered charge.
      </p>
      <div class="meta">
        <span class="pill"><b>Key tool:</b> Ramo–Shockley theorem</span>
        <span class="pill"><b>Geometry:</b> 1D slab, thickness <b>w</b></span>
        <span class="pill"><b>Result:</b> piecewise linear currents</span>
        <span class="pill"><b>Charge check:</b> electrons + holes each give <b>Ne/2</b></span>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="grid">
    <nav class="toc" aria-label="Table of Contents">
      <h2>Table of Contents <small>(sticky)</small></h2>
      <a href="#quick">Quick Summary</a>
      <a href="#part0">PART 0 — Concept Primer</a>
      <a href="#part1">PART 1 — Problem Analysis</a>
      <a href="#part2">PART 2 — Strategy & Tips</a>
      <a href="#part3">PART 3 — Full Solution</a>
      <a href="#part4">PART 4 — Deeper Understanding</a>
      <a href="#part5">PART 5 — Visualization Guide</a>
    </nav>

    <article>
      <section id="quick">
        <h2>Quick Summary</h2>
        <ul>
          <li><b>What this is:</b> Find the <b>induced external current</b> after a delta-like optical pulse generates <b>N</b> pairs uniformly across <b>0 ≤ x ≤ w</b>.</li>
          <li><b>Key physics idea:</b> The external circuit current is induced by carrier motion, not only by arrival—use the <b>Ramo–Shockley theorem</b>.</li>
          <li><b>Governing relation (1D parallel plates):</b> induced current from one carrier is <span class="eq" style="display:inline; padding:2px 6px;">i = q v / w</span> while it drifts (uniform weighting field <span class="eq" style="display:inline; padding:2px 6px;">E_w = 1/w</span>).</li>
          <li><b>Ensemble idea:</b> At time <b>t</b>, only carriers that have not yet reached a contact contribute; their fraction is set by <b>transit times</b>.</li>
          <li><b>Hole current (symbolic):</b> linear ramp-down to zero over <span class="eq" style="display:inline; padding:2px 6px;">w/v_h</span>.</li>
          <li><b>Electron current (symbolic):</b> linear ramp-down to zero over <span class="eq" style="display:inline; padding:2px 6px;">w/v_e</span>.</li>
          <li><b>Total current:</b> piecewise sum; typically a fast electron drop then a long hole tail when <span class="eq" style="display:inline; padding:2px 6px;">v_e &gt; v_h</span>.</li>
          <li><b>Charge verification:</b> <span class="eq" style="display:inline; padding:2px 6px;">∫ i_h dt = Ne/2</span>, <span class="eq" style="display:inline; padding:2px 6px;">∫ i_e dt = Ne/2</span>, so <span class="eq" style="display:inline; padding:2px 6px;">∫ i dt = Ne</span>.</li>
        </ul>
      </section>

      <section id="part0">
        <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

        <div class="two">
          <div class="card callout">
            <h3>Core definitions (symbols & units)</h3>
            <ul>
              <li><b>w</b> — detector active thickness (m).</li>
              <li><b>x</b> — generation position measured from the <b>left</b> contact (m), with <b>0 ≤ x ≤ w</b>.</li>
              <li><b>v_e, v_h</b> — (drift) velocities of electron and hole (m/s), assumed constant.</li>
              <li><b>N</b> — total number of generated electron–hole pairs (dimensionless count).</li>
              <li><b>e</b> — elementary charge magnitude (C). Electron charge is <b>−e</b>, hole charge is <b>+e</b>.</li>
              <li><b>i(t)</b> — induced current in the external circuit (A).</li>
            </ul>
          </div>

          <div class="card callout">
            <h3>Physical meaning</h3>
            <p>
              When a carrier drifts inside a biased photodetector, it changes the electrode charges to keep boundary
              conditions satisfied. That electrode charge change is what the external circuit “feels” as current.
            </p>
            <p>
              Crucially: <b>the circuit current exists while the carrier is moving</b>, even before it reaches a contact.
              The pulse shape is therefore controlled by <b>transit times</b> and how carriers are distributed in the device.
            </p>
          </div>
        </div>

        <div class="card assumptions">
          <h3>Key law: Ramo–Shockley theorem (when it is valid)</h3>
          <p>
            For a moving charge <b>q</b> with velocity component along the device axis <b>v</b>, the induced current at an electrode is
          </p>
          <div class="eqrow">
            <div class="eq" id="eq-rs">i = q * v * E_w</div>
            <button class="copy" data-copy-target="eq-rs">Copy</button>
          </div>
          <p>
            where <b>E_w</b> is the <b>weighting field</b> (a geometry-only field found by setting the electrode of interest to 1 V and all others to 0 V, with charges removed).
            In a 1D parallel-plate slab of thickness <b>w</b>, <b>E_w = 1/w</b> is uniform, so:
          </p>
          <div class="eqrow">
            <div class="eq" id="eq-1d">i = q v / w  (while the carrier is in transit)</div>
            <button class="copy" data-copy-target="eq-1d">Copy</button>
          </div>
          <ul>
            <li><b>Valid when:</b> quasi-static fields (device size small compared to EM wavelengths of interest), linear dielectrics, electrodes define boundary conditions.</li>
            <li><b>We assume:</b> constant drift velocities (uniform field, no velocity saturation changes over the region).</li>
          </ul>
        </div>

        <div class="two">
          <div class="card">
            <h3>Common approximations (and why we use them)</h3>
            <ul>
              <li><b>1D uniform weighting field:</b> simplifies induced current to <span class="eq" style="display:inline; padding:2px 6px;">i = qv/w</span>.</li>
              <li><b>Constant drift velocity:</b> lets transit time be distance/velocity.</li>
              <li><b>No recombination/trapping:</b> all carriers contribute until they hit a contact.</li>
              <li><b>Instantaneous generation at t=0:</b> isolates transit-time spreading as the only pulse-shaping mechanism.</li>
            </ul>
          </div>
          <div class="card">
            <h3>Mini intuition examples</h3>
            <ul>
              <li><b>Single carrier:</b> A charge drifting steadily induces a <b>flat (constant)</b> current until it reaches the contact, then its contribution stops abruptly.</li>
              <li><b>Many carriers at different x:</b> At later times, the “short-trip” carriers have already finished, leaving fewer contributors → the ensemble current <b>ramps down</b>.</li>
            </ul>
          </div>
        </div>

        <div class="card mistakes">
          <h3>What to watch for (pitfalls)</h3>
          <ul>
            <li>Mixing up <b>electron charge</b> (−e) with the <b>direction</b> of induced current. Ramo–Shockley already handles sign through <b>q v</b>.</li>
            <li>Forgetting that <b>carriers contribute while moving</b>, not only at collection.</li>
            <li>Using the wrong remaining-fraction condition: for holes it’s <span class="eq" style="display:inline; padding:2px 6px;">x &gt; v_h t</span>; for electrons it’s <span class="eq" style="display:inline; padding:2px 6px;">w - x &gt; v_e t</span>.</li>
            <li>Not checking that <b>integrated current = delivered charge</b>.</li>
          </ul>
        </div>
      </section>

      <section id="part1">
        <h2>PART 1 — Problem Analysis (no solving yet)</h2>

        <h3>Problem rewritten (in plain words)</h3>
        <p>
          A semiconductor slab of thickness <b>w</b> is hit by a short optical impulse at <b>t=0</b>, creating <b>N</b> electron–hole pairs uniformly across the slab.
          Electrons drift right with constant velocity <b>v<sub>e</sub></b> and holes drift left with constant velocity <b>v<sub>h</sub></b>.
          Find expressions for the <b>hole-induced current</b> <b>i<sub>h</sub>(t)</b>, the <b>electron-induced current</b> <b>i<sub>e</sub>(t)</b>, and the <b>total</b> <b>i(t)=i<sub>h</sub>(t)+i<sub>e</sub>(t)</b>,
          and verify that each carrier type contributes total charge <b>Ne/2</b>, so the circuit receives total charge <b>Ne</b>.
        </p>

        <div class="two">
          <div class="card">
            <h3>Given</h3>
            <ul>
              <li>Uniform generation: <b>N</b> pairs over <b>0 ≤ x ≤ w</b>.</li>
              <li>Constant velocities: <b>v<sub>e</sub></b>, <b>v<sub>h</sub></b>.</li>
              <li>1D slab / parallel-plate style geometry (uniform weighting field).</li>
            </ul>
          </div>
          <div class="card">
            <h3>Unknowns (to find/prove)</h3>
            <ul>
              <li><b>i<sub>h</sub>(t)</b> and <b>i<sub>e</sub>(t)</b> as explicit piecewise functions.</li>
              <li><b>i(t)</b> as the sum, including piecewise behavior when one species finishes first.</li>
              <li>Charge check: <span class="eq" style="display:inline; padding:2px 6px;">∫ i_h dt = Ne/2</span> and <span class="eq" style="display:inline; padding:2px 6px;">∫ i_e dt = Ne/2</span>.</li>
            </ul>
          </div>
        </div>

        <div class="card assumptions">
          <h3>Relevant principles (and why they apply)</h3>
          <ul>
            <li><b>Ramo–Shockley theorem:</b> The measured circuit current is induced by carrier motion in the detector geometry; perfect for transient currents.</li>
            <li><b>Kinematics with constant drift velocity:</b> Transit time = distance / velocity.</li>
            <li><b>Uniform generation distribution:</b> Allows ensemble averaging by integrating over initial position x.</li>
          </ul>
          <p>
            <b>Why not other tools?</b> Full drift-diffusion PDEs are overkill here because velocities are given constant and generation is instantaneous;
            diffusion, recombination, space-charge, and field nonuniformity are explicitly ignored by the model.
          </p>
        </div>

        <h3>Assumptions (explicit)</h3>
        <ul>
          <li>Uniform weighting field: <span class="eq" style="display:inline; padding:2px 6px;">E_w = 1/w</span>.</li>
          <li>Carrier velocities constant in time and space: <span class="eq" style="display:inline; padding:2px 6px;">v_e, v_h = const</span>.</li>
          <li>No trapping/recombination; carriers disappear only upon reaching the contacts.</li>
          <li>Optical pulse is impulsive: all pairs created at <span class="eq" style="display:inline; padding:2px 6px;">t=0</span>.</li>
          <li>We take <b>v<sub>e</sub> ≥ v<sub>h</sub></b> for the typical “fast electron, slow hole” case (the formulas still work if swapped; the piecewise intervals reorder).</li>
        </ul>

        <div class="card">
          <h3>Possible approaches (compare & choose)</h3>
          <ul>
            <li><b>(A) Ensemble averaging via remaining fraction (best):</b> Use single-carrier current <span class="eq" style="display:inline; padding:2px 6px;">qv/w</span> and multiply by the number of carriers still in transit at time t. <b>Fast and intuitive</b>.</li>
            <li><b>(B) Integrate over x with Heaviside step functions:</b> Write current contributions as step functions and integrate. <b>More formal</b>, same result.</li>
            <li><b>(C) Weighting potential charge method:</b> Use induced charge <span class="eq" style="display:inline; padding:2px 6px;">Q = -q φ_w</span> and differentiate. Elegant but slightly less direct for beginners.</li>
          </ul>
          <p><b>We choose (A)</b> because it makes the pulse shape emerge immediately from “how many carriers are still moving.”</p>
        </div>
      </section>

      <section id="part2">
        <h2>PART 2 — Strategy & Tips (roadmap only)</h2>
        <ol>
          <li><b>Model the geometry:</b> treat the detector as a 1D slab of thickness w with uniform weighting field <span class="eq" style="display:inline; padding:2px 6px;">E_w=1/w</span>. <i>Meaning:</i> induced current depends only on q and v.</li>
          <li><b>Write single-carrier induced current:</b> for a moving carrier, <span class="eq" style="display:inline; padding:2px 6px;">i = qv/w</span> while it is inside. <i>Meaning:</i> each carrier contributes a constant “rectangle” in time.</li>
          <li><b>Compute transit times vs starting position x:</b> holes: <span class="eq" style="display:inline; padding:2px 6px;">t_h(x)=x/v_h</span>, electrons: <span class="eq" style="display:inline; padding:2px 6px;">t_e(x)=(w-x)/v_e</span>. <i>Meaning:</i> different x → different cutoff times.</li>
          <li><b>At time t, find which carriers remain:</b> holes still moving if <span class="eq" style="display:inline; padding:2px 6px;">x &gt; v_h t</span>; electrons still moving if <span class="eq" style="display:inline; padding:2px 6px;">x &lt; w - v_e t</span>.</li>
          <li><b>Convert remaining interval length into remaining number:</b> uniform x-distribution ⇒ fraction is interval length / w; multiply by N.</li>
          <li><b>Multiply:</b> (remaining number) × (single-carrier current) to get <b>i<sub>h</sub>(t)</b> and <b>i<sub>e</sub>(t)</b>; enforce the time ranges where the interval is nonnegative.</li>
          <li><b>Add them:</b> piecewise, because electrons typically finish earlier (<span class="eq" style="display:inline; padding:2px 6px;">w/v_e</span> shorter) leaving a hole tail until <span class="eq" style="display:inline; padding:2px 6px;">w/v_h</span>.</li>
          <li><b>Verify charge:</b> integrate each current over time and confirm <span class="eq" style="display:inline; padding:2px 6px;">Ne/2</span> + <span class="eq" style="display:inline; padding:2px 6px;">Ne/2</span> = <span class="eq" style="display:inline; padding:2px 6px;">Ne</span>.</li>
        </ol>

        <div class="card mistakes">
          <h3>Common mistakes & quick tips</h3>
          <ul>
            <li><b>Mistake:</b> using <span class="eq" style="display:inline; padding:2px 6px;">x &lt; v_h t</span> for holes (wrong direction). <b>Tip:</b> hole reaches left contact after traveling distance x.</li>
            <li><b>Mistake:</b> forgetting piecewise behavior when electrons finish. <b>Tip:</b> mark key times <span class="eq" style="display:inline; padding:2px 6px;">t = w/v_e</span> and <span class="eq" style="display:inline; padding:2px 6px;">t = w/v_h</span> on a timeline first.</li>
            <li><b>Mistake:</b> not checking area-under-curve. <b>Tip:</b> every pulse you derive should integrate to total delivered charge.</li>
          </ul>
        </div>
      </section>

      <section id="part3">
        <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

        <h3>Physical intuition before equations</h3>
        <p>
          Each carrier contributes a <b>constant induced current</b> while drifting, and stops contributing once collected.
          Because generation is uniform in <b>x</b>, at later times the “shorter path” carriers are already gone, so the
          number of remaining contributors falls <b>linearly</b> with time. Therefore, we expect <b>triangle-like</b> currents:
          a linear ramp-down to zero.
        </p>

        <div class="card assumptions">
          <h3>Step 1 — Single-carrier induced current (Ramo–Shockley)</h3>
          <p>
            In a 1D slab of thickness <b>w</b> with uniform weighting field <b>E<sub>w</sub>=1/w</b>, the induced current at the external circuit from a carrier is
          </p>
          <div class="eqrow">
            <div class="eq" id="eq-single">i_single = q v / w</div>
            <button class="copy" data-copy-target="eq-single">Copy</button>
          </div>
          <p>
            This is constant in time <i>as long as the carrier moves with constant velocity</i> and remains inside the slab.
          </p>
        </div>

        <div class="card">
          <h3>Step 2 — Transit times as functions of generation position x</h3>
          <p>
            Let <b>x</b> be the initial position measured from the <b>left contact</b>.
          </p>
          <ul>
            <li><b>Hole:</b> drifts left to x=0 with speed <b>v<sub>h</sub></b>. Distance = x ⇒
              <span class="eq" style="display:inline; padding:2px 6px;">t_h(x) = x / v_h</span>.
            </li>
            <li><b>Electron:</b> drifts right to x=w with speed <b>v<sub>e</sub></b>. Distance = w−x ⇒
              <span class="eq" style="display:inline; padding:2px 6px;">t_e(x) = (w - x) / v_e</span>.
            </li>
          </ul>
          <p>
            <b>Meaning:</b> carriers born near their collecting contact have small transit times; those born far away have the longest transit times.
          </p>
        </div>

        <div class="card callout">
          <h3>Step 3 — Hole current i<sub>h</sub>(t): count holes still drifting at time t</h3>
          <p>
            A hole created at x is still inside (not yet collected) at time t if
          </p>
          <div class="eq" id="eq-hole-cond">t &lt; t_h(x) = x / v_h  ⇔  x &gt; v_h t</div>
          <p>
            Because generation is uniform over <b>0 ≤ x ≤ w</b>, the fraction of holes still drifting at time t is the
            fraction of x-values satisfying <span class="eq" style="display:inline; padding:2px 6px;">x ∈ (v_h t, w]</span>, whose length is <span class="eq" style="display:inline; padding:2px 6px;">w - v_h t</span>.
          </p>
          <p>
            So, for <span class="eq" style="display:inline; padding:2px 6px;">0 ≤ t ≤ w/v_h</span>:
          </p>
          <div class="eq" id="eq-hole-num">N_h,remain(t) = N * (w - v_h t) / w</div>
          <p>
            Each remaining hole contributes induced current <span class="eq" style="display:inline; padding:2px 6px;">(+e) v_h / w</span>. Thus
          </p>
          <div class="eqrow">
            <div class="eq" id="eq-hole">
i_h(t) = (e v_h / w) * N * (w - v_h t)/w
       = (N e v_h / w) - (N e v_h^2 / w^2) t,     0 ≤ t ≤ w/v_h
i_h(t) = 0,                                       otherwise</div>
            <button class="copy" data-copy-target="eq-hole">Copy</button>
          </div>
          <p>
            <b>What we did:</b> current = (current per carrier) × (how many carriers are still moving). The linear decrease comes from the uniformly shrinking interval of still-in-transit holes.
          </p>
        </div>

        <div class="card callout">
          <h3>Step 4 — Electron current i<sub>e</sub>(t): count electrons still drifting at time t</h3>
          <p>
            An electron created at x is still inside at time t if
          </p>
          <div class="eq" id="eq-elec-cond">t &lt; t_e(x) = (w - x)/v_e  ⇔  x &lt; w - v_e t</div>
          <p>
            So the allowed interval is <span class="eq" style="display:inline; padding:2px 6px;">x ∈ [0, w - v_e t)</span> of length <span class="eq" style="display:inline; padding:2px 6px;">w - v_e t</span>.
            For <span class="eq" style="display:inline; padding:2px 6px;">0 ≤ t ≤ w/v_e</span>:
          </p>
          <div class="eq" id="eq-elec-num">N_e,remain(t) = N * (w - v_e t) / w</div>
          <p>
            Each remaining electron contributes induced current magnitude <span class="eq" style="display:inline; padding:2px 6px;">e v_e / w</span> to the circuit (the sign convention is captured by qv in Ramo–Shockley; here we report the standard “photocurrent” direction consistent with the figure’s expressions). Therefore
          </p>
          <div class="eqrow">
            <div class="eq" id="eq-elec">
i_e(t) = (e v_e / w) * N * (w - v_e t)/w
       = (N e v_e / w) - (N e v_e^2 / w^2) t,     0 ≤ t ≤ w/v_e
i_e(t) = 0,                                       otherwise</div>
            <button class="copy" data-copy-target="eq-elec">Copy</button>
          </div>
          <p>
            Again: a linear ramp-down, but it ends sooner if <span class="eq" style="display:inline; padding:2px 6px;">v_e &gt; v_h</span>.
          </p>
        </div>

        <div class="card final">
          <h3>Step 5 — Total current i(t) and its piecewise form</h3>
          <p>
            The total induced current is the sum:
            <span class="eq" style="display:inline; padding:2px 6px;">i(t)=i_h(t)+i_e(t)</span>.
            If (typical) <b>v<sub>e</sub> ≥ v<sub>h</sub></b>, then <span class="eq" style="display:inline; padding:2px 6px;">w/v_e ≤ w/v_h</span>, so:
          </p>

          <div class="eqrow">
            <div class="eq" id="eq-total">
For 0 ≤ t ≤ w/v_e (both species still drifting):
i(t) = (N e / w)(v_h + v_e) - (N e / w^2)(v_h^2 + v_e^2) t

For w/v_e ≤ t ≤ w/v_h (electrons done, only holes remain):
i(t) = (N e v_h / w) * (1 - (v_h t / w))

For t > w/v_h:
i(t) = 0</div>
            <button class="copy" data-copy-target="eq-total">Copy</button>
          </div>

          <div class="kpi">
            <span class="pill"><b>Peak at t=0:</b> i(0)=Ne(vh+ve)/w</span>
            <span class="pill"><b>Electron cutoff:</b> t= w/ve</span>
            <span class="pill"><b>Hole cutoff:</b> t= w/vh</span>
          </div>
        </div>

        <div class="card">
          <h3>Step 6 — Verify delivered charge: electrons and holes each give Ne/2</h3>
          <p>
            The charge delivered by a current pulse is its time integral:
            <span class="eq" style="display:inline; padding:2px 6px;">Q = ∫ i(t) dt</span>.
            Start with holes:
          </p>
          <div class="eq" id="eq-qh">
Q_h = ∫_0^{w/v_h} [ (N e v_h / w) - (N e v_h^2 / w^2) t ] dt
    = (N e v_h / w)(w/v_h) - (N e v_h^2 / w^2) * (1/2)(w/v_h)^2
    = N e - (N e)/2
    = N e / 2</div>
          <p>
            Similarly for electrons:
          </p>
          <div class="eq" id="eq-qe">
Q_e = ∫_0^{w/v_e} [ (N e v_e / w) - (N e v_e^2 / w^2) t ] dt
    = (N e v_e / w)(w/v_e) - (N e v_e^2 / w^2) * (1/2)(w/v_e)^2
    = N e - (N e)/2
    = N e / 2</div>
          <p>
            Therefore,
            <span class="eq" style="display:inline; padding:2px 6px;">Q_total = Q_h + Q_e = Ne</span>.
            <b>Interpretation:</b> each generated pair delivers exactly one electron charge worth of total external charge, split equally between the two drifting carriers in this uniform-weighting 1D geometry.
          </p>
        </div>

        <div class="card">
          <h3>Sanity checks</h3>
          <ul>
            <li><b>Units:</b> each current term looks like <span class="eq" style="display:inline; padding:2px 6px;">(C)(m/s)/m = C/s = A</span>. Good.</li>
            <li><b>Limiting case v<sub>e</sub> → ∞:</b> electrons finish instantly (w/v<sub>e</sub>→0); their contribution becomes an impulse-like area Ne/2, leaving only the hole triangle tail.</li>
            <li><b>Symmetric velocities v<sub>e</sub>=v<sub>h</sub>:</b> both triangles have same duration; the total is a single triangle with doubled amplitude (until the same cutoff time).</li>
            <li><b>Sign/direction:</b> depending on electrode convention, electron and hole induced currents can add in the measured photocurrent direction—matching the provided expressions.</li>
          </ul>
        </div>

        <div class="card">
          <h3>Connect to the diagram & plots</h3>
          <p>
            The diagram shows a carrier pair created at x. The hole travels distance x (time x/v<sub>h</sub>) and the electron travels distance w−x (time (w−x)/v<sub>e</sub>).
            Uniform generation means “cutoff times” are uniformly distributed, so the ensemble current decreases linearly as time advances.
            In the plots, you’ll see a <b>fast electron triangle</b> ending at <b>w/v<sub>e</sub></b> and a <b>long hole triangle</b> ending at <b>w/v<sub>h</sub></b>.
          </p>
        </div>

        <div class="card final">
          <h3>Final Answer (boxed)</h3>
          <div class="eqrow">
            <div class="eq" id="eq-final">
Hole current:
i_h(t) = (N e v_h / w) - (N e v_h^2 / w^2) t,   0 ≤ t ≤ w/v_h
         0,                                     otherwise

Electron current:
i_e(t) = (N e v_e / w) - (N e v_e^2 / w^2) t,   0 ≤ t ≤ w/v_e
         0,                                     otherwise

Total current (assuming v_e ≥ v_h):
i(t) = (N e / w)(v_h + v_e) - (N e / w^2)(v_h^2 + v_e^2) t,  0 ≤ t ≤ w/v_e
       (N e v_h / w)(1 - v_h t / w),                          w/v_e ≤ t ≤ w/v_h
       0,                                                     otherwise

Charges:
∫ i_h dt = N e / 2,   ∫ i_e dt = N e / 2,   ∫ i dt = N e</div>
            <button class="copy" data-copy-target="eq-final">Copy</button>
          </div>
        </div>
      </section>

      <section id="part4">
        <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

        <div class="two">
          <div class="card">
            <h3>Re-interpreting the formulas</h3>
            <ul>
              <li><b>Amplitude scale:</b> all currents scale like <span class="eq" style="display:inline; padding:2px 6px;">Ne/w</span>. More pairs (N↑) or thinner device (w↓) → larger current.</li>
              <li><b>Time scale (transit):</b> electron triangle ends at <span class="eq" style="display:inline; padding:2px 6px;">w/v_e</span>, hole triangle ends at <span class="eq" style="display:inline; padding:2px 6px;">w/v_h</span>.</li>
              <li><b>Slope:</b> the linear decay slopes are set by <span class="eq" style="display:inline; padding:2px 6px;">-Ne v^2 / w^2</span>: faster carriers produce steeper (shorter) triangles.</li>
              <li><b>Why Ne/2 each?</b> In a uniform weighting field, the induced charge from a carrier equals <span class="eq" style="display:inline; padding:2px 6px;">q × (Δx / w)</span>. Averaging Δx over uniform starting positions gives <span class="eq" style="display:inline; padding:2px 6px;">w/2</span> for each species → <span class="eq" style="display:inline; padding:2px 6px;">Ne/2</span>.</li>
            </ul>
          </div>

          <div class="card">
            <h3>How parameters affect the outcome (tie to plots)</h3>
            <ul>
              <li>Increase <b>v<sub>e</sub></b> while holding <b>v<sub>h</sub></b> fixed: the <b>early-time peak</b> grows (since i(0) depends on v<sub>e</sub>), and the electron portion ends earlier at <span class="eq" style="display:inline; padding:2px 6px;">w/v_e</span>.</li>
              <li>Increase <b>v<sub>h</sub></b>: the long tail shortens because <span class="eq" style="display:inline; padding:2px 6px;">w/v_h</span> decreases, and the late-time current becomes smaller sooner.</li>
              <li>Increase <b>w</b>: lowers amplitudes (∝1/w) but stretches the time axis (∝w).</li>
            </ul>
          </div>
        </div>

        <div class="card">
          <h3>An alternative derivation idea (brief)</h3>
          <p>
            Use the <b>weighting potential</b> <span class="eq" style="display:inline; padding:2px 6px;">φ_w(x)=x/w</span> (for the right electrode).
            The induced charge at that electrode from a carrier moving from x<sub>0</sub> to x(t) is
            <span class="eq" style="display:inline; padding:2px 6px;">Q_ind(t) = -q [φ_w(x(t)) - φ_w(x_0)]</span>.
            Differentiate to get current: <span class="eq" style="display:inline; padding:2px 6px;">i = dQ_ind/dt = -q (dφ_w/dx) v = -q (1/w) v</span>,
            which is the same constant-current result; then ensemble-average over x<sub>0</sub>.
          </p>
        </div>

        <div class="card callout">
          <h3>Concept checks (quick self-test)</h3>
          <ul>
            <li><b>Q:</b> Why does i<sub>h</sub>(t) decrease linearly with t? <br><b>A:</b> Because the remaining fraction of holes is proportional to the remaining x-interval length <span class="eq" style="display:inline; padding:2px 6px;">w - v_h t</span>.</li>
            <li><b>Q:</b> What sets the “kink” time in i(t)? <br><b>A:</b> The faster species finishes first; typically the kink is at <span class="eq" style="display:inline; padding:2px 6px;">t=w/v_e</span>.</li>
            <li><b>Q:</b> If generation were not uniform but concentrated near x=0, what happens to i<sub>h</sub>(t)? <br><b>A:</b> Holes would finish quickly (short x), making i<sub>h</sub>(t) shorter and less “tail-like.”</li>
            <li><b>Q:</b> Does the total delivered charge depend on v<sub>e</sub> and v<sub>h</sub>? <br><b>A:</b> No. Velocities shape the pulse but the total area remains <span class="eq" style="display:inline; padding:2px 6px;">Ne</span> under these ideal assumptions.</li>
          </ul>
        </div>
      </section>

      <section id="part5">
        <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

        <div class="controls" role="group" aria-label="Interactive controls">
          <div class="ctrl">
            <label for="kSlider">Velocity ratio <span>k = v<sub>e</sub>/v<sub>h</sub></span> <span id="kReadout">10.0</span></label>
            <input id="kSlider" type="range" min="1" max="40" step="0.1" value="10" />
            <p style="margin:6px 0 0; color:var(--muted); font-size:.92rem;">
              Hold <b>v<sub>h</sub></b> fixed and vary <b>v<sub>e</sub></b>. This updates the diagram + both plots.
            </p>
          </div>
          <div class="ctrl">
            <label for="scaleSelect">Plot scaling <span>(time & current)</span></label>
            <select id="scaleSelect">
              <option value="physical" selected>Physical units (ns, mA) — example values</option>
              <option value="normalized">Normalized (t / (w/vh), i / (Ne vh/w))</option>
            </select>
            <p style="margin:6px 0 0; color:var(--muted); font-size:.92rem;">
              Switch between an <b>example numeric</b> view and a <b>dimensionless</b> view.
            </p>
          </div>
        </div>

        <div class="viz">
          <figure>
            <canvas id="diagram" aria-label="Detector diagram canvas"></canvas>
            <figcaption>
              <b>Diagram:</b> 1D slab (0 to w). A pair is created at position x. Holes drift left at v<sub>h</sub>, electrons drift right at v<sub>e</sub>.
              The dashed lines indicate transit times <span class="eq" style="display:inline; padding:1px 5px;">t_h=x/vh</span> and <span class="eq" style="display:inline; padding:1px 5px;">t_e=(w-x)/ve</span>.
            </figcaption>
          </figure>

          <figure class="small">
            <canvas id="plot2" aria-label="Parameter sweep canvas"></canvas>
            <figcaption>
              <b>Secondary plot:</b> As k changes, see how <b>peak current</b> i(0) and <b>electron cutoff time</b> w/v<sub>e</sub> vary. A marker shows the current slider setting.
            </figcaption>
          </figure>
        </div>

        <figure style="margin-top:12px;">
          <canvas id="plot1" aria-label="Current vs time canvas"></canvas>
          <figcaption>
            <b>Main plot:</b> i<sub>h</sub>(t), i<sub>e</sub>(t), and i(t) vs time. Notice the kink at t = w/v<sub>e</sub> and the tail ending at t = w/v<sub>h</sub>.
          </figcaption>
        </figure>

        <div class="card">
          <h3>What the canvases show</h3>
          <ul>
            <li><b>Diagram canvas:</b> device geometry and one representative pair at an example position x = 0.6w. The velocities update with k.</li>
            <li><b>Main plot:</b> the derived piecewise-linear currents. Axes include ticks, gridlines, units, and a legend.</li>
            <li><b>Secondary plot:</b> a mini “parameter sweep” view: peak current i(0) grows with k, while electron cutoff time w/v<sub>e</sub> shrinks with k.</li>
          </ul>
        </div>

        <div class="card">
          <h3>How the interactive control changes the physics</h3>
          <p>
            Moving the slider changes <b>k = v<sub>e</sub>/v<sub>h</sub></b> while keeping v<sub>h</sub> fixed.
            Increasing k makes electrons faster:
          </p>
          <ul>
            <li>Electron triangle ends earlier at <span class="eq" style="display:inline; padding:2px 6px;">t = w/v_e = (w/v_h)/k</span>.</li>
            <li>Peak current increases because <span class="eq" style="display:inline; padding:2px 6px;">i(0)=Ne(vh+ve)/w</span> grows with v<sub>e</sub>.</li>
            <li>The <b>hole tail</b> duration stays the same (it depends on v<sub>h</sub>).</li>
          </ul>
        </div>

      </section>
    </article>
  </div>
</main>

<footer>
  Built as a self-contained learning article (vanilla HTML/CSS/JS). Copy buttons provide plain-text equations for notes and reports.
</footer>

<script>
(function(){
  // ---------- Copy buttons ----------
  function copyText(text){
    if (navigator.clipboard && navigator.clipboard.writeText){
      return navigator.clipboard.writeText(text);
    }
    // Fallback
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.setAttribute('readonly','');
    ta.style.position = 'fixed';
    ta.style.left = '-9999px';
    document.body.appendChild(ta);
    ta.select();
    try{ document.execCommand('copy'); }catch(e){}
    document.body.removeChild(ta);
    return Promise.resolve();
  }
  document.querySelectorAll('button.copy').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const id = btn.getAttribute('data-copy-target');
      const el = document.getElementById(id);
      const raw = (el ? el.textContent : '').trim();
      await copyText(raw);
      const old = btn.textContent;
      btn.textContent = 'Copied ✓';
      setTimeout(()=>btn.textContent = old, 900);
    });
  });

  // ---------- Canvas helpers ----------
  function setupCanvas(canvas){
    const ctx = canvas.getContext('2d');
    function resize(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width * dpr));
      const h = Math.max(1, Math.floor(rect.height * dpr));
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {w: rect.width, h: rect.height, dpr};
    }
    return {ctx, resize};
  }

  function niceTicks(min, max, n=6){
    const span = max - min;
    if (span <= 0) return {step:1, start:min, end:max};
    const raw = span / Math.max(1,(n-1));
    const pow10 = Math.pow(10, Math.floor(Math.log10(raw)));
    const candidates = [1,2,5,10].map(m => m*pow10);
    let step = candidates[0];
    for (const c of candidates){ if (raw <= c){ step = c; break; } }
    const start = Math.floor(min/step)*step;
    const end = Math.ceil(max/step)*step;
    return {step, start, end};
  }

  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
    const {x,y,w,h} = box;
    // background
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.10)';
    ctx.fillRect(x,y,w,h);

    // Title
    ctx.fillStyle = 'rgba(234,240,255,0.92)';
    ctx.font = '700 13px ui-sans-serif, system-ui';
    ctx.fillText(title, x+10, y+18);

    // Plot region
    const padL = 54, padR = 14, padT = 28, padB = 42;
    const px = x + padL, py = y + padT, pw = w - padL - padR, ph = h - padT - padB;

    // Grid + ticks
    ctx.strokeStyle = 'rgba(234,240,255,0.12)';
    ctx.lineWidth = 1;

    const xt = niceTicks(xMin, xMax, 6);
    const yt = niceTicks(yMin, yMax, 6);

    // grid lines
    for (let xv = xt.start; xv <= xt.end + 1e-12; xv += xt.step){
      const t = (xv - xMin)/(xMax - xMin);
      const X = px + t*pw;
      ctx.beginPath();
      ctx.moveTo(X, py);
      ctx.lineTo(X, py+ph);
      ctx.stroke();
    }
    for (let yv = yt.start; yv <= yt.end + 1e-12; yv += yt.step){
      const t = (yv - yMin)/(yMax - yMin);
      const Y = py + ph - t*ph;
      ctx.beginPath();
      ctx.moveTo(px, Y);
      ctx.lineTo(px+pw, Y);
      ctx.stroke();
    }

    // axes
    ctx.strokeStyle = 'rgba(234,240,255,0.30)';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(px, py+ph);
    ctx.lineTo(px+pw, py+ph);
    ctx.stroke();

    // tick labels
    ctx.fillStyle = 'rgba(234,240,255,0.75)';
    ctx.font = '12px ui-sans-serif, system-ui';
    // x
    for (let xv = xt.start; xv <= xt.end + 1e-12; xv += xt.step){
      const t = (xv - xMin)/(xMax - xMin);
      const X = px + t*pw;
      ctx.fillText(formatNum(xv), X-10, py+ph+18);
    }
    // y
    for (let yv = yt.start; yv <= yt.end + 1e-12; yv += yt.step){
      const t = (yv - yMin)/(yMax - yMin);
      const Y = py + ph - t*ph;
      ctx.fillText(formatNum(yv), x+10, Y+4);
    }

    // labels
    ctx.fillStyle = 'rgba(234,240,255,0.88)';
    ctx.font = '700 12px ui-sans-serif, system-ui';
    ctx.fillText(xLabel, px + pw*0.5 - ctx.measureText(xLabel).width*0.5, y+h-12);

    // y label (rotated)
    ctx.save();
    ctx.translate(x+14, py + ph*0.5);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, -ctx.measureText(yLabel).width*0.5, 0);
    ctx.restore();

    ctx.restore();

    function xToPx(xv){ return px + (xv - xMin)/(xMax - xMin)*pw; }
    function yToPx(yv){ return py + ph - (yv - yMin)/(yMax - yMin)*ph; }
    return {plot:{x:px,y:py,w:pw,h:ph}, xToPx, yToPx};
  }

  function formatNum(v){
    const av = Math.abs(v);
    if (av >= 1000 || (av > 0 && av < 0.01)) return v.toExponential(1);
    if (av >= 10) return v.toFixed(1).replace(/\.0$/,'');
    return v.toFixed(2).replace(/0$/,'').replace(/\.$/,'');
  }

  function line(ctx, pts, xToPx, yToPx){
    if (!pts.length) return;
    ctx.beginPath();
    ctx.moveTo(xToPx(pts[0].x), yToPx(pts[0].y));
    for (let i=1;i<pts.length;i++){
      ctx.lineTo(xToPx(pts[i].x), yToPx(pts[i].y));
    }
    ctx.stroke();
  }

  function legend(ctx, items, x, y){
    ctx.save();
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillStyle = 'rgba(234,240,255,0.85)';
    ctx.strokeStyle = 'rgba(234,240,255,0.45)';
    ctx.lineWidth = 2;
    let yy = y;
    for (const it of items){
      ctx.beginPath();
      ctx.moveTo(x, yy);
      ctx.lineTo(x+20, yy);
      ctx.strokeStyle = it.stroke;
      ctx.stroke();
      ctx.fillStyle = 'rgba(234,240,255,0.85)';
      ctx.fillText(it.label, x+26, yy+4);
      yy += 18;
    }
    ctx.restore();
  }

  // ---------- Physics model ----------
  // Example values (ONLY for plotting in physical-units mode)
  const example = {
    w: 20e-6,       // 20 µm
    vh: 8e4,        // m/s (example drift velocity)
    N: 2e6,         // number of pairs
    e: 1.602e-19    // Coulomb
  };

  function currentsAt(t, w, vh, ve, N, e){
    // hole
    const thMax = w / vh;
    let ih = 0;
    if (t >= 0 && t <= thMax){
      ih = (N*e*vh/w) - (N*e*vh*vh/(w*w))*t;
    }
    // electron
    const teMax = w / ve;
    let ie = 0;
    if (t >= 0 && t <= teMax){
      ie = (N*e*ve/w) - (N*e*ve*ve/(w*w))*t;
    }
    return {ih, ie, i: ih+ie, thMax, teMax};
  }

  function sampleCurrents(w, vh, ve, N, e, n=600){
    const thMax = w/vh;
    const teMax = w/ve;
    const tMax = Math.max(thMax, teMax);
    const ptsH=[], ptsE=[], ptsT=[];
    for (let i=0;i<n;i++){
      const t = tMax * i/(n-1);
      const c = currentsAt(t, w, vh, ve, N, e);
      ptsH.push({x:t, y:c.ih});
      ptsE.push({x:t, y:c.ie});
      ptsT.push({x:t, y:c.i});
    }
    return {ptsH, ptsE, ptsT, thMax, teMax, tMax};
  }

  // ---------- Draw diagram ----------
  const diag = setupCanvas(document.getElementById('diagram'));
  const plot1 = setupCanvas(document.getElementById('plot1'));
  const plot2 = setupCanvas(document.getElementById('plot2'));

  function drawDiagram(ctx, W, H, w, vh, ve){
    ctx.clearRect(0,0,W,H);

    // panel
    const pad=16;
    const bx=pad, by=pad, bw=W-2*pad, bh=H-2*pad;
    ctx.fillStyle='rgba(0,0,0,0.08)';
    ctx.fillRect(bx,by,bw,bh);

    // device block
    const devX = bx + 40;
    const devY = by + 70;
    const devW = bw - 80;
    const devH = 70;

    ctx.strokeStyle='rgba(234,240,255,0.35)';
    ctx.lineWidth=1.5;
    ctx.fillStyle='rgba(255,255,255,0.03)';
    ctx.fillRect(devX, devY, devW, devH);
    ctx.strokeRect(devX, devY, devW, devH);

    // Contacts labels
    ctx.fillStyle='rgba(234,240,255,0.86)';
    ctx.font='700 12px ui-sans-serif, system-ui';
    ctx.fillText('Left contact (x=0)', devX, devY-10);
    const rightLabel = 'Right contact (x=w)';
    ctx.fillText(rightLabel, devX+devW-ctx.measureText(rightLabel).width, devY-10);

    // x-axis under device
    const axY = devY + devH + 34;
    ctx.strokeStyle='rgba(234,240,255,0.28)';
    ctx.lineWidth=1.2;
    ctx.beginPath();
    ctx.moveTo(devX, axY);
    ctx.lineTo(devX+devW, axY);
    ctx.stroke();

    // ticks
    ctx.fillStyle='rgba(234,240,255,0.70)';
    ctx.font='12px ui-sans-serif, system-ui';
    for (let i=0;i<=4;i++){
      const x = devX + devW * (i/4);
      ctx.beginPath();
      ctx.moveTo(x, axY-5); ctx.lineTo(x, axY+5); ctx.stroke();
      const lbl = (i===0)?'0':(i===4)?'w':(i/4).toFixed(2)+'w';
      ctx.fillText(lbl, x-10, axY+22);
    }
    ctx.fillText('x', devX+devW+10, axY+4);

    // Example generation point at x0=0.6w
    const x0 = 0.6;
    const genX = devX + devW*x0;
    const genY = devY + devH*0.5;

    // pair symbol
    ctx.fillStyle='rgba(234,240,255,0.95)';
    ctx.beginPath(); ctx.arc(genX-8, genY, 6, 0, Math.PI*2); ctx.fill(); // hole (filled)
    ctx.fillStyle='rgba(234,240,255,0.20)';
    ctx.beginPath(); ctx.arc(genX+8, genY, 6, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle='rgba(234,240,255,0.65)';
    ctx.beginPath(); ctx.arc(genX+8, genY, 6, 0, Math.PI*2); ctx.stroke(); // electron (open)
    ctx.fillStyle='rgba(234,240,255,0.90)';
    ctx.font='700 12px ui-sans-serif, system-ui';
    ctx.fillText('h+', genX-18, genY-10);
    ctx.fillText('e-', genX+2, genY-10);

    // velocity arrows
    const arrow = (x1,y1,x2,y2,label)=>{
      ctx.strokeStyle='rgba(125,211,252,0.85)';
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      // head
      const ang = Math.atan2(y2-y1, x2-x1);
      const L=10;
      ctx.beginPath();
      ctx.moveTo(x2,y2);
      ctx.lineTo(x2 - L*Math.cos(ang-Math.PI/7), y2 - L*Math.sin(ang-Math.PI/7));
      ctx.lineTo(x2 - L*Math.cos(ang+Math.PI/7), y2 - L*Math.sin(ang+Math.PI/7));
      ctx.closePath();
      ctx.fillStyle='rgba(125,211,252,0.85)';
      ctx.fill();
      ctx.fillStyle='rgba(234,240,255,0.86)';
      ctx.font='700 12px ui-sans-serif, system-ui';
      ctx.fillText(label, (x1+x2)/2 - 6, y1-10);
    };

    arrow(genX-10, genY+18, genX-70, genY+18, 'v_h');
    arrow(genX+10, genY+18, genX+80, genY+18, 'v_e');

    // Transit time dashed guides
    ctx.strokeStyle='rgba(234,240,255,0.22)';
    ctx.setLineDash([6,6]);
    ctx.lineWidth=1.2;

    // hole path to left
    ctx.beginPath();
    ctx.moveTo(genX, devY+devH+6);
    ctx.lineTo(devX, devY+devH+6);
    ctx.stroke();
    // electron path to right
    ctx.beginPath();
    ctx.moveTo(genX, devY+devH+18);
    ctx.lineTo(devX+devW, devY+devH+18);
    ctx.stroke();
    ctx.setLineDash([]);

    // annotate times
    const th = (x0*w)/vh;
    const te = ((1-x0)*w)/ve;
    ctx.fillStyle='rgba(234,240,255,0.80)';
    ctx.font='12px ui-sans-serif, system-ui';
    ctx.fillText(`t_h = x/v_h  (example: ${(th*1e9).toFixed(2)} ns)`, devX, devY+devH+52);
    ctx.fillText(`t_e = (w-x)/v_e (example: ${(te*1e9).toFixed(2)} ns)`, devX, devY+devH+70);

    // show numeric values
    ctx.fillStyle='rgba(183,195,255,0.92)';
    ctx.font='12px ui-sans-serif, system-ui';
    ctx.fillText(`Example values: w=${(w*1e6).toFixed(1)} µm, v_h=${(vh/1e4).toFixed(1)}×10^4 m/s, v_e=${(ve/1e4).toFixed(1)}×10^4 m/s`, devX, by+30);
  }

  // ---------- Draw main plot ----------
  function drawMainPlot(ctx, W, H, params){
    ctx.clearRect(0,0,W,H);
    const {w,vh,ve,N,e, mode} = params;

    const s = sampleCurrents(w,vh,ve,N,e,650);
    const {ptsH, ptsE, ptsT, thMax, teMax, tMax} = s;

    // choose scaling
    let xMin=0, xMax=tMax, yMin=0, yMax=0;
    const yVals = ptsT.map(p=>p.y).concat(ptsH.map(p=>p.y), ptsE.map(p=>p.y));
    yMax = Math.max(...yVals)*1.10;
    yMin = Math.min(0, ...yVals)*1.10;

    let xLabel='t (s)', yLabel='Current i (A)', title='Induced currents vs time';
    let transformX = (t)=>t, transformY=(i)=>i;

    if (mode === 'physical'){
      // show ns and mA
      transformX = (t)=>t*1e9;
      transformY = (i)=>i*1e3;
      xMin = 0; xMax = tMax*1e9;
      yMin = yMin*1e3; yMax = yMax*1e3;
      xLabel='t (ns)'; yLabel='Current (mA)';
      title='i_h(t), i_e(t), and i(t) — example numeric pulse';
    } else {
      // normalized: t/(w/vh), i/(Ne vh/w)
      const tH = w/vh;
      const iScale = (N*e*vh/w);
      transformX = (t)=>t/tH;
      transformY = (i)=>i/iScale;
      xMin = 0; xMax = tMax/tH;
      yMin = yMin/iScale; yMax = yMax/iScale;
      xLabel='t / (w/v_h)'; yLabel='i / (N e v_h / w)';
      title='Normalized currents (dimensionless): shape from transit-time spread';
    }

    const box = {x:14,y:14,w:W-28,h:H-28};
    const ax = drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title);

    // Draw lines
    function mapPts(pts){ return pts.map(p=>({x: transformX(p.x), y: transformY(p.y)})); }
    const Hn = mapPts(ptsH), En = mapPts(ptsE), Tn = mapPts(ptsT);

    ctx.save();
    ctx.lineWidth=2.4;

    // hole
    ctx.strokeStyle='rgba(134,239,172,0.95)';
    line(ctx, Hn, ax.xToPx, ax.yToPx);

    // electron
    ctx.strokeStyle='rgba(125,211,252,0.95)';
    line(ctx, En, ax.xToPx, ax.yToPx);

    // total
    ctx.strokeStyle='rgba(167,139,250,0.95)';
    line(ctx, Tn, ax.xToPx, ax.yToPx);

    // markers for key times
    const tE = (mode==='physical') ? teMax*1e9 : teMax/(w/vh);
    const tH = (mode==='physical') ? thMax*1e9 : thMax/(w/vh);

    ctx.strokeStyle='rgba(234,240,255,0.35)';
    ctx.setLineDash([6,6]);
    ctx.lineWidth=1.4;

    // vertical line tE
    const xE = ax.xToPx(tE);
    ctx.beginPath(); ctx.moveTo(xE, ax.plot.y); ctx.lineTo(xE, ax.plot.y+ax.plot.h); ctx.stroke();

    // vertical line tH
    const xH = ax.xToPx(tH);
    ctx.beginPath(); ctx.moveTo(xH, ax.plot.y); ctx.lineTo(xH, ax.plot.y+ax.plot.h); ctx.stroke();

    ctx.setLineDash([]);

    ctx.fillStyle='rgba(234,240,255,0.82)';
    ctx.font='12px ui-sans-serif, system-ui';
    ctx.fillText('t = w/v_e', xE+6, ax.plot.y+18);
    ctx.fillText('t = w/v_h', xH+6, ax.plot.y+34);

    ctx.restore();

    legend(ctx, [
      {label:'hole i_h(t)', stroke:'rgba(134,239,172,0.95)'},
      {label:'electron i_e(t)', stroke:'rgba(125,211,252,0.95)'},
      {label:'total i(t)', stroke:'rgba(167,139,250,0.95)'}
    ], ax.plot.x + 12, ax.plot.y + 40);
  }

  // ---------- Draw secondary sweep plot ----------
  function drawSweepPlot(ctx, W, H, params){
    ctx.clearRect(0,0,W,H);
    const {w,vh,N,e,k, mode} = params;

    // Sweep k from 1 to 40
    const kMin=1, kMax=40;
    const ptsPeak=[], ptsTe=[];
    for (let kk=kMin; kk<=kMax+1e-9; kk+=0.25){
      const ve = kk*vh;
      const i0 = (N*e/w)*(vh+ve);
      const te = w/ve;
      ptsPeak.push({x:kk, y:i0});
      ptsTe.push({x:kk, y:te});
    }

    // Scaling
    // We'll plot in two panels on same axes by normalizing each curve to [0,1] in normalized mode,
    // or in physical mode use two y-axes "combined" by normalization for readability.
    // To keep one axis, we will plot:
    //   y1 = i0 / i0(k=1)  (dimensionless)
    //   y2 = (w/ve) / (w/vh) = 1/k (dimensionless)
    // This makes the relationships clear and comparable.

    const i0_ref = (N*e/w)*(vh + 1*vh); // k=1 -> ve=vh
    const peakN = ptsPeak.map(p=>({x:p.x, y:p.y/i0_ref}));
    const teN = ptsTe.map(p=>({x:p.x, y:(p.y)/(w/vh)})); // = 1/k

    const box = {x:14,y:14,w:W-28,h:H-28};
    const ax = drawAxes(ctx, box, kMin, kMax, 0, 2.2, 'k = v_e / v_h (dimensionless)', 'normalized value', 'Parameter sweep: peak current & electron cutoff vs k');

    ctx.save();
    ctx.lineWidth=2.4;

    ctx.strokeStyle='rgba(167,139,250,0.95)';
    line(ctx, peakN, ax.xToPx, ax.yToPx);

    ctx.strokeStyle='rgba(125,211,252,0.95)';
    line(ctx, teN, ax.xToPx, ax.yToPx);

    // marker at current k
    const mx = ax.xToPx(k);
    const my1 = ax.yToPx(((N*e/w)*(vh + k*vh))/i0_ref);
    const my2 = ax.yToPx(1/k);

    ctx.fillStyle='rgba(234,240,255,0.92)';
    ctx.strokeStyle='rgba(0,0,0,0.35)';
    ctx.lineWidth=1.2;

    function dot(x,y){
      ctx.beginPath(); ctx.arc(x,y,4.6,0,Math.PI*2); ctx.fill(); ctx.stroke();
    }
    dot(mx,my1);
    dot(mx,my2);

    ctx.fillStyle='rgba(234,240,255,0.82)';
    ctx.font='12px ui-sans-serif, system-ui';
    ctx.fillText('peak i(0) / i(0)|k=1', ax.plot.x+12, ax.plot.y+38);
    ctx.fillText('(w/v_e)/(w/v_h) = 1/k', ax.plot.x+12, ax.plot.y+56);

    ctx.restore();

    legend(ctx, [
      {label:'peak current scale', stroke:'rgba(167,139,250,0.95)'},
      {label:'electron cutoff (normalized)', stroke:'rgba(125,211,252,0.95)'}
    ], ax.plot.x + 12, ax.plot.y + 72);
  }

  // ---------- Orchestrate rendering ----------
  const kSlider = document.getElementById('kSlider');
  const kReadout = document.getElementById('kReadout');
  const scaleSelect = document.getElementById('scaleSelect');

  function render(){
    const k = parseFloat(kSlider.value);
    kReadout.textContent = k.toFixed(1);

    const mode = scaleSelect.value === 'normalized' ? 'normalized' : 'physical';

    const w = example.w;
    const vh = example.vh;
    const ve = k * vh;
    const N = example.N;
    const e = example.e;

    // Resize canvases (CSS px returned)
    const d = diag.resize();
    const p1 = plot1.resize();
    const p2 = plot2.resize();

    // Draw
    drawDiagram(diag.ctx, d.w, d.h, w, vh, ve);
    drawMainPlot(plot1.ctx, p1.w, p1.h, {w,vh,ve,N,e, mode});
    drawSweepPlot(plot2.ctx, p2.w, p2.h, {w,vh,N,e,k, mode});
  }

  kSlider.addEventListener('input', render);
  scaleSelect.addEventListener('change', render);
  window.addEventListener('resize', ()=>{ render(); });

  // initial
  render();
})();
</script>
</body>
</html>
