<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Excess Noise Factor for a Photoconductive Detector (Random Gain)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --card2:#0f1730;
      --ink:#eaf0ff;
      --muted:#b7c3e6;
      --faint:#7f8bb1;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(125,211,252,.20), transparent 55%),
        radial-gradient(900px 520px at 80% 0%, rgba(167,139,250,.16), transparent 55%),
        radial-gradient(900px 650px at 50% 120%, rgba(52,211,153,.10), transparent 60%),
        linear-gradient(180deg, #070a14, var(--bg));
      line-height:1.55;
    }
    a{color:var(--accent)}
    header{
      padding:32px 18px 14px;
      max-width:1100px;
      margin:0 auto;
    }
    .hero{
      display:grid;
      gap:14px;
      grid-template-columns: 1.25fr .75fr;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns:1fr}
    }
    .titleCard{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      box-shadow:var(--shadow);
      border-radius:var(--radius);
      padding:20px 18px;
      overflow:hidden;
      position:relative;
    }
    .titleCard:before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(600px 240px at 15% 10%, rgba(125,211,252,.14), transparent 55%),
        radial-gradient(520px 220px at 75% 15%, rgba(167,139,250,.12), transparent 60%);
      pointer-events:none;
      filter:saturate(1.1);
    }
    h1{
      margin:0 0 6px;
      font-size: clamp(1.35rem, 2.2vw, 2.05rem);
      letter-spacing:.2px;
      position:relative;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      position:relative;
    }
    .meta{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:12px;
      position:relative;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.14);
      color:var(--muted);
      font-size:.92rem;
    }
    .pill b{color:var(--ink); font-weight:700}
    .toc{
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      box-shadow:var(--shadow);
      border-radius:var(--radius);
      padding:16px 14px;
      position:sticky;
      top:14px;
      height:fit-content;
    }
    .toc h2{
      margin:0 0 8px;
      font-size:1rem;
      color:var(--muted);
      letter-spacing:.2px;
    }
    .toc a{
      display:block;
      padding:7px 8px;
      border-radius:10px;
      text-decoration:none;
      color:var(--ink);
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:.97rem;
    }
    .toc a:hover{
      background:rgba(125,211,252,.08);
      border-color:rgba(125,211,252,.18);
      transform: translateX(2px);
    }
    main{
      max-width:1100px;
      margin:0 auto;
      padding:0 18px 48px;
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
      .toc{position:relative; top:auto}
    }
    section{
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:18px 16px;
      overflow:hidden;
    }
    section h2{
      margin:0 0 10px;
      font-size:1.18rem;
      letter-spacing:.2px;
    }
    section h3{
      margin:14px 0 8px;
      font-size:1.03rem;
      color:var(--muted);
      letter-spacing:.15px;
    }
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
    }
    @media (max-width: 720px){
      .grid2{grid-template-columns:1fr}
    }
    .callout{
      border:1px solid var(--line);
      background: rgba(0,0,0,.16);
      border-radius:14px;
      padding:12px 12px;
    }
    .callout .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-weight:800;
      letter-spacing:.2px;
      font-size:.92rem;
      margin-bottom:6px;
    }
    .tag.assump{color:var(--warn)}
    .tag.keyeq{color:var(--accent)}
    .tag.mist{color:var(--bad)}
    .tag.final{color:var(--good)}
    .eq{
      font-family:var(--mono);
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      padding:10px 10px;
      border-radius:12px;
      overflow:auto;
      white-space:pre;
      line-height:1.35;
      margin:8px 0 10px;
    }
    .eqRow{
      display:flex;
      align-items:stretch;
      gap:10px;
      flex-wrap:wrap;
    }
    .copyBtn{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.20);
      color:var(--ink);
      border-radius:12px;
      padding:10px 12px;
      font-weight:700;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
    }
    .copyBtn:hover{
      background:rgba(125,211,252,.10);
      border-color:rgba(125,211,252,.22);
      transform: translateY(-1px);
    }
    .copyBtn:active{transform: translateY(0px)}
    .small{font-size:.95rem}
    ul{margin:8px 0 10px 18px}
    li{margin:6px 0}
    .vizPanel{
      display:grid;
      gap:12px;
    }
    figure{
      margin:0;
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      border-radius:16px;
      padding:12px;
    }
    figcaption{
      margin-top:10px;
      color:var(--muted);
      font-size:.95rem;
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius:14px;
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.10);
    }
    .controls{
      display:grid;
      gap:10px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.16);
      border-radius:16px;
      padding:12px;
    }
    .controls h3{margin:0 0 6px}
    .controlRow{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
    }
    label{color:var(--muted); font-size:.95rem}
    input[type="range"]{width:100%}
    select{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.20);
      color:var(--ink);
      outline:none;
    }
    .readout{
      font-family:var(--mono);
      font-size:.92rem;
      color:var(--ink);
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      min-width: 170px;
      text-align:right;
    }
    footer{
      max-width:1100px;
      margin:18px auto 0;
      padding:0 18px 40px;
      color:var(--faint);
      font-size:.92rem;
    }
    .hr{
      height:1px; background:var(--line); margin:12px 0;
    }
    @media print{
      body{background:white; color:black}
      section, .toc, .titleCard, figure{box-shadow:none}
      .toc{position:relative; top:auto}
      .copyBtn{display:none}
      canvas{border:1px solid #bbb}
      a{color:black; text-decoration:none}
    }
  </style>
</head>
<body>
  <header>
    <div class="hero">
      <div class="titleCard">
        <h1>Excess Noise Factor for a Photoconductive Detector</h1>
        <p class="subtitle">
          Why a <span class="muted">random recombination lifetime</span> makes the photoconductor’s gain random — and why an <b>exponential</b> lifetime distribution forces <b>F = 2</b>.
        </p>
        <div class="meta">
          <div class="pill">Topic: <b>Photodetectors</b></div>
          <div class="pill">Key idea: <b>Random gain</b></div>
          <div class="pill">Result: <b>Excess noise factor</b> <span style="color:var(--good);font-weight:800">F=2</span></div>
        </div>
      </div>

      <nav class="toc" aria-label="Table of contents">
        <h2>Table of Contents</h2>
        <a href="#qs">Quick Summary</a>
        <a href="#p0">PART 0 — Concept Primer</a>
        <a href="#p1">PART 1 — Problem Analysis</a>
        <a href="#p2">PART 2 — Strategy & Tips</a>
        <a href="#p3">PART 3 — Full Solution</a>
        <a href="#p4">PART 4 — Deeper Understanding</a>
        <a href="#p5">PART 5 — Visualization Guide</a>
      </nav>
    </div>
  </header>

  <main>
    <article class="vizPanel">
      <section id="qs">
        <h2>Quick Summary</h2>
        <ul>
          <li><b>What this is about:</b> A photoconductor has internal gain <span class="muted">(photocarriers can traverse the device multiple times before recombining)</span>, but the recombination time is random.</li>
          <li><b>Key physics idea:</b> If the recombination lifetime <b>τ</b> is random, then the gain <b>G = τ/τ<sub>e</sub></b> is random, and randomness in gain adds noise beyond ordinary shot noise.</li>
          <li><b>Governing relation:</b> The <b>excess noise factor</b> for random gain is
            <span class="muted">F = ⟨G²⟩ / ⟨G⟩²</span> (for uncorrelated gain fluctuations per photoevent).
          </li>
          <li><b>Given model:</b> Recombination lifetime is exponential:
            <span class="muted">P(τ) = (1/τ̄) exp(−τ/τ̄), τ ≥ 0</span>.
          </li>
          <li><b>Core math:</b> For an exponential distribution, ⟨τ⟩ = τ̄ and ⟨τ²⟩ = 2τ̄².</li>
          <li><b>Final result (symbolic):</b> Because G ∝ τ, <b>F = ⟨τ²⟩/⟨τ⟩² = 2</b>.</li>
          <li><b>Meaning for SNR:</b> Random-gain SNR is smaller than deterministic-gain SNR by a factor <b>F</b>, so <b>generation–recombination (GR) noise degrades SNR by 2×</b>.</li>
        </ul>
      </section>

      <section id="p0">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <div class="grid2">
          <div class="callout">
            <div class="tag keyeq">Core definitions</div>
            <div class="eq" id="eq_defs">G = τ / τ_e
τ_e = electron transit time across sample
τ = excess-carrier recombination lifetime (random)
F = ⟨G²⟩ / ⟨G⟩²  (excess noise factor for random gain)</div>
            <div class="eqRow">
              <button class="copyBtn" data-copy="G = τ / τ_e">Copy: G equation</button>
              <button class="copyBtn" data-copy="F = ⟨G²⟩ / ⟨G⟩²">Copy: F definition</button>
            </div>
          </div>

          <div class="callout">
            <div class="tag assump">Symbols & units</div>
            <ul>
              <li><b>τ</b> (s): time an excess electron–hole pair survives before recombination.</li>
              <li><b>τ̄</b> (s): mean recombination lifetime, τ̄ = ⟨τ⟩.</li>
              <li><b>τ<sub>e</sub></b> (s): electron transit time through the device (set by drift velocity / device length).</li>
              <li><b>G</b> (dimensionless): photoconductive gain ≈ expected number of circuit “passes” per absorbed photon.</li>
              <li><b>F</b> (dimensionless): factor quantifying SNR penalty from gain randomness.</li>
            </ul>
          </div>
        </div>

        <h3>Physical meaning (what these quantities “feel like”)</h3>
        <ul>
          <li><b>Photoconductive gain</b> exists because a single absorbed photon can create carriers that persist long enough to be swept through the external circuit multiple times.</li>
          <li><b>Transit time τ<sub>e</sub></b> is how quickly the electric field carries an electron across the sample once; shorter τ<sub>e</sub> means more passes per unit lifetime → higher gain.</li>
          <li><b>Recombination lifetime τ</b> is inherently stochastic: recombination is a random termination event. That randomness turns <b>G</b> into a random variable.</li>
          <li><b>Excess noise factor F</b> measures how much additional noise you get compared with pretending the gain is perfectly deterministic.</li>
        </ul>

        <h3>Key principles & validity</h3>
        <div class="callout">
          <div class="tag assump">Assumptions typically used here</div>
          <ul>
            <li>Each photo-generated carrier’s recombination is a <b>memoryless</b> random process → exponential lifetime model.</li>
            <li>Transit time <b>τ<sub>e</sub></b> is treated as fixed (device geometry and bias fixed; drift velocity approximately constant).</li>
            <li>Gain fluctuations are treated as <b>independent</b> from event to event, so moments ⟨G⟩ and ⟨G²⟩ control the noise penalty.</li>
          </ul>
        </div>

        <h3>Common models & why we use them</h3>
        <ul>
          <li><b>Exponential lifetime:</b> If recombination is a Poisson process with constant rate, then survival probability decays exponentially; this is the simplest realistic model.</li>
          <li><b>Gamma family (broader view):</b> If lifetime results from multiple “stages” or averaging, a gamma distribution can model narrower or broader lifetime statistics; exponential is a special case.</li>
        </ul>

        <h3>Mini intuition examples (conceptual, not algebra-heavy)</h3>
        <ul>
          <li><b>If τ were fixed:</b> every photoevent produces the same gain → no extra noise from gain randomness → expect <b>F = 1</b>.</li>
          <li><b>If τ is very variable:</b> some events last much longer (very large G), others die quickly (small G) → the output fluctuates more → <b>F &gt; 1</b>.</li>
        </ul>

        <div class="callout">
          <div class="tag mist">What to watch for</div>
          <ul>
            <li>Mixing up <b>τ̄</b> (mean lifetime) with the random lifetime <b>τ</b> itself.</li>
            <li>Forgetting that <b>F depends on second moments</b> (⟨G²⟩), not just the mean gain ⟨G⟩.</li>
            <li>Assuming “exponential” means “most likely equals the mean” — actually the exponential’s mode is at 0, and it has a long tail.</li>
          </ul>
        </div>
      </section>

      <section id="p1">
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

        <h3>Problem restated (in plain language)</h3>
        <p class="muted">
          A photoconductive detector has gain <b>G = τ/τ<sub>e</sub></b>. In reality the recombination lifetime <b>τ</b> is random. If τ is exponentially distributed
          <span style="font-family:var(--mono)">(1/τ̄)exp(−τ/τ̄)</span>, show that the corresponding <b>excess noise factor</b> is <b>F = 2</b>.
          Conclude that gain randomness (generation–recombination noise) reduces the current SNR by a factor of 2.
        </p>

        <div class="grid2">
          <div class="callout">
            <div class="tag assump">Given</div>
            <ul>
              <li>Gain model: <b>G = τ/τ<sub>e</sub></b>.</li>
              <li>Lifetime PDF: <b>P(τ) = (1/τ̄) exp(−τ/τ̄)</b>, τ ≥ 0.</li>
              <li>τ̄ is the mean lifetime: τ̄ = ⟨τ⟩.</li>
              <li>SNR relation for random gain (from the prompt’s Eq. 19.6-25 idea): <span class="muted">SNR ∝ 1/F</span>.</li>
            </ul>
          </div>
          <div class="callout">
            <div class="tag assump">Unknowns / must show</div>
            <ul>
              <li>Compute the <b>excess noise factor</b> <b>F</b> implied by the random τ.</li>
              <li>Show specifically that <b>F = 2</b> for exponential τ.</li>
              <li>Interpretation: SNR is degraded by factor <b>2</b>.</li>
            </ul>
          </div>
        </div>

        <h3>Which principles apply (and why)</h3>
        <ul>
          <li><b>Stochastic recombination:</b> Exponential lifetime corresponds to a constant recombination rate (memoryless termination). This directly determines moments ⟨τ⟩ and ⟨τ²⟩.</li>
          <li><b>Random-gain noise:</b> When gain per photoevent is random, the shot-noise-like variance scales with ⟨G²⟩, while the mean scales with ⟨G⟩. Their ratio produces <b>F</b>.</li>
          <li><b>Why not detailed semiconductor transport?</b> We don’t need drift-diffusion PDEs or bandstructure; the problem is purely about how <b>random lifetime statistics</b> map into <b>gain statistics</b>.</li>
        </ul>

        <div class="callout">
          <div class="tag assump">Explicit assumptions used in the derivation</div>
          <ul>
            <li>τ<sub>e</sub> is constant (device and bias fixed).</li>
            <li>τ is independent of τ<sub>e</sub> and independent from event to event.</li>
            <li>Exponential PDF is correctly normalized and defined for τ ≥ 0.</li>
            <li>Excess noise factor is defined by gain moments: <b>F = ⟨G²⟩/⟨G⟩²</b>.</li>
          </ul>
        </div>

        <h3>Possible approaches (compare briefly)</h3>
        <ul>
          <li><b>(A) Moment method (best):</b> Use G = τ/τ<sub>e</sub>, compute ⟨G⟩ and ⟨G²⟩ from exponential moments → immediate F. <span class="muted">Fastest and cleanest.</span></li>
          <li><b>(B) Transform the PDF:</b> Convert P(τ) to P(G), then compute gain moments by integration in G. <span class="muted">More steps; same math.</span></li>
          <li><b>(C) Monte Carlo intuition:</b> Simulate many lifetimes and estimate F numerically to confirm. <span class="muted">Great sanity check, not necessary for proof.</span></li>
        </ul>
        <p class="muted"><b>Choice:</b> We’ll use <b>(A)</b> because it proves the result with minimal assumptions and highlights the physics (noise comes from second moments).</p>
      </section>

      <section id="p2">
        <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>
        <ol>
          <li><b>Goal:</b> Express F in terms of τ. <b>Tool:</b> Use G = τ/τ<sub>e</sub>. <b>Meaning:</b> Gain randomness is lifetime randomness scaled by a constant.</li>
          <li><b>Goal:</b> Write ⟨G⟩ and ⟨G²⟩. <b>Tool:</b> Linearity of expectation. <b>Meaning:</b> Mean output vs fluctuation power.</li>
          <li><b>Goal:</b> Compute ⟨τ⟩ and ⟨τ²⟩ for an exponential PDF. <b>Tool:</b> Standard exponential moments or direct integration by parts. <b>Meaning:</b> Exponential has variance = τ̄².</li>
          <li><b>Goal:</b> Form F = ⟨G²⟩/⟨G⟩² and simplify. <b>Tool:</b> Algebra cancellation of τ<sub>e</sub>. <b>Meaning:</b> F depends on lifetime statistics, not transit time.</li>
          <li><b>Goal:</b> Connect to SNR. <b>Tool:</b> SNR_random = SNR_det / F. <b>Meaning:</b> GR noise is a multiplicative penalty.</li>
        </ol>

        <div class="grid2">
          <div class="callout">
            <div class="tag mist">Common mistakes</div>
            <ul>
              <li>Using F = ⟨G⟩ instead of ⟨G²⟩/⟨G⟩².</li>
              <li>Forgetting τ<sub>e</sub> cancels in F (it does, because G is linear in τ).</li>
              <li>Computing ⟨τ²⟩ incorrectly (for exponential it is <b>2τ̄²</b>, not τ̄²).</li>
            </ul>
          </div>
          <div class="callout">
            <div class="tag keyeq">Quick tips</div>
            <ul>
              <li>Remember: for exponential with mean τ̄, <b>Var(τ) = τ̄²</b> and <b>⟨τ²⟩ = Var + mean² = 2τ̄²</b>.</li>
              <li>Interpretation shortcut: because G ∝ τ, the relative variance of G equals the relative variance of τ.</li>
            </ul>
          </div>
        </div>
      </section>

      <section id="p3">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Physical intuition before math</h3>
        <p class="muted">
          If recombination is memoryless, some carriers die quickly, while a few survive unusually long. Those rare long-lived carriers
          contribute disproportionately large gain. That “heavy tail” boosts ⟨G²⟩ relative to ⟨G⟩², so we expect <b>F &gt; 1</b>.
          For an exponential distribution, the variability is especially strong (coefficient of variation = 1), so it’s plausible we get a simple constant like <b>2</b>.
        </p>

        <div class="callout">
          <div class="tag keyeq">Step 1 — Define the random variables</div>
          <p class="muted small">
            Let <b>τ</b> be the random recombination lifetime (s). The photoconductive gain for one photoevent is
          </p>
          <div class="eq" id="eq_G">G = τ / τ_e</div>
          <p class="muted small">
            where <b>τ<sub>e</sub></b> is the (constant) electron transit time (s).
          </p>
        </div>

        <div class="callout">
          <div class="tag keyeq">Step 2 — Use the definition of excess noise factor</div>
          <p class="muted small">
            For random gain, a common (and the one implied in the prompt’s SNR relation) definition is
          </p>
          <div class="eq" id="eq_Fdef">F = ⟨G²⟩ / ⟨G⟩²</div>
          <p class="muted small">
            This compares the second moment to the square of the first: if gain is deterministic, then G is constant and ⟨G²⟩ = ⟨G⟩² → <b>F=1</b>.
          </p>
        </div>

        <h3>Step 3 — Express ⟨G⟩ and ⟨G²⟩ in terms of τ</h3>
        <p class="muted">
          Because τ<sub>e</sub> is a constant scale factor,
        </p>
        <div class="eq" id="eq_moments">
⟨G⟩  = ⟨τ/τ_e⟩   = (1/τ_e) ⟨τ⟩
⟨G²⟩ = ⟨(τ/τ_e)²⟩ = (1/τ_e²) ⟨τ²⟩</div>
        <p class="muted">
          <b>What we did:</b> pulled constants outside the expectation. <b>Why:</b> it isolates the problem to lifetime statistics ⟨τ⟩ and ⟨τ²⟩.
        </p>

        <h3>Step 4 — Insert the exponential PDF and compute ⟨τ⟩, ⟨τ²⟩</h3>
        <p class="muted">
          The lifetime is exponentially distributed with mean τ̄:
        </p>
        <div class="eq" id="eq_pdf">P(τ) = (1/τ̄) exp(−τ/τ̄),   τ ≥ 0</div>

        <div class="callout">
          <div class="tag keyeq">Compute ⟨τ⟩</div>
          <div class="eq" id="eq_tau1">
⟨τ⟩ = ∫₀^∞ τ P(τ) dτ
     = ∫₀^∞ τ (1/τ̄) e^(−τ/τ̄) dτ</div>
          <p class="muted small">
            Substitute x = τ/τ̄ ⇒ τ = τ̄ x, dτ = τ̄ dx:
          </p>
          <div class="eq" id="eq_tau1b">
⟨τ⟩ = ∫₀^∞ (τ̄ x) (1/τ̄) e^(−x) (τ̄ dx)
     = τ̄ ∫₀^∞ x e^(−x) dx</div>
          <p class="muted small">
            The integral ∫₀^∞ x e^(−x) dx = 1 (a standard Gamma-function result; also obtainable by integration by parts).
            Therefore <b>⟨τ⟩ = τ̄</b>.
          </p>
        </div>

        <div class="callout">
          <div class="tag keyeq">Compute ⟨τ²⟩</div>
          <div class="eq" id="eq_tau2">
⟨τ²⟩ = ∫₀^∞ τ² P(τ) dτ
      = ∫₀^∞ τ² (1/τ̄) e^(−τ/τ̄) dτ</div>
          <p class="muted small">
            Use the same substitution x = τ/τ̄:
          </p>
          <div class="eq" id="eq_tau2b">
⟨τ²⟩ = ∫₀^∞ (τ̄² x²) (1/τ̄) e^(−x) (τ̄ dx)
      = τ̄² ∫₀^∞ x² e^(−x) dx</div>
          <p class="muted small">
            The integral ∫₀^∞ x² e^(−x) dx = 2. Hence <b>⟨τ²⟩ = 2 τ̄²</b>.
          </p>
        </div>

        <h3>Step 5 — Form F and simplify</h3>
        <p class="muted">
          Insert the moment relations into F:
        </p>
        <div class="eq" id="eq_Fcalc">
F = ⟨G²⟩ / ⟨G⟩²
  = [ (1/τ_e²) ⟨τ²⟩ ] / [ ( (1/τ_e) ⟨τ⟩ )² ]
  = ⟨τ²⟩ / ⟨τ⟩²</div>
        <p class="muted">
          <b>What happened:</b> τ<sub>e</sub> cancels completely. <b>Why this matters:</b> the excess noise factor is controlled by the <b>relative spread</b> of lifetimes, not by the device transit time.
        </p>

        <p class="muted">
          For exponential lifetimes, ⟨τ⟩ = τ̄ and ⟨τ²⟩ = 2τ̄², so
        </p>

        <div class="callout">
          <div class="tag final">Final result</div>
          <div class="eq" id="eq_final">F = ⟨τ²⟩ / ⟨τ⟩² = (2 τ̄²) / (τ̄²) = 2</div>
          <div class="eqRow">
            <button class="copyBtn" data-copy="F = ⟨τ²⟩/⟨τ⟩² = 2 (for exponential P(τ) = (1/τ̄) e^(−τ/τ̄))">Copy: final result</button>
          </div>
        </div>

        <h3>Sanity checks</h3>
        <div class="grid2">
          <div class="callout">
            <div class="tag keyeq">Units/dimensions</div>
            <ul>
              <li>G is dimensionless (ratio of times). F is dimensionless (ratio of moments of G).</li>
              <li>In F = ⟨τ²⟩/⟨τ⟩², units: s² / (s²) → dimensionless ✔</li>
            </ul>
          </div>
          <div class="callout">
            <div class="tag keyeq">Limiting/consistency cases</div>
            <ul>
              <li>If τ were deterministic (no spread): ⟨τ²⟩ = ⟨τ⟩² → F = 1, as expected.</li>
              <li>Exponential has substantial spread (Var = τ̄²): F = 1 + Var/mean² = 1 + 1 = 2 ✔</li>
            </ul>
          </div>
        </div>

        <h3>Connect to SNR statement in the prompt</h3>
        <p class="muted">
          The prompt’s random-gain SNR relation states that the SNR is reduced by a factor F compared to deterministic gain.
          Therefore, for an exponential recombination lifetime,
        </p>
        <div class="eq" id="eq_snr">
SNR_random = SNR_deterministic / F = SNR_deterministic / 2</div>
        <p class="muted">
          <b>Plain-language interpretation:</b> generation–recombination (GR) randomness makes the photoconductor output fluctuate twice as much (in the specific “excess factor” sense), cutting the achievable SNR in half.
        </p>

        <p class="muted small">
          Diagram/plot connection: the long tail of P(τ) (and thus P(G)) boosts second moments, which is exactly what the plots below visualize.
        </p>
      </section>

      <section id="p4">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <h3>Reinterpret the final formula</h3>
        <p class="muted">
          Since <b>G = τ/τ<sub>e</sub></b> with τ<sub>e</sub> constant,
          <span style="font-family:var(--mono)">F = ⟨τ²⟩/⟨τ⟩²</span>.
          This can be rewritten using variance:
        </p>
        <div class="eq" id="eq_var">
⟨τ²⟩ = Var(τ) + ⟨τ⟩²  ⇒  F = 1 + Var(τ)/⟨τ⟩²</div>
        <p class="muted">
          So <b>F is “1 + (relative variance)”</b>. Exponential lifetimes have Var(τ)=⟨τ⟩², hence F=2.
        </p>

        <h3>How changing parameters affects the outcome (tie to interactive plots)</h3>
        <ul>
          <li>Changing <b>τ̄</b> (mean lifetime) scales the distribution horizontally and changes the mean gain ⟨G⟩ = τ̄/τ<sub>e</sub>, but it <b>does not change F</b> for a fixed shape (exponential stays F=2).</li>
          <li>Changing the <b>shape</b> (how variable lifetimes are) changes the relative variance and thus <b>F</b>. In the interactive, we generalize to a <b>gamma</b> family: exponential corresponds to shape k=1; larger k makes lifetimes less variable and drives <b>F → 1</b>.</li>
          <li>Changing <b>τ<sub>e</sub></b> changes the mean gain but cancels out of F; the plots update the indicated ⟨G⟩ even though F may stay fixed for a fixed shape.</li>
        </ul>

        <h3>Alternative derivation idea (brief)</h3>
        <p class="muted">
          Instead of using moments of τ directly, transform variables to get the gain distribution:
          since G = τ/τ<sub>e</sub>, you can show
          <span style="font-family:var(--mono)">P(G) = (τ<sub>e</sub>/τ̄) exp(−G τ<sub>e</sub>/τ̄)</span>
          (also exponential), and then compute ⟨G⟩ and ⟨G²⟩ in G-space. Same physics, different route.
        </p>

        <h3>Concept checks (quick self-test)</h3>
        <ul>
          <li><b>Q:</b> If the gain were perfectly constant event-to-event, what is F? <b>A:</b> F=1.</li>
          <li><b>Q:</b> For exponential τ, what is Var(τ)/⟨τ⟩²? <b>A:</b> 1.</li>
          <li><b>Q:</b> Does τ<sub>e</sub> affect F? <b>A:</b> No; it cancels in ⟨G²⟩/⟨G⟩².</li>
          <li><b>Q:</b> What feature of the exponential distribution most strongly increases F? <b>A:</b> Its long tail (large rare lifetimes) increases the second moment.</li>
        </ul>
      </section>

      <section id="p5">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>
        <ul>
          <li><b>Diagram canvas:</b> A biased photoconductor slab of length <b>L</b>. The electron transit time is shown as τ<sub>e</sub> ≈ L/v<sub>d</sub>. The lifetime τ sets how long carriers survive; the mean gain is ⟨G⟩ = τ̄/τ<sub>e</sub>.</li>
          <li><b>Main plot (PDF):</b> The probability density <b>P(τ)</b> versus τ. A vertical marker shows the mean τ̄. You’ll see how “spread out” the lifetime is.</li>
          <li><b>Secondary plot (parameter sweep):</b> Excess noise factor <b>F</b> versus gamma shape <b>k</b>. At <b>k=1</b>, the distribution is exponential and you should read <b>F=2</b>. As k increases, F decreases toward 1 (less randomness).</li>
          <li><b>Interactive controls:</b>
            <ul>
              <li><b>Distribution selector:</b> Choose “Exponential” (forces k=1) or “Gamma(k)” (lets you vary k).</li>
              <li><b>Shape k slider:</b> Changes lifetime variability. Lower k → broader tail → higher F. (Exponential is exactly k=1.)</li>
              <li><b>Mean lifetime τ̄ slider:</b> Scales τ. It changes ⟨G⟩ but (for fixed k) does not change F.</li>
              <li><b>Transit time τ<sub>e</sub> slider:</b> Changes ⟨G⟩ = τ̄/τ<sub>e</sub>, but not F.</li>
            </ul>
          </li>
        </ul>
      </section>
    </article>

    <aside class="vizPanel">
      <section>
        <h2>Interactive Visualizations</h2>

        <div class="controls" aria-label="Interactive controls">
          <h3>Controls</h3>

          <div class="controlRow">
            <div>
              <label for="dist">Lifetime model</label>
              <select id="dist">
                <option value="exp">Exponential (memoryless recombination)</option>
                <option value="gamma">Gamma(k) (generalized lifetime spread)</option>
              </select>
            </div>
            <div class="readout" id="readoutF">F = 2.000</div>
          </div>

          <div class="controlRow">
            <div>
              <label for="k">Shape k (dimensionless)</label>
              <input id="k" type="range" min="1" max="20" step="1" value="1" />
            </div>
            <div class="readout" id="readoutK">k = 1</div>
          </div>

          <div class="controlRow">
            <div>
              <label for="tauBar">Mean lifetime τ̄ (µs) <span class="muted">(example value for plotting)</span></label>
              <input id="tauBar" type="range" min="0.2" max="10" step="0.1" value="2.0" />
            </div>
            <div class="readout" id="readoutTauBar">τ̄ = 2.0 µs</div>
          </div>

          <div class="controlRow">
            <div>
              <label for="tauE">Transit time τ<sub>e</sub> (ns) <span class="muted">(example value for plotting)</span></label>
              <input id="tauE" type="range" min="0.5" max="50" step="0.5" value="10.0" />
            </div>
            <div class="readout" id="readoutTauE">τe = 10.0 ns</div>
          </div>

          <div class="controlRow">
            <div>
              <label class="muted">Derived (updates live)</label>
              <div class="readout" id="readoutG">⟨G⟩ = 200.0</div>
            </div>
            <button class="copyBtn" id="copyPanel" title="Copy the current key results as plain text">Copy current results</button>
          </div>

          <div class="callout">
            <div class="tag keyeq">Reminder</div>
            <div class="eq" id="eq_panel">F = ⟨G²⟩ / ⟨G⟩² = ⟨τ²⟩ / ⟨τ⟩²</div>
          </div>
        </div>

        <figure>
          <canvas id="cDiagram" aria-label="Photoconductor setup diagram"></canvas>
          <figcaption>Diagram: photoconductor slab with bias, showing τ (recombination lifetime) and τ<sub>e</sub> (transit time). The mean gain ⟨G⟩ = τ̄/τ<sub>e</sub>.</figcaption>
        </figure>

        <figure>
          <canvas id="cPdf" aria-label="Lifetime probability density plot"></canvas>
          <figcaption>Main plot: lifetime PDF P(τ). The mean τ̄ is marked; changing k changes the spread (tail) and thus F.</figcaption>
        </figure>

        <figure>
          <canvas id="cSweep" aria-label="Excess noise factor sweep plot"></canvas>
          <figcaption>Secondary plot: F versus gamma shape k. Exponential corresponds to k=1, giving F=2.</figcaption>
        </figure>

        <div class="hr"></div>
        <div class="callout">
          <div class="tag final">Bottom line</div>
          <p class="muted" style="margin:6px 0 0">
            Exponential recombination lifetimes imply <b>F = 2</b>, so random gain from GR processes <b>halves</b> the photoconductor’s current SNR relative to an ideal deterministic-gain model.
          </p>
        </div>
      </section>
    </aside>
  </main>

  <footer>
    <div class="hr"></div>
    <p>
      This article used example numerical values only for plotting (<span style="font-family:var(--mono)">τ̄</span> in µs and <span style="font-family:var(--mono)">τ<sub>e</sub></span> in ns). The proven result <b>F=2</b> for exponential lifetimes is fully symbolic and independent of those example values.
    </p>
  </footer>

  <script>
    // ---------------------------
    // Utilities: clipboard copy
    // ---------------------------
    function copyText(txt){
      navigator.clipboard.writeText(txt).then(()=>{
        toast("Copied ✓");
      }).catch(()=>{
        // fallback
        const ta=document.createElement("textarea");
        ta.value=txt;
        document.body.appendChild(ta);
        ta.select();
        try{document.execCommand("copy"); toast("Copied ✓");}
        catch(e){toast("Copy failed");}
        document.body.removeChild(ta);
      });
    }

    // tiny toast
    let toastEl=null, toastTimer=null;
    function toast(msg){
      if(!toastEl){
        toastEl=document.createElement("div");
        toastEl.style.position="fixed";
        toastEl.style.left="50%";
        toastEl.style.bottom="18px";
        toastEl.style.transform="translateX(-50%)";
        toastEl.style.padding="10px 12px";
        toastEl.style.borderRadius="12px";
        toastEl.style.border="1px solid rgba(255,255,255,.16)";
        toastEl.style.background="rgba(0,0,0,.55)";
        toastEl.style.color="white";
        toastEl.style.fontFamily="ui-sans-serif, system-ui";
        toastEl.style.fontWeight="700";
        toastEl.style.letterSpacing=".2px";
        toastEl.style.boxShadow="0 10px 28px rgba(0,0,0,.35)";
        toastEl.style.zIndex="9999";
        toastEl.style.opacity="0";
        toastEl.style.transition="opacity .15s ease, transform .15s ease";
        document.body.appendChild(toastEl);
      }
      toastEl.textContent=msg;
      toastEl.style.opacity="1";
      toastEl.style.transform="translateX(-50%) translateY(-2px)";
      clearTimeout(toastTimer);
      toastTimer=setTimeout(()=>{
        toastEl.style.opacity="0";
        toastEl.style.transform="translateX(-50%) translateY(0px)";
      }, 900);
    }

    // attach copy buttons
    document.querySelectorAll(".copyBtn[data-copy]").forEach(btn=>{
      btn.addEventListener("click", ()=> copyText(btn.getAttribute("data-copy")));
    });

    // smooth scroll for TOC
    document.querySelectorAll('.toc a').forEach(a=>{
      a.addEventListener('click', (e)=>{
        e.preventDefault();
        const id=a.getAttribute('href');
        const el=document.querySelector(id);
        if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
      });
    });

    // ---------------------------
    // Math helpers
    // ---------------------------
    function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

    // Gamma(k, theta) with integer k via Erlang formula
    // PDF: f(t) = t^(k-1) exp(-t/theta) / (Gamma(k) theta^k), t>=0
    // Here k is positive integer (slider).
    function gammaPdf(t, k, theta){
      if(t < 0) return 0;
      // compute log to avoid overflow for some parameters
      // For integer k, Gamma(k) = (k-1)!
      let logNum = (k-1)*Math.log(Math.max(t, 1e-300)) - (t/theta);
      let logDen = Math.log(fact(k-1)) + k*Math.log(theta);
      return Math.exp(logNum - logDen);
    }
    function fact(n){
      let r=1;
      for(let i=2;i<=n;i++) r*=i;
      return r;
    }

    // For Gamma(k, theta): mean = k theta, var = k theta^2
    // So F = 1 + var/mean^2 = 1 + 1/k
    function F_of_k(k){ return 1 + 1/k; }

    // ---------------------------
    // Canvas: crisp resizing
    // ---------------------------
    function setupHiDPICanvas(canvas){
      const ctx = canvas.getContext("2d");
      function resize(){
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        const w = Math.max(280, rect.width);
        const h = rect.height || 320;
        canvas.width = Math.round(w * dpr);
        canvas.height = Math.round(h * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
        return {w, h, dpr};
      }
      return {ctx, resize};
    }

    // ---------------------------
    // Plotting utilities
    // ---------------------------
    function drawAxes(ctx, box, opts){
      const {xMin,xMax,yMin,yMax,xLabel,yLabel,title} = opts;
      const {x,y,w,h} = box;

      // background
      ctx.save();
      ctx.clearRect(0,0, ctx.canvas.width, ctx.canvas.height);
      // Panel shading
      const g = ctx.createLinearGradient(0,y,0,y+h);
      g.addColorStop(0, "rgba(255,255,255,0.05)");
      g.addColorStop(1, "rgba(255,255,255,0.02)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);
      ctx.restore();

      // title
      ctx.save();
      ctx.fillStyle = "rgba(234,240,255,0.95)";
      ctx.font = "700 14px ui-sans-serif, system-ui";
      ctx.fillText(title, x+10, y+18);
      ctx.restore();

      // plot frame
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.lineWidth = 1;
      ctx.strokeRect(x,y,w,h);
      ctx.restore();

      // grid + ticks
      const nX = 6, nY = 5;
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;

      function xMap(v){ return x + (v-xMin)/(xMax-xMin)*w; }
      function yMap(v){ return y + h - (v-yMin)/(yMax-yMin)*h; }

      // grid lines
      for(let i=0;i<=nX;i++){
        const xv = x + i*w/nX;
        ctx.beginPath();
        ctx.moveTo(xv, y);
        ctx.lineTo(xv, y+h);
        ctx.stroke();
      }
      for(let j=0;j<=nY;j++){
        const yv = y + j*h/nY;
        ctx.beginPath();
        ctx.moveTo(x, yv);
        ctx.lineTo(x+w, yv);
        ctx.stroke();
      }

      // ticks labels
      ctx.fillStyle = "rgba(183,195,230,0.95)";
      ctx.font = "12px ui-sans-serif, system-ui";
      for(let i=0;i<=nX;i++){
        const v = xMin + i*(xMax-xMin)/nX;
        const xv = xMap(v);
        const txt = formatTick(v);
        ctx.fillText(txt, xv-10, y+h+18);
      }
      for(let j=0;j<=nY;j++){
        const v = yMin + j*(yMax-yMin)/nY;
        const yv = yMap(v);
        const txt = formatTick(v);
        ctx.fillText(txt, x-38, yv+4);
      }

      // axis labels
      ctx.fillStyle = "rgba(183,195,230,0.95)";
      ctx.font = "600 12px ui-sans-serif, system-ui";
      ctx.fillText(xLabel, x + w/2 - ctx.measureText(xLabel).width/2, y+h+36);

      // rotated y label
      ctx.save();
      ctx.translate(x-52, y+h/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
      ctx.restore();

      ctx.restore();

      return {xMap, yMap};
    }

    function formatTick(v){
      const av = Math.abs(v);
      if(av >= 1000) return (v/1000).toFixed(1)+"k";
      if(av >= 100) return v.toFixed(0);
      if(av >= 10) return v.toFixed(1);
      if(av >= 1) return v.toFixed(2);
      if(av >= 0.1) return v.toFixed(2);
      return v.toFixed(3);
    }

    function strokePath(ctx, pts, color, width){
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.beginPath();
      for(let i=0;i<pts.length;i++){
        const p=pts[i];
        if(i===0) ctx.moveTo(p.x,p.y);
        else ctx.lineTo(p.x,p.y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawLegend(ctx, items, x, y){
      ctx.save();
      ctx.font = "12px ui-sans-serif, system-ui";
      let yy = y;
      for(const it of items){
        ctx.fillStyle = it.color;
        ctx.fillRect(x, yy-9, 14, 10);
        ctx.fillStyle = "rgba(234,240,255,0.92)";
        ctx.fillText(it.label, x+20, yy);
        yy += 16;
      }
      ctx.restore();
    }

    // ---------------------------
    // Model state
    // ---------------------------
    const state = {
      dist: "exp",       // "exp" or "gamma"
      k: 1,              // integer >=1
      tauBar_us: 2.0,    // mean lifetime in microseconds (example)
      tauE_ns: 10.0      // transit time in nanoseconds (example)
    };

    const el = {
      dist: document.getElementById("dist"),
      k: document.getElementById("k"),
      tauBar: document.getElementById("tauBar"),
      tauE: document.getElementById("tauE"),
      readoutF: document.getElementById("readoutF"),
      readoutK: document.getElementById("readoutK"),
      readoutTauBar: document.getElementById("readoutTauBar"),
      readoutTauE: document.getElementById("readoutTauE"),
      readoutG: document.getElementById("readoutG"),
      copyPanel: document.getElementById("copyPanel"),
    };

    // canvases
    const cDiagram = setupHiDPICanvas(document.getElementById("cDiagram"));
    const cPdf = setupHiDPICanvas(document.getElementById("cPdf"));
    const cSweep = setupHiDPICanvas(document.getElementById("cSweep"));

    // ---------------------------
    // Drawing: Diagram
    // ---------------------------
    function drawDiagram(){
      const {ctx, resize} = cDiagram;
      const {w,h} = resize();

      ctx.clearRect(0,0,w,h);

      // background frame
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.14)";
      ctx.fillRect(0,0,w,h);
      ctx.restore();

      // device slab
      const pad = 18;
      const slabW = w - 2*pad;
      const slabH = Math.min(120, h*0.36);
      const slabX = pad;
      const slabY = Math.round(h*0.30);

      // draw contacts and slab
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.fillStyle = "rgba(17,26,51,0.70)";
      roundRect(ctx, slabX, slabY, slabW, slabH, 14);
      ctx.fill();
      ctx.stroke();

      // contacts
      const cW = 18;
      ctx.fillStyle = "rgba(125,211,252,0.22)";
      roundRect(ctx, slabX-6, slabY-6, cW, slabH+12, 10); ctx.fill();
      ctx.fillStyle = "rgba(167,139,250,0.20)";
      roundRect(ctx, slabX+slabW-cW+6, slabY-6, cW, slabH+12, 10); ctx.fill();

      // arrows for bias
      ctx.strokeStyle = "rgba(234,240,255,0.70)";
      ctx.lineWidth = 2;
      arrow(ctx, slabX + 24, slabY - 28, slabX + slabW - 24, slabY - 28, 10);
      ctx.font = "700 13px ui-sans-serif, system-ui";
      ctx.fillStyle = "rgba(234,240,255,0.90)";
      ctx.fillText("Bias field → (drift)", slabX + 10, slabY - 36);

      // length L marker
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth = 2;
      const yL = slabY + slabH + 24;
      ctx.beginPath();
      ctx.moveTo(slabX + 12, yL);
      ctx.lineTo(slabX + slabW - 12, yL);
      ctx.stroke();
      tick(ctx, slabX + 12, yL, 0, 10);
      tick(ctx, slabX + slabW - 12, yL, 0, 10);
      ctx.fillStyle = "rgba(183,195,230,0.95)";
      ctx.font = "600 12px ui-sans-serif, system-ui";
      ctx.fillText("Length L", slabX + slabW/2 - 30, yL + 18);

      // carrier path + transit time
      const p1x = slabX + slabW*0.25, p1y = slabY + slabH*0.55;
      const p2x = slabX + slabW*0.75, p2y = slabY + slabH*0.55;

      ctx.strokeStyle = "rgba(52,211,153,0.80)";
      ctx.lineWidth = 2.5;
      arrow(ctx, p1x, p1y, p2x, p2y, 10);

      ctx.fillStyle = "rgba(52,211,153,0.95)";
      ctx.font = "700 13px ui-sans-serif, system-ui";
      ctx.fillText("electron drift (one pass)", p1x - 10, p1y - 12);

      // show tau_e
      const tauE_ns = state.tauE_ns;
      const tauE_s = tauE_ns * 1e-9;
      ctx.fillStyle = "rgba(234,240,255,0.90)";
      ctx.font = "600 12px ui-sans-serif, system-ui";
      ctx.fillText(`τe ≈ L/vd  (example: ${tauE_ns.toFixed(1)} ns)`, slabX + 10, slabY + slabH + 52);

      // show tau and gain
      const tauBar_us = state.tauBar_us;
      const tauBar_s = tauBar_us * 1e-6;

      const k = (state.dist === "exp") ? 1 : state.k;
      const F = F_of_k(k);

      const Gmean = tauBar_s / tauE_s;

      // info box
      const boxX = pad, boxY = pad, boxW = w - 2*pad, boxH = 78;
      ctx.fillStyle = "rgba(0,0,0,0.22)";
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.lineWidth = 1.5;
      roundRect(ctx, boxX, boxY, boxW, boxH, 14);
      ctx.fill(); ctx.stroke();

      ctx.fillStyle = "rgba(183,195,230,0.95)";
      ctx.font = "700 12px ui-sans-serif, system-ui";
      ctx.fillText("Random gain from random recombination lifetime", boxX+12, boxY+20);

      ctx.fillStyle = "rgba(234,240,255,0.92)";
      ctx.font = "600 12px ui-sans-serif, system-ui";
      ctx.fillText("G = τ/τe  ⇒  ⟨G⟩ = τ̄/τe", boxX+12, boxY+40);
      ctx.fillText(`⟨G⟩ (example) = ${Gmean.toFixed(1)}     F = ${F.toFixed(3)} (SNR penalty = 1/F)`, boxX+12, boxY+60);

      ctx.restore();
    }

    function roundRect(ctx,x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }
    function arrow(ctx,x1,y1,x2,y2,head){
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
      const ang = Math.atan2(y2-y1, x2-x1);
      ctx.beginPath();
      ctx.moveTo(x2,y2);
      ctx.lineTo(x2-head*Math.cos(ang-Math.PI/7), y2-head*Math.sin(ang-Math.PI/7));
      ctx.lineTo(x2-head*Math.cos(ang+Math.PI/7), y2-head*Math.sin(ang+Math.PI/7));
      ctx.closePath();
      ctx.fillStyle = ctx.strokeStyle;
      ctx.fill();
    }
    function tick(ctx,x,y,dx,dy){
      ctx.beginPath();
      ctx.moveTo(x-dx/2, y-dy/2);
      ctx.lineTo(x+dx/2, y+dy/2);
      ctx.stroke();
    }

    // ---------------------------
    // Drawing: PDF plot
    // ---------------------------
    function drawPdf(){
      const {ctx, resize} = cPdf;
      const {w,h} = resize();

      // define plot area
      const margin = {l:64,r:18,t:34,b:56};
      const box = {x:margin.l, y:margin.t, w:w-margin.l-margin.r, h:h-margin.t-margin.b};

      const k = (state.dist === "exp") ? 1 : state.k;
      const tauBar_s = state.tauBar_us * 1e-6;
      const theta = tauBar_s / k; // so mean = k theta = tauBar_s

      // x-range: show to several means (tail)
      const xMin = 0;
      const xMax = 6 * tauBar_s; // seconds
      // estimate yMax at near mode
      let yMax = 0;
      for(let i=0;i<200;i++){
        const t = xMin + (i/199)*(xMax-xMin);
        const f = (k===1) ? (1/tauBar_s)*Math.exp(-t/tauBar_s) : gammaPdf(t,k,theta);
        yMax = Math.max(yMax, f);
      }
      yMax *= 1.12;

      const axes = drawAxes(ctx, box, {
        xMin, xMax, yMin:0, yMax,
        xLabel: "τ (s)",
        yLabel: "P(τ) (1/s)",
        title: "Lifetime distribution P(τ)"
      });

      // curve points
      const pts = [];
      const N = 420;
      for(let i=0;i<N;i++){
        const t = xMin + (i/(N-1))*(xMax-xMin);
        const f = (k===1) ? (1/tauBar_s)*Math.exp(-t/tauBar_s) : gammaPdf(t,k,theta);
        pts.push({x: axes.xMap(t), y: axes.yMap(f)});
      }

      // curve
      strokePath(ctx, pts, "rgba(125,211,252,0.95)", 2.5);

      // mean marker at tauBar_s
      const xMean = axes.xMap(tauBar_s);
      ctx.save();
      ctx.strokeStyle = "rgba(52,211,153,0.85)";
      ctx.lineWidth = 2;
      ctx.setLineDash([6,4]);
      ctx.beginPath();
      ctx.moveTo(xMean, box.y);
      ctx.lineTo(xMean, box.y+box.h);
      ctx.stroke();
      ctx.setLineDash([]);

      // label
      ctx.fillStyle = "rgba(52,211,153,0.95)";
      ctx.font = "700 12px ui-sans-serif, system-ui";
      ctx.fillText("mean τ̄", xMean+6, box.y+14);

      // legend
      drawLegend(ctx, [
        {color:"rgba(125,211,252,0.95)", label: (k===1 ? "Exponential" : `Gamma(k=${k})`)},
        {color:"rgba(52,211,153,0.95)", label: "Mean τ̄"}
      ], box.x+10, box.y+box.h-10);

      ctx.restore();

      // annotate tail intuition
      ctx.save();
      ctx.fillStyle = "rgba(183,195,230,0.95)";
      ctx.font = "600 12px ui-sans-serif, system-ui";
      const note = (k===1)
        ? "Long tail → boosts ⟨τ²⟩ → F=2"
        : "Narrower distribution → smaller relative variance → F closer to 1";
      ctx.fillText(note, margin.l, h-12);
      ctx.restore();
    }

    // ---------------------------
    // Drawing: F vs k sweep
    // ---------------------------
    function drawSweep(){
      const {ctx, resize} = cSweep;
      const {w,h} = resize();

      const margin = {l:64,r:18,t:34,b:56};
      const box = {x:margin.l, y:margin.t, w:w-margin.l-margin.r, h:h-margin.t-margin.b};

      const kMin = 1, kMax = 20;
      const FMin = 1.0, FMax = 2.1;

      const axes = drawAxes(ctx, box, {
        xMin:kMin, xMax:kMax, yMin:FMin, yMax:FMax,
        xLabel: "Shape k (dimensionless)",
        yLabel: "Excess noise factor F",
        title: "Parameter sweep: F vs k   (F = 1 + 1/k)"
      });

      // curve
      const pts = [];
      for(let k=kMin; k<=kMax; k+=0.05){
        const F = F_of_k(k);
        pts.push({x: axes.xMap(k), y: axes.yMap(F)});
      }
      strokePath(ctx, pts, "rgba(167,139,250,0.95)", 2.5);

      // highlight current k
      const kNow = (state.dist === "exp") ? 1 : state.k;
      const FNow = F_of_k(kNow);
      const xNow = axes.xMap(kNow), yNow = axes.yMap(FNow);

      ctx.save();
      ctx.fillStyle = "rgba(234,240,255,0.92)";
      ctx.strokeStyle = "rgba(234,240,255,0.40)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(xNow, yNow, 5.5, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // dashed guides
      ctx.setLineDash([6,4]);
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(xNow, box.y+box.h); ctx.lineTo(xNow, yNow); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(box.x, yNow); ctx.lineTo(xNow, yNow); ctx.stroke();
      ctx.setLineDash([]);

      // label
      ctx.fillStyle = "rgba(183,195,230,0.95)";
      ctx.font = "700 12px ui-sans-serif, system-ui";
      const lbl = `k = ${kNow}  →  F = ${FNow.toFixed(3)}`;
      ctx.fillText(lbl, xNow+10, yNow-10);

      // reference line F=2
      const y2 = axes.yMap(2);
      ctx.setLineDash([5,5]);
      ctx.strokeStyle = "rgba(52,211,153,0.70)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(box.x, y2);
      ctx.lineTo(box.x+box.w, y2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(52,211,153,0.95)";
      ctx.fillText("F = 2 (exponential, k=1)", box.x+10, y2-8);

      // legend
      drawLegend(ctx, [
        {color:"rgba(167,139,250,0.95)", label:"F = 1 + 1/k"},
        {color:"rgba(234,240,255,0.92)", label:"Current setting"},
        {color:"rgba(52,211,153,0.95)", label:"Exponential benchmark"}
      ], box.x+10, box.y+box.h-10);

      ctx.restore();

      // footer note
      ctx.save();
      ctx.fillStyle = "rgba(183,195,230,0.95)";
      ctx.font = "600 12px ui-sans-serif, system-ui";
      ctx.fillText("Exponential lifetime ⇔ k = 1  ⇒  F = 2", margin.l, h-12);
      ctx.restore();
    }

    // ---------------------------
    // Update readouts & enforce control logic
    // ---------------------------
    function updateReadouts(){
      // enforce exponential -> k=1 locked
      if(state.dist === "exp"){
        state.k = 1;
        el.k.value = "1";
        el.k.disabled = true;
      }else{
        el.k.disabled = false;
      }

      const k = (state.dist === "exp") ? 1 : state.k;
      const F = F_of_k(k);

      const tauBar_s = state.tauBar_us * 1e-6;
      const tauE_s = state.tauE_ns * 1e-9;
      const Gmean = tauBar_s / tauE_s;

      el.readoutF.textContent = `F = ${F.toFixed(3)}`;
      el.readoutK.textContent = `k = ${k}`;
      el.readoutTauBar.textContent = `τ̄ = ${state.tauBar_us.toFixed(1)} µs`;
      el.readoutTauE.textContent = `τe = ${state.tauE_ns.toFixed(1)} ns`;
      el.readoutG.textContent = `⟨G⟩ = ${Gmean.toFixed(1)}`;
    }

    function renderAll(){
      updateReadouts();
      drawDiagram();
      drawPdf();
      drawSweep();
    }

    // ---------------------------
    // Events
    // ---------------------------
    el.dist.addEventListener("change", ()=>{
      state.dist = el.dist.value;
      renderAll();
    });
    el.k.addEventListener("input", ()=>{
      state.k = parseInt(el.k.value, 10);
      renderAll();
    });
    el.tauBar.addEventListener("input", ()=>{
      state.tauBar_us = parseFloat(el.tauBar.value);
      renderAll();
    });
    el.tauE.addEventListener("input", ()=>{
      state.tauE_ns = parseFloat(el.tauE.value);
      renderAll();
    });

    el.copyPanel.addEventListener("click", ()=>{
      const k = (state.dist === "exp") ? 1 : state.k;
      const F = F_of_k(k);
      const tauBar_s = state.tauBar_us * 1e-6;
      const tauE_s = state.tauE_ns * 1e-9;
      const Gmean = tauBar_s / tauE_s;

      const modelName = (state.dist === "exp") ? "Exponential lifetime" : `Gamma(k=${k}) lifetime`;
      const txt =
`Random photoconductor gain (example parameters for plotting)
Model: ${modelName}
G = τ/τe
τ̄ = ${state.tauBar_us.toFixed(1)} µs
τe = ${state.tauE_ns.toFixed(1)} ns
⟨G⟩ = τ̄/τe = ${Gmean.toFixed(2)}
Excess noise factor: F = ⟨G²⟩/⟨G⟩² = ⟨τ²⟩/⟨τ⟩²
For gamma shape k: F = 1 + 1/k
Current F = ${F.toFixed(4)}
SNR penalty factor = 1/F = ${(1/F).toFixed(4)}
Exponential benchmark (k=1): F = 2`;
      copyText(txt);
    });

    // Re-render on resize (responsive)
    const ro = new ResizeObserver(()=>renderAll());
    ro.observe(document.getElementById("cDiagram"));
    ro.observe(document.getElementById("cPdf"));
    ro.observe(document.getElementById("cSweep"));

    // Initial render
    renderAll();
  </script>
</body>
</html>
