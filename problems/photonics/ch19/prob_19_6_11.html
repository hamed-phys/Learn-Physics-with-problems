<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Sensitivity of an AM Receiver (Shot-Noise-Limited)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --card2:#0f1730;
      --text:#e9eeff;
      --muted:#b7c3ff;
      --faint:#7f8bd6;
      --accent:#7cf0c5;
      --accent2:#8fb6ff;
      --warn:#ffcf5a;
      --danger:#ff6b88;
      --line:rgba(255,255,255,.10);
      --shadow: 0 16px 50px rgba(0,0,0,.45);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 10% 10%, rgba(124,240,197,.12), transparent 60%),
        radial-gradient(1000px 700px at 90% 20%, rgba(143,182,255,.10), transparent 55%),
        radial-gradient(900px 600px at 40% 95%, rgba(255,107,136,.08), transparent 55%),
        linear-gradient(180deg, #070a14 0%, #090f1f 40%, #070a14 100%);
      line-height:1.55;
    }
    header{
      padding:28px 18px 18px;
      max-width:1200px;
      margin:0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:16px;
      align-items:stretch;
    }
    .titleCard{
      background:linear-gradient(135deg, rgba(124,240,197,.14), rgba(143,182,255,.10));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:18px 18px 16px;
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .titleCard:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(600px 240px at 10% 10%, rgba(124,240,197,.20), transparent 60%),
                  radial-gradient(500px 220px at 80% 20%, rgba(143,182,255,.18), transparent 60%);
      filter: blur(0px);
      pointer-events:none;
    }
    .titleCard > *{position:relative}
    h1{
      margin:0 0 6px;
      font-size: clamp(1.25rem, 2.2vw, 1.9rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size: .98rem;
    }
    .badgeRow{
      display:flex; flex-wrap:wrap; gap:8px;
      margin-top:12px;
    }
    .badge{
      font-size:.82rem;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--muted);
      backdrop-filter: blur(8px);
    }
    .badge strong{color:var(--text); font-weight:650}
    .tocCard{
      background:rgba(17,26,51,.72);
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:14px 14px 12px;
      box-shadow: var(--shadow);
      position:sticky;
      top:12px;
      align-self:start;
      max-height: calc(100vh - 24px);
      overflow:auto;
    }
    .tocCard h2{
      font-size: .95rem;
      margin: 0 0 10px;
      color: var(--text);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .tocCard nav a{
      display:block;
      padding:8px 10px;
      margin:4px 0;
      border-radius:12px;
      text-decoration:none;
      color: var(--muted);
      border:1px solid transparent;
      transition: transform .15s ease, background .15s ease, border .15s ease;
    }
    .tocCard nav a:hover{
      background: rgba(124,240,197,.10);
      border-color: rgba(124,240,197,.20);
      transform: translateX(2px);
      color: var(--text);
    }

    main{
      max-width:1200px;
      margin: 0 auto;
      padding: 0 18px 38px;
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:16px;
      align-items:start;
    }
    .content{
      display:flex;
      flex-direction:column;
      gap:16px;
      min-width:0;
    }
    section{
      background: rgba(17,26,51,.58);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      overflow:hidden;
      position:relative;
    }
    section h2{
      margin:0 0 8px;
      font-size: 1.15rem;
    }
    section h3{
      margin:14px 0 8px;
      font-size: 1.02rem;
      color: var(--text);
    }
    p{margin:10px 0; color: var(--text)}
    ul{margin:10px 0 10px 20px; color: var(--text)}
    li{margin:6px 0}
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      align-items:stretch;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
    }
    .callout{
      background: linear-gradient(135deg, rgba(124,240,197,.10), rgba(143,182,255,.08));
      border:1px solid rgba(124,240,197,.20);
      border-radius: 16px;
      padding: 12px;
    }
    .callout.warn{
      background: linear-gradient(135deg, rgba(255,207,90,.10), rgba(255,107,136,.06));
      border-color: rgba(255,207,90,.22);
    }
    .callout.danger{
      background: linear-gradient(135deg, rgba(255,107,136,.12), rgba(143,182,255,.06));
      border-color: rgba(255,107,136,.22);
    }
    .eq{
      font-family: var(--mono);
      font-size: .95rem;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.10);
      padding: 10px 10px;
      border-radius: 14px;
      overflow:auto;
      white-space: pre;
      position:relative;
    }
    .eqRow{
      display:flex;
      gap:8px;
      align-items:flex-start;
    }
    .copyBtn{
      font-family: var(--sans);
      font-size: .82rem;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: var(--text);
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border .12s ease;
      user-select:none;
      white-space:nowrap;
    }
    .copyBtn:hover{
      background: rgba(124,240,197,.10);
      border-color: rgba(124,240,197,.25);
      transform: translateY(-1px);
    }
    .small{
      font-size:.92rem;
      color: var(--muted);
    }

    aside{
      position:sticky;
      top:12px;
      align-self:start;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .panel{
      background: rgba(17,26,51,.72);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: var(--shadow);
    }
    .panel h3{
      margin:0 0 10px;
      font-size: 1.02rem;
    }
    .ctrl{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px 10px;
      align-items:center;
      margin:10px 0;
      padding:10px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.16);
    }
    .ctrl label{
      font-size:.88rem;
      color: var(--muted);
      grid-column: 1 / -1;
    }
    .ctrl input[type="range"]{
      width:100%;
      grid-column: 1 / 2;
    }
    .ctrl .val{
      font-family: var(--mono);
      font-size:.86rem;
      color: var(--text);
      grid-column: 2 / 3;
      justify-self:end;
      padding: 4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      min-width: 92px;
      text-align:right;
    }
    .readout{
      display:grid;
      gap:8px;
      margin-top:8px;
    }
    .kpi{
      padding:10px;
      border-radius:16px;
      border: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(135deg, rgba(124,240,197,.10), rgba(0,0,0,.12));
    }
    .kpi .k{
      font-size:.82rem;
      color: var(--muted);
      margin-bottom:2px;
    }
    .kpi .v{
      font-family: var(--mono);
      font-size: 1.02rem;
      color: var(--text);
    }

    figure{
      margin: 10px 0 0;
      padding: 10px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.16);
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
      border-radius: 14px;
      background: rgba(8,12,24,.35);
      border: 1px solid rgba(255,255,255,.08);
    }
    .figcap{
      margin-top:8px;
      color: var(--muted);
      font-size:.9rem;
    }

    .finalBox{
      border:1px solid rgba(124,240,197,.35);
      background: linear-gradient(135deg, rgba(124,240,197,.14), rgba(143,182,255,.08));
      border-radius: 16px;
      padding: 12px;
    }
    .finalBox h3{margin:0 0 6px}
    .splitEq{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:start;
    }
    .hr{
      height:1px;
      background: rgba(255,255,255,.10);
      margin: 10px 0;
    }
    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 0 18px 26px;
      color: var(--muted);
      font-size:.92rem;
    }

    /* Print-friendly */
    @media print{
      body{background:#fff; color:#000}
      header, main, footer{max-width:100%; margin:0; padding:0}
      .tocCard, aside{display:none !important}
      section{break-inside:avoid; box-shadow:none; background:#fff; border:1px solid #ddd}
      .eq{background:#f7f7f7; border:1px solid #ddd}
      canvas{border:1px solid #ddd}
      .copyBtn{display:none}
    }

    @media (max-width: 980px){
      header .hero{grid-template-columns: 1fr}
      main{grid-template-columns: 1fr}
      aside{position:relative; top:auto}
      .grid2{grid-template-columns:1fr}
      canvas{height: 300px}
    }
  </style>
</head>

<body>
<header>
  <div class="hero">
    <div class="titleCard">
      <h1>Sensitivity of an AM Receiver (Shot-Noise-Limited Direct Detection)</h1>
      <p class="subtitle">
        Given an optical power <span class="muted">P(t) = P₀ + Pₛ cos(2πft)</span> with <span class="muted">f &lt; B</span> and <span class="muted">P₀ ≫ Pₛ</span>, find the minimum modulation amplitude <span class="muted">Pₛ</span> measurable at <span class="muted">SNR₀ = 30 dB</span>, and explain how the background power <span class="muted">P₀</span> affects sensitivity.
      </p>
      <div class="badgeRow">
        <div class="badge"><strong>Regime:</strong> negligible circuit noise</div>
        <div class="badge"><strong>Noise limit:</strong> photodetection shot noise</div>
        <div class="badge"><strong>Receiver BW:</strong> B (Hz)</div>
        <div class="badge"><strong>Responsivity:</strong> ℛ (A/W)</div>
      </div>
    </div>

    <div class="tocCard" id="toc">
      <h2>Contents <span class="small" id="tocHint">sticky</span></h2>
      <nav>
        <a href="#quick">Quick Summary</a>
        <a href="#part0">PART 0 — Concept Primer</a>
        <a href="#part1">PART 1 — Problem Analysis</a>
        <a href="#part2">PART 2 — Strategy & Tips</a>
        <a href="#part3">PART 3 — Full Solution</a>
        <a href="#part4">PART 4 — Deeper Understanding</a>
        <a href="#part5">PART 5 — Visualization Guide</a>
      </nav>
    </div>
  </div>
</header>

<main>
  <div class="content">

    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><strong>What this is about:</strong> Minimum detectable <em>AM modulation</em> on an optical carrier using a photodiode receiver.</li>
        <li><strong>Key physics idea:</strong> With negligible electronics noise and <span class="muted">P₀ ≫ Pₛ</span>, the noise is dominated by <em>shot noise</em> from the DC photocurrent due to <span class="muted">P₀</span>.</li>
        <li><strong>Photocurrent model:</strong> <span class="muted">i(t) = ℛ P(t) = I₀ + Iₛ cos(2πft)</span>, where <span class="muted">I₀ = ℛP₀</span> and <span class="muted">Iₛ = ℛPₛ</span>.</li>
        <li><strong>Shot-noise mean-square current in bandwidth B:</strong> <span class="muted">⟨i_n²⟩ = 2 q I₀ B</span> (A²), with <span class="muted">q</span> the electron charge.</li>
        <li><strong>Signal-to-noise ratio for a sinusoid:</strong> <span class="muted">SNR = (Iₛ,rms²)/(⟨i_n²⟩) = (Iₛ²/2)/(2 q I₀ B)</span>.</li>
        <li><strong>Final symbolic result:</strong> <span class="muted">Pₛ,min = √(4 q P₀ B · SNR₀ / ℛ)</span> (W).</li>
        <li><strong>Effect of background:</strong> <span class="muted">Pₛ,min ∝ √P₀</span>: increasing background power makes the minimum observable modulation worse (requires larger modulation).</li>
      </ul>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

      <div class="grid2">
        <div class="callout">
          <h3>Core definitions (symbols + units)</h3>
          <ul>
            <li><strong>Optical power:</strong> <span class="muted">P(t)</span> (W). Here <span class="muted">P(t)=P₀ + Pₛ cos(2πft)</span>.</li>
            <li><strong>Background (DC) power:</strong> <span class="muted">P₀</span> (W) — sets the average photon flux and thus the average photocurrent.</li>
            <li><strong>Modulation amplitude:</strong> <span class="muted">Pₛ</span> (W) — the size of the sinusoidal variation you want to detect.</li>
            <li><strong>Photodiode responsivity:</strong> <span class="muted">ℛ</span> (A/W) — converts optical power to photocurrent: <span class="muted">i = ℛP</span>.</li>
            <li><strong>Receiver bandwidth:</strong> <span class="muted">B</span> (Hz) — the electrical bandwidth over which noise is collected.</li>
            <li><strong>Shot noise:</strong> due to discrete electrons; with average current <span class="muted">I₀</span>, mean-square noise current in bandwidth <span class="muted">B</span> is <span class="muted">2qI₀B</span>.</li>
          </ul>
        </div>

        <div class="callout warn">
          <h3>Physical meaning & when formulas apply</h3>
          <ul>
            <li><strong>Why shot noise?</strong> Photocurrent is carried by electrons arriving randomly → current fluctuates even for constant illumination.</li>
            <li><strong>Validity:</strong> Shot noise dominates when electronics noise is negligible and detection is <em>direct</em> (no optical local oscillator).</li>
            <li><strong>White-noise approximation:</strong> Shot-noise spectral density is (approximately) flat over the relevant frequency range, so total noise scales with <span class="muted">B</span>.</li>
            <li><strong>Small-signal assumption:</strong> <span class="muted">P₀ ≫ Pₛ</span> ⇒ noise is set mainly by <span class="muted">P₀</span>, not by the modulation itself.</li>
          </ul>
        </div>
      </div>

      <h3>Common models/approximations (and why we use them)</h3>
      <ul>
        <li><strong>Linear photodetection:</strong> <span class="muted">i(t)=ℛP(t)</span>. This is accurate when the photodiode is not saturated and is biased correctly.</li>
        <li><strong>Shot noise as Poisson process:</strong> electron arrivals are Poissonian → current noise PSD <span class="muted">S_i = 2qI₀</span> (A²/Hz).</li>
        <li><strong>Sinusoid detection:</strong> for a tone within the receiver bandwidth, the useful signal is its RMS current <span class="muted">Iₛ/√2</span>.</li>
      </ul>

      <h3>Mini intuition examples (no long algebra)</h3>
      <ul>
        <li><strong>Example 1:</strong> Double the bandwidth <span class="muted">B</span> → you collect twice as much white noise power → required modulation grows like <span class="muted">√B</span>.</li>
        <li><strong>Example 2:</strong> Increase <span class="muted">P₀</span> (brighter background) → DC photocurrent increases → shot noise increases like <span class="muted">√I₀ ∝ √P₀</span> → the AM “wiggle” must be larger to stand out.</li>
      </ul>

      <div class="callout danger">
        <h3>What to watch for (pitfalls)</h3>
        <ul>
          <li>Confusing <strong>signal amplitude</strong> with <strong>RMS</strong>: a sinusoid of amplitude <span class="muted">Iₛ</span> has RMS <span class="muted">Iₛ/√2</span>.</li>
          <li>Using <span class="muted">2qI₀</span> without multiplying by bandwidth <span class="muted">B</span> when you need total noise.</li>
          <li>Forgetting the regime <span class="muted">P₀ ≫ Pₛ</span>: noise is governed by <span class="muted">P₀</span>, not <span class="muted">Pₛ</span>.</li>
        </ul>
      </div>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>Restate the problem in plain words</h3>
      <p>
        An optical receiver (photodiode + electronics) observes an optical signal whose power is a DC level <span class="muted">P₀</span> plus a small sinusoidal modulation of amplitude <span class="muted">Pₛ</span> at frequency <span class="muted">f</span>.
        The receiver has electrical bandwidth <span class="muted">B</span> that includes the modulation tone (<span class="muted">f &lt; B</span>) and negligible circuit noise. In the limit <span class="muted">P₀ ≫ Pₛ</span>, derive the minimum modulation amplitude <span class="muted">Pₛ</span> required to achieve <span class="muted">SNR₀ = 30 dB</span>, and explain how <span class="muted">P₀</span> affects it.
      </p>

      <div class="grid2">
        <div class="callout">
          <h3>Given</h3>
          <ul>
            <li><span class="muted">P(t)=P₀ + Pₛ cos(2πft)</span></li>
            <li><span class="muted">ℛ</span> (A/W)</li>
            <li>Bandwidth <span class="muted">B</span> (Hz), and <span class="muted">f &lt; B</span></li>
            <li>Negligible circuit noise</li>
            <li>Small modulation: <span class="muted">P₀ ≫ Pₛ</span></li>
            <li>Required <span class="muted">SNR₀ = 30 dB</span></li>
          </ul>
        </div>
        <div class="callout">
          <h3>Unknowns</h3>
          <ul>
            <li><span class="muted">Pₛ,min</span> (W)</li>
            <li>Qualitative effect of <span class="muted">P₀</span> on <span class="muted">Pₛ,min</span></li>
          </ul>
          <div class="hr"></div>
          <h3>What must be found/proved</h3>
          <ul>
            <li>A closed-form expression for <span class="muted">Pₛ,min</span> in terms of <span class="muted">q, P₀, B, ℛ, SNR₀</span></li>
            <li>A scaling statement: how <span class="muted">Pₛ,min</span> changes with <span class="muted">P₀</span></li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li><strong>Photodiode linear responsivity:</strong> turns optical power into current, enabling an electrical SNR calculation.</li>
        <li><strong>Shot noise:</strong> with electronics noise neglected, photocarrier discreteness dominates noise. Because <span class="muted">P₀ ≫ Pₛ</span>, the average current is set by <span class="muted">P₀</span>.</li>
        <li><strong>Bandwidth-limited noise integration:</strong> white noise integrated over bandwidth gives mean-square noise proportional to <span class="muted">B</span>.</li>
      </ul>
      <p class="muted">
        We do <em>not</em> need thermal noise or amplifier noise models because the problem states negligible circuit noise.
        We also do not need any optical mixing/heterodyne formulas because this is direct detection of intensity modulation.
      </p>

      <div class="callout warn">
        <h3>Assumptions (explicit)</h3>
        <ul>
          <li>Photodiode operates in its linear regime: <span class="muted">i(t)=ℛP(t)</span>.</li>
          <li>Shot noise dominates; other noise sources are negligible.</li>
          <li>Noise is white across the receiver bandwidth.</li>
          <li>Small-signal AM: <span class="muted">P₀ ≫ Pₛ</span> so shot noise is determined by <span class="muted">P₀</span>.</li>
          <li>Detection is effectively measuring the tone at <span class="muted">f</span> within bandwidth <span class="muted">B</span>.</li>
        </ul>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ul>
        <li><strong>(A) Current-domain SNR (best here):</strong> compute signal RMS current at <span class="muted">f</span> and compare to shot-noise mean-square current <span class="muted">2qI₀B</span>. Simple and matches “bandwidth B” wording.</li>
        <li><strong>(B) PSD approach:</strong> use shot-noise PSD <span class="muted">S_i=2qI₀</span> and integrate over an equivalent noise bandwidth around the tone. Equivalent but slightly more abstract.</li>
        <li><strong>(C) Photon-counting view:</strong> relate noise to Poisson photon statistics. Great for intuition, but requires extra conversion steps to electrical SNR.</li>
      </ul>
      <p><strong>We choose (A)</strong> because it is the most direct and transparently uses the given <span class="muted">B</span> and <span class="muted">ℛ</span>.</p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>
      <ol>
        <li><strong>Convert optical power to photocurrent</strong><br/>
          <span class="muted">Tool:</span> linear responsivity <span class="muted">i(t)=ℛP(t)</span><br/>
          <span class="muted">Meaning:</span> electrical signal amplitude is proportional to optical modulation amplitude.
        </li>
        <li><strong>Identify DC current that sets shot noise</strong><br/>
          <span class="muted">Tool:</span> average current <span class="muted">I₀=ℛP₀</span><br/>
          <span class="muted">Meaning:</span> background power determines the electron arrival rate.
        </li>
        <li><strong>Write total mean-square shot noise in bandwidth B</strong><br/>
          <span class="muted">Tool:</span> <span class="muted">⟨i_n²⟩ = 2qI₀B</span><br/>
          <span class="muted">Meaning:</span> more bandwidth → more integrated noise.
        </li>
        <li><strong>Compute the signal RMS current of the tone</strong><br/>
          <span class="muted">Tool:</span> sinusoid RMS: <span class="muted">Iₛ,rms = Iₛ/√2</span><br/>
          <span class="muted">Meaning:</span> SNR compares power-like quantities (mean squares).
        </li>
        <li><strong>Form SNR and solve for the needed modulation amplitude</strong><br/>
          <span class="muted">Tool:</span> <span class="muted">SNR = Iₛ,rms² / ⟨i_n²⟩</span><br/>
          <span class="muted">Meaning:</span> minimum detectable signal occurs when SNR equals required threshold.
        </li>
        <li><strong>Convert back to optical units</strong><br/>
          <span class="muted">Tool:</span> <span class="muted">Iₛ = ℛPₛ</span><br/>
          <span class="muted">Meaning:</span> output is <span class="muted">Pₛ,min</span> in watts.
        </li>
        <li><strong>Interpret scaling</strong><br/>
          <span class="muted">Tool:</span> proportionalities from the final expression<br/>
          <span class="muted">Meaning:</span> understand how <span class="muted">P₀, B, ℛ</span> affect sensitivity.
        </li>
      </ol>

      <div class="callout danger">
        <h3>Common mistakes & quick tips</h3>
        <ul>
          <li><strong>Mistake:</strong> using <span class="muted">Iₛ</span> instead of <span class="muted">Iₛ/√2</span> in SNR → off by factor 2.</li>
          <li><strong>Tip:</strong> keep a clear separation between DC (sets noise) and AC (is the signal).</li>
          <li><strong>Tip:</strong> convert <span class="muted">30 dB</span> to linear: <span class="muted">SNR₀ = 10^(30/10)=1000</span>.</li>
        </ul>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

      <h3>Physical intuition first</h3>
      <p>
        The photodiode produces a DC current proportional to <span class="muted">P₀</span> plus a small AC current proportional to <span class="muted">Pₛ</span>.
        Even if the electronics are perfect, the DC current is made of discrete electrons arriving randomly, producing shot noise.
        Because <span class="muted">P₀ ≫ Pₛ</span>, the random fluctuations are mainly set by the DC level (background), while the useful “tone” is set by the modulation.
        Therefore, a larger background increases noise and forces a larger modulation to achieve the same SNR.
      </p>

      <div class="callout">
        <h3>Step 1 — Photocurrent from optical power</h3>
        <p>Define responsivity <span class="muted">ℛ</span> (A/W) so that</p>
        <div class="eqRow">
          <div class="eq" id="eq1">i(t) = ℛ P(t) = ℛ(P₀ + Pₛ cos(2π f t)).</div>
          <button class="copyBtn" data-copy="#eq1">Copy</button>
        </div>
        <p>
          Identify DC and AC parts:
          <span class="muted">I₀ = ℛP₀</span> (average current) and
          <span class="muted">Iₛ = ℛPₛ</span> (AC amplitude).
          So
        </p>
        <div class="eqRow">
          <div class="eq" id="eq2">i(t) = I₀ + Iₛ cos(2π f t),  with  I₀ = ℛP₀,  Iₛ = ℛPₛ.</div>
          <button class="copyBtn" data-copy="#eq2">Copy</button>
        </div>
        <p class="small">
          What we did: translated an optical intensity modulation into an electrical current modulation. This makes SNR a standard noise problem in electronics.
        </p>
      </div>

      <div class="callout">
        <h3>Step 2 — Shot noise in bandwidth B</h3>
        <p>
          For a shot-noise-limited photodetector with average current <span class="muted">I₀</span>, the (two-sided) current-noise power spectral density is approximately white:
          <span class="muted">S_i = 2qI₀</span> (A²/Hz).
          Integrating over an electrical bandwidth <span class="muted">B</span> gives mean-square noise current:
        </p>
        <div class="eqRow">
          <div class="eq" id="eq3">⟨i_n²⟩ = 2 q I₀ B.</div>
          <button class="copyBtn" data-copy="#eq3">Copy</button>
        </div>
        <p class="small">
          What we did: converted “white noise density” into total noise in the receiver bandwidth. More bandwidth means more noise energy.
        </p>
      </div>

      <div class="callout">
        <h3>Step 3 — Signal RMS current for the sinusoid</h3>
        <p>
          The useful signal is the sinusoidal term of amplitude <span class="muted">Iₛ</span>.
          A cosine <span class="muted">Iₛ cos(2πft)</span> has RMS value
        </p>
        <div class="eqRow">
          <div class="eq" id="eq4">Iₛ,rms = Iₛ / √2.</div>
          <button class="copyBtn" data-copy="#eq4">Copy</button>
        </div>
        <p class="small">
          What we did: SNR is naturally formed using mean-square quantities, so we use RMS for the tone.
        </p>
      </div>

      <div class="callout">
        <h3>Step 4 — Form the SNR and solve for the minimum modulation</h3>
        <p>
          Define SNR at the output (current domain) as
        </p>
        <div class="eqRow">
          <div class="eq" id="eq5">SNR = (Iₛ,rms²) / (⟨i_n²⟩).</div>
          <button class="copyBtn" data-copy="#eq5">Copy</button>
        </div>
        <p>
          Substitute <span class="muted">Iₛ,rms² = Iₛ²/2</span> and <span class="muted">⟨i_n²⟩ = 2qI₀B</span>:
        </p>
        <div class="eqRow">
          <div class="eq" id="eq6">SNR = (Iₛ²/2) / (2 q I₀ B) = Iₛ² / (4 q I₀ B).</div>
          <button class="copyBtn" data-copy="#eq6">Copy</button>
        </div>
        <p>
          Solve for the required AC current amplitude:
        </p>
        <div class="eqRow">
          <div class="eq" id="eq7">Iₛ = √(4 q I₀ B · SNR).</div>
          <button class="copyBtn" data-copy="#eq7">Copy</button>
        </div>
        <p>
          Now convert <span class="muted">I₀ = ℛP₀</span> and <span class="muted">Iₛ = ℛPₛ</span>:
        </p>
        <div class="eqRow">
          <div class="eq" id="eq8">ℛPₛ = √(4 q (ℛP₀) B · SNR).</div>
          <button class="copyBtn" data-copy="#eq8">Copy</button>
        </div>
        <p>
          Divide both sides by <span class="muted">ℛ</span> to obtain the minimum modulation amplitude:
        </p>

        <div class="finalBox">
          <div class="splitEq">
            <div class="eq" id="finalEq">Pₛ,min = √( 4 q P₀ B · SNR₀ / ℛ ).</div>
            <button class="copyBtn" data-copy="#finalEq">Copy final</button>
          </div>
          <p class="small" style="margin:8px 0 0;">
            Here <span class="muted">SNR₀</span> is linear (not dB). For <span class="muted">30 dB</span>, <span class="muted">SNR₀ = 10^(30/10) = 1000</span>.
          </p>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <div class="grid2">
        <div class="callout">
          <h3>Units/dimensions</h3>
          <ul>
            <li><span class="muted">q</span> has units C.</li>
            <li><span class="muted">P₀</span> is W, <span class="muted">B</span> is Hz = 1/s, <span class="muted">ℛ</span> is A/W = C/(s·W).</li>
            <li>Inside the square root: <span class="muted">q·P₀·B/ℛ</span> → <span class="muted">C·W·(1/s) / (C/(s·W)) = W²</span>.</li>
            <li>Square root gives W, as required for <span class="muted">Pₛ,min</span>.</li>
          </ul>
        </div>
        <div class="callout">
          <h3>Limiting cases</h3>
          <ul>
            <li><strong>B → 0:</strong> <span class="muted">Pₛ,min → 0</span> (narrower measurement band collects less noise).</li>
            <li><strong>P₀ → 0:</strong> shot noise goes to zero in this model, so <span class="muted">Pₛ,min → 0</span> (but in practice other noise sources then dominate).</li>
            <li><strong>ℛ increases:</strong> <span class="muted">Pₛ,min ∝ 1/√ℛ</span> (a more efficient detector improves sensitivity).</li>
          </ul>
        </div>
      </div>

      <h3>Effect of background power P₀ (answer in plain language)</h3>
      <p>
        Since <span class="muted">Pₛ,min = √(4 q P₀ B SNR₀ / ℛ)</span>, the minimum observable modulation scales as
        <span class="muted">Pₛ,min ∝ √P₀</span>.
        <strong>Increasing the background (DC) optical power worsens AM sensitivity</strong> because it increases the DC photocurrent and hence shot noise.
        The modulation must grow as the square root of the background to keep the same SNR.
      </p>

      <p class="muted">
        Connection to the diagram/plots: the DC “pipeline” of electrons (set by <span class="muted">P₀</span>) gets noisier when you increase throughput,
        and the small AC ripple (set by <span class="muted">Pₛ</span>) must be larger to be distinguishable.
      </p>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

      <h3>Re-interpreting the final formula</h3>
      <ul>
        <li><strong>Noise term:</strong> <span class="muted">2qI₀B</span> says “electron discreteness” (q), “how many electrons per second” (I₀), and “how much bandwidth you accept” (B) determine noise.</li>
        <li><strong>Signal term:</strong> the tone power is set by <span class="muted">Iₛ,rms² = Iₛ²/2</span>, so detecting a smaller tone requires lower noise or higher conversion gain.</li>
        <li><strong>Conversion term:</strong> <span class="muted">ℛ</span> helps twice: it turns modulation into current, and it appears in the denominator as <span class="muted">1/√ℛ</span>.</li>
      </ul>

      <div class="callout">
        <h3>How parameter changes affect sensitivity (match the plots)</h3>
        <ul>
          <li><strong>Background power:</strong> <span class="muted">Pₛ,min ∝ √P₀</span> → doubling <span class="muted">P₀</span> increases <span class="muted">Pₛ,min</span> by <span class="muted">√2 ≈ 1.41</span>.</li>
          <li><strong>Bandwidth:</strong> <span class="muted">Pₛ,min ∝ √B</span> → 10× wider bandwidth costs <span class="muted">√10 ≈ 3.16</span> in required modulation.</li>
          <li><strong>Responsivity:</strong> <span class="muted">Pₛ,min ∝ 1/√ℛ</span> → better responsivity improves sensitivity with a square-root law.</li>
          <li><strong>Required SNR:</strong> <span class="muted">Pₛ,min ∝ √SNR₀</span> → demanding 10× higher linear SNR costs √10 in modulation.</li>
        </ul>
      </div>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        You can derive the same scaling from photon/electron counting: over a measurement time <span class="muted">T ≈ 1/(2B)</span>,
        the number of detected electrons is Poisson with variance equal to the mean. The DC level sets the mean count, hence the noise,
        and the modulation must exceed the square-root fluctuations to reach a target SNR. Converting counts to current reproduces the same formula.
      </p>

      <h3>Concept-check Q&A (self-test)</h3>
      <ul>
        <li><strong>Q:</strong> Why does <span class="muted">P₀</span> appear even though we are detecting <span class="muted">Pₛ</span>? <br/>
            <strong>A:</strong> Because shot noise is set by the average photocurrent, which (for <span class="muted">P₀ ≫ Pₛ</span>) is determined by <span class="muted">P₀</span>.</li>
        <li><strong>Q:</strong> If I halve bandwidth, what happens to <span class="muted">Pₛ,min</span>? <br/>
            <strong>A:</strong> It decreases by <span class="muted">√2</span> (better sensitivity).</li>
        <li><strong>Q:</strong> Does increasing <span class="muted">P₀</span> always help detection? <br/>
            <strong>A:</strong> Not in the shot-noise-limited regime for small-signal AM: larger <span class="muted">P₀</span> increases shot noise and makes the minimum detectable <span class="muted">Pₛ</span> larger.</li>
        <li><strong>Q:</strong> Where did the factor of 4 come from? <br/>
            <strong>A:</strong> From combining (i) sinusoid RMS factor <span class="muted">1/2</span> in mean-square and (ii) shot-noise mean-square <span class="muted">2qI₀B</span> in the denominator.</li>
      </ul>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

      <figure>
        <canvas id="canvasDiagram" aria-label="Receiver diagram"></canvas>
        <div class="figcap">
          <strong>Diagram:</strong> Optical AM signal → photodiode (responsivity ℛ) → photocurrent with DC + tone → band-limited noise (B) → SNR.
        </div>
      </figure>

      <figure>
        <canvas id="canvasMain" aria-label="Main plot Ps,min vs P0"></canvas>
        <div class="figcap">
          <strong>Main plot:</strong> <span class="muted">Pₛ,min</span> versus background <span class="muted">P₀</span> (log–log). The curve shows the square-root law <span class="muted">Pₛ,min ∝ √P₀</span>. A marker indicates the current slider value.
        </div>
      </figure>

      <figure>
        <canvas id="canvasSecondary" aria-label="Secondary plot Ps,min vs B"></canvas>
        <div class="figcap">
          <strong>Secondary plot:</strong> <span class="muted">Pₛ,min</span> versus bandwidth <span class="muted">B</span> (log–log) for the current <span class="muted">P₀</span>, ℛ, and SNR setting. This visualizes <span class="muted">Pₛ,min ∝ √B</span>.
        </div>
      </figure>

      <div class="callout warn">
        <h3>Interactive controls (what changes and why)</h3>
        <ul>
          <li><strong>Background power P₀ slider:</strong> increases DC photocurrent → raises shot noise → shifts both plots upward (worse sensitivity).</li>
          <li><strong>Bandwidth B slider:</strong> integrates more white noise → shifts plots upward with √B scaling; secondary plot marker moves along the curve.</li>
          <li><strong>Responsivity ℛ slider:</strong> better conversion reduces required modulation as 1/√ℛ → curves move downward as ℛ increases.</li>
          <li><strong>SNR₀ slider (dB):</strong> stricter requirement increases <span class="muted">Pₛ,min</span> as √SNR₀.</li>
        </ul>
      </div>
    </section>

  </div>

  <aside>
    <div class="panel">
      <h3>Interactive Parameters</h3>

      <div class="ctrl">
        <label for="p0">Background power P₀ (mW)</label>
        <input id="p0" type="range" min="-3" max="1" step="0.01" value="-1" />
        <div class="val" id="p0Val"></div>
      </div>

      <div class="ctrl">
        <label for="bw">Receiver bandwidth B (MHz)</label>
        <input id="bw" type="range" min="-3" max="3" step="0.01" value="0" />
        <div class="val" id="bwVal"></div>
      </div>

      <div class="ctrl">
        <label for="R">Responsivity ℛ (A/W)</label>
        <input id="R" type="range" min="0.10" max="1.20" step="0.01" value="0.80" />
        <div class="val" id="RVal"></div>
      </div>

      <div class="ctrl">
        <label for="snrdb">Required SNR₀ (dB)</label>
        <input id="snrdb" type="range" min="0" max="40" step="0.1" value="30" />
        <div class="val" id="snrVal"></div>
      </div>

      <div class="readout">
        <div class="kpi">
          <div class="k">Linear SNR₀</div>
          <div class="v" id="snrLin">—</div>
        </div>
        <div class="kpi">
          <div class="k">DC photocurrent I₀ = ℛP₀</div>
          <div class="v" id="I0">—</div>
        </div>
        <div class="kpi">
          <div class="k">Shot-noise RMS current √(2qI₀B)</div>
          <div class="v" id="inRms">—</div>
        </div>
        <div class="kpi">
          <div class="k">Minimum modulation Pₛ,min</div>
          <div class="v" id="PsMin">—</div>
        </div>
      </div>

      <div class="hr"></div>

      <button class="copyBtn" id="copyPlainFinal" style="width:100%; justify-content:center;">
        Copy final answer (plain text)
      </button>
      <p class="small" style="margin:10px 0 0;">
        Plotting uses <em>example values</em> you can change. The derived formula remains symbolic.
      </p>
    </div>

    <div class="panel">
      <h3>Key Equations (quick copy)</h3>
      <div class="eqRow" style="margin-bottom:10px;">
        <div class="eq" id="k1">⟨i_n²⟩ = 2 q I₀ B</div>
        <button class="copyBtn" data-copy="#k1">Copy</button>
      </div>
      <div class="eqRow" style="margin-bottom:10px;">
        <div class="eq" id="k2">SNR = Iₛ² / (4 q I₀ B)</div>
        <button class="copyBtn" data-copy="#k2">Copy</button>
      </div>
      <div class="eqRow">
        <div class="eq" id="k3">Pₛ,min = √( 4 q P₀ B · SNR₀ / ℛ )</div>
        <button class="copyBtn" data-copy="#k3">Copy</button>
      </div>
    </div>
  </aside>
</main>

<footer>
  <div class="muted">
    Notes: This solution assumes shot-noise-limited direct detection and that the modulation frequency lies within the receiver bandwidth.
    If <span class="muted">P₀</span> becomes very small, other noise sources (thermal noise, amplifier noise, dark current) typically dominate, changing the sensitivity.
  </div>
</footer>

<script>
/* -----------------------------
   Smooth TOC scrolling
------------------------------ */
(function(){
  document.querySelectorAll('#toc nav a').forEach(a=>{
    a.addEventListener('click', (e)=>{
      e.preventDefault();
      const id = a.getAttribute('href');
      const el = document.querySelector(id);
      if(!el) return;
      el.scrollIntoView({behavior:'smooth', block:'start'});
    });
  });
})();

/* -----------------------------
   Copy buttons
------------------------------ */
async function copyText(text){
  try{
    await navigator.clipboard.writeText(text);
    return true;
  }catch(e){
    // fallback
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.position='fixed';
    ta.style.left='-9999px';
    document.body.appendChild(ta);
    ta.select();
    try{
      document.execCommand('copy');
      document.body.removeChild(ta);
      return true;
    }catch(err){
      document.body.removeChild(ta);
      return false;
    }
  }
}
function flash(btn, ok){
  const old = btn.textContent;
  btn.textContent = ok ? 'Copied!' : 'Copy failed';
  btn.style.borderColor = ok ? 'rgba(124,240,197,.45)' : 'rgba(255,107,136,.55)';
  btn.style.background = ok ? 'rgba(124,240,197,.12)' : 'rgba(255,107,136,.12)';
  setTimeout(()=>{
    btn.textContent = old;
    btn.style.borderColor = '';
    btn.style.background = '';
  }, 900);
}
document.querySelectorAll('.copyBtn[data-copy]').forEach(btn=>{
  btn.addEventListener('click', async ()=>{
    const sel = btn.getAttribute('data-copy');
    const el = document.querySelector(sel);
    const ok = await copyText((el ? el.textContent : '').trim());
    flash(btn, ok);
  });
});
document.getElementById('copyPlainFinal').addEventListener('click', async (e)=>{
  const plain =
`Final (shot-noise-limited, P0 >> Ps):
Ps_min = sqrt( 4 q P0 B SNR0 / R )

where:
q = 1.602176634e-19 C
P0 = background optical power (W)
B = receiver bandwidth (Hz)
R = responsivity (A/W)
SNR0 = linear (for 30 dB, SNR0=1000)

Scaling with background: Ps_min ∝ sqrt(P0).`;
  const ok = await copyText(plain);
  flash(e.currentTarget, ok);
});

/* -----------------------------
   Physics + plotting utilities
------------------------------ */
const q = 1.602176634e-19; // C

function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function log10(x){ return Math.log(x)/Math.LN10; }
function pow10(x){ return Math.pow(10,x); }

function fmtSI(x, unit){
  if(!isFinite(x)) return '—';
  const abs = Math.abs(x);
  const prefixes = [
    {p:1e-12, s:'p'}, {p:1e-9, s:'n'}, {p:1e-6, s:'µ'}, {p:1e-3, s:'m'},
    {p:1, s:''}, {p:1e3, s:'k'}, {p:1e6, s:'M'}, {p:1e9, s:'G'}
  ];
  let best = prefixes[4];
  for(const pr of prefixes){
    if(abs >= pr.p) best = pr;
  }
  const v = x / best.p;
  const digits = (Math.abs(v) >= 100) ? 1 : (Math.abs(v) >= 10 ? 2 : 3);
  return v.toFixed(digits) + ' ' + best.s + unit;
}
function fmtFixed(x, unit){
  if(!isFinite(x)) return '—';
  return x.toFixed(3) + ' ' + unit;
}

function PsMin(P0, B, R, SNRlin){
  // Ps_min = sqrt(4 q P0 B SNR / R)
  return Math.sqrt(4*q*P0*B*SNRlin / R);
}
function I0(P0, R){ return R*P0; }
function inRms(P0, B, R){
  // sqrt(2 q I0 B)
  return Math.sqrt(2*q*I0(P0,R)*B);
}

/* -----------------------------
   Canvas: high-DPI setup
------------------------------ */
function setupCanvas(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(280, rect.width);
  const h = Math.max(240, rect.height);
  canvas.width = Math.round(w * dpr);
  canvas.height = Math.round(h * dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return {ctx, w, h, dpr};
}

function drawPanelBG(ctx,w,h){
  // subtle background + border
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = 'rgba(0,0,0,0.08)';
  ctx.fillRect(0,0,w,h);
  // faint vignette
  const g = ctx.createRadialGradient(w*0.25,h*0.2, 20, w*0.5,h*0.5, Math.max(w,h));
  g.addColorStop(0,'rgba(124,240,197,0.08)');
  g.addColorStop(0.45,'rgba(143,182,255,0.05)');
  g.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,w,h);
}

/* -----------------------------
   Plotting (axes, ticks, grid, legend)
------------------------------ */
function niceTicksLinear(min, max, n=6){
  const span = max-min;
  if(!(span>0)) return [min];
  const rawStep = span/(n-1);
  const pow = Math.pow(10, Math.floor(Math.log10(rawStep)));
  const steps = [1,2,5,10].map(s=>s*pow);
  let step = steps[0];
  for(const s of steps){
    if(Math.abs(rawStep - s) < Math.abs(rawStep - step)) step = s;
  }
  const start = Math.ceil(min/step)*step;
  const ticks = [];
  for(let v=start; v<=max+1e-12; v+=step) ticks.push(v);
  return ticks;
}
function niceTicksLog(min, max){
  // min,max in decades (log10). return tick decades and 1,2,5 minor
  const d0 = Math.floor(min);
  const d1 = Math.ceil(max);
  const ticks = [];
  for(let d=d0; d<=d1; d++){
    ticks.push({v:pow10(d), major:true, label:'10^'+d});
    [2,5].forEach(m=>{
      ticks.push({v:m*pow10(d), major:false, label:''});
    });
  }
  return ticks;
}

function plotXY(canvas, cfg){
  const {ctx,w,h} = setupCanvas(canvas);
  drawPanelBG(ctx,w,h);

  const pad = {l:56, r:18, t:34, b:52};
  const plotW = w - pad.l - pad.r;
  const plotH = h - pad.t - pad.b;

  // Title
  ctx.fillStyle = 'rgba(233,238,255,0.95)';
  ctx.font = '600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(cfg.title || '', pad.l, 20);

  // Axis labels
  ctx.fillStyle = 'rgba(183,195,255,0.95)';
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  // x label
  ctx.fillText(cfg.xLabel || '', pad.l + plotW*0.5 - ctx.measureText(cfg.xLabel||'').width*0.5, h - 14);
  // y label (rotated)
  ctx.save();
  ctx.translate(16, pad.t + plotH*0.5);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(cfg.yLabel || '', 0 - ctx.measureText(cfg.yLabel||'').width*0.5, 0);
  ctx.restore();

  const xLog = !!cfg.xLog;
  const yLog = !!cfg.yLog;

  // Determine ranges
  let xMin = cfg.xMin, xMax = cfg.xMax, yMin = cfg.yMin, yMax = cfg.yMax;

  // If autoscale from data:
  if(cfg.auto){
    const xs = cfg.xs, ys = cfg.ys;
    let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
    for(let i=0;i<xs.length;i++){
      const x = xs[i], y = ys[i];
      if(!isFinite(x)||!isFinite(y)) continue;
      xmin = Math.min(xmin,x); xmax=Math.max(xmax,x);
      ymin = Math.min(ymin,y); ymax=Math.max(ymax,y);
    }
    if(isFinite(xmin)&&isFinite(xmax)){
      xMin = xmin; xMax = xmax;
      yMin = ymin; yMax = ymax;
      if(xMin===xMax){ xMin*=0.9; xMax*=1.1; }
      if(yMin===yMax){ yMin*=0.9; yMax*=1.1; }
    }
  }

  // Convert to axis space
  const xA0 = xLog ? log10(xMin) : xMin;
  const xA1 = xLog ? log10(xMax) : xMax;
  const yA0 = yLog ? log10(yMin) : yMin;
  const yA1 = yLog ? log10(yMax) : yMax;

  function xToPx(x){
    const xa = xLog ? log10(x) : x;
    return pad.l + (xa - xA0)/(xA1 - xA0) * plotW;
  }
  function yToPx(y){
    const ya = yLog ? log10(y) : y;
    return pad.t + (1 - (ya - yA0)/(yA1 - yA0)) * plotH;
  }

  // Gridlines + ticks
  ctx.lineWidth = 1;

  // X ticks
  let xTicks = [];
  if(xLog){
    xTicks = niceTicksLog(xA0, xA1);
  }else{
    xTicks = niceTicksLinear(xMin, xMax, 6).map(v=>({v, major:true, label:String(v)}));
  }

  // Y ticks
  let yTicks = [];
  if(yLog){
    yTicks = niceTicksLog(yA0, yA1);
  }else{
    yTicks = niceTicksLinear(yMin, yMax, 6).map(v=>({v, major:true, label:String(v)}));
  }

  // Draw grid + tick labels
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.fillStyle = 'rgba(183,195,255,0.92)';
  ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';

  // x grid
  for(const t of xTicks){
    const x = t.v;
    if(x <= 0) continue;
    if(x < xMin*0.999 || x > xMax*1.001) continue;
    const px = xToPx(x);
    ctx.beginPath();
    ctx.moveTo(px, pad.t);
    ctx.lineTo(px, pad.t + plotH);
    ctx.strokeStyle = t.major ? 'rgba(255,255,255,0.10)' : 'rgba(255,255,255,0.06)';
    ctx.stroke();

    // ticks
    ctx.strokeStyle = 'rgba(255,255,255,0.16)';
    ctx.beginPath();
    ctx.moveTo(px, pad.t + plotH);
    ctx.lineTo(px, pad.t + plotH + (t.major?7:4));
    ctx.stroke();

    if(t.major){
      const lab = xLog ? t.label : (cfg.xTickFmt ? cfg.xTickFmt(x) : x.toPrecision(2));
      const tw = ctx.measureText(lab).width;
      ctx.fillText(lab, px - tw/2, pad.t + plotH + 18);
    }
  }

  // y grid
  for(const t of yTicks){
    const y = t.v;
    if(y <= 0) continue;
    if(y < yMin*0.999 || y > yMax*1.001) continue;
    const py = yToPx(y);
    ctx.beginPath();
    ctx.moveTo(pad.l, py);
    ctx.lineTo(pad.l + plotW, py);
    ctx.strokeStyle = t.major ? 'rgba(255,255,255,0.10)' : 'rgba(255,255,255,0.06)';
    ctx.stroke();

    // ticks
    ctx.strokeStyle = 'rgba(255,255,255,0.16)';
    ctx.beginPath();
    ctx.moveTo(pad.l - (t.major?7:4), py);
    ctx.lineTo(pad.l, py);
    ctx.stroke();

    if(t.major){
      const lab = yLog ? t.label : (cfg.yTickFmt ? cfg.yTickFmt(y) : y.toPrecision(2));
      const tw = ctx.measureText(lab).width;
      ctx.fillText(lab, pad.l - 10 - tw, py + 4);
    }
  }

  // Axes
  ctx.strokeStyle = 'rgba(255,255,255,0.22)';
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(pad.l, pad.t);
  ctx.lineTo(pad.l, pad.t + plotH);
  ctx.lineTo(pad.l + plotW, pad.t + plotH);
  ctx.stroke();

  // Plot line
  const xs = cfg.xs, ys = cfg.ys;
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(124,240,197,0.95)';
  ctx.beginPath();
  let started = false;
  for(let i=0;i<xs.length;i++){
    const x=xs[i], y=ys[i];
    if(!(x>0 && y>0)) continue;
    if(x<xMin || x>xMax || y<yMin || y>yMax) continue;
    const px = xToPx(x), py = yToPx(y);
    if(!started){ ctx.moveTo(px,py); started=true; }
    else ctx.lineTo(px,py);
  }
  ctx.stroke();

  // Legend
  if(cfg.legend){
    const text = cfg.legend;
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    const tw = ctx.measureText(text).width;
    const bx = pad.l + plotW - tw - 18;
    const by = pad.t + 10;
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.strokeStyle = 'rgba(255,255,255,0.14)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    roundRect(ctx, bx-10, by-14, tw+20, 26, 10);
    ctx.fill();
    ctx.stroke();

    ctx.strokeStyle = 'rgba(124,240,197,0.95)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(bx-2, by-2);
    ctx.lineTo(bx+18, by-2);
    ctx.stroke();

    ctx.fillStyle = 'rgba(233,238,255,0.95)';
    ctx.fillText(text, bx+24, by+2);
  }

  // Marker
  if(cfg.marker){
    const {x,y,label} = cfg.marker;
    if(x>0 && y>0){
      const px = xToPx(clamp(x,xMin,xMax));
      const py = yToPx(clamp(y,yMin,yMax));
      ctx.fillStyle = 'rgba(143,182,255,0.95)';
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(px,py,5.5,0,Math.PI*2);
      ctx.fill();
      ctx.stroke();

      if(label){
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
        const tw = ctx.measureText(label).width;
        const bx = clamp(px+10, pad.l+6, pad.l+plotW - tw - 16);
        const by = clamp(py-18, pad.t+12, pad.t+plotH - 10);
        ctx.fillStyle = 'rgba(0,0,0,0.40)';
        ctx.strokeStyle = 'rgba(255,255,255,0.14)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        roundRect(ctx, bx-8, by-14, tw+16, 24, 10);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = 'rgba(233,238,255,0.95)';
        ctx.fillText(label, bx, by+2);
      }
    }
  }
}

function roundRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

/* -----------------------------
   Diagram canvas
------------------------------ */
function drawDiagram(canvas, state){
  const {ctx,w,h} = setupCanvas(canvas);
  drawPanelBG(ctx,w,h);

  const pad = 18;
  const midY = h*0.52;

  // helper
  function box(x,y,ww,hh,label,sub){
    ctx.fillStyle = 'rgba(0,0,0,0.28)';
    ctx.strokeStyle = 'rgba(255,255,255,0.14)';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    roundRect(ctx, x,y,ww,hh,14);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = 'rgba(233,238,255,0.95)';
    ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(label, x+12, y+22);
    if(sub){
      ctx.fillStyle = 'rgba(183,195,255,0.95)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      ctx.fillText(sub, x+12, y+42);
    }
  }
  function arrow(x1,y1,x2,y2){
    ctx.strokeStyle = 'rgba(124,240,197,0.95)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
    const ang = Math.atan2(y2-y1,x2-x1);
    const ah = 10;
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2 - ah*Math.cos(ang-0.35), y2 - ah*Math.sin(ang-0.35));
    ctx.lineTo(x2 - ah*Math.cos(ang+0.35), y2 - ah*Math.sin(ang+0.35));
    ctx.closePath();
    ctx.fillStyle = 'rgba(124,240,197,0.95)';
    ctx.fill();
  }

  // Title
  ctx.fillStyle = 'rgba(233,238,255,0.95)';
  ctx.font = '600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('Physical setup (direct-detection AM receiver)', pad, 22);

  // Optical wave "beam"
  const x0 = pad+10;
  const x1 = w*0.28;
  ctx.strokeStyle = 'rgba(143,182,255,0.85)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(x0, midY-24);
  for(let x=x0; x<=x1; x+=8){
    const t = (x-x0)/(x1-x0);
    const y = midY-24 + Math.sin(t*8*Math.PI)*6;
    ctx.lineTo(x,y);
  }
  ctx.stroke();

  ctx.fillStyle = 'rgba(183,195,255,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
  ctx.fillText('P(t)=P0 + Ps cos(2πft)', x0, midY-34);

  // Boxes
  const bW = w*0.22;
  const bH = 64;
  const pdX = w*0.30, pdY = midY-46;
  box(pdX, pdY, bW, bH, 'Photodiode', 'i(t)=ℛP(t)');

  const filtX = w*0.56, filtY = midY-46;
  box(filtX, filtY, bW, bH, 'Receiver / Filter', 'BW = B');

  const snrX = w*0.82, snrY = midY-46;
  box(snrX, snrY, bW*0.70, bH, 'SNR meter', 'target SNR0');

  // Arrows
  arrow(x1+6, midY-24, pdX-8, midY-14);
  arrow(pdX+bW+8, midY-14, filtX-8, midY-14);
  arrow(filtX+bW+8, midY-14, snrX-8, midY-14);

  // Noise annotation
  ctx.fillStyle = 'rgba(255,207,90,0.95)';
  ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('Shot noise set by DC:  ⟨in²⟩ = 2 q I0 B,  I0=ℛP0', pad+10, h-20);

  // Tiny inset showing DC + tone
  const ix = pad+10, iy = midY+30, iw = w*0.35, ih = 90;
  ctx.fillStyle = 'rgba(0,0,0,0.18)';
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  roundRect(ctx, ix, iy, iw, ih, 14);
  ctx.fill(); ctx.stroke();

  ctx.fillStyle = 'rgba(183,195,255,0.95)';
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('Photocurrent', ix+12, iy+20);

  // axis
  ctx.strokeStyle = 'rgba(255,255,255,0.14)';
  ctx.beginPath();
  ctx.moveTo(ix+14, iy+70);
  ctx.lineTo(ix+iw-14, iy+70);
  ctx.stroke();

  // signal
  const I0n = 0.55;
  const As = 0.22;
  ctx.strokeStyle = 'rgba(124,240,197,0.95)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let k=0;k<=140;k++){
    const t = k/140;
    const x = ix+14 + t*(iw-28);
    const y = iy+70 - (I0n + As*Math.cos(2*Math.PI*3*t))*(ih*0.55);
    if(k===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  ctx.fillStyle = 'rgba(183,195,255,0.95)';
  ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
  ctx.fillText('DC + tone at f', ix+12, iy+42);

  // Current state label
  const label =
    `Example: P0=${fmtSI(state.P0,'W')},  B=${fmtSI(state.B,'Hz')},  ℛ=${state.R.toFixed(2)} A/W`;
  ctx.fillStyle = 'rgba(233,238,255,0.90)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
  ctx.fillText(label, w*0.42, h-20);
}

/* -----------------------------
   State + UI
------------------------------ */
const elP0 = document.getElementById('p0');
const elBw = document.getElementById('bw');
const elR  = document.getElementById('R');
const elS  = document.getElementById('snrdb');

const p0Val = document.getElementById('p0Val');
const bwVal = document.getElementById('bwVal');
const RVal  = document.getElementById('RVal');
const snrVal= document.getElementById('snrVal');

const snrLinEl = document.getElementById('snrLin');
const I0El = document.getElementById('I0');
const inRmsEl = document.getElementById('inRms');
const PsMinEl = document.getElementById('PsMin');

const cDiagram = document.getElementById('canvasDiagram');
const cMain = document.getElementById('canvasMain');
const cSec  = document.getElementById('canvasSecondary');

function getState(){
  // Sliders are log-scaled for P0 and B:
  // P0 slider exponent in mW: 10^x mW -> W
  const p0_mW = pow10(parseFloat(elP0.value));
  const P0 = p0_mW * 1e-3;

  // B slider exponent in MHz: 10^x MHz -> Hz
  const B_MHz = pow10(parseFloat(elBw.value));
  const B = B_MHz * 1e6;

  const R = parseFloat(elR.value);

  const snrdb = parseFloat(elS.value);
  const SNRlin = pow10(snrdb/10);

  return {P0, B, R, snrdb, SNRlin, p0_mW, B_MHz};
}

function updateUI(){
  const s = getState();

  p0Val.textContent = fmtSI(s.p0_mW, 'mW');
  bwVal.textContent = fmtSI(s.B_MHz, 'MHz');
  RVal.textContent = s.R.toFixed(2) + ' A/W';
  snrVal.textContent = s.snrdb.toFixed(1) + ' dB';

  snrLinEl.textContent = s.SNRlin.toFixed(0);
  const I0v = I0(s.P0, s.R);
  I0El.textContent = fmtSI(I0v, 'A');
  inRmsEl.textContent = fmtSI(inRms(s.P0, s.B, s.R), 'A');
  const Ps = PsMin(s.P0, s.B, s.R, s.SNRlin);
  PsMinEl.textContent = fmtSI(Ps, 'W') + '  (' + fmtSI(Ps*1e3,'mW') + ')';

  // Diagram
  drawDiagram(cDiagram, s);

  // Main plot: Ps_min vs P0
  const xs = [];
  const ys = [];
  const P0min = 1e-9, P0max = 1e-2; // W
  const N = 220;
  for(let i=0;i<N;i++){
    const t = i/(N-1);
    const P0 = P0min * Math.pow(P0max/P0min, t);
    xs.push(P0);
    ys.push(PsMin(P0, s.B, s.R, s.SNRlin));
  }
  const yMin = Math.max(1e-12, Math.min(...ys)*0.7);
  const yMax = Math.max(...ys)*1.3;

  plotXY(cMain, {
    title: 'Minimum detectable modulation vs background power',
    xLabel: 'Background power P₀ (W, log scale)',
    yLabel: 'Minimum modulation Pₛ,min (W, log scale)',
    xs, ys,
    xLog:true, yLog:true,
    xMin:P0min, xMax:P0max,
    yMin:yMin, yMax:yMax,
    legend: 'Pₛ,min(P₀)',
    marker:{
      x: s.P0,
      y: PsMin(s.P0, s.B, s.R, s.SNRlin),
      label: 'current'
    }
  });

  // Secondary plot: Ps_min vs B
  const x2 = [];
  const y2 = [];
  const Bmin = 1e3, Bmax = 1e9; // Hz
  for(let i=0;i<N;i++){
    const t = i/(N-1);
    const B = Bmin * Math.pow(Bmax/Bmin, t);
    x2.push(B);
    y2.push(PsMin(s.P0, B, s.R, s.SNRlin));
  }
  const y2Min = Math.max(1e-12, Math.min(...y2)*0.7);
  const y2Max = Math.max(...y2)*1.3;

  plotXY(cSec, {
    title: 'Minimum detectable modulation vs receiver bandwidth',
    xLabel: 'Bandwidth B (Hz, log scale)',
    yLabel: 'Minimum modulation Pₛ,min (W, log scale)',
    xs: x2, ys: y2,
    xLog:true, yLog:true,
    xMin:Bmin, xMax:Bmax,
    yMin:y2Min, yMax:y2Max,
    legend: 'Pₛ,min(B)',
    marker:{
      x: s.B,
      y: PsMin(s.P0, s.B, s.R, s.SNRlin),
      label: 'current'
    }
  });
}

['input','change'].forEach(evt=>{
  elP0.addEventListener(evt, updateUI);
  elBw.addEventListener(evt, updateUI);
  elR.addEventListener(evt, updateUI);
  elS.addEventListener(evt, updateUI);
});

window.addEventListener('resize', ()=> {
  // Redraw on resize for crisp layouts
  updateUI();
});

// Initial render
updateUI();
</script>
</body>
</html>
