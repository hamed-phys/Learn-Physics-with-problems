<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mean Gain of a Staircase APD (SCISCM): Bernoulli Model, Closed Form, and Continuous Limit</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f1620;
      --panel2:#0c121a;
      --text:#e9eef7;
      --muted:#a8b3c7;
      --faint:#6b7690;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line: rgba(255,255,255,0.10);
      --shadow: 0 16px 40px rgba(0,0,0,0.45);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background:
        radial-gradient(1200px 800px at 20% -10%, rgba(125,211,252,0.18), transparent 55%),
        radial-gradient(900px 700px at 95% 10%, rgba(167,139,250,0.16), transparent 55%),
        radial-gradient(900px 900px at 50% 120%, rgba(52,211,153,0.10), transparent 60%),
        linear-gradient(180deg, #070a0e, var(--bg) 40%, #070a0e);
      overflow-x:hidden;
    }

    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    code, .mono{font-family: var(--mono)}
    .eq{
      font-family: var(--mono);
      padding: .14rem .42rem;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(255,255,255,0.04);
      display:inline-block;
      white-space:nowrap;
    }

    header{
      padding: 28px 18px 16px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .hero{
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 20px 18px;
      position:relative;
      overflow:hidden;
    }
    .hero:before{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(600px 240px at 20% 15%, rgba(125,211,252,0.18), transparent 60%),
        radial-gradient(520px 220px at 75% 25%, rgba(167,139,250,0.15), transparent 60%);
      filter: blur(10px);
      opacity: .9;
      pointer-events:none;
    }
    .hero > *{position:relative}
    h1{
      margin: 0 0 6px;
      font-size: clamp(1.55rem, 2.4vw, 2.25rem);
      letter-spacing: -0.02em;
      line-height:1.15;
    }
    .subtitle{
      margin:0;
      color: var(--muted);
      max-width: 75ch;
      line-height:1.5;
      font-size: 1.02rem;
    }
    .meta{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 12px;
      color: var(--faint);
      font-size: .93rem;
    }
    .pill{
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 6px 10px;
      background: rgba(255,255,255,0.03);
    }

    main{
      max-width: 1200px;
      margin: 0 auto;
      padding: 16px 18px 70px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 16px;
      align-items:start;
    }

    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
    }
    nav.toc h2{
      margin: 0 0 10px;
      font-size: 1.02rem;
      color: var(--text);
      letter-spacing: .01em;
    }
    .toc a{
      display:block;
      padding: 7px 10px;
      border-radius: 12px;
      color: var(--muted);
      font-size: .95rem;
      line-height:1.25;
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .toc a:hover{
      background: rgba(125,211,252,0.08);
      border-color: rgba(125,211,252,0.20);
      transform: translateX(2px);
      color: var(--text);
      text-decoration:none;
    }
    .toc .small{
      color: var(--faint);
      font-size: .86rem;
      margin-top: 8px;
      line-height:1.35;
      padding: 0 10px 8px;
    }

    article{
      background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.015));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px;
      overflow:hidden;
    }

    section{scroll-margin-top: 18px}
    h2{
      margin: 18px 0 10px;
      font-size: 1.35rem;
      letter-spacing: -0.01em;
    }
    h3{
      margin: 14px 0 8px;
      font-size: 1.1rem;
      color: var(--text);
    }
    p{color: var(--muted); line-height:1.65; margin: 10px 0}
    ul{color: var(--muted); line-height:1.65; margin: 8px 0 12px 20px}
    li{margin: 6px 0}
    hr.sep{
      border:0;
      height:1px;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.14), transparent);
      margin: 16px 0;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
      nav.toc{position:relative; top:auto}
      .grid2{grid-template-columns: 1fr}
    }

    .callout{
      border: 1px solid var(--line);
      border-radius: 16px;
      background: rgba(255,255,255,0.03);
      padding: 12px 12px 10px;
      margin: 12px 0;
    }
    .callout strong{color: var(--text)}
    .callout .title{
      display:flex;
      align-items:center;
      gap:10px;
      margin-bottom: 6px;
      color: var(--text);
      font-weight: 650;
      letter-spacing: .01em;
    }
    .badge{
      font-size: .78rem;
      padding: 3px 8px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,0.04);
      color: var(--faint);
    }
    .callout.assumptions{border-color: rgba(125,211,252,0.25)}
    .callout.keyeq{border-color: rgba(167,139,250,0.25)}
    .callout.mistakes{border-color: rgba(251,191,36,0.28)}
    .callout.final{border-color: rgba(52,211,153,0.30)}
    .callout.final .title{color: var(--good)}
    .callout.keyeq .title{color: var(--accent2)}
    .callout.assumptions .title{color: var(--accent)}
    .callout.mistakes .title{color: var(--warn)}

    .copyRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-top: 8px;
    }
    button.copyBtn{
      appearance:none;
      border:1px solid var(--line);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 600;
      font-size: .9rem;
      transition: transform .10s ease, border-color .12s ease, background .12s ease;
    }
    button.copyBtn:hover{
      transform: translateY(-1px);
      border-color: rgba(125,211,252,0.30);
      background: rgba(125,211,252,0.08);
    }
    button.copyBtn:active{transform: translateY(0px) scale(0.99)}
    .copyStatus{
      color: var(--faint);
      font-size: .9rem;
      min-height: 1.2em;
    }

    figure{
      margin: 12px 0;
      border:1px solid var(--line);
      border-radius: 16px;
      overflow:hidden;
      background: rgba(0,0,0,0.18);
    }
    figcaption{
      padding: 10px 12px;
      border-top:1px solid var(--line);
      color: var(--faint);
      font-size: .92rem;
      line-height:1.45;
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
    }
    .canvasTall canvas{height: 360px}

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin: 12px 0 8px;
    }
    .ctrl{
      border:1px solid var(--line);
      border-radius: 16px;
      background: rgba(255,255,255,0.03);
      padding: 10px 12px;
    }
    .ctrl label{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      color: var(--text);
      font-weight: 650;
      margin-bottom: 8px;
    }
    .ctrl .val{
      color: var(--accent);
      font-family: var(--mono);
      font-weight:700;
      font-size: .98rem;
    }
    input[type="range"]{width:100%}
    .hint{
      color: var(--faint);
      font-size: .86rem;
      margin-top: 6px;
      line-height:1.35;
    }

    .kpiRow{
      display:grid;
      grid-template-columns: 1.2fr 1fr 1fr;
      gap: 12px;
      margin: 12px 0;
    }
    .kpi{
      border:1px solid var(--line);
      border-radius: 16px;
      background: rgba(255,255,255,0.03);
      padding: 10px 12px;
    }
    .kpi .k{color: var(--faint); font-size: .86rem}
    .kpi .v{
      margin-top: 4px;
      font-family: var(--mono);
      font-weight: 800;
      font-size: 1.15rem;
      letter-spacing: -0.01em;
    }
    .kpi .v small{color: var(--faint); font-weight:650}
    @media (max-width: 980px){
      .controls{grid-template-columns: 1fr}
      .kpiRow{grid-template-columns: 1fr}
      canvas{height: 300px}
    }

    footer{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 18px 30px;
      color: var(--faint);
      font-size: .92rem;
      line-height:1.5;
    }

    @media print{
      body{background:#fff; color:#000}
      nav.toc{display:none}
      article, .hero{box-shadow:none}
      a{color:#000; text-decoration:underline}
      .callout{break-inside: avoid}
      figure{break-inside: avoid}
      button{display:none}
      .copyStatus{display:none}
    }

    /* subtle entrance */
    @keyframes floatIn{
      from{opacity:0; transform: translateY(10px)}
      to{opacity:1; transform: translateY(0px)}
    }
    .hero, nav.toc, article{animation: floatIn .35s ease both}
    nav.toc{animation-delay:.06s}
    article{animation-delay:.1s}
  </style>
</head>
<body>
<header>
  <div class="hero">
    <h1>Mean Gain of a Staircase APD (SCISCM): Bernoulli Stages → Closed Form → Continuous Limit</h1>
    <p class="subtitle">
      We model a <span class="mono">staircase</span> avalanche photodiode (APD) as a chain of identical impact-ionization stages.
      Under <span class="mono">single-carrier injection / single-carrier multiplication (SCISCM)</span>, each stage behaves like a Bernoulli “branch-or-not” event.
      That simple probability model is enough to derive the mean gain and connect it to the familiar continuous APD result.
    </p>
    <div class="meta">
      <span class="pill">Topic: Photonics / APDs / Impact ionization</span>
      <span class="pill">Model: Bernoulli branching per stage</span>
      <span class="pill">Result: ⟨gain⟩ = (1+P)<sup>N</sup> and → exp(αL)</span>
    </div>
  </div>
</header>

<main>
  <nav class="toc" aria-label="Table of Contents">
    <h2>On this page</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy &amp; Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
    <div class="small">
      Sticky TOC: click to jump. Plots update live with the controls.
    </div>
  </nav>

  <article>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><strong>What:</strong> Find the <em>mean multiplication gain</em> of a staircase APD modeled as <span class="eq">N</span> identical stages.</li>
        <li><strong>Key physics idea:</strong> Under SCISCM, each electron traversing a stage either <em>does not</em> ionize (probability <span class="eq">1−P</span>) or <em>does</em> ionize and produces one extra electron (probability <span class="eq">P</span>).</li>
        <li><strong>Governing stochastic rule:</strong> One stage is a Bernoulli branching step with expected multiplicative factor <span class="eq">E[m] = 1·(1−P) + 2·P = 1+P</span>.</li>
        <li><strong>Main result (symbolic):</strong> Mean gain after <span class="eq">N</span> stages is <span class="eq">&lang;G&rang; = (1+P)^N</span>.</li>
        <li><strong>Continuous (conventional) SCISCM limit:</strong> Take <span class="eq">P→0</span>, <span class="eq">N→∞</span> with <span class="eq">NP = αL</span> fixed ⇒ <span class="eq">(1+P)^N → e^{NP} = e^{αL}</span>.</li>
        <li><strong>Interpretation:</strong> <span class="eq">NP</span> is the expected number of ionization events accumulated over the device; in a continuous APD it equals <span class="eq">∫ α(x)dx</span>.</li>
      </ul>

      <div class="callout keyeq">
        <div class="title">
          <span class="badge">Key Equations</span>
          Mean gain for staircase APD (SCISCM)
        </div>
        <p style="margin:6px 0 10px;">
          <span class="eq" id="eq-main">⟨G⟩ = (1 + P)^N</span>
          <span class="mono" style="color:var(--faint);">, where P is per-stage ionization probability and N is number of stages.</span>
        </p>
        <p style="margin:6px 0 0;">
          <span class="eq" id="eq-limit">(1+P)^N → exp(NP) = exp(αL)  (P→0, N→∞, NP=αL)</span>
        </p>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="eq-main">Copy ⟨G⟩=(1+P)^N</button>
          <button class="copyBtn" data-copy-target="eq-limit">Copy continuous limit</button>
          <span class="copyStatus" id="copyStatusTop" aria-live="polite"></span>
        </div>
      </div>
    </section>

    <hr class="sep" />

    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <h3>Core definitions (symbols &amp; units)</h3>
      <ul>
        <li><strong>Impact ionization:</strong> a high-field carrier creates an extra electron–hole pair by collision. (Microscopic scattering process.)</li>
        <li><strong>Stage (staircase APD):</strong> a designed region where the electron is likely to ionize at a discrete location/energy step.</li>
        <li><strong><span class="eq">P</span> (unitless):</strong> probability that an electron causes one impact-ionization event in a given stage.</li>
        <li><strong><span class="eq">N</span> (unitless):</strong> number of stages in the staircase multiplication region.</li>
        <li><strong>Gain <span class="eq">G</span> (unitless):</strong> total number of collected electrons per injected electron (random variable).</li>
        <li><strong>Mean gain <span class="eq">⟨G⟩</span> (unitless):</strong> expectation value of gain over many events.</li>
        <li><strong><span class="eq">α</span> (1/length):</strong> electron ionization coefficient in a conventional (continuous) APD; probability per unit length of ionization.</li>
        <li><strong><span class="eq">L</span> (length):</strong> multiplication-region length; <span class="eq">αL</span> is dimensionless.</li>
      </ul>

      <h3>Physical meaning (what these represent)</h3>
      <p>
        In SCISCM, we inject (or generate) essentially <em>one</em> carrier type (say an electron), and only that carrier type is assumed
        to ionize significantly (holes are “inactive” for multiplication). The avalanche is then a one-sided branching process:
        each active electron can create additional active electrons.
      </p>
      <p>
        The staircase APD uses bandgap engineering (a “staircase” in the conduction band) to localize where ionization happens:
        instead of a continuous probability along the path, the electron experiences <em>discrete opportunities</em> to ionize.
      </p>

      <h3>Key laws/principles and validity</h3>
      <ul>
        <li><strong>Bernoulli trial model:</strong> Each stage gives either “no ionization” or “one ionization” with a fixed probability <span class="eq">P</span>.
          Valid when stages are identical and independent and when multiple ionizations within a single stage are negligible.</li>
        <li><strong>Linearity of expectation:</strong> Even when the total number of electrons is random and branches, the mean can be propagated by expected
          multiplicative factors per stage.</li>
        <li><strong>Continuous limit:</strong> If you split a region into many tiny slices, each with very small ionization probability, the discrete multiplication approaches an exponential law.</li>
      </ul>

      <h3>Common models/approximations (why we use them)</h3>
      <div class="grid2">
        <div class="callout assumptions">
          <div class="title"><span class="badge">Model</span> Staircase as identical independent stages</div>
          <ul>
            <li>Each electron entering a stage experiences at most one ionization event.</li>
            <li>Ionization outcomes between stages are independent.</li>
            <li>Newly created electrons “join” the population and face the remaining stages.</li>
          </ul>
        </div>
        <div class="callout assumptions">
          <div class="title"><span class="badge">SCISCM</span> Single-carrier multiplication</div>
          <ul>
            <li>Only electrons ionize (hole ionization is neglected).</li>
            <li>So each ionization effectively increases the number of active electrons by exactly 1.</li>
            <li>Mean gain becomes especially simple (no coupled e–h feedback).</li>
          </ul>
        </div>
      </div>

      <h3>Mini intuition examples (conceptual, not algebra-heavy)</h3>
      <ul>
        <li>If <span class="eq">P=0</span>, nothing ever ionizes: one electron stays one electron ⇒ <span class="eq">⟨G⟩=1</span>.</li>
        <li>If <span class="eq">P=1</span> and there are <span class="eq">N</span> stages, every electron splits into two at every stage ⇒ mean (and exact) gain is <span class="eq">2^N</span>.</li>
      </ul>

      <div class="callout mistakes">
        <div class="title"><span class="badge">What to watch for</span> Typical pitfalls</div>
        <ul>
          <li>Confusing <strong>mean gain</strong> with the <strong>most probable</strong> gain. Branching processes can have broad distributions.</li>
          <li>Forgetting that newly created electrons also traverse the remaining stages (multiplication compounds).</li>
          <li>Mixing “per-stage probability <span class="eq">P</span>” with “per-length coefficient <span class="eq">α</span>” without a clear mapping (<span class="eq">P ≈ αΔx</span> for small slices).</li>
        </ul>
      </div>
    </section>

    <hr class="sep" />

    <section id="part1">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Restate the problem in plain language</h3>
      <p>
        A staircase APD has <span class="eq">N</span> discrete multiplication stages. In each stage, an electron has probability <span class="eq">P</span>
        to undergo impact ionization (creating one additional electron that participates in further multiplication).
        Use the Bernoulli probability law to show the mean gain is <span class="eq">(1+P)^N</span>.
        Then show that in the limit of infinitely many stages with vanishingly small per-stage probability
        (<span class="eq">P→0</span>, <span class="eq">N→∞</span>), the result reduces to the conventional SCISCM APD gain.
      </p>

      <h3>Given quantities</h3>
      <ul>
        <li><span class="eq">P</span>: per-stage ionization probability (dimensionless).</li>
        <li><span class="eq">N</span>: number of stages (dimensionless integer).</li>
      </ul>

      <h3>Unknowns / what must be shown</h3>
      <ul>
        <li>Prove: <span class="eq">⟨G⟩ = (1+P)^N</span>.</li>
        <li>Show the continuous-limit connection to a conventional SCISCM APD:
          <span class="eq">(1+P)^N → exp(αL)</span> with an appropriate identification of <span class="eq">αL</span>.</li>
      </ul>

      <h3>Relevant physical principles (and why)</h3>
      <ul>
        <li><strong>Bernoulli trial per stage:</strong> each stage is a two-outcome random experiment (ionize vs not). This is exactly what “Bernoulli probability law” means here.</li>
        <li><strong>Branching + expectation propagation:</strong> mean number of electrons after a stage equals (mean before) × (mean multiplicative factor for one electron in one stage).</li>
        <li><strong>Continuous limit of discrete compounding:</strong> the standard limit <span class="eq">(1+x/n)^n → e^x</span> connects discrete stages to an exponential law.</li>
      </ul>

      <div class="callout assumptions">
        <div class="title"><span class="badge">Assumptions</span> Idealizations used</div>
        <ul>
          <li>Each stage produces at most one additional electron (no “multiple ionizations in one stage”).</li>
          <li>All stages are identical: same <span class="eq">P</span> for every electron and every stage.</li>
          <li>Events are independent across stages and carriers (no space-charge saturation, no depletion-field collapse).</li>
          <li>SCISCM: only electrons multiply; holes do not create additional carriers that feed back.</li>
        </ul>
      </div>

      <h3>Possible approaches (compare briefly)</h3>
      <ul>
        <li><strong>Approach A — expectation recursion (best):</strong> treat each stage as multiplying the mean by <span class="eq">1+P</span>, then raise to <span class="eq">N</span>. Fast and conceptually clean.</li>
        <li><strong>Approach B — full probability distribution:</strong> build the branching-process distribution of electron count after <span class="eq">N</span> stages. More detailed, but unnecessary if only the mean is required.</li>
        <li><strong>Approach C — generating functions:</strong> elegant for branching, gives higher moments too; heavier machinery than needed here.</li>
      </ul>

      <p>
        We choose <strong>Approach A</strong> because the problem asks specifically for the <em>mean</em> gain and mentions the Bernoulli law,
        which naturally gives the per-stage expected multiplication factor.
      </p>
    </section>

    <hr class="sep" />

    <section id="part2">
      <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>

      <ol style="color:var(--muted); line-height:1.65; margin: 8px 0 12px 20px;">
        <li><strong>Define one-stage outcome.</strong>
          <br><span class="mono">Goal:</span> express how many electrons exit one stage per entering electron.
          <br><span class="mono">Tool:</span> Bernoulli two-outcome model.
          <br><span class="mono">Meaning:</span> local “branch-or-not” step.</li>

        <li><strong>Compute one-stage expected factor.</strong>
          <br><span class="mono">Goal:</span> find <span class="eq">E[m]</span> where <span class="eq">m ∈ {1,2}</span>.
          <br><span class="mono">Tool:</span> expectation of a discrete random variable.
          <br><span class="mono">Meaning:</span> average multiplication per stage.</li>

        <li><strong>Propagate the mean through N stages.</strong>
          <br><span class="mono">Goal:</span> relate <span class="eq">⟨G_{k+1}⟩</span> to <span class="eq">⟨G_k⟩</span>.
          <br><span class="mono">Tool:</span> linearity of expectation + identical independent stages.
          <br><span class="mono">Meaning:</span> compounding mean gain.</li>

        <li><strong>Close the recursion.</strong>
          <br><span class="mono">Goal:</span> solve the geometric recursion to obtain <span class="eq">(1+P)^N</span>.
          <br><span class="mono">Tool:</span> repeated multiplication.
          <br><span class="mono">Meaning:</span> mean gain grows exponentially with number of stages.</li>

        <li><strong>Take the continuous limit.</strong>
          <br><span class="mono">Goal:</span> show <span class="eq">(1+P)^N → e^{NP}</span>.
          <br><span class="mono">Tool:</span> logarithms or classic exponential limit.
          <br><span class="mono">Meaning:</span> many tiny ionization chances produce an exponential law.</li>

        <li><strong>Map to conventional APD notation.</strong>
          <br><span class="mono">Goal:</span> identify <span class="eq">NP</span> with <span class="eq">∫ α(x)dx</span> (or <span class="eq">αL</span> for uniform field).
          <br><span class="mono">Meaning:</span> staircase stages are discrete slices of a continuous multiplication region.</li>
      </ol>

      <div class="callout mistakes">
        <div class="title"><span class="badge">Common mistakes</span> Quick tips</div>
        <ul>
          <li>Do not add probabilities across stages; gains compound multiplicatively in expectation.</li>
          <li>Do not treat <span class="eq">⟨G⟩</span> as <span class="eq">1+NP</span>; that would ignore compounding from newly created carriers.</li>
          <li>In the continuous limit, keep <span class="eq">NP</span> (or <span class="eq">αL</span>) fixed—otherwise the limit is ambiguous.</li>
        </ul>
      </div>
    </section>

    <hr class="sep" />

    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Physical intuition first (before math)</h3>
      <p>
        Each stage is a chance for an electron to “spawn” one extra electron. Even if the probability <span class="eq">P</span> is modest,
        the key is that <em>new electrons also get chances in later stages</em>, so the mean grows by repeated compounding.
        That strongly suggests an exponential-in-<span class="eq">N</span> behavior, not a simple linear increase.
      </p>

      <h3>Step 1: Define the one-stage random multiplication</h3>
      <p>
        Consider <strong>one</strong> electron entering a single stage. Under SCISCM and the Bernoulli model:
      </p>
      <ul>
        <li>With probability <span class="eq">1-P</span>, no impact ionization occurs → 1 electron exits the stage.</li>
        <li>With probability <span class="eq">P</span>, one ionization occurs → 2 electrons exit the stage (the original plus one new).</li>
      </ul>
      <p>
        Define the one-stage multiplicative factor <span class="eq">m</span> for a single electron:
        <span class="eq">m = 1</span> with probability <span class="eq">1-P</span>, and <span class="eq">m = 2</span> with probability <span class="eq">P</span>.
      </p>

      <div class="callout keyeq">
        <div class="title"><span class="badge">Definition</span> One-stage Bernoulli branching</div>
        <p style="margin:6px 0 0;">
          <span class="eq">m = {1 (prob 1−P),  2 (prob P)}</span>
        </p>
      </div>

      <h3>Step 2: Compute the expected multiplication per stage</h3>
      <p>
        The expected value of <span class="eq">m</span> is
      </p>
      <p class="mono" style="color:var(--text); margin: 6px 0;">
        E[m] = 1·(1−P) + 2·P
      </p>
      <p>
        Compute it explicitly:
      </p>
      <p class="mono" style="color:var(--text); margin: 6px 0;">
        E[m] = (1−P) + 2P = 1 + P.
      </p>
      <p>
        <strong>Meaning:</strong> on average, each stage multiplies the electron population by a factor <span class="eq">1+P</span>.
      </p>

      <h3>Step 3: Propagate the mean through N stages (recursion)</h3>
      <p>
        Let <span class="eq">X_k</span> be the random number of electrons after completing <span class="eq">k</span> stages,
        starting with a single injected electron:
        <span class="eq">X_0 = 1</span>.
      </p>
      <p>
        When those <span class="eq">X_k</span> electrons pass through the next stage, each electron independently produces
        an expected factor <span class="eq">E[m] = 1+P</span>. Therefore the expected number after stage <span class="eq">k+1</span> satisfies:
      </p>

      <div class="callout keyeq">
        <div class="title"><span class="badge">Expectation recursion</span> Mean population update</div>
        <p style="margin:6px 0 0;">
          <span class="eq" id="eq-rec">⟨X_{k+1}⟩ = (1+P) ⟨X_k⟩</span>
        </p>
      </div>

      <p>
        <strong>Why this is valid:</strong> conditioning on <span class="eq">X_k</span>, the expected number leaving the next stage is
        <span class="eq">X_k · E[m]</span>. Taking expectation over <span class="eq">X_k</span> and using linearity gives the recursion above.
      </p>

      <h3>Step 4: Solve the recursion</h3>
      <p>
        Starting from <span class="eq">⟨X_0⟩=1</span>:
      </p>
      <p class="mono" style="color:var(--text); margin: 6px 0;">
        ⟨X_1⟩ = (1+P)⟨X_0⟩ = (1+P) <br/>
        ⟨X_2⟩ = (1+P)⟨X_1⟩ = (1+P)^2 <br/>
        … <br/>
        ⟨X_N⟩ = (1+P)^N
      </p>

      <div class="callout final">
        <div class="title"><span class="badge">Final answer</span> Mean gain of staircase APD (SCISCM)</div>
        <p style="margin:6px 0 10px;">
          The mean gain is the mean number of collected electrons per injected electron:
          <span class="eq" id="eq-final">⟨G⟩ = ⟨X_N⟩ = (1 + P)^N</span>.
        </p>
        <div class="copyRow">
          <button class="copyBtn" data-copy-target="eq-final">Copy final answer</button>
          <span class="copyStatus" id="copyStatusFinal" aria-live="polite"></span>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><strong>Units:</strong> <span class="eq">P</span> and <span class="eq">N</span> are dimensionless, so <span class="eq">(1+P)^N</span> is dimensionless—appropriate for gain.</li>
        <li><strong>Limiting case <span class="eq">P=0</span>:</strong> <span class="eq">⟨G⟩=(1+0)^N=1</span> (no multiplication).</li>
        <li><strong>Limiting case <span class="eq">P=1</span>:</strong> <span class="eq">⟨G⟩=2^N</span> (every stage doubles).</li>
        <li><strong>Monotonicity:</strong> Increasing either <span class="eq">P</span> or <span class="eq">N</span> increases the mean gain, as physically expected.</li>
      </ul>

      <h3>Step 5: Show the continuous (conventional) SCISCM limit</h3>
      <p>
        The problem asks for the limit where there are infinitely many stages, each with vanishingly small ionization probability,
        so that ionization in any given stage is rare, yet the overall multiplication remains finite.
        Mathematically: <span class="eq">P → 0</span>, <span class="eq">N → ∞</span>, while the product <span class="eq">NP</span> stays finite.
      </p>

      <p>
        Start from the exact mean gain:
        <span class="eq">⟨G⟩=(1+P)^N</span>.
        Take logs:
      </p>
      <p class="mono" style="color:var(--text); margin: 6px 0;">
        ln⟨G⟩ = N ln(1+P).
      </p>
      <p>
        For small <span class="eq">P</span>, the standard expansion is <span class="eq">ln(1+P) = P − P^2/2 + O(P^3)</span>.
        Multiply by <span class="eq">N</span>:
      </p>
      <p class="mono" style="color:var(--text); margin: 6px 0;">
        ln⟨G⟩ = N(P − P^2/2 + …) = NP − (N P^2)/2 + …
      </p>
      <p>
        If <span class="eq">NP</span> is finite and <span class="eq">P→0</span>, then <span class="eq">NP^2 = (NP)·P → 0</span>.
        Therefore:
      </p>
      <p class="mono" style="color:var(--text); margin: 6px 0;">
        ln⟨G⟩ → NP  ⇒  ⟨G⟩ → exp(NP).
      </p>

      <div class="callout keyeq">
        <div class="title"><span class="badge">Continuous limit</span> Many tiny stages</div>
        <p style="margin:6px 0 0;">
          <span class="eq" id="eq-cont">P→0, N→∞, with μ≡NP fixed  ⇒  ⟨G⟩=(1+P)^N → e^{μ}</span>
        </p>
      </div>

      <h3>Connect to the conventional SCISCM APD result</h3>
      <p>
        In a conventional (continuous) multiplication region, define <span class="eq">α(x)</span> as the electron ionization coefficient:
        the probability of ionization in a small length <span class="eq">dx</span> is approximately <span class="eq">α(x)dx</span> (when this is small).
      </p>
      <p>
        If we discretize the region into <span class="eq">N</span> slices of thickness <span class="eq">Δx = L/N</span>, then for sufficiently small slices:
        <span class="eq">P ≈ αΔx</span>. For uniform field (constant <span class="eq">α</span>), we get:
        <span class="eq">NP ≈ N(αL/N) = αL</span>.
      </p>
      <p>
        Therefore the continuous limit gives:
      </p>
      <p class="mono" style="color:var(--text); margin: 6px 0;">
        ⟨G⟩ → exp(NP) = exp(αL),
      </p>
      <p>
        which is the standard mean-gain form for a pure single-carrier (electron-only) multiplication model over a uniform region.
        More generally, if <span class="eq">α</span> varies with position,
        <span class="eq">NP</span> is replaced by the integral <span class="eq">∫_0^L α(x)dx</span>.
      </p>

      <div class="callout final">
        <div class="title"><span class="badge">Key identification</span> Staircase ↔ Continuous APD</div>
        <p style="margin:6px 0;">
          Discrete stages: <span class="eq">⟨G⟩=(1+P)^N</span>
          <span class="mono" style="color:var(--faint);">with</span>
          <span class="eq">P ≈ αΔx</span>, <span class="eq">Δx=L/N</span>.
        </p>
        <p style="margin:6px 0 0;">
          Continuous limit: <span class="eq">⟨G⟩ → exp(αL)</span> (or <span class="eq">exp(∫ α(x)dx)</span>).
        </p>
      </div>

      <p>
        <strong>Diagram/plots connection:</strong> The staircase diagram visualizes the <em>discrete opportunities</em> (stages) where branching can occur.
        The plots show how repeated Bernoulli branching produces <span class="eq">(1+P)^N</span> and how it converges to <span class="eq">e^{NP}</span> when stages become very fine.
      </p>
    </section>

    <hr class="sep" />

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpret the final formula</h3>
      <p>
        The mean gain <span class="eq">⟨G⟩=(1+P)^N</span> has a clean control structure:
      </p>
      <ul>
        <li><span class="eq">P</span> controls the <strong>strength of multiplication per stage</strong> (how likely branching is at each discrete step).</li>
        <li><span class="eq">N</span> controls how many times multiplication can <strong>compound</strong> (how many opportunities exist).</li>
        <li>The combination <span class="eq">μ = NP</span> is the <strong>expected total ionization count along the device</strong> in the “rare per-stage” regime, and it sets the continuous-limit gain <span class="eq">e^{μ}</span>.</li>
      </ul>

      <h3>How parameters affect outcome (connect to interactive plots)</h3>
      <ul>
        <li>Increasing <span class="eq">N</span> at fixed <span class="eq">P</span> makes gain rise rapidly (geometric growth).</li>
        <li>When <span class="eq">P</span> is small, <span class="eq">(1+P)^N</span> closely tracks <span class="eq">e^{NP}</span> (you’ll see the curves nearly overlap).</li>
        <li>The relative error between discrete and continuous models grows as <span class="eq">P</span> increases (since “small-probability per slice” is no longer true).</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        You can view the staircase APD as a <strong>Galton–Watson branching process</strong> with offspring number per electron per stage equal to 1 (prob. <span class="eq">1−P</span>) or 2 (prob. <span class="eq">P</span>).
        The mean population after <span class="eq">N</span> generations is the initial population times the mean offspring number to the power <span class="eq">N</span>, immediately giving <span class="eq">(1+P)^N</span>.
      </p>

      <h3>Concept check (quick self-test)</h3>
      <ul>
        <li><strong>Q:</strong> Why is the mean gain multiplicative across stages? <strong>A:</strong> Each stage acts independently on every electron, and expectation scales by the mean per-electron multiplication factor <span class="eq">1+P</span>.</li>
        <li><strong>Q:</strong> If <span class="eq">NP</span> is fixed and <span class="eq">N</span> increases, what must happen to <span class="eq">P</span>? <strong>A:</strong> <span class="eq">P</span> must decrease like <span class="eq">P=μ/N</span> to keep <span class="eq">μ=NP</span> constant.</li>
        <li><strong>Q:</strong> In the continuous mapping, what does <span class="eq">α</span> represent physically? <strong>A:</strong> Ionization probability per unit length (for electrons), so <span class="eq">αdx</span> is the small probability of ionization in a slice <span class="eq">dx</span>.</li>
        <li><strong>Q:</strong> Does <span class="eq">⟨G⟩</span> alone tell you noise? <strong>A:</strong> No—noise depends on higher moments (e.g., excess noise factor), not just the mean.</li>
      </ul>
    </section>

    <hr class="sep" />

    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="controls" aria-label="Interactive controls">
        <div class="ctrl">
          <label for="pSlider">Per-stage probability <span class="eq">P</span> <span class="val" id="pVal">0.10</span></label>
          <input id="pSlider" type="range" min="0" max="0.6" step="0.005" value="0.10" />
          <div class="hint">Meaning: chance that an electron creates <em>one</em> extra electron in a given stage.</div>
        </div>
        <div class="ctrl">
          <label for="nSlider">Number of stages <span class="eq">N</span> <span class="val" id="nVal">20</span></label>
          <input id="nSlider" type="range" min="1" max="120" step="1" value="20" />
          <div class="hint">Meaning: how many discrete multiplication opportunities exist.</div>
        </div>
      </div>

      <div class="kpiRow" aria-label="Computed results">
        <div class="kpi">
          <div class="k">Discrete staircase mean gain</div>
          <div class="v" id="kpiG">(1+P)^N = 6.7275</div>
        </div>
        <div class="kpi">
          <div class="k">Continuous-limit approximation</div>
          <div class="v" id="kpiExp">exp(NP) = 7.3891</div>
        </div>
        <div class="kpi">
          <div class="k">Relative difference</div>
          <div class="v" id="kpiErr">|G − exp(NP)| / exp(NP) = 8.95% <small>(example)</small></div>
        </div>
      </div>

      <figure class="canvasTall">
        <canvas id="diagramCanvas" aria-label="Staircase APD diagram"></canvas>
        <figcaption>
          <strong>Diagram:</strong> A stylized staircase APD with <span class="eq">N</span> discrete stages.
          Each stage gives an electron a Bernoulli chance <span class="eq">P</span> to create one extra electron (branching).
          This is the physical meaning behind the factor <span class="eq">1+P</span> per stage in the mean.
        </figcaption>
      </figure>

      <figure>
        <canvas id="plotCanvas1" aria-label="Main plot: mean gain versus stage index"></canvas>
        <figcaption>
          <strong>Main plot:</strong> Mean electron count after stage <span class="eq">k</span>.
          The staircase model gives <span class="eq">⟨X_k⟩=(1+P)^k</span> (solid curve).
          The continuous-limit curve <span class="eq">e^{Pk}</span> (dashed) shows how the discrete compounding approaches an exponential for small <span class="eq">P</span>.
        </figcaption>
      </figure>

      <figure>
        <canvas id="plotCanvas2" aria-label="Secondary plot: relative error between discrete and continuous models versus P"></canvas>
        <figcaption>
          <strong>Secondary plot:</strong> For the currently selected <span class="eq">N</span>, this shows the relative difference
          <span class="eq">|(1+P)^N − e^{NP}| / e^{NP}</span> as a function of <span class="eq">P</span>.
          The highlighted point marks your current <span class="eq">P</span>.
        </figcaption>
      </figure>

      <div class="callout keyeq">
        <div class="title"><span class="badge">How the controls affect the canvases</span></div>
        <ul>
          <li>Changing <span class="eq">P</span> shifts both gain curves upward and typically increases the discrete-vs-continuous mismatch.</li>
          <li>Changing <span class="eq">N</span> increases the total compounding; you’ll see the final gain and the error-vs-<span class="eq">P</span> curve change immediately.</li>
          <li>All three canvases (diagram + both plots) update live so the symbols match the derivation.</li>
        </ul>
      </div>
    </section>
  </article>
</main>

<footer>
  <p>
    Notes: The plotted numbers are <em>example values</em> chosen by the sliders (the problem statement is symbolic).
    The derivation itself is general and does not depend on any particular numerical choice.
  </p>
</footer>

<script>
/* =========================
   Utility: Copy buttons
========================= */
(function(){
  function getTextFromTarget(id){
    const el = document.getElementById(id);
    if(!el) return "";
    return el.textContent.replace(/\s+/g,' ').trim();
  }
  async function copyText(text){
    try{
      await navigator.clipboard.writeText(text);
      return true;
    }catch(e){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.style.position="fixed";
      ta.style.opacity="0";
      document.body.appendChild(ta);
      ta.select();
      let ok=false;
      try{ ok = document.execCommand("copy"); }catch(_){ ok=false; }
      document.body.removeChild(ta);
      return ok;
    }
  }
  function setStatus(msg){
    const a = document.getElementById("copyStatusTop");
    const b = document.getElementById("copyStatusFinal");
    if(a) a.textContent = msg;
    if(b) b.textContent = msg;
    clearTimeout(setStatus._t);
    setStatus._t = setTimeout(()=>{ if(a) a.textContent=""; if(b) b.textContent=""; }, 1400);
  }
  document.addEventListener("click", async (ev)=>{
    const btn = ev.target.closest(".copyBtn");
    if(!btn) return;
    const target = btn.getAttribute("data-copy-target");
    if(!target) return;
    const text = getTextFromTarget(target);
    const ok = await copyText(text);
    setStatus(ok ? "Copied." : "Copy failed (browser blocked clipboard).");
  });
})();

/* =========================
   Canvas helpers
========================= */
function setupHiDPICanvas(canvas){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(1, Math.floor(rect.width));
  const h = Math.max(1, Math.floor(rect.height));
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  const ctx = canvas.getContext("2d");
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return {ctx, w, h, dpr};
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function niceTicks(min,max,approxCount){
  const span = max - min;
  if(span <= 0) return {step:1, start:min, end:max};
  const raw = span / approxCount;
  const pow10 = Math.pow(10, Math.floor(Math.log10(raw)));
  const candidates = [1,2,5,10].map(m=>m*pow10);
  let step = candidates[0];
  for(const c of candidates){ if(Math.abs(c-raw) < Math.abs(step-raw)) step=c; }
  const start = Math.floor(min/step)*step;
  const end = Math.ceil(max/step)*step;
  return {step, start, end};
}
function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
  const {x, y, w, h, padL, padR, padT, padB} = box;
  // background
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0)";
  ctx.fillRect(x,y,w,h);
  ctx.restore();

  // title
  ctx.save();
  ctx.fillStyle = "rgba(233,238,247,0.92)";
  ctx.font = "700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillText(title, x + padL, y + 8);
  ctx.restore();

  const plotX = x + padL, plotY = y + padT, plotW = w - padL - padR, plotH = h - padT - padB;

  // grid + ticks
  const xt = niceTicks(xMin, xMax, 6);
  const yt = niceTicks(yMin, yMax, 6);

  ctx.save();
  ctx.lineWidth = 1;
  // grid
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  for(let xv = xt.start; xv <= xt.end + 1e-12; xv += xt.step){
    const px = plotX + (xv - xMin) / (xMax - xMin) * plotW;
    ctx.beginPath();
    ctx.moveTo(px, plotY);
    ctx.lineTo(px, plotY + plotH);
    ctx.stroke();
  }
  for(let yv = yt.start; yv <= yt.end + 1e-12; yv += yt.step){
    const py = plotY + plotH - (yv - yMin) / (yMax - yMin) * plotH;
    ctx.beginPath();
    ctx.moveTo(plotX, py);
    ctx.lineTo(plotX + plotW, py);
    ctx.stroke();
  }
  ctx.restore();

  // axes border
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.22)";
  ctx.lineWidth = 1;
  ctx.strokeRect(plotX, plotY, plotW, plotH);
  ctx.restore();

  // tick labels
  ctx.save();
  ctx.fillStyle = "rgba(168,179,199,0.95)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  for(let xv = xt.start; xv <= xt.end + 1e-12; xv += xt.step){
    const px = plotX + (xv - xMin) / (xMax - xMin) * plotW;
    ctx.fillText(formatTick(xv), px, plotY + plotH + 6);
    // small tick
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.beginPath();
    ctx.moveTo(px, plotY + plotH);
    ctx.lineTo(px, plotY + plotH + 4);
    ctx.stroke();
  }
  ctx.textAlign = "right";
  ctx.textBaseline = "middle";
  for(let yv = yt.start; yv <= yt.end + 1e-12; yv += yt.step){
    const py = plotY + plotH - (yv - yMin) / (yMax - yMin) * plotH;
    ctx.fillText(formatTick(yv), plotX - 8, py);
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.beginPath();
    ctx.moveTo(plotX, py);
    ctx.lineTo(plotX - 4, py);
    ctx.stroke();
  }
  ctx.restore();

  // axis labels
  ctx.save();
  ctx.fillStyle = "rgba(233,238,247,0.85)";
  ctx.font = "650 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText(xLabel, plotX + plotW/2, y + h - 6);
  ctx.translate(x + 12, plotY + plotH/2);
  ctx.rotate(-Math.PI/2);
  ctx.textBaseline = "top";
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  return {plotX, plotY, plotW, plotH};
}
function formatTick(v){
  // compact formatting
  const av = Math.abs(v);
  if(av >= 1000) return v.toFixed(0);
  if(av >= 100) return v.toFixed(0);
  if(av >= 10) return v.toFixed(1);
  if(av >= 1) return v.toFixed(2);
  if(av >= 0.01) return v.toFixed(3);
  return v.toExponential(1);
}
function mapX(xv, xMin, xMax, plotX, plotW){ return plotX + (xv - xMin)/(xMax - xMin)*plotW; }
function mapY(yv, yMin, yMax, plotY, plotH){ return plotY + plotH - (yv - yMin)/(yMax - yMin)*plotH; }

/* =========================
   Model + Rendering
========================= */
const state = {
  P: 0.10,
  N: 20
};

const els = {
  pSlider: document.getElementById("pSlider"),
  nSlider: document.getElementById("nSlider"),
  pVal: document.getElementById("pVal"),
  nVal: document.getElementById("nVal"),
  kpiG: document.getElementById("kpiG"),
  kpiExp: document.getElementById("kpiExp"),
  kpiErr: document.getElementById("kpiErr"),
  diagram: document.getElementById("diagramCanvas"),
  plot1: document.getElementById("plotCanvas1"),
  plot2: document.getElementById("plotCanvas2")
};

function gainDiscrete(P,N){ return Math.pow(1+P, N); }
function gainCont(P,N){ return Math.exp(P*N); }
function relErr(P,N){
  const gd = gainDiscrete(P,N);
  const ge = gainCont(P,N);
  return Math.abs(gd-ge)/ge;
}

function updateKPIs(){
  const P = state.P, N = state.N;
  const gd = gainDiscrete(P,N);
  const ge = gainCont(P,N);
  const e = relErr(P,N);
  els.kpiG.textContent = `(1+P)^N = ${gd.toFixed(4)}`;
  els.kpiExp.textContent = `exp(NP) = ${ge.toFixed(4)}`;
  els.kpiErr.textContent = `|G − exp(NP)| / exp(NP) = ${(100*e).toFixed(2)}% (example)`;
}

function drawDiagram(){
  const {ctx, w, h} = setupHiDPICanvas(els.diagram);
  ctx.clearRect(0,0,w,h);

  // background vignette
  const grad = ctx.createLinearGradient(0,0,0,h);
  grad.addColorStop(0, "rgba(125,211,252,0.08)");
  grad.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,w,h);

  const P = state.P, N = state.N;

  const margin = 22;
  const left = margin, right = w - margin, top = 26, bottom = h - 54;
  const width = right - left;
  const height = bottom - top;

  // Draw staircase (conduction band steps)
  const steps = Math.min(N, 14); // draw up to 14 for clarity
  const dx = width / (steps + 2);
  const dy = height / (steps + 2);
  let x = left + dx*0.8;
  let y = top + dy*0.8;

  ctx.save();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(233,238,247,0.80)";
  ctx.beginPath();
  ctx.moveTo(x, y);
  for(let i=0;i<steps;i++){
    // horizontal
    x += dx;
    ctx.lineTo(x, y);
    // step down
    y += dy;
    ctx.lineTo(x, y);
  }
  // last run
  x += dx*0.8;
  ctx.lineTo(x, y);
  ctx.stroke();
  ctx.restore();

  // Labels "stages"
  ctx.save();
  ctx.fillStyle = "rgba(168,179,199,0.95)";
  ctx.font = "12px ui-monospace, Menlo, Consolas, monospace";
  ctx.textAlign="left";
  ctx.textBaseline="top";
  ctx.fillText(`Staircase stages (schematic): showing ${steps} of N=${N}`, left, 8);
  ctx.restore();

  // Electron trajectory arrow
  ctx.save();
  ctx.strokeStyle = "rgba(125,211,252,0.95)";
  ctx.lineWidth = 2;
  ctx.setLineDash([6,5]);
  ctx.beginPath();
  ctx.moveTo(left + dx*0.7, top + dy*0.9);
  ctx.lineTo(right - dx*0.6, bottom - dy*0.2);
  ctx.stroke();
  ctx.setLineDash([]);
  // arrow head
  const ax = right - dx*0.6, ay = bottom - dy*0.2;
  ctx.fillStyle = "rgba(125,211,252,0.95)";
  ctx.beginPath();
  ctx.moveTo(ax, ay);
  ctx.lineTo(ax-10, ay-4);
  ctx.lineTo(ax-6, ay-12);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // Branching icon at a representative stage
  const bx = left + dx*3.2;
  const by = top + dy*3.6;

  ctx.save();
  ctx.strokeStyle = "rgba(167,139,250,0.95)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(bx, by);
  ctx.lineTo(bx+36, by+16);
  ctx.moveTo(bx, by);
  ctx.lineTo(bx+36, by-16);
  ctx.stroke();

  ctx.fillStyle = "rgba(167,139,250,0.95)";
  ctx.beginPath();
  ctx.arc(bx, by, 4, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // Annotate P, (1+P) factor
  ctx.save();
  ctx.fillStyle = "rgba(233,238,247,0.92)";
  ctx.font = "650 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillText(`Per-stage Bernoulli event:`, left, h - 46);

  ctx.fillStyle = "rgba(168,179,199,0.95)";
  ctx.font = "12px ui-monospace, Menlo, Consolas, monospace";
  const ptxt = `P = ${P.toFixed(3)}  →  E[m] = 1·(1−P) + 2·P = 1+P`;
  ctx.fillText(ptxt, left, h - 28);
  ctx.restore();

  // Add little stage markers
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.20)";
  ctx.lineWidth = 1;
  let mx = left + dx*0.8, my = top + dy*0.8;
  for(let i=0;i<steps;i++){
    const tx = mx + dx*0.5;
    const ty = my + dy*0.5;
    ctx.beginPath();
    ctx.arc(tx, ty, 2.2, 0, Math.PI*2);
    ctx.stroke();
    mx += dx; my += dy;
  }
  ctx.restore();
}

function drawMainPlot(){
  const {ctx, w, h} = setupHiDPICanvas(els.plot1);
  ctx.clearRect(0,0,w,h);

  const P = state.P, N = state.N;
  const xMin = 0, xMax = N;
  const yMaxCandidate = Math.max(gainDiscrete(P,N), gainCont(P,N));
  const yMin = 0;
  const yMax = yMaxCandidate * 1.10 + 0.05;

  const box = {x:0,y:0,w,h,padL:62,padR:18,padT:36,padB:46};
  const {plotX, plotY, plotW, plotH} = drawAxes(
    ctx, box, xMin, xMax, yMin, yMax,
    "Stage index k (unitless)",
    "Mean electron count ⟨Xk⟩ (unitless)",
    "Mean gain accumulation across stages"
  );

  // Plot discrete curve (1+P)^k
  ctx.save();
  ctx.lineWidth = 2.25;
  ctx.strokeStyle = "rgba(125,211,252,0.95)";
  ctx.beginPath();
  for(let k=0;k<=N;k++){
    const yv = Math.pow(1+P, k);
    const px = mapX(k, xMin, xMax, plotX, plotW);
    const py = mapY(yv, yMin, yMax, plotY, plotH);
    if(k===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.stroke();
  ctx.restore();

  // Plot continuous approximation exp(Pk)
  ctx.save();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(167,139,250,0.95)";
  ctx.setLineDash([7,5]);
  ctx.beginPath();
  const samples = Math.max(60, N*3);
  for(let i=0;i<=samples;i++){
    const k = xMin + (xMax-xMin)*i/samples;
    const yv = Math.exp(P*k);
    const px = mapX(k, xMin, xMax, plotX, plotW);
    const py = mapY(yv, yMin, yMax, plotY, plotH);
    if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();

  // Mark final point
  const gd = gainDiscrete(P,N);
  const ge = gainCont(P,N);
  const pxF = mapX(N, xMin, xMax, plotX, plotW);

  ctx.save();
  // discrete point
  ctx.fillStyle = "rgba(125,211,252,0.95)";
  ctx.beginPath();
  ctx.arc(pxF, mapY(gd, yMin, yMax, plotY, plotH), 4.2, 0, Math.PI*2);
  ctx.fill();
  // continuous point
  ctx.fillStyle = "rgba(167,139,250,0.95)";
  ctx.beginPath();
  ctx.arc(pxF, mapY(ge, yMin, yMax, plotY, plotH), 4.2, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // Legend
  ctx.save();
  const lx = plotX + 12, ly = plotY + 12;
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.strokeStyle = "rgba(255,255,255,0.16)";
  ctx.lineWidth = 1;
  roundRect(ctx, lx, ly, 260, 54, 12);
  ctx.fill();
  ctx.stroke();

  ctx.font = "12px ui-monospace, Menlo, Consolas, monospace";
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";

  // line swatches
  ctx.strokeStyle = "rgba(125,211,252,0.95)";
  ctx.lineWidth = 2.2;
  ctx.beginPath(); ctx.moveTo(lx+12, ly+18); ctx.lineTo(lx+52, ly+18); ctx.stroke();
  ctx.fillStyle = "rgba(168,179,199,0.95)";
  ctx.fillText("Discrete: ⟨Xk⟩ = (1+P)^k", lx+60, ly+18);

  ctx.strokeStyle = "rgba(167,139,250,0.95)";
  ctx.setLineDash([7,5]);
  ctx.beginPath(); ctx.moveTo(lx+12, ly+38); ctx.lineTo(lx+52, ly+38); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = "rgba(168,179,199,0.95)";
  ctx.fillText("Continuous limit: exp(Pk)", lx+60, ly+38);

  ctx.restore();
}

function drawErrorPlot(){
  const {ctx, w, h} = setupHiDPICanvas(els.plot2);
  ctx.clearRect(0,0,w,h);

  const N = state.N;
  const pMin = 0.0, pMax = 0.6;

  // compute error curve
  const samples = 240;
  let yMax = 0;
  const ys = new Array(samples+1);
  for(let i=0;i<=samples;i++){
    const P = pMin + (pMax-pMin)*i/samples;
    const e = relErr(P, N);
    ys[i]=e;
    if(e>yMax) yMax=e;
  }
  yMax = Math.max(0.02, yMax*1.10);

  const box = {x:0,y:0,w,h,padL:62,padR:18,padT:36,padB:46};
  const {plotX, plotY, plotW, plotH} = drawAxes(
    ctx, box, pMin, pMax, 0, yMax,
    "Per-stage probability P (unitless)",
    "Relative diff  |(1+P)^N − exp(NP)| / exp(NP) (unitless)",
    "Discrete vs. continuous mismatch (for current N)"
  );

  // curve
  ctx.save();
  ctx.lineWidth = 2.25;
  ctx.strokeStyle = "rgba(251,191,36,0.92)";
  ctx.beginPath();
  for(let i=0;i<=samples;i++){
    const P = pMin + (pMax-pMin)*i/samples;
    const e = ys[i];
    const px = mapX(P, pMin, pMax, plotX, plotW);
    const py = mapY(e, 0, yMax, plotY, plotH);
    if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.stroke();
  ctx.restore();

  // highlight current P
  const P0 = state.P;
  const e0 = relErr(P0, N);
  const px0 = mapX(P0, pMin, pMax, plotX, plotW);
  const py0 = mapY(e0, 0, yMax, plotY, plotH);

  ctx.save();
  ctx.fillStyle = "rgba(125,211,252,0.95)";
  ctx.beginPath();
  ctx.arc(px0, py0, 5.2, 0, Math.PI*2);
  ctx.fill();

  // label box
  const label = `P=${P0.toFixed(3)}, err=${(100*e0).toFixed(2)}%`;
  ctx.font = "12px ui-monospace, Menlo, Consolas, monospace";
  const tw = ctx.measureText(label).width;
  const bx = clamp(px0 + 10, plotX + 6, plotX + plotW - (tw + 22));
  const by = clamp(py0 - 28, plotY + 6, plotY + plotH - 26);

  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.strokeStyle = "rgba(255,255,255,0.16)";
  roundRect(ctx, bx, by, tw + 16, 22, 10);
  ctx.fill(); ctx.stroke();
  ctx.fillStyle = "rgba(233,238,247,0.90)";
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";
  ctx.fillText(label, bx + 8, by + 11);
  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

function renderAll(){
  updateKPIs();
  drawDiagram();
  drawMainPlot();
  drawErrorPlot();
}

function syncUI(){
  els.pVal.textContent = Number(state.P).toFixed(3);
  els.nVal.textContent = String(state.N);
}

function onChange(){
  syncUI();
  renderAll();
}

els.pSlider.addEventListener("input", ()=>{
  state.P = Number(els.pSlider.value);
  onChange();
});
els.nSlider.addEventListener("input", ()=>{
  state.N = Number(els.nSlider.value);
  onChange();
});

window.addEventListener("resize", ()=>{
  // re-render to adapt to new canvas sizes
  renderAll();
}, {passive:true});

// initial
syncUI();
renderAll();
</script>
</body>
</html>
