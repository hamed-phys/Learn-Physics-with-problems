<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Optimal APD Gain in an Analog Optical Receiver (with Excess Noise)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1733;
      --card:#101b3f;
      --text:#e9ecff;
      --muted:#b8c0ff;
      --faint:#8f98d6;
      --line:rgba(255,255,255,.12);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --ok:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius:18px;
      --radius2:26px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 20% -10%, rgba(125,211,252,.22), transparent 60%),
        radial-gradient(1000px 650px at 110% 20%, rgba(167,139,250,.18), transparent 55%),
        radial-gradient(900px 600px at 40% 120%, rgba(52,211,153,.12), transparent 60%),
        linear-gradient(180deg, var(--bg), #070a14 70%, #06070f);
      line-height:1.55;
    }

    header{
      padding:48px 20px 18px;
      max-width:1200px;
      margin:0 auto;
      display:grid;
      gap:14px;
    }
    .kicker{
      display:inline-flex;
      gap:10px;
      align-items:center;
      color:var(--muted);
      font-weight:650;
      letter-spacing:.02em;
      font-size:14px;
      opacity:.95;
    }
    .pill{
      display:inline-flex;
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      background:rgba(255,255,255,.04);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
    }
    h1{
      margin:0;
      font-size: clamp(28px, 3.2vw, 44px);
      line-height:1.15;
      letter-spacing:-.02em;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size: clamp(15px, 1.6vw, 18px);
      max-width: 78ch;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding: 18px 20px 70px;
      display:grid;
      grid-template-columns: 330px 1fr;
      gap:18px;
      align-items:start;
    }

    nav#toc{
      position:sticky;
      top:14px;
      align-self:start;
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    #toc .toc-head{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    #toc .toc-head strong{font-size:14px; letter-spacing:.02em;}
    #toc .toc-body{
      padding:10px 10px 14px;
    }
    #toc a{
      display:block;
      padding:9px 10px;
      border-radius:12px;
      color:var(--text);
      text-decoration:none;
      font-size:14px;
      border:1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
    }
    #toc a:hover{
      background:rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.22);
      transform: translateX(2px);
    }
    #toc .mini{
      color:var(--faint);
      font-size:12px;
      margin-top:8px;
      padding: 0 10px;
    }

    article{
      display:grid;
      gap:16px;
    }

    section{
      border:1px solid var(--line);
      border-radius: var(--radius2);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    section .sec-inner{
      padding: 18px 18px 20px;
    }
    section h2{
      margin:0 0 8px;
      font-size: clamp(18px, 2.1vw, 26px);
      letter-spacing:-.01em;
    }
    section h3{
      margin:16px 0 8px;
      font-size: 18px;
      letter-spacing:-.01em;
      color: #f1f3ff;
    }
    p{margin:8px 0 0; color: var(--text);}
    ul{margin:10px 0 0; padding-left: 20px;}
    li{margin:6px 0; color: var(--text);}
    .muted{color:var(--muted)}
    .fine{color:var(--faint); font-size: 13px;}

    .grid2{
      display:grid;
      gap:12px;
      grid-template-columns: 1fr 1fr;
    }
    .grid3{
      display:grid;
      gap:12px;
      grid-template-columns: 1fr 1fr 1fr;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr; }
      nav#toc{position:relative; top:0}
    }
    @media (max-width: 740px){
      .grid2,.grid3{grid-template-columns: 1fr;}
    }

    .callout{
      border:1px solid var(--line);
      border-radius: 16px;
      background: rgba(0,0,0,.22);
      padding: 12px 12px 12px;
      position:relative;
      overflow:hidden;
    }
    .callout::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(600px 200px at 20% 10%, rgba(125,211,252,.20), transparent 60%),
                  radial-gradient(480px 220px at 100% 80%, rgba(167,139,250,.16), transparent 55%);
      opacity:.9;
      pointer-events:none;
      filter: blur(0px);
    }
    .callout > *{position:relative}
    .tag{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      font-size: 12px;
      letter-spacing:.02em;
      color: var(--muted);
      font-weight: 650;
      margin-bottom: 6px;
    }
    .tag .dot{
      width:8px;height:8px;border-radius:999px;background:var(--accent);
      box-shadow: 0 0 0 3px rgba(125,211,252,.18);
    }

    .eqbox{
      border:1px solid rgba(125,211,252,.28);
      background: rgba(125,211,252,.08);
      border-radius: 16px;
      padding: 12px;
      margin-top: 10px;
      position:relative;
    }
    .eqbox .row{
      display:flex; gap:10px; align-items:flex-start; justify-content:space-between;
    }
    .eq{
      font-family: var(--mono);
      font-size: 14px;
      white-space: pre-wrap;
      margin:0;
      color:#f3f6ff;
    }
    .copyBtn{
      appearance:none;
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      color: var(--text);
      padding:8px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 650;
      font-size: 12px;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      flex:0 0 auto;
    }
    .copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.28);
    }
    .copyBtn:active{transform: translateY(0px) scale(.99);}
    .copyToast{
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 12px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.55);
      color: var(--text);
      font-size: 13px;
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: opacity .2s ease, transform .2s ease;
      z-index: 9999;
    }
    .copyToast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-2px);
    }

    .controls{
      display:grid;
      gap:10px;
      border:1px solid var(--line);
      border-radius: 18px;
      padding: 12px;
      background: rgba(0,0,0,.18);
      margin-top: 10px;
    }
    .controlRow{
      display:grid;
      grid-template-columns: 140px 1fr 80px;
      gap:10px;
      align-items:center;
    }
    .controlRow label{
      font-size: 13px;
      color: var(--muted);
      font-weight: 650;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    select{
      width:100%;
      padding:8px 10px;
      border-radius: 12px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      color: var(--text);
      font-weight: 650;
    }
    .val{
      font-family: var(--mono);
      font-size: 13px;
      color: #f3f6ff;
      text-align:right;
    }

    figure{
      margin: 10px 0 0;
      border: 1px solid var(--line);
      border-radius: 18px;
      background: rgba(0,0,0,.18);
      overflow:hidden;
    }
    figure figcaption{
      padding: 10px 12px;
      border-top: 1px solid var(--line);
      color: var(--muted);
      font-size: 13px;
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    }
    .canvasTall{height: 360px;}
    .canvasShort{height: 300px;}

    .answer{
      border:1px solid rgba(52,211,153,.30);
      background: rgba(52,211,153,.08);
      border-radius: 18px;
      padding: 12px;
      margin-top: 10px;
    }
    .answer strong{color:#dcffe9}
    .boxTitle{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      margin-bottom: 6px;
    }
    .boxTitle span{
      display:inline-flex; gap:8px; align-items:center;
      font-weight: 800; letter-spacing:.02em; font-size: 12px; color:#dcffe9;
      text-transform: uppercase;
    }
    .badge{
      width:9px; height:9px; border-radius: 999px; background: var(--ok);
      box-shadow: 0 0 0 4px rgba(52,211,153,.16);
    }

    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 22px 20px 46px;
      color: var(--faint);
      font-size: 13px;
    }

    /* Subtle section reveal */
    section{
      transform: translateY(4px);
      opacity: .98;
      animation: rise .35s ease both;
    }
    @keyframes rise{
      from{transform: translateY(10px); opacity:.0}
      to{transform: translateY(0px); opacity:1}
    }

    /* Print friendly */
    @media print{
      body{background:#fff;color:#000}
      header, main, footer{max-width: 100%; padding: 0}
      nav#toc{display:none}
      section{box-shadow:none; border:1px solid #bbb; background:#fff}
      .callout, figure, .controls, .eqbox, .answer{background:#fff}
      .copyBtn{display:none}
      canvas{height: 260px}
    }
  </style>
</head>
<body>
<header>
  <div class="kicker">
    <span class="pill">Photonics • Detectors • Noise</span>
    <span class="pill">APD Optimization</span>
  </div>
  <h1>Optimal Gain for an APD in an Analog Receiver</h1>
  <p class="subtitle">
    We find the avalanche photodiode (APD) mean multiplication gain that maximizes analog receiver SNR when both
    circuit noise and shot noise matter—and we quantify the SNR improvement over a p-i-n photodiode.
  </p>
</header>

<main>
  <nav id="toc" aria-label="Table of contents">
    <div class="toc-head">
      <strong>Mini Table of Contents</strong>
      <span class="pill" style="font-size:12px;color:var(--muted)">sticky</span>
    </div>
    <div class="toc-body">
      <a href="#quick">Quick Summary</a>
      <a href="#part0">PART 0 — Concept Primer</a>
      <a href="#part1">PART 1 — Problem Analysis</a>
      <a href="#part2">PART 2 — Strategy & Tips</a>
      <a href="#part3">PART 3 — Full Solution</a>
      <a href="#part4">PART 4 — Deeper Understanding</a>
      <a href="#part5">PART 5 — Visualization Guide</a>
      <div class="mini">Tip: Use the sliders in the Visualization section to explore how the optimum shifts with parameters.</div>
    </div>
  </nav>

  <article>
    <!-- Quick Summary -->
    <section id="quick">
      <div class="sec-inner">
        <h2>Quick Summary</h2>
        <ul>
          <li><strong>What this is about:</strong> Choosing APD mean gain <span class="eq">M</span> to maximize analog receiver SNR when circuit noise competes with shot noise.</li>
          <li><strong>Key idea:</strong> APD gain boosts signal as <span class="eq">∝ M</span> but increases shot noise faster via <em>excess noise factor</em> <span class="eq">F(M)</span>.</li>
          <li><strong>Given:</strong> Circuit-noise variance is <span class="eq">R = σ_c^2/σ_p^2 = 100</span> (relative to p-i-n photoelectron/shot-noise variance). Ionization ratio <span class="eq">k = 0.2</span>.</li>
          <li><strong>Governing model (McIntyre):</strong> <span class="eq">F(M)=kM+(1-k)(2-1/M)</span>.</li>
          <li><strong>SNR improvement factor:</strong> <span class="eq">G(M)=SNR_APD/SNR_PIN = (1+R) M^2 / (M^2 F(M)+R)</span>.</li>
          <li><strong>Optimality condition:</strong> Maximization yields a compact cubic:
            <span class="eq">k M^3 + (1-k) M - 2R = 0</span> (for <span class="eq">M ≥ 1</span>).
          </li>
          <li><strong>Numeric result:</strong> For <span class="eq">R=100</span>, <span class="eq">k=0.2</span>, the optimum is
            <span class="eq">M_opt ≈ 9.86</span>, giving <span class="eq">G_opt ≈ 22.35</span> (≈ <span class="eq">13.49 dB</span>) SNR improvement.</li>
        </ul>

        <div class="eqbox">
          <div class="row">
            <pre class="eq" id="eq_key1">F(M)=kM+(1-k)(2-1/M)
G(M)=(1+R) M^2/(M^2 F(M)+R)
Optimal: k M^3+(1-k)M-2R=0</pre>
            <button class="copyBtn" data-copy="#eq_key1">Copy key equations</button>
          </div>
        </div>
      </div>
    </section>

    <!-- PART 0 -->
    <section id="part0">
      <div class="sec-inner">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <div class="grid2">
          <div class="callout">
            <div class="tag"><span class="dot"></span>Core definitions</div>
            <ul>
              <li><strong>Mean APD gain</strong> <span class="eq">M</span> (dimensionless): average multiplication of primary photocurrent by avalanche impact ionization.</li>
              <li><strong>Ionization ratio</strong> <span class="eq">k</span> (dimensionless): ratio of hole-to-electron ionization coefficients (conventionally <span class="eq">k = β/α</span>). Smaller <span class="eq">k</span> usually means <em>less excess noise</em> for electron-initiated multiplication.</li>
              <li><strong>Excess noise factor</strong> <span class="eq">F(M)</span> (dimensionless): quantifies how multiplication randomness increases current noise beyond a noiseless gain.</li>
              <li><strong>Noise variances</strong>:
                <span class="eq">σ_p^2</span> = photoelectron/shot-noise variance (p-i-n baseline),
                <span class="eq">σ_c^2</span> = circuit (electronics) noise variance.
              </li>
              <li><strong>Ratio</strong> <span class="eq">R = σ_c^2/σ_p^2</span> (dimensionless): tells whether you are circuit-noise-limited (<span class="eq">R≫1</span>) or shot-noise-limited (<span class="eq">R≪1</span>).</li>
            </ul>
          </div>

          <div class="callout">
            <div class="tag"><span class="dot"></span>Physical meaning</div>
            <p>
              In an <strong>analog</strong> optical receiver, the detected signal is a current (or voltage) proportional to optical power.
              Noise comes from two major sources:
            </p>
            <ul>
              <li><strong>Shot noise</strong>: due to the discrete arrival of photoelectrons (Poisson statistics). Even a perfect detector has this.</li>
              <li><strong>Circuit noise</strong>: from the amplifier and resistor thermal noise, etc. This does <em>not</em> get multiplied by APD gain.</li>
            </ul>
            <p>
              An APD helps primarily when circuit noise dominates, because multiplying the photocurrent boosts signal above the electronics noise floor.
              But at high gain the avalanche process becomes very noisy (large <span class="eq">F(M)</span>), eroding SNR.
            </p>
          </div>
        </div>

        <h3>Key laws/principles and validity</h3>
        <ul>
          <li><strong>Poisson/shot noise model:</strong> photoelectron count fluctuations scale with mean count. In current form, shot-noise variance scales with mean current (and bandwidth). We compress details into <span class="eq">σ_p^2</span> for the p-i-n case.</li>
          <li><strong>McIntyre excess noise factor:</strong> for conventional APDs (uniform field, local ionization), a widely used model is
            <span class="eq">F(M)=kM+(1-k)(2-1/M)</span>.
            It captures that higher <span class="eq">M</span> means more stochastic multiplication.
          </li>
          <li><strong>Independent noise sources:</strong> circuit noise and multiplication-modified shot noise add in variance (uncorrelated assumption).</li>
        </ul>

        <h3>Common models/approximations (and why)</h3>
        <div class="grid2">
          <div class="callout">
            <div class="tag"><span class="dot"></span>Why we use variance ratios</div>
            <p>
              The problem gives a single ratio <span class="eq">R=σ_c^2/σ_p^2</span>. That lets us optimize SNR <em>without needing</em> optical power,
              responsivity, bandwidth, or exact amplifier model—because those details cancel in the SNR ratio.
            </p>
          </div>
          <div class="callout">
            <div class="tag"><span class="dot"></span>When APDs help</div>
            <p>
              If circuit noise is huge (<span class="eq">R≫1</span>), some APD gain can dramatically improve SNR.
              If shot noise dominates (<span class="eq">R≪1</span>), APD gain usually <em>does not</em> help much because it amplifies shot noise too.
            </p>
          </div>
        </div>

        <h3>Mini intuition examples</h3>
        <ul>
          <li><strong>Example A (circuit-noise-limited):</strong> If <span class="eq">R=100</span>, multiplying signal by <span class="eq">M≈10</span> can lift signal above electronics noise—until excess noise becomes too large.</li>
          <li><strong>Example B (shot-noise-limited):</strong> If <span class="eq">R=0</span>, then <span class="eq">SNR(M)∝ M^2/(M^2F)=1/F</span>, which decreases with increasing <span class="eq">M</span>. Best is <span class="eq">M=1</span>.</li>
        </ul>

        <div class="callout" style="margin-top:12px;">
          <div class="tag"><span class="dot"></span>What to watch for (pitfalls)</div>
          <ul>
            <li>Mixing “gain improves SNR” with the fact that APD multiplication <em>also</em> increases noise via <span class="eq">F(M)</span>.</li>
            <li>Forgetting that circuit noise is <em>not</em> multiplied by <span class="eq">M</span>.</li>
            <li>Using the wrong form of <span class="eq">F(M)</span> (it depends on convention and injection type). Here we use the common McIntyre form given above.</li>
            <li>Maximizing SNR directly vs. maximizing SNR improvement (they differ only by a constant here, so it’s safe).</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- PART 1 -->
    <section id="part1">
      <div class="sec-inner">
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

        <h3>Problem restatement (in plain words)</h3>
        <p>
          An analog optical receiver using a p-i-n photodiode has circuit-noise variance that is 100× larger than the p-i-n photoelectron (shot) noise variance.
          If we replace the p-i-n diode with a conventional APD whose ionization ratio is <span class="eq">k=0.2</span>, find the APD mean gain <span class="eq">M</span> that maximizes SNR, and the resulting SNR improvement relative to the p-i-n case.
        </p>

        <div class="grid2">
          <div class="callout">
            <div class="tag"><span class="dot"></span>Given</div>
            <ul>
              <li><span class="eq">R = σ_c^2/σ_p^2 = 100</span></li>
              <li><span class="eq">k = 0.2</span></li>
              <li>Use conventional APD excess noise model <span class="eq">F(M)</span></li>
            </ul>
          </div>
          <div class="callout">
            <div class="tag"><span class="dot"></span>Unknowns</div>
            <ul>
              <li>Optimal mean gain: <span class="eq">M_opt</span></li>
              <li>SNR improvement: <span class="eq">G_opt = SNR_APD/SNR_PIN</span> (linear) and optionally in dB</li>
            </ul>
          </div>
        </div>

        <h3>Relevant principles (and why they apply)</h3>
        <ul>
          <li><strong>Analog receiver SNR:</strong> SNR is signal-power (mean-squared signal) divided by total noise variance at the decision/measurement point.</li>
          <li><strong>APD multiplication:</strong> multiplies mean photocurrent by <span class="eq">M</span>.</li>
          <li><strong>Excess noise:</strong> shot-noise-related variance is multiplied by <span class="eq">M^2F(M)</span> (extra randomness beyond deterministic gain).</li>
          <li><strong>Noise addition:</strong> circuit noise remains <span class="eq">σ_c^2</span> and adds in variance.</li>
        </ul>
        <p class="muted">
          We do <em>not</em> need to model bandwidth, responsivity, or optical power explicitly because the given ratio <span class="eq">R</span> lets us work with normalized quantities.
        </p>

        <div class="callout">
          <div class="tag"><span class="dot"></span>Assumptions</div>
          <ul>
            <li>Linear analog front-end; SNR based on variance addition of independent noise sources.</li>
            <li>APD described by McIntyre excess noise factor: <span class="eq">F(M)=kM+(1-k)(2-1/M)</span>.</li>
            <li>Same optical input and same post-detection bandwidth for the p-i-n and APD cases (so baseline shot-noise variance <span class="eq">σ_p^2</span> is a consistent reference).</li>
            <li>Mean gain <span class="eq">M ≥ 1</span>.</li>
          </ul>
        </div>

        <h3>Possible approaches (pros/cons)</h3>
        <ul>
          <li><strong>Approach 1: Work with absolute currents and bandwidth.</strong> Pro: very physical. Con: unnecessary parameters (responsivity, B, etc.) clutter; many cancel anyway.</li>
          <li><strong>Approach 2: Normalize everything by <span class="eq">σ_p^2</span>.</strong> Pro: clean; uses the given ratio directly; fastest to optimize. Con: requires comfort with SNR ratios.</li>
          <li><strong>Approach 3: Optimize by differentiating log-SNR.</strong> Pro: sometimes simpler algebra. Con: here direct differentiation is already simple.</li>
        </ul>
        <p><strong>Best choice:</strong> Approach 2 (normalized SNR), because the problem is explicitly stated in terms of a variance ratio.</p>
      </div>
    </section>

    <!-- PART 2 -->
    <section id="part2">
      <div class="sec-inner">
        <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

        <ol style="margin:10px 0 0; padding-left: 20px;">
          <li>
            <strong>Define baseline SNR for p-i-n.</strong>
            <div class="fine">Tool: SNR = (mean signal)<sup>2</sup>/variance. Meaning: sets a reference to compare improvements.</div>
          </li>
          <li>
            <strong>Write APD signal scaling.</strong>
            <div class="fine">Tool: mean signal ∝ M. Meaning: APD boosts the photocurrent amplitude.</div>
          </li>
          <li>
            <strong>Write APD noise scaling.</strong>
            <div class="fine">Tool: shot-noise variance term → M<sup>2</sup>F(M) times baseline; circuit noise unchanged. Meaning: multiplication is noisy.</div>
          </li>
          <li>
            <strong>Form the SNR ratio <span class="eq">G(M)=SNR_APD/SNR_PIN</span>.</strong>
            <div class="fine">Tool: normalize by <span class="eq">σ_p^2</span>. Meaning: cancels unknown absolute constants.</div>
          </li>
          <li>
            <strong>Insert McIntyre <span class="eq">F(M)</span> and simplify.</strong>
            <div class="fine">Tool: algebra. Meaning: get a function of only M, k, and R.</div>
          </li>
          <li>
            <strong>Maximize <span class="eq">G(M)</span> by differentiation.</strong>
            <div class="fine">Tool: set derivative to zero; solve for M. Meaning: find the trade-off point where extra gain no longer helps.</div>
          </li>
          <li>
            <strong>Evaluate numerically for <span class="eq">R=100</span>, <span class="eq">k=0.2</span>.</strong>
            <div class="fine">Tool: solve cubic root. Meaning: obtain <span class="eq">M_opt</span>.</div>
          </li>
          <li>
            <strong>Compute improvement <span class="eq">G_opt</span> (linear and dB).</strong>
            <div class="fine">Tool: plug into <span class="eq">G(M)</span> and take <span class="eq">10 log10</span>. Meaning: quantify practical benefit.</div>
          </li>
        </ol>

        <div class="callout" style="margin-top:12px;">
          <div class="tag"><span class="dot"></span>Common mistakes & quick tips</div>
          <ul>
            <li><strong>Mistake:</strong> multiplying circuit noise by <span class="eq">M</span>. <strong>Tip:</strong> circuit noise is added by electronics after detection; it stays fixed.</li>
            <li><strong>Mistake:</strong> using <span class="eq">F(M)=M</span>. <strong>Tip:</strong> that ignores ionization statistics; use the McIntyre form with <span class="eq">k</span>.</li>
            <li><strong>Mistake:</strong> maximizing <span class="eq">M</span> blindly. <strong>Tip:</strong> excess noise grows with gain; SNR has a maximum.</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- PART 3 -->
    <section id="part3">
      <div class="sec-inner">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Physical intuition (before math)</h3>
        <p>
          With <span class="eq">R=100</span>, the receiver is strongly <strong>circuit-noise-limited</strong> when using a p-i-n diode.
          Adding APD gain initially helps a lot because the signal grows like <span class="eq">M</span> while circuit noise stays fixed.
          However, the avalanche process is random: the shot-noise-related variance grows roughly like <span class="eq">M^2F(M)</span>, which eventually dominates and stops further improvement.
          So we expect an optimum at a moderate <span class="eq">M</span>, not at the largest possible gain.
        </p>

        <h3>Step 1: Define baseline (p-i-n) SNR using the given ratio</h3>
        <p>
          Let <span class="eq">S</span> be the mean signal (current or voltage) at the receiver output for the p-i-n case.
          The total noise variance is the sum of:
          <span class="eq">σ_p^2</span> (photoelectron/shot-noise variance) and <span class="eq">σ_c^2</span> (circuit noise variance).
        </p>
        <div class="eqbox">
          <div class="row">
            <pre class="eq" id="eq_snr0">SNR_PIN = S^2 / (σ_p^2 + σ_c^2)
R = σ_c^2 / σ_p^2 = 100  ⇒  σ_c^2 = R σ_p^2</pre>
            <button class="copyBtn" data-copy="#eq_snr0">Copy</button>
          </div>
        </div>
        <p>
          Substitute <span class="eq">σ_c^2 = R σ_p^2</span>:
        </p>
        <div class="eqbox">
          <div class="row">
            <pre class="eq" id="eq_snr0b">SNR_PIN = S^2 / ( (1+R) σ_p^2 )</pre>
            <button class="copyBtn" data-copy="#eq_snr0b">Copy</button>
          </div>
        </div>

        <h3>Step 2: Write the APD signal and noise</h3>
        <p>
          With mean multiplication <span class="eq">M</span>, the mean signal becomes <span class="eq">MS</span>.
          The shot-noise-related variance is multiplied by <span class="eq">M^2F(M)</span>.
          Circuit noise remains <span class="eq">σ_c^2</span>.
        </p>
        <div class="eqbox">
          <div class="row">
            <pre class="eq" id="eq_apd_snr">SNR_APD(M) = (M S)^2 / ( M^2 F(M) σ_p^2 + σ_c^2 )
           = M^2 S^2 / ( M^2 F(M) σ_p^2 + R σ_p^2 )</pre>
            <button class="copyBtn" data-copy="#eq_apd_snr">Copy</button>
          </div>
        </div>
        <p class="muted">
          Explanation: the <span class="eq">M^2</span> in the noise term comes from multiplying current fluctuations by gain; <span class="eq">F(M)</span> accounts for additional randomness in avalanche multiplication.
        </p>

        <h3>Step 3: Form the SNR improvement factor</h3>
        <p>
          Divide APD SNR by p-i-n SNR to eliminate unknown constants (<span class="eq">S</span> and <span class="eq">σ_p^2</span>):
        </p>
        <div class="eqbox">
          <div class="row">
            <pre class="eq" id="eq_gain">G(M) = SNR_APD / SNR_PIN
     = [(M^2 S^2)/( (M^2 F + R) σ_p^2 )] / [S^2/((1+R)σ_p^2)]
     = (1+R) M^2 / ( M^2 F(M) + R )</pre>
            <button class="copyBtn" data-copy="#eq_gain">Copy</button>
          </div>
        </div>

        <h3>Step 4: Insert McIntyre excess noise factor</h3>
        <p>
          For a conventional APD (McIntyre model):
        </p>
        <div class="eqbox">
          <div class="row">
            <pre class="eq" id="eq_F">F(M) = kM + (1-k)(2 - 1/M)</pre>
            <button class="copyBtn" data-copy="#eq_F">Copy</button>
          </div>
        </div>
        <p>
          It is useful to expand <span class="eq">M^2F(M)</span> into a polynomial-like form:
        </p>
        <div class="eqbox">
          <div class="row">
            <pre class="eq" id="eq_expand">M^2 F(M) = M^2 [ kM + 2(1-k) - (1-k)/M ]
         = k M^3 + 2(1-k) M^2 - (1-k) M</pre>
            <button class="copyBtn" data-copy="#eq_expand">Copy</button>
          </div>
        </div>

        <h3>Step 5: Maximize SNR (equivalently maximize <span class="eq">G(M)</span>)</h3>
        <p>
          Since <span class="eq">(1+R)</span> is constant, maximizing <span class="eq">G(M)</span> is the same as maximizing
          <span class="eq">g(M)= M^2/(M^2F(M)+R)</span>.
          Let the denominator be:
        </p>
        <div class="eqbox">
          <div class="row">
            <pre class="eq" id="eq_D">D(M) = M^2 F(M) + R
     = k M^3 + 2(1-k) M^2 - (1-k) M + R</pre>
            <button class="copyBtn" data-copy="#eq_D">Copy</button>
          </div>
        </div>
        <p>
          Optimize <span class="eq">g(M)=M^2/D(M)</span> using the quotient rule:
        </p>
        <div class="eqbox">
          <div class="row">
            <pre class="eq" id="eq_deriv">g'(M)=0  ⇒  (2M)D - M^2 D' = 0  ⇒  2D = M D'</pre>
            <button class="copyBtn" data-copy="#eq_deriv">Copy</button>
          </div>
        </div>
        <p>
          Compute <span class="eq">D'(M)</span>:
        </p>
        <div class="eqbox">
          <div class="row">
            <pre class="eq" id="eq_Dp">D'(M)= d/dM [k M^3 + 2(1-k) M^2 - (1-k)M + R]
     = 3k M^2 + 4(1-k) M - (1-k)</pre>
            <button class="copyBtn" data-copy="#eq_Dp">Copy</button>
          </div>
        </div>

        <p>
          Now apply the condition <span class="eq">2D = M D'</span>:
        </p>
        <div class="eqbox">
          <div class="row">
            <pre class="eq" id="eq_cubic">2[k M^3 + 2(1-k) M^2 - (1-k)M + R]
= M[3k M^2 + 4(1-k)M - (1-k)]</pre>
            <button class="copyBtn" data-copy="#eq_cubic">Copy</button>
          </div>
        </div>
        <p>
          Expand and simplify. The <span class="eq">M^2</span> terms cancel neatly, leaving:
        </p>
        <div class="eqbox">
          <div class="row">
            <pre class="eq" id="eq_cubic2">k M^3 + (1-k) M - 2R = 0</pre>
            <button class="copyBtn" data-copy="#eq_cubic2">Copy</button>
          </div>
        </div>
        <p class="muted">
          Explanation: This cubic is the core trade-off—higher <span class="eq">M</span> helps overcome <span class="eq">R</span>, but the <span class="eq">kM^3</span> term penalizes high gain because excess noise grows.
        </p>

        <h3>Step 6: Solve for the given numbers (<span class="eq">k=0.2</span>, <span class="eq">R=100</span>)</h3>
        <p>
          Insert values into <span class="eq">k M^3 + (1-k)M - 2R = 0</span>:
        </p>
        <div class="eqbox">
          <div class="row">
            <pre class="eq" id="eq_numeric_cubic">0.2 M^3 + 0.8 M - 200 = 0
Divide by 0.2:
M^3 + 4M - 1000 = 0</pre>
            <button class="copyBtn" data-copy="#eq_numeric_cubic">Copy</button>
          </div>
        </div>
        <p>
          This cubic has one physically relevant real root with <span class="eq">M ≥ 1</span>:
        </p>

        <div class="answer">
          <div class="boxTitle">
            <span><span class="badge"></span>Final numerical optimum</span>
            <button class="copyBtn" data-copy="#final_ans_text">Copy final answer</button>
          </div>
          <pre class="eq" id="final_ans_text">Given R = 100 and k = 0.2:

Optimal mean gain solves: 0.2 M^3 + 0.8 M - 200 = 0
⇒ M_opt ≈ 9.86

Excess noise factor at M_opt:
F(M) = kM + (1-k)(2 - 1/M)  ⇒  F(M_opt) ≈ 3.51

SNR improvement over p-i-n:
G_opt = (1+R) M^2 / (M^2 F(M) + R)
     ≈ 22.35  (linear)  ≈ 13.49 dB</pre>
        </div>

        <h3>Sanity checks</h3>
        <div class="grid2">
          <div class="callout">
            <div class="tag"><span class="dot"></span>Units / dimensions</div>
            <ul>
              <li><span class="eq">M</span>, <span class="eq">k</span>, <span class="eq">F</span>, <span class="eq">R</span>, and <span class="eq">G</span> are dimensionless.</li>
              <li>The cubic <span class="eq">kM^3 + (1-k)M - 2R</span> is dimensionless and consistent.</li>
            </ul>
          </div>
          <div class="callout">
            <div class="tag"><span class="dot"></span>Limiting cases</div>
            <ul>
              <li><strong>If <span class="eq">R→0</span>:</strong> the cubic becomes <span class="eq">kM^3+(1-k)M=0</span> ⇒ only positive solution is <span class="eq">M=0</span> (unphysical), so optimum is at the boundary <span class="eq">M=1</span>. APD gain does not help shot-noise-limited receivers.</li>
              <li><strong>If <span class="eq">R</span> increases:</strong> the term <span class="eq">2R</span> pushes the root to larger <span class="eq">M</span>, meaning more gain is beneficial when circuit noise dominates.</li>
              <li><strong>If <span class="eq">k</span> decreases:</strong> excess noise is reduced, allowing a higher optimal gain (and often higher peak improvement).</li>
            </ul>
          </div>
        </div>

        <p>
          Connection to the diagram and plots: the APD block multiplies the signal but introduces the stochastic multiplication noise captured by <span class="eq">F(M)</span>.
          The plots visualize how <span class="eq">G(M)</span> rises (overcoming circuit noise) and then saturates/rolls due to excess noise.
        </p>
      </div>
    </section>

    <!-- PART 4 -->
    <section id="part4">
      <div class="sec-inner">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpreting the final formulas</h3>
        <p>
          The improvement factor
          <span class="eq">G(M)=(1+R)M^2/(M^2F(M)+R)</span>
          has a clear structure:
        </p>
        <ul>
          <li><strong>Numerator <span class="eq">(1+R)M^2</span>:</strong> you get the signal boost <span class="eq">M^2</span> compared to p-i-n, scaled by the fact that p-i-n noise included both shot and circuit noise (<span class="eq">1+R</span> in normalized units).</li>
          <li><strong>Denominator <span class="eq">M^2F(M)+R</span>:</strong> APD shot-noise term grows with gain and excess noise; circuit noise stays constant.</li>
          <li><strong>Optimum condition <span class="eq">kM^3+(1-k)M=2R</span>:</strong> at optimum, “penalty” terms on the left balance the available circuit-noise advantage on the right.</li>
        </ul>

        <h3>How parameters affect the outcome (connect to the interactive plots)</h3>
        <ul>
          <li><strong>Increase <span class="eq">R</span> (more circuit noise):</strong> the best <span class="eq">M</span> increases and the achievable peak improvement usually increases.</li>
          <li><strong>Increase <span class="eq">k</span> (worse ionization asymmetry):</strong> <span class="eq">F(M)</span> rises faster with <span class="eq">M</span>, so <span class="eq">M_opt</span> decreases and peak improvement drops.</li>
          <li><strong>Decrease <span class="eq">k</span>:</strong> lower excess noise; APD can run at higher gain before becoming too noisy.</li>
        </ul>

        <h3>Alternative derivation idea (brief)</h3>
        <p>
          Instead of differentiating <span class="eq">g(M)=M^2/(M^2F+R)</span>, you can maximize <span class="eq">ln g(M)</span>:
          <span class="eq">d/dM[2 ln M - ln(M^2F+R)] = 0</span>.
          This leads to the same condition <span class="eq">2D = M D'</span> and the same cubic after substitution.
        </p>

        <h3>Concept check (self-test)</h3>
        <ul>
          <li><strong>Q:</strong> Why doesn’t circuit noise scale with <span class="eq">M</span>? <strong>A:</strong> It is generated by electronics (amplifier/thermal) after detection, so APD multiplication does not amplify it.</li>
          <li><strong>Q:</strong> If <span class="eq">R</span> is tiny, should you use large APD gain? <strong>A:</strong> No. When shot noise dominates, gain mostly increases noise via <span class="eq">F(M)</span>, so optimum is <span class="eq">M≈1</span>.</li>
          <li><strong>Q:</strong> What does smaller <span class="eq">k</span> generally do? <strong>A:</strong> It lowers <span class="eq">F(M)</span> growth, improving APD usefulness and allowing higher optimal gain.</li>
          <li><strong>Q:</strong> What sets the optimum mathematically? <strong>A:</strong> The balance between circuit noise term <span class="eq">R</span> and excess-noise growth embedded in <span class="eq">F(M)</span>, captured by <span class="eq">kM^3+(1-k)M=2R</span>.</li>
        </ul>
      </div>
    </section>

    <!-- PART 5 -->
    <section id="part5">
      <div class="sec-inner">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

        <div class="grid2">
          <div>
            <h3>Interactive controls</h3>
            <p class="muted">
              Use these to explore how APD optimization depends on circuit-noise dominance (<span class="eq">R</span>) and ionization ratio (<span class="eq">k</span>).
              Defaults match the problem: <span class="eq">R=100</span>, <span class="eq">k=0.2</span>.
            </p>
            <div class="controls" aria-label="Interactive controls">
              <div class="controlRow">
                <label for="kSel">Ionization ratio k</label>
                <select id="kSel">
                  <option value="0.02">0.02 (low excess noise)</option>
                  <option value="0.10">0.10</option>
                  <option value="0.20" selected>0.20 (problem)</option>
                  <option value="0.30">0.30</option>
                  <option value="0.50">0.50</option>
                  <option value="0.80">0.80 (high excess noise)</option>
                </select>
                <div class="val" id="kVal">0.20</div>
              </div>

              <div class="controlRow">
                <label for="rRange">Noise ratio R = σc²/σp²</label>
                <input id="rRange" type="range" min="0" max="300" step="1" value="100"/>
                <div class="val" id="rVal">100</div>
              </div>

              <div class="controlRow">
                <label for="mRange">Probe gain M (marker)</label>
                <input id="mRange" type="range" min="1" max="60" step="0.1" value="9.9"/>
                <div class="val" id="mVal">9.9</div>
              </div>

              <div class="controlRow">
                <label for="autoBtn">Set M = Mopt</label>
                <button class="copyBtn" id="autoBtn" style="width:100%;">Snap to optimum</button>
                <div class="val" id="mOptVal">Mopt ≈ 9.86</div>
              </div>
            </div>

            <div class="callout" style="margin-top:12px;">
              <div class="tag"><span class="dot"></span>What should change (and why)</div>
              <ul>
                <li>When <span class="eq">R</span> increases, the peak of <span class="eq">G(M)</span> tends to shift to larger <span class="eq">M</span> (more gain needed to beat electronics noise).</li>
                <li>When <span class="eq">k</span> increases, <span class="eq">F(M)</span> grows faster, reducing both the optimal gain and the maximum improvement.</li>
                <li>The “Probe gain” slider moves a marker so you can compare any chosen <span class="eq">M</span> to the optimum.</li>
              </ul>
            </div>
          </div>

          <div>
            <h3>What each canvas shows</h3>
            <ul>
              <li><strong>Diagram:</strong> the analog receiver chain: optical input → APD (gain <span class="eq">M</span>, excess noise <span class="eq">F</span>) → amplifier with circuit noise → output SNR.</li>
              <li><strong>Main plot:</strong> SNR improvement <span class="eq">G(M)</span> vs. gain <span class="eq">M</span>. Shows the optimum and your probe point.</li>
              <li><strong>Secondary plot:</strong> normalized noise terms vs. <span class="eq">M</span>: the APD shot-noise term <span class="eq">M^2F(M)</span> and the constant circuit term <span class="eq">R</span>. Visualizes the trade-off behind the optimum.</li>
            </ul>
          </div>
        </div>

        <figure>
          <canvas id="diag" class="canvasShort" aria-label="Receiver diagram canvas"></canvas>
          <figcaption>
            Labeled physical setup: optical signal detected by APD with mean gain <span class="eq">M</span> and excess noise <span class="eq">F(M)</span>, followed by electronics with fixed circuit noise.
          </figcaption>
        </figure>

        <figure>
          <canvas id="plot1" class="canvasTall" aria-label="Main plot canvas"></canvas>
          <figcaption>
            Main quantitative plot: SNR improvement <span class="eq">G(M)=SNR_APD/SNR_PIN</span> versus gain <span class="eq">M</span>. Includes optimum marker and probe marker.
          </figcaption>
        </figure>

        <figure>
          <canvas id="plot2" class="canvasTall" aria-label="Secondary plot canvas"></canvas>
          <figcaption>
            Secondary plot: normalized noise terms. <span class="eq">R</span> is constant circuit-noise variance; <span class="eq">M^2F(M)</span> is the APD-multiplied shot-noise variance term (normalized by <span class="eq">σ_p^2</span>).
          </figcaption>
        </figure>

      </div>
    </section>
  </article>
</main>

<footer>
  <div style="border-top:1px solid rgba(255,255,255,.14); padding-top:14px;">
    <p>
      This article used the standard McIntyre excess-noise model for conventional APDs and a normalized SNR optimization
      based on the provided variance ratio <span class="eq">R=σ_c^2/σ_p^2</span>.
      If your APD is a low-noise “staircase” or has dead-space effects, <span class="eq">F(M)</span> can differ and the optimum may shift.
    </p>
  </div>
</footer>

<div class="copyToast" id="toast">Copied.</div>

<script>
/* ======= Utilities: crisp canvas with devicePixelRatio ======= */
function setupHiDPICanvas(canvas){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(10, Math.floor(rect.width));
  const h = Math.max(10, Math.floor(rect.height));
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  return {ctx, w, h, dpr};
}

function lerp(a,b,t){ return a + (b-a)*t; }
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

/* ======= Math model ======= */
function F_of_M(M,k){
  // McIntyre: F = kM + (1-k)(2 - 1/M)
  return k*M + (1-k)*(2 - 1/M);
}
function G_of_M(M,k,R){
  const F = F_of_M(M,k);
  return (1+R) * (M*M) / ( (M*M)*F + R );
}
function cubicForMopt(k,R){
  // Solve: k M^3 + (1-k) M - 2R = 0  for M>=1
  // We'll find root with robust bisection on [1, Mmax] since monotonic increasing for k>0.
  const f = (M)=> k*M*M*M + (1-k)*M - 2*R;

  // Edge case: if R=0, optimum is M=1 boundary; return 1
  if (R <= 0) return 1;

  let lo = 1, hi = 1;
  let flo = f(lo), fhi = f(hi);

  // Expand hi until sign change
  let iter = 0;
  while (fhi < 0 && iter < 80){
    hi *= 1.6;
    fhi = f(hi);
    iter++;
    if (hi > 1e6) break;
  }
  // If no sign change (shouldn't for typical parameters), fallback
  if (fhi < 0) return hi;

  // Bisection
  for (let i=0;i<80;i++){
    const mid = 0.5*(lo+hi);
    const fm = f(mid);
    if (fm === 0) return mid;
    if (fm > 0){ hi = mid; fhi = fm; }
    else { lo = mid; flo = fm; }
  }
  return 0.5*(lo+hi);
}

/* ======= Plotting helpers ======= */
function drawAxes(ctx, box, xMin, xMax, yMin, yMax, opts){
  // box: {x,y,w,h}
  const {x,y,w,h} = box;
  const padL = opts.padL ?? 56;
  const padR = opts.padR ?? 16;
  const padT = opts.padT ?? 18;
  const padB = opts.padB ?? 46;

  const px = x + padL;
  const py = y + padT;
  const pw = w - padL - padR;
  const ph = h - padT - padB;

  // background panel
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.18)';
  ctx.fillRect(x, y, w, h);

  // grid and ticks
  const gridColor = 'rgba(255,255,255,0.10)';
  const axisColor = 'rgba(255,255,255,0.55)';
  const textColor = 'rgba(233,236,255,0.92)';
  const faint = 'rgba(184,192,255,0.75)';

  function xToPx(v){ return px + (v - xMin) * (pw/(xMax-xMin)); }
  function yToPx(v){ return py + ph - (v - yMin) * (ph/(yMax-yMin)); }

  // choose tick counts
  const xTicks = opts.xTicks ?? 6;
  const yTicks = opts.yTicks ?? 6;

  ctx.lineWidth = 1;

  // gridlines + tick labels
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillStyle = faint;

  // X grid
  for(let i=0;i<=xTicks;i++){
    const t = i/xTicks;
    const xv = lerp(xMin, xMax, t);
    const xp = xToPx(xv);
    ctx.strokeStyle = gridColor;
    ctx.beginPath();
    ctx.moveTo(xp, py);
    ctx.lineTo(xp, py+ph);
    ctx.stroke();

    ctx.fillText(formatNum(xv), xp-12, py+ph+18);
  }

  // Y grid
  for(let i=0;i<=yTicks;i++){
    const t = i/yTicks;
    const yv = lerp(yMin, yMax, t);
    const yp = yToPx(yv);
    ctx.strokeStyle = gridColor;
    ctx.beginPath();
    ctx.moveTo(px, yp);
    ctx.lineTo(px+pw, yp);
    ctx.stroke();

    ctx.fillText(formatNum(yv), x+8, yp+4);
  }

  // axes
  ctx.strokeStyle = axisColor;
  ctx.beginPath();
  ctx.moveTo(px, py);
  ctx.lineTo(px, py+ph);
  ctx.lineTo(px+pw, py+ph);
  ctx.stroke();

  // labels
  ctx.fillStyle = textColor;
  ctx.font = '13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  if(opts.title){
    ctx.font = '700 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(opts.title, x+12, y+18);
  }
  ctx.font = '13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  if(opts.xLabel){
    const tw = ctx.measureText(opts.xLabel).width;
    ctx.fillText(opts.xLabel, px + pw/2 - tw/2, y + h - 14);
  }
  if(opts.yLabel){
    ctx.save();
    ctx.translate(x+16, py + ph/2);
    ctx.rotate(-Math.PI/2);
    const tw = ctx.measureText(opts.yLabel).width;
    ctx.fillText(opts.yLabel, -tw/2, 0);
    ctx.restore();
  }

  ctx.restore();

  return {plotBox:{x:px,y:py,w:pw,h:ph}, xToPx, yToPx};
}

function drawLegend(ctx, items, x, y){
  // items: [{label, color}]
  ctx.save();
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillStyle = 'rgba(233,236,255,0.92)';
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1;

  let w = 0;
  for(const it of items){
    w = Math.max(w, ctx.measureText(it.label).width);
  }
  const pad = 10;
  const boxW = pad*2 + 18 + 8 + w;
  const boxH = pad*2 + items.length*18 - 2;

  ctx.fillStyle = 'rgba(0,0,0,0.28)';
  ctx.fillRect(x, y, boxW, boxH);
  ctx.strokeRect(x, y, boxW, boxH);

  for(let i=0;i<items.length;i++){
    const it = items[i];
    const yy = y + pad + i*18 + 4;
    // swatch
    ctx.strokeStyle = it.color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x+pad, yy);
    ctx.lineTo(x+pad+18, yy);
    ctx.stroke();
    // text
    ctx.fillStyle = 'rgba(233,236,255,0.92)';
    ctx.lineWidth = 1;
    ctx.fillText(it.label, x+pad+18+8, yy+4);
  }

  ctx.restore();
}

function formatNum(v){
  const av = Math.abs(v);
  if (av >= 1000) return v.toFixed(0);
  if (av >= 100) return v.toFixed(0);
  if (av >= 10) return v.toFixed(1);
  if (av >= 1) return v.toFixed(2);
  return v.toFixed(3);
}

/* ======= Render diagram ======= */
function drawDiagram(){
  const canvas = document.getElementById('diag');
  const {ctx,w,h} = setupHiDPICanvas(canvas);

  ctx.clearRect(0,0,w,h);

  const margin = 16;
  const x0 = margin, y0 = margin, W = w-2*margin, H = h-2*margin;

  // subtle background gradient
  const grad = ctx.createLinearGradient(0,0,w,h);
  grad.addColorStop(0,'rgba(125,211,252,0.08)');
  grad.addColorStop(1,'rgba(167,139,250,0.06)');
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,w,h);

  // receiver chain blocks
  const blockH = 74;
  const gap = 16;
  const blockW = (W - 2*gap)/3;
  const y = y0 + (H - blockH)/2;

  function block(x, labelTop, labelBottom, color){
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.22)';
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1;
    roundRect(ctx, x, y, blockW, blockH, 16);
    ctx.fill();
    ctx.stroke();

    // highlight strip
    ctx.fillStyle = color;
    roundRect(ctx, x+10, y+10, 10, blockH-20, 10);
    ctx.fill();

    ctx.fillStyle = 'rgba(233,236,255,0.95)';
    ctx.font = '700 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(labelTop, x+28, y+30);
    ctx.fillStyle = 'rgba(184,192,255,0.85)';
    ctx.font = '13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(labelBottom, x+28, y+52);
    ctx.restore();
  }

  const c1 = 'rgba(125,211,252,0.9)';
  const c2 = 'rgba(167,139,250,0.9)';
  const c3 = 'rgba(52,211,153,0.9)';

  const bx1 = x0;
  const bx2 = x0 + blockW + gap;
  const bx3 = x0 + 2*(blockW + gap);

  block(bx1, 'Optical input', 'Power → photons', c1);
  block(bx2, 'APD detector', 'Gain M, noise F(M)', c2);
  block(bx3, 'Electronics', 'Circuit noise σc²', c3);

  // arrows
  ctx.save();
  ctx.strokeStyle = 'rgba(233,236,255,0.85)';
  ctx.lineWidth = 2;
  ctx.fillStyle = 'rgba(233,236,255,0.85)';
  arrow(ctx, bx1+blockW, y+blockH/2, bx2, y+blockH/2);
  arrow(ctx, bx2+blockW, y+blockH/2, bx3, y+blockH/2);

  // output label
  const outX = bx3 + blockW + 22;
  const outY = y + blockH/2;
  arrow(ctx, bx3+blockW, outY, outX-10, outY);
  ctx.font = '700 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText('Output SNR', outX, outY-6);
  ctx.font = '13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillStyle = 'rgba(184,192,255,0.85)';
  ctx.fillText('maximize over M', outX, outY+14);

  ctx.restore();

  // compact formula callout
  const boxX = x0;
  const boxY = y0;
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.strokeStyle = 'rgba(255,255,255,0.16)';
  roundRect(ctx, boxX, boxY, Math.min(520, W), 58, 16);
  ctx.fill(); ctx.stroke();
  ctx.fillStyle = 'rgba(233,236,255,0.92)';
  ctx.font = '700 13px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  const txt1 = 'G(M)=(1+R) M^2/(M^2 F(M)+R)';
  const txt2 = 'F(M)=kM+(1-k)(2-1/M)';
  ctx.fillText(txt1, boxX+14, boxY+24);
  ctx.fillStyle = 'rgba(184,192,255,0.88)';
  ctx.font = '13px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillText(txt2, boxX+14, boxY+44);
  ctx.restore();
}

function roundRect(ctx,x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}

function arrow(ctx,x1,y1,x2,y2){
  const head = 10;
  const dx = x2-x1, dy=y2-y1;
  const ang = Math.atan2(dy,dx);
  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.lineTo(x2,y2);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x2,y2);
  ctx.lineTo(x2 - head*Math.cos(ang - Math.PI/6), y2 - head*Math.sin(ang - Math.PI/6));
  ctx.lineTo(x2 - head*Math.cos(ang + Math.PI/6), y2 - head*Math.sin(ang + Math.PI/6));
  ctx.closePath();
  ctx.fill();
}

/* ======= Render plots ======= */
function drawMainPlot(k,R,Mprobe){
  const canvas = document.getElementById('plot1');
  const {ctx,w,h} = setupHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  // domain
  const xMin = 1;
  const xMax = 60;

  // compute curve to find y range
  let yMax = 0;
  for(let i=0;i<=400;i++){
    const M = lerp(xMin,xMax,i/400);
    yMax = Math.max(yMax, G_of_M(M,k,R));
  }
  yMax *= 1.08;
  const yMin = 0;

  const ax = drawAxes(ctx, {x:10,y:10,w:w-20,h:h-20}, xMin,xMax,yMin,yMax, {
    title: 'SNR Improvement vs APD Gain',
    xLabel: 'Mean gain M (dimensionless)',
    yLabel: 'G(M) = SNR_APD / SNR_PIN (linear)',
    xTicks: 6,
    yTicks: 6
  });

  // draw curve
  ctx.save();
  ctx.lineWidth = 2.5;
  ctx.strokeStyle = 'rgba(125,211,252,0.95)';
  ctx.beginPath();
  for(let i=0;i<=600;i++){
    const M = lerp(xMin,xMax,i/600);
    const G = G_of_M(M,k,R);
    const xp = ax.xToPx(M);
    const yp = ax.yToPx(G);
    if(i===0) ctx.moveTo(xp,yp);
    else ctx.lineTo(xp,yp);
  }
  ctx.stroke();

  // optimal marker
  const Mopt = cubicForMopt(k,R);
  const Gopt = G_of_M(Mopt,k,R);
  drawMarker(ctx, ax.xToPx(Mopt), ax.yToPx(Gopt), 'rgba(52,211,153,0.95)', 'Mopt');

  // probe marker
  const Mp = clamp(Mprobe, xMin, xMax);
  const Gp = G_of_M(Mp,k,R);
  drawMarker(ctx, ax.xToPx(Mp), ax.yToPx(Gp), 'rgba(167,139,250,0.95)', 'Probe');

  // annotate values
  ctx.fillStyle = 'rgba(233,236,255,0.92)';
  ctx.font = '13px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  const txt = `k=${k.toFixed(2)}   R=${R.toFixed(0)}   Mopt≈${Mopt.toFixed(2)}   Gopt≈${Gopt.toFixed(2)}  (${(10*Math.log10(Gopt)).toFixed(2)} dB)`;
  ctx.fillText(txt, 26, h-18);

  // legend
  drawLegend(ctx, [
    {label:'G(M)', color:'rgba(125,211,252,0.95)'},
    {label:'Optimum', color:'rgba(52,211,153,0.95)'},
    {label:'Probe M', color:'rgba(167,139,250,0.95)'}
  ], 22, 34);

  ctx.restore();
}

function drawSecondaryPlot(k,R,Mprobe){
  const canvas = document.getElementById('plot2');
  const {ctx,w,h} = setupHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  const xMin = 1, xMax = 60;

  // y-range based on max of M^2F and R and sum
  let yMax = 0;
  for(let i=0;i<=400;i++){
    const M = lerp(xMin,xMax,i/400);
    const term = (M*M)*F_of_M(M,k);
    yMax = Math.max(yMax, term, R, term+R);
  }
  yMax *= 1.08;
  const yMin = 0;

  const ax = drawAxes(ctx, {x:10,y:10,w:w-20,h:h-20}, xMin,xMax,yMin,yMax, {
    title: 'Noise Trade-off (normalized by σp²)',
    xLabel: 'Mean gain M (dimensionless)',
    yLabel: 'Normalized variance terms (dimensionless)',
    xTicks: 6,
    yTicks: 6
  });

  // curves: shot term, circuit term, total
  const colorShot = 'rgba(125,211,252,0.95)';
  const colorCirc = 'rgba(251,191,36,0.95)';
  const colorTot = 'rgba(233,236,255,0.80)';

  function drawCurve(fn, color, lw){
    ctx.strokeStyle = color;
    ctx.lineWidth = lw;
    ctx.beginPath();
    for(let i=0;i<=600;i++){
      const M = lerp(xMin,xMax,i/600);
      const yv = fn(M);
      const xp = ax.xToPx(M);
      const yp = ax.yToPx(yv);
      if(i===0) ctx.moveTo(xp,yp);
      else ctx.lineTo(xp,yp);
    }
    ctx.stroke();
  }

  ctx.save();
  drawCurve((M)=> (M*M)*F_of_M(M,k), colorShot, 2.4);
  drawCurve((M)=> R, colorCirc, 2.4);
  drawCurve((M)=> (M*M)*F_of_M(M,k) + R, colorTot, 2.0);

  // probe vertical line
  const Mp = clamp(Mprobe, xMin, xMax);
  const xP = ax.xToPx(Mp);
  ctx.strokeStyle = 'rgba(167,139,250,0.85)';
  ctx.lineWidth = 1.5;
  ctx.setLineDash([6,5]);
  ctx.beginPath();
  ctx.moveTo(xP, ax.plotBox.y);
  ctx.lineTo(xP, ax.plotBox.y + ax.plotBox.h);
  ctx.stroke();
  ctx.setLineDash([]);

  // markers at probe
  const shot = (Mp*Mp)*F_of_M(Mp,k);
  const tot = shot + R;
  drawMarker(ctx, xP, ax.yToPx(shot), colorShot, 'M²F');
  drawMarker(ctx, xP, ax.yToPx(R), colorCirc, 'R');
  drawMarker(ctx, xP, ax.yToPx(tot), colorTot, 'Total');

  // legend
  drawLegend(ctx, [
    {label:'APD shot term: M²F(M)', color: colorShot},
    {label:'Circuit term: R', color: colorCirc},
    {label:'Total: M²F(M)+R', color: colorTot}
  ], 22, 34);

  // annotation
  ctx.fillStyle = 'rgba(233,236,255,0.92)';
  ctx.font = '13px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  const txt = `At probe M=${Mp.toFixed(2)}:  M²F≈${shot.toFixed(2)} , R=${R.toFixed(0)} , total≈${tot.toFixed(2)}`;
  ctx.fillText(txt, 26, h-18);

  ctx.restore();
}

function drawMarker(ctx, x, y, color, label){
  ctx.save();
  ctx.fillStyle = color;
  ctx.strokeStyle = 'rgba(0,0,0,0.35)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x,y,5.5,0,Math.PI*2);
  ctx.fill();
  ctx.stroke();

  ctx.font = '700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillStyle = 'rgba(233,236,255,0.92)';
  ctx.fillText(label, x+8, y-8);
  ctx.restore();
}

/* ======= UI wiring ======= */
const kSel = document.getElementById('kSel');
const rRange = document.getElementById('rRange');
const mRange = document.getElementById('mRange');
const kVal = document.getElementById('kVal');
const rVal = document.getElementById('rVal');
const mVal = document.getElementById('mVal');
const mOptVal = document.getElementById('mOptVal');
const autoBtn = document.getElementById('autoBtn');

function renderAll(){
  const k = parseFloat(kSel.value);
  const R = parseFloat(rRange.value);
  const Mprobe = parseFloat(mRange.value);

  kVal.textContent = k.toFixed(2);
  rVal.textContent = R.toFixed(0);
  mVal.textContent = Mprobe.toFixed(1);

  const Mopt = cubicForMopt(k,R);
  mOptVal.textContent = `Mopt ≈ ${Mopt.toFixed(2)}`;

  drawDiagram();
  drawMainPlot(k,R,Mprobe);
  drawSecondaryPlot(k,R,Mprobe);
}

kSel.addEventListener('change', renderAll);
rRange.addEventListener('input', renderAll);
mRange.addEventListener('input', renderAll);

autoBtn.addEventListener('click', ()=>{
  const k = parseFloat(kSel.value);
  const R = parseFloat(rRange.value);
  const Mopt = cubicForMopt(k,R);
  mRange.value = clamp(Mopt, parseFloat(mRange.min), parseFloat(mRange.max));
  renderAll();
});

/* ======= Copy buttons ======= */
const toast = document.getElementById('toast');
function showToast(msg){
  toast.textContent = msg;
  toast.classList.add('show');
  setTimeout(()=>toast.classList.remove('show'), 900);
}
document.querySelectorAll('.copyBtn[data-copy]').forEach(btn=>{
  btn.addEventListener('click', async ()=>{
    const sel = btn.getAttribute('data-copy');
    const el = document.querySelector(sel);
    if(!el) return;
    const text = (el.innerText || el.textContent || '').trim();
    try{
      await navigator.clipboard.writeText(text);
      showToast('Copied to clipboard.');
    }catch(e){
      // fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      showToast('Copied.');
    }
  });
});

/* ======= Smooth scroll for TOC ======= */
document.querySelectorAll('#toc a[href^="#"]').forEach(a=>{
  a.addEventListener('click', (e)=>{
    e.preventDefault();
    const id = a.getAttribute('href');
    const target = document.querySelector(id);
    if(target){
      target.scrollIntoView({behavior:'smooth', block:'start'});
      history.replaceState(null, '', id);
    }
  });
});

/* ======= Responsiveness ======= */
let resizeTimer = null;
window.addEventListener('resize', ()=>{
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(renderAll, 120);
});

/* initial render */
renderAll();
</script>
</body>
</html>
