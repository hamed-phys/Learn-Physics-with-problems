<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Maximum Responsivity of Ideal Semiconductor Photodetectors (Si, GaAs, InSb)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --panel2:#101c3a;
      --text:#eaf0ff;
      --muted:#b7c3e6;
      --faint:#7f90c7;
      --line:rgba(255,255,255,.12);
      --good:#7CFFB2;
      --warn:#FFD27C;
      --bad:#FF7C9C;
      --accent:#7CB7FF;
      --accent2:#B07CFF;
      --shadow: 0 18px 45px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% 15%, rgba(124,183,255,.18), transparent 60%),
        radial-gradient(900px 700px at 80% 20%, rgba(176,124,255,.16), transparent 55%),
        radial-gradient(800px 600px at 70% 85%, rgba(124,255,178,.10), transparent 60%),
        linear-gradient(180deg, var(--bg), #070a14 55%, #05060f);
      line-height:1.55;
      overflow-x:hidden;
    }

    header{
      padding: clamp(18px, 4vw, 44px) 16px 14px;
      max-width: 1100px;
      margin: 0 auto;
    }

    .hero{
      display:grid;
      grid-template-columns: 1.4fr .9fr;
      gap:18px;
      align-items:stretch;
    }

    @media (max-width: 900px){
      .hero{ grid-template-columns:1fr; }
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 18px;
      position:relative;
      overflow:hidden;
    }

    .card::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(800px 160px at 10% 10%, rgba(124,183,255,.18), transparent 55%),
                  radial-gradient(700px 180px at 90% 30%, rgba(176,124,255,.14), transparent 55%);
      pointer-events:none;
      opacity:.9;
      filter: blur(.2px);
    }
    .card > *{ position:relative; }

    h1{
      margin:0 0 6px;
      font-size: clamp(22px, 2.6vw, 34px);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size: clamp(14px, 1.4vw, 16px);
    }

    .pillrow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:12px;
    }
    .pill{
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      background:rgba(255,255,255,.04);
      color:var(--muted);
      font-size: 13px;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .dot{ width:9px; height:9px; border-radius:50%; background: var(--accent); box-shadow:0 0 0 3px rgba(124,183,255,.18); }
    .dot.p2{ background: var(--accent2); box-shadow:0 0 0 3px rgba(176,124,255,.16); }
    .dot.p3{ background: var(--good); box-shadow:0 0 0 3px rgba(124,255,178,.12); }

    main{
      max-width:1100px;
      margin: 0 auto;
      padding: 0 16px 56px;
      display:grid;
      grid-template-columns: 1fr 310px;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{ grid-template-columns:1fr; }
    }

    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      padding: 14px 14px 10px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.025));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    nav.toc h2{
      margin: 0 0 8px;
      font-size: 14px;
      letter-spacing:.5px;
      color:var(--muted);
      text-transform: uppercase;
    }
    nav.toc a{
      display:block;
      text-decoration:none;
      color: var(--text);
      padding: 7px 10px;
      margin: 4px 0;
      border-radius: 10px;
      border:1px solid transparent;
      font-size: 14px;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
    }
    nav.toc a:hover{
      background: rgba(124,183,255,.10);
      border-color: rgba(124,183,255,.25);
      transform: translateX(2px);
    }
    nav.toc .mini{
      color: var(--faint);
      font-size: 12.5px;
      margin-top: 6px;
      line-height:1.35;
    }

    section{
      scroll-margin-top: 86px;
    }

    .content .card{ margin-bottom: 18px; }
    .content h2{
      margin: 0 0 10px;
      font-size: 20px;
    }
    .content h3{
      margin: 14px 0 8px;
      font-size: 16px;
      color: var(--muted);
    }

    ul{ margin: 8px 0 0 18px; }
    li{ margin: 6px 0; color: var(--text); }
    .muted{ color: var(--muted); }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top: 10px;
    }
    @media (max-width: 760px){ .callouts{ grid-template-columns:1fr; } }

    .callout{
      border-radius: 16px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      padding: 12px 12px;
    }
    .callout .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-weight: 650;
      font-size: 12px;
      letter-spacing:.35px;
      text-transform: uppercase;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      margin-bottom: 8px;
    }
    .tag.good{ color: var(--good); border-color: rgba(124,255,178,.25); }
    .tag.warn{ color: var(--warn); border-color: rgba(255,210,124,.25); }
    .tag.key{ color: var(--accent); border-color: rgba(124,183,255,.25); }

    .eqbox{
      border-radius: 16px;
      border:1px solid rgba(124,183,255,.22);
      background: linear-gradient(180deg, rgba(124,183,255,.10), rgba(124,183,255,.04));
      padding: 12px 12px;
      margin-top: 10px;
      overflow:auto;
    }
    .eq{
      font-family: var(--mono);
      font-size: 14px;
      white-space: nowrap;
    }

    .btnrow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:10px;
      align-items:center;
    }
    button.copy{
      border: 1px solid var(--line);
      background: rgba(255,255,255,.05);
      color: var(--text);
      padding: 9px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 650;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    button.copy:hover{
      background: rgba(124,183,255,.12);
      border-color: rgba(124,183,255,.25);
      transform: translateY(-1px);
    }
    .toast{
      font-size: 13px;
      color: var(--muted);
      min-height: 18px;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:12px;
      align-items:start;
    }
    @media (max-width: 900px){ .grid2{ grid-template-columns:1fr; } }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    @media (max-width: 620px){ .controls{ grid-template-columns:1fr; } }

    .ctrl{
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      border-radius: 16px;
      padding: 10px 10px;
    }
    .ctrl label{
      display:flex;
      justify-content:space-between;
      gap:8px;
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    select, input[type="range"]{
      width:100%;
    }
    select{
      background: rgba(0,0,0,.25);
      color: var(--text);
      border:1px solid var(--line);
      padding: 10px 10px;
      border-radius: 12px;
      outline:none;
    }
    input[type="range"]{
      accent-color: var(--accent);
    }
    .small{
      font-size: 12.5px;
      color: var(--faint);
      margin-top: 6px;
      line-height:1.35;
    }

    figure{
      margin: 0;
    }
    canvas{
      width: 100%;
      height: 320px;
      display:block;
      border-radius: 16px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.22);
    }
    .canvasTall{ height: 360px; }
    .caption{
      margin-top: 8px;
      font-size: 12.5px;
      color: var(--muted);
      line-height:1.35;
    }

    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      overflow:hidden;
      border-radius: 16px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      margin-top: 10px;
    }
    th, td{
      padding: 10px 10px;
      border-bottom:1px solid var(--line);
      font-size: 14px;
    }
    th{
      text-align:left;
      color: var(--muted);
      background: rgba(255,255,255,.03);
      font-weight: 750;
    }
    tr:last-child td{ border-bottom:none; }

    .final{
      border:1px solid rgba(124,255,178,.22);
      background: linear-gradient(180deg, rgba(124,255,178,.12), rgba(124,255,178,.05));
      border-radius: 18px;
      padding: 14px 14px;
      margin-top: 10px;
    }
    .final h3{
      margin:0 0 8px;
      color: var(--good);
      font-size: 16px;
    }
    .final pre{
      margin: 0;
      padding: 10px 10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      font-family: var(--mono);
      font-size: 13.5px;
      overflow:auto;
      white-space:pre;
    }

    footer{
      max-width:1100px;
      margin: 0 auto;
      padding: 0 16px 40px;
      color: var(--faint);
      font-size: 12.5px;
    }

    /* subtle entry animation */
    @media (prefers-reduced-motion: no-preference){
      .card{
        animation: floatIn .5s ease both;
      }
      @keyframes floatIn{
        from{ opacity:0; transform: translateY(8px); }
        to{ opacity:1; transform: translateY(0); }
      }
    }

    /* print-friendly */
    @media print{
      body{ background:#fff; color:#000; }
      .card, nav.toc{ box-shadow:none; background:#fff; border:1px solid #bbb; }
      canvas{ border:1px solid #bbb; background:#fff; }
      nav.toc{ position: static; }
      button.copy{ display:none; }
      .toast{ display:none; }
    }
  </style>
</head>

<body>
<header>
  <div class="hero">
    <div class="card">
      <h1>Maximum Responsivity of Ideal Semiconductor Photodetectors</h1>
      <p class="subtitle">
        Determine the <b>maximum responsivity</b> for ideal (unity quantum efficiency, unity gain) photodetectors made of
        <b>Si</b>, <b>GaAs</b>, and <b>InSb</b>—and understand why the bandgap sets the limit.
      </p>
      <div class="pillrow">
        <div class="pill"><span class="dot"></span>Key idea: responsivity ∝ wavelength</div>
        <div class="pill"><span class="dot p2"></span>Limit set by bandgap cutoff λ<sub>g</sub></div>
        <div class="pill"><span class="dot p3"></span>Result: R<sub>max</sub> = q/E<sub>g</sub></div>
      </div>
    </div>

    <div class="card">
      <h2 style="margin:0 0 10px;font-size:18px;">Interactive Explorer</h2>
      <p class="muted" style="margin:0 0 10px;">
        Use controls to see how material bandgap, quantum efficiency, and gain affect responsivity and its maximum.
      </p>

      <div class="controls" aria-label="Interactive controls">
        <div class="ctrl">
          <label for="matSel"><span>Material</span><span id="matLabel" class="muted">Si</span></label>
          <select id="matSel">
            <option value="Si" selected>Silicon (Si)</option>
            <option value="GaAs">Gallium Arsenide (GaAs)</option>
            <option value="InSb">Indium Antimonide (InSb)</option>
          </select>
          <div class="small" id="egInfo">E<sub>g</sub> ≈ 1.12 eV (example, ~300 K)</div>
        </div>

        <div class="ctrl">
          <label for="etaRange"><span>Quantum efficiency η</span><span id="etaLabel" class="muted">1.00</span></label>
          <input id="etaRange" type="range" min="0" max="1" step="0.01" value="1" />
          <div class="small">Ideal problem uses η = 1. Slider shows how non-ideal η scales R.</div>
        </div>

        <div class="ctrl" style="grid-column:1 / -1;">
          <label for="gainRange"><span>Photocarrier gain M</span><span id="gainLabel" class="muted">1.0</span></label>
          <input id="gainRange" type="range" min="1" max="20" step="0.1" value="1" />
          <div class="small">Ideal problem uses M = 1 (unity gain). Avalanche/APD-like gain would multiply responsivity.</div>
        </div>
      </div>

      <div class="final" style="margin-top:12px;">
        <h3>Live readout (selected settings)</h3>
        <div class="muted" id="liveReadout" style="font-size:14px;"></div>
      </div>
    </div>
  </div>
</header>

<main>
  <article class="content">

    <!-- Quick Summary -->
    <section id="quick-summary" class="card">
      <h2>Quick Summary</h2>
      <ul>
        <li>We want the <b>maximum responsivity</b> <span class="muted">(A/W)</span> of an <b>ideal</b> semiconductor photodetector for Si, GaAs, and InSb.</li>
        <li>Responsivity relates output photocurrent to incident optical power: <b>R = I<sub>ph</sub>/P<sub>opt</sub></b>.</li>
        <li>For a photodiode with quantum efficiency η and gain M, the governing relation is:
          <span class="muted">R(λ) = η M (q / hν) = η M (qλ / hc)</span>.
        </li>
        <li>Semiconductors only absorb photons with <b>hν ≥ E<sub>g</sub></b>, giving a cutoff wavelength
          <b>λ<sub>g</sub> = hc / E<sub>g</sub></b>.
        </li>
        <li>Because <b>R ∝ λ</b>, the maximum occurs at the <b>longest</b> absorbed wavelength: <b>λ = λ<sub>g</sub></b>.</li>
        <li>Final key result (ideal η = 1, M = 1): <b>R<sub>max</sub> = q / E<sub>g</sub></b> (numeric for each material).</li>
      </ul>

      <div class="eqbox">
        <div class="eq" id="eq1">R(λ) = η M · (qλ)/(hc),  for  λ ≤ λg ;   R(λ) ≈ 0 for λ &gt; λg</div>
      </div>

      <div class="btnrow">
        <button class="copy" data-copy-target="eq1">Copy key equation</button>
        <button class="copy" data-copy-target="finalText">Copy final answers</button>
        <span class="toast" id="toast"></span>
      </div>
    </section>

    <!-- PART 0 -->
    <section id="part0" class="card">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <h3>Core definitions (symbols &amp; units)</h3>
      <ul>
        <li><b>Responsivity</b> <b>R</b> <span class="muted">(A/W)</span>: photocurrent per optical power, <b>R = I<sub>ph</sub>/P<sub>opt</sub></b>.</li>
        <li><b>Quantum efficiency</b> <b>η</b> <span class="muted">(dimensionless)</span>: fraction of incident photons that produce collected charge carriers.</li>
        <li><b>Gain</b> <b>M</b> <span class="muted">(dimensionless)</span>: number of collected electrons per absorbed photon (M = 1 for a unity-gain photodiode).</li>
        <li><b>Photon energy</b> <b>hν</b> <span class="muted">(J or eV)</span>, where <b>ν</b> is frequency, <b>λ</b> is wavelength, and <b>h</b> is Planck’s constant.</li>
        <li><b>Bandgap</b> <b>E<sub>g</sub></b> <span class="muted">(eV)</span>: minimum energy required to excite an electron from valence to conduction band (enables absorption &amp; carrier generation).</li>
      </ul>

      <h3>Physical meaning: why responsivity depends on wavelength</h3>
      <p class="muted">
        Optical power is energy per time. Photocurrent is charge per time. Each photon carries energy <b>hν</b>.
        If a detector turns each photon into (on average) <b>ηM</b> electrons, then the charge delivered per photon is <b>ηM·q</b>.
        So the charge-per-energy ratio becomes <b>(ηM q)/(hν)</b>. Lower-energy photons (longer λ) give more current per watt—until the bandgap blocks absorption.
      </p>

      <div class="callouts">
        <div class="callout">
          <div class="tag key">Key law</div>
          <div class="eqbox" style="margin:0;">
            <div class="eq" id="eq2">R = Iph / Popt = η M · (q / hν) = η M · (qλ / hc)</div>
          </div>
        </div>
        <div class="callout">
          <div class="tag warn">Validity conditions</div>
          <ul style="margin-top:6px;">
            <li>Steady-state illumination (average photocurrent).</li>
            <li>Linear regime (no saturation, no space-charge limits).</li>
            <li>“Ideal” means η = 1 (every photon → carrier) and M = 1 (no multiplication).</li>
            <li>Absorption requires <b>hν ≥ E<sub>g</sub></b> (band-to-band detection).</li>
          </ul>
        </div>
      </div>

      <h3>Common model/approximation used here</h3>
      <ul>
        <li><b>Step-function absorption edge:</b> assume absorption is strong for <b>hν ≥ E<sub>g</sub></b> and negligible for <b>hν &lt; E<sub>g</sub></b>.</li>
        <li>This is why we treat responsivity as <b>R(λ) ∝ λ</b> up to λ<sub>g</sub> and ~0 beyond.</li>
      </ul>

      <h3>Mini intuition examples</h3>
      <ul>
        <li><b>Same optical power, different wavelengths:</b> 1 W at longer λ contains more photons per second (each photon has less energy), so you can get more electrons per second ⇒ larger R.</li>
        <li><b>But too long a wavelength:</b> if photons don’t have enough energy to cross the bandgap, they pass through without generating carriers ⇒ R collapses to ~0.</li>
      </ul>

      <div class="callout" style="margin-top:10px;">
        <div class="tag warn">What to watch for (pitfalls)</div>
        <ul style="margin-top:6px;">
          <li>Mixing up <b>responsivity</b> (A/W) with <b>quantum efficiency</b> (dimensionless).</li>
          <li>Forgetting the <b>bandgap cutoff</b>: you cannot push λ arbitrarily long and keep increasing R.</li>
          <li>Unit slips: using E<sub>g</sub> in eV but h, c in SI without conversion. (A nice shortcut exists: <b>R<sub>max</sub>[A/W] = 1/E<sub>g</sub>[eV]</b> for η=M=1.)</li>
        </ul>
      </div>
    </section>

    <!-- PART 1 -->
    <section id="part1" class="card">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <p>
        <b>Restatement:</b> For an ideal semiconductor photodetector (η = 1, M = 1), find the <b>maximum</b> possible responsivity
        if the detector is made from (a) silicon, (b) gallium arsenide, and (c) indium antimonide.
      </p>

      <h3>Given</h3>
      <ul>
        <li>Ideal detector: <b>η = 1</b>, <b>M = 1</b>.</li>
        <li>Material sets bandgap <b>E<sub>g</sub></b>. (We will use common ~300 K values for numerical answers.)</li>
      </ul>

      <h3>Unknowns</h3>
      <ul>
        <li>Maximum responsivity <b>R<sub>max</sub></b> (A/W) for each material.</li>
        <li>Corresponding cutoff wavelength <b>λ<sub>g</sub></b> (useful for interpreting where the maximum occurs).</li>
      </ul>

      <h3>What must be found</h3>
      <ul>
        <li>A clear expression for <b>R<sub>max</sub></b> and numeric values for Si, GaAs, InSb.</li>
      </ul>

      <h3>Relevant physical principles (and why)</h3>
      <ul>
        <li><b>Photon energy:</b> hν = hc/λ (connects wavelength to energy-per-photon).</li>
        <li><b>Carrier generation limit:</b> one absorbed photon yields at most one electron-hole pair without multiplication (ideal unity gain).</li>
        <li><b>Bandgap threshold:</b> absorption requires hν ≥ E<sub>g</sub>, giving the maximum wavelength that can be detected.</li>
      </ul>

      <h3>Assumptions</h3>
      <div class="callout">
        <div class="tag key">Assumptions</div>
        <ul style="margin-top:6px;">
          <li>Band-to-band photodetection with a sharp cutoff at λ<sub>g</sub>.</li>
          <li>No reflection, no recombination loss: η = 1.</li>
          <li>No internal multiplication: M = 1.</li>
          <li>Temperature dependence of E<sub>g</sub> ignored; use standard room-temperature example values for numeric results.</li>
        </ul>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ol style="margin:8px 0 0 18px;">
        <li><b>Energy-per-photon approach:</b> compute electrons per second from photons per second and divide by power. <span class="muted">Very intuitive; slightly longer.</span></li>
        <li><b>Direct responsivity formula:</b> use R = ηM q/(hν), then use ν = c/λ. <span class="muted">Fastest and clean.</span></li>
        <li><b>Bandgap-limited optimization:</b> note R increases with λ, so maximize at λ = λ<sub>g</sub>. <span class="muted">Best for “maximum” questions.</span></li>
      </ol>

      <p class="muted" style="margin-top:10px;">
        <b>Chosen approach:</b> Combine (2) and (3): write R(λ), apply the bandgap constraint, and evaluate at λ = λ<sub>g</sub>.
      </p>
    </section>

    <!-- PART 2 -->
    <section id="part2" class="card">
      <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>

      <ol style="margin:8px 0 0 18px;">
        <li>
          <b>Write responsivity in terms of photon energy</b><br>
          Goal: relate current per optical power.<br>
          Tool: R = ηM q/(hν).<br>
          Meaning: charge delivered per photon divided by energy per photon.
        </li>
        <li>
          <b>Convert to wavelength form</b><br>
          Goal: see how R varies with λ.<br>
          Tool: ν = c/λ ⇒ R(λ) = ηM qλ/(hc).<br>
          Meaning: longer λ (lower photon energy) gives higher A/W.
        </li>
        <li>
          <b>Apply bandgap cutoff</b><br>
          Goal: enforce absorption condition.<br>
          Tool: hν ≥ E<sub>g</sub> ⇒ λ ≤ λ<sub>g</sub> = hc/E<sub>g</sub>.<br>
          Meaning: semiconductor cannot detect beyond λ<sub>g</sub>.
        </li>
        <li>
          <b>Maximize R under λ ≤ λ<sub>g</sub></b><br>
          Goal: find R<sub>max</sub>.<br>
          Tool: since R ∝ λ, maximum occurs at λ = λ<sub>g</sub>.<br>
          Meaning: best responsivity is at the “reddest” detectable photons.
        </li>
        <li>
          <b>Evaluate R at λ<sub>g</sub></b><br>
          Goal: simplify and compute numbers.<br>
          Tool: R<sub>max</sub> = ηM qλ<sub>g</sub>/(hc) = ηM q/E<sub>g</sub>.<br>
          Meaning: responsivity ceiling is set by the bandgap energy.
        </li>
      </ol>

      <div class="callouts">
        <div class="callout">
          <div class="tag warn">Common mistakes</div>
          <ul style="margin-top:6px;">
            <li>Using λ &gt; λ<sub>g</sub> in R(λ) as if the detector still absorbs.</li>
            <li>Forgetting that “maximum” here means maximize over λ subject to absorption.</li>
            <li>Mixing eV and joules when using q, h, c (use the shortcut when η=M=1).</li>
          </ul>
        </div>
        <div class="callout">
          <div class="tag good">Quick tips</div>
          <ul style="margin-top:6px;">
            <li>At η=M=1: <b>R<sub>max</sub>[A/W] = 1 / E<sub>g</sub>[eV]</b>.</li>
            <li>Also: <b>λ<sub>g</sub>[µm] ≈ 1.24 / E<sub>g</sub>[eV]</b>.</li>
            <li>Check reasonableness: smaller bandgap ⇒ longer λ cutoff ⇒ larger R<sub>max</sub>.</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- PART 3 -->
    <section id="part3" class="card">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Physical intuition (before math)</h3>
      <p class="muted">
        For a fixed optical power P, the photon arrival rate is Ṅ = P/(hν). If every photon produces one electron (η=1, M=1),
        then the electron rate equals Ṅ, and the current is I = qṄ = qP/(hν). Therefore, the responsivity R = I/P = q/(hν).
        As ν decreases (λ increases), hν gets smaller, so R gets larger—until photons become too weak to cross the bandgap.
        Hence, the maximum should occur right at the absorption edge (λ = λ<sub>g</sub>).
      </p>

      <h3>Step 1 — Start from definitions</h3>
      <p>
        Responsivity is
        <span class="muted"><b>R = I<sub>ph</sub> / P<sub>opt</sub></b></span>,
        where:
      </p>
      <ul>
        <li><b>I<sub>ph</sub></b> is photocurrent (A),</li>
        <li><b>P<sub>opt</sub></b> is incident optical power (W).</li>
      </ul>

      <h3>Step 2 — Relate current to photon rate</h3>
      <p>
        Let <b>Ṅ</b> be the incident photon rate (photons/s). Each photon has energy <b>hν</b>, so
      </p>
      <div class="eqbox">
        <div class="eq">Popt = Ṅ · hν  ⇒  Ṅ = Popt / (hν)</div>
      </div>
      <p class="muted">
        This is simply “power = (photons per second) × (energy per photon)”.
      </p>

      <h3>Step 3 — Include quantum efficiency and gain</h3>
      <p>
        If a fraction <b>η</b> of photons generate collected carriers, and each absorbed photon results in <b>M</b> collected electrons,
        then the electron rate collected is <b>η M Ṅ</b>, and the photocurrent becomes:
      </p>
      <div class="eqbox">
        <div class="eq">Iph = (η M Ṅ) · q</div>
      </div>
      <p class="muted">
        Here <b>q</b> is the elementary charge (C). This converts “electrons per second” into coulombs per second (amps).
      </p>

      <h3>Step 4 — Form responsivity</h3>
      <p>
        Substitute Ṅ = P<sub>opt</sub>/(hν) into I<sub>ph</sub>:
      </p>
      <div class="eqbox">
        <div class="eq">Iph = η M · (Popt / (hν)) · q</div>
      </div>
      <p>
        Divide by P<sub>opt</sub> to get responsivity:
      </p>
      <div class="eqbox">
        <div class="eq">R = Iph / Popt = η M · (q / (hν))</div>
      </div>

      <h3>Step 5 — Convert to wavelength form</h3>
      <p>
        Using ν = c/λ (with c the speed of light), we have hν = hc/λ, so:
      </p>
      <div class="eqbox">
        <div class="eq">R(λ) = η M · (q / (hc/λ)) = η M · (qλ / (hc))</div>
      </div>
      <p class="muted">
        This shows clearly: <b>R grows linearly with λ</b>—if the material still absorbs at that wavelength.
      </p>

      <h3>Step 6 — Apply the semiconductor absorption condition (bandgap cutoff)</h3>
      <p>
        Band-to-band absorption requires photon energy ≥ bandgap:
      </p>
      <div class="eqbox">
        <div class="eq">hν ≥ Eg</div>
      </div>
      <p>
        Rewrite with hν = hc/λ:
      </p>
      <div class="eqbox">
        <div class="eq">hc/λ ≥ Eg  ⇒  λ ≤ λg = hc/Eg</div>
      </div>
      <p class="muted">
        So the detector can respond only up to the cutoff wavelength <b>λ<sub>g</sub></b>.
      </p>

      <h3>Step 7 — Maximize R under λ ≤ λ<sub>g</sub></h3>
      <p>
        Since R(λ) = ηM(qλ/hc) is increasing with λ, the maximum allowed λ gives the maximum responsivity:
      </p>
      <div class="eqbox">
        <div class="eq" id="eq3">Rmax = R(λg) = η M · (qλg / (hc)) = η M · (q / Eg)</div>
      </div>
      <p class="muted">
        The simplification happens because λ<sub>g</sub> = hc/E<sub>g</sub>. The bandgap directly sets the ceiling.
      </p>

      <h3>Step 8 — Ideal case (η = 1, M = 1) and numerical values</h3>
      <p>
        For the problem’s ideal detector, η = 1 and M = 1:
      </p>
      <div class="eqbox">
        <div class="eq">Rmax(ideal) = q/Eg</div>
      </div>

      <p class="muted">
        Convenient shortcut: if E<sub>g</sub> is expressed in eV, then
        <b>q/E<sub>g</sub> = 1/E<sub>g</sub></b> in units of A/W, because 1 eV = q joules.
      </p>

      <table aria-label="Material results">
        <thead>
          <tr>
            <th>Material</th>
            <th>Bandgap E<sub>g</sub> (eV, example ~300 K)</th>
            <th>Cutoff λ<sub>g</sub> (µm)</th>
            <th>R<sub>max</sub> (A/W) ideal</th>
          </tr>
        </thead>
        <tbody id="resultsTableBody">
          <!-- filled by JS for consistency -->
        </tbody>
      </table>

      <div class="final">
        <h3>Final Answer (boxed)</h3>
        <pre id="finalText">Rmax(ideal) = q/Eg  and  λg = hc/Eg

Using typical room-temperature bandgaps:
• Si (Eg ≈ 1.12 eV):  λg ≈ 1.11 µm,  Rmax ≈ 0.893 A/W
• GaAs (Eg ≈ 1.42 eV): λg ≈ 0.873 µm, Rmax ≈ 0.704 A/W
• InSb (Eg ≈ 0.17 eV):  λg ≈ 7.29 µm,  Rmax ≈ 5.88 A/W</pre>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><b>Units:</b> q/E<sub>g</sub> has units C/J = A/W. ✓</li>
        <li><b>Limiting trend:</b> smaller E<sub>g</sub> ⇒ larger R<sub>max</sub>. InSb has the smallest bandgap and the largest R<sub>max</sub>. ✓</li>
        <li><b>Physical interpretation:</b> R is charge out per energy in. At the band edge, each photon has minimal energy that still produces a carrier, maximizing charge per joule. ✓</li>
      </ul>

      <p class="muted">
        Connection to diagram/plots: the plots show <b>R rising with λ</b> up to <b>λ<sub>g</sub></b>, then dropping to ~0 because photons no longer exceed the bandgap.
      </p>
    </section>

    <!-- PART 4 -->
    <section id="part4" class="card">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Reinterpreting the final formula</h3>
      <p>
        <span class="muted"><b>R<sub>max</sub> = η M (q/E<sub>g</sub>)</b></span> tells you:
      </p>
      <ul>
        <li><b>E<sub>g</sub></b> controls the <b>energy cost</b> (minimum photon energy) to create carriers. Smaller bandgap ⇒ more current per watt.</li>
        <li><b>η</b> is an <b>efficiency multiplier</b> (optical + collection losses reduce η).</li>
        <li><b>M</b> is a <b>multiplication multiplier</b> (internal gain devices can exceed the “one electron per photon” limit).</li>
      </ul>

      <div class="callout" style="margin-top:10px;">
        <div class="tag key">Key takeaway</div>
        <p class="muted" style="margin:6px 0 0;">
          The “maximum responsivity” for a unity-gain, unity-η semiconductor detector is not a mysterious device detail—
          it is fundamentally set by <b>bandgap energy</b>.
        </p>
      </div>

      <h3>How parameter changes affect the outcome (connect to interactive plots)</h3>
      <ul>
        <li>Changing material changes <b>E<sub>g</sub></b> ⇒ shifts λ<sub>g</sub> and scales R<sub>max</sub> as 1/E<sub>g</sub>.</li>
        <li>Increasing η scales the entire R(λ) curve and R<sub>max</sub> linearly.</li>
        <li>Increasing M scales the responsivity and maximum linearly (but real devices trade gain for noise/bandwidth).</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p class="muted">
        Start from “one collected electron corresponds to charge q.” For ideal unity gain and η=1,
        energy per collected electron at the band edge is ~E<sub>g</sub>. Then “charge per energy” is q/E<sub>g</sub>, immediately giving R<sub>max</sub>.
        This is essentially the same physics, phrased as an energy-per-charge argument.
      </p>

      <h3>Concept check (self-test)</h3>
      <ul>
        <li><b>Q:</b> Why does responsivity increase with wavelength (before cutoff)?<br><b>A:</b> Longer λ means smaller photon energy hν, so each watt contains more photons; with one electron per photon, more electrons per second ⇒ larger A/W.</li>
        <li><b>Q:</b> Why can’t we take λ → ∞ to get infinite responsivity?<br><b>A:</b> Photons must satisfy hν ≥ E<sub>g</sub> to be absorbed; beyond λ<sub>g</sub> they don’t generate carriers.</li>
        <li><b>Q:</b> What does R<sub>max</sub> depend on for an ideal detector?<br><b>A:</b> Only E<sub>g</sub> (and η, M if non-ideal); geometry doesn’t appear in the ideal ceiling.</li>
      </ul>
    </section>

    <!-- Visualizations -->
    <section id="viz" class="card">
      <h2>Interactive Visualizations</h2>

      <div class="grid2">
        <figure>
          <canvas id="diagram" class="canvasTall" aria-label="Photodiode setup diagram"></canvas>
          <div class="caption">
            <b>Diagram:</b> Light of wavelength λ hits a semiconductor junction. Photons with <b>λ ≤ λ<sub>g</sub></b> (hν ≥ E<sub>g</sub>) generate carriers and current.
            Longer wavelengths are not absorbed (idealized edge).
          </div>
        </figure>

        <figure>
          <canvas id="plot1" aria-label="Responsivity vs wavelength plot"></canvas>
          <div class="caption">
            <b>Main plot:</b> Responsivity <b>R(λ)</b> rises linearly with λ up to the cutoff <b>λ<sub>g</sub></b>, where <b>R reaches R<sub>max</sub></b>.
            Beyond λ<sub>g</sub>, the curve drops to ~0 (no absorption).
          </div>
        </figure>
      </div>

      <figure style="margin-top:12px;">
        <canvas id="plot2" aria-label="Rmax versus quantum efficiency plot"></canvas>
        <div class="caption">
          <b>Secondary plot (parameter sweep):</b> Maximum responsivity <b>R<sub>max</sub>(η)</b> for the selected material.
          The η slider moves the marker and rescales both plots and the diagram annotations.
        </div>
      </figure>
    </section>

    <!-- PART 5 -->
    <section id="part5" class="card">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <h3>What each canvas shows</h3>
      <ul>
        <li><b>Diagram canvas:</b> A simplified photodiode geometry (incident light, junction, carrier collection) plus the bandgap threshold concept and cutoff wavelength λ<sub>g</sub>.</li>
        <li><b>Main plot (R vs λ):</b> The theoretical relation <span class="muted">R(λ) = ηM(qλ/hc)</span> for λ ≤ λ<sub>g</sub>, and ~0 for λ &gt; λ<sub>g</sub>.</li>
        <li><b>Secondary plot (R<sub>max</sub> vs η):</b> Shows that the maximum scales linearly with η (and also with M).</li>
      </ul>

      <h3>How the interactive controls work</h3>
      <ul>
        <li><b>Material selector:</b> changes E<sub>g</sub>, which changes λ<sub>g</sub> and the ideal ceiling R<sub>max</sub> = q/E<sub>g</sub>.</li>
        <li><b>η slider:</b> scales responsivity linearly: R → ηR and R<sub>max</sub> → ηR<sub>max</sub>.</li>
        <li><b>M slider:</b> also scales linearly (useful to visualize gain, though the posed problem fixes M = 1).</li>
      </ul>

      <div class="callout" style="margin-top:10px;">
        <div class="tag warn">Tip</div>
        <p class="muted" style="margin:6px 0 0;">
          Try selecting <b>InSb</b>: its small bandgap pushes λ<sub>g</sub> into the mid-IR and dramatically increases the ideal maximum A/W.
          This is exactly what the formula <b>R<sub>max</sub> ∝ 1/E<sub>g</sub></b> predicts.
        </p>
      </div>
    </section>

  </article>

  <nav class="toc" aria-label="Table of contents">
    <h2>Contents</h2>
    <a href="#quick-summary">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy &amp; Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#viz">Interactive Visualizations</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
    <div class="mini">
      Sticky TOC: click to jump. Scroll position is preserved with modern browsers.
    </div>
  </nav>
</main>

<footer>
  <p style="margin:0;">
    Notes: Numerical bandgaps used here are typical room-temperature example values often used in photonics texts
    (Si ≈ 1.12 eV, GaAs ≈ 1.42 eV, InSb ≈ 0.17 eV). Exact E<sub>g</sub> depends on temperature and material quality.
  </p>
</footer>

<script>
/* ---------- Copy buttons ---------- */
(function(){
  const toast = document.getElementById('toast');
  function showToast(msg){
    toast.textContent = msg;
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.textContent="", 1400);
  }
  document.querySelectorAll('button.copy').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const id = btn.getAttribute('data-copy-target');
      const el = document.getElementById(id);
      if(!el){ showToast("Nothing to copy."); return; }
      const text = el.innerText.replace(/\u00a0/g,' ').trim();
      try{
        await navigator.clipboard.writeText(text);
        showToast("Copied.");
      }catch(e){
        // fallback
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position='fixed';
        ta.style.left='-9999px';
        document.body.appendChild(ta);
        ta.select();
        try{ document.execCommand('copy'); showToast("Copied."); }
        catch(_){ showToast("Copy blocked by browser."); }
        document.body.removeChild(ta);
      }
    });
  });
})();

/* ---------- Physics model ---------- */
const CONST = {
  // SI constants (not strictly needed for eV shortcut, but used for plotting in SI units)
  q: 1.602176634e-19,      // C
  h: 6.62607015e-34,       // J*s
  c: 299792458             // m/s
};

// Typical room-temperature bandgaps (example values)
const MATERIALS = {
  "Si":   { name:"Silicon (Si)", Eg_eV: 1.12 },
  "GaAs": { name:"Gallium Arsenide (GaAs)", Eg_eV: 1.42 },
  "InSb": { name:"Indium Antimonide (InSb)", Eg_eV: 0.17 }
};

function lambda_g_um(Eg_eV){
  // λg [µm] ≈ 1.239841984 / Eg[eV]
  return 1.239841984 / Eg_eV;
}
function Rmax_ideal_A_per_W(Eg_eV){
  // For η=M=1: Rmax = q/Eg_J = 1/Eg_eV A/W
  return 1 / Eg_eV;
}
function R_lambda_A_per_W(lambda_m, Eg_eV, eta, M){
  // Piecewise: R = ηM qλ/(hc) for λ <= λg; else 0 (idealized)
  const lg_m = (lambda_g_um(Eg_eV) * 1e-6);
  if(lambda_m <= lg_m){
    return eta * M * (CONST.q * lambda_m) / (CONST.h * CONST.c);
  }
  return 0;
}

/* ---------- Populate results table (consistent with computed values) ---------- */
(function fillTable(){
  const tbody = document.getElementById('resultsTableBody');
  const rows = ["Si","GaAs","InSb"].map(k=>{
    const Eg = MATERIALS[k].Eg_eV;
    const lg = lambda_g_um(Eg);
    const Rm = Rmax_ideal_A_per_W(Eg);
    return `
      <tr>
        <td><b>${k}</b></td>
        <td>${Eg.toFixed(2)}</td>
        <td>${lg.toFixed(3)}</td>
        <td>${Rm.toFixed(3)}</td>
      </tr>
    `;
  }).join("");
  tbody.innerHTML = rows;
})();

/* ---------- Canvas helpers (high-DPI + axes) ---------- */
function setupHiDPICanvas(canvas){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(10, Math.floor(rect.width * dpr));
  const h = Math.max(10, Math.floor(rect.height * dpr));
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h;
  }
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  return { ctx, w: rect.width, h: rect.height, dpr };
}

function drawPanelTitle(ctx, x, y, title){
  ctx.save();
  ctx.font = "700 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillStyle = "rgba(234,240,255,.92)";
  ctx.fillText(title, x, y);
  ctx.restore();
}

function niceTicks(min, max, approxCount){
  // simple "nice" ticks for linear axis
  const span = max - min;
  if(span <= 0) return {step:1, ticks:[min]};
  const raw = span / Math.max(2, approxCount);
  const pow = Math.pow(10, Math.floor(Math.log10(raw)));
  const frac = raw / pow;
  let niceFrac = 1;
  if(frac < 1.5) niceFrac = 1;
  else if(frac < 3) niceFrac = 2;
  else if(frac < 7) niceFrac = 5;
  else niceFrac = 10;
  const step = niceFrac * pow;
  const start = Math.ceil(min/step)*step;
  const ticks = [];
  for(let v=start; v<=max+1e-12; v+=step) ticks.push(v);
  return {step, ticks};
}

function drawAxes(ctx, box, xRange, yRange, opts){
  const {x0,y0,w,h} = box;
  const padL = opts.padL ?? 52;
  const padR = opts.padR ?? 16;
  const padT = opts.padT ?? 24;
  const padB = opts.padB ?? 44;

  const plot = {
    x: x0 + padL,
    y: y0 + padT,
    w: w - padL - padR,
    h: h - padT - padB
  };

  // background
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,.18)";
  ctx.fillRect(x0, y0, w, h);

  // grid + ticks
  const xt = niceTicks(xRange.min, xRange.max, 6);
  const yt = niceTicks(yRange.min, yRange.max, 5);

  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 1;

  // vertical grid
  xt.ticks.forEach(v=>{
    const px = plot.x + (v - xRange.min) / (xRange.max - xRange.min) * plot.w;
    ctx.beginPath();
    ctx.moveTo(px, plot.y);
    ctx.lineTo(px, plot.y + plot.h);
    ctx.stroke();
  });

  // horizontal grid
  yt.ticks.forEach(v=>{
    const py = plot.y + plot.h - (v - yRange.min) / (yRange.max - yRange.min) * plot.h;
    ctx.beginPath();
    ctx.moveTo(plot.x, py);
    ctx.lineTo(plot.x + plot.w, py);
    ctx.stroke();
  });

  // axes
  ctx.strokeStyle = "rgba(255,255,255,.35)";
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(plot.x, plot.y);
  ctx.lineTo(plot.x, plot.y + plot.h);
  ctx.lineTo(plot.x + plot.w, plot.y + plot.h);
  ctx.stroke();

  // labels
  ctx.fillStyle = "rgba(234,240,255,.85)";
  ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";

  // x ticks
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  xt.ticks.forEach(v=>{
    const px = plot.x + (v - xRange.min) / (xRange.max - xRange.min) * plot.w;
    ctx.fillText(opts.formatX(v), px, plot.y + plot.h + 10);
    // tick mark
    ctx.strokeStyle = "rgba(255,255,255,.35)";
    ctx.beginPath();
    ctx.moveTo(px, plot.y + plot.h);
    ctx.lineTo(px, plot.y + plot.h + 6);
    ctx.stroke();
  });

  // y ticks
  ctx.textAlign = "right";
  ctx.textBaseline = "middle";
  yt.ticks.forEach(v=>{
    const py = plot.y + plot.h - (v - yRange.min) / (yRange.max - yRange.min) * plot.h;
    ctx.fillText(opts.formatY(v), plot.x - 8, py);
    // tick mark
    ctx.strokeStyle = "rgba(255,255,255,.35)";
    ctx.beginPath();
    ctx.moveTo(plot.x - 6, py);
    ctx.lineTo(plot.x, py);
    ctx.stroke();
  });

  // axis titles
  ctx.save();
  ctx.fillStyle = "rgba(183,195,230,.95)";
  ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillText(opts.xLabel, plot.x + plot.w/2, y0 + h - 20);

  ctx.translate(x0 + 16, plot.y + plot.h/2);
  ctx.rotate(-Math.PI/2);
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillText(opts.yLabel, 0, 0);
  ctx.restore();

  ctx.restore();

  function xToPx(x){ return plot.x + (x - xRange.min)/(xRange.max-xRange.min)*plot.w; }
  function yToPx(y){ return plot.y + plot.h - (y - yRange.min)/(yRange.max-yRange.min)*plot.h; }

  return {plot, xToPx, yToPx};
}

function legend(ctx, x, y, items){
  ctx.save();
  ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";
  const pad = 8, rowH = 18;
  const w = 220;
  const h = pad*2 + rowH*items.length;
  ctx.fillStyle = "rgba(0,0,0,.28)";
  ctx.strokeStyle = "rgba(255,255,255,.12)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(x, y, w, h, 12);
  ctx.fill();
  ctx.stroke();

  items.forEach((it,i)=>{
    const yy = y + pad + rowH*(i+0.5);
    ctx.strokeStyle = it.color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x+12, yy);
    ctx.lineTo(x+34, yy);
    ctx.stroke();
    ctx.fillStyle = "rgba(234,240,255,.9)";
    ctx.fillText(it.label, x+42, yy);
  });
  ctx.restore();
}
if(!CanvasRenderingContext2D.prototype.roundRect){
  CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    this.beginPath();
    this.moveTo(x+rr,y);
    this.arcTo(x+w,y, x+w,y+h, rr);
    this.arcTo(x+w,y+h, x,y+h, rr);
    this.arcTo(x,y+h, x,y, rr);
    this.arcTo(x,y, x+w,y, rr);
    this.closePath();
    return this;
  };
}

/* ---------- Drawing: diagram ---------- */
function drawDiagram(state){
  const canvas = document.getElementById('diagram');
  const {ctx, w, h} = setupHiDPICanvas(canvas);

  // clear
  ctx.clearRect(0,0,w,h);

  // panel title
  drawPanelTitle(ctx, 14, 18, "Setup diagram: bandgap-limited photodiode responsivity");

  // parameters
  const Eg = state.Eg_eV;
  const lg = lambda_g_um(Eg);
  const Rm = (state.eta * state.M) * Rmax_ideal_A_per_W(Eg);

  // draw a simple diode block
  const margin = 18;
  const bx = margin, by = 40, bw = w - 2*margin, bh = h - 60;
  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,.03)";
  ctx.strokeStyle = "rgba(255,255,255,.14)";
  ctx.lineWidth = 1.2;
  ctx.roundRect(bx, by, bw, bh, 18);
  ctx.fill();
  ctx.stroke();

  // junction line
  const jx = bx + bw*0.55;
  ctx.strokeStyle = "rgba(124,183,255,.55)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(jx, by+20);
  ctx.lineTo(jx, by+bh-20);
  ctx.stroke();

  // P and N regions
  ctx.fillStyle = "rgba(176,124,255,.12)";
  ctx.fillRect(bx+12, by+12, jx-(bx+12)-2, bh-24);
  ctx.fillStyle = "rgba(124,255,178,.10)";
  ctx.fillRect(jx+2, by+12, (bx+bw-12)-(jx+2), bh-24);

  // labels
  ctx.fillStyle = "rgba(234,240,255,.92)";
  ctx.font = "700 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText("p-region", bx+26, by+34);
  ctx.fillText("n-region", jx+18, by+34);
  ctx.fillText("junction", jx-26, by+bh-22);

  // incoming light arrow
  const ax0 = bx + 16;
  const ay = by + bh*0.55;
  ctx.strokeStyle = "rgba(255,210,124,.85)";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(bx - 6, ay);
  ctx.lineTo(ax0, ay);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(ax0, ay);
  ctx.lineTo(ax0-10, ay-7);
  ctx.lineTo(ax0-10, ay+7);
  ctx.closePath();
  ctx.fillStyle = "rgba(255,210,124,.85)";
  ctx.fill();

  ctx.fillStyle = "rgba(234,240,255,.9)";
  ctx.font = "12.5px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText("incident light", bx - 2, ay - 12);
  ctx.fillText("wavelength λ", bx - 2, ay + 16);

  // carriers
  ctx.fillStyle = "rgba(124,183,255,.95)";
  for(let i=0;i<8;i++){
    const x = jx + (Math.random()*0.38+0.02)*bw*0.35;
    const y = by + 50 + Math.random()*(bh-110);
    ctx.beginPath();
    ctx.arc(x, y, 3.2, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.fillStyle = "rgba(176,124,255,.95)";
  for(let i=0;i<8;i++){
    const x = jx - (Math.random()*0.38+0.02)*bw*0.35;
    const y = by + 50 + Math.random()*(bh-110);
    ctx.beginPath();
    ctx.arc(x, y, 3.2, 0, Math.PI*2);
    ctx.fill();
  }

  // bandgap note
  ctx.fillStyle = "rgba(183,195,230,.95)";
  ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText("Absorption condition:", bx+22, by+bh-52);
  ctx.fillStyle = "rgba(234,240,255,.9)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
  ctx.fillText("hν ≥ Eg  ⇔  λ ≤ λg = hc/Eg", bx+22, by+bh-33);

  // numeric summary on diagram
  const boxW = Math.min(360, bw-24);
  const boxX = bx + bw - boxW - 14;
  const boxY = by + 16;
  ctx.fillStyle = "rgba(0,0,0,.28)";
  ctx.strokeStyle = "rgba(255,255,255,.14)";
  ctx.lineWidth = 1;
  ctx.roundRect(boxX, boxY, boxW, 82, 14);
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = "rgba(234,240,255,.92)";
  ctx.font = "700 12.5px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText(state.materialName, boxX+12, boxY+20);
  ctx.fillStyle = "rgba(183,195,230,.95)";
  ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText(`Eg ≈ ${Eg.toFixed(2)} eV`, boxX+12, boxY+40);
  ctx.fillText(`λg ≈ ${lg.toFixed(3)} µm`, boxX+12, boxY+58);
  ctx.fillText(`Rmax = ηM·q/Eg ≈ ${Rm.toFixed(3)} A/W`, boxX+12, boxY+76);

  ctx.restore();
}

/* ---------- Drawing: Plot 1 (R vs λ) ---------- */
function drawPlot1(state){
  const canvas = document.getElementById('plot1');
  const {ctx, w, h} = setupHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  const Eg = state.Eg_eV;
  const lg_um = lambda_g_um(Eg);
  const lg = lg_um; // in µm for x-axis
  const eta = state.eta;
  const M = state.M;

  // x range: 0 to 1.5*lg
  const xMin = 0;
  const xMax = Math.max(0.5, 1.5*lg);

  // y max: a bit above Rmax (with eta,M)
  const Rmax = eta * M * Rmax_ideal_A_per_W(Eg);
  const yMin = 0;
  const yMax = Math.max(0.2, Rmax*1.15);

  const ax = drawAxes(ctx, {x0:0,y0:0,w,h}, {min:xMin,max:xMax}, {min:yMin,max:yMax}, {
    padL: 56, padR: 14, padT: 28, padB: 46,
    xLabel: "Wavelength λ (µm)",
    yLabel: "Responsivity R (A/W)",
    formatX: v => (v>=10 ? v.toFixed(0) : v.toFixed(2)).replace(/\.00$/,""),
    formatY: v => (v>=10 ? v.toFixed(0) : v.toFixed(2)).replace(/\.00$/,"")
  });

  drawPanelTitle(ctx, 14, 18, "Responsivity vs wavelength (bandgap cutoff)");

  // curve
  ctx.save();
  ctx.strokeStyle = "rgba(124,183,255,.95)";
  ctx.lineWidth = 2.6;
  ctx.beginPath();

  const N = 400;
  for(let i=0;i<=N;i++){
    const x = xMin + (xMax-xMin)*i/N; // µm
    const lambda_m = x * 1e-6;
    const R = R_lambda_A_per_W(lambda_m, Eg, eta, M);
    const px = ax.xToPx(x);
    const py = ax.yToPx(R);
    if(i===0) ctx.moveTo(px,py);
    else ctx.lineTo(px,py);
  }
  ctx.stroke();

  // cutoff marker at lg
  const pxg = ax.xToPx(lg);
  ctx.strokeStyle = "rgba(255,210,124,.85)";
  ctx.lineWidth = 2;
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.moveTo(pxg, ax.plot.y);
  ctx.lineTo(pxg, ax.plot.y + ax.plot.h);
  ctx.stroke();
  ctx.setLineDash([]);

  // dot at (lg, Rmax)
  const pyg = ax.yToPx(Rmax);
  ctx.fillStyle = "rgba(255,210,124,.9)";
  ctx.beginPath();
  ctx.arc(pxg, pyg, 4.2, 0, Math.PI*2);
  ctx.fill();

  // annotation box
  ctx.fillStyle = "rgba(0,0,0,.32)";
  ctx.strokeStyle = "rgba(255,255,255,.14)";
  ctx.lineWidth = 1;
  const bx = Math.min(ax.plot.x + ax.plot.w - 240, pxg + 10);
  const by = ax.plot.y + 12;
  ctx.roundRect(bx, by, 230, 58, 12);
  ctx.fill();
  ctx.stroke();
  ctx.fillStyle = "rgba(234,240,255,.92)";
  ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText("Maximum at λ = λg", bx+10, by+18);
  ctx.fillStyle = "rgba(183,195,230,.95)";
  ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText(`λg ≈ ${lg.toFixed(3)} µm`, bx+10, by+36);
  ctx.fillText(`Rmax ≈ ${Rmax.toFixed(3)} A/W`, bx+10, by+52);

  legend(ctx, ax.plot.x + 10, ax.plot.y + 10, [
    {color:"rgba(124,183,255,.95)", label:"R(λ) = ηM qλ/(hc) (λ≤λg)"},
    {color:"rgba(255,210,124,.85)", label:"Cutoff at λg"}
  ]);

  ctx.restore();
}

/* ---------- Drawing: Plot 2 (Rmax vs η) ---------- */
function drawPlot2(state){
  const canvas = document.getElementById('plot2');
  const {ctx, w, h} = setupHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  const Eg = state.Eg_eV;
  const M = state.M;

  const xMin = 0, xMax = 1; // η
  const RmaxIdeal = Rmax_ideal_A_per_W(Eg);
  const yMin = 0;
  const yMax = Math.max(0.2, (M * RmaxIdeal)*1.15);

  const ax = drawAxes(ctx, {x0:0,y0:0,w,h}, {min:xMin,max:xMax}, {min:yMin,max:yMax}, {
    padL: 56, padR: 14, padT: 28, padB: 46,
    xLabel: "Quantum efficiency η (dimensionless)",
    yLabel: "Maximum responsivity Rmax (A/W)",
    formatX: v => v.toFixed(1),
    formatY: v => (v>=10 ? v.toFixed(0) : v.toFixed(2)).replace(/\.00$/,"")
  });

  drawPanelTitle(ctx, 14, 18, "Parameter sweep: Rmax versus quantum efficiency (material-dependent slope)");

  // line: Rmax(η)=η*M*(1/Eg)
  ctx.save();
  ctx.strokeStyle = "rgba(176,124,255,.95)";
  ctx.lineWidth = 2.6;
  ctx.beginPath();
  const N = 200;
  for(let i=0;i<=N;i++){
    const eta = xMin + (xMax-xMin)*i/N;
    const Rm = eta * M * RmaxIdeal;
    const px = ax.xToPx(eta);
    const py = ax.yToPx(Rm);
    if(i===0) ctx.moveTo(px,py);
    else ctx.lineTo(px,py);
  }
  ctx.stroke();

  // marker at current eta
  const eta = state.eta;
  const Rm = eta * M * RmaxIdeal;
  const px = ax.xToPx(eta);
  const py = ax.yToPx(Rm);
  ctx.fillStyle = "rgba(124,255,178,.92)";
  ctx.beginPath();
  ctx.arc(px, py, 4.6, 0, Math.PI*2);
  ctx.fill();

  // small guide lines
  ctx.strokeStyle = "rgba(124,255,178,.55)";
  ctx.lineWidth = 1.5;
  ctx.setLineDash([5,5]);
  ctx.beginPath();
  ctx.moveTo(px, ax.plot.y + ax.plot.h);
  ctx.lineTo(px, py);
  ctx.moveTo(ax.plot.x, py);
  ctx.lineTo(px, py);
  ctx.stroke();
  ctx.setLineDash([]);

  // annotation
  ctx.fillStyle = "rgba(0,0,0,.32)";
  ctx.strokeStyle = "rgba(255,255,255,.14)";
  ctx.lineWidth = 1;
  const bx = Math.min(ax.plot.x + ax.plot.w - 260, px + 10);
  const by = ax.plot.y + 12;
  ctx.roundRect(bx, by, 250, 58, 12);
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = "rgba(234,240,255,.92)";
  ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText("Current setting", bx+10, by+18);
  ctx.fillStyle = "rgba(183,195,230,.95)";
  ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText(`η = ${eta.toFixed(2)} ,  M = ${M.toFixed(1)}`, bx+10, by+36);
  ctx.fillText(`Rmax = ηM/Eg ≈ ${Rm.toFixed(3)} A/W`, bx+10, by+52);

  legend(ctx, ax.plot.x + 10, ax.plot.y + 10, [
    {color:"rgba(176,124,255,.95)", label:"Rmax(η) = η·M·(1/Eg)"},
    {color:"rgba(124,255,178,.92)", label:"Current η"}
  ]);

  ctx.restore();
}

/* ---------- State + UI wiring ---------- */
const UI = {
  matSel: document.getElementById('matSel'),
  matLabel: document.getElementById('matLabel'),
  egInfo: document.getElementById('egInfo'),
  etaRange: document.getElementById('etaRange'),
  etaLabel: document.getElementById('etaLabel'),
  gainRange: document.getElementById('gainRange'),
  gainLabel: document.getElementById('gainLabel'),
  liveReadout: document.getElementById('liveReadout')
};

const state = {
  materialKey: UI.matSel.value,
  get materialName(){ return MATERIALS[this.materialKey].name; },
  get Eg_eV(){ return MATERIALS[this.materialKey].Eg_eV; },
  eta: parseFloat(UI.etaRange.value),
  M: parseFloat(UI.gainRange.value)
};

function updateReadouts(){
  UI.matLabel.textContent = state.materialKey;
  UI.etaLabel.textContent = state.eta.toFixed(2);
  UI.gainLabel.textContent = state.M.toFixed(1);

  const Eg = state.Eg_eV;
  const lg = lambda_g_um(Eg);
  const RmaxIdeal = Rmax_ideal_A_per_W(Eg);
  const Rmax = state.eta * state.M * RmaxIdeal;

  UI.egInfo.innerHTML = `E<sub>g</sub> ≈ ${Eg.toFixed(2)} eV (example, ~300 K)`;
  UI.liveReadout.innerHTML =
    `<div style="display:grid;gap:6px;">
      <div><b>Material:</b> ${state.materialName}</div>
      <div><b>Bandgap:</b> E<sub>g</sub> ≈ ${Eg.toFixed(2)} eV</div>
      <div><b>Cutoff wavelength:</b> λ<sub>g</sub> = hc/E<sub>g</sub> ≈ ${lg.toFixed(3)} µm</div>
      <div><b>Maximum responsivity:</b> R<sub>max</sub> = η M (q/E<sub>g</sub>) ≈ <b>${Rmax.toFixed(3)} A/W</b></div>
      <div class="muted" style="font-size:12.5px;">
        (Ideal case for the question: set η = 1.00 and M = 1.0.)
      </div>
    </div>`;
}

function renderAll(){
  updateReadouts();
  drawDiagram(state);
  drawPlot1(state);
  drawPlot2(state);
}

UI.matSel.addEventListener('change', ()=>{
  state.materialKey = UI.matSel.value;
  renderAll();
});
UI.etaRange.addEventListener('input', ()=>{
  state.eta = parseFloat(UI.etaRange.value);
  renderAll();
});
UI.gainRange.addEventListener('input', ()=>{
  state.M = parseFloat(UI.gainRange.value);
  renderAll();
});

// Redraw on resize (responsive)
const ro = new ResizeObserver(()=>renderAll());
["diagram","plot1","plot2"].forEach(id=>ro.observe(document.getElementById(id)));

renderAll();
</script>
</body>
</html>
