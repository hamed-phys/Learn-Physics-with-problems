<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <title>Paraxial Helmholtz Equation & Conjugate Waves — Structured Solution</title>
  <style>
    :root{
      --bg: #0b0d12;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.09);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --faint: rgba(255,255,255,0.45);
      --border: rgba(255,255,255,0.14);
      --accent: #7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --shadow: 0 18px 55px rgba(0,0,0,0.35);
      --radius: 18px;
      --radius2: 14px;
      --maxw: 1100px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background:
        radial-gradient(1200px 800px at 15% 10%, rgba(125,211,252,0.16), transparent 55%),
        radial-gradient(900px 700px at 85% 20%, rgba(167,139,250,0.14), transparent 60%),
        radial-gradient(900px 700px at 60% 90%, rgba(52,211,153,0.08), transparent 62%),
        linear-gradient(180deg, #07080b 0%, #0b0d12 30%, #0a0c11 100%);
      line-height: 1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding: 28px 18px 8px;
    }
    .wrap{
      width:min(var(--maxw), calc(100% - 32px));
      margin: 0 auto;
    }
    .hero{
      background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 22px 20px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position: relative;
    }
    .hero:before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(800px 280px at 15% 20%, rgba(125,211,252,0.12), transparent 60%),
        radial-gradient(700px 260px at 80% 15%, rgba(167,139,250,0.10), transparent 60%);
      filter: blur(10px);
      pointer-events:none;
      opacity:0.9;
    }
    .hero > *{position:relative}
    h1{
      margin: 0 0 6px;
      font-size: clamp(1.35rem, 2.5vw, 2.05rem);
      letter-spacing: 0.2px;
    }
    .subtitle{
      margin:0;
      color: var(--muted);
      font-size: 0.98rem;
    }

    main{
      padding: 14px 18px 40px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.3fr 0.7fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr}
    }

    .card{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px;
      overflow:hidden;
    }
    .card h2, .card h3{
      margin: 0 0 10px;
      font-size: 1.05rem;
      letter-spacing:0.15px;
    }
    .card h3{font-size: 1rem}
    .muted{color:var(--muted)}
    .small{font-size:0.92rem}
    .pill{
      display:inline-flex; gap:8px; align-items:center;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      color: var(--muted);
      font-size: 0.86rem;
      margin: 8px 8px 0 0;
      user-select:none;
    }
    .pill b{color:var(--text); font-weight:650}

    /* Sticky TOC */
    .toc{
      position: sticky;
      top: 12px;
      padding: 14px;
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    .toc h3{margin:0 0 10px}
    .toc a{
      display:block;
      padding: 7px 10px;
      border-radius: 10px;
      color: var(--muted);
      border: 1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .toc a:hover{
      background: rgba(255,255,255,0.06);
      border-color: rgba(255,255,255,0.12);
      transform: translateX(2px);
      color: var(--text);
      text-decoration:none;
    }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
    }
    @media (max-width: 700px){ .callouts{grid-template-columns: 1fr} }

    .callout{
      border-radius: var(--radius2);
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      padding: 12px;
      position:relative;
      overflow:hidden;
    }
    .callout:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(500px 220px at 20% 0%, rgba(125,211,252,0.10), transparent 60%);
      opacity:0.7;
      pointer-events:none;
    }
    .callout > *{position:relative}
    .kpi{
      font-family: var(--mono);
      font-size: 0.92rem;
      color: var(--text);
      background: rgba(0,0,0,0.15);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 8px 10px;
      border-radius: 12px;
      overflow:auto;
    }

    /* Equation blocks + copy buttons */
    .eqwrap{
      position:relative;
      margin: 10px 0 14px;
      border-radius: var(--radius2);
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      padding: 10px 10px 10px;
    }
    .eq{
      font-family: var(--mono);
      font-size: 0.94rem;
      white-space: pre-wrap;
      margin: 0;
      color: rgba(255,255,255,0.92);
    }
    .copybtn{
      position:absolute;
      top: 10px;
      right: 10px;
      padding: 7px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      cursor:pointer;
      font-size: 0.84rem;
      transition: transform .12s ease, background .12s ease;
      user-select:none;
    }
    .copybtn:hover{transform: translateY(-1px); background: rgba(255,255,255,0.10);}
    .copybtn:active{transform: translateY(0px) scale(0.99);}

    /* Viz */
    .vizgrid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 12px;
    }
    .viz{
      padding: 12px;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
    }
    .vizhead{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:12px;
      margin-bottom: 10px;
    }
    .viztitle{margin:0; font-size:0.98rem}
    .vizmeta{color:var(--muted); font-size:0.86rem}
    canvas{
      width: 100%;
      height: 330px;
      display:block;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
    }
    @media (max-width: 520px){
      canvas{height: 280px;}
    }

    /* Controls */
    .controls{
      display:grid;
      gap: 12px;
      margin-top: 10px;
    }
    .ctrl{
      border: 1px solid var(--border);
      border-radius: var(--radius2);
      background: rgba(255,255,255,0.05);
      padding: 10px;
    }
    .ctrl label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      color: var(--muted);
      font-size: 0.9rem;
      margin-bottom: 8px;
    }
    .ctrl input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .ctrl select{
      width:100%;
      padding: 9px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.25);
      color: var(--text);
      outline:none;
    }
    .row2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 980px){ .row2{grid-template-columns:1fr} }

    /* Sections */
    section{scroll-margin-top: 78px;}
    .partTitle{
      display:flex; align-items:center; gap:10px;
      margin: 0 0 10px;
      font-size: 1.1rem;
    }
    .badge{
      font-family: var(--mono);
      font-size:0.78rem;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      color: var(--muted);
      background: rgba(255,255,255,0.06);
    }
    ul{margin: 8px 0 0 18px}
    li{margin: 6px 0}
    .hr{
      height:1px; background: rgba(255,255,255,0.10);
      margin: 14px 0;
    }
    .boxFinal{
      border-radius: var(--radius);
      padding: 14px;
      border: 1px solid rgba(125,211,252,0.26);
      background: linear-gradient(180deg, rgba(125,211,252,0.14), rgba(125,211,252,0.05));
    }
    .boxFinal h3{margin:0 0 8px}
    .note{
      border-left: 4px solid rgba(167,139,250,0.65);
      padding: 10px 12px;
      background: rgba(167,139,250,0.08);
      border-radius: 12px;
      margin: 12px 0;
      color: rgba(255,255,255,0.88);
    }
    footer{
      padding: 18px;
      color: var(--faint);
      text-align:center;
    }

    /* Print */
    @media print{
      body{background:#fff; color:#000}
      .card,.toc,.hero,.viz{box-shadow:none}
      .toc{position:static}
      .copybtn{display:none}
      canvas{border:1px solid #999; background:#fff}
      a{color:#000; text-decoration:underline}
    }
  </style>
</head>

<body>
  <header>
    <div class="wrap">
      <div class="hero">
        <h1>Paraxial Helmholtz Equation (2.2-23) &amp; Conjugate Waves (2.2-7)</h1>
        <p class="subtitle">
          A self-contained, step-by-step derivation of the paraxial wave equation using the slowly-varying envelope approximation,
          plus a physical comparison between <span style="font-family:var(--mono)">U(r)</span> and its complex conjugate <span style="font-family:var(--mono)">U*(r)</span>.
        </p>

        <div class="callouts">
          <div class="callout">
            <h2 style="margin:0 0 8px; font-size:1.02rem;">Quick Summary</h2>
            <ul class="small muted" style="margin-top:6px">
              <li>Write the field as <span style="font-family:var(--mono)">U = A(x,y,z) e^{-j k z}</span> with a slowly varying envelope <span style="font-family:var(--mono)">A</span>.</li>
              <li>Substitute into Helmholtz: <span style="font-family:var(--mono)">∇²U + k²U = 0</span>.</li>
              <li>Neglect <span style="font-family:var(--mono)">∂²A/∂z²</span> compared to <span style="font-family:var(--mono)">k ∂A/∂z</span> and <span style="font-family:var(--mono)">k²A</span> (the paraxial/SVEA conditions).</li>
              <li>Result: <span style="font-family:var(--mono)">∇_T² A − j 2k ∂A/∂z = 0</span> (paraxial Helmholtz equation).</li>
              <li>Conjugation flips phase sign: wavefronts are the same surfaces, but normals (energy flow direction) reverse.</li>
              <li>For plane waves, <span style="font-family:var(--mono)">U*</span> propagates opposite; for spherical waves, <span style="font-family:var(--mono)">U*</span> is an incoming (converging) spherical wave.</li>
            </ul>
          </div>

          <div class="callout">
            <h2 style="margin:0 0 8px; font-size:1.02rem;">Symbols (used in text &amp; plots)</h2>
            <div class="kpi" id="symKpi">
k = 2π/λ  (wavenumber)   [rad/m]
λ          (wavelength)  [m]
j = √(-1)
U(r)       complex field
A(x,y,z)   slowly-varying envelope
∇_T² = ∂²/∂x² + ∂²/∂y²   (transverse Laplacian)
            </div>
            <div class="pill"><span>Example values for plots:</span> <b id="exVals">λ = 1.55 µm</b></div>
          </div>
        </div>
      </div>
    </div>
  </header>

  <main>
    <div class="wrap grid">
      <article class="card">
        <section id="part1">
          <div class="partTitle"><span class="badge">PART 1</span><span>Problem Analysis</span></div>

          <h2>Restate the tasks (in plain words)</h2>
          <p class="muted">
            <b>(2.2-6)</b> Start from the scalar Helmholtz equation and show how, under “paraxial / slowly-varying envelope”
            assumptions (2.2-21) and (2.2-22), it reduces to the paraxial Helmholtz equation (2.2-23).
            <br><br>
            <b>(2.2-7)</b> Compare a monochromatic wave with complex amplitude <span style="font-family:var(--mono)">U(r)</span>
            to one with the same frequency but complex amplitude <span style="font-family:var(--mono)">U*(r)</span>:
            compare <b>intensity</b>, <b>wavefronts</b> (constant-phase surfaces), and <b>wavefront normals</b>.
            Use a specific plane-wave and spherical-wave example.
          </p>

          <div class="hr"></div>

          <h3>Given quantities</h3>
          <ul class="muted small">
            <li>Helmholtz equation for monochromatic scalar fields: <span style="font-family:var(--mono)">∇²U + k²U = 0</span>.</li>
            <li>Envelope ansatz (implied by the text): <span style="font-family:var(--mono)">U(x,y,z) = A(x,y,z) e^{-j k z}</span> (carrier mainly along +z).</li>
            <li>Approximations (slow z-variation of envelope):
              <ul>
                <li>(2.2-21) <span style="font-family:var(--mono)">|∂A/∂z| &ll; k |A|</span></li>
                <li>(2.2-22) <span style="font-family:var(--mono)">|∂²A/∂z²| &ll; k² |A|</span> (and in practice also &ll; <span style="font-family:var(--mono)">k|∂A/∂z|</span>)</li>
              </ul>
            </li>
            <li>Examples for conjugate waves:
              <ul>
                <li>Plane wave: <span style="font-family:var(--mono)">U(r)=A exp[-j k (x+y)/√2]</span></li>
                <li>Spherical wave: <span style="font-family:var(--mono)">U(r)=(A/r) exp(-j k r)</span></li>
              </ul>
            </li>
          </ul>

          <h3>Unknowns / what must be shown</h3>
          <ul class="muted small">
            <li>Derive: <span style="font-family:var(--mono)">∇_T² A − j 2k ∂A/∂z = 0</span> (paraxial Helmholtz equation).</li>
            <li>Explain how <span style="font-family:var(--mono)">U*</span> changes (or does not change) intensity, wavefronts, and wavefront normals, using the given examples.</li>
          </ul>

          <h3>Relevant physical principles and why they apply</h3>
          <ul class="muted small">
            <li><b>Monochromatic wave representation:</b> A time-harmonic field can be written as <span style="font-family:var(--mono)">Re{U(r) e^{+jωt}}</span>. The spatial complex amplitude <span style="font-family:var(--mono)">U(r)</span> satisfies Helmholtz in homogeneous media.</li>
            <li><b>Carrier + envelope (paraxial/SVEA):</b> If the wave propagates mainly along +z, factor out the rapid phase <span style="font-family:var(--mono)">e^{-jkz}</span>. The remaining envelope varies slowly compared to one wavelength, enabling the approximation.</li>
            <li><b>Wavefronts and normals:</b> Constant-phase surfaces come from <span style="font-family:var(--mono)">arg(U)</span>. The local propagation (wavevector direction) is normal to these phase surfaces; conjugating flips the phase sign and therefore flips the normal direction.</li>
          </ul>

          <h3>Possible solution approaches</h3>
          <ul class="muted small">
            <li><b>Direct substitution approach (best):</b> Insert <span style="font-family:var(--mono)">U=A e^{-jkz}</span> into Helmholtz, expand derivatives, then apply the inequalities (2.2-21, 2.2-22).</li>
            <li><b>Fourier/Angular spectrum approach:</b> Expand fields into plane-wave components and apply small-angle approximation. Powerful for optics, but longer for this derivation.</li>
            <li><b>Geometric optics/WKB style:</b> Write <span style="font-family:var(--mono)">U= a e^{jS}</span> and expand in powers of k. Insightful, but not as directly tied to equations (2.2-21, 2.2-22).</li>
          </ul>
          <p class="note small">
            We’ll use the <b>direct substitution</b> approach because it maps one-to-one onto the given approximations and yields (2.2-23) cleanly.
          </p>
        </section>

        <section id="part2" style="margin-top:16px;">
          <div class="partTitle"><span class="badge">PART 2</span><span>Strategy &amp; Tips</span></div>

          <h2>Roadmap (no algebra yet)</h2>
          <ol class="muted small">
            <li><b>Goal:</b> Start from Helmholtz. <b>Tool:</b> <span style="font-family:var(--mono)">∇²U + k²U = 0</span>.</li>
            <li><b>Goal:</b> Separate fast z-phase. <b>Tool:</b> Use <span style="font-family:var(--mono)">U=A e^{-jkz}</span>.</li>
            <li><b>Goal:</b> Compute derivatives. <b>Tool:</b> Product rule for <span style="font-family:var(--mono)">∂/∂z</span> and Laplacian.</li>
            <li><b>Goal:</b> Group transverse vs longitudinal terms. <b>Tool:</b> Define <span style="font-family:var(--mono)">∇_T² = ∂²/∂x² + ∂²/∂y²</span>.</li>
            <li><b>Goal:</b> Apply paraxial/SVEA inequalities. <b>Tool:</b> Neglect <span style="font-family:var(--mono)">∂²A/∂z²</span> relative to dominant terms.</li>
            <li><b>Goal:</b> Arrive at (2.2-23). <b>Tool:</b> Simplify to first-order-in-z equation.</li>
            <li><b>Goal:</b> Conjugate-wave comparison. <b>Tool:</b> Use properties: <span style="font-family:var(--mono)">|U*|²=|U|²</span>, <span style="font-family:var(--mono)">arg(U*) = -arg(U)</span>.</li>
            <li><b>Goal:</b> Apply to plane and spherical examples. <b>Tool:</b> Identify phase surfaces and their normals (direction of increasing phase).</li>
          </ol>

          <h3>Common mistakes &amp; quick tips</h3>
          <ul class="muted small">
            <li><b>Sign confusion:</b> If you choose time dependence <span style="font-family:var(--mono)">e^{+jωt}</span> vs <span style="font-family:var(--mono)">e^{-jωt}</span>, the spatial phase sign conventions shift. Stay consistent.</li>
            <li><b>Dropping the wrong term:</b> In paraxial derivation, you drop <span style="font-family:var(--mono)">∂²A/∂z²</span>, not <span style="font-family:var(--mono)">∂A/∂z</span>. Keeping <span style="font-family:var(--mono)">∂A/∂z</span> is what makes the equation a propagation equation.</li>
            <li><b>Wavefront normal direction:</b> The wavefront normal for <span style="font-family:var(--mono)">U*</span> is reversed because the phase gradient flips sign.</li>
            <li><b>Spherical wave intuition:</b> <span style="font-family:var(--mono)">exp(-jkr)/r</span> is outward (with the chosen convention); its conjugate <span style="font-family:var(--mono)">exp(+jkr)/r</span> is inward (time-reversed) propagation.</li>
          </ul>
        </section>

        <section id="part3" style="margin-top:16px;">
          <div class="partTitle"><span class="badge">PART 3</span><span>Full Solution</span></div>

          <h2>Physical intuition first</h2>
          <p class="muted">
            The Helmholtz equation allows waves traveling in many directions. In many optical systems (lasers, beams),
            the wave is predominantly along the +z axis, with only small angular spread (“paraxial”).
            That means the field oscillates rapidly as <span style="font-family:var(--mono)">e^{-jkz}</span>,
            while the transverse profile (and any additional phase curvature) changes slowly with z.
            Factoring out the fast oscillation leaves an envelope <span style="font-family:var(--mono)">A</span>
            whose second derivative in z is small compared to terms proportional to k.
          </p>

          <div class="hr"></div>

          <h2>(2.2-6) Derive the paraxial Helmholtz equation</h2>

          <h3>1) Start from Helmholtz</h3>
          <div class="eqwrap">
            <button class="copybtn" data-copy="∇²U + k²U = 0">Copy</button>
            <pre class="eq">∇²U + k²U = 0</pre>
          </div>

          <h3>2) Use carrier-envelope form (main propagation along +z)</h3>
          <p class="muted small">Let</p>
          <div class="eqwrap">
            <button class="copybtn" data-copy="U(x,y,z) = A(x,y,z) e^{-j k z}">Copy</button>
            <pre class="eq">U(x,y,z) = A(x,y,z) e^{-j k z}</pre>
          </div>
          <p class="muted small">
            where <span style="font-family:var(--mono)">A</span> varies slowly in z over a distance of order λ:
            <span style="font-family:var(--mono)">|∂A/∂z| &ll; k|A|</span> and
            <span style="font-family:var(--mono)">|∂²A/∂z²| &ll; k²|A|</span>.
          </p>

          <h3>3) Expand the Laplacian</h3>
          <p class="muted small">
            Split the Laplacian into transverse and longitudinal parts:
            <span style="font-family:var(--mono)">∇² = ∇_T² + ∂²/∂z²</span>, where
            <span style="font-family:var(--mono)">∇_T² = ∂²/∂x² + ∂²/∂y²</span>.
          </p>

          <h3>4) Compute z-derivatives (step-by-step)</h3>
          <p class="muted small">First derivative:</p>
          <div class="eqwrap">
            <button class="copybtn" data-copy="∂U/∂z = (∂A/∂z - j k A) e^{-j k z}">Copy</button>
            <pre class="eq">∂U/∂z = (∂A/∂z - j k A) e^{-j k z}</pre>
          </div>

          <p class="muted small">Second derivative:</p>
          <div class="eqwrap">
            <button class="copybtn" data-copy="∂²U/∂z² = (∂²A/∂z² - j 2k ∂A/∂z - k² A) e^{-j k z}">Copy</button>
            <pre class="eq">∂²U/∂z² = (∂²A/∂z² - j 2k ∂A/∂z - k² A) e^{-j k z}</pre>
          </div>

          <p class="muted small">
            Transverse derivatives simply pass through the carrier (because <span style="font-family:var(--mono)">e^{-jkz}</span> depends only on z):
          </p>
          <div class="eqwrap">
            <button class="copybtn" data-copy="∇_T² U = (∇_T² A) e^{-j k z}">Copy</button>
            <pre class="eq">∇_T² U = (∇_T² A) e^{-j k z}</pre>
          </div>

          <h3>5) Substitute into Helmholtz and simplify</h3>
          <p class="muted small">
            Using <span style="font-family:var(--mono)">∇²U = ∇_T²U + ∂²U/∂z²</span>:
          </p>
          <div class="eqwrap">
            <button class="copybtn" data-copy="(∇_T²A + ∂²A/∂z² - j 2k ∂A/∂z - k²A)e^{-jkz} + k²(A e^{-jkz}) = 0">Copy</button>
            <pre class="eq">(∇_T²A + ∂²A/∂z² - j 2k ∂A/∂z - k²A)e^{-jkz} + k²(A e^{-jkz}) = 0</pre>
          </div>
          <p class="muted small">
            The <span style="font-family:var(--mono)">-k²A</span> term cancels the <span style="font-family:var(--mono)">+k²A</span> term, leaving:
          </p>
          <div class="eqwrap">
            <button class="copybtn" data-copy="∇_T²A + ∂²A/∂z² - j 2k ∂A/∂z = 0">Copy</button>
            <pre class="eq">∇_T²A + ∂²A/∂z² - j 2k ∂A/∂z = 0</pre>
          </div>

          <h3>6) Apply the paraxial/SVEA approximations (2.2-21) and (2.2-22)</h3>
          <p class="muted small">
            The assumptions say that the envelope does not change appreciably over one wavelength, so the second z-derivative is small:
            <span style="font-family:var(--mono)">|∂²A/∂z²| &ll; k|∂A/∂z|</span> and <span style="font-family:var(--mono)">|∂²A/∂z²| &ll; k²|A|</span>.
            Therefore we neglect <span style="font-family:var(--mono)">∂²A/∂z²</span> compared to the other terms.
          </p>

          <div class="boxFinal" id="finalBox">
            <h3>Final result (Paraxial Helmholtz Equation, 2.2-23)</h3>
            <div class="eqwrap" style="margin:0">
              <button class="copybtn" data-copy="∇_T² A − j 2k (∂A/∂z) = 0">Copy</button>
              <pre class="eq">∇_T² A − j 2k (∂A/∂z) = 0</pre>
            </div>
            <p class="muted small" style="margin:10px 0 0">
              This is a <b>first-order propagation equation</b> in z: given <span style="font-family:var(--mono)">A(x,y,0)</span>, it predicts how the envelope evolves for z &gt; 0.
            </p>
          </div>

          <h3>Sanity checks</h3>
          <ul class="muted small">
            <li><b>Units:</b> <span style="font-family:var(--mono)">∇_T²A</span> has units of <span style="font-family:var(--mono)">A/m²</span>. The term <span style="font-family:var(--mono)">2k ∂A/∂z</span> also has <span style="font-family:var(--mono)">1/m × A/m = A/m²</span>. Consistent.</li>
            <li><b>Limiting case:</b> If <span style="font-family:var(--mono)">A</span> is independent of x,y, then <span style="font-family:var(--mono)">∇_T²A=0</span> and the equation gives <span style="font-family:var(--mono)">∂A/∂z=0</span>. That matches a perfect plane wave: no transverse structure to diffract.</li>
            <li><b>Physical meaning:</b> Transverse curvature (nonzero <span style="font-family:var(--mono)">∇_T²A</span>) drives slow evolution along z, i.e., diffraction.</li>
          </ul>

          <div class="hr"></div>

          <h2>(2.2-7) Conjugate waves: compare U and U*</h2>

          <h3>General statements</h3>
          <p class="muted small">
            Write the complex field as <span style="font-family:var(--mono)">U(r)=|U(r)| e^{j φ(r)}</span>.
            Then the complex conjugate is <span style="font-family:var(--mono)">U*(r)=|U(r)| e^{-j φ(r)}</span>.
          </p>

          <h3>Intensity</h3>
          <p class="muted small">
            The (time-averaged) intensity is proportional to <span style="font-family:var(--mono)">|U|²</span>.
            Conjugation does not change magnitude:
          </p>
          <div class="eqwrap">
            <button class="copybtn" data-copy="I(r) ∝ |U(r)|²,  and  |U*(r)|² = |U(r)|²">Copy</button>
            <pre class="eq">I(r) ∝ |U(r)|²,  and  |U*(r)|² = |U(r)|²</pre>
          </div>
          <p class="muted small"><b>Conclusion:</b> <span style="font-family:var(--mono)">U</span> and <span style="font-family:var(--mono)">U*</span> have the <b>same intensity pattern</b>.</p>

          <h3>Wavefronts (constant-phase surfaces)</h3>
          <p class="muted small">
            Wavefronts are surfaces where phase is constant:
            <span style="font-family:var(--mono)">φ(r)=const</span>.
            For <span style="font-family:var(--mono)">U*</span>, the phase is <span style="font-family:var(--mono)">-φ(r)</span>.
          </p>
          <p class="muted small">
            The set of constant-phase surfaces is the same geometrically: if <span style="font-family:var(--mono)">φ(r)=c</span> is a wavefront for U, then <span style="font-family:var(--mono)">-φ(r)=-c</span> is a wavefront for U*.
            So the <b>surfaces</b> are identical; only the <b>phase labeling/sign</b> flips.
          </p>

          <h3>Wavefront normals / propagation direction</h3>
          <p class="muted small">
            The local normal direction is given by the phase gradient (local wavevector):
            <span style="font-family:var(--mono)">k_local ∝ ∇φ</span>.
            Conjugation flips phase, so
            <span style="font-family:var(--mono)">∇(-φ) = -∇φ</span>.
          </p>
          <div class="eqwrap">
            <button class="copybtn" data-copy="If U = |U| e^{jφ}, then U* = |U| e^{-jφ} ⇒ wavefront normals reverse: ∇φ → -∇φ">Copy</button>
            <pre class="eq">If U = |U| e^{jφ}, then U* = |U| e^{-jφ} ⇒ wavefront normals reverse: ∇φ → -∇φ</pre>
          </div>
          <p class="muted small"><b>Conclusion:</b> <span style="font-family:var(--mono)">U*</span> represents a wave propagating in the <b>opposite direction</b> (time-reversed in many contexts).</p>

          <h3>Example 1: Plane wave</h3>
          <p class="muted small">
            Given <span style="font-family:var(--mono)">U(r)=A exp[-j k (x+y)/√2]</span>.
            The phase is <span style="font-family:var(--mono)">φ= -k(x+y)/√2</span>.
          </p>
          <ul class="muted small">
            <li><b>Intensity:</b> <span style="font-family:var(--mono)">|U|²=|A|²</span> (constant), and same for <span style="font-family:var(--mono)">U*</span>.</li>
            <li><b>Wavefronts:</b> <span style="font-family:var(--mono)">x+y = const</span> (planes at 45° in the x–y plane), same geometry for both.</li>
            <li><b>Normals:</b> For U, <span style="font-family:var(--mono)">∇φ = -(k/√2)(î + ĵ)</span>. For U*, <span style="font-family:var(--mono)">∇(-φ)= +(k/√2)(î + ĵ)</span>. They are opposite.</li>
          </ul>

          <h3>Example 2: Spherical wave</h3>
          <p class="muted small">
            Given <span style="font-family:var(--mono)">U(r)=(A/r) exp(-jkr)</span>, phase <span style="font-family:var(--mono)">φ=-kr</span>.
          </p>
          <ul class="muted small">
            <li><b>Intensity:</b> <span style="font-family:var(--mono)">|U|² = |A|² / r²</span>, same for <span style="font-family:var(--mono)">U*</span>.</li>
            <li><b>Wavefronts:</b> <span style="font-family:var(--mono)">r = const</span> (spheres), same geometry.</li>
            <li><b>Normals:</b> For U, <span style="font-family:var(--mono)">∇φ = -k r̂</span> (points inward in phase-gradient sign with this convention, while energy flow is outward for the outgoing solution); for U*, the sign flips, corresponding to the <b>incoming</b> spherical wave (converging toward the origin).</li>
          </ul>

          <div class="boxFinal" style="margin-top:12px">
            <h3>Final takeaway for (2.2-7)</h3>
            <div class="eqwrap" style="margin:0">
              <button class="copybtn" data-copy="U and U* have identical intensity and identical wavefront surfaces, but opposite wavefront normals (opposite propagation direction).">Copy</button>
              <pre class="eq">U and U* have identical intensity and identical wavefront surfaces,
but opposite wavefront normals (opposite propagation direction).</pre>
            </div>
          </div>

        </section>
      </article>

      <aside class="toc" aria-label="Table of contents">
        <h3>Table of Contents</h3>
        <a href="#part1">PART 1 — Problem Analysis</a>
        <a href="#part2">PART 2 — Strategy &amp; Tips</a>
        <a href="#part3">PART 3 — Full Solution</a>
        <a href="#viz">Interactive Visualizations</a>
      </aside>
    </div>

    <div class="wrap">
      <section id="viz" class="card" style="margin-top:14px">
        <div class="partTitle"><span class="badge">VIZ</span><span>Interactive Visualizations</span></div>
        <p class="muted small" style="margin-top:0">
          Controls below change the <b>wavelength</b> (thus <b>k</b>) and the <b>envelope scale</b> (how slowly A varies),
          and update <b>all</b> plots live.
        </p>

        <div class="controls">
          <div class="row2">
            <div class="ctrl">
              <label>
                <span>Wave example (for phase/wavefront plots)</span>
                <span class="muted" id="waveModeRead">Plane wave</span>
              </label>
              <select id="waveMode">
                <option value="plane">Plane wave: U = A exp[-j k (x+y)/√2]</option>
                <option value="spherical">Spherical wave: U = (A/r) exp(-j k r)</option>
              </select>
            </div>
            <div class="ctrl">
              <label>
                <span>Show which field in diagram?</span>
                <span class="muted" id="conjRead">Compare U vs U*</span>
              </label>
              <select id="conjMode">
                <option value="both">Compare U (blue) and U* (purple)</option>
                <option value="u">Only U</option>
                <option value="ustar">Only U*</option>
              </select>
            </div>
          </div>

          <div class="row2">
            <div class="ctrl">
              <label>
                <span>Wavelength λ (example parameter)</span>
                <span class="muted" id="lambdaRead">1.55 µm</span>
              </label>
              <input id="lambda" type="range" min="0.40" max="3.00" step="0.01" value="1.55" />
              <div class="muted small" style="margin-top:6px">
                k = 2π/λ = <span id="kRead">4.053e6</span> rad/m
              </div>
            </div>

            <div class="ctrl">
              <label>
                <span>Envelope variation length L (in wavelengths)</span>
                <span class="muted" id="LRead">10.0 λ</span>
              </label>
              <input id="L" type="range" min="1" max="60" step="1" value="10" />
              <div class="muted small" style="margin-top:6px">
                Envelope demo: A(z)=exp[-(z/L)²]
              </div>
            </div>
          </div>
        </div>

        <div class="vizgrid">
          <div class="viz">
            <div class="vizhead">
              <h3 class="viztitle">1) Diagram — Wavefronts &amp; Normals (U vs U*)</h3>
              <div class="vizmeta">Geometry view (2D schematic)</div>
            </div>
            <canvas id="cDiagram" aria-label="Wavefront diagram canvas"></canvas>
          </div>

          <div class="viz">
            <div class="vizhead">
              <h3 class="viztitle">2) Main Plot — Phase along a line (wrapped) + intensity reference</h3>
              <div class="vizmeta">x in meters, phase in radians (mod 2π)</div>
            </div>
            <canvas id="cMain" aria-label="Main plot canvas"></canvas>
          </div>

          <div class="viz">
            <div class="vizhead">
              <h3 class="viztitle">3) Secondary Plot — Paraxial validity (ratios vs L/λ)</h3>
              <div class="vizmeta">Shows when ∂²A/∂z² is negligible</div>
            </div>
            <canvas id="cSecondary" aria-label="Secondary plot canvas"></canvas>
            <p class="muted small" style="margin:10px 0 0">
              Interpreting the curves: paraxial/SVEA is strong when these ratios are <b>&ll; 1</b>. The marker shows your chosen <b>L/λ</b>.
            </p>
          </div>
        </div>

      </section>
    </div>

  </main>

  <footer>
    Built with vanilla HTML/CSS/JS • Copy buttons copy plain text • Canvases are hi-DPI aware and responsive.
  </footer>

  <script>
    // -------------------------------
    // Utilities: smooth scroll
    // -------------------------------
    document.addEventListener('click', (e) => {
      const a = e.target.closest('a[href^="#"]');
      if(!a) return;
      const id = a.getAttribute('href');
      const el = document.querySelector(id);
      if(!el) return;
      e.preventDefault();
      el.scrollIntoView({behavior:'smooth', block:'start'});
      history.replaceState(null, '', id);
    });

    // -------------------------------
    // Copy buttons
    // -------------------------------
    function flash(btn, text){
      const old = btn.textContent;
      btn.textContent = text;
      btn.style.background = 'rgba(52,211,153,0.16)';
      setTimeout(() => {
        btn.textContent = old;
        btn.style.background = '';
      }, 900);
    }
    async function copyText(t){
      try{
        await navigator.clipboard.writeText(t);
        return true;
      }catch(err){
        // fallback
        const ta = document.createElement('textarea');
        ta.value = t;
        ta.style.position='fixed';
        ta.style.left='-9999px';
        document.body.appendChild(ta);
        ta.select();
        try{
          document.execCommand('copy');
          document.body.removeChild(ta);
          return true;
        }catch(e){
          document.body.removeChild(ta);
          return false;
        }
      }
    }
    document.querySelectorAll('.copybtn').forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        const t = btn.getAttribute('data-copy') || '';
        const ok = await copyText(t);
        flash(btn, ok ? 'Copied!' : 'Copy failed');
      });
    });

    // -------------------------------
    // Math helpers
    // -------------------------------
    const TAU = Math.PI * 2;
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function wrapPhase(phi){
      // wrap to [-π, π)
      let x = ((phi + Math.PI) % TAU + TAU) % TAU - Math.PI;
      return x;
    }
    function linspace(a,b,n){
      const arr = new Array(n);
      const step = (b-a)/(n-1);
      for(let i=0;i<n;i++) arr[i]=a+i*step;
      return arr;
    }

    // -------------------------------
    // Hi-DPI canvas setup
    // -------------------------------
    function setupCanvas(canvas){
      const ctx = canvas.getContext('2d');
      function resize(){
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        const w = Math.max(2, Math.floor(rect.width * dpr));
        const h = Math.max(2, Math.floor(rect.height * dpr));
        if(canvas.width !== w || canvas.height !== h){
          canvas.width = w;
          canvas.height = h;
        }
        ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      }
      const ro = new ResizeObserver(()=>{ resize(); renderAll(); });
      ro.observe(canvas);
      resize();
      return {ctx, resize};
    }

    // Plotting primitives
    function clear(ctx, w, h){
      ctx.clearRect(0,0,w,h);
    }
    function styleText(ctx){
      ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillStyle = 'rgba(255,255,255,0.88)';
      ctx.strokeStyle = 'rgba(255,255,255,0.75)';
      ctx.lineWidth = 1;
    }
    function drawPanel(ctx, x,y,w,h){
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.20)';
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 1;
      roundRect(ctx, x,y,w,h, 14);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }
    function roundRect(ctx,x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel){
      const {x,y,w,h} = box;
      // grid
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      const nGrid = 6;
      for(let i=0;i<=nGrid;i++){
        const gx = x + (w*i/nGrid);
        ctx.beginPath(); ctx.moveTo(gx,y); ctx.lineTo(gx,y+h); ctx.stroke();
      }
      for(let i=0;i<=nGrid;i++){
        const gy = y + (h*i/nGrid);
        ctx.beginPath(); ctx.moveTo(x,gy); ctx.lineTo(x+w,gy); ctx.stroke();
      }

      // axes border
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 1;
      ctx.strokeRect(x,y,w,h);

      // ticks & labels
      ctx.fillStyle = 'rgba(255,255,255,0.80)';
      ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';

      const nTicks = 6;
      for(let i=0;i<=nTicks;i++){
        const tx = x + (w*i/nTicks);
        const val = xMin + (xMax-xMin)*i/nTicks;
        ctx.beginPath();
        ctx.moveTo(tx, y+h);
        ctx.lineTo(tx, y+h+5);
        ctx.strokeStyle='rgba(255,255,255,0.25)';
        ctx.stroke();
        ctx.fillText(formatSI(val), tx-14, y+h+18);
      }
      for(let i=0;i<=nTicks;i++){
        const ty = y + (h*(nTicks-i)/nTicks);
        const val = yMin + (yMax-yMin)*i/nTicks;
        ctx.beginPath();
        ctx.moveTo(x-5, ty);
        ctx.lineTo(x, ty);
        ctx.strokeStyle='rgba(255,255,255,0.25)';
        ctx.stroke();
        ctx.fillText(formatSI(val), x-48, ty+4);
      }

      // axis labels
      ctx.fillStyle = 'rgba(255,255,255,0.86)';
      ctx.fillText(xLabel, x + w*0.5 - ctx.measureText(xLabel).width*0.5, y+h+34);
      ctx.save();
      ctx.translate(x-62, y + h*0.5);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, -ctx.measureText(yLabel).width*0.5, 0);
      ctx.restore();
      ctx.restore();

      // mapping functions
      function X(u){ return x + (u-xMin)/(xMax-xMin)*w; }
      function Y(v){ return y + (1-(v-yMin)/(yMax-yMin))*h; }
      return {X,Y};
    }

    function formatSI(v){
      const av = Math.abs(v);
      if(av === 0) return '0';
      if(av >= 1e6) return (v/1e6).toFixed(2)+'e6';
      if(av >= 1e3) return (v/1e3).toFixed(2)+'e3';
      if(av >= 1) return v.toFixed(2);
      if(av >= 1e-3) return (v*1e3).toFixed(2)+'e-3';
      if(av >= 1e-6) return (v*1e6).toFixed(2)+'e-6';
      return v.toExponential(2);
    }

    function drawLine(ctx, pts, map, color, width=2){
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.beginPath();
      for(let i=0;i<pts.length;i++){
        const p = pts[i];
        const x = map.X(p.x);
        const y = map.Y(p.y);
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawLegend(ctx, items, x, y){
      ctx.save();
      ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      let yy = y;
      items.forEach(it=>{
        ctx.fillStyle = it.color;
        ctx.fillRect(x, yy-9, 12, 3);
        ctx.fillStyle = 'rgba(255,255,255,0.88)';
        ctx.fillText(it.label, x+18, yy);
        yy += 16;
      });
      ctx.restore();
    }

    // -------------------------------
    // Model state / controls
    // -------------------------------
    const elLambda = document.getElementById('lambda');
    const elL = document.getElementById('L');
    const elWaveMode = document.getElementById('waveMode');
    const elConjMode = document.getElementById('conjMode');
    const lambdaRead = document.getElementById('lambdaRead');
    const kRead = document.getElementById('kRead');
    const LRead = document.getElementById('LRead');
    const waveModeRead = document.getElementById('waveModeRead');
    const conjRead = document.getElementById('conjRead');
    const exVals = document.getElementById('exVals');

    function getState(){
      const lambda_um = parseFloat(elLambda.value);     // µm
      const lambda_m  = lambda_um * 1e-6;
      const k = TAU / lambda_m;
      const L_over_lambda = parseFloat(elL.value);
      const L = L_over_lambda * lambda_m;
      const waveMode = elWaveMode.value; // plane or spherical
      const conjMode = elConjMode.value; // both/u/ustar
      return {lambda_um, lambda_m, k, L_over_lambda, L, waveMode, conjMode};
    }

    function updateReadouts(){
      const s = getState();
      lambdaRead.textContent = `${s.lambda_um.toFixed(2)} µm`;
      kRead.textContent = (s.k).toExponential(3);
      LRead.textContent = `${s.L_over_lambda.toFixed(0)} λ`;
      waveModeRead.textContent = (s.waveMode === 'plane') ? 'Plane wave' : 'Spherical wave';
      conjRead.textContent = (s.conjMode === 'both') ? 'Compare U vs U*' : (s.conjMode === 'u' ? 'Only U' : 'Only U*');
      exVals.textContent = `λ = ${s.lambda_um.toFixed(2)} µm`;
    }

    // -------------------------------
    // Canvases
    // -------------------------------
    const cDiagram = document.getElementById('cDiagram');
    const cMain = document.getElementById('cMain');
    const cSecondary = document.getElementById('cSecondary');

    const d1 = setupCanvas(cDiagram);
    const d2 = setupCanvas(cMain);
    const d3 = setupCanvas(cSecondary);

    function renderAll(){
      updateReadouts();
      renderDiagram();
      renderMainPlot();
      renderSecondaryPlot();
    }

    // -------------------------------
    // 1) Diagram: wavefronts & normals
    // -------------------------------
    function renderDiagram(){
      const s = getState();
      const ctx = d1.ctx;
      const w = cDiagram.clientWidth;
      const h = cDiagram.clientHeight;

      clear(ctx, w, h);
      drawPanel(ctx, 10, 10, w-20, h-20);

      // Title
      ctx.save();
      styleText(ctx);
      ctx.fillStyle='rgba(255,255,255,0.90)';
      const title = (s.waveMode==='plane')
        ? 'Plane wavefronts: x + y = const'
        : 'Spherical wavefronts: r = const';
      ctx.fillText(title, 22, 30);
      ctx.fillStyle='rgba(255,255,255,0.70)';
      ctx.fillText('Normals indicate propagation direction (U vs U*)', 22, 48);
      ctx.restore();

      const margin = 22;
      const bx = margin, by = 62, bw = w - 2*margin, bh = h - by - margin;
      // coordinate transform for drawing
      function toX(u){ return bx + (u+1)/2*bw; }
      function toY(v){ return by + (1-(v+1)/2)*bh; }

      // Colors
      const colU = 'rgba(125,211,252,0.95)';   // blue
      const colUs = 'rgba(167,139,250,0.95)';  // purple
      const faint = 'rgba(255,255,255,0.10)';

      // axes lines
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(toX(-1), toY(0));
      ctx.lineTo(toX(1),  toY(0));
      ctx.moveTo(toX(0),  toY(-1));
      ctx.lineTo(toX(0),  toY(1));
      ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,0.55)';
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.fillText('x', toX(1)-10, toY(0)-8);
      ctx.fillText('y', toX(0)+8, toY(1)+14);
      ctx.restore();

      // spacing from wavelength: draw ~6 phase surfaces within box
      const nFronts = 7;
      if(s.waveMode==='plane'){
        // lines x + y = c, in normalized coords.
        for(let i=0;i<nFronts;i++){
          const c = -1.2 + i*(2.4/(nFronts-1));
          // line in x-y: y = c - x, clip to box [-1,1]
          const x1=-1, y1=c-x1;
          const x2= 1, y2=c-x2;
          ctx.save();
          ctx.strokeStyle = faint;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(toX(x1), toY(y1));
          ctx.lineTo(toX(x2), toY(y2));
          ctx.stroke();
          ctx.restore();
        }

        // draw normals: U along -(1,1) direction for given phase form exp(-jk(x+y)/√2)
        // U* along +(1,1).
        const showU = (s.conjMode==='both' || s.conjMode==='u');
        const showUs = (s.conjMode==='both' || s.conjMode==='ustar');

        const cx = 0.25, cy = -0.25;
        if(showU){
          drawArrow(ctx, toX(cx), toY(cy), toX(cx-0.45), toY(cy-0.45), colU, 'U');
        }
        if(showUs){
          drawArrow(ctx, toX(cx), toY(cy), toX(cx+0.45), toY(cy+0.45), colUs, 'U*');
        }

        // small note of direction vector
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.72)';
        ctx.font = '12px ui-sans-serif, system-ui';
        ctx.fillText('Wavefronts are parallel planes; conjugation flips normal direction.', 22, h-18);
        ctx.restore();

      }else{
        // spherical: draw circles centered at origin
        for(let i=0;i<nFronts;i++){
          const r = 0.15 + i*(0.85/(nFronts-1));
          ctx.save();
          ctx.strokeStyle = faint;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(toX(0), toY(0), r*Math.min(bw,bh)/2, 0, TAU);
          ctx.stroke();
          ctx.restore();
        }

        const showU = (s.conjMode==='both' || s.conjMode==='u');
        const showUs = (s.conjMode==='both' || s.conjMode==='ustar');

        // outgoing vs incoming: we depict U as outward arrow, U* as inward arrow
        const px = 0.55, py = 0.2;
        const x0 = toX(px), y0 = toY(py);
        const xOut = toX(px+0.30), yOut = toY(py+0.11);
        const xIn  = toX(px-0.26), yIn  = toY(py-0.10);

        if(showU){
          drawArrow(ctx, x0, y0, xOut, yOut, colU, 'U (outgoing)');
        }
        if(showUs){
          drawArrow(ctx, x0, y0, xIn, yIn, colUs, 'U* (incoming)');
        }

        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.72)';
        ctx.font = '12px ui-sans-serif, system-ui';
        ctx.fillText('Wavefronts are spheres; conjugation swaps outgoing ↔ incoming.', 22, h-18);
        ctx.restore();
      }

      // legend
      const items = [];
      if(s.conjMode==='both' || s.conjMode==='u') items.push({label:'U', color:'rgba(125,211,252,0.95)'});
      if(s.conjMode==='both' || s.conjMode==='ustar') items.push({label:'U*', color:'rgba(167,139,250,0.95)'});
      drawLegend(ctx, items, w-120, 36);
    }

    function drawArrow(ctx, x1,y1,x2,y2,color,label){
      ctx.save();
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
      // arrow head
      const ang = Math.atan2(y2-y1, x2-x1);
      const ah = 10;
      ctx.beginPath();
      ctx.moveTo(x2,y2);
      ctx.lineTo(x2 - ah*Math.cos(ang-0.35), y2 - ah*Math.sin(ang-0.35));
      ctx.lineTo(x2 - ah*Math.cos(ang+0.35), y2 - ah*Math.sin(ang+0.35));
      ctx.closePath();
      ctx.fill();

      // label
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.fillStyle = 'rgba(255,255,255,0.88)';
      ctx.fillText(label, x2 + 8, y2 + 4);
      ctx.restore();
    }

    // -------------------------------
    // 2) Main plot: phase along a line + intensity
    // -------------------------------
    function renderMainPlot(){
      const s = getState();
      const ctx = d2.ctx;
      const w = cMain.clientWidth;
      const h = cMain.clientHeight;

      clear(ctx, w, h);
      drawPanel(ctx, 10, 10, w-20, h-20);

      // Choose x-range in meters based on wavelength: show ±5λ
      const xMin = -5*s.lambda_m;
      const xMax =  5*s.lambda_m;

      // y-range: wrapped phase in [-π, π], show also intensity (scaled) as dashed line
      const yMin = -Math.PI;
      const yMax =  Math.PI;

      // inner plot box
      const box = {x: 70, y: 44, w: w-90, h: h-86};
      const map = drawAxes(ctx, box, xMin, xMax, yMin, yMax, 'x (m)', 'wrapped phase φ (rad)');

      // Title
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.90)';
      ctx.font = '13px ui-sans-serif, system-ui';
      const t = (s.waveMode==='plane')
        ? 'Plane wave: y=0 line ⇒ φ(x)=∓k x/√2'
        : 'Spherical wave: along radius ⇒ φ(r)=∓k r (plotted vs x=r)';
      ctx.fillText(t, 22, 30);
      ctx.fillStyle = 'rgba(255,255,255,0.68)';
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.fillText('Blue: U, Purple: U*, Dashed gray: intensity (scaled reference)', 22, 48);
      ctx.restore();

      const N = 700;
      const xs = linspace(xMin, xMax, N);

      const ptsU = [];
      const ptsUs = [];
      const ptsI = [];

      for(let i=0;i<N;i++){
        const x = xs[i];
        let phiU, phiUs, I;

        if(s.waveMode==='plane'){
          // For y=0: U = A exp[-j k (x)/√2]  (since y=0)
          phiU  = -s.k * x / Math.SQRT2;
          phiUs = +s.k * x / Math.SQRT2;
          I = 1.0; // constant
        }else{
          // Interpret x as r>=0 for spherical (use |x| to avoid negative radius)
          const r = Math.max(1e-12, Math.abs(x));
          phiU  = -s.k * r;
          phiUs = +s.k * r;
          // intensity ~ 1/r^2, clip and normalize for display
          I = 1/(r*r);
        }

        ptsU.push({x, y: wrapPhase(phiU)});
        ptsUs.push({x, y: wrapPhase(phiUs)});
        ptsI.push({x, y: intensityToPhaseScale(I)}); // plotted on phase axis as a reference
      }

      // scale intensity into [-π, π] just for visualization
      function intensityToPhaseScale(I){
        let In = I;
        if(s.waveMode==='spherical'){
          // normalize to max over displayed range
          const rmin = Math.max(1e-12, Math.abs(xMin));
          const rmax = Math.max(1e-12, Math.abs(xMax));
          const Imax = 1/(rmin*rmin);
          const Imin = 1/(rmax*rmax);
          In = (I - Imin) / (Imax - Imin + 1e-30);
        }else{
          In = 1;
        }
        In = clamp(In, 0, 1);
        return yMin + In*(yMax-yMin);
      }

      // draw curves
      const showU = (s.conjMode==='both' || s.conjMode==='u');
      const showUs = (s.conjMode==='both' || s.conjMode==='ustar');

      if(showU)  drawLine(ctx, ptsU,  map, 'rgba(125,211,252,0.95)', 2.2);
      if(showUs) drawLine(ctx, ptsUs, map, 'rgba(167,139,250,0.95)', 2.2);

      // intensity line dashed
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 1.6;
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      for(let i=0;i<ptsI.length;i++){
        const p = ptsI[i];
        const X = map.X(p.x), Y = map.Y(p.y);
        if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
      }
      ctx.stroke();
      ctx.restore();

      // legend
      const items = [];
      if(showU) items.push({label:'U: wrapped phase', color:'rgba(125,211,252,0.95)'});
      if(showUs) items.push({label:'U*: wrapped phase', color:'rgba(167,139,250,0.95)'});
      items.push({label:'Intensity (scaled)', color:'rgba(255,255,255,0.45)'});
      drawLegend(ctx, items, box.x + box.w - 190, box.y + 20);
    }

    // -------------------------------
    // 3) Secondary plot: paraxial ratios vs L/λ
    // -------------------------------
    function renderSecondaryPlot(){
      const s = getState();
      const ctx = d3.ctx;
      const w = cSecondary.clientWidth;
      const h = cSecondary.clientHeight;

      clear(ctx, w, h);
      drawPanel(ctx, 10, 10, w-20, h-20);

      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.90)';
      ctx.font = '13px ui-sans-serif, system-ui';
      ctx.fillText('Paraxial/SVEA ratios for A(z)=exp[-(z/L)²]', 22, 30);
      ctx.fillStyle = 'rgba(255,255,255,0.68)';
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.fillText('We want these ≪ 1 (then ∂²A/∂z² is negligible). Marker = chosen L/λ.', 22, 48);
      ctx.restore();

      // Sweep L/λ from 1 to 60 (to match slider)
      const Lmin = 1, Lmax = 60;
      const N = 240;
      const Ls = linspace(Lmin, Lmax, N);

      // ratios:
      // R1 = max|A'|/(k max|A|)
      // R2 = max|A''|/(k max|A'|)
      // R3 = max|A''|/(k² max|A|)
      // For A(z)=exp(-(z/L)²):
      // A' = (-2z/L²) A  => max |A'| occurs at |z|=L/√2 => max|A'| = (√2/L) e^{-1/2}
      // A'' = [(-2/L²) + (4z²/L^4)] A
      // Max |A''| occurs at z=0 gives 2/L², but absolute max is 2/L² at z=0 (since A<=1, other points have smaller A).
      // We'll use analytic maxima for speed and clarity.
      function ratios(L_over_lambda){
        const lambda = s.lambda_m;
        const L = L_over_lambda * lambda;
        const k = s.k;

        const maxA = 1.0;
        const maxAp = (Math.SQRT2 / L) * Math.exp(-0.5); // √2/L e^{-1/2}
        const maxApp = 2.0/(L*L); // at z=0, magnitude 2/L²

        const R1 = maxAp / (k * maxA);
        const R2 = maxApp / (k * maxAp);
        const R3 = maxApp / (k*k * maxA);
        return {R1,R2,R3};
      }

      // Compute curves
      const pts1=[], pts2=[], pts3=[];
      let yMax = 0;
      for(let i=0;i<N;i++){
        const Lrat = Ls[i];
        const r = ratios(Lrat);
        yMax = Math.max(yMax, r.R1, r.R2, r.R3);
        pts1.push({x:Lrat, y:r.R1});
        pts2.push({x:Lrat, y:r.R2});
        pts3.push({x:Lrat, y:r.R3});
      }

      // set y range (log-ish without log axis): clamp to [0, max] but keep readable
      // We'll use yMax up to 2 maybe; if too small, expand.
      const yMin = 0;
      const yMaxPlot = Math.max(0.2, Math.min(2.2, yMax*1.05));

      const box = {x: 70, y: 44, w: w-90, h: h-86};
      const map = drawAxes(ctx, box, Lmin, Lmax, yMin, yMaxPlot, 'L/λ (dimensionless)', 'ratio (dimensionless)');

      // draw y=1 reference line
      ctx.save();
      ctx.strokeStyle = 'rgba(251,191,36,0.40)';
      ctx.lineWidth = 1.4;
      ctx.setLineDash([6,6]);
      const y1 = map.Y(1);
      ctx.beginPath(); ctx.moveTo(box.x, y1); ctx.lineTo(box.x+box.w, y1); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = 'rgba(251,191,36,0.72)';
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.fillText('ratio = 1', box.x + 8, y1 - 6);
      ctx.restore();

      // plot curves
      drawLine(ctx, pts1, map, 'rgba(125,211,252,0.95)', 2.0);
      drawLine(ctx, pts2, map, 'rgba(167,139,250,0.95)', 2.0);
      drawLine(ctx, pts3, map, 'rgba(52,211,153,0.92)', 2.0);

      // marker at chosen L/λ
      const rr = ratios(s.L_over_lambda);
      const mx = map.X(s.L_over_lambda);
      const my = map.Y(clamp(rr.R3, yMin, yMaxPlot));
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.90)';
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(mx, my, 5.5, 0, TAU);
      ctx.fill();
      ctx.stroke();

      // annotate numeric values near marker
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.fillStyle = 'rgba(255,255,255,0.82)';
      const label =
        `L/λ=${s.L_over_lambda.toFixed(0)}  R1=${rr.R1.toExponential(2)}  R2=${rr.R2.toExponential(2)}  R3=${rr.R3.toExponential(2)}`;
      const tx = clamp(mx - 120, box.x+8, box.x+box.w-260);
      const ty = clamp(my - 16, box.y+14, box.y+box.h-10);
      ctx.fillText(label, tx, ty);
      ctx.restore();

      // legend
      drawLegend(ctx, [
        {label:'R1 = max|A\'| / (k max|A|)', color:'rgba(125,211,252,0.95)'},
        {label:'R2 = max|A\'\'| / (k max|A\'|)', color:'rgba(167,139,250,0.95)'},
        {label:'R3 = max|A\'\'| / (k² max|A|)', color:'rgba(52,211,153,0.92)'}
      ], box.x + 18, box.y + 22);
    }

    // -------------------------------
    // Hook up controls
    // -------------------------------
    [elLambda, elL, elWaveMode, elConjMode].forEach(el=>{
      el.addEventListener('input', renderAll);
      el.addEventListener('change', renderAll);
    });

    // initial render
    renderAll();
  </script>
</body>
</html>
