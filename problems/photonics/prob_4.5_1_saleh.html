<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Holography with a Spherical Reference Wave (Paraxial/Paraboloidal Approximation)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f1620;
      --panel2:#101a26;
      --text:#e9eef6;
      --muted:#a9b6c7;
      --faint:#6c7a8f;
      --line:#223043;
      --accent:#7bdcff;
      --accent2:#a7ffb3;
      --warn:#ffcf7b;
      --danger:#ff7b92;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(123,220,255,.10), transparent 60%),
        radial-gradient(1000px 650px at 75% 35%, rgba(167,255,179,.08), transparent 55%),
        radial-gradient(900px 600px at 50% 95%, rgba(255,207,123,.06), transparent 55%),
        var(--bg);
      line-height:1.5;
    }
    a{color:var(--accent)}
    header{
      padding:32px 18px 10px;
      max-width:1200px;
      margin:0 auto;
    }
    .title{
      display:flex;
      gap:16px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-size: clamp(1.4rem, 2.5vw, 2.2rem);
      letter-spacing: .2px;
    }
    .subtitle{
      margin:8px 0 0;
      color:var(--muted);
      max-width: 70ch;
    }
    main{
      max-width:1200px;
      margin:0 auto;
      padding:12px 18px 50px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
    }

    /* Sticky mini ToC */
    .toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(15,22,32,.92), rgba(15,22,32,.72));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:14px 14px 10px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .toc h2{
      font-size: 0.95rem;
      margin:0 0 8px;
      letter-spacing:.3px;
      color:var(--text);
    }
    .toc a{
      display:block;
      text-decoration:none;
      color:var(--muted);
      padding:8px 10px;
      border-radius: 12px;
      border:1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      font-size: 0.93rem;
    }
    .toc a:hover{
      background: rgba(123,220,255,.08);
      border-color: rgba(123,220,255,.18);
      transform: translateX(2px);
      color:var(--text);
    }
    .toc .hint{
      font-size:0.85rem;
      color:var(--faint);
      margin:10px 2px 0;
    }

    .content{
      display:flex;
      flex-direction:column;
      gap:18px;
      min-width:0;
    }

    section, article{
      background: linear-gradient(180deg, rgba(16,26,38,.92), rgba(16,26,38,.78));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:18px 18px 16px;
      backdrop-filter: blur(10px);
      overflow:hidden;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid2{grid-template-columns: 1fr}
    }

    .card{
      background: linear-gradient(180deg, rgba(15,22,32,.9), rgba(15,22,32,.68));
      border:1px solid rgba(34,48,67,.9);
      border-radius: 16px;
      padding:14px 14px 12px;
    }

    .callout{
      border-left: 4px solid var(--accent);
      background: rgba(123,220,255,.06);
      padding:12px 12px 10px;
      border-radius: 14px;
    }
    .warn{
      border-left-color: var(--warn);
      background: rgba(255,207,123,.08);
    }
    .danger{
      border-left-color: var(--danger);
      background: rgba(255,123,146,.07);
    }

    h2{
      margin:0 0 10px;
      font-size: 1.18rem;
      letter-spacing:.2px;
    }
    h3{
      margin:14px 0 8px;
      font-size: 1.02rem;
      letter-spacing:.2px;
      color:var(--text);
    }
    p{margin:8px 0}
    ul{margin:8px 0 8px 18px; color:var(--muted)}
    li{margin:5px 0}
    .muted{color:var(--muted)}
    .small{font-size:.92rem}
    .tiny{font-size:.85rem}

    /* Equation blocks with copy button */
    .eq{
      position:relative;
      background: rgba(11,15,20,.55);
      border:1px solid rgba(34,48,67,.9);
      border-radius: 14px;
      padding:12px 12px 10px;
      overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: #dff6ff;
      margin:10px 0 8px;
      white-space: pre-wrap;
    }
    .copyBtn{
      position:absolute;
      top:10px;
      right:10px;
      font: inherit;
      font-family: inherit;
      font-size:.82rem;
      padding:7px 10px;
      border-radius: 12px;
      border:1px solid rgba(123,220,255,.25);
      background: rgba(123,220,255,.10);
      color: var(--text);
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
    }
    .copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(123,220,255,.16);
      border-color: rgba(123,220,255,.38);
    }
    .copyBtn:active{transform: translateY(0px) scale(.99)}
    .copyNote{
      margin-top:6px;
      color: var(--faint);
      font-size:.85rem;
    }

    /* Visualization layout */
    .vizWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
    }
    .vizRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .vizRow{grid-template-columns: 1fr}
    }
    figure{
      margin:0;
      background: rgba(11,15,20,.45);
      border:1px solid rgba(34,48,67,.9);
      border-radius: 16px;
      padding:10px;
      overflow:hidden;
    }
    figcaption{
      color: var(--muted);
      font-size:.9rem;
      margin:8px 4px 2px;
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius: 12px;
      background: rgba(7,10,14,.55);
    }
    .canvasTall canvas{height:360px}

    /* Controls */
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 620px){
      .controls{grid-template-columns: 1fr}
    }
    label{
      display:block;
      font-size:.86rem;
      color: var(--muted);
      margin:0 0 6px;
    }
    .control{
      background: rgba(11,15,20,.55);
      border:1px solid rgba(34,48,67,.9);
      border-radius: 14px;
      padding:10px 10px 8px;
    }
    input[type="range"]{width:100%}
    select, input[type="number"]{
      width:100%;
      padding:8px 10px;
      border-radius: 12px;
      border:1px solid rgba(34,48,67,.9);
      background: rgba(16,26,38,.95);
      color: var(--text);
      outline:none;
    }
    .valRow{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      margin-top:6px;
      color: var(--faint);
      font-size:.84rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    .btnRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:8px;
    }
    .btn{
      padding:9px 12px;
      border-radius: 14px;
      border:1px solid rgba(167,255,179,.25);
      background: rgba(167,255,179,.10);
      color:var(--text);
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .btn:hover{
      transform: translateY(-1px);
      background: rgba(167,255,179,.16);
      border-color: rgba(167,255,179,.35);
    }
    .btn:active{transform: translateY(0px) scale(.99)}
    .pill{
      display:inline-block;
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid rgba(123,220,255,.22);
      background: rgba(123,220,255,.08);
      color: var(--muted);
      font-size:.82rem;
      margin-left:8px;
      vertical-align: middle;
    }

    .finalBox{
      border:1px solid rgba(167,255,179,.35);
      background: rgba(167,255,179,.08);
      border-radius: 16px;
      padding:14px 14px 12px;
    }

    .hr{
      height:1px;
      background: rgba(34,48,67,.9);
      margin:14px 0;
    }

    /* Subtle entrance */
    @keyframes rise{from{opacity:0; transform: translateY(6px)} to{opacity:1; transform: translateY(0)}}
    section, article, .toc{animation: rise .35s ease both}
    section:nth-child(2){animation-delay:.03s}
    section:nth-child(3){animation-delay:.06s}
    section:nth-child(4){animation-delay:.09s}

    /* Print-friendly */
    @media print{
      body{background:white; color:black}
      .toc{display:none}
      section, article{box-shadow:none; background:white; border:1px solid #ddd}
      canvas{background:white; border:1px solid #ddd}
      .copyBtn, .btnRow{display:none}
      .eq{color:black; background:#f7f7f7}
      a{color:black; text-decoration:underline}
    }
  </style>
</head>
<body>
<header>
  <div class="title">
    <div>
      <h1>Holography with a Spherical Reference Wave (Paraxial / Paraboloidal Spherical-Wave Approximation)</h1>
      <p class="subtitle">
        We record an interference pattern on the plane <span class="pill">z = 0</span> using a spherical reference wave from <span class="pill">(0,0,−d)</span>.
        Find the hologram fringe pattern for two object waves, and analyze what the reconstruction produces when illuminated again by the reference.
      </p>
    </div>
  </div>
</header>

<main>
  <!-- Sticky mini ToC -->
  <nav class="toc" aria-label="Table of contents">
    <h2>Table of Contents</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy &amp; Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#viz">Interactive Visualizations</a>
    <p class="hint">Tip: use the controls to see how the fringe curvature and spacing change.</p>
  </nav>

  <div class="content">
    <!-- Quick Summary -->
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li>The recorded hologram intensity is <span class="muted">I(x,y)=|R+O|<sup>2</sup>=|R|<sup>2</sup>+|O|<sup>2</sup>+2Re{R*O}</span>.</li>
        <li>Paraxial spherical wave (about distance <span class="muted">d</span>) on <span class="muted">z=0</span>:
          phase <span class="muted">≈ k[d + (x²+y²)/(2d)]</span> (amplitude nearly constant).</li>
        <li><b>Case (a)</b> plane-wave object at angle <span class="muted">θx</span>: the interference term contains
          <span class="muted">cos(k x sinθx − k(x²+y²)/(2d) + const)</span> → curved Fresnel-like fringes with a linear carrier.</li>
        <li><b>Case (b)</b> spherical object from <span class="muted">(−x0,0,−d1)</span>:
          <span class="muted">cos( k[(x+x0)²+y²]/(2d1) − k(x²+y²)/(2d) + const )</span> → a shifted Fresnel zone pattern.</li>
        <li>Reconstruction (amplitude hologram) with the same reference yields: a <b>zero order</b>, a <b>virtual image</b> proportional to <span class="muted">O</span>, and a <b>conjugate (real) image</b> related to <span class="muted">O*</span> with extra curvature from <span class="muted">R²</span>.</li>
      </ul>
    </section>

    <!-- PART 1 -->
    <article id="part1">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>1) Restate the problem (in my own words)</h3>
      <p class="muted">
        A hologram is recorded in the plane <b>z = 0</b> by interfering an <b>object field</b> <span class="muted">O(x,y)</span>
        with a <b>spherical reference field</b> <span class="muted">R(x,y)</span> emitted from the point <span class="muted">(0,0,−d)</span>.
        Using the paraxial (paraboloidal) approximation for spherical waves, determine:
      </p>
      <ul>
        <li>(a) the hologram intensity pattern when the object wave is a plane wave tilted by angle <span class="muted">θx</span> in the x–z plane;</li>
        <li>(b) the hologram pattern when the object wave is a spherical wave emitted from <span class="muted">(−x0,0,−d1)</span>;</li>
        <li>and for each case, analyze what wavefields are reconstructed when the developed hologram is illuminated again by the reference wave.</li>
      </ul>

      <h3>2) Given quantities</h3>
      <ul>
        <li>Recording plane: <b>z = 0</b>.</li>
        <li>Reference source point: <b>(0,0,−d)</b>.</li>
        <li>Case (a) object: plane wave at angle <b>θx</b> (tilt in x).</li>
        <li>Case (b) object: spherical wave centered at <b>(−x0,0,−d1)</b>.</li>
        <li>Wavelength <span class="muted">λ</span> (not given numerically; we will keep symbolic and use example values for plots).</li>
      </ul>

      <h3>3) Unknowns</h3>
      <ul>
        <li>The hologram intensity pattern <span class="muted">I(x,y)</span> (or its interference/fringe term).</li>
        <li>Qualitative + quantitative form of reconstructed waves: zero order, virtual image, conjugate image (real image) and their curvature/geometry.</li>
      </ul>

      <h3>4) What must be found/proved</h3>
      <ul>
        <li>Explicit expressions (paraxial) for <span class="muted">I(x,y)</span> for both object cases.</li>
        <li>Identify the reconstructed components when illuminating with the reference wave (standard holography analysis).</li>
      </ul>

      <h3>5) Relevant physical principles (and why they apply)</h3>
      <div class="callout">
        <p><b>Interference recording:</b> A photographic plate records intensity, not complex field:
          <span class="muted">I = |R+O|²</span>. The cross term <span class="muted">R*O</span> encodes the relative phase and thus the wavefront shape.</p>
        <p><b>Paraxial (Fresnel) approximation:</b> If the recording plane is small compared to distances <span class="muted">d, d1</span>,
          spherical wave distances can be expanded as
          <span class="muted">r ≈ d + (x²+y²)/(2d)</span>. This converts spherical waves into quadratic phase factors (“paraboloids”).</p>
        <p><b>Reconstruction:</b> If the processed hologram acts as an <b>amplitude transmittance</b>
          <span class="muted">t(x,y) ≈ t0 + β I(x,y)</span>, illumination by <span class="muted">R</span> produces multiple terms.
          Two of them are proportional to <span class="muted">O</span> (virtual image) and to a conjugated object-like term (real image).</p>
      </div>

      <h3>6) Possible approaches</h3>
      <ul>
        <li><b>Direct field algebra:</b> write <span class="muted">R(x,y), O(x,y)</span> on <span class="muted">z=0</span>, compute <span class="muted">I=|R+O|²</span>,
          isolate the cosine fringe term via phase difference Δφ. (Fast, transparent.)</li>
        <li><b>Spatial-frequency / grating viewpoint:</b> treat fringes as locally periodic with period from phase gradient:
          <span class="muted">p(x)=2π/|∂Δφ/∂x|</span>. (Great for intuition and plotting.)</li>
        <li><b>Imaging-equation reconstruction:</b> interpret quadratic phase differences as thin-lens behavior to locate the real image. (Helpful, but can be overkill.)</li>
      </ul>

      <h3>7) Best approach (choice + justification)</h3>
      <p class="muted">
        We’ll use <b>direct field algebra</b> with the <b>paraxial spherical-wave expansion</b>, because it produces a clean, symbolic
        hologram pattern for both cases. Then we’ll analyze reconstruction by expanding <span class="muted">tR</span> and interpreting the resulting phase factors.
        We’ll also compute the <b>local fringe spacing</b> from the phase gradient for a meaningful, interactive visualization.
      </p>
    </article>

    <!-- PART 2 -->
    <article id="part2">
      <h2>PART 2 — Strategy &amp; Tips (roadmap only)</h2>

      <h3>Step-by-step plan (no algebra yet)</h3>
      <ol class="muted">
        <li><b>Define geometry:</b> recording plane z=0, reference point (0,0,−d), object definition for each case.</li>
        <li><b>Write reference field:</b> use paraxial spherical wave approximation for phase on z=0.</li>
        <li><b>Write object field:</b> (a) plane wave phase on z=0; (b) spherical wave from (−x0,0,−d1) with paraboloidal phase.</li>
        <li><b>Compute intensity:</b> apply <span class="muted">I=|R+O|²</span>; express the interference term as a cosine of phase difference.</li>
        <li><b>Extract hologram pattern:</b> write Δφ(x,y) explicitly; recognize fringe type (curved Fresnel/zone-plate-like).</li>
        <li><b>Model hologram transmittance:</b> assume amplitude hologram <span class="muted">t ≈ t0 + β I</span>.</li>
        <li><b>Reconstruct:</b> illuminate with reference R; expand <span class="muted">E_out = tR</span> and identify zero order, virtual image, conjugate image.</li>
        <li><b>Sanity checks:</b> units (phases dimensionless), limits (d→∞ recovers plane reference), physical interpretation (fringe spacing trends).</li>
      </ol>

      <h3>Common mistakes &amp; quick tips</h3>
      <div class="callout warn">
        <ul>
          <li><b>Sign errors in phase:</b> keep a consistent convention: <span class="muted">exp(+ik r)</span> for outgoing waves; conjugation flips the sign.</li>
          <li><b>Dropping constants incorrectly:</b> overall constant phase does not affect intensity fringes, but keep it until you form Δφ, then you may discard it.</li>
          <li><b>Forgetting the paraboloidal term:</b> <span class="muted">(x²+y²)/(2d)</span> is the whole reason fringes curve for a spherical reference.</li>
          <li><b>Reconstruction interpretation:</b> the object term typically appears as <span class="muted">|R|² O</span> (a scaled copy), while the conjugate involves <span class="muted">R² O*</span> (extra curvature).</li>
        </ul>
      </div>
    </article>

    <!-- PART 3 -->
    <article id="part3">
      <h2>PART 3 — Full Solution</h2>

      <h3>Physical intuition (before equations)</h3>
      <p class="muted">
        A spherical reference wave has <b>curved phase fronts</b>. When it interferes with an object wave,
        the recorded fringes must “absorb” that curvature: even if the object is a simple tilted plane wave,
        the phase difference includes a <b>quadratic</b> term, producing curved fringes (Fresnel-zone-plate-like).
        When you illuminate the developed hologram with the reference wave again, one term reconstructs the original object wavefront
        (a <b>virtual image</b>), and another term reconstructs its complex conjugate (a <b>real image</b> term) with extra curvature from the reference.
      </p>

      <div class="hr"></div>

      <h3>Definitions and paraxial spherical-wave approximation</h3>
      <p class="muted">
        Let <span class="muted">k = 2π/λ</span> and define <span class="muted">ρ² = x² + y²</span>.
        The reference point source is at <span class="muted">(0,0,−d)</span>, and we evaluate fields on the recording plane <span class="muted">z=0</span>.
      </p>

      <p class="muted">
        The exact distance from the reference source to point (x,y,0) is
        <span class="muted">r_R = √(x²+y²+d²)</span>.
        Under the paraxial assumption <span class="muted">ρ ≪ d</span>,
      </p>

      <div class="eq" id="eq_parax_r">
r_R = √(d² + ρ²) ≈ d + ρ²/(2d)
      <button class="copyBtn" data-copy-target="eq_parax_r">Copy</button>
      </div>

      <p class="muted">
        So an outgoing spherical reference field can be approximated (ignoring slow amplitude variation) as
      </p>

      <div class="eq" id="eq_ref_field">
R(x,y) ≈ A_R exp[i k ( d + ρ²/(2d) )]
      <button class="copyBtn" data-copy-target="eq_ref_field">Copy</button>
      </div>

      <p class="muted">
        (If you want a more physical amplitude, include 1/d, but it does not change fringe locations in the common “constant-amplitude” paraxial model.)
      </p>

      <h3>General hologram intensity formula</h3>
      <p class="muted">
        The recorded intensity is
      </p>
      <div class="eq" id="eq_intensity">
I(x,y) = |R+O|² = |R|² + |O|² + R*O + R O*
       = I_R + I_O + 2 Re{ R* O }
       = I_R + I_O + 2 √(I_R I_O) cos[Δφ(x,y)]
where Δφ = φ_O − φ_R
      <button class="copyBtn" data-copy-target="eq_intensity">Copy</button>
      </div>

      <p class="muted">
        The “hologram pattern” usually means the spatial dependence of the interference term, i.e. the cosine of the phase difference.
        Next we compute Δφ for each object case.
      </p>

      <div class="hr"></div>

      <h3>(a) Object wave is a plane wave traveling at angle θx</h3>

      <p class="muted">
        Take the plane wave propagating in the x–z plane with direction cosines:
        <span class="muted">k⃗ = k( sinθx, 0, cosθx )</span>.
        On the plane <span class="muted">z=0</span>, its complex field can be written as
      </p>

      <div class="eq" id="eq_obj_plane">
O_a(x,y) = A_O exp[i k ( x sinθx + z cosθx )] → (at z=0)
O_a(x,y) = A_O exp[i k x sinθx]
      <button class="copyBtn" data-copy-target="eq_obj_plane">Copy</button>
      </div>

      <p class="muted">
        The phases are:
        <span class="muted">φ_R = k(d + ρ²/(2d))</span>, and <span class="muted">φ_O = k x sinθx</span>.
        Therefore the phase difference is
      </p>

      <div class="eq" id="eq_delta_plane">
Δφ_a(x,y) = k x sinθx − k (ρ²/(2d)) − k d   (constant −kd can be dropped in cos)
So, up to an irrelevant constant:
Δφ_a(x,y) ≈ k x sinθx − (k/(2d))(x²+y²)
      <button class="copyBtn" data-copy-target="eq_delta_plane">Copy</button>
      </div>

      <p class="muted">
        Thus the hologram intensity pattern is
      </p>

      <div class="eq" id="eq_holo_plane">
I_a(x,y) = I_R + I_O + 2 √(I_R I_O) cos[ k x sinθx − (k/(2d))(x²+y²) + const ]
      <button class="copyBtn" data-copy-target="eq_holo_plane">Copy</button>
      </div>

      <div class="callout">
        <p><b>Interpretation:</b> compared with a plane-wave reference (which would give straight fringes),
          the spherical reference adds <b>quadratic curvature</b> in both x and y.
          The plane-wave tilt contributes a <b>linear carrier</b> in x, shifting fringes laterally and helping separate images.</p>
      </div>

      <h3>Reconstruction for case (a)</h3>
      <p class="muted">
        Model the developed hologram as an <b>amplitude transmittance</b> (common textbook model):
      </p>
      <div class="eq" id="eq_transmittance">
t(x,y) ≈ t0 + β I(x,y)
Illumination by the reference gives: E_out = t R
      <button class="copyBtn" data-copy-target="eq_transmittance">Copy</button>
      </div>

      <p class="muted">
        Expand the key terms:
      </p>
      <div class="eq" id="eq_recon_expand">
E_out = t0 R + β(|R|² R) + β(|O|² R) + β(R*O)R + β(R O*)R
     = (zero-order terms) + β |R|² O  + β R² O*
      <button class="copyBtn" data-copy-target="eq_recon_expand">Copy</button>
      </div>

      <ul>
        <li class="muted"><b>Zero order:</b> <span class="muted">t0 R</span> and <span class="muted">β|R|²R</span> propagate roughly like the reference (background).</li>
        <li class="muted"><b>Virtual image term:</b> <span class="muted">β|R|² O</span> is proportional to the original plane wave <span class="muted">O</span>:
          it reconstructs a plane wave at the same tilt <span class="muted">θx</span>.</li>
        <li class="muted"><b>Conjugate term:</b> <span class="muted">β R² O*</span> contains <span class="muted">O* = A_O exp(−ik x sinθx)</span> (opposite tilt)
          multiplied by <span class="muted">R²</span> (extra quadratic phase). This produces the “twin” (conjugate) wave, generally with different curvature than the virtual image.</li>
      </ul>

      <p class="muted small">
        <b>Limiting case sanity check:</b> if the reference becomes planar (<span class="muted">d→∞</span>), the quadratic reference phase vanishes,
        and the conjugate term becomes simply another plane wave (the classic “twin image”).
      </p>

      <div class="hr"></div>

      <h3>(b) Object wave is a spherical wave centered at (−x0, 0, −d1)</h3>

      <p class="muted">
        The object source point is <span class="muted">(−x0, 0, −d1)</span>.
        The distance from that point to (x,y,0) is
        <span class="muted">r_O = √((x+x0)² + y² + d1²)</span>.
        Under paraxial conditions <span class="muted">|x+x0|,|y| ≪ d1</span>, we expand:
      </p>

      <div class="eq" id="eq_parax_obj">
r_O = √(d1² + (x+x0)² + y²) ≈ d1 + [ (x+x0)² + y² ]/(2 d1)
      <button class="copyBtn" data-copy-target="eq_parax_obj">Copy</button>
      </div>

      <p class="muted">
        Thus (again ignoring slow amplitude change) the object field on z=0 is
      </p>

      <div class="eq" id="eq_obj_spherical">
O_b(x,y) ≈ A_O exp[i k ( d1 + ((x+x0)² + y²)/(2 d1) )]
      <button class="copyBtn" data-copy-target="eq_obj_spherical">Copy</button>
      </div>

      <p class="muted">
        Now compute the phase difference Δφ = φ_O − φ_R:
      </p>

      <div class="eq" id="eq_delta_spherical">
Δφ_b(x,y) = k d1 + (k/(2d1))[(x+x0)² + y²]  −  [k d + (k/(2d))(x²+y²)]
Drop the constant k(d1−d) inside cos:
Δφ_b(x,y) ≈ (k/2) (x²+y²)(1/d1 − 1/d) + (k x x0)/d1 + k x0²/(2d1)
      <button class="copyBtn" data-copy-target="eq_delta_spherical">Copy</button>
      </div>

      <p class="muted">
        Therefore the hologram intensity pattern is
      </p>

      <div class="eq" id="eq_holo_spherical">
I_b(x,y) = I_R + I_O + 2 √(I_R I_O) cos[
  (k/2)(x²+y²)(1/d1 − 1/d) + (k x x0)/d1 + const
]
      <button class="copyBtn" data-copy-target="eq_holo_spherical">Copy</button>
      </div>

      <div class="callout">
        <p><b>Interpretation:</b> the fringes are again governed by a <b>quadratic phase</b> (a Fresnel zone plate),
          but now the coefficient is set by the <b>difference of curvatures</b> of the object and reference waves:
          <span class="muted">(1/d1 − 1/d)</span>. The offset <span class="muted">x0</span> adds a <b>linear term</b> in x (a lateral carrier),
          shifting the fringe pattern and aiding image separation.</p>
      </div>

      <h3>Reconstruction for case (b)</h3>
      <p class="muted">
        Using the same amplitude hologram model <span class="muted">t ≈ t0 + β I</span> and illuminating with the reference <span class="muted">R</span>,
        the output field contains the same key “image terms”:
      </p>

      <div class="eq" id="eq_recon_terms_b">
E_out contains:
(1) Virtual image term:  β (R* O_b) R = β |R|² O_b     → reproduces the original object spherical wave O_b (virtual image).
(2) Conjugate term:      β (R O_b*) R = β R² O_b*      → produces the conjugate (“twin”) image wave.
      <button class="copyBtn" data-copy-target="eq_recon_terms_b">Copy</button>
      </div>

      <p class="muted">
        To see the curvature of the conjugate term explicitly, write the relevant phases (on z=0):
      </p>

      <div class="eq" id="eq_conjugate_phase">
O_b*(x,y) ≈ A_O exp[ -i k ( d1 + ((x+x0)²+y²)/(2d1) ) ]
R²(x,y)   ≈ A_R² exp[ i 2k ( d + (x²+y²)/(2d) ) ] = A_R² exp[ i 2kd + i k (x²+y²)/d ]

So: R² O_b* ∝ exp[i(2kd − k d1)] · exp[ i k (x²+y²)/d  − i (k/(2d1))((x+x0)²+y²) ].
      <button class="copyBtn" data-copy-target="eq_conjugate_phase">Copy</button>
      </div>

      <p class="muted">
        The quadratic coefficient in the conjugate term is proportional to
        <span class="muted">k[(1/d) − (1/2d1)]</span> (plus a linear x-term from <span class="muted">x0</span>).
        Depending on distances, this term can correspond to a <b>converging</b> or <b>diverging</b> wave—i.e., a real image can form at some distance.
        The important qualitative result (standard in holography) is:
      </p>

      <ul>
        <li class="muted"><b>Virtual image:</b> looks like the original object located at <span class="muted">(−x0,0,−d1)</span> (behind the plate).</li>
        <li class="muted"><b>Real (conjugate) image:</b> corresponds to the complex-conjugated wavefront; it generally forms on the opposite side (in front of the plate), with curvature modified by the reference.</li>
      </ul>

      <div class="finalBox">
        <h3 style="margin-top:0">Final Results (boxed)</h3>

        <div class="eq" id="eq_final">
Let k = 2π/λ and ρ² = x² + y². Reference spherical wave from (0,0,−d):
R(x,y) ≈ A_R exp[i k ( d + ρ²/(2d) )].

Hologram intensity (general):
I = |R+O|² = I_R + I_O + 2 √(I_R I_O) cos(Δφ),  Δφ = φ_O − φ_R.

(a) Object plane wave at tilt θx (on z=0):
O_a(x,y) = A_O exp[i k x sinθx]
Δφ_a(x,y) ≈ k x sinθx − (k/(2d)) (x²+y²)
⇒ I_a(x,y) = I_R + I_O + 2 √(I_R I_O) cos[ k x sinθx − (k/(2d))(x²+y²) + const ].

(b) Object spherical wave from (−x0,0,−d1) (paraxial):
O_b(x,y) ≈ A_O exp[i k ( d1 + ((x+x0)²+y²)/(2d1) )]
Δφ_b(x,y) ≈ (k/2)(x²+y²)(1/d1 − 1/d) + (k x x0)/d1  (+ const)
⇒ I_b(x,y) = I_R + I_O + 2 √(I_R I_O) cos[ (k/2)(x²+y²)(1/d1 − 1/d) + (k x x0)/d1 + const ].

Reconstruction with amplitude hologram t≈t0+βI illuminated by R:
E_out = tR contains:
• zero-order background terms,
• a virtual image term ∝ |R|² O (reconstructs the original object wave),
• a conjugate term ∝ R² O* (the “twin/real” image with curvature altered by the reference).
        <button class="copyBtn" data-copy-target="eq_final">Copy</button>
        </div>

        <p class="copyNote">Copy gives plain text suitable for notes or a solution key.</p>
      </div>

      <h3>Sanity checks</h3>
      <div class="callout">
        <p><b>Units:</b> all phases are dimensionless because they are <span class="muted">k × (length)</span>.</p>
        <p><b>Limit d → ∞ (plane reference):</b> the quadratic term <span class="muted">ρ²/(2d)</span> vanishes, and case (a) fringes become straight (classic off-axis plane reference).</p>
        <p><b>Curvature matching:</b> in case (b), if <span class="muted">d1 = d</span> and <span class="muted">x0=0</span>, then Δφ is (approximately) constant → minimal fringes, as expected when object and reference are identical.</p>
        <p><b>Physical interpretation:</b> increasing <span class="muted">θx</span> increases linear phase gradient → tighter fringes in x. Decreasing <span class="muted">d</span> strengthens curvature → more strongly curved fringes.</p>
      </div>
    </article>

    <!-- Visualizations -->
    <section id="viz">
      <h2>Interactive Visualizations</h2>
      <p class="muted">
        The plots below use the same formulas derived above (paraxial phases). Values are <b>example values</b> for visualization.
        Use the controls to switch between object cases and see how the hologram fringes change.
      </p>

      <div class="grid2">
        <div class="card">
          <h3 style="margin-top:0">Controls</h3>
          <div class="controls" aria-label="interactive controls">
            <div class="control">
              <label for="mode">Object type</label>
              <select id="mode">
                <option value="plane">Case (a): Plane wave at angle θx</option>
                <option value="spherical">Case (b): Spherical wave from (−x0,0,−d1)</option>
              </select>
              <div class="valRow"><span>Updates all plots</span><span id="modeHint">—</span></div>
            </div>

            <div class="control">
              <label for="lambdaNm">Wavelength λ (nm)</label>
              <input id="lambdaNm" type="number" min="200" max="2000" step="1" value="633">
              <div class="valRow"><span>k = 2π/λ</span><span id="kVal">—</span></div>
            </div>

            <div class="control">
              <label for="dMm">Reference distance d (mm)</label>
              <input id="dMm" type="range" min="50" max="800" step="1" value="250">
              <div class="valRow"><span>d</span><span id="dVal">—</span></div>
            </div>

            <div class="control" id="thetaBox">
              <label for="thetaDeg">Plane-wave angle θx (deg)</label>
              <input id="thetaDeg" type="range" min="-15" max="15" step="0.1" value="6">
              <div class="valRow"><span>θx</span><span id="thetaVal">—</span></div>
            </div>

            <div class="control" id="d1Box">
              <label for="d1Mm">Object distance d1 (mm)</label>
              <input id="d1Mm" type="range" min="50" max="800" step="1" value="180">
              <div class="valRow"><span>d1</span><span id="d1Val">—</span></div>
            </div>

            <div class="control" id="x0Box">
              <label for="x0Mm">Object lateral offset x0 (mm)</label>
              <input id="x0Mm" type="range" min="-25" max="25" step="0.1" value="8">
              <div class="valRow"><span>x0</span><span id="x0Val">—</span></div>
            </div>

            <div class="control">
              <label for="spanMm">Plot window half-width L (mm)</label>
              <input id="spanMm" type="range" min="1" max="20" step="0.1" value="8">
              <div class="valRow"><span>−L…+L</span><span id="spanVal">—</span></div>
            </div>

            <div class="control">
              <label for="contrast">Interference contrast (0…1)</label>
              <input id="contrast" type="range" min="0" max="1" step="0.01" value="0.9">
              <div class="valRow"><span>visibility</span><span id="cVal">—</span></div>
            </div>
          </div>

          <div class="btnRow">
            <button class="btn" id="reset">Reset example values</button>
            <button class="btn" id="toggleGrid">Toggle dense grid</button>
          </div>

          <p class="tiny muted" style="margin-top:10px">
            Notes: Intensity is shown as <span class="muted">I = 1 + V cos(Δφ)</span> (normalized, with example contrast V).
            Fringe locations are controlled by <span class="muted">Δφ(x,y)</span> from the solution.
          </p>
        </div>

        <div class="card">
          <h3 style="margin-top:0">What you are seeing</h3>
          <div class="callout">
            <p class="muted">
              <b>Main plot</b> (2D): normalized hologram intensity on z=0 over a square window (mm).
              <br><b>Secondary plot</b> (1D): cross-section <span class="muted">I(x, y=0)</span>.
              <br><b>Parameter-sweep plot</b>: local fringe period <span class="muted">p(x)=2π/|∂Δφ/∂x|</span> along y=0.
            </p>
          </div>

          <h3>Local fringe period formulas (used in sweep plot)</h3>
          <div class="eq" id="eq_period">
For case (a): Δφ_a = k x sinθx − (k/(2d))(x²+y²)
Along y=0: ∂Δφ_a/∂x = k sinθx − (k/d) x
⇒ p_a(x) = 2π / |k sinθx − (k/d) x|

For case (b): Δφ_b = (k/2)(x²+y²)(1/d1 − 1/d) + (k x x0)/d1 + const
Along y=0: ∂Δφ_b/∂x = k x (1/d1 − 1/d) + (k x0)/d1
⇒ p_b(x) = 2π / |k x (1/d1 − 1/d) + (k x0)/d1|
          <button class="copyBtn" data-copy-target="eq_period">Copy</button>
          </div>
        </div>
      </div>

      <div class="vizWrap" style="margin-top:14px">
        <figure class="canvasTall">
          <canvas id="diagram" aria-label="Diagram of holography geometry"></canvas>
          <figcaption><b>Diagram:</b> recording plane z=0, reference point (0,0,−d), and object wave geometry.</figcaption>
        </figure>

        <div class="vizRow">
          <figure>
            <canvas id="map2d" aria-label="2D hologram intensity map"></canvas>
            <figcaption><b>Main quantitative plot:</b> 2D normalized hologram intensity I(x,y) over ±L (mm).</figcaption>
          </figure>
          <figure>
            <canvas id="line1d" aria-label="1D cross-section intensity"></canvas>
            <figcaption><b>Secondary plot:</b> cross-section I(x, y=0) with axes (mm, normalized intensity).</figcaption>
          </figure>
        </div>

        <figure>
          <canvas id="sweep" aria-label="Parameter sweep plot of fringe spacing"></canvas>
          <figcaption><b>Parameter-sweep visualization:</b> local fringe period p(x) = 2π/|∂Δφ/∂x| along y=0 (mm).</figcaption>
        </figure>
      </div>
    </section>

    <footer class="muted small" style="padding: 0 2px 12px">
      <p>
        Built with vanilla HTML/CSS/JS. Paraxial (Fresnel) approximation is used for spherical waves:
        <span class="muted">√(d²+ρ²) ≈ d + ρ²/(2d)</span>.
      </p>
    </footer>
  </div>
</main>

<script>
(function(){
  // ---------- Utilities ----------
  const $ = (id)=>document.getElementById(id);
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

  function fmt(x, digits=3){
    if (!isFinite(x)) return "—";
    const ax=Math.abs(x);
    if (ax>0 && ax<1e-3) return x.toExponential(2);
    if (ax>=1e4) return x.toExponential(2);
    return x.toFixed(digits);
  }

  async function copyText(text){
    try{
      await navigator.clipboard.writeText(text);
      return true;
    }catch(e){
      // Fallback
      const ta=document.createElement('textarea');
      ta.value=text;
      document.body.appendChild(ta);
      ta.select();
      try{ document.execCommand('copy'); document.body.removeChild(ta); return true; }
      catch(err){ document.body.removeChild(ta); return false; }
    }
  }

  // Copy buttons for equations/final answer
  document.addEventListener('click', async (e)=>{
    const btn = e.target.closest('.copyBtn');
    if(!btn) return;
    const targetId = btn.getAttribute('data-copy-target');
    const el = $(targetId);
    if(!el) return;
    // copy element textContent minus "Copy"
    const txt = el.textContent.replace(/\bCopy\b/g,'').trim();
    const ok = await copyText(txt);
    btn.textContent = ok ? "Copied!" : "Copy failed";
    setTimeout(()=>btn.textContent="Copy", 900);
  });

  // ---------- State ----------
  const state = {
    mode: 'plane',       // 'plane' or 'spherical'
    lambdaNm: 633,
    dMm: 250,
    thetaDeg: 6,
    d1Mm: 180,
    x0Mm: 8,
    spanMm: 8,
    contrast: 0.9,
    denseGrid: false,
    // resolution for 2D map
    N: 220
  };

  // ---------- Canvases with HiDPI ----------
  function setupCanvas(canvas){
    const ctx = canvas.getContext('2d');
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.max(2, Math.floor(rect.width * dpr));
      canvas.height = Math.max(2, Math.floor(rect.height * dpr));
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {w: rect.width, h: rect.height, dpr};
    }
    return {canvas, ctx, resize};
  }

  const C = {
    diagram: setupCanvas($('diagram')),
    map2d: setupCanvas($('map2d')),
    line1d: setupCanvas($('line1d')),
    sweep: setupCanvas($('sweep'))
  };

  // ---------- Physics core ----------
  function paramsSI(){
    const lambda = state.lambdaNm * 1e-9;
    const k = 2*Math.PI / lambda;
    const d = state.dMm * 1e-3;
    const d1 = state.d1Mm * 1e-3;
    const x0 = state.x0Mm * 1e-3;
    const theta = state.thetaDeg * Math.PI / 180;
    const L = state.spanMm * 1e-3;
    return {lambda,k,d,d1,x0,theta,L};
  }

  // Phase difference Δφ at z=0 (dropping irrelevant constants)
  function deltaPhi(x,y, P){
    const rho2 = x*x + y*y;
    if(state.mode === 'plane'){
      // Δφ = k x sinθ - (k/(2d)) rho^2
      return P.k*(x*Math.sin(P.theta) - rho2/(2*P.d));
    }else{
      // Δφ = (k/2) rho^2 (1/d1 - 1/d) + (k x x0)/d1  (const dropped)
      return (P.k/2)*rho2*(1/P.d1 - 1/P.d) + P.k*(x*P.x0)/P.d1;
    }
  }

  // Normalized intensity model: I = 1 + V cos(Δφ)
  function intensityNorm(x,y,P){
    return 1 + state.contrast*Math.cos(deltaPhi(x,y,P));
  }

  // Local fringe period p(x) along y=0: p=2π/|∂Δφ/∂x|
  function fringePeriod(x,P){
    let dphidx;
    if(state.mode==='plane'){
      // ∂Δφ/∂x = k sinθ - (k/d) x
      dphidx = P.k*Math.sin(P.theta) - (P.k/P.d)*x;
    }else{
      // ∂Δφ/∂x = k x (1/d1 - 1/d) + (k x0)/d1
      dphidx = P.k*x*(1/P.d1 - 1/P.d) + P.k*(P.x0/P.d1);
    }
    const denom = Math.abs(dphidx);
    if(denom < 1e-12) return Infinity;
    return 2*Math.PI/denom;
  }

  // ---------- Plotting helpers ----------
  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title, opts={}){
    const {x,y,w,h} = box;
    const padL = 56, padR=18, padT=34, padB=44;
    const plot = {x:x+padL, y:y+padT, w:w-padL-padR, h:h-padT-padB};

    // panel
    ctx.save();
    ctx.fillStyle = 'rgba(7,10,14,0.15)';
    ctx.fillRect(x,y,w,h);

    // title
    ctx.fillStyle = 'rgba(233,238,246,0.92)';
    ctx.font = '600 14px ui-sans-serif, system-ui';
    ctx.fillText(title, x+10, y+20);

    // grid & axes
    const gridN = opts.dense ? 10 : 6;
    ctx.strokeStyle = 'rgba(108,122,143,0.35)';
    ctx.lineWidth = 1;

    // gridlines
    for(let i=0;i<=gridN;i++){
      const tx = plot.x + plot.w*(i/gridN);
      const ty = plot.y + plot.h*(i/gridN);
      ctx.beginPath(); ctx.moveTo(tx, plot.y); ctx.lineTo(tx, plot.y+plot.h); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(plot.x, ty); ctx.lineTo(plot.x+plot.w, ty); ctx.stroke();
    }

    // axes border
    ctx.strokeStyle = 'rgba(223,246,255,0.55)';
    ctx.strokeRect(plot.x, plot.y, plot.w, plot.h);

    // tick labels
    ctx.fillStyle = 'rgba(169,182,199,0.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

    const ticks = opts.dense ? 6 : 5;
    for(let i=0;i<=ticks;i++){
      const fx = i/ticks;
      const xv = xMin + (xMax-xMin)*fx;
      const px = plot.x + plot.w*fx;
      ctx.fillText(fmt(xv, opts.tickDigits??2), px-12, plot.y+plot.h+18);

      const fy = i/ticks;
      const yv = yMax - (yMax-yMin)*fy;
      const py = plot.y + plot.h*fy;
      ctx.fillText(fmt(yv, opts.tickDigits??2), plot.x-50, py+4);

      // tick marks
      ctx.strokeStyle = 'rgba(223,246,255,0.55)';
      ctx.beginPath(); ctx.moveTo(px, plot.y+plot.h); ctx.lineTo(px, plot.y+plot.h+6); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(plot.x-6, py); ctx.lineTo(plot.x, py); ctx.stroke();
    }

    // axis labels
    ctx.fillStyle = 'rgba(233,238,246,0.92)';
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillText(xLabel, plot.x + plot.w/2 - ctx.measureText(xLabel).width/2, y + h - 10);

    // y label rotated
    ctx.save();
    ctx.translate(x+14, plot.y + plot.h/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
    ctx.restore();

    ctx.restore();
    return plot;
  }

  function mapToPlot(x, y, plot, xMin, xMax, yMin, yMax){
    const px = plot.x + (x - xMin) / (xMax - xMin) * plot.w;
    const py = plot.y + (yMax - y) / (yMax - yMin) * plot.h;
    return {px,py};
  }

  // ---------- Draw: Diagram ----------
  function drawDiagram(){
    const {ctx, resize} = C.diagram;
    const {w,h} = resize();

    ctx.clearRect(0,0,w,h);

    // Coordinate mapping
    // We'll draw a side view (x-z plane) plus small inset for y axis notion.
    const margin = 16;
    const box = {x: margin, y: margin, w: w-2*margin, h: h-2*margin};

    // background card-ish
    ctx.save();
    ctx.fillStyle='rgba(7,10,14,0.25)';
    ctx.fillRect(box.x, box.y, box.w, box.h);
    ctx.restore();

    // scale
    const P = paramsSI();
    const zMin = -Math.max(P.d, P.d1)*1.15;
    const zMax = 0.02;
    const xSpan = P.L*1.2 + Math.abs(P.x0)*1.2 + 0.002;
    const xMin = -xSpan, xMax = xSpan;

    function toScreen(x,z){
      const sx = box.x + 54 + (x - xMin)/(xMax-xMin)*(box.w-80);
      const sz = box.y + 34 + (zMax - z)/(zMax-zMin)*(box.h-70);
      return {sx, sz};
    }

    // axes
    ctx.save();
    ctx.strokeStyle='rgba(223,246,255,0.55)';
    ctx.lineWidth=1;
    // x axis at z=0
    const a0 = toScreen(xMin,0), a1 = toScreen(xMax,0);
    ctx.beginPath(); ctx.moveTo(a0.sx, a0.sz); ctx.lineTo(a1.sx, a1.sz); ctx.stroke();
    // z axis at x=0
    const b0 = toScreen(0,zMin), b1 = toScreen(0,0.0);
    ctx.beginPath(); ctx.moveTo(b0.sx, b0.sz); ctx.lineTo(b1.sx, b1.sz); ctx.stroke();

    ctx.fillStyle='rgba(233,238,246,0.92)';
    ctx.font='12px ui-sans-serif, system-ui';
    ctx.fillText('x (mm)', a1.sx-44, a1.sz-8);
    ctx.fillText('z (mm)', b0.sx+6, b0.sz+14);

    // Recording plane z=0
    ctx.fillStyle='rgba(123,220,255,0.10)';
    ctx.strokeStyle='rgba(123,220,255,0.35)';
    ctx.beginPath();
    ctx.rect(box.x+54, a0.sz-8, box.w-80, 16);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle='rgba(169,182,199,0.95)';
    ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText('Recording plane: z = 0', box.x+64, a0.sz-12);

    // Reference source at (0, -d)
    const ref = toScreen(0,-P.d);
    ctx.fillStyle='rgba(123,220,255,0.95)';
    ctx.beginPath(); ctx.arc(ref.sx, ref.sz, 5, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='rgba(233,238,246,0.92)';
    ctx.font='12px ui-sans-serif, system-ui';
    ctx.fillText('Reference source (0,0,−d)', ref.sx+10, ref.sz-8);

    // Reference wavefront hint (arcs)
    ctx.strokeStyle='rgba(123,220,255,0.25)';
    for(let r=0.03; r<=0.10; r+=0.02){
      // approximate circles in x-z plane centered at ref
      const N=80;
      ctx.beginPath();
      for(let i=0;i<=N;i++){
        const t = (i/N)*Math.PI; // upper half
        const x = r*Math.cos(t);
        const z = -P.d + r*Math.sin(t);
        const s = toScreen(x,z);
        if(i===0) ctx.moveTo(s.sx,s.sz); else ctx.lineTo(s.sx,s.sz);
      }
      ctx.stroke();
    }

    // Object depiction
    if(state.mode==='plane'){
      // Draw plane wave direction arrow
      const x0 = -xSpan*0.55;
      const z0 = -P.d*0.25;
      const start = toScreen(x0,z0);
      const dir = {x: Math.sin(P.theta), z: Math.cos(P.theta)};
      const len = 0.10; // meters-ish in drawing scale
      const end = toScreen(x0 + len*dir.x, z0 + len*dir.z);
      ctx.strokeStyle='rgba(167,255,179,0.85)';
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(start.sx,start.sz); ctx.lineTo(end.sx,end.sz); ctx.stroke();
      // arrow head
      const ang = Math.atan2(end.sz-start.sz, end.sx-start.sx);
      ctx.beginPath();
      ctx.moveTo(end.sx, end.sz);
      ctx.lineTo(end.sx-10*Math.cos(ang-0.35), end.sz-10*Math.sin(ang-0.35));
      ctx.lineTo(end.sx-10*Math.cos(ang+0.35), end.sz-10*Math.sin(ang+0.35));
      ctx.closePath();
      ctx.fillStyle='rgba(167,255,179,0.85)';
      ctx.fill();

      ctx.fillStyle='rgba(233,238,246,0.92)';
      ctx.font='12px ui-sans-serif, system-ui';
      ctx.fillText('Object: plane wave at angle θx', start.sx+10, start.sz-8);

      // angle marker near origin
      const o = toScreen(0,-0.001);
      ctx.strokeStyle='rgba(167,255,179,0.45)';
      ctx.lineWidth=1;
      ctx.beginPath();
      const rAng=24;
      ctx.arc(o.sx, o.sz, rAng, -Math.PI/2, -Math.PI/2 + P.theta);
      ctx.stroke();
      ctx.fillStyle='rgba(169,182,199,0.95)';
      ctx.fillText('θx', o.sx + rAng+6, o.sz - 6);
    }else{
      // spherical object source at (-x0, -d1)
      const obj = toScreen(-P.x0, -P.d1);
      ctx.fillStyle='rgba(167,255,179,0.95)';
      ctx.beginPath(); ctx.arc(obj.sx,obj.sz,5,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='rgba(233,238,246,0.92)';
      ctx.font='12px ui-sans-serif, system-ui';
      ctx.fillText('Object source (−x0,0,−d1)', obj.sx+10, obj.sz-8);

      // object wavefront arcs
      ctx.strokeStyle='rgba(167,255,179,0.25)';
      for(let r=0.03; r<=0.10; r+=0.02){
        const N=80;
        ctx.beginPath();
        for(let i=0;i<=N;i++){
          const t = (i/N)*Math.PI;
          const x = -P.x0 + r*Math.cos(t);
          const z = -P.d1 + r*Math.sin(t);
          const s = toScreen(x,z);
          if(i===0) ctx.moveTo(s.sx,s.sz); else ctx.lineTo(s.sx,s.sz);
        }
        ctx.stroke();
      }
    }

    // Legend-ish
    ctx.fillStyle='rgba(169,182,199,0.95)';
    ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText('Blue: reference R   Green: object O', box.x+60, box.y+box.h-16);

    ctx.restore();
  }

  // ---------- Draw: 2D intensity map ----------
  function drawMap2D(){
    const {ctx, resize, canvas} = C.map2d;
    const {w,h} = resize();
    ctx.clearRect(0,0,w,h);

    const P = paramsSI();
    const L = P.L; // meters
    const xMin = -L, xMax = L;
    const yMin = -L, yMax = L;

    // Axes
    const plot = drawAxes(ctx,
      {x:0,y:0,w,h},
      -state.spanMm, state.spanMm, -state.spanMm, state.spanMm,
      'x (mm)', 'y (mm)',
      `2D Hologram Intensity  I(x,y) = 1 + V cos(Δφ)   (V=${fmt(state.contrast,2)})`,
      {dense: state.denseGrid, tickDigits: 1}
    );

    // Render intensity into an ImageData in plot region
    const N = state.N;
    const imgW = Math.max(2, Math.floor(plot.w));
    const imgH = Math.max(2, Math.floor(plot.h));

    // To keep fast, render at reduced resolution if plot is huge
    const scale = Math.max(1, Math.floor(Math.max(imgW,imgH)/N));
    const rw = Math.max(2, Math.floor(imgW/scale));
    const rh = Math.max(2, Math.floor(imgH/scale));

    const image = ctx.createImageData(rw, rh);
    const data = image.data;

    for(let j=0;j<rh;j++){
      const y = yMax - (j/(rh-1))*(yMax-yMin);
      for(let i=0;i<rw;i++){
        const x = xMin + (i/(rw-1))*(xMax-xMin);
        const I = intensityNorm(x,y,P); // around [1-V, 1+V]
        // map to grayscale 0..255
        const g = Math.round(clamp((I - (1-state.contrast))/(2*state.contrast),0,1)*255);
        const idx = 4*(j*rw+i);
        data[idx+0]=g;
        data[idx+1]=g;
        data[idx+2]=g;
        data[idx+3]=255;
      }
    }

    // Draw into plot area with nearest-neighbor scaling
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    // Put image then scale to plot
    // We'll draw to an offscreen bitmap by putting at (0,0) and scaling with drawImage
    const off = document.createElement('canvas');
    off.width = rw; off.height = rh;
    off.getContext('2d').putImageData(image,0,0);
    ctx.drawImage(off, plot.x, plot.y, plot.w, plot.h);
    ctx.restore();

    // Add a simple legend bar for grayscale mapping
    ctx.save();
    const barW = 120, barH=10;
    const bx = plot.x + plot.w - barW - 8;
    const by = plot.y + 8;
    const grad = ctx.createLinearGradient(bx,by,bx+barW,by);
    grad.addColorStop(0,'rgb(0,0,0)');
    grad.addColorStop(1,'rgb(255,255,255)');
    ctx.fillStyle = grad;
    ctx.fillRect(bx,by,barW,barH);
    ctx.strokeStyle = 'rgba(223,246,255,0.55)';
    ctx.strokeRect(bx,by,barW,barH);
    ctx.fillStyle='rgba(169,182,199,0.95)';
    ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText('low', bx, by+barH+14);
    ctx.fillText('high', bx+barW-28, by+barH+14);
    ctx.restore();
  }

  // ---------- Draw: 1D line plot I(x,0) ----------
  function drawLine1D(){
    const {ctx, resize} = C.line1d;
    const {w,h} = resize();
    ctx.clearRect(0,0,w,h);

    const P = paramsSI();
    const L = P.L;
    const xMin = -L, xMax = L;

    // y range: [1-V, 1+V]
    const yMin = 1 - state.contrast, yMax = 1 + state.contrast;

    const plot = drawAxes(ctx,
      {x:0,y:0,w,h},
      -state.spanMm, state.spanMm, yMin, yMax,
      'x (mm)', 'I(x,0) (normalized)',
      'Cross-section at y = 0',
      {dense: state.denseGrid, tickDigits: 2}
    );

    // draw curve
    ctx.save();
    ctx.strokeStyle = 'rgba(123,220,255,0.95)';
    ctx.lineWidth = 2;

    const N = 900;
    ctx.beginPath();
    for(let i=0;i<=N;i++){
      const x = xMin + (i/N)*(xMax-xMin);
      const y = intensityNorm(x,0,P);
      const m = mapToPlot(x*1e3, y, plot, -state.spanMm, state.spanMm, yMin, yMax);
      if(i===0) ctx.moveTo(m.px,m.py); else ctx.lineTo(m.px,m.py);
    }
    ctx.stroke();

    // midline at I=1
    ctx.strokeStyle='rgba(167,255,179,0.55)';
    ctx.lineWidth=1;
    const m0 = mapToPlot(-state.spanMm, 1, plot, -state.spanMm, state.spanMm, yMin, yMax);
    const m1 = mapToPlot(state.spanMm, 1, plot, -state.spanMm, state.spanMm, yMin, yMax);
    ctx.beginPath(); ctx.moveTo(m0.px,m0.py); ctx.lineTo(m1.px,m1.py); ctx.stroke();
    ctx.fillStyle='rgba(169,182,199,0.95)';
    ctx.font='12px ui-sans-serif, system-ui';
    ctx.fillText('I = 1', m1.px-34, m1.py-6);

    ctx.restore();
  }

  // ---------- Draw: sweep plot p(x) ----------
  function drawSweep(){
    const {ctx, resize} = C.sweep;
    const {w,h} = resize();
    ctx.clearRect(0,0,w,h);

    const P = paramsSI();
    const L = P.L;
    const xMin = -L, xMax = L;

    // Compute p(x) in mm, clamp huge values for plotting
    const N = 700;
    let pMin = Infinity, pMax = -Infinity;
    const xs = new Array(N+1);
    const ps = new Array(N+1);
    for(let i=0;i<=N;i++){
      const x = xMin + (i/N)*(xMax-xMin);
      const p = fringePeriod(x,P); // meters
      const pmm = p*1e3;
      xs[i]=x*1e3; // mm
      // cap for display
      const capped = Math.min(pmm, 50);
      ps[i]=capped;
      if(isFinite(capped)){
        pMin=Math.min(pMin,capped);
        pMax=Math.max(pMax,capped);
      }
    }
    if(!isFinite(pMin) || !isFinite(pMax) || pMin===pMax){
      pMin=0; pMax=10;
    }
    pMin = Math.max(0, Math.min(pMin, 10));
    pMax = Math.max(pMin+1e-6, Math.min(pMax, 50));

    const title = (state.mode==='plane')
      ? 'Local fringe period p(x) along y=0 (plane-wave object)'
      : 'Local fringe period p(x) along y=0 (spherical object)';

    const plot = drawAxes(ctx,
      {x:0,y:0,w,h},
      -state.spanMm, state.spanMm, pMin, pMax,
      'x (mm)', 'p(x) (mm)',
      title + '  (capped at 50 mm)',
      {dense: state.denseGrid, tickDigits: 1}
    );

    // draw curve
    ctx.save();
    ctx.strokeStyle='rgba(255,207,123,0.95)';
    ctx.lineWidth=2;
    ctx.beginPath();
    for(let i=0;i<=N;i++){
      const x = xs[i];
      const p = ps[i];
      const m = mapToPlot(x, p, plot, -state.spanMm, state.spanMm, pMin, pMax);
      if(i===0) ctx.moveTo(m.px,m.py); else ctx.lineTo(m.px,m.py);
    }
    ctx.stroke();

    // annotate where denominator nearly zero -> huge spacing
    // Find the max point (likely near singularity)
    let imax=0;
    for(let i=1;i<ps.length;i++) if(ps[i]>ps[imax]) imax=i;
    const mm = mapToPlot(xs[imax], ps[imax], plot, -state.spanMm, state.spanMm, pMin, pMax);
    ctx.fillStyle='rgba(233,238,246,0.92)';
    ctx.font='12px ui-sans-serif, system-ui';
    ctx.fillText('largest spacing', mm.px+8, mm.py-8);

    ctx.restore();
  }

  // ---------- UI sync ----------
  function syncUI(){
    $('mode').value = state.mode;
    $('lambdaNm').value = state.lambdaNm;
    $('dMm').value = state.dMm;
    $('thetaDeg').value = state.thetaDeg;
    $('d1Mm').value = state.d1Mm;
    $('x0Mm').value = state.x0Mm;
    $('spanMm').value = state.spanMm;
    $('contrast').value = state.contrast;

    const P = paramsSI();
    $('kVal').textContent = `k = ${fmt(P.k,2)} rad/m`;
    $('dVal').textContent = `${fmt(state.dMm,0)} mm`;
    $('thetaVal').textContent = `${fmt(state.thetaDeg,1)}°`;
    $('d1Val').textContent = `${fmt(state.d1Mm,0)} mm`;
    $('x0Val').textContent = `${fmt(state.x0Mm,1)} mm`;
    $('spanVal').textContent = `L = ${fmt(state.spanMm,1)} mm`;
    $('cVal').textContent = `V = ${fmt(state.contrast,2)}`;

    $('modeHint').textContent = (state.mode==='plane')
      ? 'Δφ = k x sinθ − kρ²/(2d)'
      : 'Δφ = (k/2)ρ²(1/d1−1/d) + k x x0/d1';

    // Show/hide relevant controls
    $('thetaBox').style.display = (state.mode==='plane') ? 'block' : 'none';
    $('d1Box').style.display = (state.mode==='spherical') ? 'block' : 'none';
    $('x0Box').style.display = (state.mode==='spherical') ? 'block' : 'none';
  }

  function renderAll(){
    syncUI();
    drawDiagram();
    drawMap2D();
    drawLine1D();
    drawSweep();
  }

  // ---------- Event wiring ----------
  $('mode').addEventListener('change', (e)=>{ state.mode = e.target.value; renderAll(); });

  $('lambdaNm').addEventListener('input', (e)=>{
    const v = parseFloat(e.target.value);
    state.lambdaNm = clamp(v, 200, 2000);
    renderAll();
  });

  $('dMm').addEventListener('input', (e)=>{ state.dMm = parseFloat(e.target.value); renderAll(); });
  $('thetaDeg').addEventListener('input', (e)=>{ state.thetaDeg = parseFloat(e.target.value); renderAll(); });
  $('d1Mm').addEventListener('input', (e)=>{ state.d1Mm = parseFloat(e.target.value); renderAll(); });
  $('x0Mm').addEventListener('input', (e)=>{ state.x0Mm = parseFloat(e.target.value); renderAll(); });
  $('spanMm').addEventListener('input', (e)=>{ state.spanMm = parseFloat(e.target.value); renderAll(); });
  $('contrast').addEventListener('input', (e)=>{ state.contrast = parseFloat(e.target.value); renderAll(); });

  $('reset').addEventListener('click', ()=>{
    state.mode='plane';
    state.lambdaNm=633;
    state.dMm=250;
    state.thetaDeg=6;
    state.d1Mm=180;
    state.x0Mm=8;
    state.spanMm=8;
    state.contrast=0.9;
    state.denseGrid=false;
    renderAll();
  });

  $('toggleGrid').addEventListener('click', ()=>{
    state.denseGrid = !state.denseGrid;
    renderAll();
  });

  // Resize handling
  let resizeTimer=null;
  window.addEventListener('resize', ()=>{
    clearTimeout(resizeTimer);
    resizeTimer=setTimeout(renderAll, 80);
  });

  // Initial render
  renderAll();
})();
</script>
</body>
</html>
