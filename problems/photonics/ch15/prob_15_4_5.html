<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Growth of the Photon-Flux Density in a Saturated Laser Amplifier</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f1722;
      --card:#111c2a;
      --ink:#e8eef7;
      --muted:#a9b6c7;
      --faint:#6f7d90;
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.16);
      --accent:#7dd3fc;
      --accent2:#a7f3d0;
      --warn:#fbbf24;
      --good:#34d399;
      --bad:#fb7185;
      --shadow: 0 18px 60px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1200px 600px at 15% 10%, rgba(125,211,252,.10), transparent 60%),
        radial-gradient(900px 450px at 85% 15%, rgba(167,243,208,.10), transparent 55%),
        linear-gradient(180deg, #070a0f, var(--bg));
      line-height:1.55;
    }

    header{
      padding:32px 18px 18px;
      max-width:1200px;
      margin:0 auto;
    }

    .title{
      display:grid;
      gap:10px;
      align-items:start;
    }
    h1{
      margin:0;
      font-size:clamp(26px, 3.4vw, 42px);
      letter-spacing:.2px;
      line-height:1.15;
    }
    .subtitle{
      color:var(--muted);
      max-width:72ch;
      font-size:clamp(14px, 1.6vw, 18px);
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding:18px;
      display:grid;
      grid-template-columns: 300px 1fr;
      gap:18px;
      align-items:start;
    }

    nav{
      position:sticky;
      top:14px;
      align-self:start;
      background:linear-gradient(180deg, rgba(17,28,42,.92), rgba(17,28,42,.80));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:14px;
      box-shadow:var(--shadow);
      backdrop-filter: blur(10px);
    }
    nav .toc-title{
      font-weight:700;
      letter-spacing:.3px;
      margin:0 0 10px 0;
      font-size:14px;
      color:var(--ink);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .toc-dot{
      width:9px; height:9px; border-radius:99px;
      background: radial-gradient(circle at 30% 30%, var(--accent), rgba(125,211,252,.15));
      box-shadow: 0 0 0 3px rgba(125,211,252,.12);
    }
    nav a{
      display:block;
      text-decoration:none;
      color:var(--muted);
      padding:8px 10px;
      border-radius:12px;
      border:1px solid transparent;
      transition: all .18s ease;
      font-size:14px;
    }
    nav a:hover{
      color:var(--ink);
      background:rgba(125,211,252,.08);
      border-color:rgba(125,211,252,.18);
      transform: translateX(2px);
    }

    section{
      background:linear-gradient(180deg, rgba(17,28,42,.88), rgba(15,23,34,.78));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:18px;
      box-shadow:var(--shadow);
      backdrop-filter: blur(8px);
      margin-bottom:16px;
      overflow:hidden;
    }

    h2{
      margin:0 0 10px 0;
      font-size:clamp(18px, 2.2vw, 26px);
      letter-spacing:.2px;
    }
    h3{
      margin:16px 0 8px;
      font-size:clamp(15px, 1.7vw, 20px);
      color:var(--ink);
    }
    p{ margin:10px 0; color:var(--ink); }
    .muted{ color:var(--muted); }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1.2fr .8fr .8fr;
      gap:14px;
    }
    .card{
      background:linear-gradient(180deg, rgba(17,28,42,.9), rgba(14,20,30,.7));
      border:1px solid var(--line);
      border-radius:16px;
      padding:14px;
    }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }

    .callout{
      border-radius:16px;
      padding:12px 12px;
      border:1px solid var(--line2);
      background: rgba(255,255,255,.03);
      position:relative;
      overflow:hidden;
    }
    .callout::before{
      content:"";
      position:absolute;
      left:-40px; top:-40px;
      width:110px; height:110px;
      background: radial-gradient(circle at 35% 35%, rgba(125,211,252,.22), transparent 65%);
      transform: rotate(12deg);
    }
    .callout h4{
      margin:0 0 6px;
      font-size:14px;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .tag{
      font-size:12px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid var(--line2);
      color:var(--muted);
    }
    .tag.warn{ border-color:rgba(251,191,36,.35); color:#fde68a; }
    .tag.good{ border-color:rgba(52,211,153,.35); color:#bbf7d0; }

    ul{ margin:10px 0 0 18px; color:var(--ink); }
    li{ margin:6px 0; color:var(--ink); }
    .small{ font-size:13px; color:var(--muted); }

    .eq{
      margin:10px 0;
      background:rgba(0,0,0,.25);
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px 12px;
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:start;
    }
    pre{
      margin:0;
      font-family:var(--mono);
      font-size:13px;
      line-height:1.45;
      white-space:pre-wrap;
      word-break:break-word;
      color:#eaf2ff;
    }
    .btn{
      cursor:pointer;
      user-select:none;
      border:none;
      background:rgba(125,211,252,.14);
      color:var(--ink);
      padding:8px 10px;
      border-radius:12px;
      font-weight:650;
      letter-spacing:.2px;
      font-size:12px;
      transition:transform .15s ease, background .15s ease, opacity .15s ease;
    }
    .btn:hover{ transform: translateY(-1px); background:rgba(125,211,252,.18); }
    .btn:active{ transform: translateY(0px); opacity:.9; }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
      align-items:end;
      margin-top:10px;
    }
    .control{
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px;
      background: rgba(255,255,255,.02);
    }
    label{
      display:block;
      font-size:12px;
      color:var(--muted);
      margin-bottom:8px;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    select{
      width:100%;
      background:rgba(0,0,0,.25);
      border:1px solid var(--line);
      color:var(--ink);
      border-radius:12px;
      padding:10px 10px;
      outline:none;
    }
    .readout{
      font-family:var(--mono);
      font-size:12px;
      color:#dbeafe;
      margin-top:8px;
      opacity:.95;
    }

    figure{ margin:0; }
    canvas{
      width:100%;
      height:340px;
      display:block;
      border-radius:16px;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(0,0,0,.26), rgba(0,0,0,.18));
    }
    .canvasTall{ height:380px; }
    .canvasShort{ height:280px; }

    .twoCanv{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }

    .hr{
      height:1px;
      background:var(--line);
      margin:14px 0;
    }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding:10px 18px 32px;
      color:var(--faint);
      font-size:12px;
    }

    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.02);
      color:var(--muted);
      font-size:12px;
    }

    .kbd{
      font-family:var(--mono);
      font-size:12px;
      padding:2px 6px;
      border-radius:8px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.22);
      color:#eaf2ff;
    }

    .boxFinal{
      border:1px solid rgba(52,211,153,.30);
      background: rgba(52,211,153,.06);
    }

    .boxWarn{
      border:1px solid rgba(251,191,36,.30);
      background: rgba(251,191,36,.06);
    }

    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
      nav{ position:relative; top:auto; }
      .twoCanv{ grid-template-columns: 1fr; }
      .controls{ grid-template-columns: 1fr; }
      .grid2{ grid-template-columns: 1fr; }
      .grid3{ grid-template-columns: 1fr; }
      canvas{ height:320px; }
      .canvasShort{ height:260px; }
      .canvasTall{ height:340px; }
    }

    @media print{
      body{ background:#fff; color:#000; }
      nav{ display:none; }
      section{ box-shadow:none; border:1px solid #ddd; background:#fff; }
      canvas{ border:1px solid #bbb; background:#fff; }
      .btn{ display:none; }
      .eq{ background:#fff; border:1px solid #ddd; }
      pre{ color:#000; }
      .muted,.small{ color:#333; }
    }

    /* subtle entrance animation */
    @keyframes floatIn{
      from{ opacity:0; transform: translateY(10px); }
      to{ opacity:1; transform: translateY(0px); }
    }
    section{ animation: floatIn .35s ease both; }
  </style>
</head>

<body>
<header>
  <div class="title">
    <h1>15.4-5 — Growth of the Photon-Flux Density in a Saturated Laser Amplifier</h1>
    <div class="subtitle">
      We solve the standard <b>saturable gain</b> model for a laser amplifier, plot the normalized photon-flux density
      versus the dimensionless length <span class="kbd">&gamma;<sub>0</sub>z</span>, and identify where saturation begins.
      Everything below is self-contained (no external libraries) and includes interactive plots.
    </div>
  </div>
</header>

<main>
  <!-- Sticky TOC -->
  <nav aria-label="Table of contents">
    <div class="toc-title"><span class="toc-dot"></span>Table of Contents</div>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy & Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
  </nav>

  <article>
    <!-- Quick Summary -->
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>What this is about:</b> how photon-flux density <span class="kbd">&phi;(z)</span> grows in a laser amplifier when gain saturates at high flux.</li>
        <li><b>Key physics idea:</b> the gain coefficient decreases as intensity/flux builds up: <span class="kbd">&gamma;(&phi;)=&gamma;<sub>0</sub>/(1+&phi;/&phi;<sub>s</sub>)</span>.</li>
        <li><b>Governing ODE:</b> <span class="kbd">d&phi;/dz = &gamma;<sub>0</sub>&phi;/(1+&phi;/&phi;<sub>s</sub>)</span> (steady-state, 1D propagation).</li>
        <li><b>Integrated relation (given):</b> <span class="kbd">ln(&phi;(z)/&phi;(0)) + (&phi;(z)-&phi;(0))/&phi;<sub>s</sub> = &gamma;<sub>0</sub> z</span>.</li>
        <li><b>What we plot:</b> normalized gain <span class="kbd">G(z)=&phi;(z)/&phi;(0)</span> vs <span class="kbd">u=&gamma;<sub>0</sub>z</span> for <span class="kbd">X=&phi;(0)/&phi;<sub>s</sub>=0.05</span>.</li>
        <li><b>Onset of saturation (practical marker):</b> when <span class="kbd">&phi;(z)&approx;&phi;<sub>s</sub></span> (gain drops to half of small-signal): occurs at <span class="kbd">u<sub>sat</sub> = ln(1/X) + (1-X) &approx; 3.95</span> for <span class="kbd">X=0.05</span>.</li>
        <li><b>Final result type:</b> symbolic implicit solution (plus fast numerical inversion for plots).</li>
      </ul>

      <div class="callouts">
        <div class="callout boxWarn">
          <h4><span class="tag warn">Key idea</span> Saturation is not a “switch”</h4>
          <div class="small">
            The amplifier starts deviating from exponential growth <i>gradually</i>. A clean, physics-based marker is
            the point where <span class="kbd">&phi;</span> reaches the saturation flux <span class="kbd">&phi;<sub>s</sub></span>,
            making the gain coefficient drop to <span class="kbd">&gamma;<sub>0</sub>/2</span>.
          </div>
        </div>
        <div class="callout boxFinal">
          <h4><span class="tag good">Final</span> Saturation-onset location for X=0.05</h4>
          <div class="small">
            Set <span class="kbd">&phi;(z)=&phi;<sub>s</sub></span> ⇒ <span class="kbd">G=1/X=20</span>. Then:
            <span class="kbd">u<sub>sat</sub>=&gamma;<sub>0</sub>z<sub>sat</sub>=ln(20)+0.95≈3.95</span>.
          </div>
        </div>
      </div>
    </section>

    <!-- PART 0 -->
    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="grid2">
        <div class="card">
          <h3>Core definitions (symbols & units)</h3>
          <ul>
            <li><span class="kbd">&phi;(z)</span>: photon-flux density along the amplifier (photons·m<sup>−2</sup>·s<sup>−1</sup>). In many texts this is proportional to optical intensity.</li>
            <li><span class="kbd">z</span>: propagation distance inside the gain medium (m).</li>
            <li><span class="kbd">&gamma;<sub>0</sub></span>: small-signal (unsaturated) gain coefficient (m<sup>−1</sup>). When the signal is weak, <span class="kbd">&phi;</span> grows exponentially with rate <span class="kbd">&gamma;<sub>0</sub></span>.</li>
            <li><span class="kbd">&phi;<sub>s</sub></span>: saturation photon-flux density (same units as <span class="kbd">&phi;</span>). It sets the scale at which gain noticeably decreases.</li>
            <li><span class="kbd">u=&gamma;<sub>0</sub>z</span>: dimensionless “gain-length”. Very convenient for plotting.</li>
          </ul>
        </div>

        <div class="card">
          <h3>Physical meaning</h3>
          <p class="muted">
            In a population-inverted medium, stimulated emission amplifies light. But stimulated emission also
            <b>depletes the inversion</b>. As the signal grows, it “uses up” the available gain,
            so the local gain coefficient drops with increasing photon flux.
          </p>
          <p class="muted">
            A common steady-state model is
            <span class="kbd">&gamma;(&phi;)=&gamma;<sub>0</sub>/(1+&phi;/&phi;<sub>s</sub>)</span>:
            at low flux <span class="kbd">&phi;&ll;&phi;<sub>s</sub></span> we have nearly constant gain,
            while at high flux <span class="kbd">&phi;&gg;&phi;<sub>s</sub></span> the gain decreases roughly like <span class="kbd">1/&phi;</span>.
          </p>
        </div>
      </div>

      <div class="hr"></div>

      <div class="grid2">
        <div class="card">
          <h3>Key law / model (and validity)</h3>
          <ul>
            <li><b>1D propagation, steady-state:</b> the signal evolves with distance, not time (CW or slowly varying compared to population relaxation).</li>
            <li><b>Uniform pump / uniform medium:</b> <span class="kbd">&gamma;<sub>0</sub></span> and <span class="kbd">&phi;<sub>s</sub></span> taken constant in <span class="kbd">z</span>.</li>
            <li><b>No diffraction, no reflections:</b> we track photon flux density along the axis only (a “traveling-wave” amplifier picture).</li>
            <li><b>Saturable gain only:</b> other effects (ASE, reabsorption, spatial hole burning) are ignored unless specified.</li>
          </ul>
        </div>

        <div class="card">
          <h3>Common approximations (why we use them)</h3>
          <ul>
            <li><b>Small-signal regime:</b> if <span class="kbd">&phi;&ll;&phi;<sub>s</sub></span>, then <span class="kbd">&gamma;(&phi;)&approx;&gamma;<sub>0</sub></span> and <span class="kbd">&phi;(z)=&phi;(0)e^{&gamma;<sub>0</sub>z}</span>.</li>
            <li><b>Deep saturation:</b> if <span class="kbd">&phi;&gg;&phi;<sub>s</sub></span>, growth becomes slower; the ODE approaches <span class="kbd">d&phi;/dz &approx; &gamma;<sub>0</sub>&phi;<sub>s</sub></span>, nearly linear in <span class="kbd">z</span>.</li>
            <li><b>Dimensionless form:</b> scaling with <span class="kbd">u=&gamma;<sub>0</sub>z</span> and <span class="kbd">X=&phi;(0)/&phi;<sub>s</sub></span> exposes the universal behavior.</li>
          </ul>
        </div>
      </div>

      <div class="callouts">
        <div class="callout">
          <h4><span class="tag">Mini intuition</span> Example 1: weak input</h4>
          <div class="small">
            If the input is tiny (say <span class="kbd">X=10<sup>−3</sup></span>), the medium barely notices the signal at first,
            so the first several gain-lengths look almost exponential before saturation bends the curve.
          </div>
        </div>
        <div class="callout">
          <h4><span class="tag">Mini intuition</span> Example 2: stronger input</h4>
          <div class="small">
            If the input is already near saturation (say <span class="kbd">X=0.5</span>), the gain starts reduced immediately,
            so the curve is sub-exponential almost from <span class="kbd">u=0</span>.
          </div>
        </div>
      </div>

      <div class="callout boxWarn" style="margin-top:12px;">
        <h4><span class="tag warn">What to watch for</span> Typical pitfalls</h4>
        <ul class="small">
          <li>Confusing <span class="kbd">&phi;<sub>s</sub></span> (a flux scale) with “maximum output”. Saturation reduces gain; it does not cap output at a fixed value.</li>
          <li>Forgetting that the solution is <b>implicit</b>: you often solve <span class="kbd">ln G + X(G−1)=u</span> numerically for <span class="kbd">G</span>.</li>
          <li>Using the exponential law beyond the regime <span class="kbd">&phi;&ll;&phi;<sub>s</sub></span> (overestimates output).</li>
        </ul>
      </div>
    </section>

    <!-- PART 1 -->
    <section id="part1">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>Restate the problem (in plain words)</h3>
      <p>
        A laser amplifier has saturable gain. The photon-flux density <span class="kbd">&phi;(z)</span> grows along distance <span class="kbd">z</span> according to the
        integrated relation
        <span class="kbd">ln(&phi;(z)/&phi;(0)) + (&phi;(z)-&phi;(0))/&phi;<sub>s</sub> = &gamma;<sub>0</sub> z</span>.
        You must plot the normalized flux <span class="kbd">&phi;(z)/&phi;(0)</span> versus the dimensionless distance <span class="kbd">&gamma;<sub>0</sub>z</span> for
        <span class="kbd">&phi;(0)/&phi;<sub>s</sub> = 0.05</span>, and identify the onset of saturation.
      </p>

      <div class="grid2">
        <div class="card">
          <h3>Given</h3>
          <ul>
            <li>Integrated model (Eq. 15.4-7 in the prompt): <span class="kbd">ln(&phi;(z)/&phi;(0)) + (&phi;(z)-&phi;(0))/&phi;<sub>s</sub> = &gamma;<sub>0</sub> z</span>.</li>
            <li>Input-to-saturation ratio: <span class="kbd">X=&phi;(0)/&phi;<sub>s</sub>=0.05</span>.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Unknowns / tasks</h3>
          <ul>
            <li>Compute/plot <span class="kbd">G(u)=&phi;(z)/&phi;(0)</span> as a function of <span class="kbd">u=&gamma;<sub>0</sub>z</span>.</li>
            <li>Identify where saturation begins (define a reasonable criterion and compute the corresponding <span class="kbd">u</span>).</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li><b>Stimulated emission amplification:</b> power/flux grows proportionally to current power/flux times a gain coefficient.</li>
        <li><b>Gain saturation:</b> the gain coefficient decreases as the signal depletes the inversion; the simplest steady-state law yields the given ODE and integrated form.</li>
        <li><b>Why not other models?</b> We are not asked about bandwidth, dispersion, diffraction, or cavity feedback—this is a traveling-wave amplifier with a local saturable gain.</li>
      </ul>

      <div class="callout">
        <h4><span class="tag">Assumptions</span> What we assume explicitly</h4>
        <ul class="small">
          <li>Steady-state (CW or slowly varying), so populations track the signal without dynamic lag.</li>
          <li>Uniform medium: <span class="kbd">&gamma;<sub>0</sub></span> and <span class="kbd">&phi;<sub>s</sub></span> constant in <span class="kbd">z</span>.</li>
          <li>Single traveling wave; no reflections or cavity buildup; no transverse effects.</li>
        </ul>
      </div>

      <h3>Possible approaches (compare 2–3)</h3>
      <ul>
        <li><b>Approach A: Work directly with the integrated equation</b> <span class="kbd">ln G + X(G−1)=u</span> and invert numerically for <span class="kbd">G</span>. <span class="muted">(Best for plotting; minimal algebra.)</span></li>
        <li><b>Approach B: Solve the ODE</b> <span class="kbd">d&phi;/dz = &gamma;<sub>0</sub>&phi;/(1+&phi;/&phi;<sub>s</sub>)</span> by separation of variables, then apply initial condition. <span class="muted">(Shows the physics; leads to the same implicit form.)</span></li>
        <li><b>Approach C: Use Lambert W</b> to write an explicit closed form for <span class="kbd">&phi;(z)</span>. <span class="muted">(Compact, but less intuitive; still fine.)</span></li>
      </ul>

      <p><b>Chosen approach:</b> We’ll derive the integrated form via separation (for learning), then compute plots by numerically inverting
        <span class="kbd">ln G + X(G−1)=u</span> (fast, robust), and use <span class="kbd">&phi;&approx;&phi;<sub>s</sub></span> as the saturation-onset marker.</p>
    </section>

    <!-- PART 2 -->
    <section id="part2">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

      <ol>
        <li><b>Goal:</b> write the local gain model. <b>Tool:</b> saturable gain law <span class="kbd">&gamma;(&phi;)=&gamma;<sub>0</sub>/(1+&phi;/&phi;<sub>s</sub>)</span>.
          <div class="small">Meaning: gain is reduced when the signal flux is comparable to <span class="kbd">&phi;<sub>s</sub></span>.</div>
        </li>
        <li><b>Goal:</b> form the differential equation. <b>Tool:</b> <span class="kbd">d&phi;/dz = &gamma;(&phi;)&phi;</span>.
          <div class="small">Meaning: local fractional growth rate is the local gain coefficient.</div>
        </li>
        <li><b>Goal:</b> separate variables and integrate. <b>Tool:</b> algebraic rearrangement to get <span class="kbd">(1/&phi; + 1/&phi;<sub>s</sub>) d&phi; = &gamma;<sub>0</sub> dz</span>.
          <div class="small">Meaning: saturation introduces an extra linear-in-&phi; term in the integral.</div>
        </li>
        <li><b>Goal:</b> apply the boundary condition at <span class="kbd">z=0</span>. <b>Tool:</b> evaluate the integration constant using <span class="kbd">&phi;(0)</span>.
          <div class="small">Meaning: output depends on the input through the dimensionless ratio <span class="kbd">X=&phi;(0)/&phi;<sub>s</sub></span>.</div>
        </li>
        <li><b>Goal:</b> non-dimensionalize for plotting. <b>Tool:</b> define <span class="kbd">G=&phi;/&phi;(0)</span>, <span class="kbd">u=&gamma;<sub>0</sub>z</span>, <span class="kbd">X=&phi;(0)/&phi;<sub>s</sub></span>.
          <div class="small">Meaning: curves become “universal” functions of <span class="kbd">u</span> for a chosen <span class="kbd">X</span>.</div>
        </li>
        <li><b>Goal:</b> invert <span class="kbd">ln G + X(G−1)=u</span>. <b>Tool:</b> numerical root-finding (Newton) for each <span class="kbd">u</span>.
          <div class="small">Meaning: saturation makes <span class="kbd">G</span> implicit; computation is straightforward.</div>
        </li>
        <li><b>Goal:</b> define saturation onset and compute it. <b>Tool:</b> set <span class="kbd">&phi;=&phi;<sub>s</sub></span> ⇒ <span class="kbd">G=1/X</span>, solve for <span class="kbd">u</span>.
          <div class="small">Meaning: at <span class="kbd">&phi;=&phi;<sub>s</sub></span>, the gain has dropped to half its small-signal value.</div>
        </li>
      </ol>

      <div class="callouts">
        <div class="callout boxWarn">
          <h4><span class="tag warn">Common mistake</span> Mixing up what is “constant”</h4>
          <div class="small">
            <span class="kbd">&gamma;<sub>0</sub></span> is constant (small-signal gain), but the <i>actual</i> gain
            <span class="kbd">&gamma;(&phi;)</span> changes with <span class="kbd">z</span> because <span class="kbd">&phi;</span> changes with <span class="kbd">z</span>.
          </div>
        </div>
        <div class="callout">
          <h4><span class="tag">Tip</span> Quick saturation marker</h4>
          <div class="small">
            If you want a single number for “when saturation starts,” a clean choice is the point where
            <span class="kbd">&phi;=&phi;<sub>s</sub></span>. It corresponds to a 2× reduction in gain coefficient.
          </div>
        </div>
      </div>
    </section>

    <!-- PART 3 -->
    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Physical intuition first</h3>
      <p>
        If the gain were constant, photon flux would grow exponentially: <span class="kbd">&phi;=&phi;(0)e^{&gamma;<sub>0</sub>z}</span>.
        With saturation, the amplifier behaves like this:
      </p>
      <ul>
        <li>Early on (<span class="kbd">&phi;&ll;&phi;<sub>s</sub></span>): growth is almost exponential.</li>
        <li>As <span class="kbd">&phi;</span> approaches <span class="kbd">&phi;<sub>s</sub></span>: gain coefficient drops appreciably, so the curve bends below the exponential.</li>
        <li>Deep saturation (<span class="kbd">&phi;&gg;&phi;<sub>s</sub></span>): growth slows toward nearly linear in <span class="kbd">z</span>.</li>
      </ul>

      <div class="hr"></div>

      <h3>Step 1 — Write the saturable-gain differential equation</h3>
      <p>
        Define the <b>local gain coefficient</b> as
        <span class="kbd">&gamma;(&phi;)=&gamma;<sub>0</sub>/(1+&phi;/&phi;<sub>s</sub>)</span>,
        where:
      </p>
      <ul>
        <li><span class="kbd">&gamma;<sub>0</sub></span> is the small-signal gain (m<sup>−1</sup>),</li>
        <li><span class="kbd">&phi;<sub>s</sub></span> is the saturation photon-flux density (photons·m<sup>−2</sup>·s<sup>−1</sup>).</li>
      </ul>
      <p>
        Traveling-wave amplification means the flux grows as:
      </p>

      <div class="eq" data-copy="eq-ode">
        <pre id="eq-ode">dφ/dz = γ(φ) φ = (γ0 φ)/(1 + φ/φs)</pre>
        <button class="btn" data-copy-btn="eq-ode">Copy</button>
      </div>

      <p class="muted">
        What we did: we used “fractional growth rate = gain coefficient,” and inserted the saturation law for gain.
      </p>

      <h3>Step 2 — Separate variables</h3>
      <p>
        Rearrange to isolate <span class="kbd">φ</span>-terms on the left and <span class="kbd">z</span>-terms on the right:
      </p>

      <div class="eq" data-copy="eq-sep">
        <pre id="eq-sep">(1/φ + 1/φs) dφ = γ0 dz</pre>
        <button class="btn" data-copy-btn="eq-sep">Copy</button>
      </div>

      <p class="muted">
        Why this works: <span class="kbd">(1 + φ/φs)/φ = 1/φ + 1/φs</span>, which makes the left side integrable in elementary functions.
      </p>

      <h3>Step 3 — Integrate and apply the initial condition</h3>
      <p>
        Integrate from <span class="kbd">z=0</span> (input) to a general position <span class="kbd">z</span>:
      </p>

      <div class="eq" data-copy="eq-int">
        <pre id="eq-int">∫_{φ(0)}^{φ(z)} (1/φ + 1/φs) dφ = ∫_{0}^{z} γ0 dz</pre>
        <button class="btn" data-copy-btn="eq-int">Copy</button>
      </div>

      <p>
        Evaluate each side:
      </p>
      <ul>
        <li><span class="kbd">∫(1/φ)dφ = ln φ</span></li>
        <li><span class="kbd">∫(1/φs)dφ = φ/φs</span></li>
        <li><span class="kbd">∫ γ0 dz = γ0 z</span></li>
      </ul>

      <p>So we obtain (matching the given equation):</p>

      <div class="eq" data-copy="eq-1547">
        <pre id="eq-1547">ln(φ(z)/φ(0)) + (φ(z) - φ(0))/φs = γ0 z</pre>
        <button class="btn" data-copy-btn="eq-1547">Copy</button>
      </div>

      <p class="muted">
        Interpretation: relative growth has a logarithmic part (like exponential gain) plus a linear-in-φ part that encodes saturation.
      </p>

      <h3>Step 4 — Put it in dimensionless plotting form</h3>
      <p>
        Define:
      </p>
      <ul>
        <li><span class="kbd">G(z) = φ(z)/φ(0)</span> (dimensionless gain in photon flux),</li>
        <li><span class="kbd">X = φ(0)/φs</span> (how “close to saturation” the input is),</li>
        <li><span class="kbd">u = γ0 z</span> (dimensionless distance).</li>
      </ul>

      <p>
        Substitute <span class="kbd">φ(z)=G φ(0)</span> and divide by <span class="kbd">φ(0)</span> where needed:
        <span class="kbd">(φ(z)-φ(0))/φs = (φ(0)(G-1))/φs = X(G-1)</span>.
      </p>

      <div class="eq" data-copy="eq-master">
        <pre id="eq-master">ln(G) + X (G - 1) = u,   where  G = φ(z)/φ(0),  X = φ(0)/φs,  u = γ0 z.</pre>
        <button class="btn" data-copy-btn="eq-master">Copy</button>
      </div>

      <p class="muted">
        This is the core plotting equation. It is implicit: for each <span class="kbd">u</span> you solve for <span class="kbd">G</span>.
      </p>

      <h3>Step 5 — Plot for X = 0.05 and identify saturation onset</h3>
      <p>
        The problem requests <span class="kbd">X=φ(0)/φs=0.05</span>. To locate “onset of saturation,” a physics-based criterion is:
      </p>
      <ul>
        <li><b>Onset marker:</b> <span class="kbd">φ(z) = φs</span> (signal reaches saturation flux).</li>
        <li>At this point, <span class="kbd">γ(φ) = γ0/(1+1)=γ0/2</span>, i.e. the gain coefficient has dropped by 2×.</li>
      </ul>

      <p>
        If <span class="kbd">φ(z)=φs</span>, then <span class="kbd">G = φ(z)/φ(0) = φs/φ(0) = 1/X</span>.
        Insert <span class="kbd">G=1/X</span> into <span class="kbd">ln(G)+X(G-1)=u</span>:
      </p>

      <div class="eq" data-copy="eq-usat">
        <pre id="eq-usat">u_sat = ln(1/X) + X(1/X - 1) = ln(1/X) + (1 - X)</pre>
        <button class="btn" data-copy-btn="eq-usat">Copy</button>
      </div>

      <p>
        For <span class="kbd">X=0.05</span>:
      </p>
      <ul>
        <li><span class="kbd">1/X = 20</span></li>
        <li><span class="kbd">u_sat = ln(20) + 0.95 ≈ 2.9957 + 0.95 ≈ 3.9457</span></li>
      </ul>

      <div class="eq" data-copy="final-answer">
        <pre id="final-answer">For φ(0)/φs = 0.05, saturation begins around γ0 z ≈ u_sat = ln(20) + 0.95 ≈ 3.95 (when φ(z) ≈ φs and the gain drops to γ0/2).</pre>
        <button class="btn" data-copy-btn="final-answer">Copy</button>
      </div>

      <h3>Sanity checks</h3>
      <div class="grid2">
        <div class="card">
          <h3>Units / dimensions</h3>
          <ul class="small">
            <li><span class="kbd">u=&gamma;<sub>0</sub>z</span> is dimensionless since <span class="kbd">&gamma;<sub>0</sub></span> is m<sup>−1</sup>.</li>
            <li><span class="kbd">G</span> and <span class="kbd">X</span> are dimensionless ratios.</li>
            <li>Each term in <span class="kbd">ln G + X(G−1)=u</span> is dimensionless: consistent.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Limiting cases</h3>
          <ul class="small">
            <li><b>Small-signal:</b> if <span class="kbd">X→0</span>, equation becomes <span class="kbd">ln G = u</span> ⇒ <span class="kbd">G=e^u</span> (pure exponential).</li>
            <li><b>Deep saturation:</b> if <span class="kbd">G</span> is huge so <span class="kbd">XG ≫ 1</span>, then <span class="kbd">X(G−1)≈u</span> ⇒ <span class="kbd">G≈u/X</span> (approximately linear in <span class="kbd">u</span>, hence in <span class="kbd">z</span>).</li>
          </ul>
        </div>
      </div>

      <p class="muted">
        Connection to the diagram and plots: the amplifier diagram defines input <span class="kbd">φ(0)</span> and output <span class="kbd">φ(z)</span>.
        The main plot shows how <span class="kbd">G</span> follows the exponential early, then bends due to saturation; the secondary plot shows the corresponding drop in normalized gain coefficient.
      </p>

      <div class="hr"></div>

      <!-- Visualization block -->
      <h3>Interactive Visualization</h3>

      <div class="controls" aria-label="Interactive controls">
        <div class="control">
          <label for="xSlider">Input ratio X = φ(0)/φs (dimensionless)</label>
          <input id="xSlider" type="range" min="-3" max="0" step="0.01" value="-1.30103" />
          <div class="readout" id="xReadout">X = 0.0500</div>
          <div class="small muted">Slider is logarithmic (10^value), so you can explore very small X easily.</div>
        </div>

        <div class="control">
          <label for="uMax">Plot range u_max = γ0 z_max</label>
          <input id="uMax" type="range" min="2" max="10" step="0.05" value="6.5" />
          <div class="readout" id="uReadout">u_max = 6.50</div>
          <div class="small muted">Increasing u_max extends the amplifier length in dimensionless units.</div>
        </div>

        <div class="control">
          <label for="markerMode">Saturation marker</label>
          <select id="markerMode">
            <option value="phiEqualsPhiS" selected>φ(z) = φs (gain drops to γ0/2)</option>
            <option value="gainDrop10">10% deviation from exponential (G / e^u = 0.9)</option>
            <option value="gEffHalf">γ_eff/γ0 = 0.5 (same as φ=φs)</option>
          </select>
          <div class="readout" id="markerReadout">u_sat ≈ 3.95 (for current X)</div>
          <div class="small muted">All plots update live when you change the marker choice.</div>
        </div>
      </div>

      <div class="twoCanv" style="margin-top:12px;">
        <figure class="card">
          <div class="pill" style="margin-bottom:10px;">Diagram: Saturated laser amplifier (traveling-wave)</div>
          <canvas id="cDiagram" class="canvasShort" aria-label="Amplifier diagram canvas"></canvas>
          <figcaption class="small muted" style="margin-top:8px;">
            A uniform gain medium of length z. Input flux φ(0) enters, grows to φ(z), while gain decreases as φ increases.
          </figcaption>
        </figure>

        <figure class="card">
          <div class="pill" style="margin-bottom:10px;">Main plot: Gain G(u)=φ(z)/φ(0) vs u=γ0 z</div>
          <canvas id="cMain" class="canvasTall" aria-label="Main plot canvas"></canvas>
          <figcaption class="small muted" style="margin-top:8px;">
            Shows saturated curve (implicit solution) and the unsaturated exponential reference.
          </figcaption>
        </figure>
      </div>

      <figure class="card" style="margin-top:12px;">
        <div class="pill" style="margin-bottom:10px;">Secondary plot: Normalized gain coefficient γ_eff/γ0 vs u</div>
        <canvas id="cSecondary" aria-label="Secondary plot canvas"></canvas>
        <figcaption class="small muted" style="margin-top:8px;">
          Here γ_eff(u)/γ0 = 1/(1 + φ/φs) = 1/(1 + X·G(u)). This shows directly where gain starts to collapse.
        </figcaption>
      </figure>

    </section>

    <!-- PART 4 -->
    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpret the final formula</h3>
      <p>
        The master relation
        <span class="kbd">ln G + X(G−1)=u</span>
        contains two “competing” contributions:
      </p>
      <ul>
        <li><b>ln G term:</b> the exponential-growth piece you would have with constant gain.</li>
        <li><b>X(G−1) term:</b> the saturation penalty; it grows with <span class="kbd">G</span> and becomes important when <span class="kbd">XG ≳ 1</span>, i.e. when <span class="kbd">φ(z) ≳ φs</span>.</li>
      </ul>

      <h3>How parameters affect the outcome (connect to the plots)</h3>
      <ul>
        <li>Decreasing <span class="kbd">X=φ(0)/φs</span> (weaker input or larger saturation flux) delays saturation; the curve follows <span class="kbd">e^u</span> longer.</li>
        <li>Increasing <span class="kbd">u</span> (longer medium or larger <span class="kbd">γ0</span>) increases output, but eventually pushes the amplifier into saturation, reducing the incremental gain.</li>
        <li>The secondary plot makes the rule-of-thumb visible: when <span class="kbd">γ_eff/γ0</span> drops significantly below 1, the main curve bends strongly.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p class="muted">
        You can solve explicitly for <span class="kbd">G</span> using the Lambert W function. Starting from
        <span class="kbd">ln G + XG = u + X</span>,
        exponentiate to get <span class="kbd">G e^{XG} = e^{u+X}</span>, then rewrite as
        <span class="kbd">XG e^{XG} = X e^{u+X}</span> giving
        <span class="kbd">G = (1/X) W( X e^{u+X} )</span>.
        For plotting, numerical inversion is often simpler and avoids special functions.
      </p>

      <h3>Concept checks (quick self-test)</h3>
      <ul>
        <li><b>Q:</b> If <span class="kbd">φ(0)</span> is reduced by 10× (so <span class="kbd">X</span> is 10× smaller), what happens to saturation onset in <span class="kbd">u</span>? <b>A:</b> It moves to larger <span class="kbd">u</span> roughly like <span class="kbd">ln(1/X)</span>; saturation is delayed.</li>
        <li><b>Q:</b> Why is <span class="kbd">φ=φs</span> a meaningful marker? <b>A:</b> It is exactly where <span class="kbd">γ(φ)=γ0/2</span>, i.e. gain is halved from small-signal.</li>
        <li><b>Q:</b> In deep saturation, why does growth become nearly linear in <span class="kbd">z</span>? <b>A:</b> Because <span class="kbd">dφ/dz ≈ γ0 φs</span> becomes approximately constant.</li>
        <li><b>Q:</b> Does saturation mean <span class="kbd">φ(z)</span> stops increasing? <b>A:</b> No—growth continues, but at a reduced rate.</li>
      </ul>
    </section>

    <!-- PART 5 -->
    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <h3>What each canvas shows</h3>
      <ul>
        <li><b>Diagram canvas:</b> a block of gain medium of length <span class="kbd">z</span> with input <span class="kbd">φ(0)</span> and output <span class="kbd">φ(z)</span>. It annotates the saturation scale <span class="kbd">φs</span> and the small-signal gain <span class="kbd">γ0</span>.</li>
        <li><b>Main plot:</b> <span class="kbd">G(u)=φ(z)/φ(0)</span> (saturated solution) vs <span class="kbd">u=γ0 z</span>, plus the reference exponential <span class="kbd">e^u</span> (what you’d get with no saturation).</li>
        <li><b>Secondary plot:</b> normalized gain coefficient <span class="kbd">γ_eff/γ0 = 1/(1+φ/φs) = 1/(1+X·G(u))</span> vs <span class="kbd">u</span>.
          This reveals directly when the amplifier “runs out of gain.”</li>
      </ul>

      <h3>Interactive controls</h3>
      <ul>
        <li><b>X slider (φ(0)/φs):</b> increases/decreases how hard the signal saturates the amplifier. Larger <span class="kbd">X</span> saturates sooner and more strongly.</li>
        <li><b>u_max slider:</b> changes the horizontal range of the plots, i.e. how long the amplifier is in dimensionless units.</li>
        <li><b>Marker selection:</b> chooses a saturation-onset criterion and places a marker on the plots.
          For the default criterion (<span class="kbd">φ=φs</span>), the marker is at <span class="kbd">u_sat = ln(1/X) + (1−X)</span>.</li>
      </ul>

      <div class="callout boxWarn">
        <h4><span class="tag warn">Reading tip</span> Compare to the exponential</h4>
        <div class="small">
          The exponential curve <span class="kbd">e^u</span> is a “small-signal fantasy.” The gap between it and the saturated curve quantifies how much gain depletion matters.
          The secondary plot explains that gap: as <span class="kbd">γ_eff/γ0</span> falls, the main curve bends away from <span class="kbd">e^u</span>.
        </div>
      </div>
    </section>
  </article>
</main>

<footer>
  <div>
    Built as a self-contained learning article with interactive plots (vanilla HTML/CSS/JS). Copy buttons produce plain text.
  </div>
</footer>

<script>
/* =========================
   Copy buttons (plain text)
========================= */
(function(){
  function copyTextFromId(id){
    const el = document.getElementById(id);
    const txt = (el && el.textContent) ? el.textContent.trim() : "";
    if(!txt) return;
    navigator.clipboard.writeText(txt).then(()=>{
      // small transient feedback
      const btn = document.querySelector(`[data-copy-btn="${id}"]`);
      if(btn){
        const old = btn.textContent;
        btn.textContent = "Copied!";
        setTimeout(()=>btn.textContent = old, 800);
      }
    }).catch(()=>{ /* ignore */ });
  }
  document.addEventListener("click", (e)=>{
    const btn = e.target.closest("[data-copy-btn]");
    if(!btn) return;
    copyTextFromId(btn.getAttribute("data-copy-btn"));
  });
})();

/* =========================
   Math helpers
========================= */
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function niceStep(range, targetTicks){
  const raw = range / targetTicks;
  const pow = Math.pow(10, Math.floor(Math.log10(raw)));
  const r = raw / pow;
  let step;
  if(r < 1.5) step = 1;
  else if(r < 3.5) step = 2;
  else if(r < 7.5) step = 5;
  else step = 10;
  return step * pow;
}

/* Solve ln(G) + X(G-1) = u for G>0.
   Newton with safe guards. */
function solveG(u, X){
  if(X <= 0){
    return Math.exp(u);
  }
  // good initial guess:
  // small-signal: exp(u); deep-sat approx: 1 + u/X
  let G = Math.exp(Math.min(u, 6)); // avoid enormous initial
  const Gsat = 1 + u / Math.max(X, 1e-9);
  G = Math.min(G, Gsat);
  G = Math.max(G, 1e-12);

  for(let i=0;i<30;i++){
    const f = Math.log(G) + X*(G - 1) - u;
    const fp = 1/G + X;
    const d = f / fp;
    let Gn = G - d;

    // keep positive and avoid wild jumps
    if(!isFinite(Gn) || Gn <= 0){
      Gn = G * 0.5;
    }
    // damping if overshooting
    if(Math.abs(d) > 0.6*G){
      Gn = G - Math.sign(d)*0.6*G;
    }
    // convergence
    if(Math.abs(Gn - G) <= 1e-10 * Math.max(1, G)) { G = Gn; break; }
    G = Gn;
  }
  // final guard
  if(!isFinite(G) || G <= 0) G = Math.exp(u);
  return G;
}

/* Find u where ratio R(u)=G(u)/exp(u) crosses target (e.g., 0.9).
   We'll do bracket + bisection on [0, uMax]. */
function findUForDeviation(X, uMax, targetRatio){
  const f = (u)=>{
    const G = solveG(u, X);
    const ratio = G / Math.exp(u);
    return ratio - targetRatio;
  };
  let a = 0, b = uMax;
  let fa = f(a), fb = f(b);

  // if already below target at start (possible if X big), return 0
  if(fa <= 0) return 0;

  // ensure bracket; if fb>0, no crossing in range
  if(fb > 0) return NaN;

  for(let i=0;i<60;i++){
    const m = 0.5*(a+b);
    const fm = f(m);
    if(!isFinite(fm)) return NaN;
    if(fm > 0){
      a = m; fa = fm;
    }else{
      b = m; fb = fm;
    }
    if(Math.abs(b-a) < 1e-4) break;
  }
  return 0.5*(a+b);
}

/* =========================
   Canvas plotting engine
========================= */
function makeHiDPICanvas(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(2, Math.floor(rect.width * dpr));
  const h = Math.max(2, Math.floor(rect.height * dpr));
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w;
    canvas.height = h;
  }
  const ctx = canvas.getContext("2d");
  ctx.setTransform(1,0,0,1,0,0);
  return {ctx, dpr, w, h};
}

function drawAxes(ctx, plot){
  const {
    xMin, xMax, yMin, yMax,
    px, py, pw, ph,
    xLabel, yLabel, title
  } = plot;

  // background panel
  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,0.02)";
  ctx.fillRect(px, py, pw, ph);

  // title
  ctx.fillStyle = "rgba(232,238,247,0.92)";
  ctx.font = "600 14px ui-sans-serif, system-ui";
  ctx.textAlign = "left";
  ctx.textBaseline = "bottom";
  ctx.fillText(title, px+10, py-8);

  // ticks
  const xRange = xMax - xMin;
  const yRange = yMax - yMin;
  const xStep = niceStep(xRange, 6);
  const yStep = niceStep(yRange, 6);

  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth = 1;

  // gridlines + tick labels
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  ctx.fillStyle = "rgba(169,182,199,0.90)";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";

  function xToPx(x){ return px + (x - xMin) / xRange * pw; }
  function yToPy(y){ return py + ph - (y - yMin) / yRange * ph; }

  // vertical grid
  const xStart = Math.ceil(xMin / xStep) * xStep;
  for(let x = xStart; x <= xMax + 1e-12; x += xStep){
    const X = xToPx(x);
    ctx.beginPath();
    ctx.moveTo(X, py);
    ctx.lineTo(X, py+ph);
    ctx.stroke();
    ctx.fillText((Math.abs(x) < 1e-10 ? "0" : x.toFixed(2).replace(/\.00$/,"")), X, py+ph+6);
  }

  // horizontal grid
  ctx.textAlign = "right";
  ctx.textBaseline = "middle";
  const yStart = Math.ceil(yMin / yStep) * yStep;
  for(let y = yStart; y <= yMax + 1e-12; y += yStep){
    const Y = yToPy(y);
    ctx.beginPath();
    ctx.moveTo(px, Y);
    ctx.lineTo(px+pw, Y);
    ctx.stroke();
    ctx.fillText((Math.abs(y) < 1e-10 ? "0" : y.toFixed(2).replace(/\.00$/,"")), px-8, Y);
  }

  // axes border
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.strokeRect(px, py, pw, ph);

  // labels
  ctx.fillStyle = "rgba(232,238,247,0.88)";
  ctx.font = "600 12px ui-sans-serif, system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText(xLabel, px+pw/2, py+ph+30);

  // y label rotated
  ctx.save();
  ctx.translate(px-44, py+ph/2);
  ctx.rotate(-Math.PI/2);
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  ctx.restore();

  return {xToPx, yToPy};
}

function drawLine(ctx, pts, style){
  ctx.save();
  ctx.strokeStyle = style.stroke || "rgba(125,211,252,0.95)";
  ctx.lineWidth = style.width || 2;
  ctx.setLineDash(style.dash || []);
  ctx.beginPath();
  for(let i=0;i<pts.length;i++){
    const p = pts[i];
    if(i===0) ctx.moveTo(p.x, p.y);
    else ctx.lineTo(p.x, p.y);
  }
  ctx.stroke();
  ctx.restore();
}

function drawLegend(ctx, items, x, y){
  ctx.save();
  const pad = 10;
  const lineH = 18;
  const w = 10 + 210;
  const h = pad*2 + lineH*items.length;
  ctx.fillStyle = "rgba(0,0,0,0.32)";
  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(x, y, w, h, 12);
  ctx.fill();
  ctx.stroke();

  ctx.font = "12px ui-sans-serif, system-ui";
  ctx.textBaseline = "middle";
  for(let i=0;i<items.length;i++){
    const yy = y + pad + lineH*i + lineH/2;
    // sample line
    ctx.save();
    ctx.strokeStyle = items[i].stroke;
    ctx.lineWidth = items[i].width || 2;
    ctx.setLineDash(items[i].dash || []);
    ctx.beginPath();
    ctx.moveTo(x+12, yy);
    ctx.lineTo(x+42, yy);
    ctx.stroke();
    ctx.restore();
    ctx.fillStyle = "rgba(232,238,247,0.90)";
    ctx.fillText(items[i].label, x+52, yy);
  }
  ctx.restore();
}

/* =========================
   Draw diagram
========================= */
function drawDiagram(canvas, X){
  const {ctx, w, h} = makeHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  const pad = 18;
  const midY = Math.round(h*0.52);

  // Title
  ctx.fillStyle = "rgba(232,238,247,0.92)";
  ctx.font = "700 14px ui-sans-serif, system-ui";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillText("Saturated amplifier model (1D traveling wave)", pad, pad);

  // Amplifier block
  const bx = pad + 70;
  const by = midY - 55;
  const bw = w - (pad*2 + 140);
  const bh = 110;

  // glow
  ctx.save();
  ctx.fillStyle = "rgba(125,211,252,0.08)";
  ctx.beginPath();
  ctx.roundRect(bx-6, by-6, bw+12, bh+12, 18);
  ctx.fill();
  ctx.restore();

  ctx.fillStyle = "rgba(255,255,255,0.04)";
  ctx.strokeStyle = "rgba(255,255,255,0.16)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.roundRect(bx, by, bw, bh, 18);
  ctx.fill();
  ctx.stroke();

  // Arrows
  function arrow(x1,y1,x2,y2){
    const ang = Math.atan2(y2-y1, x2-x1);
    const head = 10;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2-head*Math.cos(ang-Math.PI/7), y2-head*Math.sin(ang-Math.PI/7));
    ctx.lineTo(x2-head*Math.cos(ang+Math.PI/7), y2-head*Math.sin(ang+Math.PI/7));
    ctx.closePath();
    ctx.fill();
  }

  ctx.strokeStyle = "rgba(232,238,247,0.7)";
  ctx.fillStyle = "rgba(232,238,247,0.7)";
  ctx.lineWidth = 2;

  const inX = pad + 16;
  const outX = w - pad - 16;
  arrow(inX, midY, bx, midY);
  arrow(bx+bw, midY, outX, midY);

  // Labels
  ctx.fillStyle = "rgba(232,238,247,0.92)";
  ctx.font = "600 12px ui-sans-serif, system-ui";
  ctx.textAlign = "left";
  ctx.textBaseline = "bottom";
  ctx.fillText("Input: φ(0)", pad+8, midY-10);

  ctx.textAlign = "right";
  ctx.fillText("Output: φ(z)", w-pad-8, midY-10);

  // inside annotations
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillStyle = "rgba(169,182,199,0.92)";
  ctx.font = "600 12px ui-sans-serif, system-ui";
  ctx.fillText("Uniform gain medium", bx+bw/2, by+28);

  ctx.fillStyle = "rgba(232,238,247,0.90)";
  ctx.font = "600 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  ctx.fillText("γ(φ) = γ0 / (1 + φ/φs)", bx+bw/2, by+58);

  // saturation scale annotation
  ctx.fillStyle = "rgba(251,191,36,0.95)";
  ctx.font = "600 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  ctx.fillText("X = φ(0)/φs = " + X.toFixed(4), bx+bw/2, by+86);

  // length marker
  ctx.strokeStyle = "rgba(255,255,255,0.22)";
  ctx.fillStyle = "rgba(255,255,255,0.22)";
  ctx.lineWidth = 2;
  const yLen = by+bh+22;
  arrow(bx, yLen, bx+bw, yLen);
  ctx.fillStyle = "rgba(169,182,199,0.92)";
  ctx.font = "600 12px ui-sans-serif, system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillText("Propagation distance z  (dimensionless u = γ0 z)", bx+bw/2, yLen+8);
}

/* =========================
   Draw plots
========================= */
function buildData(X, uMax, n){
  const data = [];
  for(let i=0;i<=n;i++){
    const u = uMax * i / n;
    const G = solveG(u, X);
    const exp = Math.exp(u);
    const gEff = 1 / (1 + X*G); // γ_eff/γ0
    data.push({u, G, exp, gEff});
  }
  return data;
}

function computeMarker(X, uMax, mode){
  if(mode === "phiEqualsPhiS" || mode === "gEffHalf"){
    // φ=φs => G = 1/X, u = ln(1/X)+(1-X)
    const u = Math.log(1/X) + (1 - X);
    return (u <= uMax) ? u : NaN;
  }
  if(mode === "gainDrop10"){
    // Find u where G/exp(u)=0.9
    return findUForDeviation(X, uMax, 0.9);
  }
  return NaN;
}

function drawMainPlot(canvas, X, uMax, mode){
  const {ctx, w, h} = makeHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  const margin = {l:72, r:18, t:42, b:54};
  const px = margin.l, py = margin.t, pw = w - margin.l - margin.r, ph = h - margin.t - margin.b;

  const data = buildData(X, uMax, 260);

  // y range: include saturated curve and exponential, but keep reasonable
  let yMax = 1;
  for(const p of data){
    yMax = Math.max(yMax, p.G, p.exp);
  }
  // compress extremely large by limiting view; keep plot readable:
  const yTop = Math.min(yMax, 250); // display limit
  const plot = {
    xMin:0, xMax:uMax,
    yMin:0, yMax:yTop,
    px, py, pw, ph,
    xLabel:"u = γ0 z (dimensionless)",
    yLabel:"G(u) = φ(z)/φ(0)",
    title:"Gain in a saturated amplifier"
  };
  const {xToPx, yToPy} = drawAxes(ctx, plot);

  // curves
  const ptsSat = [];
  const ptsExp = [];
  for(const p of data){
    ptsSat.push({x:xToPx(p.u), y:yToPy(Math.min(p.G, yTop))});
    ptsExp.push({x:xToPx(p.u), y:yToPy(Math.min(p.exp, yTop))});
  }

  drawLine(ctx, ptsSat, {stroke:"rgba(125,211,252,0.95)", width:2.6, dash:[]});
  drawLine(ctx, ptsExp, {stroke:"rgba(167,243,208,0.90)", width:2.2, dash:[8,6]});

  // marker
  const uMarker = computeMarker(X, uMax, mode);
  if(isFinite(uMarker)){
    const Gm = solveG(uMarker, X);
    const xm = xToPx(uMarker);
    const ym = yToPy(Math.min(Gm, yTop));

    ctx.save();
    ctx.fillStyle = "rgba(251,191,36,0.95)";
    ctx.strokeStyle = "rgba(251,191,36,0.65)";
    ctx.lineWidth = 2;
    // vertical line
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(xm, py);
    ctx.lineTo(xm, py+ph);
    ctx.stroke();
    ctx.setLineDash([]);

    // point
    ctx.beginPath();
    ctx.arc(xm, ym, 5.5, 0, Math.PI*2);
    ctx.fill();

    // label
    ctx.fillStyle = "rgba(232,238,247,0.92)";
    ctx.font = "600 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.textAlign = "left";
    ctx.textBaseline = "bottom";
    const label = "marker: u ≈ " + uMarker.toFixed(2);
    ctx.fillText(label, clamp(xm+10, px+8, px+pw-130), clamp(ym-10, py+18, py+ph-6));
    ctx.restore();
  }

  // legend
  drawLegend(ctx, [
    {label:"Saturated solution G(u)", stroke:"rgba(125,211,252,0.95)", width:2.6, dash:[]},
    {label:"Small-signal reference e^u", stroke:"rgba(167,243,208,0.90)", width:2.2, dash:[8,6]}
  ], px+10, py+10);

  // note about clipping if needed
  if(yMax > yTop){
    ctx.save();
    ctx.fillStyle = "rgba(169,182,199,0.85)";
    ctx.font = "600 12px ui-sans-serif, system-ui";
    ctx.textAlign = "right";
    ctx.textBaseline = "top";
    ctx.fillText("Note: y-axis clipped for readability (true max ≈ " + yMax.toFixed(1) + ")", px+pw, py-26);
    ctx.restore();
  }
}

function drawSecondaryPlot(canvas, X, uMax, mode){
  const {ctx, w, h} = makeHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  const margin = {l:72, r:18, t:42, b:54};
  const px = margin.l, py = margin.t, pw = w - margin.l - margin.r, ph = h - margin.t - margin.b;

  const data = buildData(X, uMax, 260);

  const plot = {
    xMin:0, xMax:uMax,
    yMin:0, yMax:1.05,
    px, py, pw, ph,
    xLabel:"u = γ0 z (dimensionless)",
    yLabel:"γ_eff(u) / γ0",
    title:"Local gain reduction due to saturation"
  };
  const {xToPx, yToPy} = drawAxes(ctx, plot);

  const pts = data.map(p=>({x:xToPx(p.u), y:yToPy(p.gEff)}));
  drawLine(ctx, pts, {stroke:"rgba(251,191,36,0.95)", width:2.6, dash:[]});

  // reference lines: 1 and 0.5
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.20)";
  ctx.lineWidth = 1.5;
  ctx.setLineDash([6,6]);
  const y1 = yToPy(1);
  const y05 = yToPy(0.5);
  ctx.beginPath(); ctx.moveTo(px, y1); ctx.lineTo(px+pw, y1); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(px, y05); ctx.lineTo(px+pw, y05); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = "rgba(169,182,199,0.9)";
  ctx.font = "600 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  ctx.textAlign = "left"; ctx.textBaseline = "bottom";
  ctx.fillText("1.0", px+6, y1-6);
  ctx.fillText("0.5", px+6, y05-6);
  ctx.restore();

  // marker vertical
  const uMarker = computeMarker(X, uMax, mode);
  if(isFinite(uMarker)){
    const xm = xToPx(uMarker);
    const Gm = solveG(uMarker, X);
    const gEm = 1/(1+X*Gm);
    const ym = yToPy(gEm);

    ctx.save();
    ctx.strokeStyle = "rgba(125,211,252,0.65)";
    ctx.fillStyle = "rgba(125,211,252,0.95)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);
    ctx.beginPath(); ctx.moveTo(xm, py); ctx.lineTo(xm, py+ph); ctx.stroke();
    ctx.setLineDash([]);
    ctx.beginPath(); ctx.arc(xm, ym, 5.5, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = "rgba(232,238,247,0.92)";
    ctx.font = "600 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.textAlign = "left"; ctx.textBaseline = "bottom";
    ctx.fillText("γ_eff/γ0 ≈ " + gEm.toFixed(2), clamp(xm+10, px+8, px+pw-150), clamp(ym-10, py+18, py+ph-6));
    ctx.restore();
  }

  drawLegend(ctx, [
    {label:"γ_eff/γ0 = 1/(1 + X·G(u))", stroke:"rgba(251,191,36,0.95)", width:2.6, dash:[]},
    {label:"Reference: 0.5 and 1.0", stroke:"rgba(255,255,255,0.22)", width:1.5, dash:[6,6]}
  ], px+10, py+10);
}

/* =========================
   App state + updates
========================= */
const xSlider = document.getElementById("xSlider");
const uMaxSlider = document.getElementById("uMax");
const markerMode = document.getElementById("markerMode");

const xReadout = document.getElementById("xReadout");
const uReadout = document.getElementById("uReadout");
const markerReadout = document.getElementById("markerReadout");

const cDiagram = document.getElementById("cDiagram");
const cMain = document.getElementById("cMain");
const cSecondary = document.getElementById("cSecondary");

function sliderToX(v){
  // log10 slider: X = 10^v
  return Math.pow(10, parseFloat(v));
}

function update(){
  const X = sliderToX(xSlider.value);
  const uMax = parseFloat(uMaxSlider.value);
  const mode = markerMode.value;

  xReadout.textContent = "X = " + X.toFixed(4);
  uReadout.textContent = "u_max = " + uMax.toFixed(2);

  const uMarker = computeMarker(X, uMax, mode);
  let label;
  if(mode === "phiEqualsPhiS" || mode === "gEffHalf"){
    label = isFinite(uMarker)
      ? ("u_sat ≈ " + uMarker.toFixed(2) + " (φ ≈ φs)")
      : ("u_sat is outside current range");
  }else{
    label = isFinite(uMarker)
      ? ("u_dev ≈ " + uMarker.toFixed(2) + " (G/e^u = 0.9)")
      : ("No 10% deviation found in range");
  }
  markerReadout.textContent = label;

  drawDiagram(cDiagram, X);
  drawMainPlot(cMain, X, uMax, mode);
  drawSecondaryPlot(cSecondary, X, uMax, mode);

  // For the specific problem's requested case, if X is near 0.05, we can show the exact expected number in readout.
}

[xSlider, uMaxSlider, markerMode].forEach(el=>{
  el.addEventListener("input", update);
  el.addEventListener("change", update);
});

window.addEventListener("resize", ()=>{ update(); });

// initialize to the requested case X=0.05
(function init(){
  // slider is log10; log10(0.05) = -1.30103...
  xSlider.value = (-1.30103).toString();
  uMaxSlider.value = "6.5";
  markerMode.value = "phiEqualsPhiS";
  update();
})();

/* =========================
   RoundRect polyfill for older browsers
========================= */
if(!CanvasRenderingContext2D.prototype.roundRect){
  CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    this.beginPath();
    this.moveTo(x+r, y);
    this.arcTo(x+w, y, x+w, y+h, r);
    this.arcTo(x+w, y+h, x, y+h, r);
    this.arcTo(x, y+h, x, y, r);
    this.arcTo(x, y, x+w, y, r);
    this.closePath();
    return this;
  };
}
</script>
</body>
</html>
