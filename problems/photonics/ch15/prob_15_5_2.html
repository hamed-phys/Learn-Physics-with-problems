<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Signal-to-ASE Ratio in an Unsaturated Optical Amplifier (γ0 d Dependence)</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#101827;
      --card:#0f172a;
      --text:#e6edf7;
      --muted:#a9b4c7;
      --line:#22304a;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
      --radius2: 22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 10% 10%, rgba(125,211,252,.10), transparent 60%),
        radial-gradient(900px 500px at 90% 20%, rgba(167,139,250,.10), transparent 60%),
        radial-gradient(800px 500px at 40% 110%, rgba(52,211,153,.08), transparent 60%),
        var(--bg);
      line-height:1.55;
    }
    header{
      padding:42px 22px 26px;
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .wrap{
      max-width:1180px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:18px;
      padding:18px 18px 56px;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr}
    }
    .hero{
      max-width:1180px;
      margin:0 auto;
      padding:0 18px;
    }
    h1{
      margin:0 0 10px;
      font-size:clamp(26px, 3vw, 40px);
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      font-size:clamp(14px, 1.4vw, 16px);
      max-width:78ch;
    }
    .pillrow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:14px;
    }
    .pill{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      border-radius:999px;
      padding:6px 10px;
      color:var(--muted);
      font-size:12.5px;
    }

    aside{
      position:relative;
    }
    .toc{
      position:sticky;
      top:14px;
      background:linear-gradient(180deg, rgba(16,24,39,.90), rgba(16,24,39,.72));
      border:1px solid rgba(255,255,255,.08);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:14px 14px 10px;
      backdrop-filter: blur(10px);
    }
    .toc h3{
      margin:0 0 8px;
      font-size:14px;
      color:var(--text);
      letter-spacing:.2px;
    }
    .toc a{
      display:block;
      padding:7px 10px;
      margin:4px 0;
      text-decoration:none;
      color:var(--muted);
      border-radius:12px;
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:13px;
    }
    .toc a:hover{
      background:rgba(125,211,252,.08);
      border-color:rgba(125,211,252,.18);
      color:var(--text);
      transform: translateX(2px);
    }

    main{
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    section{
      background:linear-gradient(180deg, rgba(16,24,39,.78), rgba(15,23,42,.78));
      border:1px solid rgba(255,255,255,.08);
      border-radius:var(--radius2);
      box-shadow:var(--shadow);
      padding:18px 18px 16px;
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    section h2{
      margin:0 0 12px;
      font-size:20px;
      letter-spacing:.2px;
    }
    section h3{
      margin:16px 0 8px;
      font-size:16px;
      color:#dbe7ff;
    }
    p{margin:10px 0}
    ul{margin:10px 0 10px 20px}
    li{margin:6px 0}
    .grid2{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
    }
    @media (max-width: 860px){
      .grid2{grid-template-columns:1fr}
    }
    .callout{
      border:1px solid rgba(255,255,255,.10);
      border-left:4px solid var(--accent);
      background:rgba(125,211,252,.06);
      padding:12px 12px;
      border-radius:14px;
    }
    .callout.warn{
      border-left-color:var(--warn);
      background:rgba(251,191,36,.06);
    }
    .callout.good{
      border-left-color:var(--good);
      background:rgba(52,211,153,.06);
    }
    .callout.bad{
      border-left-color:var(--bad);
      background:rgba(251,113,133,.06);
    }
    .eqbox{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      border-radius:14px;
      padding:12px 12px 10px;
      margin:10px 0;
    }
    .eqtop{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-bottom:8px;
    }
    .eqtitle{
      font-size:12.5px;
      color:var(--muted);
      letter-spacing:.15px;
    }
    button.copy{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
      color:var(--text);
      padding:6px 10px;
      border-radius:12px;
      font-size:12px;
      cursor:pointer;
      transition: transform .10s ease, background .10s ease;
      white-space:nowrap;
    }
    button.copy:hover{background:rgba(255,255,255,.07); transform: translateY(-1px)}
    button.copy:active{transform: translateY(0px)}
    pre, code{
      font-family:var(--mono);
      white-space:pre-wrap;
      word-break:break-word;
      margin:0;
      font-size:13.2px;
      color:#eaf2ff;
    }

    .vizWrap{
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap:12px;
      align-items:start;
    }
    @media (max-width: 980px){
      .vizWrap{grid-template-columns:1fr}
    }
    .controls{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      border-radius:16px;
      padding:12px;
    }
    .controls h3{
      margin:0 0 8px;
      font-size:15px;
      color:#dbe7ff;
    }
    .control{
      padding:10px 10px 8px;
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      background:rgba(0,0,0,.10);
      margin:10px 0;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:12.5px;
      color:var(--muted);
      margin-bottom:6px;
    }
    input[type="range"]{width:100%}
    .row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      margin-top:6px;
    }
    .chip{
      font-family:var(--mono);
      font-size:12px;
      padding:6px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.03);
      color:#dbe7ff;
    }
    .toggle{
      display:flex;
      align-items:center;
      gap:8px;
      color:var(--muted);
      font-size:12.5px;
      user-select:none;
      margin-top:8px;
    }
    .toggle input{transform: translateY(1px)}
    figure{
      margin:0;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.14);
      border-radius:16px;
      padding:10px;
    }
    figcaption{
      color:var(--muted);
      font-size:12.5px;
      margin-top:8px;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius:12px;
      background:rgba(6,10,18,.55);
      border:1px solid rgba(255,255,255,.06);
    }
    .mini{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
    }
    @media (max-width: 760px){
      .mini{grid-template-columns:1fr}
    }
    footer{
      max-width:1180px;
      margin:0 auto;
      padding:18px 18px 40px;
      color:var(--muted);
      font-size:12.5px;
    }
    .printNote{
      display:none;
    }
    @media print{
      :root{--bg:#ffffff; --text:#111827; --muted:#374151; --panel:#ffffff; --card:#ffffff}
      body{background:#ffffff}
      header, footer{border:none}
      .toc{display:none}
      section, figure, .controls{box-shadow:none; backdrop-filter:none}
      .printNote{display:block; margin-top:10px; color:#111827}
      button.copy{display:none}
    }
  </style>
</head>
<body>
<header>
  <div class="hero">
    <h1>Ratio of Signal Power to ASE Power in an Unsaturated Optical Amplifier</h1>
    <div class="subtitle">
      We derive how the <b>output signal photon-flux density</b> compares to <b>amplified spontaneous emission (ASE)</b>
      for a constant-gain (unsaturated) amplifier, and we sketch the dependence on the gain–length product <b>G = γ<sub>0</sub>d</b>.
    </div>
    <div class="pillrow">
      <div class="pill">Regime: unsaturated (small-signal) gain</div>
      <div class="pill">Key idea: integrate spontaneous emission along z and amplify it</div>
      <div class="pill">Main result: ratio depends on G through 1/(1 − e<sup>−G</sup>)</div>
    </div>
  </div>
</header>

<div class="wrap">
  <main>

    <section id="quick-summary">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>What this is about:</b> In an unsaturated optical amplifier, the signal grows exponentially, but <b>ASE also grows</b> because spontaneous photons are created all along the device and then amplified.</li>
        <li><b>Key physics idea:</b> Treat ASE as a <b>distributed source</b> with rate ξ<sub>sp</sub> per unit length, and propagate each locally-generated photon to the output with the same gain as the signal.</li>
        <li><b>Governing evolution:</b> dφ/dz = γ<sub>0</sub>φ for a flux density φ in a constant-gain medium (valid when gain is not depleted).</li>
        <li><b>Signal at output:</b> φ<sub>s</sub>(d) = φ<sub>s</sub>(0) e<sup>γ0 d</sup>.</li>
        <li><b>ASE at output (forward):</b> φ<sub>ASE</sub>(d) = ∫₀ᵈ ξ<sub>sp</sub> e<sup>γ0(d−z)</sup> dz = (ξ<sub>sp</sub>/γ<sub>0</sub>) (e<sup>γ0 d</sup> − 1).</li>
        <li><b>Requested ratio vs gain–length product G = γ<sub>0</sub>d:</b>
          <span class="chip">φ<sub>s</sub>(d)/φ<sub>ASE</sub>(d) = (γ<sub>0</sub> φ<sub>s</sub>(0)/ξ<sub>sp</sub>) · 1/(1 − e<sup>−G</sup>)</span>
          (symbolic; sketch: decreases from ~1/G at small G to a constant at large G).
        </li>
      </ul>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="grid2">
        <div>
          <h3>Core definitions (symbols + units)</h3>
          <ul>
            <li><b>z</b> (m): longitudinal coordinate along the amplifier (z=0 input, z=d output).</li>
            <li><b>d</b> (m): amplifier length.</li>
            <li><b>γ<sub>0</sub></b> (m<sup>−1</sup>): <b>gain coefficient</b> in the unsaturated (small-signal) regime. Often the intensity/flux obeys exponential growth with exponent γ<sub>0</sub>z.</li>
            <li><b>ν<sub>0</sub></b> (Hz): optical frequency of the signal (used only to label the mode; the derivation is flux-based).</li>
            <li><b>φ<sub>s</sub>(z)</b> (photons·s<sup>−1</sup>, or photon-flux density per a chosen mode/area): signal photon flux at position z.</li>
            <li><b>ξ<sub>sp</sub></b> (photons·s<sup>−1</sup>·m<sup>−1</sup>): spontaneous emission <b>photon creation rate per unit length</b> into the relevant forward-propagating mode/band.</li>
            <li><b>φ<sub>ASE</sub>(d)</b> (photons·s<sup>−1</sup>): ASE photon flux at the output (forward ASE).</li>
            <li><b>G = γ<sub>0</sub>d</b> (dimensionless): gain–length product (the natural variable for “sketch vs γ<sub>0</sub>d”).</li>
          </ul>
        </div>

        <div>
          <h3>Physical meaning</h3>
          <p>
            The amplifier does two things simultaneously:
          </p>
          <ul>
            <li>It <b>amplifies</b> any forward-propagating photons (signal and also any noise photons already present).</li>
            <li>It <b>creates</b> new photons by spontaneous emission throughout the medium; those photons then get amplified as they propagate to the output.</li>
          </ul>
          <div class="callout">
            <b>Big intuition:</b> Signal is “born” at z=0 and amplified over the full length d, whereas ASE is “born” everywhere; photons born near the output experience little gain, photons born near the input experience a lot.
          </div>
        </div>
      </div>

      <h3>Key model and validity conditions</h3>
      <div class="callout good">
        <b>Unsaturated (small-signal) amplifier model:</b> Gain coefficient γ<sub>0</sub> is constant along z and does not depend on the optical power. This requires the signal (and ASE) to be weak enough that population inversion is not significantly depleted.
      </div>
      <ul>
        <li><b>1D forward model:</b> We track forward-propagating photon flux only (no backward ASE, no cavity feedback).</li>
        <li><b>Single effective mode/band:</b> ξ<sub>sp</sub> already represents the spontaneous emission rate into the relevant forward mode and bandwidth (so we don’t need extra factors here).</li>
      </ul>

      <h3>Common approximations and why we use them</h3>
      <ul>
        <li><b>Constant γ<sub>0</sub>:</b> makes the propagation exponential and isolates the dependence on G = γ<sub>0</sub>d.</li>
        <li><b>Distributed source for ASE:</b> simplest way to compute ASE without detailed quantum noise formalism; correct scaling is captured by integrating the amplified contributions.</li>
      </ul>

      <h3>Mini intuition examples</h3>
      <ul>
        <li><b>Short amplifier (G ≪ 1):</b> signal barely amplifies; ASE is approximately ξ<sub>sp</sub>d (little gain). The ratio ends up behaving like ~1/G (very sensitive to small G).</li>
        <li><b>Long/high-gain amplifier (G ≫ 1):</b> both signal and ASE scale like e<sup>G</sup>, so their ratio approaches a constant set by how “strong” the injected signal is compared to the spontaneous source strength.</li>
      </ul>

      <h3>What to watch for (pitfalls)</h3>
      <div class="callout warn">
        <ul>
          <li><b>Mixing units:</b> φ is a photon flux (or flux density), ξ<sub>sp</sub> is per unit length. Their ratio must combine with γ<sub>0</sub> to become dimensionless where appropriate.</li>
          <li><b>Forgetting distributed origin of ASE:</b> ASE is not just “amplified once”; it’s generated everywhere and each piece is amplified by a different factor.</li>
          <li><b>Double-counting bandwidth/polarizations:</b> If ξ<sub>sp</sub> already includes these, do not add extra factors. (Problem statement implies ξ<sub>sp</sub> is the effective rate per unit length.)</li>
        </ul>
      </div>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Restate the problem (in plain words)</h3>
      <p>
        A laser amplifier of length <b>d</b> has a constant (unsaturated) gain coefficient <b>γ<sub>0</sub></b>.
        An input signal photon flux density <b>φ<sub>s</sub>(0)</b> at frequency ν<sub>0</sub> enters at z=0.
        Along the amplifier, amplified spontaneous emission is introduced at a constant rate <b>ξ<sub>sp</sub></b> per unit length.
        The output signal is φ<sub>s</sub>(d), and the forward ASE at the output is φ<sub>ASE</sub>(d).
        <b>Sketch how the ratio φ<sub>s</sub>(d)/φ<sub>ASE</sub>(d) depends on the product γ<sub>0</sub>d.</b>
      </p>

      <div class="grid2">
        <div>
          <h3>Given</h3>
          <ul>
            <li>d (length)</li>
            <li>γ<sub>0</sub> (constant gain coefficient)</li>
            <li>φ<sub>s</sub>(0) (input signal photon flux density)</li>
            <li>ξ<sub>sp</sub> (spontaneous emission rate per unit length into the forward mode/band)</li>
          </ul>
        </div>
        <div>
          <h3>Unknowns / what to find</h3>
          <ul>
            <li>φ<sub>s</sub>(d)</li>
            <li>φ<sub>ASE</sub>(d)</li>
            <li>Ratio R(G) = φ<sub>s</sub>(d)/φ<sub>ASE</sub>(d) as a function of G = γ<sub>0</sub>d</li>
            <li>Qualitative sketch of R vs G</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li><b>Exponential gain law (linear ODE):</b> In an unsaturated amplifier, the photon flux grows proportionally to itself:
          <span class="chip">dφ/dz = γ<sub>0</sub>φ</span>.
          This applies because the gain medium’s inversion is assumed constant (no depletion).</li>
        <li><b>Superposition for a linear system:</b> Because the equation is linear, we can add a <b>source term</b> for spontaneous emission and integrate its contribution along z.</li>
      </ul>
      <p>
        What we <b>don’t</b> use: saturation dynamics, spatially varying gain, reflections/cavity effects, or detailed quantum noise spectra—none are required by the statement.
      </p>

      <h3>Assumptions (explicit)</h3>
      <div class="callout">
        <ul>
          <li>Gain is constant: γ(z)=γ<sub>0</sub> (unsaturated regime).</li>
          <li>ASE is treated as a forward-propagating flux generated uniformly: ξ<sub>sp</sub> is constant in z.</li>
          <li>Single effective mode/band (ξ<sub>sp</sub> already accounts for bandwidth/polarization selection relevant to φ).</li>
          <li>Steady-state, no time dependence; no pump depletion modeled.</li>
        </ul>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ul>
        <li><b>Approach A (best):</b> Solve a linear ODE with a distributed source term for ASE and a homogeneous solution for the signal.
          <b>Pros:</b> clean, directly yields dependence on G. <b>Cons:</b> requires careful interpretation of ξ<sub>sp</sub>.</li>
        <li><b>Approach B:</b> Build ASE as a sum of small slices Δz each contributing ξ<sub>sp</sub>Δz amplified by e<sup>γ0(d−z)</sup>, then take Δz→0.
          <b>Pros:</b> very intuitive. <b>Cons:</b> essentially the same as A but less compact.</li>
        <li><b>Approach C:</b> Full quantum-noise amplifier theory (noise figure, n<sub>sp</sub>, etc.).
          <b>Pros:</b> most general. <b>Cons:</b> overkill for this prompt.</li>
      </ul>
      <p><b>Chosen:</b> Approach A/B (linear ODE + distributed-source integral) because it isolates the requested dependence on G = γ<sub>0</sub>d with minimal assumptions.</p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>
      <ol>
        <li>
          <b>Write the signal propagation law</b><br/>
          <span class="chip">dφ<sub>s</sub>/dz = γ<sub>0</sub> φ<sub>s</sub></span><br/>
          <span style="color:var(--muted)">Meaning: each additional length amplifies the existing signal proportionally.</span>
        </li>
        <li>
          <b>Solve for φ<sub>s</sub>(z) with input boundary condition</b><br/>
          Use exponential solution with φ<sub>s</sub>(0) given.
        </li>
        <li>
          <b>Model ASE as a distributed source</b><br/>
          Each slice dz creates ξ<sub>sp</sub>dz photons/s that then get amplified from z to d.
        </li>
        <li>
          <b>Integrate contributions to the output ASE</b><br/>
          Compute φ<sub>ASE</sub>(d) = ∫₀ᵈ ξ<sub>sp</sub> e<sup>γ0(d−z)</sup> dz.
        </li>
        <li>
          <b>Form the ratio and rewrite in terms of G = γ<sub>0</sub>d</b><br/>
          This gives the requested dependence on the product γ<sub>0</sub>d.
        </li>
        <li>
          <b>Extract limiting behaviors</b><br/>
          Expand for small G and simplify for large G to understand the “sketch shape”.
        </li>
      </ol>

      <div class="callout warn">
        <b>Common mistakes & quick tips</b>
        <ul>
          <li>Don’t forget the amplification factor for ASE created at position z: it is e<sup>γ0(d−z)</sup>, not e<sup>γ0 z</sup>.</li>
          <li>Near G → 0 the ratio behaves like ~1/G; don’t be surprised by the divergence (it reflects vanishing ASE gain-length normalization in this idealized model).</li>
          <li>If you plot in linear scale, small-G behavior can dominate; consider log-scale as a visualization option.</li>
        </ul>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Physical intuition (before equations)</h3>
      <p>
        If there were no spontaneous emission, the signal would simply grow as it propagates.
        But spontaneous photons are continuously injected into the same gain medium. Photons created near the input are amplified for almost the full length; photons created near the output are amplified very little.
        Therefore, <b>ASE at the output is an integral of exponentials</b>.
        We expect that for large gain-length, both signal and ASE become dominated by the same exponential gain and thus their ratio becomes roughly constant (set by the injected signal strength relative to spontaneous generation).
      </p>

      <h3>Step 1: Signal amplification</h3>
      <div class="eqbox" id="eq-signal">
        <div class="eqtop">
          <div class="eqtitle">Key equation (unsaturated exponential gain)</div>
          <button class="copy" data-copy="dφ_s/dz = γ0 φ_s&#10;⇒ φ_s(z) = φ_s(0) e^(γ0 z)&#10;⇒ φ_s(d) = φ_s(0) e^(γ0 d)">Copy</button>
        </div>
        <pre><code>dφ_s/dz = γ0 φ_s

Solve:
(1/φ_s) dφ_s = γ0 dz
⇒ ln φ_s = γ0 z + const
Apply boundary condition φ_s(0) given:
⇒ φ_s(z) = φ_s(0) e^(γ0 z)

Therefore at the output z=d:
⇒ φ_s(d) = φ_s(0) e^(γ0 d)</code></pre>
      </div>
      <p style="color:var(--muted)">
        What we did: solved a first-order linear ODE. Why: constant gain means the fractional increase per length is constant.
      </p>

      <h3>Step 2: ASE as a distributed, amplified source</h3>
      <p>
        Consider a small slice of amplifier between z and z+dz. It injects spontaneous photons into the forward direction at a rate
        <span class="chip">dφ<sub>sp</sub>(z) = ξ<sub>sp</sub> dz</span>.
        Those photons then propagate from z to d, experiencing gain over distance (d−z), so at the output they contribute
        <span class="chip">dφ<sub>ASE,out</sub> = ξ<sub>sp</sub> dz · e<sup>γ0(d−z)</sup></span>.
      </p>

      <div class="eqbox" id="eq-ase">
        <div class="eqtop">
          <div class="eqtitle">ASE output as an integral of amplified contributions</div>
          <button class="copy" data-copy="φ_ASE(d) = ∫_0^d ξ_sp e^(γ0(d−z)) dz = (ξ_sp/γ0)(e^(γ0 d) − 1)">Copy</button>
        </div>
        <pre><code>φ_ASE(d) = ∫_0^d [ ξ_sp e^(γ0(d − z)) ] dz

Pull out constants and integrate:
φ_ASE(d) = ξ_sp e^(γ0 d) ∫_0^d e^(−γ0 z) dz
         = ξ_sp e^(γ0 d) [ (1 − e^(−γ0 d)) / γ0 ]
         = (ξ_sp/γ0) (e^(γ0 d) − 1)</code></pre>
      </div>
      <p style="color:var(--muted)">
        What we did: added up (integrated) infinitesimal spontaneous contributions, each amplified by the remaining gain.
        Why: the amplifier is linear in the unsaturated regime, so superposition holds.
      </p>

      <h3>Step 3: Form the ratio and express in terms of G = γ0 d</h3>
      <p>
        Now compute
        <span class="chip">R = φ<sub>s</sub>(d)/φ<sub>ASE</sub>(d)</span>
        and rewrite everything using <b>G = γ<sub>0</sub>d</b>.
      </p>

      <div class="eqbox" id="eq-ratio">
        <div class="eqtop">
          <div class="eqtitle">Signal-to-ASE ratio vs gain–length product</div>
          <button class="copy" data-copy="R(G) = φ_s(d)/φ_ASE(d) = [φ_s(0) e^G] / [(ξ_sp/γ0)(e^G − 1)] = (γ0 φ_s(0)/ξ_sp) · e^G/(e^G − 1) = (γ0 φ_s(0)/ξ_sp) · 1/(1 − e^(−G))">Copy</button>
        </div>
        <pre><code>R = φ_s(d) / φ_ASE(d)
  = [φ_s(0) e^(γ0 d)] / [ (ξ_sp/γ0)(e^(γ0 d) − 1) ]

Let G = γ0 d:
R(G) = (γ0 φ_s(0)/ξ_sp) · e^G/(e^G − 1)
     = (γ0 φ_s(0)/ξ_sp) · 1/(1 − e^(−G))</code></pre>
      </div>

      <div class="callout good" id="final-answer">
        <b>Final result (boxed):</b><br/>
        <span class="chip" style="display:inline-block; margin-top:8px;">
          φ<sub>s</sub>(d)/φ<sub>ASE</sub>(d) = (γ<sub>0</sub> φ<sub>s</sub>(0) / ξ<sub>sp</sub>) · 1 / (1 − e<sup>−γ0 d</sup>)
        </span>
        <div style="margin-top:10px;">
          <button class="copy" data-copy="φ_s(d)/φ_ASE(d) = (γ0 φ_s(0)/ξ_sp) · 1/(1 − e^(−γ0 d))">Copy final answer</button>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <div class="grid2">
        <div class="callout">
          <b>Units</b>
          <ul>
            <li>φ<sub>s</sub> and φ<sub>ASE</sub> are photon fluxes → same units, ratio dimensionless.</li>
            <li>γ<sub>0</sub> has units 1/m, ξ<sub>sp</sub> has units photons·s<sup>−1</sup>·m<sup>−1</sup>, so γ<sub>0</sub>φ<sub>s</sub>(0)/ξ<sub>sp</sub> is dimensionless. Good.</li>
          </ul>
        </div>
        <div class="callout">
          <b>Limiting cases (shape for the sketch)</b>
          <ul>
            <li><b>Small G ≪ 1:</b> 1 − e<sup>−G</sup> ≈ G ⇒ R(G) ≈ (γ<sub>0</sub> φ<sub>s</sub>(0)/ξ<sub>sp</sub>) · (1/G).</li>
            <li><b>Large G ≫ 1:</b> e<sup>−G</sup> → 0 ⇒ R(G) → (γ<sub>0</sub> φ<sub>s</sub>(0)/ξ<sub>sp</sub>) (a constant plateau).</li>
            <li><b>Monotonicity:</b> 1/(1 − e<sup>−G</sup>) decreases from ∞ to 1 as G increases, so the ratio decreases toward its plateau.</li>
          </ul>
        </div>
      </div>

      <p>
        <b>Connection to diagram/plots:</b> The diagram shows ASE “birth” along z; the integral weights each slice by
        e<sup>γ0(d−z)</sup>. In the plots, the x-axis uses G=γ0d. The main curve has the universal shape
        1/(1−e<sup>−G</sup>) scaled by the factor (γ0 φ<sub>s</sub>(0)/ξ<sub>sp</sub>).
      </p>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpret the final formula</h3>
      <p>
        The ratio can be written as
        <span class="chip">R(G) = K · 1/(1 − e<sup>−G</sup>)</span>
        where <span class="chip">K = (γ<sub>0</sub> φ<sub>s</sub>(0))/ξ<sub>sp</sub></span>.
      </p>
      <ul>
        <li><b>K</b> sets the overall scale: bigger injected signal φ<sub>s</sub>(0) or higher gain coefficient γ<sub>0</sub> increases the ratio; bigger spontaneous source rate ξ<sub>sp</sub> decreases it.</li>
        <li><b>The G-dependent factor</b> captures the distributed nature of ASE. It is always ≥ 1 and approaches 1 at large G, meaning that at high gain-length both signal and ASE “share” the same exponential and the ratio saturates to K.</li>
      </ul>

      <h3>How parameters change the outcome (connect to plots)</h3>
      <ul>
        <li>Increasing <b>d</b> increases G, moving you to the right on the main plot; the ratio <b>drops toward the plateau</b>.</li>
        <li>Increasing <b>γ<sub>0</sub></b> does two things: increases G (moves right) and increases K (scales ratio up). Net effect depends on both; the plots update both effects simultaneously.</li>
        <li>Increasing <b>φ<sub>s</sub>(0)</b> scales the ratio upward (signal-dominated).</li>
        <li>Increasing <b>ξ<sub>sp</sub></b> scales the ratio downward (more ASE).</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        Instead of integrating “slices,” you can write an ODE for total forward flux including a constant source:
        <span class="chip">dφ/dz = γ<sub>0</sub>φ + ξ<sub>sp</sub></span>
        and solve it with φ(0)=0 for ASE-only evolution. This yields the same
        φ<sub>ASE</sub>(d) = (ξ<sub>sp</sub>/γ<sub>0</sub>)(e<sup>γ0 d</sup> − 1).
      </p>

      <h3>Concept checks (quick self-test)</h3>
      <ul>
        <li><b>Q:</b> Why does φ<sub>ASE</sub>(d) contain (e<sup>G</sup> − 1) instead of just e<sup>G</sup>? <b>A:</b> Because ASE is generated along the length; the “−1” accounts for photons generated near the output that receive little amplification.</li>
        <li><b>Q:</b> What happens to the ratio as G → ∞? <b>A:</b> It approaches K = γ<sub>0</sub>φ<sub>s</sub>(0)/ξ<sub>sp</sub>, a constant.</li>
        <li><b>Q:</b> What does the divergence R ~ 1/G as G → 0 mean physically? <b>A:</b> In a very short/low-gain device, the idealized distributed-source model gives ASE ≈ ξ<sub>sp</sub>d while the ratio is dominated by the normalization with γ<sub>0</sub>d; practically, other noise and coupling details set a finite value.</li>
        <li><b>Q:</b> If ξ<sub>sp</sub> doubles, what happens to R? <b>A:</b> R halves (inverse proportionality).</li>
      </ul>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="vizWrap">
        <div>
          <div class="mini">
            <figure>
              <canvas id="diagram" width="800" height="420" aria-label="Amplifier diagram"></canvas>
              <figcaption>
                <b>Diagram:</b> Unsaturated amplifier of length d. Signal enters at z=0 and is amplified.
                Spontaneous photons are created uniformly (rate ξ<sub>sp</sub> per unit length) and amplified from their birth point to the output.
              </figcaption>
            </figure>

            <figure>
              <canvas id="plotMain" width="800" height="520" aria-label="Main plot ratio vs gain-length product"></canvas>
              <figcaption>
                <b>Main plot:</b> R(G)=φ<sub>s</sub>(d)/φ<sub>ASE</sub>(d) versus G=γ<sub>0</sub>d. A marker shows your current (γ<sub>0</sub>, d) choice.
              </figcaption>
            </figure>
          </div>

          <figure style="margin-top:12px;">
            <canvas id="plotSecondary" width="1000" height="520" aria-label="Secondary plot signal and ASE vs gain-length product"></canvas>
            <figcaption>
              <b>Secondary plot:</b> Output signal φ<sub>s</sub>(d) and ASE φ<sub>ASE</sub>(d) vs G for the same parameters, revealing how both grow ~e<sup>G</sup> at large G (so the ratio plateaus).
            </figcaption>
          </figure>
        </div>

        <div class="controls">
          <h3>Interactive controls</h3>

          <div class="control">
            <label>
              <span>Gain coefficient γ<sub>0</sub> (m<sup>−1</sup>)</span>
              <span class="chip" id="valGamma">—</span>
            </label>
            <input id="gamma" type="range" min="0" max="1000" value="550" />
            <div class="row">
              <span class="chip" id="chipG">G = γ<sub>0</sub>d: —</span>
            </div>
          </div>

          <div class="control">
            <label>
              <span>Length d (m)</span>
              <span class="chip" id="valD">—</span>
            </label>
            <input id="len" type="range" min="0" max="1000" value="450" />
          </div>

          <div class="control">
            <label>
              <span>Input signal φ<sub>s</sub>(0) (photons/s) <span style="color:var(--muted)">(example)</span></span>
              <span class="chip" id="valPhi0">—</span>
            </label>
            <input id="phi0" type="range" min="0" max="1000" value="700" />
          </div>

          <div class="control">
            <label>
              <span>Spontaneous rate ξ<sub>sp</sub> (photons/s/m) <span style="color:var(--muted)">(example)</span></span>
              <span class="chip" id="valXi">—</span>
            </label>
            <input id="xi" type="range" min="0" max="1000" value="520" />
          </div>

          <label class="toggle">
            <input id="logY" type="checkbox" />
            Use log scale on y-axis (plots)
          </label>

          <div class="callout" style="margin-top:10px;">
            <b>What changes when you move sliders?</b>
            <ul>
              <li>γ<sub>0</sub> changes both <b>G</b> (moves the marker) and the scale factor <b>K = γ<sub>0</sub>φ<sub>s</sub>(0)/ξ<sub>sp</sub></b>.</li>
              <li>d changes <b>G</b> only (moves the marker horizontally).</li>
              <li>φ<sub>s</sub>(0) and ξ<sub>sp</sub> scale the ratio up/down without changing the universal G-shape.</li>
            </ul>
          </div>

          <div class="printNote">
            Interactive plots are static in print. For best results, view on screen.
          </div>
        </div>
      </div>
    </section>

  </main>

  <aside>
    <nav class="toc" aria-label="Table of contents">
      <h3>Table of Contents</h3>
      <a href="#quick-summary">Quick Summary</a>
      <a href="#part0">PART 0 — Concept Primer</a>
      <a href="#part1">PART 1 — Problem Analysis</a>
      <a href="#part2">PART 2 — Strategy & Tips</a>
      <a href="#part3">PART 3 — Full Solution</a>
      <a href="#part4">PART 4 — Deeper Understanding</a>
      <a href="#part5">PART 5 — Visualization Guide</a>
      <a href="#final-answer">Final Answer Box</a>
    </nav>
  </aside>
</div>

<footer>
  <div>
    Notes: This treatment is intentionally minimal and matches the problem’s statement.
    In more detailed amplifier-noise models, ξ<sub>sp</sub> may be expressed using spontaneous emission factors and optical bandwidth;
    here it is taken as the effective photon injection rate per unit length into the tracked forward channel.
  </div>
</footer>

<script>
(function(){
  // ---------- Utility: Copy buttons ----------
  function attachCopyButtons(){
    document.querySelectorAll('button.copy').forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        const text = btn.getAttribute('data-copy') || '';
        try{
          await navigator.clipboard.writeText(text.replace(/&#10;/g,"\n"));
          const old = btn.textContent;
          btn.textContent = "Copied ✓";
          setTimeout(()=>btn.textContent = old, 900);
        }catch(e){
          const old = btn.textContent;
          btn.textContent = "Copy failed";
          setTimeout(()=>btn.textContent = old, 900);
        }
      });
    });
  }

  // ---------- Slider mappings (log-ish for wide dynamic ranges) ----------
  function lerp(a,b,t){ return a + (b-a)*t; }
  function invlerp(a,b,x){ return (x-a)/(b-a); }
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

  // Map slider s in [0,1000] to log10 range [lo, hi]
  function sliderToLog(s, lo, hi){
    const t = clamp(s/1000, 0, 1);
    const exp = lerp(lo, hi, t);
    return Math.pow(10, exp);
  }
  function formatSI(x){
    if (!isFinite(x)) return "—";
    const abs = Math.abs(x);
    if (abs === 0) return "0";
    const units = [
      {v:1e12,s:"T"}, {v:1e9,s:"G"}, {v:1e6,s:"M"}, {v:1e3,s:"k"},
      {v:1,s:""}, {v:1e-3,s:"m"}, {v:1e-6,s:"µ"}, {v:1e-9,s:"n"}
    ];
    for (const u of units){
      if (abs >= u.v){
        return (x/u.v).toFixed(abs/u.v < 10 ? 3 : abs/u.v < 100 ? 2 : 1) + u.s;
      }
    }
    return x.toExponential(2);
  }
  function formatFixed(x, n=3){
    if (!isFinite(x)) return "—";
    if (Math.abs(x) >= 1000) return x.toFixed(0);
    if (Math.abs(x) >= 10) return x.toFixed(2);
    return x.toFixed(n);
  }

  // ---------- Physics model ----------
  // Signal: φ_s(d) = φ0 e^(γ d)
  // ASE (forward): φ_ASE(d) = (ξ/γ) (e^(γ d) - 1)
  // Ratio: R = (γ φ0/ξ) * 1/(1 - e^(-G)), where G=γ d
  function phiSignal(phi0, gamma, d){
    return phi0 * Math.exp(gamma * d);
  }
  function phiASE(xi, gamma, d){
    if (gamma === 0) return xi * d; // limit γ→0
    return (xi/gamma) * (Math.exp(gamma * d) - 1);
  }
  function ratio(phi0, xi, gamma, d){
    const ase = phiASE(xi, gamma, d);
    const sig = phiSignal(phi0, gamma, d);
    return sig/ase;
  }

  // ---------- Canvas helpers ----------
  function setupCanvas(canvas){
    const ctx = canvas.getContext('2d');
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const cssW = Math.max(240, rect.width);
      const cssH = Math.max(180, rect.height);
      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {w:cssW, h:cssH, dpr};
    }
    return {ctx, resize};
  }

  function drawGrid(ctx, x0,y0,w,h, nx, ny){
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.lineWidth = 1;
    for (let i=0;i<=nx;i++){
      const x = x0 + (w*i/nx);
      ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+h); ctx.stroke();
    }
    for (let j=0;j<=ny;j++){
      const y = y0 + (h*j/ny);
      ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+w,y); ctx.stroke();
    }
    ctx.restore();
  }

  function roundRect(ctx, x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function drawAxes(ctx, plot, opts){
    const {x0,y0,w,h} = plot;
    ctx.save();
    // frame
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1.2;
    roundRect(ctx, x0, y0, w, h, 12);
    ctx.stroke();

    // title
    ctx.fillStyle = "rgba(230,237,247,0.95)";
    ctx.font = "600 14px ui-sans-serif, system-ui";
    ctx.fillText(opts.title || "", x0+10, y0-10);

    // labels
    ctx.fillStyle = "rgba(169,180,199,0.95)";
    ctx.font = "12px ui-sans-serif, system-ui";
    ctx.fillText(opts.xlabel || "", x0 + w/2 - ctx.measureText(opts.xlabel||"").width/2, y0 + h + 34);

    // y-label (rotated)
    ctx.save();
    ctx.translate(x0 - 42, y0 + h/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(opts.ylabel || "", -ctx.measureText(opts.ylabel||"").width/2, 0);
    ctx.restore();

    ctx.restore();
  }

  function ticksLinear(min,max,n){
    const out=[];
    for(let i=0;i<=n;i++){
      const t=i/n;
      out.push(lerp(min,max,t));
    }
    return out;
  }

  function ticksLog(min,max,n){
    // min/max in decades (actual values passed; assume >0)
    const out=[];
    const a=Math.log10(min), b=Math.log10(max);
    for(let i=0;i<=n;i++){
      const t=i/n;
      out.push(Math.pow(10, lerp(a,b,t)));
    }
    return out;
  }

  function drawTicks(ctx, plot, xmin,xmax,ymin,ymax, logY){
    const {x0,y0,w,h} = plot;
    ctx.save();
    ctx.fillStyle="rgba(169,180,199,0.92)";
    ctx.font="11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

    // x ticks (linear)
    const xt = ticksLinear(xmin,xmax,5);
    for(const xv of xt){
      const x = x0 + (xv - xmin)/(xmax-xmin)*w;
      ctx.strokeStyle="rgba(255,255,255,0.22)";
      ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(x, y0+h); ctx.lineTo(x, y0+h+6); ctx.stroke();
      const label = (Math.abs(xv) < 10) ? xv.toFixed(2) : xv.toFixed(1);
      ctx.fillText(label, x - ctx.measureText(label).width/2, y0+h+18);
    }

    // y ticks
    const yt = logY ? ticksLog(ymin,ymax,5) : ticksLinear(ymin,ymax,5);
    for(const yv of yt){
      const y = y0 + (1 - (logY ? (Math.log10(yv)-Math.log10(ymin))/(Math.log10(ymax)-Math.log10(ymin)) : (yv-ymin)/(ymax-ymin)))*h;
      ctx.strokeStyle="rgba(255,255,255,0.22)";
      ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(x0-6, y); ctx.lineTo(x0, y); ctx.stroke();
      const label = logY ? formatSI(yv) : (Math.abs(yv) < 10 ? yv.toFixed(3) : yv.toFixed(2));
      ctx.fillText(label, x0 - 10 - ctx.measureText(label).width, y + 3);
    }
    ctx.restore();
  }

  function toXY(plot, x, y, xmin,xmax,ymin,ymax, logY){
    const {x0,y0,w,h} = plot;
    const xx = x0 + (x - xmin)/(xmax-xmin)*w;
    let tY;
    if(logY){
      tY = (Math.log10(y)-Math.log10(ymin))/(Math.log10(ymax)-Math.log10(ymin));
    }else{
      tY = (y - ymin)/(ymax-ymin);
    }
    const yy = y0 + (1 - tY)*h;
    return {xx,yy};
  }

  function drawLegend(ctx, x, y, entries){
    ctx.save();
    ctx.font="12px ui-sans-serif, system-ui";
    const pad=10, lineH=18;
    let w=0;
    for(const e of entries){
      w = Math.max(w, ctx.measureText(e.label).width);
    }
    const boxW = pad*2 + 18 + w;
    const boxH = pad*2 + entries.length*lineH;
    ctx.fillStyle="rgba(0,0,0,0.35)";
    ctx.strokeStyle="rgba(255,255,255,0.12)";
    roundRect(ctx, x, y, boxW, boxH, 12);
    ctx.fill(); ctx.stroke();

    entries.forEach((e,i)=>{
      const yy = y + pad + i*lineH + 12;
      ctx.fillStyle=e.color;
      ctx.fillRect(x+pad, yy-9, 12, 12);
      ctx.fillStyle="rgba(230,237,247,0.92)";
      ctx.fillText(e.label, x+pad+18, yy);
    });
    ctx.restore();
  }

  // ---------- Drawing: diagram ----------
  const diag = setupCanvas(document.getElementById('diagram'));
  function drawDiagram(params){
    const {ctx, resize} = diag;
    const {w,h} = resize();
    ctx.clearRect(0,0,w,h);

    // background glow
    ctx.save();
    ctx.fillStyle="rgba(125,211,252,0.06)";
    ctx.beginPath(); ctx.arc(w*0.25,h*0.45, Math.min(w,h)*0.35, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle="rgba(167,139,250,0.06)";
    ctx.beginPath(); ctx.arc(w*0.78,h*0.35, Math.min(w,h)*0.30, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    // amplifier block
    const x0 = w*0.12, y0 = h*0.32, bw = w*0.76, bh = h*0.26;
    ctx.save();
    ctx.fillStyle="rgba(255,255,255,0.04)";
    ctx.strokeStyle="rgba(255,255,255,0.18)";
    ctx.lineWidth=1.5;
    roundRect(ctx, x0,y0,bw,bh, 18);
    ctx.fill(); ctx.stroke();

    // z axis line
    ctx.strokeStyle="rgba(255,255,255,0.35)";
    ctx.lineWidth=1.2;
    ctx.beginPath();
    ctx.moveTo(x0, y0+bh+55);
    ctx.lineTo(x0+bw, y0+bh+55);
    ctx.stroke();

    // ticks and labels
    ctx.fillStyle="rgba(169,180,199,0.95)";
    ctx.font="12px ui-sans-serif, system-ui";
    ctx.fillText("z = 0", x0-4, y0+bh+76);
    ctx.fillText("z = d", x0+bw-30, y0+bh+76);
    ctx.fillText("amplifier length d", x0 + bw/2 - 52, y0+bh+96);

    // signal arrow in
    ctx.strokeStyle="rgba(125,211,252,0.95)";
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(x0-55, y0+bh/2);
    ctx.lineTo(x0+25, y0+bh/2);
    ctx.stroke();
    ctx.fillStyle="rgba(125,211,252,0.95)";
    ctx.beginPath();
    ctx.moveTo(x0+25, y0+bh/2);
    ctx.lineTo(x0+12, y0+bh/2-7);
    ctx.lineTo(x0+12, y0+bh/2+7);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle="rgba(230,237,247,0.95)";
    ctx.font="600 12.5px ui-sans-serif, system-ui";
    ctx.fillText("input signal  φs(0)  at ν0", x0-58, y0+bh/2-18);

    // output arrow
    ctx.strokeStyle="rgba(52,211,153,0.95)";
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(x0+bw-25, y0+bh/2);
    ctx.lineTo(x0+bw+55, y0+bh/2);
    ctx.stroke();
    ctx.fillStyle="rgba(52,211,153,0.95)";
    ctx.beginPath();
    ctx.moveTo(x0+bw+55, y0+bh/2);
    ctx.lineTo(x0+bw+42, y0+bh/2-7);
    ctx.lineTo(x0+bw+42, y0+bh/2+7);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle="rgba(230,237,247,0.95)";
    ctx.font="600 12.5px ui-sans-serif, system-ui";
    ctx.fillText("output:  φs(d)  +  φASE(d)", x0+bw-30, y0+bh/2-18);

    // spontaneous emission "sprinkles"
    const N=18;
    for(let i=0;i<N;i++){
      const t = (i+0.5)/N;
      const x = x0 + t*bw;
      const y = y0 + bh*0.2 + (i%3)*bh*0.25 + (Math.sin(i*2.1)*4);
      ctx.fillStyle="rgba(167,139,250,0.85)";
      ctx.beginPath(); ctx.arc(x, y, 2.4, 0, Math.PI*2); ctx.fill();
      // little arrow toward output
      ctx.strokeStyle="rgba(167,139,250,0.55)";
      ctx.lineWidth=1.4;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x+18, y+ (i%2? -6: 6));
      ctx.stroke();
    }

    // gain label
    ctx.fillStyle="rgba(230,237,247,0.95)";
    ctx.font="600 13px ui-sans-serif, system-ui";
    ctx.fillText("unsaturated gain coefficient:  γ0 (constant)", x0+14, y0+bh+26);
    ctx.fillStyle="rgba(169,180,199,0.95)";
    ctx.font="12px ui-sans-serif, system-ui";
    ctx.fillText("spontaneous emission rate per unit length into forward mode:  ξsp", x0+14, y0-12);

    ctx.restore();
  }

  // ---------- Drawing: plots ----------
  const mainPlot = setupCanvas(document.getElementById('plotMain'));
  const secPlot  = setupCanvas(document.getElementById('plotSecondary'));

  function drawMain(params){
    const {ctx, resize} = mainPlot;
    const {w,h} = resize();
    ctx.clearRect(0,0,w,h);

    const padL=70, padR=16, padT=44, padB=56;
    const plot = {x0:padL, y0:padT, w:w-padL-padR, h:h-padT-padB};

    // ranges
    const xmin=0.02;
    const xmax=Math.max(2, params.gamma*params.d*1.25, 6);
    const logY = params.logY;

    // build curve
    const n=500;
    let yMin=Infinity, yMax=0;
    const xs=[], ys=[];
    for(let i=0;i<n;i++){
      const x = xmin + (xmax-xmin)*(i/(n-1));
      const G = x;
      // R(G) = (γ φ0/ξ) * 1/(1 - e^-G)
      const K = (params.gamma * params.phi0)/params.xi;
      const y = K / (1 - Math.exp(-G));
      xs.push(x); ys.push(y);
      if (isFinite(y)){
        yMin = Math.min(yMin, y);
        yMax = Math.max(yMax, y);
      }
    }
    if(!isFinite(yMin) || yMin<=0){ yMin = 1e-6; }
    if(yMax<=0 || !isFinite(yMax)){ yMax = 1; }

    // expand for aesthetics
    if(logY){
      yMin = Math.max(yMin/2, 1e-12);
      yMax = yMax*2;
    }else{
      const span = yMax-yMin || 1;
      yMin = Math.max(0, yMin - 0.08*span);
      yMax = yMax + 0.10*span;
    }

    // grid
    drawGrid(ctx, plot.x0, plot.y0, plot.w, plot.h, 6, 6);

    // axes and ticks
    drawAxes(ctx, plot, {
      title:"Main Plot — Ratio R(G) = φs(d) / φASE(d)",
      xlabel:"G = γ0 d  (dimensionless)",
      ylabel:"R (dimensionless)"
    });
    drawTicks(ctx, plot, xmin,xmax, yMin,yMax, logY);

    // curve
    ctx.save();
    ctx.strokeStyle="rgba(125,211,252,0.95)";
    ctx.lineWidth=2.4;
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const p = toXY(plot, xs[i], ys[i], xmin,xmax,yMin,yMax, logY);
      if(i===0) ctx.moveTo(p.xx,p.yy);
      else ctx.lineTo(p.xx,p.yy);
    }
    ctx.stroke();
    ctx.restore();

    // marker at current G
    const Gcur = params.gamma*params.d;
    const Kcur = (params.gamma * params.phi0)/params.xi;
    const Rcur = Kcur / (1 - Math.exp(-Math.max(Gcur, 1e-9)));
    const pm = toXY(plot, clamp(Gcur,xmin,xmax), Rcur, xmin,xmax,yMin,yMax, logY);

    ctx.save();
    ctx.fillStyle="rgba(52,211,153,0.95)";
    ctx.beginPath(); ctx.arc(pm.xx, pm.yy, 5.2, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle="rgba(0,0,0,0.55)";
    ctx.lineWidth=2;
    ctx.stroke();

    // annotation
    const label = `current: G=${Gcur.toFixed(3)}, R=${formatSI(Rcur)}`;
    ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    const tw = ctx.measureText(label).width;
    const lx = Math.min(plot.x0 + plot.w - tw - 12, pm.xx + 10);
    const ly = Math.max(plot.y0 + 14, pm.yy - 10);
    ctx.fillStyle="rgba(0,0,0,0.35)";
    ctx.strokeStyle="rgba(255,255,255,0.12)";
    roundRect(ctx, lx-8, ly-16, tw+16, 24, 10);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle="rgba(230,237,247,0.92)";
    ctx.fillText(label, lx, ly);
    ctx.restore();

    // legend
    drawLegend(ctx, plot.x0 + 12, plot.y0 + 12, [
      {label:"R(G) curve", color:"rgba(125,211,252,0.95)"},
      {label:"current (γ0, d)", color:"rgba(52,211,153,0.95)"}
    ]);
  }

  function drawSecondary(params){
    const {ctx, resize} = secPlot;
    const {w,h} = resize();
    ctx.clearRect(0,0,w,h);

    const padL=74, padR=16, padT=44, padB=56;
    const plot = {x0:padL, y0:padT, w:w-padL-padR, h:h-padT-padB};

    const xmin=0.02;
    const xmax=Math.max(2, params.gamma*params.d*1.25, 6);
    const logY = params.logY;

    // We plot φs_out(G) and φASE_out(G) as functions of G, holding γ0 fixed.
    // To express them vs G, use d = G/γ0. Then:
    // φs_out(G) = φ0 e^G
    // φASE_out(G) = (ξ/γ0)(e^G - 1)
    const n=500;
    const xs=[], ysS=[], ysA=[];
    let yMin=Infinity, yMax=0;
    for(let i=0;i<n;i++){
      const G = xmin + (xmax-xmin)*(i/(n-1));
      const phiS = params.phi0 * Math.exp(G);
      const phiA = (params.gamma===0) ? params.xi*(G/1e-9) : (params.xi/params.gamma)*(Math.exp(G)-1);
      xs.push(G); ysS.push(phiS); ysA.push(phiA);
      for(const y of [phiS,phiA]){
        if(isFinite(y) && y>0){
          yMin=Math.min(yMin,y);
          yMax=Math.max(yMax,y);
        }
      }
    }
    if(!isFinite(yMin) || yMin<=0) yMin=1e-6;
    if(!isFinite(yMax) || yMax<=0) yMax=1;

    if(logY){
      yMin = Math.max(yMin/3, 1e-18);
      yMax = yMax*3;
    }else{
      const span = yMax-yMin || 1;
      yMin = Math.max(0, yMin - 0.05*span);
      yMax = yMax + 0.10*span;
    }

    // grid + axes
    drawGrid(ctx, plot.x0, plot.y0, plot.w, plot.h, 6, 6);
    drawAxes(ctx, plot, {
      title:"Secondary Plot — Output signal and ASE versus G",
      xlabel:"G = γ0 d  (dimensionless)",
      ylabel:"Photon flux at output (photons/s)"
    });
    drawTicks(ctx, plot, xmin,xmax, yMin,yMax, logY);

    // curves
    ctx.save();
    // signal
    ctx.strokeStyle="rgba(52,211,153,0.92)";
    ctx.lineWidth=2.3;
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const p = toXY(plot, xs[i], ysS[i], xmin,xmax,yMin,yMax, logY);
      if(i===0) ctx.moveTo(p.xx,p.yy); else ctx.lineTo(p.xx,p.yy);
    }
    ctx.stroke();
    // ASE
    ctx.strokeStyle="rgba(167,139,250,0.92)";
    ctx.lineWidth=2.3;
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const p = toXY(plot, xs[i], ysA[i], xmin,xmax,yMin,yMax, logY);
      if(i===0) ctx.moveTo(p.xx,p.yy); else ctx.lineTo(p.xx,p.yy);
    }
    ctx.stroke();
    ctx.restore();

    // marker at current G and corresponding outputs
    const Gcur = params.gamma*params.d;
    const phiS_cur = params.phi0*Math.exp(Gcur);
    const phiA_cur = phiASE(params.xi, params.gamma, params.d);

    const ps = toXY(plot, clamp(Gcur,xmin,xmax), phiS_cur, xmin,xmax,yMin,yMax, logY);
    const pa = toXY(plot, clamp(Gcur,xmin,xmax), phiA_cur, xmin,xmax,yMin,yMax, logY);

    ctx.save();
    ctx.fillStyle="rgba(52,211,153,0.95)";
    ctx.beginPath(); ctx.arc(ps.xx, ps.yy, 4.8, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle="rgba(167,139,250,0.95)";
    ctx.beginPath(); ctx.arc(pa.xx, pa.yy, 4.8, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    // legend
    drawLegend(ctx, plot.x0 + 12, plot.y0 + 12, [
      {label:"φs(d) = φs(0) e^G", color:"rgba(52,211,153,0.92)"},
      {label:"φASE(d) = (ξsp/γ0)(e^G − 1)", color:"rgba(167,139,250,0.92)"}
    ]);

    // small note on example values
    ctx.save();
    ctx.fillStyle="rgba(169,180,199,0.95)";
    ctx.font="12px ui-sans-serif, system-ui";
    const note = `example values for plotting: φs(0)=${formatSI(params.phi0)} photons/s, ξsp=${formatSI(params.xi)} photons/s/m, γ0=${formatFixed(params.gamma)} 1/m`;
    ctx.fillText(note, plot.x0, plot.y0 + plot.h + 48);
    ctx.restore();
  }

  // ---------- Controls + update ----------
  const elGamma = document.getElementById('gamma');
  const elLen   = document.getElementById('len');
  const elPhi0  = document.getElementById('phi0');
  const elXi    = document.getElementById('xi');
  const elLogY  = document.getElementById('logY');

  const valGamma = document.getElementById('valGamma');
  const valD = document.getElementById('valD');
  const valPhi0 = document.getElementById('valPhi0');
  const valXi = document.getElementById('valXi');
  const chipG = document.getElementById('chipG');

  function getParams(){
    // γ0: 0.1 .. 5 (log)
    const gamma = sliderToLog(+elGamma.value, Math.log10(0.1), Math.log10(5.0));
    // d: 0.02 .. 6 m (log-ish but allow small) to avoid exactly zero
    const d = sliderToLog(+elLen.value, Math.log10(0.02), Math.log10(6.0));
    // φs0: 1e4 .. 1e10 photons/s
    const phi0 = sliderToLog(+elPhi0.value, 4, 10);
    // ξsp: 1e2 .. 1e8 photons/s/m
    const xi = sliderToLog(+elXi.value, 2, 8);
    return {gamma, d, phi0, xi, logY: !!elLogY.checked};
  }

  function updateReadouts(p){
    valGamma.textContent = formatFixed(p.gamma,3);
    valD.textContent = formatFixed(p.d,3);
    valPhi0.textContent = formatSI(p.phi0);
    valXi.textContent = formatSI(p.xi);
    const G = p.gamma*p.d;
    chipG.innerHTML = `G = γ<sub>0</sub>d: ${G.toFixed(3)}`;
  }

  function render(){
    const p = getParams();
    updateReadouts(p);
    drawDiagram(p);
    drawMain(p);
    drawSecondary(p);
  }

  // Listen
  [elGamma, elLen, elPhi0, elXi, elLogY].forEach(el=>{
    el.addEventListener('input', render);
    el.addEventListener('change', render);
  });
  window.addEventListener('resize', render);

  attachCopyButtons();
  render();
})();
</script>
</body>
</html>
