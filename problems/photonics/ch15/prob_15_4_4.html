<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Saturation Photon-Flux Density & Saturation Optical Intensity (Ruby and Nd3+:YAG)</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#101827;
      --card:#0f1a2b;
      --muted:#8ea0b7;
      --text:#e9f0ff;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --ok:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 18px 40px rgba(0,0,0,.45);
      --shadow2: 0 10px 24px rgba(0,0,0,.35);
      --radius:18px;
      --radius2:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 800px at 15% 5%, rgba(125,211,252,.14), transparent 60%),
        radial-gradient(1000px 700px at 80% 20%, rgba(167,139,250,.14), transparent 55%),
        radial-gradient(900px 700px at 50% 90%, rgba(52,211,153,.08), transparent 60%),
        var(--bg);
      color:var(--text);
      line-height:1.55;
    }

    header{
      padding:38px 20px 18px;
      max-width:1200px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 1.6fr 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      header{grid-template-columns:1fr}
    }
    .titleCard{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:22px 22px 18px;
      box-shadow:var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .titleCard::before{
      content:"";
      position:absolute; inset:-1px;
      background:
        radial-gradient(700px 220px at 20% 0%, rgba(125,211,252,.18), transparent 60%),
        radial-gradient(700px 220px at 80% 10%, rgba(167,139,250,.18), transparent 60%);
      pointer-events:none;
      filter: blur(0px);
    }
    .titleCard > *{position:relative}
    h1{
      margin:0 0 10px 0;
      font-size: clamp(26px, 3vw, 40px);
      letter-spacing:-0.02em;
      line-height:1.12;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size:15px;
      max-width:72ch;
    }

    .quickCard{
      background:rgba(16,24,39,.75);
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:18px 18px 14px;
      box-shadow:var(--shadow2);
    }
    .quickCard h2{
      margin:0 0 10px 0;
      font-size:16px;
      letter-spacing:.02em;
      text-transform:uppercase;
      color:#cfe7ff;
    }
    ul{
      margin:0;
      padding-left:18px;
      color:#dfe9ff;
    }
    li{margin:7px 0}
    .pillRow{
      display:flex; flex-wrap:wrap; gap:8px; margin-top:10px;
    }
    .pill{
      font-size:12px;
      color:#d9ecff;
      border:1px solid rgba(125,211,252,.35);
      background:rgba(125,211,252,.08);
      padding:6px 10px;
      border-radius:999px;
      font-family:var(--mono);
      white-space:nowrap;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding: 10px 20px 56px;
      display:grid;
      grid-template-columns: 260px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
    }

    nav{
      position:sticky;
      top:14px;
      background:rgba(16,24,39,.75);
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:14px 14px 12px;
      box-shadow:var(--shadow2);
      backdrop-filter: blur(8px);
    }
    nav h3{
      margin:0 0 10px 0;
      font-size:13px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color:#cfe7ff;
    }
    .toc a{
      display:block;
      padding:8px 10px;
      margin:3px 0;
      border-radius:10px;
      text-decoration:none;
      color:#dce9ff;
      border:1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      font-size:14px;
    }
    .toc a:hover{
      background:rgba(125,211,252,.09);
      border-color:rgba(125,211,252,.25);
      transform: translateX(2px);
    }

    section{
      background:rgba(16,24,39,.62);
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:18px;
      box-shadow:var(--shadow2);
      margin-bottom:16px;
    }
    section h2{
      margin:0 0 10px 0;
      font-size:20px;
      letter-spacing:-0.01em;
    }
    section h3{
      margin:16px 0 8px 0;
      font-size:16px;
      color:#d8e9ff;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 980px){
      .grid2{grid-template-columns:1fr}
    }

    .callout{
      border-radius:var(--radius2);
      padding:12px 12px 10px;
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    }
    .callout strong{color:#eaf2ff}
    .callout.assump{border-color: rgba(251,191,36,.35); background: rgba(251,191,36,.06)}
    .callout.keyeq{border-color: rgba(125,211,252,.35); background: rgba(125,211,252,.06)}
    .callout.mist{border-color: rgba(251,113,133,.35); background: rgba(251,113,133,.06)}
    .callout.answer{border-color: rgba(52,211,153,.35); background: rgba(52,211,153,.06)}
    .callout small{color:var(--muted)}

    .eq{
      font-family:var(--mono);
      font-size: 13.5px;
      background: rgba(0,0,0,.20);
      border:1px solid rgba(255,255,255,.10);
      padding:10px 10px;
      border-radius:12px;
      overflow:auto;
      position:relative;
    }
    .eq .label{
      display:inline-block;
      font-size:11px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color:#bfe6ff;
      margin-bottom:6px;
    }

    .btnCopy{
      appearance:none;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color:#e9f3ff;
      padding:7px 10px;
      border-radius:12px;
      font-size:12px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      margin-top:8px;
    }
    .btnCopy:hover{transform: translateY(-1px); background: rgba(255,255,255,.09); border-color: rgba(125,211,252,.35)}
    .btnCopy:active{transform: translateY(0px)}
    .copyNote{
      color:var(--muted);
      font-size:12px;
      margin-left:8px;
    }

    .vizWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
    }
    .vizCard{
      border-radius:var(--radius);
      border:1px solid var(--line);
      background: rgba(15,26,43,.55);
      padding:12px;
      box-shadow: var(--shadow2);
      overflow:hidden;
    }
    .vizHeader{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      margin:2px 2px 10px;
    }
    .vizHeader .t{
      font-size:14px;
      letter-spacing:.04em;
      text-transform:uppercase;
      color:#cfe7ff;
    }
    .vizHeader .s{
      font-size:12px;
      color:var(--muted);
      font-family:var(--mono);
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius:14px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
    }
    .controls{
      display:grid;
      grid-template-columns: 1.2fr 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 980px){
      .controls{grid-template-columns:1fr}
    }
    .control{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      border-radius:14px;
      padding:10px 10px 8px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:12px;
      color:#d9e9ff;
      margin-bottom:6px;
    }
    .control label span:last-child{
      color:var(--muted);
      font-family:var(--mono);
      font-size:12px;
      white-space:nowrap;
    }
    input[type="range"]{width:100%}
    select{
      width:100%;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:8px 10px;
      font-size:13px;
      outline:none;
    }
    .readout{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 980px){
      .readout{grid-template-columns:1fr}
    }
    .stat{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      border-radius:14px;
      padding:10px;
    }
    .stat .k{
      font-size:12px;
      color:var(--muted);
      letter-spacing:.06em;
      text-transform:uppercase;
    }
    .stat .v{
      margin-top:4px;
      font-family:var(--mono);
      font-size:14px;
      color:#eaf2ff;
    }
    .stat .v b{color:#c7f9ff}

    .mini{
      font-size:13.5px;
      color:#dbe8ff;
    }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding:10px 20px 40px;
      color:var(--muted);
      font-size:13px;
    }

    @media print{
      body{background:white; color:black}
      header, main, section, nav, .vizCard, .titleCard, .quickCard{
        background:white !important;
        box-shadow:none !important;
        border:1px solid #ddd !important;
      }
      nav{position:static}
      canvas{border:1px solid #bbb !important; background:white !important}
      .btnCopy{display:none}
    }
  </style>
</head>
<body>
  <header>
    <div class="titleCard">
      <h1>Saturation Photon-Flux Density & Saturation Intensity<br/>for Ruby and Nd<sup>3+</sup>:YAG (Homogeneous Broadening)</h1>
      <p class="subtitle">
        We compute the <b>saturation photon-flux density</b> &phi;<sub>s</sub> and the corresponding <b>saturation optical intensity</b> I<sub>s</sub>
        for two classic laser transitions using tabulated emission cross sections and upper-state lifetimes.
        Along the way we connect the formulas to a simple physical picture: “saturation happens when stimulated emission competes with spontaneous decay.”
      </p>
      <div class="pillRow">
        <div class="pill">Two-level / effective transition</div>
        <div class="pill">Homogeneous line → one cross section σ<sub>0</sub></div>
        <div class="pill">Gain saturation model g(I)=g<sub>0</sub>/(1+I/I<sub>s</sub>)</div>
      </div>
    </div>

    <div class="quickCard" id="quick-summary">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>Goal:</b> Find saturation photon flux &phi;<sub>s</sub>(&nu;<sub>0</sub>) and saturation intensity I<sub>s</sub>(&nu;<sub>0</sub>) for <b>ruby (694 nm)</b> and <b>Nd<sup>3+</sup>:YAG (1064 nm)</b>.</li>
        <li><b>Key idea:</b> Saturation occurs when <b>stimulated emission rate</b> equals the <b>upper-state decay rate</b> 1/&tau;.</li>
        <li><b>Governing relation:</b> stimulated rate per excited ion is <span class="eq" style="display:inline-block;padding:2px 6px;border-radius:8px">W<sub>st</sub>=σ<sub>0</sub>&phi;</span>, where &phi; is photon flux (photons·cm<sup>−2</sup>·s<sup>−1</sup>).</li>
        <li><b>Saturation photon flux:</b> <b>&phi;<sub>s</sub>=1/(σ<sub>0</sub>&tau;)</b> (homogeneously broadened, simple rate model).</li>
        <li><b>Intensity–flux link:</b> <b>I = h&nu;&phi; = (hc/&lambda;)&phi;</b> ⇒ <b>I<sub>s</sub> = (hc/&lambda;) &phi;<sub>s</sub></b>.</li>
        <li><b>Numerical results:</b> Ruby: &phi;<sub>s</sub>≈1.67×10<sup>22</sup> photons·cm<sup>−2</sup>·s<sup>−1</sup>, I<sub>s</sub>≈4.77×10<sup>3</sup> W·cm<sup>−2</sup>.</li>
        <li><b>Numerical results:</b> Nd:YAG: &phi;<sub>s</sub>≈1.45×10<sup>21</sup> photons·cm<sup>−2</sup>·s<sup>−1</sup>, I<sub>s</sub>≈2.71×10<sup>2</sup> W·cm<sup>−2</sup>.</li>
      </ul>
    </div>
  </header>

  <main>
    <nav aria-label="Table of contents">
      <h3>Table of Contents</h3>
      <div class="toc">
        <a href="#quick-summary">Quick Summary</a>
        <a href="#part0">PART 0 — Concept Primer</a>
        <a href="#part1">PART 1 — Problem Analysis</a>
        <a href="#part2">PART 2 — Strategy & Tips</a>
        <a href="#part3">PART 3 — Full Solution</a>
        <a href="#part4">PART 4 — Deeper Understanding</a>
        <a href="#part5">PART 5 — Visualization Guide</a>
      </div>
    </nav>

    <div>
      <section id="part0">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <div class="grid2">
          <div class="callout">
            <strong>Core definitions (symbols + units)</strong>
            <ul class="mini">
              <li><b>Photon flux density</b> &phi;: number of photons crossing unit area per unit time.
                Units: photons·cm<sup>−2</sup>·s<sup>−1</sup>.</li>
              <li><b>Optical intensity</b> I: optical power per unit area. Units: W·cm<sup>−2</sup> (or W·m<sup>−2</sup>).</li>
              <li><b>Photon energy</b> E<sub>ph</sub>=h&nu;=hc/&lambda; (J).</li>
              <li><b>Stimulated-emission cross section</b> σ<sub>0</sub> at line center (cm<sup>2</sup>).</li>
              <li><b>Upper-state lifetime</b> &tau; (s): effective decay time of the upper laser level (often the spontaneous lifetime &tau;<sub>sp</sub> in tables).</li>
              <li><b>Saturation intensity</b> I<sub>s</sub>: intensity where gain drops to about half in the simplest model.</li>
            </ul>
          </div>

          <div class="callout">
            <strong>Physical meaning</strong>
            <ul class="mini">
              <li>σ<sub>0</sub> tells how strongly an ion interacts with the light at the transition frequency:
                larger σ<sub>0</sub> → stimulated emission happens faster for the same photon flux.</li>
              <li>&tau; tells how quickly the excited population would decay without the laser field.</li>
              <li>Saturation happens when the light field “empties” the upper level as fast as nature refills/decays it:
                stimulated rate ≈ spontaneous decay rate.</li>
            </ul>
          </div>
        </div>

        <h3>Key principles and validity</h3>
        <div class="callout keyeq">
          <strong>Principle: competition of rates</strong>
          <div class="eq" id="eq-rate">
            <div class="label">Key rate relation</div>
            W<sub>st</sub> = σ<sub>0</sub> · &phi; &nbsp;&nbsp; (stimulated emission rate per excited ion)
          </div>
          <button class="btnCopy" data-copy-target="eq-rate">Copy equation</button><span class="copyNote" id="note-eq-rate"></span>
          <p class="mini" style="margin:10px 0 0">
            This holds for a simple effective transition where σ<sub>0</sub> is the (line-center) stimulated-emission cross section,
            and &phi; is the photon flux at the transition frequency.
          </p>
        </div>

        <div class="callout assump" style="margin-top:12px">
          <strong>Assumptions/conditions (why “homogeneously broadened” matters)</strong>
          <ul class="mini">
            <li><b>Homogeneous broadening:</b> all ions share essentially the same resonance frequency (or rapidly sample it), so saturation affects the whole ensemble similarly.
              Then using a single σ<sub>0</sub> at &nu;<sub>0</sub> is sensible.</li>
            <li><b>Steady-state / CW-like saturation picture:</b> we compare rates using an effective lifetime &tau;.</li>
            <li><b>Neglect complications:</b> excited-state absorption, upconversion, strong reabsorption, multi-level bottlenecks, spatial hole burning, etc.</li>
          </ul>
        </div>

        <h3>Common models/approximations</h3>
        <div class="grid2">
          <div class="callout">
            <strong>Intensity–photon-flux link</strong>
            <div class="eq" id="eq-link">
              <div class="label">Energy flow</div>
              I = (photon energy) × (photon flux) = h&nu; · &phi; = (hc/&lambda;) · &phi;
            </div>
            <button class="btnCopy" data-copy-target="eq-link">Copy equation</button><span class="copyNote" id="note-eq-link"></span>
          </div>
          <div class="callout">
            <strong>Gain saturation (one common form)</strong>
            <div class="eq" id="eq-gain">
              <div class="label">Saturated gain model</div>
              g(I) = g<sub>0</sub> / (1 + I / I<sub>s</sub>)
            </div>
            <button class="btnCopy" data-copy-target="eq-gain">Copy equation</button><span class="copyNote" id="note-eq-gain"></span>
            <p class="mini" style="margin:10px 0 0">
              This model is consistent with defining I<sub>s</sub> via the condition “stimulated rate ≈ 1/&tau;”.
            </p>
          </div>
        </div>

        <h3>Mini intuition examples</h3>
        <ul class="mini">
          <li>If σ<sub>0</sub> is <b>100× larger</b>, you need <b>100× less</b> photon flux to reach saturation (because each photon interacts more strongly).</li>
          <li>If &tau; is <b>10× longer</b>, the excited population is “harder to empty quickly,” so the saturation flux is <b>10× smaller</b> (you can compete with decay using fewer photons per second).</li>
        </ul>

        <div class="callout mist" style="margin-top:12px">
          <strong>What to watch for (pitfalls)</strong>
          <ul class="mini">
            <li><b>Units:</b> σ in cm<sup>2</sup> with &phi; in photons·cm<sup>−2</sup>·s<sup>−1</sup> gives rates in s<sup>−1</sup>.</li>
            <li><b>Lifetime choice:</b> tables may list radiative lifetime &tau;<sub>sp</sub> while the effective upper-state lifetime can be shorter if nonradiative decay is strong.</li>
            <li><b>Definition conventions:</b> some texts include factors like 1/2 depending on the exact saturation definition (population difference vs. upper-level population). Here we use the standard “rate-balance” definition used for gain saturation estimates.</li>
          </ul>
        </div>
      </section>

      <section id="part1">
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

        <h3>Problem restatement</h3>
        <p class="mini">
          Using the tabulated parameters (transition wavelength &lambda;<sub>0</sub>, stimulated emission cross section σ<sub>0</sub>,
          and upper-state lifetime &tau;<sub>sp</sub>), determine:
          <b>(i)</b> the saturation photon-flux density &phi;<sub>s</sub>(&nu;<sub>0</sub>) and
          <b>(ii)</b> the corresponding saturation optical intensity I<sub>s</sub>(&nu;<sub>0</sub>)
          for the <b>homogeneously broadened</b> laser transitions of <b>ruby</b> and <b>Nd<sup>3+</sup>:YAG</b>.
        </p>

        <div class="grid2">
          <div class="callout">
            <strong>Given (from the table)</strong>
            <ul class="mini">
              <li><b>Ruby (Cr<sup>3+</sup>:Al<sub>2</sub>O<sub>3</sub>)</b>: &lambda;<sub>0</sub>=694 nm, σ<sub>0</sub>=2×10<sup>−20</sup> cm<sup>2</sup>, &tau;=3 ms.</li>
              <li><b>Nd<sup>3+</sup>:YAG</b>: &lambda;<sub>0</sub>=1064 nm, σ<sub>0</sub>=3×10<sup>−18</sup> cm<sup>2</sup>, &tau;=230 &mu;s.</li>
              <li>Physical constants: h, c.</li>
            </ul>
          </div>
          <div class="callout">
            <strong>Unknowns</strong>
            <ul class="mini">
              <li>&phi;<sub>s</sub>(&nu;<sub>0</sub>) for ruby and Nd:YAG.</li>
              <li>I<sub>s</sub>(&nu;<sub>0</sub>) for ruby and Nd:YAG.</li>
            </ul>
            <strong style="display:block;margin-top:10px">What must be found</strong>
            <ul class="mini">
              <li>Numeric saturation levels using the provided σ<sub>0</sub> and &tau;.</li>
            </ul>
          </div>
        </div>

        <h3>Relevant physics and why it applies</h3>
        <ul class="mini">
          <li><b>Stimulated emission rate:</b> W<sub>st</sub>=σ<sub>0</sub>&phi; applies because the cross section connects photon flux to transition probability per unit time.</li>
          <li><b>Rate-balance saturation definition:</b> saturation is a competition between W<sub>st</sub> and the decay rate 1/&tau; of the upper state.</li>
          <li><b>Intensity–flux conversion:</b> I=h&nu;&phi; is purely energy accounting: each photon carries energy h&nu;.</li>
        </ul>

        <div class="callout assump">
          <strong>Assumptions (explicit)</strong>
          <ul class="mini">
            <li>Homogeneous broadening; we use σ<sub>0</sub> at the line center &nu;<sub>0</sub>.</li>
            <li>Steady-state effective lifetime &tau; (taken as the tabulated &tau;<sub>sp</sub> for this estimate).</li>
            <li>No additional loss channels included (no ESA, upconversion, etc.).</li>
          </ul>
        </div>

        <h3>Possible approaches</h3>
        <ol class="mini">
          <li><b>Rate-balance approach (best here):</b> set σ<sub>0</sub>&phi;<sub>s</sub>=1/&tau; and convert to I<sub>s</sub>.
            <br/><small style="color:var(--muted)">Pros: direct, minimal assumptions beyond the given ones; Cons: ignores detailed multi-level kinetics.</small>
          </li>
          <li><b>Bloch-equation / saturation parameter approach:</b> derive I<sub>s</sub> from T<sub>1</sub>, T<sub>2</sub> and dipole moment.
            <br/><small style="color:var(--muted)">Pros: microscopic; Cons: requires parameters not provided.</small>
          </li>
          <li><b>Gain-saturation model fitting:</b> use g(I)=g<sub>0</sub>/(1+I/I<sub>s</sub>) and interpret I<sub>s</sub>.
            <br/><small style="color:var(--muted)">Pros: connects to amplifier/laser modeling; Cons: still needs a definition to compute I<sub>s</sub>.</small>
          </li>
        </ol>
        <p class="mini">
          <b>Chosen approach:</b> the <b>rate-balance</b> method is the best match to the data in the table (σ<sub>0</sub>, &tau;, &lambda;).
        </p>
      </section>

      <section id="part2">
        <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

        <ol class="mini">
          <li><b>Goal:</b> express stimulated emission rate in terms of photon flux.
            <br/><b>Tool:</b> W<sub>st</sub>=σ<sub>0</sub>&phi;.
            <br/><b>Meaning:</b> more photons per area per time means more stimulated events per excited ion.</li>

          <li><b>Goal:</b> define saturation condition.
            <br/><b>Tool:</b> “rate-balance” σ<sub>0</sub>&phi;<sub>s</sub>=1/&tau;.
            <br/><b>Meaning:</b> stimulated emission drains the upper level as fast as it naturally decays.</li>

          <li><b>Goal:</b> solve for &phi;<sub>s</sub>.
            <br/><b>Tool:</b> algebra: &phi;<sub>s</sub>=1/(σ<sub>0</sub>&tau;).
            <br/><b>Meaning:</b> saturation flux depends only on how strong the transition is (σ<sub>0</sub>) and how long the excitation lasts (&tau;).</li>

          <li><b>Goal:</b> convert flux to intensity.
            <br/><b>Tool:</b> I=h&nu;&phi;=(hc/&lambda;)&phi;.
            <br/><b>Meaning:</b> multiply photons per second per area by energy per photon.</li>

          <li><b>Goal:</b> compute numerically for ruby and Nd:YAG.
            <br/><b>Tool:</b> careful unit handling (nm→m, ms/&mu;s→s; keep σ in cm<sup>2</sup> to yield W/cm<sup>2</sup> directly).</li>

          <li><b>Goal:</b> sanity checks.
            <br/><b>Tools:</b> dimensional analysis; compare trends with σ and &tau;.</li>
        </ol>

        <div class="callout mist">
          <strong>Common mistakes + quick tips</strong>
          <ul class="mini">
            <li><b>Mixing area units:</b> if σ is in cm<sup>2</sup>, keep intensity in W/cm<sup>2</sup> (or convert everything to SI consistently).</li>
            <li><b>Using GHz linewidth here:</b> not needed for this particular saturation estimate because σ<sub>0</sub> is already given.</li>
            <li><b>Forgetting that I=h&nu;&phi;:</b> photon flux is not power flux until multiplied by photon energy.</li>
          </ul>
        </div>
      </section>

      <section id="part3">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Physical intuition first</h3>
        <p class="mini">
          Imagine a slab of laser medium with many ions in the upper laser level. Two processes depopulate that level:
          <b>(1)</b> spontaneous decay at a rate ~1/&tau; and <b>(2)</b> stimulated emission driven by the passing optical field.
          If the field is weak, stimulated emission is slow and the gain is “unsaturated”.
          If the field is strong enough that stimulated emission drains the upper level about as fast as it naturally decays,
          the medium can’t maintain the same inversion, and the gain drops: that’s saturation.
        </p>

        <div class="callout keyeq">
          <strong>Step 1 — Define photon flux and stimulated rate</strong>
          <p class="mini" style="margin:8px 0 10px">
            Let &phi; be the photon flux density at the transition frequency &nu;<sub>0</sub>:
            photons·cm<sup>−2</sup>·s<sup>−1</sup>. The stimulated emission rate per excited ion is
          </p>
          <div class="eq" id="eq1">
            <div class="label">Stimulated rate per ion</div>
            W<sub>st</sub>(&nu;<sub>0</sub>) = σ<sub>0</sub>(&nu;<sub>0</sub>) · &phi;(&nu;<sub>0</sub>)
          </div>
          <button class="btnCopy" data-copy-target="eq1">Copy equation</button><span class="copyNote" id="note-eq1"></span>
          <p class="mini" style="margin:10px 0 0">
            Here σ<sub>0</sub> is the (line-center) stimulated-emission cross section supplied by the table for a homogeneous line.
          </p>
        </div>

        <div class="callout keyeq" style="margin-top:12px">
          <strong>Step 2 — Saturation condition (rate balance)</strong>
          <p class="mini" style="margin:8px 0 10px">
            A standard operational definition for the saturation photon flux is:
            <b>stimulated emission rate equals spontaneous decay rate</b>.
            That is,
          </p>
          <div class="eq" id="eq2">
            <div class="label">Saturation condition</div>
            σ<sub>0</sub> · &phi;<sub>s</sub> = 1 / &tau;
          </div>
          <button class="btnCopy" data-copy-target="eq2">Copy equation</button><span class="copyNote" id="note-eq2"></span>
          <p class="mini" style="margin:10px 0 0">
            Physically: at &phi;=&phi;<sub>s</sub>, one excited ion is stimulated to emit roughly once during its lifetime.
          </p>
        </div>

        <div class="callout keyeq" style="margin-top:12px">
          <strong>Step 3 — Solve for saturation photon flux</strong>
          <div class="eq" id="eq3">
            <div class="label">Saturation photon-flux density</div>
            &phi;<sub>s</sub>(&nu;<sub>0</sub>) = 1 / (σ<sub>0</sub>(&nu;<sub>0</sub>) · &tau;)
          </div>
          <button class="btnCopy" data-copy-target="eq3">Copy equation</button><span class="copyNote" id="note-eq3"></span>
          <p class="mini" style="margin:10px 0 0">
            Units check: (cm<sup>2</sup>·s)<sup>−1</sup> = photons·cm<sup>−2</sup>·s<sup>−1</sup> (since “photon” is a count).
          </p>
        </div>

        <div class="callout keyeq" style="margin-top:12px">
          <strong>Step 4 — Convert to saturation intensity</strong>
          <p class="mini" style="margin:8px 0 10px">
            Each photon carries energy h&nu;=hc/&lambda;. Power per area equals energy per photon times photons per second per area:
          </p>
          <div class="eq" id="eq4">
            <div class="label">Flux → intensity</div>
            I = h&nu; · &phi; = (hc/&lambda;) · &phi;
            <br/>
            ⇒ I<sub>s</sub> = h&nu;<sub>0</sub> · &phi;<sub>s</sub> = (hc/&lambda;<sub>0</sub>) · 1/(σ<sub>0</sub>&tau;)
          </div>
          <button class="btnCopy" data-copy-target="eq4">Copy equation</button><span class="copyNote" id="note-eq4"></span>
          <p class="mini" style="margin:10px 0 0">
            If σ is in cm<sup>2</sup>, then I<sub>s</sub> comes out naturally in W/cm<sup>2</sup>.
          </p>
        </div>

        <h3>Step 5 — Numerical evaluation</h3>
        <p class="mini">
          We now plug in the table values (σ<sub>0</sub>, &tau;) and compute photon energy using &lambda;<sub>0</sub>.
          Constants: h=6.62607015×10<sup>−34</sup> J·s, c=2.99792458×10<sup>8</sup> m/s.
        </p>

        <div class="grid2">
          <div class="callout">
            <strong>Ruby (Cr<sup>3+</sup>:Al<sub>2</sub>O<sub>3</sub>)</strong>
            <ul class="mini">
              <li>&lambda;<sub>0</sub>=694 nm</li>
              <li>σ<sub>0</sub>=2×10<sup>−20</sup> cm<sup>2</sup></li>
              <li>&tau;=3 ms = 3×10<sup>−3</sup> s</li>
            </ul>
            <div class="eq" id="eq-ruby">
              <div class="label">Compute &phi;<sub>s</sub>, I<sub>s</sub></div>
              &phi;<sub>s</sub> = 1/(σ<sub>0</sub>&tau;)
              = 1 / ((2×10<sup>−20</sup>)(3×10<sup>−3</sup>))
              = 1.67×10<sup>22</sup> photons·cm<sup>−2</sup>·s<sup>−1</sup>
              <br/><br/>
              I<sub>s</sub> = (hc/&lambda;<sub>0</sub>)&phi;<sub>s</sub>
              ≈ ( (6.626×10<sup>−34</sup>)(2.998×10<sup>8</sup>) / (694×10<sup>−9</sup>) ) (1.67×10<sup>22</sup>)
              ≈ 4.77×10<sup>3</sup> W·cm<sup>−2</sup>
            </div>
            <button class="btnCopy" data-copy-target="eq-ruby">Copy ruby result</button><span class="copyNote" id="note-eq-ruby"></span>
          </div>

          <div class="callout">
            <strong>Nd<sup>3+</sup>:YAG</strong>
            <ul class="mini">
              <li>&lambda;<sub>0</sub>=1064 nm</li>
              <li>σ<sub>0</sub>=3×10<sup>−18</sup> cm<sup>2</sup></li>
              <li>&tau;=230 &mu;s = 2.30×10<sup>−4</sup> s</li>
            </ul>
            <div class="eq" id="eq-ndyag">
              <div class="label">Compute &phi;<sub>s</sub>, I<sub>s</sub></div>
              &phi;<sub>s</sub> = 1/(σ<sub>0</sub>&tau;)
              = 1 / ((3×10<sup>−18</sup>)(2.30×10<sup>−4</sup>))
              = 1.45×10<sup>21</sup> photons·cm<sup>−2</sup>·s<sup>−1</sup>
              <br/><br/>
              I<sub>s</sub> = (hc/&lambda;<sub>0</sub>)&phi;<sub>s</sub>
              ≈ ( (6.626×10<sup>−34</sup>)(2.998×10<sup>8</sup>) / (1064×10<sup>−9</sup>) ) (1.45×10<sup>21</sup>)
              ≈ 2.71×10<sup>2</sup> W·cm<sup>−2</sup>
            </div>
            <button class="btnCopy" data-copy-target="eq-ndyag">Copy Nd:YAG result</button><span class="copyNote" id="note-eq-ndyag"></span>
          </div>
        </div>

        <div class="callout answer" style="margin-top:14px">
          <strong>Final Answer (boxed)</strong>
          <div class="eq" id="final-answer">
            <div class="label">Saturation levels</div>
            General (homogeneous, rate-balance):
            &phi;<sub>s</sub> = 1/(σ<sub>0</sub>&tau;), &nbsp; I<sub>s</sub> = (hc/&lambda;<sub>0</sub>) · 1/(σ<sub>0</sub>&tau;)
            <br/><br/>
            Ruby (694 nm, σ<sub>0</sub>=2×10<sup>−20</sup> cm<sup>2</sup>, &tau;=3 ms):
            &phi;<sub>s</sub>≈1.67×10<sup>22</sup> photons·cm<sup>−2</sup>·s<sup>−1</sup>, &nbsp; I<sub>s</sub>≈4.77×10<sup>3</sup> W·cm<sup>−2</sup>
            <br/>
            Nd<sup>3+</sup>:YAG (1064 nm, σ<sub>0</sub>=3×10<sup>−18</sup> cm<sup>2</sup>, &tau;=230 &mu;s):
            &phi;<sub>s</sub>≈1.45×10<sup>21</sup> photons·cm<sup>−2</sup>·s<sup>−1</sup>, &nbsp; I<sub>s</sub>≈2.71×10<sup>2</sup> W·cm<sup>−2</sup>
          </div>
          <button class="btnCopy" data-copy-target="final-answer">Copy final answer</button><span class="copyNote" id="note-final-answer"></span>

          <h3 style="margin-top:14px">Sanity checks</h3>
          <ul class="mini">
            <li><b>Dimensions:</b> σ&tau; has units cm<sup>2</sup>·s, so 1/(σ&tau;) is photons·cm<sup>−2</sup>·s<sup>−1</sup>.</li>
            <li><b>Trend:</b> Nd:YAG has σ<sub>0</sub> about 150× larger than ruby, so it should saturate at much lower flux and intensity—exactly what we find.</li>
            <li><b>Limiting behavior:</b> If σ→0 (weak transition), &phi;<sub>s</sub>→∞ (hard to saturate). If &tau;→∞, &phi;<sub>s</sub>→0 (very easy to compete with decay).</li>
          </ul>
        </div>

        <p class="mini">
          <b>Connection to diagram and plots:</b> In the diagram below, a beam traverses an active medium. As you turn up the beam intensity,
          the stimulated emission rate increases (W<sub>st</sub>=σ&phi;), which lowers the inversion and reduces gain.
          The plots visualize (i) the linear mapping between photon flux and intensity, and (ii) the nonlinear gain saturation curve.
        </p>
      </section>

      <section id="part4">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpreting the formula</h3>
        <ul class="mini">
          <li><b>&phi;<sub>s</sub>=1/(σ<sub>0</sub>&tau;):</b> a pure “rate competition” threshold. Bigger σ<sub>0</sub> or bigger &tau; makes saturation easier (lower required flux).</li>
          <li><b>I<sub>s</sub>=(hc/&lambda;<sub>0</sub>)&phi;<sub>s</sub>:</b> same saturation condition expressed as power per area. Shorter wavelength increases photon energy, pushing I<sub>s</sub> upward for fixed &phi;<sub>s</sub>.</li>
        </ul>

        <h3>Parameter sensitivity (connect to the interactive plots)</h3>
        <div class="callout">
          <ul class="mini">
            <li>Changing σ<sub>0</sub> by a factor <i>k</i> changes &phi;<sub>s</sub> and I<sub>s</sub> by <b>1/k</b>.</li>
            <li>Changing &tau; by a factor <i>k</i> changes &phi;<sub>s</sub> and I<sub>s</sub> by <b>1/k</b>.</li>
            <li>Changing &lambda; changes I<sub>s</sub> (through photon energy) but leaves &phi;<sub>s</sub> unchanged.</li>
          </ul>
        </div>

        <h3>Alternative derivation idea (brief)</h3>
        <p class="mini">
          One can start from the steady-state rate equation for the upper-state population N:
          dN/dt = pump − N/&tau; − (σ&phi;)N.
          In steady state, the stimulated term effectively shortens the lifetime to
          1/&tau;<sub>eff</sub> = 1/&tau; + σ&phi;.
          Saturation corresponds to σ&phi; comparable to 1/&tau;, which leads again to &phi;<sub>s</sub>=1/(στ).
        </p>

        <h3>Concept checks (quick self-test)</h3>
        <ul class="mini">
          <li><b>Q:</b> If σ increases, does I<sub>s</sub> increase or decrease? <b>A:</b> Decrease (inversely with σ).</li>
          <li><b>Q:</b> If you double the lifetime, what happens to &phi;<sub>s</sub>? <b>A:</b> It halves.</li>
          <li><b>Q:</b> Why can Nd:YAG saturate at much lower intensity than ruby? <b>A:</b> Mainly because σ is much larger, so stimulated emission is faster at the same flux.</li>
          <li><b>Q:</b> Does homogeneous broadening matter? <b>A:</b> Yes; it justifies using one σ<sub>0</sub> for the whole ensemble and the simple saturation picture.</li>
        </ul>
      </section>

      <section id="part5">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

        <div class="vizWrap">
          <div class="vizCard">
            <div class="vizHeader">
              <div class="t">Diagram — Saturable gain medium under an optical beam</div>
              <div class="s">Shows photon flux, stimulated emission, and the meaning of I<sub>s</sub></div>
            </div>
            <canvas id="cDiagram" aria-label="Physical setup diagram"></canvas>
          </div>

          <div class="vizCard">
            <div class="vizHeader">
              <div class="t">Main Plot — Intensity I vs photon flux &phi; (with saturation point)</div>
              <div class="s">I = (hc/&lambda;) &phi; and the point (&phi;<sub>s</sub>, I<sub>s</sub>)</div>
            </div>
            <canvas id="cMain" aria-label="Main quantitative plot"></canvas>
          </div>

          <div class="vizCard">
            <div class="vizHeader">
              <div class="t">Secondary Plot — Normalized gain g/g<sub>0</sub> vs intensity (gain saturation)</div>
              <div class="s">g/g<sub>0</sub> = 1/(1+I/I<sub>s</sub>); marker follows your chosen I</div>
            </div>
            <canvas id="cSecondary" aria-label="Secondary quantitative plot"></canvas>

            <div class="controls" role="group" aria-label="Interactive controls">
              <div class="control">
                <label for="materialSel"><span>Material (loads &lambda;, σ<sub>0</sub>, &tau;)</span><span id="matBadge">—</span></label>
                <select id="materialSel">
                  <option value="ruby">Ruby (Cr3+:Al2O3) — 694 nm</option>
                  <option value="ndyag">Nd3+:YAG — 1064 nm</option>
                </select>
              </div>

              <div class="control">
                <label for="Iratio"><span>Chosen intensity (I / I<sub>s</sub>)</span><span id="IratioVal">1.00</span></label>
                <input id="Iratio" type="range" min="0" max="5" step="0.01" value="1.00" />
              </div>

              <div class="control">
                <label for="sigmaScale"><span>Scale σ<sub>0</sub> (×)</span><span id="sigmaScaleVal">1.00</span></label>
                <input id="sigmaScale" type="range" min="0.2" max="5" step="0.01" value="1.00" />
              </div>
            </div>

            <div class="readout" aria-label="Computed readouts">
              <div class="stat">
                <div class="k">Saturation photon flux &phi;<sub>s</sub></div>
                <div class="v" id="phiOut">—</div>
              </div>
              <div class="stat">
                <div class="k">Saturation intensity I<sub>s</sub></div>
                <div class="v" id="IsOut">—</div>
              </div>
              <div class="stat">
                <div class="k">Stimulated rate at chosen I</div>
                <div class="v" id="WstOut">—</div>
              </div>
              <div class="stat">
                <div class="k">Normalized gain at chosen I</div>
                <div class="v" id="gOut">—</div>
              </div>
            </div>

            <div class="callout" style="margin-top:12px">
              <strong>How the interaction works</strong>
              <ul class="mini">
                <li><b>Material selector</b> switches (&lambda;<sub>0</sub>, σ<sub>0</sub>, &tau;) between ruby and Nd:YAG, updating all plots and readouts.</li>
                <li><b>I/I<sub>s</sub> slider</b> moves the marker on the gain curve and updates the stimulated rate W<sub>st</sub>.</li>
                <li><b>σ scale slider</b> explores sensitivity: increasing σ lowers &phi;<sub>s</sub> and I<sub>s</sub> and changes the marker’s absolute intensity.</li>
              </ul>
              <small>Note: This is a clean “textbook” saturation model meant to match the problem’s scope.</small>
            </div>
          </div>
        </div>
      </section>
    </div>
  </main>

  <footer>
    <div>
      Built as a self-contained learning note (vanilla HTML/CSS/JS). Numerical values use the provided table parameters:
      Ruby: 694 nm, σ<sub>0</sub>=2×10<sup>−20</sup> cm<sup>2</sup>, &tau;=3 ms; Nd:YAG: 1064 nm, σ<sub>0</sub>=3×10<sup>−18</sup> cm<sup>2</sup>, &tau;=230 &mu;s.
    </div>
  </footer>

  <script>
    // ---------- Copy buttons ----------
    function getPlainTextFromElement(el){
      // Convert HTML with subs/sups to a readable plain text.
      // Minimal converter: replace <sub>/<sup> with _{}/^{}, strip tags.
      const clone = el.cloneNode(true);

      // Replace <br> with newlines
      clone.querySelectorAll("br").forEach(br => br.replaceWith("\n"));

      // Convert subs/sups into inline markers
      clone.querySelectorAll("sub").forEach(s => {
        const t = s.textContent;
        s.replaceWith("_{"+t+"}");
      });
      clone.querySelectorAll("sup").forEach(s => {
        const t = s.textContent;
        s.replaceWith("^{" + t + "}");
      });

      // Remove labels
      clone.querySelectorAll(".label").forEach(l => l.remove());

      // Strip remaining tags to text
      return clone.textContent.replace(/\n{3,}/g,"\n\n").trim();
    }

    function flashNote(noteEl, msg, ok=true){
      noteEl.textContent = msg;
      noteEl.style.color = ok ? "rgba(52,211,153,.95)" : "rgba(251,113,133,.95)";
      setTimeout(()=>{ noteEl.textContent=""; }, 1200);
    }

    document.querySelectorAll(".btnCopy").forEach(btn=>{
      btn.addEventListener("click", async ()=>{
        const id = btn.getAttribute("data-copy-target");
        const target = document.getElementById(id);
        const note = document.getElementById("note-"+id) || btn.nextElementSibling;
        if(!target){ if(note) flashNote(note, "Target not found", false); return; }
        const txt = getPlainTextFromElement(target);
        try{
          await navigator.clipboard.writeText(txt);
          if(note) flashNote(note, "Copied!");
        }catch(e){
          if(note) flashNote(note, "Copy failed", false);
        }
      });
    });

    // ---------- Physics / parameters ----------
    const CONST = {
      h: 6.62607015e-34,     // J*s
      c: 2.99792458e8        // m/s
    };

    const materials = {
      ruby: {
        name: "Ruby (Cr3+:Al2O3)",
        lambda_nm: 694,
        sigma_cm2: 2e-20,
        tau_s: 3e-3
      },
      ndyag: {
        name: "Nd3+:YAG",
        lambda_nm: 1064,
        sigma_cm2: 3e-18,
        tau_s: 230e-6
      }
    };

    function compute(matKey, sigmaScale){
      const m = materials[matKey];
      const lambda_m = m.lambda_nm * 1e-9;
      const nu = CONST.c / lambda_m;
      const Eph = CONST.h * nu;               // J
      const sigma = m.sigma_cm2 * sigmaScale; // cm^2
      const tau = m.tau_s;                    // s
      const phi_s = 1.0 / (sigma * tau);      // photons/(cm^2*s)
      const I_s = Eph * phi_s;                // (J)*(photons/(cm^2*s)) = W/cm^2
      return { ...m, lambda_m, nu, Eph, sigma, tau, phi_s, I_s };
    }

    function fmtSci(x, sig=3){
      if(!isFinite(x) || x===0) return String(x);
      const exp = Math.floor(Math.log10(Math.abs(x)));
      const mant = x / Math.pow(10, exp);
      return mant.toFixed(sig-1) + "×10^" + exp;
    }
    function fmt(x){
      if(!isFinite(x)) return "—";
      if(x === 0) return "0";
      const ax = Math.abs(x);
      if(ax >= 1e4 || ax < 1e-2) return fmtSci(x, 3);
      return x.toFixed(3);
    }

    // ---------- Canvas drawing helpers (HiDPI, axes, ticks, grid) ----------
    function setupCanvas(canvas){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(320, rect.width);
      const h = rect.height;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return { ctx, w, h, dpr };
    }

    function clear(ctx, w, h){
      ctx.clearRect(0,0,w,h);
      // subtle vignette
      const g = ctx.createRadialGradient(w*0.2,h*0.2,10,w*0.5,h*0.5,Math.max(w,h)*0.9);
      g.addColorStop(0, "rgba(255,255,255,0.03)");
      g.addColorStop(1, "rgba(0,0,0,0.20)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);
    }

    function drawAxes(ctx, box, xLabel, yLabel, title){
      const {x,y,w,h} = box;
      // frame
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 1;
      ctx.strokeRect(x,y,w,h);

      // title
      ctx.fillStyle = "rgba(233,240,255,0.92)";
      ctx.font = "600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(title, x+8, y+16);

      // axis labels
      ctx.fillStyle = "rgba(142,160,183,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillText(xLabel, x + w - ctx.measureText(xLabel).width - 8, y + h - 8);

      ctx.save();
      ctx.translate(x+12, y+22);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();
    }

    function ticksLinear(min, max, n=6){
      const span = max - min;
      if(span<=0) return [min];
      const raw = span / (n-1);
      const pow10 = Math.pow(10, Math.floor(Math.log10(raw)));
      const steps = [1,2,5,10].map(m=>m*pow10);
      let step = steps[0];
      for(const s of steps){
        if(Math.abs(raw-s) < Math.abs(raw-step)) step=s;
      }
      const start = Math.ceil(min/step)*step;
      const out=[];
      for(let v=start; v<=max+1e-12; v+=step) out.push(v);
      return out;
    }

    function drawGridAndTicks(ctx, box, xMin, xMax, yMin, yMax, fmtX, fmtY){
      const {x,y,w,h} = box;
      ctx.save();
      ctx.beginPath();
      ctx.rect(x,y,w,h);
      ctx.clip();

      const xt = ticksLinear(xMin, xMax, 6);
      const yt = ticksLinear(yMin, yMax, 6);

      // grid
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      xt.forEach(v=>{
        const px = x + (v-xMin)/(xMax-xMin)*w;
        ctx.beginPath();
        ctx.moveTo(px,y);
        ctx.lineTo(px,y+h);
        ctx.stroke();
      });
      yt.forEach(v=>{
        const py = y + h - (v-yMin)/(yMax-yMin)*h;
        ctx.beginPath();
        ctx.moveTo(x,py);
        ctx.lineTo(x+w,py);
        ctx.stroke();
      });

      // ticks + labels
      ctx.restore();
      ctx.fillStyle = "rgba(142,160,183,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";

      xt.forEach(v=>{
        const px = x + (v-xMin)/(xMax-xMin)*w;
        ctx.strokeStyle = "rgba(255,255,255,0.16)";
        ctx.beginPath();
        ctx.moveTo(px, y+h);
        ctx.lineTo(px, y+h+5);
        ctx.stroke();
        const s = fmtX(v);
        ctx.fillText(s, px - ctx.measureText(s).width/2, y+h+18);
      });

      yt.forEach(v=>{
        const py = y + h - (v-yMin)/(yMax-yMin)*h;
        ctx.strokeStyle = "rgba(255,255,255,0.16)";
        ctx.beginPath();
        ctx.moveTo(x-5, py);
        ctx.lineTo(x, py);
        ctx.stroke();
        const s = fmtY(v);
        ctx.fillText(s, x - ctx.measureText(s).width - 8, py + 4);
      });
    }

    function plotLine(ctx, box, xMin, xMax, yMin, yMax, f, n=240, stroke="rgba(125,211,252,0.95)"){
      const {x,y,w,h}=box;
      ctx.save();
      ctx.beginPath();
      ctx.rect(x,y,w,h);
      ctx.clip();

      ctx.beginPath();
      for(let i=0;i<=n;i++){
        const xv = xMin + (xMax-xMin)*i/n;
        const yv = f(xv);
        const px = x + (xv-xMin)/(xMax-xMin)*w;
        const py = y + h - (yv-yMin)/(yMax-yMin)*h;
        if(i===0) ctx.moveTo(px,py);
        else ctx.lineTo(px,py);
      }
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }

    function drawMarker(ctx, box, xMin, xMax, yMin, yMax, xv, yv, color="rgba(52,211,153,0.95)", label=""){
      const {x,y,w,h}=box;
      const px = x + (xv-xMin)/(xMax-xMin)*w;
      const py = y + h - (yv-yMin)/(yMax-yMin)*h;
      ctx.save();
      ctx.fillStyle = color;
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(px,py,5.5,0,Math.PI*2);
      ctx.fill();
      ctx.stroke();

      if(label){
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
        const pad=6;
        const tw = ctx.measureText(label).width;
        const bx = Math.min(px+10, x+w - (tw+pad*2));
        const by = Math.max(y+10, py-28);
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.strokeStyle = "rgba(255,255,255,0.14)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.roundRect(bx,by, tw+pad*2, 22, 9);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = "rgba(233,240,255,0.92)";
        ctx.fillText(label, bx+pad, by+15);
      }
      ctx.restore();
    }

    // Polyfill for roundRect for older browsers
    if(!CanvasRenderingContext2D.prototype.roundRect){
      CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
        const rr = Math.min(r, w/2, h/2);
        this.beginPath();
        this.moveTo(x+rr,y);
        this.arcTo(x+w,y,x+w,y+h,rr);
        this.arcTo(x+w,y+h,x,y+h,rr);
        this.arcTo(x,y+h,x,y,rr);
        this.arcTo(x,y,x+w,y,rr);
        this.closePath();
        return this;
      };
    }

    // ---------- Draw diagram ----------
    function drawDiagram(state){
      const canvas = document.getElementById("cDiagram");
      const {ctx,w,h} = setupCanvas(canvas);
      clear(ctx,w,h);

      // Layout
      const margin = 18;
      const cx = margin, cy = margin, cw = w - 2*margin, ch = h - 2*margin;

      // Medium slab
      const slabX = cx + cw*0.24;
      const slabW = cw*0.52;
      const slabY = cy + ch*0.28;
      const slabH = ch*0.44;

      ctx.fillStyle = "rgba(125,211,252,0.08)";
      ctx.strokeStyle = "rgba(125,211,252,0.35)";
      ctx.lineWidth = 2;
      ctx.roundRect(slabX, slabY, slabW, slabH, 16);
      ctx.fill();
      ctx.stroke();

      // Beam arrow
      const beamY = cy + ch*0.50;
      const x0 = cx + cw*0.06;
      const x1 = cx + cw*0.94;
      ctx.strokeStyle = "rgba(233,240,255,0.75)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x0, beamY);
      ctx.lineTo(x1, beamY);
      ctx.stroke();

      // Arrow head
      ctx.fillStyle = "rgba(233,240,255,0.75)";
      ctx.beginPath();
      ctx.moveTo(x1, beamY);
      ctx.lineTo(x1-14, beamY-7);
      ctx.lineTo(x1-14, beamY+7);
      ctx.closePath();
      ctx.fill();

      // Pump squiggles (left/top)
      ctx.strokeStyle = "rgba(167,139,250,0.75)";
      ctx.lineWidth = 2;
      for(let i=0;i<3;i++){
        const px = slabX + slabW*(0.18 + i*0.2);
        const py0 = slabY - 18;
        ctx.beginPath();
        for(let k=0;k<16;k++){
          const t = k/15;
          const xx = px + 10*Math.sin(t*2*Math.PI);
          const yy = py0 + t*14;
          if(k===0) ctx.moveTo(xx,yy);
          else ctx.lineTo(xx,yy);
        }
        ctx.stroke();
      }

      // Inside slab: dots (ions)
      const nx=8, ny=4;
      ctx.fillStyle = "rgba(52,211,153,0.85)";
      for(let j=0;j<ny;j++){
        for(let i=0;i<nx;i++){
          const px = slabX + slabW*(0.10 + i*(0.80/(nx-1)));
          const py = slabY + slabH*(0.20 + j*(0.60/(ny-1)));
          ctx.beginPath();
          ctx.arc(px,py,2.6,0,Math.PI*2);
          ctx.fill();
        }
      }

      // Labels
      ctx.fillStyle = "rgba(233,240,255,0.92)";
      ctx.font = "600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Active medium (homogeneous line)", slabX+12, slabY+20);

      ctx.fillStyle = "rgba(142,160,183,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillText("beam intensity I, photon flux ϕ", x0+4, beamY-12);
      ctx.fillText("pump (creates inversion)", slabX+10, slabY-24);

      // Rate balance text box
      const bx = cx + cw*0.06, by = cy + ch*0.72, bw = cw*0.62, bh = ch*0.22;
      ctx.fillStyle = "rgba(0,0,0,0.40)";
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.lineWidth = 1;
      ctx.roundRect(bx,by,bw,bh,14);
      ctx.fill(); ctx.stroke();

      ctx.fillStyle = "rgba(233,240,255,0.92)";
      ctx.font = "600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Saturation idea (rate competition)", bx+12, by+20);

      ctx.fillStyle = "rgba(142,160,183,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      const line1 = "W_st = σ0 ϕ   and   saturation when  σ0 ϕ_s ≈ 1/τ";
      const line2 = "Then  I_s = hν ϕ_s = (hc/λ0) 1/(σ0 τ)";
      ctx.fillText(line1, bx+12, by+44);
      ctx.fillText(line2, bx+12, by+64);

      // Show current material numbers (short)
      const m = state;
      const line3 = `Selected: ${m.name}  |  λ0=${m.lambda_nm} nm,  σ0=${fmtSci(m.sigma,3)} cm^2,  τ=${fmt(m.tau)} s`;
      ctx.fillStyle = "rgba(125,211,252,0.95)";
      ctx.fillText(line3, bx+12, by+86);
    }

    // ---------- Main plot: I vs phi ----------
    function drawMainPlot(state){
      const canvas = document.getElementById("cMain");
      const {ctx,w,h} = setupCanvas(canvas);
      clear(ctx,w,h);

      const padL=64, padR=18, padT=30, padB=44;
      const box = {x:padL, y:padT, w:w-padL-padR, h:h-padT-padB};

      // Choose domain around saturation point
      const phiS = state.phi_s;
      const xMin = 0;
      const xMax = phiS * 2.2;
      const yMin = 0;
      const yMax = state.I_s * 2.2;

      drawAxes(ctx, box, "ϕ (photons·cm⁻²·s⁻¹)", "I (W·cm⁻²)", "I = (hc/λ) ϕ  with saturation point");
      drawGridAndTicks(ctx, box, xMin, xMax, yMin, yMax,
        v => (v===0 ? "0" : fmtSci(v,2)),
        v => (v===0 ? "0" : (Math.abs(v)>=1000 ? fmtSci(v,2) : v.toFixed(0)))
      );

      // Plot line
      const slope = state.Eph; // J, and I=Eph*phi
      plotLine(ctx, box, xMin, xMax, yMin, yMax, (phi)=>slope*phi, 260, "rgba(125,211,252,0.95)");

      // Mark saturation point
      drawMarker(ctx, box, xMin, xMax, yMin, yMax, phiS, state.I_s, "rgba(52,211,153,0.95)", "(ϕs, Is)");

      // Legend
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.lineWidth = 1;
      ctx.roundRect(box.x+10, box.y+box.h-58, 240, 48, 12);
      ctx.fill(); ctx.stroke();

      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillStyle = "rgba(233,240,255,0.92)";
      ctx.fillText("Line: I = (hc/λ) ϕ", box.x+22, box.y+box.h-36);
      ctx.fillStyle = "rgba(52,211,153,0.95)";
      ctx.fillText("Marker: saturation (ϕs, Is)", box.x+22, box.y+box.h-18);

      // Small annotation about numbers
      ctx.fillStyle = "rgba(142,160,183,0.95)";
      ctx.fillText(`λ0=${state.lambda_nm} nm`, box.x+box.w-120, box.y+18);
    }

    // ---------- Secondary plot: g/g0 vs I ----------
    function drawSecondaryPlot(state, Iratio){
      const canvas = document.getElementById("cSecondary");
      const {ctx,w,h} = setupCanvas(canvas);
      clear(ctx,w,h);

      const padL=64, padR=18, padT=30, padB=44;
      const box = {x:padL, y:padT, w:w-padL-padR, h:h-padT-padB};

      // x in W/cm^2 up to 5*Is
      const xMin = 0;
      const xMax = state.I_s * 5;
      const yMin = 0;
      const yMax = 1.05;

      drawAxes(ctx, box, "I (W·cm⁻²)", "g/g0 (unitless)", "Gain saturation: g/g0 = 1/(1 + I/Is)");
      drawGridAndTicks(ctx, box, xMin, xMax, yMin, yMax,
        v => (v===0 ? "0" : (xMax>=1000 ? fmtSci(v,2) : v.toFixed(0))),
        v => v.toFixed(2)
      );

      // curve
      plotLine(ctx, box, xMin, xMax, yMin, yMax, (I)=>1/(1+I/state.I_s), 300, "rgba(167,139,250,0.95)");

      // marker for chosen I
      const I = Iratio * state.I_s;
      const g = 1/(1+Iratio);
      drawMarker(ctx, box, xMin, xMax, yMin, yMax, I, g, "rgba(52,211,153,0.95)", `I/Is=${Iratio.toFixed(2)}`);

      // Reference line at g/g0=0.5
      ctx.save();
      ctx.beginPath();
      ctx.rect(box.x,box.y,box.w,box.h);
      ctx.clip();
      const y05 = box.y + box.h - (0.5-yMin)/(yMax-yMin)*box.h;
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(box.x, y05);
      ctx.lineTo(box.x+box.w, y05);
      ctx.stroke();
      ctx.restore();

      ctx.fillStyle = "rgba(142,160,183,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillText("g/g0=0.5", box.x+8, y05-6);

      // Legend box
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.lineWidth = 1;
      ctx.roundRect(box.x+10, box.y+box.h-58, 270, 48, 12);
      ctx.fill(); ctx.stroke();

      ctx.fillStyle = "rgba(233,240,255,0.92)";
      ctx.fillText("Curve: g/g0 = 1/(1 + I/Is)", box.x+22, box.y+box.h-36);
      ctx.fillStyle = "rgba(52,211,153,0.95)";
      ctx.fillText("Marker: your chosen I", box.x+22, box.y+box.h-18);
    }

    // ---------- UI wiring ----------
    const els = {
      sel: document.getElementById("materialSel"),
      Iratio: document.getElementById("Iratio"),
      IratioVal: document.getElementById("IratioVal"),
      sigmaScale: document.getElementById("sigmaScale"),
      sigmaScaleVal: document.getElementById("sigmaScaleVal"),
      matBadge: document.getElementById("matBadge"),
      phiOut: document.getElementById("phiOut"),
      IsOut: document.getElementById("IsOut"),
      WstOut: document.getElementById("WstOut"),
      gOut: document.getElementById("gOut")
    };

    function update(){
      const key = els.sel.value;
      const Iratio = parseFloat(els.Iratio.value);
      const sigmaScale = parseFloat(els.sigmaScale.value);

      els.IratioVal.textContent = Iratio.toFixed(2);
      els.sigmaScaleVal.textContent = sigmaScale.toFixed(2);

      const state = compute(key, sigmaScale);

      els.matBadge.textContent = key === "ruby" ? "ruby" : "Nd:YAG";

      // Readouts
      els.phiOut.innerHTML = `<b>${fmtSci(state.phi_s,3)}</b> photons·cm<sup>−2</sup>·s<sup>−1</sup>`;
      els.IsOut.innerHTML  = `<b>${(Math.abs(state.I_s)>=1000?fmtSci(state.I_s,3):state.I_s.toFixed(2))}</b> W·cm<sup>−2</sup>`;

      // Stimulated rate at chosen I:
      // phi = I / (h nu) = I / Eph
      const I = Iratio * state.I_s;
      const phi = I / state.Eph;
      const Wst = state.sigma * phi; // s^-1
      const gnorm = 1/(1+Iratio);

      els.WstOut.innerHTML = `<b>${fmt(Wst)}</b> s<sup>−1</sup>  <span style="color:rgba(142,160,183,.95)"> (compare 1/τ=${fmt(1/state.tau)} s<sup>−1</sup>)</span>`;
      els.gOut.innerHTML = `<b>${gnorm.toFixed(3)}</b>`;

      // Draw all canvases
      drawDiagram(state);
      drawMainPlot(state);
      drawSecondaryPlot(state, Iratio);
    }

    els.sel.addEventListener("change", update);
    els.Iratio.addEventListener("input", update);
    els.sigmaScale.addEventListener("input", update);
    window.addEventListener("resize", ()=>{ update(); });

    // Initial render
    update();
  </script>
</body>
</html>
