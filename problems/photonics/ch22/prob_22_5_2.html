<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Combined SHG + SFG: Five-Wave Mixing Coupled Equations and Suppression of SHG</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --card:#121c3a;
      --ink:#eaf0ff;
      --muted:#b9c6ea;
      --faint:#7f93c9;
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.16);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#86efac;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --radius2:22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1000px 700px at 20% -10%, rgba(125,211,252,.18), transparent 60%),
        radial-gradient(900px 650px at 85% 0%, rgba(167,139,250,.16), transparent 55%),
        radial-gradient(800px 600px at 65% 120%, rgba(134,239,172,.08), transparent 55%),
        linear-gradient(180deg, #070a14, #0b1020 28%, #070a14);
      line-height:1.55;
      letter-spacing:.1px;
    }

    header{
      padding: clamp(18px, 3vw, 32px);
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.04), transparent);
      position:relative;
      overflow:hidden;
    }
    header::after{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(800px 260px at 35% 0%, rgba(125,211,252,.14), transparent 60%);
      pointer-events:none;
      filter: blur(10px);
      opacity:.9;
    }
    header .wrap{position:relative; z-index:1; max-width:1200px; margin:0 auto;}
    h1{
      margin:0 0 8px 0;
      font-size: clamp(22px, 2.4vw, 34px);
      line-height:1.18;
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      max-width: 70ch;
      font-size: clamp(14px, 1.25vw, 16px);
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding: clamp(16px, 2.8vw, 28px);
    }

    .layout{
      display:grid;
      grid-template-columns: 310px 1fr;
      gap: 18px;
      align-items:start;
    }

    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 14px 14px 10px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }
    nav.toc h2{
      font-size: 13px;
      letter-spacing:.12em;
      text-transform: uppercase;
      color: var(--muted);
      margin: 2px 0 10px;
    }
    .toc a{
      display:block;
      padding: 8px 10px;
      border-radius: 12px;
      color: var(--ink);
      text-decoration:none;
      border: 1px solid transparent;
      transition: transform .18s ease, background .18s ease, border-color .18s ease;
      font-size: 14px;
    }
    .toc a:hover{
      background: rgba(125,211,252,.09);
      border-color: rgba(125,211,252,.22);
      transform: translateX(2px);
    }
    .toc .small{
      color: var(--faint);
      font-size: 12px;
      margin-top: 8px;
      padding: 10px 10px 8px;
      border-top:1px solid var(--line);
    }

    article{
      min-width: 0;
    }

    section{
      margin: 0 0 18px 0;
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.015));
      border: 1px solid var(--line);
      border-radius: var(--radius2);
      padding: clamp(14px, 2vw, 20px);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    section::before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background: radial-gradient(800px 180px at 10% 0%, rgba(125,211,252,.08), transparent 65%);
      opacity:.9;
    }
    section > *{position:relative; z-index:1;}

    h2{
      margin: 0 0 10px 0;
      font-size: clamp(18px, 1.9vw, 24px);
      letter-spacing:.2px;
    }
    h3{
      margin: 14px 0 8px;
      font-size: 16px;
      color: var(--ink);
    }
    p{margin: 8px 0; color: var(--ink);}
    .muted{color:var(--muted)}
    .fine{color:var(--faint); font-size: 13px}

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns: 1fr;}
      nav.toc{position:relative; top:auto;}
      .grid2,.grid3{grid-template-columns: 1fr;}
    }

    .card{
      background: rgba(18,28,58,.62);
      border: 1px solid var(--line2);
      border-radius: var(--radius);
      padding: 12px 12px 10px;
    }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    @media (max-width: 980px){ .callouts{grid-template-columns:1fr;} }

    .callout{
      border-radius: var(--radius);
      padding: 12px 12px 10px;
      border: 1px solid var(--line2);
      background: rgba(18,28,58,.62);
      position:relative;
      overflow:hidden;
    }
    .callout::after{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(480px 220px at 20% 0%, rgba(167,139,250,.14), transparent 65%);
      opacity:.8;
      pointer-events:none;
    }
    .callout > *{position:relative; z-index:1;}
    .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size: 12px;
      letter-spacing:.1em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .dot{
      width:10px; height:10px; border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(125,211,252,.15);
    }
    .dot.purple{background: var(--accent2); box-shadow: 0 0 0 3px rgba(167,139,250,.16);}
    .dot.green{background: var(--good); box-shadow: 0 0 0 3px rgba(134,239,172,.16);}
    .dot.yellow{background: var(--warn); box-shadow: 0 0 0 3px rgba(251,191,36,.16);}
    .dot.red{background: var(--bad); box-shadow: 0 0 0 3px rgba(251,113,133,.16);}

    .eqbox{
      margin: 10px 0 0;
      border-radius: 16px;
      border:1px solid rgba(125,211,252,.22);
      background: linear-gradient(180deg, rgba(125,211,252,.08), rgba(125,211,252,.04));
      padding: 12px 12px 10px;
      overflow:auto;
      position:relative;
    }
    .eqbox pre{
      margin:0;
      color: var(--ink);
      font-family: var(--mono);
      font-size: 13px;
      line-height: 1.45;
      white-space: pre;
    }

    .copyrow{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-top: 8px;
      flex-wrap:wrap;
    }
    button.copy{
      appearance:none;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--ink);
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 13px;
      cursor:pointer;
      transition: transform .12s ease, background .18s ease, border-color .18s ease;
    }
    button.copy:hover{
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.28);
      transform: translateY(-1px);
    }
    button.copy:active{transform: translateY(0px) scale(.99);}
    .copyhint{font-size: 12px; color: var(--faint);}

    details{
      margin-top: 12px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.02);
      border-radius: 16px;
      padding: 10px 12px;
    }
    details summary{
      cursor:pointer;
      color: var(--muted);
      font-weight: 600;
      list-style:none;
    }
    details summary::-webkit-details-marker{display:none}
    details summary::before{
      content:"▸";
      margin-right:10px;
      color: var(--accent);
      display:inline-block;
      transform: translateY(-1px);
      transition: transform .18s ease;
    }
    details[open] summary::before{transform: rotate(90deg) translateX(1px);}

    figure{
      margin: 12px 0 0;
      border: 1px solid var(--line2);
      background: rgba(18,28,58,.55);
      border-radius: var(--radius2);
      overflow:hidden;
    }
    figcaption{
      padding: 10px 12px 12px;
      color: var(--muted);
      font-size: 13px;
      border-top:1px solid var(--line);
    }
    .canvasWrap{
      padding: 10px 10px 0;
    }
    canvas{
      width:100%;
      height: 360px;
      display:block;
      border-radius: 16px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.10);
    }
    @media (max-width: 980px){
      canvas{height: 320px;}
    }

    .backtop{
      display:inline-flex;
      align-items:center;
      gap:10px;
      margin-top: 10px;
      color: var(--muted);
      text-decoration:none;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.02);
      transition: transform .15s ease, background .18s ease, border-color .18s ease;
    }
    .backtop:hover{
      background: rgba(125,211,252,.08);
      border-color: rgba(125,211,252,.22);
      transform: translateY(-1px);
    }

    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 18px clamp(16px, 2.8vw, 28px) 28px;
      color: var(--faint);
      font-size: 13px;
    }

    /* Print-friendly */
    @media print{
      body{background:#fff; color:#000;}
      header, section, nav.toc, figure{box-shadow:none;}
      nav.toc{position:relative; border:1px solid #bbb;}
      section, figure{break-inside: avoid; page-break-inside: avoid;}
      a{color:#000; text-decoration:none;}
      .eqbox{border-color:#666; background:#f6f6f6;}
      button.copy{display:none;}
      canvas{border:1px solid #666; background:#fff;}
    }
  </style>
</head>

<body>
  <header id="top">
    <div class="wrap">
      <h1>Combined SHG + SFG (Five-Wave Mixing): Coupled Equations, Numerical Solution, and Why a Second Wave Can Suppress SHG</h1>
      <p class="subtitle">
        Two fundamentals at angular frequencies <span class="muted">ω₁</span> and <span class="muted">ω₂</span> interact in a χ(2) medium together with their second harmonics (<span class="muted">2ω₁</span>, <span class="muted">2ω₂</span>) and the sum-frequency wave (<span class="muted">ω₁+ω₂</span>). With phase matching for all three processes, energy “competes” across channels—sometimes strongly reducing the SHG of one pump.
      </p>
    </div>
  </header>

  <main>
    <div class="layout">
      <nav class="toc" aria-label="Table of contents">
        <h2>Table of Contents</h2>
        <a href="#qs">Quick Summary</a>
        <a href="#p0">PART 0 — Concept Primer</a>
        <a href="#p1">PART 1 — Problem Analysis</a>
        <a href="#p2">PART 2 — Strategy &amp; Tips</a>
        <a href="#p3">PART 3 — Full Solution</a>
        <a href="#p4">PART 4 — Deeper Understanding</a>
        <a href="#p5">PART 5 — Optional Plot Guide</a>
        <div class="small">
          <div><span class="muted">Usability:</span> Copy buttons are provided for key equations and the final answer.</div>
          <div style="margin-top:6px;">This article uses plain-text equations (no MathJax).</div>
        </div>
      </nav>

      <article>
        <!-- Quick Summary -->
        <section id="qs">
          <h2>Quick Summary</h2>
          <ul>
            <li><strong>What this problem is about:</strong> simultaneous <span class="muted">SHG</span> (ω₁→2ω₁ and ω₂→2ω₂) and <span class="muted">SFG</span> (ω₁+ω₂→ω₁+ω₂) in a second-order nonlinear medium.</li>
            <li><strong>Key physics idea:</strong> with perfect phase matching, the nonlinear polarization coherently transfers energy; multiple channels can <em>compete</em> for the same pump photons.</li>
            <li><strong>Governing model:</strong> slowly-varying envelope approximation (SVEA) leading to <strong>five coupled complex ODEs</strong> for the wave envelopes.</li>
            <li><strong>What you must write:</strong> coupled equations for the five-wave mixing including back-conversion terms (complex conjugates).</li>
            <li><strong>What you must show numerically:</strong> solving the ODEs demonstrates that adding the ω₂ wave can reduce the generated 2ω₁ power—i.e., <strong>suppresses SHG of ω₁</strong>.</li>
            <li><strong>Result type:</strong> equations are <strong>symbolic</strong>; the demonstration is <strong>numerical</strong> using <em>example values</em> (clearly labeled) to produce one static plot.</li>
            <li><strong>Physical meaning:</strong> ω₁ photons can be diverted into the SFG channel (ω₁+ω₂) and/or altered by coupled dynamics, leaving fewer photons for ω₁+ω₁→2ω₁ conversion.</li>
          </ul>

          <div class="callouts">
            <div class="callout">
              <div class="tag"><span class="dot green"></span>Bottom line</div>
              <p>
                When ω₂ is present and SFG is phase matched, ω₁ is depleted by SFG in addition to SHG. This “competition”
                can significantly lower the 2ω₁ output compared with the ω₂=0 case.
              </p>
            </div>
            <div class="callout">
              <div class="tag"><span class="dot yellow"></span>What we will plot (example)</div>
              <p>
                A single static plot of <span class="muted">|A<sub>2ω₁</sub>(z)|²</span> versus propagation distance z:
                (i) only ω₁ present (pure SHG), (ii) both ω₁ and ω₂ present (combined SHG+SFG). The second curve lies lower.
              </p>
            </div>
          </div>

          <a class="backtop" href="#top">↑ Back to top</a>
        </section>

        <!-- PART 0 -->
        <section id="p0">
          <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

          <h3>0.1 Core definitions (symbols + SI units)</h3>
          <div class="grid2">
            <div class="card">
              <p><strong>Frequencies</strong></p>
              <ul class="muted">
                <li>ω₁, ω₂ (rad·s⁻¹): fundamental angular frequencies</li>
                <li>2ω₁, 2ω₂ (rad·s⁻¹): second-harmonic angular frequencies</li>
                <li>ω₃ = ω₁+ω₂ (rad·s⁻¹): sum-frequency angular frequency</li>
              </ul>
            </div>
            <div class="card">
              <p><strong>Waves and envelopes</strong></p>
              <ul class="muted">
                <li>E<sub>j</sub>(z,t) ≈ ½[A<sub>j</sub>(z) e<sup>i(k<sub>j</sub>z−ω<sub>j</sub>t)</sup> + c.c.] (V·m⁻¹)</li>
                <li>A<sub>j</sub>(z): complex slowly-varying envelope (V·m⁻¹ or a scaled unit)</li>
                <li>k<sub>j</sub> (m⁻¹): wave number at ω<sub>j</sub></li>
              </ul>
            </div>
          </div>

          <h3>0.2 Physical meaning of key quantities (intuition)</h3>
          <ul>
            <li><strong>χ(2) nonlinearity:</strong> creates a nonlinear polarization P<sup>(2)</sup> ∝ χ(2)E² that acts like a source term for new frequencies.</li>
            <li><strong>Phase matching (Δk≈0):</strong> ensures the generated wave stays in phase with its nonlinear source, allowing coherent buildup instead of oscillatory cancellation.</li>
            <li><strong>Coupled-wave envelopes:</strong> A(z) changes because energy is exchanged among waves; the complex phases matter (not just intensities).</li>
          </ul>

          <div class="callouts">
            <div class="callout">
              <div class="tag"><span class="dot purple"></span>Key law: SVEA coupled-wave equations</div>
              <p>
                Under SVEA and plane-wave/steady-state assumptions, Maxwell’s equations reduce to first-order ODEs:
                <span class="muted">dA/dz = i × (coupling) × (products of other envelopes)</span>.
                The products represent three-wave mixing driven by χ(2).
              </p>
            </div>
            <div class="callout">
              <div class="tag"><span class="dot red"></span>Validity conditions</div>
              <ul class="muted">
                <li>Slowly varying envelopes: |dA/dz| ≪ k|A|</li>
                <li>Quasi-monochromatic waves; negligible dispersion over bandwidth</li>
                <li>Plane-wave (or effective-area) approximation</li>
                <li>Lossless medium (or loss included separately if needed)</li>
              </ul>
            </div>
          </div>

          <h3>0.3 Common models/approximations (why used)</h3>
          <ul>
            <li><strong>Perfect phase matching:</strong> Δk=0 removes explicit z-dependent factors e<sup>iΔkz</sup>, highlighting pure coherent energy exchange.</li>
            <li><strong>Single polarization / scalar model:</strong> uses effective nonlinear coefficient d<sub>eff</sub> (embedded into coupling constants) instead of full tensor χ(2).</li>
            <li><strong>Normalized amplitudes:</strong> rescales envelopes so the equations become clean and Manley–Rowe relations are easy to state.</li>
          </ul>

          <h3>0.4 Mini intuition examples (minimal algebra)</h3>
          <div class="grid3">
            <div class="card">
              <p><strong>Example A: pure SHG</strong></p>
              <p class="muted">With only ω₁ present, energy oscillates between ω₁ and 2ω₁ (back-conversion is possible). Maximum conversion depends on phase and coupling strength.</p>
            </div>
            <div class="card">
              <p><strong>Example B: pure SFG</strong></p>
              <p class="muted">With ω₁ and ω₂ present, a new wave ω₁+ω₂ grows; the pumps can deplete if coupling is strong and phase matched.</p>
            </div>
            <div class="card">
              <p><strong>Example C: competition</strong></p>
              <p class="muted">If ω₁ is used simultaneously by SHG and SFG, the processes “compete” for ω₁ photons, often reducing the power available to either channel compared to the isolated case.</p>
            </div>
          </div>

          <h3>0.5 What to watch for (pitfalls)</h3>
          <ul>
            <li><strong>Forgetting complex conjugates:</strong> back-conversion requires terms like A*B, not just A².</li>
            <li><strong>Wrong frequency labeling:</strong> keep ω₃ = ω₁+ω₂ distinct from 2ω₁ and 2ω₂.</li>
            <li><strong>Ignoring normalization:</strong> coefficients (½ factors) depend on how amplitudes are defined. Be consistent, then check energy/photon invariants.</li>
            <li><strong>Assuming monotonic growth:</strong> in lossless, phase-matched χ(2) mixing, energy exchange can be oscillatory, not strictly increasing.</li>
          </ul>

          <details>
            <summary>Optional deeper note: where the coupled equations come from (conceptual)</summary>
            <p class="muted">
              You insert the multi-frequency ansatz for E(z,t) into Maxwell’s wave equation, compute the nonlinear polarization
              components P<sup>(2)</sup>(ω) produced by products of fields at other frequencies, then apply SVEA to reduce the
              second-order z-derivatives to first-order evolution in z. Each “allowed” three-wave interaction yields one product
              term in the envelope derivative.
            </p>
          </details>

          <a class="backtop" href="#top">↑ Back to top</a>
        </section>

        <!-- PART 1 -->
        <section id="p1">
          <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

          <h3>1.1 Restate the problem (in plain words)</h3>
          <p>
            We have five co-propagating waves in a χ(2) medium: fundamentals at ω₁ and ω₂, their second harmonics at 2ω₁ and 2ω₂,
            and a sum-frequency wave at ω₃=ω₁+ω₂. All three processes are simultaneously phase matched:
          </p>
          <ul class="muted">
            <li>SHG(1): ω₁+ω₁ ↔ 2ω₁</li>
            <li>SHG(2): ω₂+ω₂ ↔ 2ω₂</li>
            <li>SFG: ω₁+ω₂ ↔ ω₃</li>
          </ul>
          <p>
            Task: write the coupled-wave equations for this five-wave system, solve them numerically, and show that adding ω₂ can
            suppress SHG at 2ω₁.
          </p>

          <h3>1.2 Given quantities</h3>
          <ul>
            <li>Frequencies: ω₁, ω₂; generated frequencies: 2ω₁, 2ω₂, ω₃=ω₁+ω₂</li>
            <li>Assumption: phase matching satisfied for SHG(1), SHG(2), and SFG (Δk=0 for each)</li>
            <li>Medium: second-order nonlinear (effective coefficient absorbed into coupling constants)</li>
          </ul>

          <h3>1.3 Unknowns</h3>
          <ul>
            <li>Complex envelopes vs distance: A₁(z), A₂(z), A<sub>2ω₁</sub>(z), A<sub>2ω₂</sub>(z), A₃(z) where ω₃=ω₁+ω₂</li>
            <li>How the presence of A₂(0) changes the evolution of A<sub>2ω₁</sub>(z)</li>
          </ul>

          <h3>1.4 What must be found / proved</h3>
          <ul>
            <li>Write down coupled ODEs describing five-wave mixing (including back-conversion terms)</li>
            <li>Numerically integrate and demonstrate a case where <strong>|A<sub>2ω₁</sub>|²</strong> is smaller when ω₂ is present</li>
          </ul>

          <h3>1.5 Relevant principles (why they apply)</h3>
          <ul>
            <li><strong>Second-order nonlinear polarization:</strong> P<sup>(2)</sup> generates sum frequencies and harmonics because it contains products of electric fields.</li>
            <li><strong>Phase matching:</strong> makes coupling strongest; since it is assumed satisfied, we set Δk terms to zero.</li>
            <li><strong>Manley–Rowe relations:</strong> provide consistency checks (photon-number-like invariants) in a lossless medium.</li>
          </ul>

          <h3>1.6 Assumptions (explicit)</h3>
          <div class="callouts">
            <div class="callout">
              <div class="tag"><span class="dot"></span>Assumptions used</div>
              <ul class="muted">
                <li>Co-propagating plane waves; same z-axis</li>
                <li>Slowly varying envelopes (SVEA)</li>
                <li>Lossless, no walk-off, no group-velocity mismatch</li>
                <li>Perfect phase matching for SHG(1), SHG(2), SFG</li>
                <li>Single effective nonlinear coefficient in each channel (real couplings)</li>
              </ul>
            </div>
            <div class="callout">
              <div class="tag"><span class="dot yellow"></span>What we are not modeling</div>
              <ul class="muted">
                <li>Temporal pulse effects and dispersion</li>
                <li>Diffraction / finite beam size (effective area)</li>
                <li>Other χ(2) channels (e.g., DFG to |ω₁−ω₂|) unless specified</li>
              </ul>
            </div>
          </div>

          <h3>1.7 Possible approaches (compare 2–3)</h3>
          <div class="grid3">
            <div class="card">
              <p><strong>Approach 1: Full coupled-wave ODEs (best here)</strong></p>
              <p class="muted">Write the five coupled complex ODEs and integrate numerically. Captures depletion, back-conversion, and competition directly.</p>
              <p class="fine">Pros: faithful. Cons: needs numerics.</p>
            </div>
            <div class="card">
              <p><strong>Approach 2: Perturbative / undepleted pumps</strong></p>
              <p class="muted">Assume A₁, A₂ constant; solve linear equations for generated waves. Good for weak conversion but cannot show strong suppression by depletion.</p>
              <p class="fine">Pros: analytic. Cons: misses key effect.</p>
            </div>
            <div class="card">
              <p><strong>Approach 3: Manley–Rowe + phase analysis</strong></p>
              <p class="muted">Use invariants to bound conversion and interpret energy sharing. Helpful for insight but still needs ODEs to show trajectories.</p>
              <p class="fine">Pros: intuition. Cons: not a full solution alone.</p>
            </div>
          </div>
          <p><strong>Choice:</strong> We use <em>Approach 1</em> because the question explicitly asks for coupled equations and a numerical demonstration of suppression.</p>

          <a class="backtop" href="#top">↑ Back to top</a>
        </section>

        <!-- PART 2 -->
        <section id="p2">
          <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>

          <ol>
            <li><strong>Define the five envelopes</strong> for ω₁, ω₂, 2ω₁, 2ω₂, and ω₃=ω₁+ω₂. <span class="muted">Goal:</span> clear notation.</li>
            <li><strong>List the three phase-matched interactions</strong> (SHG1, SHG2, SFG). <span class="muted">Tool:</span> frequency bookkeeping.</li>
            <li><strong>Write envelope equations</strong> using the standard χ(2) form: each wave’s derivative equals i×(coupling)×(product of the other two waves involved). <span class="muted">Meaning:</span> nonlinear polarization drives growth/depletion.</li>
            <li><strong>Choose a consistent normalization</strong> (coupling constants, 1/2 factors). <span class="muted">Tool:</span> symmetry and Manley–Rowe checks.</li>
            <li><strong>State Manley–Rowe invariants</strong> to sanity-check numerics. <span class="muted">Meaning:</span> photon-number-like conservation.</li>
            <li><strong>Pick example initial conditions</strong> to compare: (A₂=0) vs (A₂≠0), with others initially zero. <span class="muted">Meaning:</span> isolate the effect of the second wave.</li>
            <li><strong>Numerically integrate</strong> the five complex ODEs (e.g., RK4) along z. <span class="muted">Outcome:</span> envelopes vs distance.</li>
            <li><strong>Plot one key curve</strong>: |A<sub>2ω₁</sub>(z)|² for both cases on one graph to demonstrate suppression.</li>
          </ol>

          <div class="callouts">
            <div class="callout">
              <div class="tag"><span class="dot red"></span>Common mistakes</div>
              <ul class="muted">
                <li>Dropping the conjugate terms in pump equations (kills back-conversion and violates invariants).</li>
                <li>Mixing up ω₃ with 2ω₁ or 2ω₂.</li>
                <li>Using inconsistent factors of 2 between SHG and SFG couplings.</li>
                <li>Interpreting “suppression” as loss—here it’s redistribution to other frequencies in a lossless model.</li>
              </ul>
            </div>
            <div class="callout">
              <div class="tag"><span class="dot green"></span>Quick sanity checks</div>
              <ul class="muted">
                <li>If ω₂=0, the system reduces to standard SHG for ω₁↔2ω₁.</li>
                <li>If ω₁=0, similarly for ω₂↔2ω₂.</li>
                <li>If SHG couplings are set to 0, you recover pure SFG equations.</li>
              </ul>
            </div>
          </div>

          <a class="backtop" href="#top">↑ Back to top</a>
        </section>

        <!-- PART 3 -->
        <section id="p3">
          <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

          <h3>3.1 Qualitative expectation (before calculating)</h3>
          <p>
            If only ω₁ is present, phase-matched SHG transfers energy from ω₁ into 2ω₁. If we now also launch ω₂, then ω₁ photons
            have an additional allowed pathway: ω₁+ω₂ → ω₃ (sum-frequency generation). Because the medium is lossless in our model,
            this does not “destroy” energy—it <em>diverts</em> energy from ω₁ into ω₃ (and possibly affects phases), leaving less ω₁
            available to drive ω₁+ω₁→2ω₁. Therefore we expect <strong>reduced 2ω₁ output</strong> for the same propagation length.
          </p>

          <h3>3.2 Define the five complex envelopes</h3>
          <p class="muted">
            Let the waves be labeled by their frequencies:
            <strong>ω₁</strong>, <strong>ω₂</strong>, <strong>2ω₁</strong>, <strong>2ω₂</strong>, and <strong>ω₃=ω₁+ω₂</strong>.
          </p>
          <div class="eqbox" role="group" aria-label="Envelope definitions">
<pre data-copy="E_j(z,t) ≈ (1/2)[ A_j(z) exp(i(k_j z − ω_j t)) + c.c. ],  j ∈ {1,2,2ω1,2ω2,3}
ω_3 = ω_1 + ω_2">
E_j(z,t) ≈ (1/2)[ A_j(z) exp(i(k_j z − ω_j t)) + c.c. ],  j ∈ {1,2,2ω1,2ω2,3}
ω_3 = ω_1 + ω_2
</pre>
            <div class="copyrow">
              <button class="copy" data-copy-btn>Copy equation (plain text)</button>
              <span class="copyhint">Copies the definition/notation block.</span>
            </div>
          </div>

          <h3>3.3 Phase matching conditions (given as satisfied)</h3>
          <p>
            The problem states phase matching is satisfied for both SHG processes and for SFG. In standard notation:
          </p>
          <div class="eqbox" role="group" aria-label="Phase matching equations">
<pre data-copy="Δk_SHG1 = k(2ω1) − 2k(ω1) = 0
Δk_SHG2 = k(2ω2) − 2k(ω2) = 0
Δk_SFG  = k(ω1+ω2) − k(ω1) − k(ω2) = 0">
Δk_SHG1 = k(2ω1) − 2k(ω1) = 0
Δk_SHG2 = k(2ω2) − 2k(ω2) = 0
Δk_SFG  = k(ω1+ω2) − k(ω1) − k(ω2) = 0
</pre>
            <div class="copyrow">
              <button class="copy" data-copy-btn>Copy equations (plain text)</button>
              <span class="copyhint">We will set exp(iΔkz)=1 because Δk=0.</span>
            </div>
          </div>

          <h3>3.4 Coupled-wave equations for the five-wave mixing</h3>
          <p>
            Each phase-matched χ(2) process is a three-wave interaction. The envelope derivative for each participating wave is
            proportional to the product of the other two envelopes. To keep the algebra clear and emphasize the physics, we write
            the equations in a widely used <strong>normalized</strong> form with real coupling constants κ₁, κ₂, κ₃ &gt; 0:
          </p>

          <div class="callouts">
            <div class="callout">
              <div class="tag"><span class="dot"></span>Notation</div>
              <ul class="muted">
                <li>A₁(z) ≡ envelope at ω₁</li>
                <li>A₂(z) ≡ envelope at ω₂</li>
                <li>B₁(z) ≡ envelope at 2ω₁</li>
                <li>B₂(z) ≡ envelope at 2ω₂</li>
                <li>C(z) ≡ envelope at ω₃=ω₁+ω₂</li>
              </ul>
            </div>
            <div class="callout">
              <div class="tag"><span class="dot green"></span>Couplings</div>
              <ul class="muted">
                <li>κ₁: SHG coupling for ω₁ ↔ 2ω₁</li>
                <li>κ₂: SHG coupling for ω₂ ↔ 2ω₂</li>
                <li>κ₃: SFG coupling for ω₁ + ω₂ ↔ ω₃</li>
              </ul>
            </div>
          </div>

          <div class="eqbox" role="group" aria-label="Coupled equations">
<pre data-copy="Five-wave coupled envelope equations (phase matched, lossless, normalized):

dA1/dz = i[ κ1 A1* B1  +  κ3 A2* C ]
dB1/dz = i[ κ1 (A1^2)/2 ]

dA2/dz = i[ κ2 A2* B2  +  κ3 A1* C ]
dB2/dz = i[ κ2 (A2^2)/2 ]

dC/dz  = i[ κ3 A1 A2 ]

(*) The * denotes complex conjugation.">
Five-wave coupled envelope equations (phase matched, lossless, normalized):

dA1/dz = i[ κ1 A1* B1  +  κ3 A2* C ]
dB1/dz = i[ κ1 (A1^2)/2 ]

dA2/dz = i[ κ2 A2* B2  +  κ3 A1* C ]
dB2/dz = i[ κ2 (A2^2)/2 ]

dC/dz  = i[ κ3 A1 A2 ]

(*) The * denotes complex conjugation.
</pre>
            <div class="copyrow">
              <button class="copy" data-copy-btn>Copy key equations (plain text)</button>
              <span class="copyhint">These are the requested coupled equations for SHG(1), SHG(2), and SFG together.</span>
            </div>
          </div>

          <h3>3.5 Why these terms appear (step-by-step interpretation)</h3>
          <ul>
            <li><strong>dB₁/dz ∝ A₁²:</strong> two ω₁ photons combine to source 2ω₁ (SHG forward generation).</li>
            <li><strong>dA₁/dz ∝ A₁*B₁:</strong> the reverse process 2ω₁ → ω₁+ω₁ (back-conversion) requires the complex conjugate of A₁.</li>
            <li><strong>dC/dz ∝ A₁A₂:</strong> one ω₁ and one ω₂ photon combine to source ω₃=ω₁+ω₂ (SFG generation).</li>
            <li><strong>dA₁/dz ∝ A₂* C and dA₂/dz ∝ A₁* C:</strong> reverse SFG (down-conversion) uses complex conjugates.</li>
            <li><strong>½ factors in dB/dz:</strong> arise from symmetric pairing of two identical photons; with this normalization the energy/photon invariants take a clean form.</li>
          </ul>

          <h3>3.6 Sanity checks (dimensions + limiting cases)</h3>
          <div class="grid2">
            <div class="card">
              <p><strong>Limiting cases</strong></p>
              <ul class="muted">
                <li>If A₂=0 and κ₃=0, you recover standard SHG: (A₁,B₁) only.</li>
                <li>If κ₁=κ₂=0, you recover pure SFG among (A₁,A₂,C).</li>
                <li>If κ₃=0, the two SHG processes are independent.</li>
              </ul>
            </div>
            <div class="card">
              <p><strong>Conservation intuition</strong></p>
              <p class="muted">
                In a lossless χ(2) medium, energy is redistributed among frequencies. When multiple phase-matched channels exist,
                ω₁ can be depleted into <em>either</em> 2ω₁ <em>or</em> ω₃, so SHG(1) can be reduced without any absorption.
              </p>
            </div>
          </div>

          <details>
            <summary>Optional deeper note: Manley–Rowe relations (useful invariants)</summary>
            <p class="muted">
              With a consistent amplitude normalization, lossless three-wave mixing yields invariants corresponding to
              conservation of “photon flux combinations.” For the combined system, you can form independent conserved quantities such as:
            </p>
            <div class="eqbox">
<pre data-copy="One convenient set of invariants (conceptual form):

N1 + 2N(2ω1) + N3 = const
N2 + 2N(2ω2) + N3 = const

where Nj ∝ |Aj|^2 (up to normalization) and N3 corresponds to ω3=ω1+ω2.

These express that creating one ω3 photon consumes one ω1 and one ω2 photon,
and creating one 2ω1 photon consumes two ω1 photons (similarly for ω2).">
One convenient set of invariants (conceptual form):

N1 + 2N(2ω1) + N3 = const
N2 + 2N(2ω2) + N3 = const

where Nj ∝ |Aj|^2 (up to normalization) and N3 corresponds to ω3=ω1+ω2.

These express that creating one ω3 photon consumes one ω1 and one ω2 photon,
and creating one 2ω1 photon consumes two ω1 photons (similarly for ω2).
</pre>
              <div class="copyrow">
                <button class="copy" data-copy-btn>Copy (plain text)</button>
                <span class="copyhint">These are used as consistency checks on numerics.</span>
              </div>
            </div>
          </details>

          <h3>3.7 Numerical demonstration (example values)</h3>
          <p>
            The problem asks for a numerical solution and a demonstration of suppression. Since no numerical parameters are provided,
            we choose <strong>example values</strong> purely to illustrate the effect (the qualitative conclusion is general whenever SFG significantly depletes ω₁).
          </p>

          <div class="callouts">
            <div class="callout">
              <div class="tag"><span class="dot yellow"></span>Example values used (only for the plot)</div>
              <ul class="muted">
                <li>κ₁ = κ₂ = κ₃ = 1 (normalized couplings)</li>
                <li>Initial conditions (Case A: SHG only): A₁(0)=1, A₂(0)=0, B₁(0)=B₂(0)=C(0)=0</li>
                <li>Initial conditions (Case B: SHG + SFG): A₁(0)=1, A₂(0)=1, B₁(0)=B₂(0)=C(0)=0</li>
                <li>Integrate from z=0 to z=6 (normalized length units)</li>
              </ul>
            </div>
            <div class="callout">
              <div class="tag"><span class="dot green"></span>What “suppression” means here</div>
              <p class="muted">
                We compare the generated 2ω₁ intensity proxy |B₁(z)|² between the two cases.
                If the Case B curve is lower, then launching ω₂ suppresses SHG of ω₁ by diverting ω₁ into ω₃ (and related dynamics).
              </p>
            </div>
          </div>

          <figure aria-label="Static plot showing suppression of SHG by second wave">
            <div class="canvasWrap">
              <canvas id="plot" width="900" height="420"></canvas>
            </div>
            <figcaption>
              <strong>Static plot (computed once on page load):</strong>
              example numerical integration of the coupled equations showing <span class="muted">|B₁(z)|² = |A<sub>2ω₁</sub>(z)|²</span>
              for two cases. The presence of ω₂ opens SFG to ω₃, reducing the maximum 2ω₁ conversion.
            </figcaption>
          </figure>

          <h3>3.8 Final answer (what you would submit)</h3>
          <div class="eqbox" role="group" aria-label="Final answer block">
<pre data-copy="FINAL ANSWER (plain text):

Let A1(z), A2(z) be the complex envelopes at ω1, ω2; let B1(z), B2(z) be the envelopes at 2ω1, 2ω2; and let C(z) be the envelope at ω3=ω1+ω2. With perfect phase matching for SHG(1), SHG(2), and SFG, a standard lossless SVEA normalized model is:

dA1/dz = i[ κ1 A1* B1 + κ3 A2* C ]
dB1/dz = i[ κ1 (A1^2)/2 ]

dA2/dz = i[ κ2 A2* B2 + κ3 A1* C ]
dB2/dz = i[ κ2 (A2^2)/2 ]

dC/dz  = i[ κ3 A1 A2 ]

(κ1, κ2, κ3 are real couplings; * denotes complex conjugation.)

Numerical integration (example: κ1=κ2=κ3=1, A1(0)=1, B1(0)=0; compare A2(0)=0 vs A2(0)=1 with B2(0)=C(0)=0) shows that |B1(z)|^2 is substantially smaller when ω2 is present, demonstrating that the second wave can suppress SHG of ω1 via competing SFG (ω1+ω2→ω3) that depletes A1.">
FINAL ANSWER (plain text):

Let A1(z), A2(z) be the complex envelopes at ω1, ω2; let B1(z), B2(z) be the envelopes at 2ω1, 2ω2; and let C(z) be the envelope at ω3=ω1+ω2. With perfect phase matching for SHG(1), SHG(2), and SFG, a standard lossless SVEA normalized model is:

dA1/dz = i[ κ1 A1* B1 + κ3 A2* C ]
dB1/dz = i[ κ1 (A1^2)/2 ]

dA2/dz = i[ κ2 A2* B2 + κ3 A1* C ]
dB2/dz = i[ κ2 (A2^2)/2 ]

dC/dz  = i[ κ3 A1 A2 ]

(κ1, κ2, κ3 are real couplings; * denotes complex conjugation.)

Numerical integration (example: κ1=κ2=κ3=1, A1(0)=1, B1(0)=0; compare A2(0)=0 vs A2(0)=1 with B2(0)=C(0)=0) shows that |B1(z)|^2 is substantially smaller when ω2 is present, demonstrating that the second wave can suppress SHG of ω1 via competing SFG (ω1+ω2→ω3) that depletes A1.
</pre>
            <div class="copyrow">
              <button class="copy" data-copy-btn>Copy final answer (plain text)</button>
              <span class="copyhint">Ready to paste into a homework/notes submission.</span>
            </div>
          </div>

          <a class="backtop" href="#top">↑ Back to top</a>
        </section>

        <!-- PART 4 -->
        <section id="p4">
          <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

          <h3>4.1 Re-interpreting the equations: what each term controls</h3>
          <ul>
            <li><strong>κ₁ term in dA₁/dz and dB₁/dz:</strong> sets how strongly ω₁ couples to its second harmonic 2ω₁ (SHG channel).</li>
            <li><strong>κ₃ term in dA₁/dz, dA₂/dz, dC/dz:</strong> sets how strongly ω₁ and ω₂ combine to produce ω₃ (SFG channel).</li>
            <li><strong>Complex conjugates:</strong> encode phase-sensitive back-action; they are why conversion can reverse and oscillate.</li>
          </ul>

          <h3>4.2 Why ω₂ can suppress SHG of ω₁ (mechanism)</h3>
          <p>
            In the ω₂=0 case, ω₁ has essentially one available nonlinear “escape route”: conversion to 2ω₁ (plus possible back-conversion).
            When ω₂ is present and SFG is phase matched, ω₁ now has an additional coherent pathway:
          </p>
          <div class="eqbox">
<pre data-copy="Competing pathways that consume ω1 photons:

SHG(1):  ω1 + ω1  →  2ω1     (rate set by κ1 and A1^2)
SFG:     ω1 + ω2  →  ω3      (rate set by κ3 and A1 A2)">
Competing pathways that consume ω1 photons:

SHG(1):  ω1 + ω1  →  2ω1     (rate set by κ1 and A1^2)
SFG:     ω1 + ω2  →  ω3      (rate set by κ3 and A1 A2)
</pre>
              <div class="copyrow">
                <button class="copy" data-copy-btn>Copy (plain text)</button>
                <span class="copyhint">This is the key physical “competition” statement.</span>
              </div>
          </div>
          <p>
            If κ₃|A₂| is comparable to or larger than κ₁|A₁|, the SFG channel can drain ω₁ rapidly into ω₃, reducing ω₁’s ability to
            drive the quadratic SHG source term A₁². That is the core reason the 2ω₁ output can drop.
          </p>

          <h3>4.3 Parameter dependence (qualitative)</h3>
          <ul>
            <li><strong>Increase κ₃ (stronger SFG):</strong> more diversion of ω₁ into ω₃ → stronger suppression of 2ω₁ in many regimes.</li>
            <li><strong>Increase initial A₂(0):</strong> boosts the SFG drive term A₁A₂ → faster depletion of ω₁ → reduced SHG of ω₁.</li>
            <li><strong>Increase κ₁ (stronger SHG):</strong> SHG competes better; suppression may weaken if SHG dominates.</li>
            <li><strong>Initial relative phases:</strong> because the equations are phase sensitive, phases can shift where/when conversion peaks occur (oscillatory exchange).</li>
          </ul>

          <h3>4.4 Alternative derivation idea (brief but meaningful)</h3>
          <p class="muted">
            Instead of writing the equations directly, you can derive them from an interaction Hamiltonian (three-wave mixing)
            with terms like â<sub>2ω₁</sub>â<sub>ω₁</sub><sup>†</sup>â<sub>ω₁</sub><sup>†</sup>, â<sub>ω₃</sub>â<sub>ω₁</sub><sup>†</sup>â<sub>ω₂</sub><sup>†</sup>, then take classical limits
            (replace operators by complex amplitudes). This approach automatically encodes the conjugate/back-conversion structure.
          </p>

          <h3>4.5 Concept checks (self-test, with answers)</h3>
          <ul>
            <li><strong>Q:</strong> If Δk≠0, do you still expect strong suppression? <strong>A:</strong> Not necessarily—phase mismatch reduces coherent buildup; competition weakens because conversion efficiencies drop.</li>
            <li><strong>Q:</strong> Why can |B₁|² oscillate instead of growing forever? <strong>A:</strong> Because in a lossless coherent system, back-conversion terms allow energy to flow back to the pumps.</li>
            <li><strong>Q:</strong> Is suppression “loss”? <strong>A:</strong> No—energy is redistributed, often into ω₃ (and potentially 2ω₂), not dissipated.</li>
            <li><strong>Q:</strong> What term directly generates ω₃? <strong>A:</strong> dC/dz = i κ₃ A₁ A₂ (under phase matching).</li>
          </ul>

          <a class="backtop" href="#top">↑ Back to top</a>
        </section>

        <!-- PART 5 -->
        <section id="p5">
          <h2>PART 5 — Optional Plot Guide</h2>

          <h3>What the plot shows (and why it’s useful)</h3>
          <p>
            The plot overlays <span class="muted">|B₁(z)|² = |A<sub>2ω₁</sub>(z)|²</span> for two scenarios:
            <strong>Case A</strong> (only ω₁ launched) and <strong>Case B</strong> (ω₁ and ω₂ launched). This directly visualizes the requested claim:
            the ω₂ wave can <em>suppress</em> the SHG output at 2ω₁ by enabling SFG.
          </p>

          <h3>Axes, units, and example parameters</h3>
          <ul class="muted">
            <li><strong>x-axis:</strong> propagation distance z (normalized units)</li>
            <li><strong>y-axis:</strong> |B₁|² (normalized intensity/power proxy at 2ω₁)</li>
            <li><strong>Example values (only for plot):</strong> κ₁=κ₂=κ₃=1; A₁(0)=1; compare A₂(0)=0 vs A₂(0)=1; others start at 0.</li>
          </ul>

          <h3>What features to notice</h3>
          <ul>
            <li><strong>Peak reduction:</strong> the maximum |B₁|² is lower when ω₂ is present.</li>
            <li><strong>Oscillations:</strong> both curves can oscillate because of coherent back-conversion in a lossless medium.</li>
            <li><strong>Interpretation:</strong> the missing 2ω₁ power is largely redirected into ω₃ (SFG) and related coupled dynamics.</li>
          </ul>

          <a class="backtop" href="#top">↑ Back to top</a>
        </section>
      </article>
    </div>
  </main>

  <footer>
    <div>
      <strong>Note:</strong> The numerical plot uses example normalized parameters because the problem statement provides no material constants or input powers.
      The qualitative suppression effect is general whenever the SFG channel significantly depletes ω₁ under phase matching.
    </div>
  </footer>

  <script>
    (function(){
      "use strict";

      // ---------- Copy buttons ----------
      function findCopyText(btn){
        const box = btn.closest(".eqbox");
        if(!box) return "";
        const pre = box.querySelector("pre[data-copy]");
        return pre ? pre.getAttribute("data-copy") : (pre ? pre.textContent : "");
      }
      async function copyToClipboard(text){
        try{
          await navigator.clipboard.writeText(text);
          return true;
        }catch(e){
          // Fallback
          const ta = document.createElement("textarea");
          ta.value = text;
          ta.style.position = "fixed";
          ta.style.left = "-9999px";
          ta.style.top = "0";
          document.body.appendChild(ta);
          ta.focus();
          ta.select();
          let ok = false;
          try{ ok = document.execCommand("copy"); }catch(_){ ok = false; }
          document.body.removeChild(ta);
          return ok;
        }
      }
      document.addEventListener("click", async (ev)=>{
        const btn = ev.target.closest("button[data-copy-btn]");
        if(!btn) return;
        const txt = findCopyText(btn);
        if(!txt) return;
        const ok = await copyToClipboard(txt);
        const old = btn.textContent;
        btn.textContent = ok ? "Copied!" : "Copy failed";
        btn.disabled = true;
        setTimeout(()=>{ btn.textContent = old; btn.disabled = false; }, 900);
      });

      // ---------- Complex arithmetic helpers ----------
      function C(re, im){ return {re: re, im: im}; }
      function cAdd(a,b){ return {re:a.re+b.re, im:a.im+b.im}; }
      function cSub(a,b){ return {re:a.re-b.re, im:a.im-b.im}; }
      function cMul(a,b){ return {re:a.re*b.re - a.im*b.im, im:a.re*b.im + a.im*b.re}; }
      function cScale(a,s){ return {re:a.re*s, im:a.im*s}; }
      function cConj(a){ return {re:a.re, im:-a.im}; }
      function cAbs2(a){ return a.re*a.re + a.im*a.im; }

      // ---------- ODE system (phase matched, normalized) ----------
      // y = [A1, B1, A2, B2, C] each complex
      function deriv(y, k1, k2, k3){
        const A1 = y[0], B1 = y[1], A2 = y[2], B2 = y[3], CC = y[4];

        // dA1/dz = i[ k1 A1* B1 + k3 A2* C ]
        const termA1 = cAdd(
          cScale(cMul(cConj(A1), B1), k1),
          cScale(cMul(cConj(A2), CC), k3)
        );
        const dA1 = cMul(C(0,1), termA1);

        // dB1/dz = i[ k1 (A1^2)/2 ]
        const dB1 = cMul(C(0,1), cScale(cMul(A1, A1), k1*0.5));

        // dA2/dz = i[ k2 A2* B2 + k3 A1* C ]
        const termA2 = cAdd(
          cScale(cMul(cConj(A2), B2), k2),
          cScale(cMul(cConj(A1), CC), k3)
        );
        const dA2 = cMul(C(0,1), termA2);

        // dB2/dz = i[ k2 (A2^2)/2 ]
        const dB2 = cMul(C(0,1), cScale(cMul(A2, A2), k2*0.5));

        // dC/dz = i[ k3 A1 A2 ]
        const dC = cMul(C(0,1), cScale(cMul(A1, A2), k3));

        return [dA1, dB1, dA2, dB2, dC];
      }

      // RK4 integrator
      function rk4Integrate(z0, z1, nSteps, y0, k1, k2, k3){
        const h = (z1 - z0) / nSteps;
        const zs = new Array(nSteps+1);
        const ys = new Array(nSteps+1);

        // deep copy y0
        let y = y0.map(v=>C(v.re, v.im));
        zs[0] = z0;
        ys[0] = y.map(v=>C(v.re, v.im));

        for(let i=0;i<nSteps;i++){
          const z = z0 + i*h;

          const k_1 = deriv(y, k1, k2, k3);

          const y2 = y.map((v,idx)=> cAdd(v, cScale(k_1[idx], h*0.5)));
          const k_2 = deriv(y2, k1, k2, k3);

          const y3 = y.map((v,idx)=> cAdd(v, cScale(k_2[idx], h*0.5)));
          const k_3 = deriv(y3, k1, k2, k3);

          const y4 = y.map((v,idx)=> cAdd(v, cScale(k_3[idx], h)));
          const k_4 = deriv(y4, k1, k2, k3);

          y = y.map((v,idx)=>{
            const sum = cAdd(
              cAdd(k_1[idx], cScale(k_2[idx], 2)),
              cAdd(cScale(k_3[idx], 2), k_4[idx])
            );
            return cAdd(v, cScale(sum, h/6));
          });

          zs[i+1] = z + h;
          ys[i+1] = y.map(v=>C(v.re, v.im));
        }
        return {zs, ys};
      }

      // ---------- Plot (single static canvas) ----------
      const canvas = document.getElementById("plot");
      const ctx = canvas.getContext("2d");

      function draw(){
        if(!canvas || !ctx) return;

        // Responsive + high-DPI
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        const cssW = canvas.clientWidth;
        const cssH = canvas.clientHeight;
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);

        // ----- Compute example data (once per draw; still non-interactive) -----
        const k1 = 1, k2 = 1, k3 = 1;
        const zStart = 0, zEnd = 6;
        const steps = 2400;

        // Case A: only ω1
        const y0A = [C(1,0), C(0,0), C(0,0), C(0,0), C(0,0)];
        const solA = rk4Integrate(zStart, zEnd, steps, y0A, k1, k2, k3);

        // Case B: ω1 and ω2
        const y0B = [C(1,0), C(0,0), C(1,0), C(0,0), C(0,0)];
        const solB = rk4Integrate(zStart, zEnd, steps, y0B, k1, k2, k3);

        // Extract |B1|^2
        const x = solA.zs;
        const yA = solA.ys.map(v => cAbs2(v[1]));
        const yB = solB.ys.map(v => cAbs2(v[1]));

        // Determine y-range (pad slightly)
        let yMax = 0;
        for(let i=0;i<yA.length;i++){
          if(yA[i] > yMax) yMax = yA[i];
          if(yB[i] > yMax) yMax = yB[i];
        }
        yMax = Math.max(0.05, yMax * 1.10);
        const yMin = 0;

        // ----- Drawing utilities -----
        const W = cssW, H = cssH;
        const padL = 62, padR = 18, padT = 44, padB = 54;
        const plotW = W - padL - padR;
        const plotH = H - padT - padB;

        function X(z){ return padL + (z - zStart) * (plotW / (zEnd - zStart)); }
        function Y(v){ return padT + (yMax - v) * (plotH / (yMax - yMin)); }

        // Clear
        ctx.clearRect(0,0,W,H);

        // Background panel
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.18)";
        roundRect(ctx, 10, 10, W-20, H-20, 16);
        ctx.fill();
        ctx.restore();

        // Title
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.font = "700 14px " + getUIFont();
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillText("Example: Suppression of SHG at 2ω₁ by adding ω₂ (phase matched, normalized)", padL, 14);
        ctx.restore();

        // Grid + axes
        const xTicks = 6;  // 0..6
        const yTicks = 5;

        ctx.save();
        ctx.lineWidth = 1;
        // Gridlines
        for(let i=0;i<=xTicks;i++){
          const z = zStart + (zEnd - zStart) * (i/xTicks);
          const xx = X(z);
          ctx.strokeStyle = "rgba(255,255,255,0.10)";
          ctx.beginPath(); ctx.moveTo(xx, padT); ctx.lineTo(xx, padT+plotH); ctx.stroke();
        }
        for(let j=0;j<=yTicks;j++){
          const v = yMin + (yMax - yMin) * (j/yTicks);
          const yy = Y(v);
          ctx.strokeStyle = "rgba(255,255,255,0.10)";
          ctx.beginPath(); ctx.moveTo(padL, yy); ctx.lineTo(padL+plotW, yy); ctx.stroke();
        }

        // Axes
        ctx.strokeStyle = "rgba(255,255,255,0.35)";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(padL, padT);
        ctx.lineTo(padL, padT+plotH);
        ctx.lineTo(padL+plotW, padT+plotH);
        ctx.stroke();

        // Tick labels
        ctx.fillStyle = "rgba(255,255,255,0.78)";
        ctx.font = "12px " + getUIFont();
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        for(let i=0;i<=xTicks;i++){
          const z = zStart + (zEnd - zStart) * (i/xTicks);
          const xx = X(z);
          const yy = padT + plotH + 8;
          ctx.fillText(z.toFixed(0), xx, yy);
        }
        ctx.textAlign = "right";
        ctx.textBaseline = "middle";
        for(let j=0;j<=yTicks;j++){
          const v = yMin + (yMax - yMin) * (j/yTicks);
          const yy = Y(v);
          ctx.fillText(v.toFixed(2), padL - 10, yy);
        }

        // Axis labels
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        ctx.font = "600 13px " + getUIFont();
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.fillText("Propagation distance  z  (normalized units)", padL + plotW/2, H - 16);
        ctx.translate(18, padT + plotH/2);
        ctx.rotate(-Math.PI/2);
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillText("|A₂ω₁(z)|²  (normalized intensity proxy)", 0, 0);
        ctx.restore();

        // Curves
        // Case A: brighter cyan
        drawCurve(x, yA, "rgba(125,211,252,0.92)", 2.2);
        // Case B: purple
        drawCurve(x, yB, "rgba(167,139,250,0.92)", 2.2);

        // Legend
        drawLegend([
          {label:"Case A: A₂(0)=0 (only SHG of ω₁)", color:"rgba(125,211,252,0.92)"},
          {label:"Case B: A₂(0)=1 (SHG + SFG competing)", color:"rgba(167,139,250,0.92)"}
        ]);

        // Annotation: peak values
        const peakA = maxOf(yA);
        const peakB = maxOf(yB);
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.78)";
        ctx.font = "12px " + getUIFont();
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillText("Peak |A₂ω₁|² (Case A) ≈ " + peakA.toFixed(3), padL, padT - 24);
        ctx.fillText("Peak |A₂ω₁|² (Case B) ≈ " + peakB.toFixed(3) + "  (suppressed)", padL + 220, padT - 24);
        ctx.restore();

        // Helpers
        function drawCurve(xArr, yArr, strokeStyle, lineW){
          ctx.save();
          ctx.strokeStyle = strokeStyle;
          ctx.lineWidth = lineW;
          ctx.lineJoin = "round";
          ctx.lineCap = "round";
          ctx.beginPath();
          for(let i=0;i<xArr.length;i++){
            const xx = X(xArr[i]);
            const yy = Y(yArr[i]);
            if(i===0) ctx.moveTo(xx,yy);
            else ctx.lineTo(xx,yy);
          }
          ctx.stroke();
          ctx.restore();
        }

        function drawLegend(items){
          const boxW = Math.min(540, plotW);
          const boxH = 52;
          const x0 = padL + plotW - boxW;
          const y0 = padT + 10;
          ctx.save();
          ctx.fillStyle = "rgba(0,0,0,0.25)";
          ctx.strokeStyle = "rgba(255,255,255,0.16)";
          ctx.lineWidth = 1;
          roundRect(ctx, x0, y0, boxW, boxH, 14);
          ctx.fill();
          ctx.stroke();

          ctx.font = "12px " + getUIFont();
          ctx.textAlign = "left";
          ctx.textBaseline = "middle";
          let yy = y0 + 18;
          for(const it of items){
            ctx.strokeStyle = it.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x0+14, yy);
            ctx.lineTo(x0+42, yy);
            ctx.stroke();

            ctx.fillStyle = "rgba(255,255,255,0.82)";
            ctx.fillText(it.label, x0+52, yy);
            yy += 18;
          }
          ctx.restore();
        }

        function maxOf(arr){
          let m = -Infinity;
          for(let i=0;i<arr.length;i++) if(arr[i] > m) m = arr[i];
          return m;
        }
      }

      function roundRect(c,x,y,w,h,r){
        const rr = Math.min(r, w/2, h/2);
        c.beginPath();
        c.moveTo(x+rr,y);
        c.arcTo(x+w,y,x+w,y+h,rr);
        c.arcTo(x+w,y+h,x,y+h,rr);
        c.arcTo(x,y+h,x,y,rr);
        c.arcTo(x,y,x+w,y,rr);
        c.closePath();
      }

      function getUIFont(){
        return "ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      }

      // Initial draw + redraw on resize (still static; no user controls)
      let raf = null;
      function scheduleDraw(){
        if(raf) cancelAnimationFrame(raf);
        raf = requestAnimationFrame(draw);
      }
      window.addEventListener("resize", scheduleDraw, {passive:true});
      scheduleDraw();
    })();
  </script>
</body>
</html>
