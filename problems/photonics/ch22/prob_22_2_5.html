<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Matching Conditions for Three-Wave Mixing in a Dispersive Medium (n(λ0) ≈ n0 − ξλ0)</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1a2e;
      --panel2:#0c1628;
      --text:#eaf0ff;
      --muted:#b8c3e6;
      --faint:#7f8ab3;
      --accent:#7cf3c2;
      --accent2:#7aa7ff;
      --warn:#ffcf5a;
      --danger:#ff6b8a;
      --ok:#5ef0ff;
      --border:rgba(255,255,255,.12);
      --shadow: 0 14px 45px rgba(0,0,0,.38);
      --radius:18px;
      --radius2:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      background:
        radial-gradient(1200px 700px at 10% 5%, rgba(122,167,255,.18), transparent 60%),
        radial-gradient(900px 600px at 90% 20%, rgba(124,243,194,.12), transparent 55%),
        radial-gradient(1200px 800px at 40% 120%, rgba(255,107,138,.10), transparent 60%),
        var(--bg);
      color:var(--text);
      font-family:var(--sans);
      line-height:1.55;
    }

    a{color:inherit}
    .wrap{
      max-width:1180px;
      margin:0 auto;
      padding:28px 18px 70px;
    }

    header{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius: var(--radius);
      padding:22px 20px;
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    header:before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(600px 240px at 15% 0%, rgba(124,243,194,.18), transparent 60%),
        radial-gradient(700px 260px at 85% 10%, rgba(122,167,255,.20), transparent 62%);
      opacity:.75;
      filter: blur(0px);
      pointer-events:none;
    }
    header > *{position:relative}

    h1{
      font-size: clamp(1.25rem, 2.2vw, 1.9rem);
      margin:0 0 10px;
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      margin:0;
      max-width: 75ch;
    }

    .grid{
      display:grid;
      grid-template-columns: 330px 1fr;
      gap:18px;
      margin-top:18px;
      align-items:start;
    }

    nav.toc{
      position:sticky;
      top:16px;
      border:1px solid var(--border);
      border-radius: var(--radius);
      background: rgba(15,26,46,.72);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 34px rgba(0,0,0,.28);
      overflow:hidden;
    }
    .toc-head{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .toc-title{
      font-weight:700;
      letter-spacing:.2px;
      font-size:.98rem;
      margin:0;
    }
    .toc small{color:var(--faint)}
    .toc a{
      display:block;
      padding:10px 14px;
      text-decoration:none;
      color:var(--muted);
      border-left: 3px solid transparent;
      transition: transform .12s ease, background .12s ease, color .12s ease, border-color .12s ease;
    }
    .toc a:hover{
      background: rgba(255,255,255,.05);
      color:var(--text);
      transform: translateX(2px);
      border-left-color: rgba(124,243,194,.55);
    }
    .toc a.active{
      background: rgba(124,243,194,.09);
      color: var(--text);
      border-left-color: var(--accent);
    }

    main{
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    section{
      border:1px solid var(--border);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      box-shadow: 0 10px 34px rgba(0,0,0,.22);
      overflow:hidden;
    }
    section > .sec{
      padding:18px 18px 16px;
    }
    h2{
      margin:0 0 10px;
      font-size:1.22rem;
      letter-spacing:.2px;
    }
    h3{
      margin:16px 0 8px;
      font-size:1.06rem;
      color: var(--text);
    }

    p{margin:10px 0; color: var(--muted)}
    ul{margin:10px 0 0 20px; color: var(--muted)}
    li{margin:6px 0}
    .kicker{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:6px 10px;
      border:1px solid var(--border);
      border-radius: 999px;
      background: rgba(0,0,0,.18);
      color: var(--muted);
      font-size:.86rem;
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(124,243,194,.12);
    }

    .callouts{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:12px;
      margin-top:12px;
    }
    .card{
      grid-column: span 12;
      border:1px solid var(--border);
      border-radius: var(--radius2);
      background: rgba(12,22,40,.62);
      padding:12px 12px;
    }
    .card strong{color: var(--text)}
    .card p{margin:6px 0 0}
    .card .tag{
      display:inline-block;
      font-size:.78rem;
      letter-spacing:.25px;
      padding:4px 8px;
      border-radius: 999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      color: var(--muted);
      margin-bottom:8px;
    }
    .assump{border-left: 4px solid rgba(122,167,255,.9)}
    .eqs{border-left: 4px solid rgba(124,243,194,.9)}
    .mist{border-left: 4px solid rgba(255,207,90,.95)}
    .final{border-left: 4px solid rgba(94,240,255,.95)}
    .warn{border-left: 4px solid rgba(255,107,138,.95)}

    @media (min-width: 920px){
      .card.half{grid-column: span 6;}
      .card.third{grid-column: span 4;}
    }

    pre, code{
      font-family: var(--mono);
      font-size: .94rem;
      line-height:1.45;
    }
    code{
      background: rgba(255,255,255,.06);
      border:1px solid var(--border);
      padding:2px 6px;
      border-radius: 8px;
      color: var(--text);
      white-space: nowrap;
    }
    pre{
      margin:10px 0 0;
      padding:12px 12px;
      background: rgba(0,0,0,.22);
      border:1px solid var(--border);
      border-radius: 14px;
      overflow:auto;
      color: var(--text);
    }

    .eqblock{
      position:relative;
      margin-top:10px;
    }
    .copybtn{
      position:absolute;
      top:10px;
      right:10px;
      font-size:.82rem;
      border:1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 10px;
      padding:7px 10px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease;
    }
    .copybtn:hover{transform: translateY(-1px); background: rgba(255,255,255,.10)}
    .copybtn:active{transform: translateY(0px) scale(.98)}
    .copyhint{
      display:none;
      position:absolute;
      top:10px;
      right:98px;
      font-size:.78rem;
      color: var(--muted);
      padding:6px 10px;
      border:1px solid var(--border);
      border-radius: 999px;
      background: rgba(0,0,0,.28);
    }

    details{
      border:1px solid var(--border);
      border-radius: 14px;
      background: rgba(255,255,255,.03);
      padding:10px 12px;
      margin-top:12px;
    }
    summary{
      cursor:pointer;
      color: var(--text);
      font-weight:650;
      letter-spacing:.15px;
      list-style:none;
    }
    summary::-webkit-details-marker{display:none}
    summary:before{
      content:"▸";
      display:inline-block;
      margin-right:10px;
      color: var(--accent);
      transform: translateY(-1px);
      transition: transform .15s ease;
    }
    details[open] summary:before{transform: rotate(90deg) translateX(2px)}

    figure{
      margin:12px 0 0;
      border:1px solid var(--border);
      border-radius: var(--radius2);
      background: rgba(0,0,0,.18);
      overflow:hidden;
    }
    figcaption{
      padding:10px 12px;
      color: var(--muted);
      border-top:1px solid var(--border);
      font-size:.92rem;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
    }

    .backtop{
      display:inline-flex;
      align-items:center;
      gap:8px;
      margin-top:10px;
      text-decoration:none;
      color: var(--muted);
      border:1px solid var(--border);
      border-radius: 999px;
      padding:8px 12px;
      background: rgba(255,255,255,.04);
      transition: transform .12s ease, background .12s ease, color .12s ease;
    }
    .backtop:hover{transform: translateY(-1px); background: rgba(255,255,255,.08); color: var(--text)}

    footer{
      margin-top:18px;
      color: var(--faint);
      font-size:.92rem;
      padding:16px 4px 0;
    }

    /* Print */
    @media print{
      :root{--bg:#fff; --text:#111; --muted:#222; --faint:#444; --border:#bbb;}
      body{background:#fff}
      header, section, nav.toc{box-shadow:none; background:#fff}
      nav.toc{display:none}
      .grid{grid-template-columns: 1fr}
      a.backtop{display:none}
      .copybtn, .copyhint{display:none !important}
      code, pre{border:1px solid #bbb; background:#f6f6f6; color:#111}
      section{break-inside:avoid; page-break-inside:avoid}
      h2{page-break-after:avoid}
    }

    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr}
      nav.toc{position:relative; top:auto}
    }
  </style>
</head>
<body>
  <div id="top" class="wrap">
    <header>
      <div class="kicker" aria-label="topic tag">
        <span class="dot" aria-hidden="true"></span>
        <span><strong>Nonlinear Optics</strong> • χ(2) three-wave mixing • phase matching with dispersion</span>
      </div>
      <h1>Matching Conditions for Three-Wave Mixing in a Dispersive Medium</h1>
      <p class="subtitle">
        Given a simple (but revealing) dispersive model <code>n(λ0) ≈ n0 − ξ λ0</code>, we prove that
        three <em>co-propagating</em> waves cannot be efficiently coupled by a second-order (χ(2)) process,
        and then show how allowing one wave to travel backward can restore phase matching.
      </p>
    </header>

    <div class="grid">
      <nav class="toc" aria-label="Table of contents">
        <div class="toc-head">
          <div>
            <p class="toc-title">Table of Contents</p>
            <small>Sticky • click to jump</small>
          </div>
          <small id="tocProg" title="Scroll progress">0%</small>
        </div>
        <a href="#quick">Quick Summary</a>
        <a href="#primer">PART 0 — Concept Primer</a>
        <a href="#analysis">PART 1 — Problem Analysis</a>
        <a href="#strategy">PART 2 — Strategy & Tips</a>
        <a href="#solution">PART 3 — Full Solution</a>
        <a href="#deeper">PART 4 — Deeper Understanding</a>
        <a href="#plot">PART 5 — Optional Plot Guide</a>
      </nav>

      <main>
        <section id="quick">
          <div class="sec">
            <h2>Quick Summary</h2>
            <ul>
              <li><strong>What it’s about:</strong> Phase matching (momentum conservation) for χ(2) three-wave mixing in a dispersive medium.</li>
              <li><strong>Key physics idea:</strong> Efficient energy transfer requires both <em>energy</em> conservation (frequency relation) and <em>momentum</em> conservation (wave-vector relation).</li>
              <li><strong>Given dispersion model:</strong> <code>n(λ0) ≈ n0 − ξ λ0</code> (linear in free-space wavelength).</li>
              <li><strong>Governing relation:</strong> <code>k(λ0) = (2π/λ0) n(λ0)</code> with sign set by propagation direction.</li>
              <li><strong>Crucial consequence:</strong> This model makes <code>k</code> linear in <code>1/λ0</code> but with a constant offset <code>−2πξ</code>.</li>
              <li><strong>Main result (symbolic):</strong> For three waves traveling in the same direction, any χ(2) mixing has a nonzero constant phase mismatch (cannot be phase matched unless ξ=0).</li>
              <li><strong>Opposite direction case:</strong> If one wave counter-propagates, the constant offset can cancel; phase matching becomes possible for specific wavelength choices.</li>
              <li><strong>Physical meaning:</strong> Co-propagating mixing fails because “k-vectors don’t add up” by an irreducible amount set by dispersion slope; introducing a backward wave flips a sign and can restore vector balance.</li>
            </ul>

            <div class="callouts">
              <div class="card eqs half">
                <div class="tag">Key equations</div>
                <div class="eqblock">
                  <button class="copybtn" data-copy="eq-key" aria-label="Copy key equations">Copy</button>
                  <span class="copyhint" id="hint-eq-key" aria-hidden="true">Copied ✓</span>
                  <pre id="eq-key">n(λ0) ≈ n0 − ξ λ0

k(λ0) = (2π/λ0) n(λ0) = 2π(n0/λ0 − ξ)

Energy (SFG example):  ω3 = ω1 + ω2  ⇔  1/λ03 = 1/λ01 + 1/λ02

Phase matching (collinear):  s3 k3 = s1 k1 + s2 k2,   where si = +1 (forward), −1 (backward)</pre>
                </div>
              </div>

              <div class="card final half">
                <div class="tag">Final answer (copyable)</div>
                <div class="eqblock">
                  <button class="copybtn" data-copy="ans" aria-label="Copy final answer">Copy</button>
                  <span class="copyhint" id="hint-ans" aria-hidden="true">Copied ✓</span>
                  <pre id="ans">With n(λ0)=n0−ξλ0, the wavevector is k(λ0)=2π(n0/λ0−ξ).

For three co-propagating waves in any χ(2) process, the phase-matching condition requires k3 = k1 ± k2 (all positive signs for co-propagation).
Using the energy relation (e.g., SFG: 1/λ03 = 1/λ01 + 1/λ02), one finds a constant mismatch:
Δk = k3 − (k1 + k2) = +2πξ (nonzero if ξ≠0),
(or similarly a nonzero constant for other ± choices).
Therefore efficient coupling (Δk=0) is impossible unless ξ=0 (no dispersion in this model).

If one wave counter-propagates, the sign flip can cancel the constant offset −2πξ, and phase matching can be achieved for specific wavelengths.
Example (SFG with wave 2 backward): k3 = k1 − k2 leads to a solvable condition (e.g., λ02 = 2n0/ξ), so efficient coupling is possible in principle.</pre>
                </div>
              </div>
            </div>

            <a class="backtop" href="#top" aria-label="Back to top">↑ Back to top</a>
          </div>
        </section>

        <section id="primer">
          <div class="sec">
            <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

            <h3>0.1 Core definitions (symbols + SI units)</h3>
            <ul>
              <li><code>λ0</code>: free-space wavelength (m).</li>
              <li><code>n(λ0)</code>: refractive index (dimensionless).</li>
              <li><code>k</code>: wavevector magnitude in the medium (rad/m). For collinear propagation, the signed wavevector is <code>k⃗ = s k</code> with <code>s=+1</code> forward and <code>s=−1</code> backward.</li>
              <li><code>ω</code>: angular frequency (rad/s), related by <code>ω = 2πc/λ0</code> in vacuum.</li>
              <li><code>χ(2)</code>: second-order nonlinear susceptibility (SI units depend on convention; you won’t need its numerical value here).</li>
              <li><code>Δk</code>: phase mismatch (rad/m). Efficient mixing requires <code>Δk≈0</code>.</li>
              <li>Given model parameters: <code>n0</code> (dimensionless), <code>ξ</code> (1/m) so that <code>ξλ0</code> is dimensionless.</li>
            </ul>

            <h3>0.2 What these quantities mean (intuition)</h3>
            <p>
              In a χ(2) medium, the nonlinear polarization can act like a “source” that drives new optical waves.
              For the drive to build up coherently over distance, the generated wave must stay <em>in phase</em> with that source.
              That coherence is controlled by the phase mismatch <code>Δk</code>.
            </p>

            <div class="callouts">
              <div class="card eqs half">
                <div class="tag">Why phase matching matters</div>
                <p>
                  In many standard derivations, the generated amplitude contains a factor like
                  <code>sin(Δk L/2)/(Δk/2)</code>. If <code>Δk=0</code>, growth is ~<code>L</code>.
                  If <code>Δk≠0</code>, the growth oscillates and the net conversion stays small.
                </p>
              </div>
              <div class="card assump half">
                <div class="tag">Validity conditions</div>
                <p>
                  We assume monochromatic plane waves, collinear propagation, weak depletion (conceptually),
                  and that the dispersion is well approximated by <code>n(λ0) ≈ n0 − ξλ0</code> over the wavelengths involved.
                </p>
              </div>
            </div>

            <h3>0.3 Key laws/principles</h3>
            <ul>
              <li><strong>Energy conservation (frequency matching):</strong> For sum-frequency generation (SFG), <code>ω3 = ω1 + ω2</code>. For difference-frequency generation (DFG), <code>ω3 = ω1 − ω2</code> (with <code>ω1&gt;ω2</code>).</li>
              <li><strong>Momentum conservation (phase matching):</strong> The nonlinear polarization has a spatial phase given by the combination of interacting waves. For collinear waves, it becomes
                <code>s3 k3 = s1 k1 ± s2 k2</code> (the ± corresponds to whether the polarization involves <code>E2</code> or <code>E2*</code> in the mixing term).
              </li>
              <li><strong>Dispersion relation:</strong> In a nonmagnetic medium, <code>k = n(ω) ω / c</code>. Using free-space wavelength, <code>k(λ0) = (2π/λ0) n(λ0)</code>.</li>
            </ul>

            <h3>0.4 Common models/approximations (and why)</h3>
            <ul>
              <li><strong>Plane-wave / slowly varying envelope:</strong> isolates the essential coherence condition via <code>Δk</code>.</li>
              <li><strong>Collinear (1D) geometry:</strong> turns vector momentum conservation into sign bookkeeping (<code>s=±1</code>).</li>
              <li><strong>Simple linear-in-λ0 dispersion:</strong> makes the algebra transparent and highlights which parts of <code>k(λ0)</code> matter for phase matching.</li>
            </ul>

            <h3>0.5 Mini intuition examples (minimal algebra)</h3>
            <ul>
              <li><strong>No dispersion case:</strong> If <code>n</code> were constant, phase matching for co-propagating SFG would be possible because <code>k ∝ 1/λ0</code> and the energy relation gives a compatible harmonic sum for <code>1/λ0</code>.</li>
              <li><strong>Offset in k:</strong> If <code>k(λ0)</code> contains a constant shift (independent of wavelength), then adding or subtracting wavevectors can leave an unavoidable constant residue—exactly what happens here.</li>
              <li><strong>Backward wave trick:</strong> Making one wave propagate backward flips the sign of its contribution and can cancel constant residues that otherwise spoil matching.</li>
            </ul>

            <h3>0.6 What to watch for (pitfalls)</h3>
            <div class="callouts">
              <div class="card mist">
                <div class="tag">Pitfalls</div>
                <ul>
                  <li>Mixing up <code>λ0</code> (vacuum wavelength) with wavelength in the medium (<code>λ = λ0/n</code>).</li>
                  <li>Forgetting that <code>k⃗</code> is a vector: direction matters; in 1D it becomes a sign.</li>
                  <li>Assuming energy matching automatically implies phase matching (it does not in a dispersive medium).</li>
                  <li>Missing the constant term in <code>k(λ0)</code> after substituting <code>n(λ0)=n0−ξλ0</code>.</li>
                </ul>
              </div>
            </div>

            <a class="backtop" href="#top">↑ Back to top</a>
          </div>
        </section>

        <section id="analysis">
          <div class="sec">
            <h2>PART 1 — Problem Analysis (No solving yet)</h2>

            <h3>1.1 Restate the problem (in plain words)</h3>
            <p>
              A nonlinear medium has refractive index that depends on vacuum wavelength as
              <code>n(λ0) ≈ n0 − ξλ0</code>.
              You have three waves with vacuum wavelengths <code>λ01</code>, <code>λ02</code>, <code>λ03</code>.
              Show that if all three waves travel in the same direction, a second-order nonlinear interaction cannot efficiently couple them
              (i.e., cannot satisfy phase matching together with frequency matching).
              Then ask: if one wave travels in the opposite direction, can efficient coupling become possible?
            </p>

            <h3>1.2 Given quantities</h3>
            <ul>
              <li>Dispersion model: <code>n(λ0) ≈ n0 − ξλ0</code> with constants <code>n0</code>, <code>ξ</code>.</li>
              <li>Three waves with vacuum wavelengths <code>λ01</code>, <code>λ02</code>, <code>λ03</code>.</li>
              <li>Second-order nonlinearity (χ(2)) ⇒ three-wave mixing processes (SFG/DFG/SHG as special cases).</li>
            </ul>

            <h3>1.3 Unknowns / what must be proved</h3>
            <ul>
              <li>Prove <strong>no efficient coupling</strong> for co-propagating waves: show <code>Δk ≠ 0</code> inevitably under the model (unless ξ=0).</li>
              <li>Determine whether <strong>efficient coupling is possible</strong> when one wave counter-propagates, and under what kind of condition.</li>
            </ul>

            <h3>1.4 Relevant principles (and why)</h3>
            <ul>
              <li><strong>Frequency matching</strong> is required because χ(2) polarization oscillates at sums/differences of input frequencies.</li>
              <li><strong>Phase matching</strong> is required because energy transfer accumulates coherently only when the driven wave stays in phase with the nonlinear polarization source.</li>
              <li>We do <strong>not</strong> need detailed coupled-wave amplitudes; we only need the structure of <code>k(λ0)</code> and the matching conditions.</li>
            </ul>

            <div class="callouts">
              <div class="card assump">
                <div class="tag">Assumptions (explicit)</div>
                <ul>
                  <li>Collinear propagation (1D along z).</li>
                  <li>Monochromatic plane waves; steady state.</li>
                  <li>Use vacuum wavelengths in the dispersion model as stated.</li>
                  <li>Ignore birefringence/quasi-phase matching; only material dispersion is in play.</li>
                </ul>
              </div>
            </div>

            <h3>1.5 Possible approaches (compare + choose)</h3>
            <ul>
              <li><strong>Approach A (best):</strong> Derive <code>k(λ0)</code> from the given <code>n(λ0)</code>, then combine with generic χ(2) matching conditions. Fast, clean, and directly answers the “show that” claim.</li>
              <li><strong>Approach B:</strong> Write coupled-wave equations and show the conversion efficiency contains <code>sinc(ΔkL/2)</code>, then argue <code>Δk</code> cannot vanish. More work, same core algebra.</li>
              <li><strong>Approach C:</strong> Geometric “phasor” buildup argument for coherence length <code>π/|Δk|</code>. Intuitive but still needs <code>Δk</code>.</li>
            </ul>
            <p><strong>Chosen approach:</strong> A — because it proves impossibility (or possibility) using only conservation laws and the dispersion model.</p>

            <a class="backtop" href="#top">↑ Back to top</a>
          </div>
        </section>

        <section id="strategy">
          <div class="sec">
            <h2>PART 2 — Strategy & Tips (Roadmap only)</h2>

            <ol style="color:var(--muted); margin:10px 0 0 20px;">
              <li><strong>Compute the medium wavevector:</strong> Use <code>k=(2π/λ0)n(λ0)</code> and substitute <code>n0−ξλ0</code>. (Goal: expose any constant terms.)</li>
              <li><strong>Write generic χ(2) energy matching:</strong> pick a representative process (SFG) and note others are analogous. (Goal: relate the three wavelengths.)</li>
              <li><strong>Write collinear phase matching with direction signs:</strong> <code>s3 k3 = s1 k1 ± s2 k2</code>. (Goal: include the possibility of backward propagation.)</li>
              <li><strong>Case 1: all co-propagating:</strong> set all <code>s=+1</code> and evaluate <code>Δk</code> using the energy relation. (Goal: show a nonzero constant mismatch remains.)</li>
              <li><strong>Case 2: one wave backward:</strong> flip one sign and see whether the constant term cancels; solve for whether a wavelength choice can make <code>Δk=0</code>. (Goal: show “possible in principle”.)</li>
              <li><strong>Interpret:</strong> connect the algebra to coherence/efficiency and explain the physical reason.</li>
            </ol>

            <div class="callouts">
              <div class="card mist">
                <div class="tag">Common mistakes (quick tips)</div>
                <ul>
                  <li>Don’t drop the constant offset <code>−2πξ</code> in <code>k(λ0)</code>; it drives the whole result.</li>
                  <li>Remember: “one wave backward” means <code>k⃗</code> changes sign, not <code>λ0</code> or <code>ω</code>.</li>
                  <li>Use the energy relation to eliminate <code>λ03</code> before comparing wavevector sums.</li>
                </ul>
              </div>
            </div>

            <a class="backtop" href="#top">↑ Back to top</a>
          </div>
        </section>

        <section id="solution">
          <div class="sec">
            <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

            <h3>3.1 Qualitative expectation (before algebra)</h3>
            <p>
              In many materials, dispersion makes phase matching hard because different frequencies “want” different wavevectors.
              Here, the given model is especially restrictive: it makes <code>k(λ0)</code> equal to a term proportional to <code>1/λ0</code> plus a wavelength-independent constant.
              Co-propagating phase matching involves <em>sums</em> of wavevectors, so constants tend to add and create an unavoidable mismatch.
              If we reverse one wave, its wavevector contribution flips sign, so constant terms may cancel—opening a path to matching.
            </p>

            <h3>3.2 Step 1: Derive k(λ0) from n(λ0)</h3>
            <p>
              The wavevector magnitude in the medium (for a wave with vacuum wavelength <code>λ0</code>) is
              <code>k(λ0) = (2π/λ0) n(λ0)</code>.
              Substitute the given dispersion approximation:
            </p>

            <div class="eqblock">
              <button class="copybtn" data-copy="eq-k" aria-label="Copy k(λ0) derivation">Copy</button>
              <span class="copyhint" id="hint-eq-k" aria-hidden="true">Copied ✓</span>
              <pre id="eq-k">k(λ0) = (2π/λ0) n(λ0)
      = (2π/λ0)(n0 − ξλ0)
      = 2π(n0/λ0 − ξ)</pre>
            </div>

            <p>
              <strong>Key observation:</strong> <code>k(λ0)</code> contains a constant term <code>−2πξ</code> that does not depend on wavelength.
            </p>

            <h3>3.3 Step 2: State energy matching (use SFG as representative)</h3>
            <p>
              For sum-frequency generation (a standard χ(2) three-wave mixing process),
              <code>ω3 = ω1 + ω2</code>. Using <code>ω = 2πc/λ0</code> (vacuum relation),
              this becomes:
            </p>

            <div class="eqblock">
              <button class="copybtn" data-copy="eq-energy" aria-label="Copy energy matching">Copy</button>
              <span class="copyhint" id="hint-eq-energy" aria-hidden="true">Copied ✓</span>
              <pre id="eq-energy">ω3 = ω1 + ω2
2πc/λ03 = 2πc/λ01 + 2πc/λ02
⇒ 1/λ03 = 1/λ01 + 1/λ02</pre>
            </div>

            <details>
              <summary>What about other χ(2) processes (DFG, etc.)?</summary>
              <p>
                The same logic works for difference-frequency generation (DFG): <code>ω3 = ω1 − ω2</code>,
                giving <code>1/λ03 = 1/λ01 − 1/λ02</code> (with <code>ω1 &gt; ω2</code>).
                The key point is that energy matching provides a linear relation among the reciprocals <code>1/λ0</code>.
              </p>
            </details>

            <h3>3.4 Step 3: Write the collinear phase matching condition with direction signs</h3>
            <p>
              In 1D (collinear along z), a wave traveling forward has <code>k⃗ = +k</code> and backward has <code>k⃗ = −k</code>.
              We encode direction by <code>s_i ∈ {+1, −1}</code>, so <code>k⃗_i = s_i k_i</code>.
            </p>
            <p>
              For SFG, the nonlinear polarization driving wave 3 carries spatial phase like <code>exp[i(s1k1 + s2k2)z]</code>,
              so momentum conservation (phase matching) is:
            </p>

            <div class="eqblock">
              <button class="copybtn" data-copy="eq-pm" aria-label="Copy phase matching">Copy</button>
              <span class="copyhint" id="hint-eq-pm" aria-hidden="true">Copied ✓</span>
              <pre id="eq-pm">Phase matching (SFG, collinear):
s3 k3 = s1 k1 + s2 k2

Define mismatch:
Δk = s3 k3 − (s1 k1 + s2 k2)
Efficient coupling requires Δk ≈ 0.</pre>
            </div>

            <h3>3.5 Case 1: All three waves co-propagating (show impossibility)</h3>
            <p>
              “Traveling in the same direction” means <code>s1 = s2 = s3 = +1</code>.
              Then SFG phase matching would require:
              <code>k3 = k1 + k2</code>.
            </p>
            <p>
              Using <code>k_i = 2π(n0/λ0i − ξ)</code>:
            </p>

            <div class="eqblock">
              <button class="copybtn" data-copy="eq-coprop" aria-label="Copy co-propagating mismatch derivation">Copy</button>
              <span class="copyhint" id="hint-eq-coprop" aria-hidden="true">Copied ✓</span>
              <pre id="eq-coprop">k3 = k1 + k2

2π(n0/λ03 − ξ) = 2π(n0/λ01 − ξ) + 2π(n0/λ02 − ξ)
⇒ n0/λ03 − ξ = n0/λ01 + n0/λ02 − 2ξ
⇒ n0/λ03 = n0/λ01 + n0/λ02 − ξ</pre>
            </div>

            <p>
              Now insert the energy constraint for SFG:
              <code>1/λ03 = 1/λ01 + 1/λ02</code>.
              Multiply that by <code>n0</code>:
              <code>n0/λ03 = n0/λ01 + n0/λ02</code>.
            </p>
            <p>
              Compare with the phase matching requirement above:
              it demands <code>n0/λ03 = n0/λ01 + n0/λ02 − ξ</code>.
              These can only both be true if <code>ξ = 0</code>.
            </p>

            <div class="callouts">
              <div class="card warn">
                <div class="tag">Conclusion for co-propagating waves</div>
                <p>
                  Under <code>n(λ0)=n0−ξλ0</code> with <code>ξ≠0</code>, energy matching forces
                  <code>n0/λ03 = n0/λ01 + n0/λ02</code>, but phase matching would require a value smaller by <code>ξ</code>.
                  Therefore <strong>exact phase matching is impossible</strong>.
                </p>
              </div>
            </div>

            <p>
              A compact way to show the “unavoidable mismatch” is to compute <code>Δk</code> directly:
            </p>

            <div class="eqblock">
              <button class="copybtn" data-copy="eq-dk" aria-label="Copy constant mismatch result">Copy</button>
              <span class="copyhint" id="hint-eq-dk" aria-hidden="true">Copied ✓</span>
              <pre id="eq-dk">Δk = k3 − (k1 + k2)
   = 2π(n0/λ03 − ξ) − 2π[(n0/λ01 − ξ) + (n0/λ02 − ξ)]
   = 2π[n0(1/λ03 − 1/λ01 − 1/λ02) + ξ]

Using energy matching (SFG): 1/λ03 = 1/λ01 + 1/λ02
⇒ Δk = 2π ξ  (a constant ≠ 0 if ξ ≠ 0)</pre>
            </div>

            <p>
              Since <code>Δk</code> is a nonzero constant, the interaction coherence length is finite:
              <code>Lc = π/|Δk| = 1/(2|ξ|)</code>, and power transfer oscillates rather than building up steadily—hence “not efficiently coupled.”
            </p>

            <details>
              <summary>Does this depend on choosing SFG? (Answer: no.)</summary>
              <p>
                No. Any χ(2) three-wave interaction produces a phase matching equation that adds/subtracts
                wavevectors. Because every <code>k_i</code> contains the same constant offset <code>−2πξ</code>,
                co-propagating combinations always leave a leftover constant.
                For example, in a DFG-type relation (co-propagating) you would get <code>k1 = k2 + k3</code> (or similar),
                and the constants still fail to balance unless <code>ξ=0</code>.
              </p>
            </details>

            <h3>3.6 Case 2: One wave travels in the opposite direction (is efficient coupling possible?)</h3>
            <p>
              Now let one wave counter-propagate. A common (and instructive) choice is:
              waves 1 and 3 forward (<code>s1=s3=+1</code>) and wave 2 backward (<code>s2=−1</code>).
              For SFG, the phase matching condition becomes:
              <code>k3 = k1 + (−k2) = k1 − k2</code>.
            </p>

            <p>
              Substitute <code>k(λ0)=2π(n0/λ0−ξ)</code>:
            </p>

            <div class="eqblock">
              <button class="copybtn" data-copy="eq-back" aria-label="Copy backward-wave phase matching derivation">Copy</button>
              <span class="copyhint" id="hint-eq-back" aria-hidden="true">Copied ✓</span>
              <pre id="eq-back">k3 = k1 − k2

2π(n0/λ03 − ξ) = 2π(n0/λ01 − ξ) − 2π(n0/λ02 − ξ)

Divide by 2π:
n0/λ03 − ξ = n0/λ01 − ξ − n0/λ02 + ξ
⇒ n0/λ03 − ξ = n0(1/λ01 − 1/λ02)</pre>
            </div>

            <p>
              Notice what happened: the <code>−ξ</code> constants on the right partly canceled because wave 2 was subtracted.
              Now enforce energy matching for SFG:
              <code>1/λ03 = 1/λ01 + 1/λ02</code>. Substitute into the phase match equation:
            </p>

            <div class="eqblock">
              <button class="copybtn" data-copy="eq-solve" aria-label="Copy condition for phase matching with one backward wave">Copy</button>
              <span class="copyhint" id="hint-eq-solve" aria-hidden="true">Copied ✓</span>
              <pre id="eq-solve">From energy: 1/λ03 = 1/λ01 + 1/λ02

Plug into phase matching:
n0(1/λ01 + 1/λ02) − ξ = n0(1/λ01 − 1/λ02)

Cancel n0/λ01:
n0(1/λ02 + 1/λ02) = ξ
⇒ 2n0/λ02 = ξ
⇒ λ02 = 2n0 / ξ</pre>
            </div>

            <p>
              This is a <strong>specific solvability condition</strong>: if the counter-propagating wave (wave 2 in this setup)
              has vacuum wavelength <code>λ02 = 2n0/ξ</code>, then both energy and momentum conditions can be satisfied simultaneously,
              so <code>Δk=0</code> is achievable and efficient coupling is possible <em>in principle</em>.
            </p>

            <div class="callouts">
              <div class="card final">
                <div class="tag">Boxed result (interpretation)</div>
                <p>
                  Co-propagating: constants add → unavoidable <code>Δk = 2πξ</code> (no phase matching if <code>ξ≠0</code>).<br/>
                  One backward wave: constants can cancel → phase matching becomes possible for appropriate wavelength choices
                  (e.g., SFG with wave 2 backward gives <code>λ02 = 2n0/ξ</code>).
                </p>
              </div>
            </div>

            <h3>3.7 Sanity checks</h3>
            <ul>
              <li><strong>Units:</strong> <code>ξ</code> has units 1/m, so <code>2n0/ξ</code> has units m, consistent for a wavelength.</li>
              <li><strong>Limiting case ξ → 0:</strong> dispersion vanishes; co-propagating phase mismatch <code>Δk=2πξ</code> → 0, restoring possibility of phase matching.</li>
              <li><strong>Direction reasoning:</strong> The only change from “impossible” to “possible” was flipping one sign in the momentum equation—consistent with the idea that vector nature of <code>k⃗</code> matters.</li>
              <li><strong>Physical meaning:</strong> The model gives every wavevector the same constant shift. Co-propagating sum rules can’t remove it; subtracting a backward wave can.</li>
            </ul>

            <a class="backtop" href="#top">↑ Back to top</a>
          </div>
        </section>

        <section id="deeper">
          <div class="sec">
            <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

            <h3>4.1 Re-interpret the core formula</h3>
            <p>
              The dispersion model produces:
              <code>k(λ0) = 2π(n0/λ0) − 2πξ</code>.
              Think of this as:
              <strong>(i)</strong> a term proportional to <code>1/λ0</code> (the “usual” part) and
              <strong>(ii)</strong> a constant offset in wavevector shared by all wavelengths.
            </p>
            <p>
              In χ(2) mixing, phase matching compares <em>sums/differences</em> of wavevectors.
              If all waves propagate forward, the constant offsets combine into a leftover constant mismatch.
              If one wave propagates backward, its wavevector enters with the opposite sign and can cancel those constants.
            </p>

            <h3>4.2 Parameter dependence (qualitative)</h3>
            <ul>
              <li><strong>Larger |ξ| (stronger wavelength dependence of n):</strong> makes the co-propagating mismatch <code>|Δk| = 2π|ξ|</code> bigger ⇒ coherence length smaller ⇒ worse efficiency.</li>
              <li><strong>Changing n0:</strong> does not remove the co-propagating mismatch because it cancels via the energy relation; but <code>n0</code> does set the required backward-wave wavelength (e.g., <code>λ02 = 2n0/ξ</code> in the SFG backward configuration).</li>
              <li><strong>Sign of ξ:</strong> affects whether the required <code>λ02</code> is physically positive in that specific configuration; more generally, “possible in principle” means there exists some direction assignment and wavelength choice satisfying both constraints.</li>
            </ul>

            <details>
              <summary>Alternative derivation idea (brief but meaningful)</summary>
              <p>
                Instead of using wavelengths, write everything in terms of frequency:
                <code>k(ω)=n(ω)ω/c</code>.
                Convert the given <code>n(λ0)</code> into an approximate <code>n(ω)</code> using <code>λ0=2πc/ω</code>.
                You will again find that <code>k</code> has an additive constant shift.
                Then apply <code>ω3=ω1+ω2</code> and compare <code>k3</code> with <code>k1+k2</code> to recover a constant mismatch.
              </p>
            </details>

            <h3>4.3 Concept check (self-test with answers)</h3>
            <ul>
              <li><strong>Q:</strong> Why isn’t energy conservation enough for efficient conversion?<br/>
                  <strong>A:</strong> Because even if frequencies match, the nonlinear polarization can drift out of phase with the generated wave if <code>Δk≠0</code>, causing destructive interference along z.</li>
              <li><strong>Q:</strong> What feature of <code>n(λ0)=n0−ξλ0</code> kills co-propagating phase matching?<br/>
                  <strong>A:</strong> It creates a wavelength-independent offset <code>−2πξ</code> in <code>k</code>, leaving an irreducible constant mismatch in forward-direction sums.</li>
              <li><strong>Q:</strong> What does making one wave backward change mathematically?<br/>
                  <strong>A:</strong> It flips the sign of that wave’s <code>k⃗</code> contribution in momentum conservation, allowing constant terms to cancel.</li>
              <li><strong>Q:</strong> Does “possible” mean it will always happen automatically?<br/>
                  <strong>A:</strong> No. It means there exists a set of wavelengths/directions that satisfy both constraints; engineering a real device also needs appropriate polarization selection rules, nonzero χ(2), overlap, etc.</li>
            </ul>

            <a class="backtop" href="#top">↑ Back to top</a>
          </div>
        </section>

        <section id="plot">
          <div class="sec">
            <h2>PART 5 — Optional Plot Guide</h2>

            <p>
              A plot is useful here because the entire argument hinges on the <strong>structure of the dispersion relation</strong>:
              <code>k(λ0)</code> is linear in <code>1/λ0</code> but shifted downward by a constant <code>2πξ</code>.
              That constant shift is precisely what creates a constant phase mismatch for co-propagating mixing.
            </p>

            <figure>
              <canvas id="plotCanvas" width="980" height="520" aria-label="Plot of k versus 1/λ0"></canvas>
              <figcaption>
                <strong>Plot (example values):</strong> Wavevector magnitude <code>k</code> vs reciprocal vacuum wavelength <code>1/λ0</code>.
                The line is <code>k = 2π(n0·(1/λ0) − ξ)</code> with example <code>n0 = 1.7</code>, <code>ξ = 2.0×10^6 m⁻¹</code>.
                The constant vertical shift (set by <code>ξ</code>) is what prevents co-propagating wavevector sums from matching exactly.
              </figcaption>
            </figure>

            <h3>How to read the plot</h3>
            <ul>
              <li><strong>x-axis:</strong> <code>1/λ0</code> in <code>m⁻¹</code>.</li>
              <li><strong>y-axis:</strong> <code>k</code> in <code>rad/m</code>.</li>
              <li><strong>Example values:</strong> chosen solely to draw a curve; the final proof is symbolic and independent of numbers.</li>
              <li><strong>Feature to notice:</strong> the straight-line relationship with a nonzero intercept due to the <code>−2πξ</code> term.</li>
            </ul>

            <a class="backtop" href="#top">↑ Back to top</a>
          </div>
        </section>

        <footer>
          <p>
            Built for learning: conservation laws + dispersion → phase matching. No external libraries; all equations are plain text and copyable.
          </p>
        </footer>
      </main>
    </div>
  </div>

  <script>
    // ------- Copy buttons -------
    function copyTextFrom(el){
      const text = el.innerText.replace(/\u00A0/g, " ");
      return navigator.clipboard.writeText(text);
    }
    function flashHint(btn){
      const id = btn.getAttribute("data-copy");
      const hint = document.getElementById("hint-" + id);
      if(!hint) return;
      hint.style.display = "inline-block";
      hint.style.opacity = "1";
      clearTimeout(hint._t);
      hint._t = setTimeout(() => {
        hint.style.opacity = "0";
        setTimeout(()=>hint.style.display="none", 200);
      }, 900);
    }
    document.querySelectorAll(".copybtn").forEach(btn=>{
      btn.addEventListener("click", async ()=>{
        const id = btn.getAttribute("data-copy");
        const target = document.getElementById(id);
        if(!target) return;
        try{
          await copyTextFrom(target);
          flashHint(btn);
        }catch(e){
          // Fallback
          const range = document.createRange();
          range.selectNodeContents(target);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
          try{ document.execCommand("copy"); flashHint(btn); }catch(_){}
          sel.removeAllRanges();
        }
      });
    });

    // ------- TOC active link + progress -------
    const tocLinks = Array.from(document.querySelectorAll("nav.toc a"));
    const sections = tocLinks.map(a => document.querySelector(a.getAttribute("href"))).filter(Boolean);
    const tocProg = document.getElementById("tocProg");

    function setActive(){
      const y = window.scrollY + 120;
      let idx = 0;
      for(let i=0;i<sections.length;i++){
        if(sections[i].offsetTop <= y) idx = i;
      }
      tocLinks.forEach((a,i)=>a.classList.toggle("active", i===idx));
      const doc = document.documentElement;
      const scrollTop = doc.scrollTop || document.body.scrollTop;
      const scrollHeight = doc.scrollHeight - doc.clientHeight;
      const pct = scrollHeight > 0 ? Math.round((scrollTop/scrollHeight)*100) : 0;
      tocProg.textContent = pct + "%";
    }
    window.addEventListener("scroll", setActive, {passive:true});
    window.addEventListener("resize", setActive);
    setActive();

    // ------- Canvas plot (crisp, responsive, non-interactive) -------
    const canvas = document.getElementById("plotCanvas");
    const ctx = canvas.getContext("2d");

    function drawPlot(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const parent = canvas.parentElement;
      const cssW = parent.clientWidth;
      const cssH = Math.max(360, Math.min(520, Math.round(cssW * 0.52)));
      canvas.style.height = cssH + "px";
      canvas.style.width = cssW + "px";
      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);

      // Colors (avoid CSS vars lookup for speed)
      const bg = "rgba(0,0,0,0.12)";
      const panel = "rgba(255,255,255,0.06)";
      const grid = "rgba(255,255,255,0.10)";
      const axis = "rgba(255,255,255,0.34)";
      const text = "rgba(234,240,255,0.92)";
      const muted = "rgba(184,195,230,0.92)";

      const W = cssW, H = cssH;
      ctx.clearRect(0,0,W,H);

      // Panel
      roundRect(ctx, 0.5, 0.5, W-1, H-1, 14);
      ctx.fillStyle = bg; ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.12)"; ctx.lineWidth = 1;
      ctx.stroke();

      const padL = 64, padR = 18, padT = 44, padB = 52;
      const x0 = padL, y0 = H - padB;
      const x1 = W - padR, y1 = padT;

      // Example parameters
      const n0 = 1.7;
      const xi = 2.0e6; // 1/m (example)
      // x range: 1/λ0
      const xmin = 0.8e6, xmax = 4.2e6; // 1/m
      // y = 2π(n0 x - xi)
      function kOf(x){ return 2*Math.PI*(n0*x - xi); }

      const ymin = kOf(xmin) * 0.92;
      const ymax = kOf(xmax) * 1.02;

      function X(x){ return x0 + (x - xmin) * (x1 - x0) / (xmax - xmin); }
      function Y(y){ return y0 - (y - ymin) * (y0 - y1) / (ymax - ymin); }

      // Grid
      const nx = 7, ny = 6;
      ctx.lineWidth = 1;

      ctx.strokeStyle = grid;
      for(let i=0;i<=nx;i++){
        const t = i/nx;
        const x = x0 + t*(x1-x0);
        ctx.beginPath();
        ctx.moveTo(x, y0);
        ctx.lineTo(x, y1);
        ctx.stroke();
      }
      for(let j=0;j<=ny;j++){
        const t = j/ny;
        const y = y0 - t*(y0-y1);
        ctx.beginPath();
        ctx.moveTo(x0, y);
        ctx.lineTo(x1, y);
        ctx.stroke();
      }

      // Axes
      ctx.strokeStyle = axis;
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y0);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x0, y1);
      ctx.stroke();

      // Ticks + labels
      ctx.fillStyle = muted;
      ctx.font = "12px " + getComputedStyle(document.documentElement).getPropertyValue('--sans');
      ctx.textAlign = "center";
      ctx.textBaseline = "top";

      for(let i=0;i<=nx;i++){
        const xVal = xmin + (xmax-xmin)*(i/nx);
        const x = X(xVal);
        ctx.strokeStyle = axis;
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(x, y0);
        ctx.lineTo(x, y0 + 6);
        ctx.stroke();
        const label = formatSci(xVal, 2);
        ctx.fillText(label, x, y0 + 10);
      }

      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      for(let j=0;j<=ny;j++){
        const yVal = ymin + (ymax-ymin)*(j/ny);
        const y = Y(yVal);
        ctx.strokeStyle = axis;
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(x0, y);
        ctx.lineTo(x0 - 6, y);
        ctx.stroke();
        const label = formatSci(yVal, 2);
        ctx.fillText(label, x0 - 10, y);
      }

      // Title
      ctx.fillStyle = text;
      ctx.font = "700 14px " + getComputedStyle(document.documentElement).getPropertyValue('--sans');
      ctx.textAlign = "left";
      ctx.textBaseline = "alphabetic";
      ctx.fillText("Wavevector vs reciprocal vacuum wavelength (example)", x0, 26);

      // Axis labels
      ctx.fillStyle = muted;
      ctx.font = "600 12px " + getComputedStyle(document.documentElement).getPropertyValue('--sans');
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      ctx.fillText("x = 1/λ₀  (m⁻¹)", (x0+x1)/2, H - 10);

      // Y label (rotated)
      ctx.save();
      ctx.translate(18, (y0+y1)/2);
      ctx.rotate(-Math.PI/2);
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText("k  (rad/m)", 0, 0);
      ctx.restore();

      // Plot line
      ctx.strokeStyle = "rgba(124,243,194,0.92)";
      ctx.lineWidth = 2.4;
      ctx.beginPath();
      const N = 220;
      for(let i=0;i<=N;i++){
        const xVal = xmin + (xmax-xmin)*(i/N);
        const yVal = kOf(xVal);
        const px = X(xVal), py = Y(yVal);
        if(i===0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();

      // Legend
      const lx = x1 - 260, ly = y1 + 12, lw = 248, lh = 38;
      roundRect(ctx, lx, ly, lw, lh, 12);
      ctx.fillStyle = panel; ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.fillStyle = muted;
      ctx.font = "12px " + getComputedStyle(document.documentElement).getPropertyValue('--sans');
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      // line sample
      ctx.strokeStyle = "rgba(124,243,194,0.92)";
      ctx.lineWidth = 2.4;
      ctx.beginPath();
      ctx.moveTo(lx+12, ly+19);
      ctx.lineTo(lx+46, ly+19);
      ctx.stroke();
      ctx.fillStyle = muted;
      ctx.fillText("k = 2π(n₀ x − ξ),  n₀=1.7,  ξ=2.0×10⁶ m⁻¹", lx+54, ly+19);
    }

    function roundRect(c, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      c.beginPath();
      c.moveTo(x+rr, y);
      c.arcTo(x+w, y, x+w, y+h, rr);
      c.arcTo(x+w, y+h, x, y+h, rr);
      c.arcTo(x, y+h, x, y, rr);
      c.arcTo(x, y, x+w, y, rr);
      c.closePath();
    }

    function formatSci(val, digits){
      if(val === 0) return "0";
      const sign = val < 0 ? "-" : "";
      const a = Math.abs(val);
      const exp = Math.floor(Math.log10(a));
      const mant = a / Math.pow(10, exp);
      const m = mant.toFixed(digits);
      // Prefer plain if not too big/small
      if(exp >= -2 && exp <= 3){
        const plain = (sign + (a).toFixed(Math.max(0, digits - exp))).replace(/\.?0+$/,"");
        return plain;
      }
      return sign + m + "×10" + superscript(exp);
    }

    function superscript(n){
      const map = {"-":"⁻","0":"⁰","1":"¹","2":"²","3":"³","4":"⁴","5":"⁵","6":"⁶","7":"⁷","8":"⁸","9":"⁹"};
      const s = String(n);
      let out = "";
      for(const ch of s) out += map[ch] || ch;
      return out;
    }

    let plotRaf = null;
    function scheduleDraw(){
      cancelAnimationFrame(plotRaf);
      plotRaf = requestAnimationFrame(drawPlot);
    }
    window.addEventListener("resize", scheduleDraw, {passive:true});
    scheduleDraw();
  </script>
</body>
</html>
