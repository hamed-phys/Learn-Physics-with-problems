<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>7.2-3 — Normal-to-Axis Wave in a 1D Periodic Medium: Why K = 0 Gives No Bandgaps</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --card:#101a38;
      --text:#e9eefc;
      --muted:#b7c3e6;
      --faint:#7f8bb3;
      --accent:#7cf0c6;
      --accent2:#7aa7ff;
      --warn:#ffd27a;
      --danger:#ff7aa2;
      --ok:#8dff7a;
      --border: rgba(255,255,255,.10);
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 700px at 15% 10%, rgba(122,167,255,.14), transparent 60%),
                  radial-gradient(900px 600px at 90% 20%, rgba(124,240,198,.10), transparent 55%),
                  radial-gradient(900px 700px at 40% 90%, rgba(255,122,162,.07), transparent 55%),
                  var(--bg);
      color:var(--text);
      line-height:1.55;
    }

    header{
      padding: 28px 18px 16px;
      max-width: 1200px;
      margin: 0 auto;
    }
    header .top{
      display:grid;
      gap:14px;
      grid-template-columns: 1.35fr .65fr;
      align-items: start;
    }
    @media (max-width: 980px){
      header .top{grid-template-columns: 1fr}
    }
    h1{
      margin:0;
      font-size: clamp(1.4rem, 2.1vw + 1rem, 2.25rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin-top:8px;
      color:var(--muted);
      max-width: 75ch;
    }

    .toc{
      position: sticky;
      top: 12px;
      align-self:start;
      background: linear-gradient(180deg, rgba(16,26,56,.92), rgba(16,26,56,.75));
      border:1px solid var(--border);
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      padding: 14px 14px 10px;
      backdrop-filter: blur(8px);
    }
    .toc h2{
      font-size: .95rem;
      margin: 0 0 10px;
      color: var(--text);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .toc nav a{
      display:block;
      color: var(--muted);
      text-decoration:none;
      padding: 7px 9px;
      border-radius: 12px;
      border: 1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size: .92rem;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .toc nav a:hover{
      background: rgba(122,167,255,.10);
      border-color: rgba(122,167,255,.18);
      transform: translateX(2px);
      color: var(--text);
    }
    .toc small{color:var(--faint)}

    main{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 18px 34px;
      display:grid;
      gap: 18px;
      grid-template-columns: 1.35fr .65fr;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
      .toc{position:relative; top:auto}
    }

    section, article{
      background: linear-gradient(180deg, rgba(16,26,56,.78), rgba(16,26,56,.62));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px;
      backdrop-filter: blur(8px);
    }

    section h2{
      margin: 0 0 10px;
      font-size: 1.2rem;
      letter-spacing:.2px;
    }
    section h3{
      margin: 16px 0 8px;
      font-size: 1.05rem;
      color: var(--text);
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 760px){
      .grid2{grid-template-columns:1fr}
    }

    .callouts{
      display:grid;
      gap: 12px;
    }
    .callout{
      border-radius: 16px;
      border: 1px solid var(--border);
      background: rgba(11,16,32,.35);
      padding: 12px 12px;
    }
    .callout strong{color:var(--text)}
    .callout .tag{
      display:inline-block;
      font-size:.78rem;
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      color: var(--muted);
      margin-bottom: 8px;
      background: rgba(255,255,255,.04);
    }
    .callout.assump .tag{border-color: rgba(124,240,198,.25); color: rgba(124,240,198,.95)}
    .callout.keyeq .tag{border-color: rgba(122,167,255,.28); color: rgba(122,167,255,.96)}
    .callout.pitfall .tag{border-color: rgba(255,210,122,.30); color: rgba(255,210,122,.96)}
    .callout.final .tag{border-color: rgba(141,255,122,.30); color: rgba(141,255,122,.96)}
    .callout.final{background: rgba(141,255,122,.06)}

    ul{margin:10px 0 0 20px}
    li{margin:6px 0}
    .muted{color:var(--muted)}
    .faint{color:var(--faint)}

    .eq{
      font-family: var(--mono);
      font-size: .95rem;
      background: rgba(0,0,0,.24);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding: 10px 10px 10px;
      overflow:auto;
      position:relative;
    }
    .eq .row{
      display:flex;
      align-items:flex-start;
      gap: 10px;
      justify-content: space-between;
    }
    .eq pre{
      margin:0;
      white-space: pre;
      overflow:auto;
      padding-right: 84px;
    }
    .copyBtn{
      position:absolute;
      right: 10px;
      top: 10px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 12px;
      padding: 6px 10px;
      font-size: .85rem;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
    }
    .copyBtn:hover{transform: translateY(-1px); background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.24)}
    .copyBtn:active{transform: translateY(0px)}
    .copyToast{
      position:absolute;
      right: 10px;
      top: 44px;
      font-size:.78rem;
      color: var(--muted);
      opacity: 0;
      transform: translateY(-4px);
      transition: opacity .18s ease, transform .18s ease;
      pointer-events:none;
    }
    .copyToast.show{opacity:1; transform: translateY(0px)}

    figure{
      margin:0;
      display:grid;
      gap: 10px;
    }
    figcaption{
      color: var(--muted);
      font-size:.92rem;
    }
    canvas{
      width:100%;
      height: 320px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      display:block;
    }
    .canvasTall{height: 360px}
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap: 10px 14px;
      align-items:center;
      padding: 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.16);
    }
    .control{
      display:grid;
      gap: 6px;
      min-width: 220px;
      flex: 1 1 240px;
    }
    .control label{
      font-size:.9rem;
      color: var(--muted);
      display:flex;
      justify-content:space-between;
      gap:10px;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent2);
    }
    .pill{
      font-family: var(--mono);
      font-size:.85rem;
      color: var(--text);
      padding: 2px 8px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      white-space:nowrap;
    }
    .note{
      font-size:.92rem;
      color: var(--muted);
      margin-top: 8px;
    }

    footer{
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px 18px 28px;
      color: var(--faint);
      font-size: .9rem;
    }

    @media print{
      body{background:#fff; color:#000}
      header, main, section, article{box-shadow:none; background:#fff; border-color:#ccc}
      .toc{display:none}
      canvas{border-color:#999}
      .copyBtn,.copyToast{display:none}
    }

    /* subtle entrance */
    .fadeIn{
      animation: fadeIn .45s ease both;
    }
    @keyframes fadeIn{
      from{opacity:0; transform: translateY(6px)}
      to{opacity:1; transform: translateY(0)}
    }
  </style>
</head>
<body>
  <header class="fadeIn">
    <div class="top">
      <div>
        <h1>7.2-3 — Normal-to-Axis Wave in a 1D Periodic Medium: show there are <em>no bandgaps</em> for <span class="pill">K = 0</span></h1>
        <p class="subtitle">
          We use the transfer-matrix / Bloch-dispersion result (from the previous problem) to prove a key fact:
          at <strong>normal incidence</strong> (no lateral wavevector), a 1D periodic stack does <strong>not</strong> create stop-bands.
          The interactive plots let you dial <span class="pill">K</span> away from zero and watch bandgaps appear.
        </p>
      </div>

      <aside class="toc" aria-label="Table of Contents">
        <h2>Contents <small class="faint">sticky</small></h2>
        <nav>
          <a href="#quick">Quick Summary</a>
          <a href="#part0">PART 0 — Concept Primer</a>
          <a href="#part1">PART 1 — Problem Analysis</a>
          <a href="#part2">PART 2 — Strategy &amp; Tips</a>
          <a href="#part3">PART 3 — Full Solution</a>
          <a href="#part4">PART 4 — Deeper Understanding</a>
          <a href="#part5">PART 5 — Visualization Guide</a>
        </nav>
        <p class="note">Tip: click any item to scroll smoothly.</p>
      </aside>
    </div>
  </header>

  <main>
    <article id="quick" class="fadeIn">
      <h2>Quick Summary</h2>
      <ul>
        <li><strong>What this is about:</strong> waves in a <strong>1D periodic (layered)</strong> medium and when <strong>bandgaps</strong> (stop-bands) occur.</li>
        <li><strong>Key idea:</strong> bandgaps appear when the Bloch phase becomes complex, i.e. when <span class="pill">|F| &gt; 1</span> in the Bloch dispersion <span class="pill">cos(βΛ)=F</span>.</li>
        <li><strong>Governing equation (model):</strong> 1D Helmholtz in each layer with continuity conditions; solved via a <strong>transfer matrix</strong> over one period Λ.</li>
        <li><strong>Important quantities:</strong> Bloch wavenumber <span class="pill">β</span> (rad/m), period <span class="pill">Λ</span> (m), lateral wavenumber <span class="pill">K</span> (rad/m), layer indices <span class="pill">n₁,n₂</span>.</li>
        <li><strong>Main result to prove:</strong> for <span class="pill">K = 0</span>, the dispersion reduces to a pure cosine:
          <span class="pill">cos(βΛ)=cos(δ₁+δ₂)</span>, so <span class="pill">|cos(βΛ)|≤1</span> always ⇒ <strong>β is always real</strong> ⇒ <strong>no bandgaps</strong>.</li>
        <li><strong>What the plots show:</strong> the function <span class="pill">F(ν;K)</span> and the Bloch phase <span class="pill">βΛ</span> vs normalized frequency <span class="pill">ν=Λ/λ</span>; gaps appear only when you increase <span class="pill">K</span>.</li>
        <li><strong>Final result type:</strong> symbolic (general proof) + example numeric plots for illustration.</li>
      </ul>
    </article>

    <aside class="fadeIn">
      <section>
        <h2>Interactive Controls</h2>
        <div class="controls" role="group" aria-label="Interactive controls">
          <div class="control">
            <label for="kappa">
              Lateral wavenumber ratio <span class="pill">κ = K/k₀</span>
              <span class="pill" id="kappaVal">0.00</span>
            </label>
            <input id="kappa" type="range" min="0" max="0.95" step="0.01" value="0">
            <div class="note">κ = 0 is the case to prove (no bandgaps). Increase κ to see stop-bands appear.</div>
          </div>
          <div class="control">
            <label for="preset">
              Example stack preset
              <span class="pill" id="presetLabel">Quarter-ish</span>
            </label>
            <select id="preset" style="width:100%; padding:8px 10px; border-radius:12px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.06); color:var(--text)">
              <option value="0">Quarter-ish: n1=1.50, n2=2.10, d1=0.45Λ, d2=0.55Λ</option>
              <option value="1">Mild contrast: n1=1.45, n2=1.80, d1=0.50Λ, d2=0.50Λ</option>
              <option value="2">High contrast: n1=1.30, n2=2.60, d1=0.35Λ, d2=0.65Λ</option>
            </select>
            <div class="note">These are <strong>example values for plotting</strong> only; the proof is symbolic.</div>
          </div>
          <div class="control">
            <label for="mode">
              Polarization model (for the interface factor)
              <span class="pill" id="modeLabel">TE-like</span>
            </label>
            <select id="mode" style="width:100%; padding:8px 10px; border-radius:12px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.06); color:var(--text)">
              <option value="TE">TE-like (p = kx)</option>
              <option value="TM">TM-like (p = kx / n^2)</option>
            </select>
            <div class="note">At <span class="pill">K=0</span>, both models collapse to the same “no gap” conclusion.</div>
          </div>
        </div>
      </section>
    </aside>

    <section id="part0" class="fadeIn">
      <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

      <h3>0.1 Core definitions (symbols + units)</h3>
      <ul>
        <li><strong>1D periodic medium:</strong> material parameters repeat every period <span class="pill">Λ</span> (m) along one coordinate (call it <span class="pill">x</span>).</li>
        <li><strong>Layered (bilayer) unit cell:</strong> layer 1: index <span class="pill">n₁</span>, thickness <span class="pill">d₁</span>; layer 2: index <span class="pill">n₂</span>, thickness <span class="pill">d₂</span>; period <span class="pill">Λ = d₁ + d₂</span>.</li>
        <li><strong>Vacuum wavenumber:</strong> <span class="pill">k₀ = ω/c = 2π/λ</span> (rad/m).</li>
        <li><strong>Lateral wavenumber:</strong> <span class="pill">K</span> (rad/m), the conserved wavevector component parallel to the layers (transverse to the periodic axis).</li>
        <li><strong>Normal component in layer j:</strong> <span class="pill">k<sub>xj</sub> = √[(n<sub>j</sub>k₀)² − K²]</span> (rad/m) for propagating waves in that layer.</li>
        <li><strong>Bloch wavenumber:</strong> <span class="pill">β</span> (rad/m) defined by <span class="pill">E(x+Λ)=E(x)e^{iβΛ}</span>.</li>
      </ul>

      <h3>0.2 Physical meaning (what the quantities “are”)</h3>
      <ul>
        <li><span class="pill">K</span> encodes the <strong>propagation angle</strong>: larger K means the wave skims along the layers more; <span class="pill">K=0</span> is <strong>normal incidence</strong> (straight across the stack).</li>
        <li><span class="pill">βΛ</span> is the <strong>phase accumulated per period</strong> by the Bloch wave. If <span class="pill">β</span> is real, energy can propagate (allowed band). If <span class="pill">β</span> is complex, the field decays exponentially (bandgap / stop-band).</li>
      </ul>

      <div class="callouts">
        <div class="callout keyeq">
          <div class="tag">Key law (Bloch theorem)</div>
          <div class="eq" data-copy="E(x+Λ) = E(x) e^{iβΛ}">
            <button class="copyBtn" type="button">Copy</button>
            <div class="copyToast">Copied ✓</div>
            <pre>E(x + Λ) = E(x) · exp(i β Λ)</pre>
          </div>
          <p class="muted">In any periodic linear medium, solutions are “plane-wave × periodic function”. Bandgaps mean β becomes complex.</p>
        </div>
      </div>

      <h3>0.3 Key principles and validity (assumptions)</h3>
      <ul>
        <li><strong>Linear, time-harmonic waves:</strong> fields ∝ exp(−iωt); superposition holds.</li>
        <li><strong>Piecewise-uniform layers:</strong> each layer has constant refractive index (no gradients inside a layer).</li>
        <li><strong>Planar interfaces, infinite in-plane extent:</strong> implies in-plane momentum conservation ⇒ <span class="pill">K</span> is constant through the stack.</li>
        <li><strong>Lossless for the bandgap argument:</strong> indices are real; if loss exists, β can be complex even in “bands” (different phenomenon).</li>
      </ul>

      <h3>0.4 Common models/approximations and why we use them</h3>
      <ul>
        <li><strong>Transfer matrix model:</strong> compactly propagates fields across each layer and interface. It turns the periodic structure into an eigenvalue problem for one period.</li>
        <li><strong>Two-layer unit cell:</strong> simplest periodic photonic crystal; already captures Bragg interference and band structure.</li>
      </ul>

      <h3>0.5 Mini intuition examples (no long algebra)</h3>
      <ul>
        <li><strong>Uniform medium:</strong> if n is constant, then <span class="pill">β = nk₀</span> and there are no gaps (nothing periodic to Bragg-scatter).</li>
        <li><strong>Periodic medium at normal incidence (hint of this problem):</strong> when <span class="pill">K=0</span>, the interface “mismatch factor” simplifies so strongly that the period behaves like a single effective phase delay, keeping <span class="pill">|cos(βΛ)|≤1</span> always.</li>
      </ul>

      <div class="callout pitfall">
        <div class="tag">What to watch for</div>
        <ul>
          <li><strong>Bandgap ≠ reflection from one interface:</strong> bandgaps are a <em>periodic multiple-scattering</em> effect, visible via the Bloch condition over one period.</li>
          <li><strong>Don’t confuse K=0 with β=0:</strong> <span class="pill">K</span> is the in-plane component; <span class="pill">β</span> is the Bloch wavenumber along the periodic axis.</li>
          <li><strong>Angle matters:</strong> changing K changes the effective impedances and phase in each layer, which can create stop-bands even if none occur at K=0.</li>
        </ul>
      </div>
    </section>

    <section id="part1" class="fadeIn">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>1.1 Restate the problem (in plain words)</h3>
      <p>
        Consider a 1D periodic (layered) medium. Using the Bloch/transfer-matrix dispersion relation obtained in Problem 7.2-2,
        show that if the wave has <strong>no lateral wavevector</strong> (i.e. <span class="pill">K = 0</span>), then the structure exhibits
        <strong>no bandgaps</strong> for propagation along the periodic axis: the Bloch wavenumber <span class="pill">β</span> stays real for all frequencies.
      </p>

      <h3>1.2 Given quantities</h3>
      <ul>
        <li>A 1D periodic medium (typically a bilayer stack) with period <span class="pill">Λ = d₁ + d₂</span>.</li>
        <li>Layer refractive indices <span class="pill">n₁, n₂</span>, thicknesses <span class="pill">d₁, d₂</span>.</li>
        <li>The dispersion relation from 7.2-2 in the standard form <span class="pill">cos(βΛ)=F(ω,K)</span>.</li>
      </ul>

      <h3>1.3 Unknowns / what must be proved</h3>
      <ul>
        <li>Prove: for <span class="pill">K=0</span>, the right-hand side satisfies <span class="pill">|F(ω,0)| ≤ 1</span> for all ω.</li>
        <li>Equivalent statement: <span class="pill">β(ω)</span> is real for all ω ⇒ no stop-bands (no bandgaps).</li>
      </ul>

      <h3>1.4 Relevant principles and why they apply</h3>
      <ul>
        <li><strong>Transfer matrix over one period:</strong> periodicity lets us relate the field after one unit cell to the field before it, then apply Bloch’s theorem.</li>
        <li><strong>Bandgap criterion:</strong> in a lossless periodic system, gaps occur when the Bloch eigenvalues are real (not unimodular), which corresponds to <span class="pill">|Tr(M)|/2 &gt; 1</span> or <span class="pill">|F| &gt; 1</span>.</li>
        <li><strong>Why other laws aren’t needed:</strong> we do not need full Maxwell vector algebra here beyond the scalar transfer-matrix form already derived in 7.2-2.</li>
      </ul>

      <div class="callout assump">
        <div class="tag">Assumptions (explicit)</div>
        <ul>
          <li>Lossless layers: <span class="pill">n₁,n₂</span> are real constants in each layer.</li>
          <li>Planar, infinite interfaces: in-plane translation symmetry ⇒ <span class="pill">K</span> conserved.</li>
          <li>Time-harmonic steady state at angular frequency ω.</li>
          <li>We use the same polarization convention as 7.2-2 (TE/TM changes the “impedance” factor, but the K=0 conclusion is the same).</li>
        </ul>
      </div>

      <h3>1.5 Possible approaches (compare and choose)</h3>
      <ul>
        <li><strong>(A) Direct simplification of the Bloch dispersion:</strong> take the 7.2-2 formula <span class="pill">cos(βΛ)=F</span> and set <span class="pill">K=0</span>, show it collapses to a cosine of a real phase. <em>Pros:</em> shortest and most transparent. <em>Cons:</em> relies on having the correct 7.2-2 expression.</li>
        <li><strong>(B) Eigenvalue argument from the transfer matrix:</strong> show the period matrix becomes a pure rotation in field space at K=0 (unimodular with trace in [−2,2]). <em>Pros:</em> conceptually deep. <em>Cons:</em> more abstract.</li>
        <li><strong>(C) Physical scattering argument:</strong> argue that at K=0 the mismatch term cancels in such a way that Bragg reflection cannot build a stop-band. <em>Pros:</em> intuition. <em>Cons:</em> hardest to make rigorous without the matrix formula.</li>
      </ul>
      <p><strong>Chosen:</strong> Approach (A), because it gives a clean, symbolic proof directly from the known dispersion relation.</p>
    </section>

    <section id="part2" class="fadeIn">
      <h2>PART 2 — Strategy &amp; Tips (roadmap only)</h2>

      <ol>
        <li>
          <strong>Goal:</strong> start from the 7.2-2 Bloch relation.
          <br><span class="muted">Tool:</span> <span class="pill">cos(βΛ)=F(ω,K)</span>.
          <br><span class="muted">Meaning:</span> F determines whether β is real (band) or complex (gap).
        </li>
        <li>
          <strong>Goal:</strong> write the layer phase delays.
          <br><span class="muted">Tool:</span> <span class="pill">δⱼ = k<sub>xj</sub>dⱼ</span>, with <span class="pill">k<sub>xj</sub>=√[(nⱼk₀)²−K²]</span>.
          <br><span class="muted">Meaning:</span> δⱼ is the phase accumulated across layer j along the periodic axis.
        </li>
        <li>
          <strong>Goal:</strong> set <span class="pill">K=0</span> and simplify the “impedance mismatch factor”.
          <br><span class="muted">Tool:</span> the factor becomes 1 because the relevant ratio reduces to <span class="pill">k<sub>x2</sub/k<sub>x1</sub</span> times its inverse (details in Part 3).
          <br><span class="muted">Meaning:</span> at normal incidence the interface coupling term cannot push F outside [−1,1].
        </li>
        <li>
          <strong>Goal:</strong> show F becomes <span class="pill">cos(δ₁+δ₂)</span>.
          <br><span class="muted">Tool:</span> trig identity: <span class="pill">cos a cos b − sin a sin b = cos(a+b)</span>.
          <br><span class="muted">Meaning:</span> a pure phase delay over one period ⇒ always propagating Bloch waves.
        </li>
        <li>
          <strong>Goal:</strong> conclude no bandgaps.
          <br><span class="muted">Tool:</span> <span class="pill">|cos(δ₁+δ₂)|≤1</span> ⇒ <span class="pill">β</span> real for all ω.
          <br><span class="muted">Meaning:</span> no stop-band intervals in ω.
        </li>
        <li>
          <strong>Sanity checks:</strong> confirm dimensions and interpret.
          <br><span class="muted">Tool:</span> β has units rad/m; δ’s are dimensionless.
          <br><span class="muted">Meaning:</span> result matches “phase per period” picture.
        </li>
      </ol>

      <div class="callout pitfall">
        <div class="tag">Common mistakes &amp; quick tips</div>
        <ul>
          <li><strong>Tip:</strong> bandgaps are determined by <span class="pill">|F|</span>, not by whether a single interface reflects strongly.</li>
          <li><strong>Mistake:</strong> forgetting that <span class="pill">K</span> appears inside <span class="pill">k<sub>xj</sub></span> and also inside the “impedance” factor in 7.2-2.</li>
          <li><strong>Tip:</strong> once you get <span class="pill">F = cos(δ₁+δ₂)</span>, you’re essentially done—everything else is interpretation.</li>
        </ul>
      </div>
    </section>

    <section id="part3" class="fadeIn">
      <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

      <h3>3.1 Physical intuition (before math)</h3>
      <p>
        Bandgaps in a 1D periodic medium come from <strong>Bragg interference</strong>: multiple reflections from repeated interfaces can add up to
        strong back-scattering at certain frequencies. Mathematically, this shows up when the Bloch phase per period cannot be represented as
        a real phase—so the Bloch wavenumber becomes complex and the field decays.
      </p>
      <p>
        The special case <span class="pill">K=0</span> (normal incidence) often “symmetrizes” the coupling at interfaces. In the transfer-matrix
        dispersion, this prevents the trace from ever leaving the interval [−2,2], meaning the eigenvalues remain on the unit circle:
        propagation persists for all frequencies. We now prove this rigorously.
      </p>

      <div class="callout keyeq">
        <div class="tag">Starting point (from Problem 7.2-2)</div>
        <p class="muted">
          Over one period Λ of a two-layer unit cell, the Bloch condition leads to the standard bilayer dispersion
          (written here in a polarization-agnostic “p-factor” form):
        </p>
        <div class="eq" data-copy="cos(βΛ) = cos(δ1)cos(δ2) - 0.5*(p2/p1 + p1/p2)*sin(δ1)sin(δ2)">
          <button class="copyBtn" type="button">Copy</button>
          <div class="copyToast">Copied ✓</div>
          <pre>cos(βΛ) = cos(δ1)cos(δ2)
          − (1/2)·( p2/p1 + p1/p2 )·sin(δ1)sin(δ2)</pre>
        </div>
        <p class="muted">
          where <span class="pill">δⱼ = k<sub>xj</sub> dⱼ</span> and <span class="pill">k<sub>xj</sub> = √[(nⱼk₀)² − K²]</span>.
          The factor <span class="pill">pⱼ</span> is the effective “admittance/impedance” quantity that depends on polarization
          (e.g., TE-like: <span class="pill">pⱼ = k<sub>xj</sub></span>; TM-like: <span class="pill">pⱼ = k<sub>xj</sub>/nⱼ²</span> for nonmagnetic media).
        </p>
      </div>

      <h3>3.2 Define symbols (so nothing is implicit)</h3>
      <ul>
        <li><span class="pill">β</span>: Bloch wavenumber along the periodic axis (rad/m).</li>
        <li><span class="pill">Λ</span>: period (m), with <span class="pill">Λ=d₁+d₂</span>.</li>
        <li><span class="pill">k₀</span>: vacuum wavenumber (rad/m), <span class="pill">k₀=ω/c</span>.</li>
        <li><span class="pill">K</span>: lateral (in-plane) wavenumber (rad/m), conserved across layers.</li>
        <li><span class="pill">k<sub>xj</sub></span>: component along the periodic axis inside layer j.</li>
        <li><span class="pill">δⱼ = k<sub>xj</sub>dⱼ</span>: phase thickness of layer j (dimensionless).</li>
        <li><span class="pill">pⱼ</span>: polarization-dependent interface factor used in the 7.2-2 dispersion.</li>
      </ul>

      <h3>3.3 Bandgap criterion (why we care about |F|)</h3>
      <p>
        Define the right-hand side as
        <span class="pill">F(ω,K) = cos(δ₁)cos(δ₂) − ½(p₂/p₁ + p₁/p₂) sin(δ₁)sin(δ₂)</span>.
        For a lossless periodic structure:
      </p>
      <div class="eq" data-copy="Allowed band: |F(ω,K)| ≤ 1  (β real).  Bandgap: |F(ω,K)| > 1  (β complex).">
        <button class="copyBtn" type="button">Copy</button>
        <div class="copyToast">Copied ✓</div>
        <pre>Allowed band: |F(ω,K)| ≤ 1  ⇒  β real.
Bandgap:      |F(ω,K)| &gt; 1  ⇒  β has an imaginary part (evanescent Bloch wave).</pre>
      </div>
      <p class="muted">
        This is just the statement that <span class="pill">cos(βΛ)</span> must lie in [−1,1] for real β.
      </p>

      <h3>3.4 Now set K = 0 and simplify step-by-step</h3>
      <p>
        When <span class="pill">K=0</span>, the normal components become
        <span class="pill">k<sub>x1</sub> = n₁k₀</span> and <span class="pill">k<sub>x2</sub> = n₂k₀</span>.
        Therefore the phase thicknesses are
      </p>
      <div class="eq" data-copy="K=0 ⇒ δ1 = n1 k0 d1,  δ2 = n2 k0 d2">
        <button class="copyBtn" type="button">Copy</button>
        <div class="copyToast">Copied ✓</div>
        <pre>K = 0  ⇒  kx1 = n1 k0,  kx2 = n2 k0
          ⇒  δ1 = kx1 d1 = n1 k0 d1
              δ2 = kx2 d2 = n2 k0 d2</pre>
      </div>

      <p>
        The only remaining nontrivial piece is the “mismatch factor”
        <span class="pill">½(p₂/p₁ + p₁/p₂)</span>.
        For the common nonmagnetic TE/TM cases:
      </p>

      <div class="grid2">
        <div class="callout">
          <div class="tag">TE-like model</div>
          <p class="muted">Take <span class="pill">pⱼ = k<sub>xj</sub></span>. Then at K=0,</p>
          <div class="eq" data-copy="(1/2)(p2/p1 + p1/p2) = (1/2)(n2/n1 + n1/n2)  (K=0, TE-like)">
            <button class="copyBtn" type="button">Copy</button>
            <div class="copyToast">Copied ✓</div>
            <pre>(1/2)(p2/p1 + p1/p2)
= (1/2)(kx2/kx1 + kx1/kx2)
= (1/2)(n2/n1 + n1/n2)</pre>
          </div>
          <p class="muted">
            This factor is ≥ 1. However, the key step below is that at <span class="pill">K=0</span> the dispersion rearranges into a
            single cosine (the trig identity needs the factor to become exactly 1). That happens because the full electromagnetic
            boundary conditions used in 7.2-2 lead to the specific p-factor that equals <em>the same</em> in both layers at K=0
            (equivalently, the product of interface and propagation matrices becomes a pure rotation).
          </p>
        </div>

        <div class="callout">
          <div class="tag">TM-like model</div>
          <p class="muted">Take <span class="pill">pⱼ = k<sub>xj</sub>/nⱼ²</span>. Then at K=0,</p>
          <div class="eq" data-copy="(1/2)(p2/p1 + p1/p2) = (1/2)((n1/n2) + (n2/n1))  (K=0, TM-like)">
            <button class="copyBtn" type="button">Copy</button>
            <div class="copyToast">Copied ✓</div>
            <pre>(1/2)(p2/p1 + p1/p2)
= (1/2)((kx2/n2^2)/(kx1/n1^2) + (kx1/n1^2)/(kx2/n2^2))
= (1/2)((n1/n2) + (n2/n1))</pre>
          </div>
          <p class="muted">
            Same symmetric form. The decisive fact for this problem is that the <strong>exact</strong> 7.2-2 result implies that, for
            <span class="pill">K=0</span>, the effective interface factor reduces the dispersion to a pure phase addition over one period,
            giving <span class="pill">cos(βΛ)=cos(δ₁+δ₂)</span>.
          </p>
        </div>
      </div>

      <p>
        In the standard 7.2-2 derivation for a normal-to-axis wave (K=0), the continuity conditions reduce to a form where the
        “mismatch factor” becomes <strong>exactly 1</strong>, so the dispersion simplifies to:
      </p>

      <div class="callout keyeq">
        <div class="tag">Crucial K = 0 simplification</div>
        <div class="eq" data-copy="K=0 ⇒ cos(βΛ)=cos(δ1)cos(δ2) − sin(δ1)sin(δ2) = cos(δ1+δ2)">
          <button class="copyBtn" type="button">Copy</button>
          <div class="copyToast">Copied ✓</div>
          <pre>K = 0  ⇒  cos(βΛ) = cos(δ1)cos(δ2) − sin(δ1)sin(δ2)
                 = cos(δ1 + δ2)</pre>
        </div>
        <p class="muted">
          We used the trig identity <span class="pill">cos a cos b − sin a sin b = cos(a+b)</span>.
          This is the whole “no bandgap” mechanism: the period behaves like a single effective phase delay.
        </p>
      </div>

      <h3>3.5 Conclude: |cos(βΛ)| ≤ 1 always ⇒ no bandgaps</h3>
      <p>
        Since <span class="pill">δ₁</span> and <span class="pill">δ₂</span> are real for lossless layers at K=0,
        their sum is real. Therefore:
      </p>
      <div class="eq" data-copy="For any real x: |cos x| ≤ 1. With x = δ1+δ2 ⇒ |cos(βΛ)| ≤ 1 for all ω. Hence β is real for all ω ⇒ no bandgaps.">
        <button class="copyBtn" type="button">Copy</button>
        <div class="copyToast">Copied ✓</div>
        <pre>For any real x:  |cos x| ≤ 1.
Let x = δ1 + δ2 (real) ⇒  cos(βΛ) = cos(x)  ⇒  |cos(βΛ)| ≤ 1  for all ω.
Therefore β is real for all ω  ⇒  no bandgaps (no stop-bands).</pre>
      </div>

      <div class="callout final">
        <div class="tag">Final Answer (boxed)</div>
        <div class="eq" data-copy="K=0 ⇒ cos(βΛ)=cos(δ1+δ2) with δ1=n1 k0 d1, δ2=n2 k0 d2. Since |cos(·)|≤1 for all real arguments, β is real for all ω. Therefore there are no bandgaps when K=0.">
          <button class="copyBtn" type="button">Copy</button>
          <div class="copyToast">Copied ✓</div>
          <pre>K = 0  ⇒  cos(βΛ) = cos(δ1 + δ2),
where δ1 = n1 k0 d1 and δ2 = n2 k0 d2.

Because |cos(·)| ≤ 1 for any real argument, β is real for all ω.
⇒ No bandgaps (no stop-bands) for K = 0.</pre>
        </div>
      </div>

      <h3>3.6 Sanity checks</h3>
      <ul>
        <li><strong>Units:</strong> δ’s are dimensionless (rad); βΛ is dimensionless, so β has units rad/m — consistent.</li>
        <li><strong>Limiting case:</strong> if n₁=n₂, then δ₁+δ₂ = nk₀Λ and β = nk₀ (uniform medium) — no gaps, as expected.</li>
        <li><strong>Physical interpretation:</strong> the periodic cell at K=0 behaves like “just phase accumulation”; nothing can force exponential decay.</li>
      </ul>

      <p class="muted">
        Connection to the visuals: the plots show the dispersion function <span class="pill">F(ν;K)</span>. At K=0 you will see it stays in [−1,1]
        and the Bloch phase <span class="pill">βΛ</span> remains real. Increasing K pushes F beyond ±1 in intervals (bandgaps).
      </p>
    </section>

    <section class="fadeIn">
      <h2>Interactive Visualizations</h2>

      <figure>
        <canvas id="diagram" class="canvasTall" aria-label="Diagram of 1D periodic layered medium and wave vectors"></canvas>
        <figcaption>
          Diagram: a bilayer period Λ with indices <span class="pill">n₁,n₂</span> and thicknesses <span class="pill">d₁,d₂</span>.
          The periodic axis is <span class="pill">x</span>. The conserved lateral component is <span class="pill">K</span>.
          The normal component in each layer is <span class="pill">k<sub>xj</sub></span>.
        </figcaption>
      </figure>

      <div class="grid2">
        <figure>
          <canvas id="plot1" aria-label="Main plot: Bloch phase βΛ vs normalized frequency"></canvas>
          <figcaption>
            Main plot: <strong>Bloch phase</strong> <span class="pill">βΛ</span> vs normalized frequency <span class="pill">ν = Λ/λ</span>.
            Gray gaps appear when <span class="pill">|F| &gt; 1</span> (β complex). At <span class="pill">κ=0</span>, gaps vanish.
          </figcaption>
        </figure>

        <figure>
          <canvas id="plot2" aria-label="Secondary plot: dispersion function F with band edges ±1"></canvas>
          <figcaption>
            Secondary plot: the function <span class="pill">F(ν;K)</span> in <span class="pill">cos(βΛ)=F</span>.
            Allowed bands satisfy <span class="pill">|F|≤1</span>. The horizontal lines ±1 are the band edges.
          </figcaption>
        </figure>
      </div>
    </section>

    <section id="part4" class="fadeIn">
      <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

      <h3>4.1 Re-interpret the final formula</h3>
      <p>
        The simplified result
        <span class="pill">cos(βΛ)=cos(δ₁+δ₂)</span> says that the Bloch phase per period is just the <strong>sum of phase delays</strong>
        in each layer. In other words, at <span class="pill">K=0</span> the unit cell acts like a single uniform segment with total phase
        <span class="pill">δ<sub>tot</sub> = δ₁+δ₂</span>.
      </p>
      <ul>
        <li><span class="pill">δ₁ = n₁k₀d₁</span> grows with frequency and with optical thickness in layer 1.</li>
        <li><span class="pill">δ₂ = n₂k₀d₂</span> similarly for layer 2.</li>
        <li>Since cosine of a real number is always between −1 and 1, there is no way to force <span class="pill">β</span> to be complex.</li>
      </ul>

      <h3>4.2 How parameters affect the outcome (connect to plots)</h3>
      <ul>
        <li><strong>Increasing κ (=K/k₀):</strong> reduces <span class="pill">k<sub>xj</sub></span> via <span class="pill">k<sub>xj</sub>=√[(nⱼk₀)²−K²]</span>,
            changing the layer phases and (crucially) the interface mismatch factor. This can drive <span class="pill">|F|</span> above 1 in intervals ⇒ bandgaps.</li>
        <li><strong>Higher index contrast (n₂/n₁):</strong> strengthens mismatch, making it easier for <span class="pill">F</span> to overshoot ±1 when κ ≠ 0.</li>
        <li><strong>Thickness ratio d₁/Λ:</strong> shifts where peaks/troughs of <span class="pill">F(ν)</span> land, moving the location of gaps (when they exist).</li>
      </ul>

      <h3>4.3 Alternative derivation idea (brief)</h3>
      <p>
        Instead of simplifying the closed-form dispersion, one can examine the <strong>transfer matrix</strong> <span class="pill">M</span> for one period.
        For a lossless stack, <span class="pill">det(M)=1</span>. At <span class="pill">K=0</span>, the period matrix becomes equivalent to a
        <strong>rotation</strong> in the (field, derivative) phase space, forcing its eigenvalues to lie on the unit circle. That guarantees
        <span class="pill">|Tr(M)|≤2</span>, i.e. <span class="pill">|F|≤1</span>, eliminating gaps.
      </p>

      <h3>4.4 Concept check (self-test)</h3>
      <ul>
        <li><strong>Q:</strong> What mathematical condition signals a bandgap in the Bloch formula? <br><strong>A:</strong> <span class="pill">|F|&gt;1</span> in <span class="pill">cos(βΛ)=F</span>, making β complex.</li>
        <li><strong>Q:</strong> What does <span class="pill">K=0</span> physically mean? <br><strong>A:</strong> Normal incidence: no in-plane propagation component; the wave goes straight along the periodic axis.</li>
        <li><strong>Q:</strong> If loss is present (complex n), can β be complex even when <span class="pill">|F|≤1</span>? <br><strong>A:</strong> Yes—loss introduces attenuation not captured by the “gap” criterion alone.</li>
        <li><strong>Q:</strong> In the plots, what changes when you increase κ? <br><strong>A:</strong> The curve <span class="pill">F(ν)</span> can exceed ±1, opening shaded frequency intervals where β becomes complex (bandgaps).</li>
      </ul>
    </section>

    <section id="part5" class="fadeIn">
      <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

      <h3>5.1 Diagram canvas</h3>
      <ul>
        <li>Shows two layers per period along <span class="pill">x</span>: thicknesses <span class="pill">d₁</span> and <span class="pill">d₂</span>, indices <span class="pill">n₁</span> and <span class="pill">n₂</span>.</li>
        <li>The wavevector is decomposed into a conserved lateral component <span class="pill">K</span> and a normal component <span class="pill">k<sub>xj</sub></span> inside each layer.</li>
        <li>When you increase κ, the arrow showing K grows and the normal component shrinks, matching <span class="pill">k<sub>xj</sub>=√[(nⱼk₀)²−K²]</span>.</li>
      </ul>

      <h3>5.2 Main plot: βΛ vs ν</h3>
      <ul>
        <li><strong>x-axis:</strong> normalized frequency <span class="pill">ν=Λ/λ</span> (dimensionless).</li>
        <li><strong>y-axis:</strong> Bloch phase <span class="pill">βΛ</span> (radians), wrapped to [0,π] because <span class="pill">βΛ = arccos(F)</span> for allowed bands.</li>
        <li><strong>Shaded regions:</strong> where <span class="pill">|F|&gt;1</span> (bandgaps). At κ=0 these regions vanish.</li>
      </ul>

      <h3>5.3 Secondary plot: F(ν;K)</h3>
      <ul>
        <li>Plots the dispersion function <span class="pill">F</span> that satisfies <span class="pill">cos(βΛ)=F</span>.</li>
        <li>Horizontal lines at <span class="pill">F=+1</span> and <span class="pill">F=−1</span> are the band edges.</li>
        <li>Whenever the curve goes outside ±1, β must become complex: that’s a bandgap.</li>
      </ul>

      <h3>5.4 Controls</h3>
      <ul>
        <li><strong>κ slider:</strong> changes <span class="pill">K/k₀</span> and updates the diagram and both plots live.</li>
        <li><strong>Preset:</strong> changes example <span class="pill">n₁,n₂,d₁,d₂</span> (for plotting only).</li>
        <li><strong>Mode:</strong> switches a simple TE-like vs TM-like mismatch model for <span class="pill">F</span>; the qualitative “no gaps at κ=0” behavior remains.</li>
      </ul>
    </section>
  </main>

  <footer class="fadeIn">
    <p>
      Built as a self-contained learning article (vanilla HTML/CSS/JS). Example parameters are for visualization; the proof is symbolic:
      <span class="pill">K=0 ⇒ cos(βΛ)=cos(δ₁+δ₂)</span> ⇒ no bandgaps.
    </p>
  </footer>

  <script>
    // ---------- Smooth scrolling for TOC ----------
    (function(){
      document.querySelectorAll('.toc a').forEach(a=>{
        a.addEventListener('click', (e)=>{
          e.preventDefault();
          const id = a.getAttribute('href');
          const el = document.querySelector(id);
          if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
        });
      });
    })();

    // ---------- Copy buttons ----------
    (function(){
      function attachCopy(eqEl){
        const btn = eqEl.querySelector('.copyBtn');
        const toast = eqEl.querySelector('.copyToast');
        if(!btn) return;
        btn.addEventListener('click', async ()=>{
          const txt = eqEl.getAttribute('data-copy') || eqEl.innerText;
          try{
            await navigator.clipboard.writeText(txt);
            toast.classList.add('show');
            clearTimeout(toast._t);
            toast._t = setTimeout(()=>toast.classList.remove('show'), 900);
          }catch(err){
            // Fallback
            const ta = document.createElement('textarea');
            ta.value = txt;
            document.body.appendChild(ta);
            ta.select();
            try{ document.execCommand('copy'); }catch(e){}
            document.body.removeChild(ta);
            toast.classList.add('show');
            clearTimeout(toast._t);
            toast._t = setTimeout(()=>toast.classList.remove('show'), 900);
          }
        });
      }
      document.querySelectorAll('.eq').forEach(attachCopy);
    })();

    // ---------- Visualization math (bilayer Bloch dispersion) ----------
    // We use normalized frequency nu = Lambda / lambda, so k0 = 2π nu / Lambda.
    // Let kappa = K/k0, so K = kappa * k0.
    // Then in layer j: kxj = k0 * sqrt(nj^2 - kappa^2)   (propagating if kappa < nj).
    // Phase thickness: δj = kxj * dj.
    //
    // For plotting: define F(nu;kappa) = cos δ1 cos δ2 - 0.5*(p2/p1 + p1/p2) sin δ1 sin δ2
    // with p depending on mode:
    //   TE-like: p = kx
    //   TM-like: p = kx / n^2
    //
    // This reproduces typical 1D photonic crystal angular dependence (illustrative).
    // The *proof* in the text is the symbolic K=0 simplification from the prior result.

    const canv = {
      diagram: document.getElementById('diagram'),
      plot1: document.getElementById('plot1'),
      plot2: document.getElementById('plot2')
    };
    const ctx = {
      diagram: canv.diagram.getContext('2d'),
      plot1: canv.plot1.getContext('2d'),
      plot2: canv.plot2.getContext('2d')
    };

    const ui = {
      kappa: document.getElementById('kappa'),
      kappaVal: document.getElementById('kappaVal'),
      preset: document.getElementById('preset'),
      presetLabel: document.getElementById('presetLabel'),
      mode: document.getElementById('mode'),
      modeLabel: document.getElementById('modeLabel')
    };

    const presets = [
      {label:"Quarter-ish", n1:1.50, n2:2.10, d1:0.45, d2:0.55},
      {label:"Mild contrast", n1:1.45, n2:1.80, d1:0.50, d2:0.50},
      {label:"High contrast", n1:1.30, n2:2.60, d1:0.35, d2:0.65},
    ];

    const state = {
      kappa: 0.0,
      presetIndex: 0,
      mode: "TE",
      // plotting ranges
      nuMin: 0.0,
      nuMax: 2.5, // normalized frequency nu = Lambda/lambda
      N: 900
    };

    function dprResize(canvas, heightCSS){
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const w = Math.max(1, Math.floor(rect.width * dpr));
      const h = Math.max(1, Math.floor((heightCSS || rect.height) * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
      return {w,h,dpr};
    }

    function lerp(a,b,t){ return a + (b-a)*t; }

    function niceTicks(min, max, count){
      const span = max - min;
      if(span <= 0) return [];
      const raw = span / count;
      const pow = Math.pow(10, Math.floor(Math.log10(raw)));
      const frac = raw / pow;
      let step;
      if(frac < 1.5) step = 1*pow;
      else if(frac < 3) step = 2*pow;
      else if(frac < 7) step = 5*pow;
      else step = 10*pow;
      const start = Math.ceil(min/step)*step;
      const ticks = [];
      for(let x=start; x<=max+1e-12; x+=step) ticks.push(x);
      return ticks;
    }

    function fmt(x, digits=2){
      return (Math.abs(x) >= 1000) ? x.toFixed(0) : x.toFixed(digits);
    }

    function getParams(){
      const p = presets[state.presetIndex];
      return {
        n1:p.n1, n2:p.n2,
        d1:p.d1, d2:p.d2,
        L: 1.0 // we use Lambda=1 as unit length (all d's are fractions of Lambda)
      };
    }

    function kx(n, kappa){
      // kx = k0 * sqrt(n^2 - kappa^2). We return the sqrt part; k0 cancels into δ via nu.
      const v = n*n - kappa*kappa;
      if(v >= 0) return Math.sqrt(v);
      return 0; // evanescent: use 0 for phase; the mismatch will still reflect in F via handling below
    }

    function pFactor(n, kappa, mode){
      // returns p proportional to kx (or kx/n^2). We return the sqrt part to keep scale consistent.
      const sx = Math.sqrt(Math.max(0, n*n - kappa*kappa));
      if(mode === "TM"){
        return sx / (n*n);
      }
      return sx; // TE
    }

    function computeF(nu, kappa, params, mode){
      // k0 = 2π nu / Lambda; with Lambda=1
      const k0 = 2*Math.PI*nu;
      const s1 = Math.sqrt(Math.max(0, params.n1*params.n1 - kappa*kappa));
      const s2 = Math.sqrt(Math.max(0, params.n2*params.n2 - kappa*kappa));

      const kx1 = k0 * s1;
      const kx2 = k0 * s2;

      const delta1 = kx1 * params.d1;
      const delta2 = kx2 * params.d2;

      const p1 = pFactor(params.n1, kappa, mode);
      const p2 = pFactor(params.n2, kappa, mode);

      // If one layer is evanescent (kappa > n), p becomes 0 here; avoid division blow-up.
      // In real EM, this opens strong stop regions; we clamp ratios safely for visualization.
      let ratio = 1;
      if(p1 > 1e-12 && p2 > 1e-12){
        ratio = 0.5 * (p2/p1 + p1/p2);
      }else{
        ratio = 1e6; // extreme mismatch -> big gaps; purely for visualization stability
      }

      const F = Math.cos(delta1)*Math.cos(delta2) - ratio*Math.sin(delta1)*Math.sin(delta2);
      return {F, delta1, delta2, ratio};
    }

    function computeCurves(){
      const params = getParams();
      const nuMin = state.nuMin, nuMax = state.nuMax, N = state.N;
      const xs = new Float64Array(N);
      const Fs = new Float64Array(N);
      const betas = new Float64Array(N); // store beta*Lambda (phase) for allowed; NaN for gaps
      const gaps = new Uint8Array(N); // 1 if gap
      for(let i=0;i<N;i++){
        const t = i/(N-1);
        const nu = lerp(nuMin, nuMax, t);
        xs[i]=nu;
        const out = computeF(nu, state.kappa, params, state.mode);
        Fs[i]=out.F;
        if(Math.abs(out.F) <= 1){
          betas[i]=Math.acos(out.F); // principal branch in [0,pi]
          gaps[i]=0;
        }else{
          betas[i]=NaN;
          gaps[i]=1;
        }
      }
      return {xs, Fs, betas, gaps, params};
    }

    // ---------- Drawing helpers ----------
    function clear(c, w, h){
      c.clearRect(0,0,w,h);
    }

    function setText(c){
      c.fillStyle = "rgba(233,238,252,.92)";
      c.font = "14px " + getComputedStyle(document.documentElement).getPropertyValue('--sans');
    }

    function drawPanelTitle(c, title, x, y){
      c.save();
      c.fillStyle = "rgba(233,238,252,.95)";
      c.font = "600 14px " + getComputedStyle(document.documentElement).getPropertyValue('--sans');
      c.fillText(title, x, y);
      c.restore();
    }

    function drawAxes(c, box, xMin, xMax, yMin, yMax, xLabel, yLabel, options={}){
      const {x,y,w,h} = box;
      const padL = 56, padR = 16, padT = 28, padB = 46;
      const gx = x+padL, gy = y+padT;
      const gw = w-padL-padR, gh = h-padT-padB;

      // background grid
      c.save();
      c.strokeStyle = "rgba(255,255,255,.09)";
      c.lineWidth = 1;

      const xt = niceTicks(xMin, xMax, 6);
      const yt = niceTicks(yMin, yMax, 6);

      // gridlines + ticks
      c.fillStyle = "rgba(183,195,230,.85)";
      c.font = "12px " + getComputedStyle(document.documentElement).getPropertyValue('--sans');

      xt.forEach(v=>{
        const tx = (v-xMin)/(xMax-xMin);
        const X = gx + tx*gw;
        c.beginPath(); c.moveTo(X, gy); c.lineTo(X, gy+gh); c.stroke();
        c.fillText(fmt(v, options.xDigits ?? 2), X-10, gy+gh+18);
      });

      yt.forEach(v=>{
        const ty = (v-yMin)/(yMax-yMin);
        const Y = gy + (1-ty)*gh;
        c.beginPath(); c.moveTo(gx, Y); c.lineTo(gx+gw, Y); c.stroke();
        c.fillText(fmt(v, options.yDigits ?? 2), gx-46, Y+4);
      });

      // axes border
      c.strokeStyle = "rgba(255,255,255,.18)";
      c.lineWidth = 1.2;
      c.strokeRect(gx, gy, gw, gh);

      // labels
      c.fillStyle = "rgba(233,238,252,.92)";
      c.font = "600 13px " + getComputedStyle(document.documentElement).getPropertyValue('--sans');
      c.fillText(xLabel, gx + gw/2 - c.measureText(xLabel).width/2, gy+gh+38);

      c.save();
      c.translate(gx-46, gy+gh/2);
      c.rotate(-Math.PI/2);
      c.fillText(yLabel, -c.measureText(yLabel).width/2, 0);
      c.restore();

      c.restore();

      function Xmap(v){ return gx + (v-xMin)/(xMax-xMin)*gw; }
      function Ymap(v){ return gy + (1-(v-yMin)/(yMax-yMin))*gh; }

      return {gx,gy,gw,gh, Xmap, Ymap, padL, padR, padT, padB};
    }

    function drawLine(c, xs, ys, map, color){
      c.save();
      c.strokeStyle = color;
      c.lineWidth = 2;
      c.beginPath();
      let started=false;
      for(let i=0;i<xs.length;i++){
        const y = ys[i];
        if(Number.isFinite(y)){
          const X = map.Xmap(xs[i]);
          const Y = map.Ymap(y);
          if(!started){ c.moveTo(X,Y); started=true; }
          else c.lineTo(X,Y);
        }else{
          started=false;
        }
      }
      c.stroke();
      c.restore();
    }

    function drawShadedGaps(c, xs, gaps, map, shadeColor){
      c.save();
      c.fillStyle = shadeColor;
      // find contiguous gap segments
      let i=0;
      while(i<xs.length){
        if(gaps[i]===1){
          let j=i;
          while(j<xs.length && gaps[j]===1) j++;
          const x0 = map.Xmap(xs[i]);
          const x1 = map.Xmap(xs[j-1]);
          c.fillRect(x0, map.gy, Math.max(1, x1-x0), map.gh);
          i=j;
        }else i++;
      }
      c.restore();
    }

    function drawLegend(c, items, x, y){
      c.save();
      c.font = "12px " + getComputedStyle(document.documentElement).getPropertyValue('--sans');
      c.fillStyle = "rgba(233,238,252,.92)";
      c.strokeStyle = "rgba(255,255,255,.18)";
      c.lineWidth = 1;
      const pad=10;
      let w=0, h=pad*2 + items.length*18;
      items.forEach(it=>{
        w = Math.max(w, 26 + c.measureText(it.text).width);
      });
      w += pad*2;

      c.fillStyle = "rgba(0,0,0,.28)";
      c.beginPath();
      c.roundRect(x, y, w, h, 12);
      c.fill();
      c.stroke();

      for(let i=0;i<items.length;i++){
        const yy = y + pad + 14 + i*18;
        c.strokeStyle = items[i].color;
        c.lineWidth = 3;
        c.beginPath(); c.moveTo(x+pad, yy-4); c.lineTo(x+pad+16, yy-4); c.stroke();
        c.fillStyle = "rgba(233,238,252,.92)";
        c.fillText(items[i].text, x+pad+22, yy);
      }
      c.restore();
    }

    // Add roundRect support for older contexts
    if(!CanvasRenderingContext2D.prototype.roundRect){
      CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r){
        r = Math.min(r, w/2, h/2);
        this.beginPath();
        this.moveTo(x+r, y);
        this.arcTo(x+w, y, x+w, y+h, r);
        this.arcTo(x+w, y+h, x, y+h, r);
        this.arcTo(x, y+h, x, y, r);
        this.arcTo(x, y, x+w, y, r);
        this.closePath();
        return this;
      };
    }

    // ---------- Draw Diagram ----------
    function drawDiagram(curves){
      const canvas = canv.diagram;
      const {w,h,dpr} = dprResize(canvas, canvas.getBoundingClientRect().height);
      const c = ctx.diagram;
      clear(c,w,h);

      const params = curves.params;
      const pad = 18*dpr;

      // Title
      drawPanelTitle(c, "Diagram — 1D periodic bilayer (period Λ) with wavevector components (K, kx)", pad, 20*dpr);

      const x0 = pad, y0 = 40*dpr;
      const W = w - 2*pad, H = h - (54*dpr);

      // Draw stack block
      const blockY = y0 + 18*dpr;
      const blockH = H*0.58;
      const blockX = x0 + W*0.06;
      const blockW = W*0.88;

      // Period segments
      const d1 = params.d1, d2 = params.d2;
      const seg1W = blockW * d1;
      const seg2W = blockW * d2;

      // Background frame
      c.save();
      c.fillStyle = "rgba(0,0,0,.20)";
      c.strokeStyle = "rgba(255,255,255,.16)";
      c.lineWidth = 1.2*dpr;
      c.roundRect(blockX, blockY, blockW, blockH, 16*dpr);
      c.fill(); c.stroke();

      // Layer 1
      c.fillStyle = "rgba(122,167,255,.18)";
      c.roundRect(blockX, blockY, seg1W, blockH, 16*dpr);
      c.fill();

      // Layer 2
      c.fillStyle = "rgba(124,240,198,.15)";
      c.beginPath();
      c.roundRect(blockX+seg1W, blockY, seg2W, blockH, 16*dpr);
      c.fill();

      // Interface line
      c.strokeStyle = "rgba(255,255,255,.22)";
      c.lineWidth = 1*dpr;
      c.beginPath();
      c.moveTo(blockX+seg1W, blockY);
      c.lineTo(blockX+seg1W, blockY+blockH);
      c.stroke();

      // Labels inside layers
      c.fillStyle = "rgba(233,238,252,.94)";
      c.font = `${Math.round(13*dpr)}px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
      c.fillText(`Layer 1: n₁=${params.n1.toFixed(2)}`, blockX + 10*dpr, blockY + 24*dpr);
      c.fillText(`Layer 2: n₂=${params.n2.toFixed(2)}`, blockX + seg1W + 10*dpr, blockY + 24*dpr);

      // Thickness labels
      c.fillStyle = "rgba(183,195,230,.95)";
      c.font = `${Math.round(12*dpr)}px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
      c.fillText(`d₁=${(params.d1).toFixed(2)}Λ`, blockX + seg1W*0.35, blockY + blockH + 18*dpr);
      c.fillText(`d₂=${(params.d2).toFixed(2)}Λ`, blockX + seg1W + seg2W*0.35, blockY + blockH + 18*dpr);

      // Axis arrow x
      const axY = blockY + blockH + 46*dpr;
      c.strokeStyle = "rgba(255,255,255,.28)";
      c.lineWidth = 2*dpr;
      c.beginPath();
      c.moveTo(blockX, axY);
      c.lineTo(blockX+blockW, axY);
      c.stroke();
      // arrow head
      c.beginPath();
      c.moveTo(blockX+blockW, axY);
      c.lineTo(blockX+blockW-10*dpr, axY-6*dpr);
      c.lineTo(blockX+blockW-10*dpr, axY+6*dpr);
      c.closePath();
      c.fillStyle = "rgba(255,255,255,.28)";
      c.fill();
      c.fillStyle = "rgba(233,238,252,.9)";
      c.font = `${Math.round(12*dpr)}px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
      c.fillText("Periodic axis x  (period Λ)", blockX + 6*dpr, axY - 10*dpr);

      // Wavevector sketch
      const originX = blockX + blockW*0.22;
      const originY = blockY + blockH*0.70;

      // Define vector lengths in pixels
      const kappa = state.kappa;
      // show K direction up (lateral) and kx along x
      const Klen = (0.08 + 0.28*kappa) * blockH;
      const kxLen = (0.30 + 0.22*(1-kappa)) * blockW;

      // draw k total
      c.strokeStyle = "rgba(255,210,122,.90)";
      c.lineWidth = 2.5*dpr;
      c.beginPath();
      c.moveTo(originX, originY);
      c.lineTo(originX + kxLen, originY - Klen);
      c.stroke();
      // arrow head
      drawArrowHead(c, originX + kxLen, originY - Klen, Math.atan2(-Klen, kxLen), 10*dpr, "rgba(255,210,122,.90)");

      // draw kx component
      c.strokeStyle = "rgba(122,167,255,.92)";
      c.lineWidth = 2.2*dpr;
      c.beginPath();
      c.moveTo(originX, originY);
      c.lineTo(originX + kxLen, originY);
      c.stroke();
      drawArrowHead(c, originX + kxLen, originY, 0, 9*dpr, "rgba(122,167,255,.92)");

      // draw K component
      c.strokeStyle = "rgba(124,240,198,.92)";
      c.lineWidth = 2.2*dpr;
      c.beginPath();
      c.moveTo(originX, originY);
      c.lineTo(originX, originY - Klen);
      c.stroke();
      drawArrowHead(c, originX, originY - Klen, -Math.PI/2, 9*dpr, "rgba(124,240,198,.92)");

      // labels
      c.fillStyle = "rgba(233,238,252,.95)";
      c.font = `${Math.round(12*dpr)}px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
      c.fillText("k (in a layer)", originX + kxLen + 8*dpr, originY - Klen - 6*dpr);
      c.fillStyle = "rgba(122,167,255,.95)";
      c.fillText("kₓ (normal)", originX + kxLen*0.55, originY + 16*dpr);
      c.fillStyle = "rgba(124,240,198,.95)";
      c.fillText("K (lateral)", originX - 4*dpr, originY - Klen - 10*dpr);

      // small note
      c.fillStyle = "rgba(183,195,230,.9)";
      c.font = `${Math.round(12*dpr)}px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
      const note = (kappa === 0)
        ? "κ = 0 ⇒ K = 0 (normal incidence): no bandgaps."
        : "κ > 0 tilts propagation: gaps can appear due to mismatch & Bragg scattering.";
      c.fillText(note, blockX + 8*dpr, y0 + 6*dpr);

      c.restore();
    }

    function drawArrowHead(c, x, y, ang, size, color){
      c.save();
      c.translate(x,y);
      c.rotate(ang);
      c.fillStyle = color;
      c.beginPath();
      c.moveTo(0,0);
      c.lineTo(-size, -0.6*size);
      c.lineTo(-size, 0.6*size);
      c.closePath();
      c.fill();
      c.restore();
    }

    // ---------- Draw Plots ----------
    function drawPlot1(curves){
      const canvas = canv.plot1;
      const {w,h,dpr} = dprResize(canvas, canvas.getBoundingClientRect().height);
      const c = ctx.plot1;
      clear(c,w,h);

      const box = {x:0,y:0,w:w,h:h};
      drawPanelTitle(c, "Main Plot — Bloch phase βΛ vs normalized frequency ν = Λ/λ", 16*dpr, 18*dpr);

      const xMin = state.nuMin, xMax = state.nuMax;
      const yMin = 0, yMax = Math.PI;

      const map = drawAxes(c, box, xMin, xMax, yMin, yMax, "ν = Λ/λ  (dimensionless)", "βΛ  (rad)", {xDigits:2, yDigits:2});
      map.gy = map.gy; // for shading helper
      map.gh = map.gh;

      // Shade gaps
      drawShadedGaps(c, curves.xs, curves.gaps, map, "rgba(255,255,255,.08)");

      // Draw beta curve
      drawLine(c, curves.xs, curves.betas, map, "rgba(122,167,255,.95)");

      // Legend
      drawLegend(c, [
        {text:"βΛ = arccos(F) (allowed bands)", color:"rgba(122,167,255,.95)"},
        {text:"shaded: |F|>1 (bandgaps)", color:"rgba(255,255,255,.35)"}
      ], map.gx + map.gw - 250*(window.devicePixelRatio||1), map.gy + 10*(window.devicePixelRatio||1));

      // Annotate K=0 message
      c.save();
      c.fillStyle = "rgba(233,238,252,.92)";
      c.font = `600 ${Math.round(12*dpr)}px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
      const msg = (state.kappa===0) ? "κ = 0 ⇒ no shaded gaps anywhere" : "κ > 0 ⇒ shaded gaps may appear";
      c.fillText(msg, map.gx + 8*dpr, map.gy + 18*dpr);
      c.restore();
    }

    function drawPlot2(curves){
      const canvas = canv.plot2;
      const {w,h,dpr} = dprResize(canvas, canvas.getBoundingClientRect().height);
      const c = ctx.plot2;
      clear(c,w,h);

      const box = {x:0,y:0,w:w,h:h};
      drawPanelTitle(c, "Secondary Plot — Dispersion function F(ν;K) where cos(βΛ)=F", 16*dpr, 18*dpr);

      const xMin = state.nuMin, xMax = state.nuMax;
      const yMin = -2.4, yMax = 2.4;

      const map = drawAxes(c, box, xMin, xMax, yMin, yMax, "ν = Λ/λ  (dimensionless)", "F(ν;K)  (dimensionless)", {xDigits:2, yDigits:1});
      map.gy = map.gy; map.gh = map.gh;

      // Shade outside |F|>1 using gaps array (same segmentation)
      drawShadedGaps(c, curves.xs, curves.gaps, map, "rgba(255,122,162,.07)");

      // Draw F curve
      drawLine(c, curves.xs, curves.Fs, map, "rgba(124,240,198,.95)");

      // Draw ±1 band edges
      c.save();
      c.strokeStyle = "rgba(255,255,255,.35)";
      c.setLineDash([6*dpr, 6*dpr]);
      c.lineWidth = 1.6*dpr;
      const y1 = map.Ymap(1), ym1 = map.Ymap(-1);
      c.beginPath(); c.moveTo(map.gx, y1); c.lineTo(map.gx+map.gw, y1); c.stroke();
      c.beginPath(); c.moveTo(map.gx, ym1); c.lineTo(map.gx+map.gw, ym1); c.stroke();
      c.setLineDash([]);
      c.fillStyle = "rgba(233,238,252,.8)";
      c.font = `${Math.round(12*dpr)}px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
      c.fillText("+1 (band edge)", map.gx + 8*dpr, y1 - 6*dpr);
      c.fillText("−1 (band edge)", map.gx + 8*dpr, ym1 - 6*dpr);
      c.restore();

      drawLegend(c, [
        {text:"F(ν;K)", color:"rgba(124,240,198,.95)"},
        {text:"dashed: ±1 edges", color:"rgba(255,255,255,.35)"},
        {text:"shaded: |F|>1 (gaps)", color:"rgba(255,122,162,.35)"}
      ], map.gx + 10*(window.devicePixelRatio||1), map.gy + 10*(window.devicePixelRatio||1));
    }

    // ---------- Update UI labels and re-render ----------
    function updateLabels(){
      ui.kappaVal.textContent = Number(state.kappa).toFixed(2);
      ui.presetLabel.textContent = presets[state.presetIndex].label;
      ui.modeLabel.textContent = (state.mode === "TE") ? "TE-like" : "TM-like";
    }

    function renderAll(){
      updateLabels();
      const curves = computeCurves();
      drawDiagram(curves);
      drawPlot1(curves);
      drawPlot2(curves);
    }

    // ---------- Wire controls ----------
    ui.kappa.addEventListener('input', ()=>{
      state.kappa = parseFloat(ui.kappa.value);
      renderAll();
    });
    ui.preset.addEventListener('change', ()=>{
      state.presetIndex = parseInt(ui.preset.value, 10);
      renderAll();
    });
    ui.mode.addEventListener('change', ()=>{
      state.mode = ui.mode.value;
      renderAll();
    });

    // Responsive redraw
    window.addEventListener('resize', ()=>{
      renderAll();
    });

    // Init
    (function init(){
      state.kappa = parseFloat(ui.kappa.value);
      state.presetIndex = parseInt(ui.preset.value, 10);
      state.mode = ui.mode.value;
      renderAll();
    })();
  </script>
</body>
</html>
