<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Quarter-Wave and Half-Wave Stacks — Reflectance of N Double Layers (Derivation + Interactive)</title>
  <style>
    :root{
      --bg:#0b0f17;
      --card:#101828;
      --muted:#98a2b3;
      --text:#e6eaf2;
      --accent:#7dd3fc;
      --accent2:#a7f3d0;
      --warn:#fda4af;
      --ok:#86efac;
      --line:rgba(255,255,255,.10);
      --shadow: 0 18px 50px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background: radial-gradient(1200px 600px at 20% 10%, rgba(125,211,252,.14), transparent 55%),
                  radial-gradient(900px 600px at 70% 30%, rgba(167,243,208,.10), transparent 55%),
                  linear-gradient(180deg, #070a10, #0b0f17 30%, #070a10);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:28px 18px 18px;
      border-bottom:1px solid var(--line);
      position:relative;
      overflow:hidden;
    }
    header .wrap{
      max-width:1200px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:18px;
      align-items:end;
    }
    h1{
      margin:0 0 8px 0;
      font-size: clamp(22px, 3vw, 40px);
      letter-spacing:.2px;
    }
    header p{
      margin:0;
      color:var(--muted);
      max-width:70ch;
    }
    .meta{
      justify-self:end;
      text-align:right;
      color:var(--muted);
      font-size:14px;
    }
    main{
      max-width:1200px;
      margin:0 auto;
      padding:18px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }
    nav.toc{
      position:sticky;
      top:14px;
      align-self:start;
      padding:14px;
      border:1px solid var(--line);
      border-radius:var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }
    nav.toc h2{
      font-size:14px;
      margin:0 0 10px 0;
      color:var(--accent2);
      letter-spacing:.12em;
      text-transform:uppercase;
    }
    nav.toc a{
      display:block;
      padding:7px 10px;
      border-radius:12px;
      color:var(--text);
      font-size:14px;
      border:1px solid transparent;
    }
    nav.toc a:hover{
      background: rgba(125,211,252,.08);
      border-color: rgba(125,211,252,.18);
      text-decoration:none;
    }
    .content{
      display:flex;
      flex-direction:column;
      gap:14px;
      min-width:0;
    }
    section, article{
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      padding:16px;
      overflow:hidden;
      position:relative;
    }
    section h2, article h2{
      margin:0 0 10px 0;
      font-size: clamp(18px, 2vw, 26px);
    }
    h3{
      margin:14px 0 8px 0;
      font-size:18px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      align-items:start;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:12px;
      align-items:start;
    }
    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .callout{
      padding:12px;
      border-radius:16px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.02);
    }
    .callout strong{
      display:block;
      margin-bottom:6px;
      letter-spacing:.02em;
    }
    .callout.assump{border-color: rgba(167,243,208,.22)}
    .callout.keyeq{border-color: rgba(125,211,252,.25)}
    .callout.mist{border-color: rgba(253,164,175,.25)}
    .callout.final{border-color: rgba(134,239,172,.28)}
    ul{margin:8px 0 0 18px}
    li{margin:4px 0}
    .eqbox{
      position:relative;
      margin:10px 0;
      border:1px dashed rgba(125,211,252,.35);
      border-radius:16px;
      padding:10px 10px 10px 12px;
      background: rgba(125,211,252,.06);
      overflow:auto;
    }
    pre, code{font-family:var(--mono)}
    pre{
      margin:0;
      white-space:pre-wrap;
      word-break:break-word;
      color:#eaf2ff;
      font-size: 14px;
    }
    .copyBtn{
      position:absolute;
      top:10px;
      right:10px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.25);
      color:var(--text);
      padding:6px 10px;
      border-radius:12px;
      cursor:pointer;
      font-size:12px;
      transition: transform .12s ease, background .12s ease;
      user-select:none;
    }
    .copyBtn:hover{transform: translateY(-1px); background: rgba(0,0,0,.35)}
    .copyBtn:active{transform: translateY(0px) scale(.98)}
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.02);
      color:var(--muted);
      font-size:12px;
    }
    .vizWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .controls{
      display:grid;
      grid-template-columns: repeat(4, minmax(0,1fr));
      gap:10px;
      padding:12px;
      border:1px solid var(--line);
      border-radius:16px;
      background: rgba(255,255,255,.02);
    }
    .control{
      min-width:0;
    }
    .control label{
      display:block;
      font-size:12px;
      color:var(--muted);
      margin-bottom:6px;
      letter-spacing:.02em;
    }
    .control input[type="range"]{width:100%}
    .control select, .control input[type="number"]{
      width:100%;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      color:var(--text);
      outline:none;
    }
    .control .readout{
      font-family:var(--mono);
      font-size:12px;
      color:#eaf2ff;
      margin-top:6px;
      opacity:.9;
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
    }
    .canvasTall{height:360px}
    .canvasMid{height:320px}
    .canvasShort{height:300px}
    footer{
      max-width:1200px;
      margin:0 auto;
      padding:18px;
      color:var(--muted);
      font-size:13px;
      border-top:1px solid var(--line);
    }
    .kicker{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .fadeIn{
      animation: fadeIn .45s ease both;
    }
    @keyframes fadeIn{
      from{opacity:0; transform: translateY(6px)}
      to{opacity:1; transform: translateY(0)}
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
      nav.toc{position:relative; top:auto}
      header .wrap{grid-template-columns: 1fr}
      .meta{justify-self:start; text-align:left}
      .controls{grid-template-columns: 1fr 1fr}
      .callouts{grid-template-columns: 1fr}
      .grid2{grid-template-columns: 1fr}
      .grid3{grid-template-columns: 1fr}
    }
    @media print{
      body{background:#fff; color:#000}
      header, nav.toc, .copyBtn, .controls{display:none !important}
      section, article{box-shadow:none; border:1px solid #ddd; background:#fff}
      a{color:#000; text-decoration:underline}
      pre{color:#000}
      canvas{border:1px solid #ddd; background:#fff}
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div>
        <h1>7.1-7 — Quarter-Wave and Half-Wave Stacks: Reflectance of <span style="white-space:nowrap">N</span> Double Layers</h1>
        <p>
          We derive compact, design-wavelength expressions for the reflectance of a periodic dielectric multilayer (a 1D photonic crystal / Bragg mirror)
          made of <em>N</em> repeating pairs of two dielectrics with equal optical thickness. Then we connect the formulas to an interactive transfer-matrix simulation.
        </p>
        <div class="kicker">
          <span class="pill">Topic: thin-film interference</span>
          <span class="pill">Tool: transfer (characteristic) matrix</span>
          <span class="pill">Design cases: λ<sub>0</sub>/4 and λ<sub>0</sub>/2</span>
        </div>
      </div>
      <div class="meta">
        <div><strong>Learning mode:</strong> theory → analysis → derivation → interpretation</div>
        <div><strong>Assumed:</strong> normal incidence (TE/TM identical)</div>
      </div>
    </div>
  </header>

  <main>
    <nav class="toc" aria-label="Table of contents">
      <h2>Contents</h2>
      <a href="#quick" data-scroll>Quick Summary</a>
      <a href="#p0" data-scroll>PART 0 — Concept Primer</a>
      <a href="#p1" data-scroll>PART 1 — Problem Analysis</a>
      <a href="#p2" data-scroll>PART 2 — Strategy &amp; Tips</a>
      <a href="#p3" data-scroll>PART 3 — Full Solution</a>
      <a href="#p4" data-scroll>PART 4 — Deeper Understanding</a>
      <a href="#p5" data-scroll>PART 5 — Visualization Guide</a>
      <a href="#viz" data-scroll>Interactive Visualizations</a>
    </nav>

    <div class="content">
      <section id="quick" class="fadeIn">
        <h2>Quick Summary</h2>
        <ul>
          <li><strong>What:</strong> Find the <em>reflectance</em> of a stack of <em>N</em> repeating double layers (n<sub>1</sub>, d<sub>1</sub>) and (n<sub>2</sub>, d<sub>2</sub>) with <strong>equal optical thickness</strong> n<sub>1</sub>d<sub>1</sub> = n<sub>2</sub>d<sub>2</sub>.</li>
          <li><strong>Key idea:</strong> Multilayer reflection is easiest via the <strong>characteristic (transfer) matrix</strong> and the resulting <strong>input optical admittance</strong> seen by the incident wave.</li>
          <li><strong>Governing building block:</strong> For a layer with refractive index n and phase thickness δ,
            the matrix is <span style="font-family:var(--mono)">M = [[cosδ, i sinδ / n],[i n sinδ, cosδ]]</span> (normal incidence).</li>
          <li><strong>Design wavelengths:</strong>
            quarter-wave: n d = λ<sub>0</sub>/4 ⇒ δ(λ<sub>0</sub>) = π/2; half-wave: n d = λ<sub>0</sub>/2 ⇒ δ(λ<sub>0</sub>) = π.</li>
          <li><strong>Quarter-wave pair simplifies:</strong> one (n<sub>1</sub> then n<sub>2</sub>) pair becomes diagonal, so <em>N</em> pairs are easy to raise to a power.</li>
          <li><strong>Final result type:</strong> symbolic closed-form <strong>R(λ<sub>0</sub>)</strong> for quarter-wave and half-wave stacks; interactive numeric <strong>R(λ)</strong> via transfer matrix for any wavelength.</li>
          <li><strong>Headline outcomes:</strong> quarter-wave stacks can produce very high reflectance (Bragg mirror); half-wave stacks are effectively “invisible” at λ<sub>0</sub> (same reflectance as bare substrate, only a phase delay).</li>
        </ul>
      </section>

      <article id="p0" class="fadeIn">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <div class="callouts">
          <div class="callout keyeq">
            <strong>Core definitions</strong>
            <ul>
              <li><strong>Refractive index</strong> n (dimensionless): sets phase velocity v = c/n in a dielectric.</li>
              <li><strong>Physical thickness</strong> d (m): geometric thickness of one layer.</li>
              <li><strong>Optical thickness</strong> n d (m): thickness measured in wavelengths inside the medium.</li>
              <li><strong>Vacuum wavelength</strong> λ (m): wavelength in free space.</li>
              <li><strong>Phase thickness</strong> δ = (2π/λ) n d (radians): phase accumulated across a layer (normal incidence).</li>
              <li><strong>Reflectance</strong> R = |r|² (dimensionless): fraction of power reflected; r is the complex field reflection coefficient.</li>
            </ul>
          </div>
          <div class="callout assump">
            <strong>Physical meaning</strong>
            <ul>
              <li>Each interface reflects a small portion of the wave (Fresnel reflection).</li>
              <li>Multiple reflections inside the stack interfere. The <em>optical thickness</em> determines whether reflected contributions add constructively (high R) or cancel (low R).</li>
              <li>A periodic stack can behave like a <strong>1D photonic crystal</strong> with a stop-band where propagation is suppressed and reflection is strong.</li>
            </ul>
          </div>
        </div>

        <h3>Key laws / principles (and validity)</h3>
        <ul>
          <li><strong>Linear, isotropic dielectrics</strong> with real refractive indices (no absorption). Then energy conservation gives R + T = 1 (at normal incidence, with proper impedance factors).</li>
          <li><strong>Plane-wave, normal incidence</strong>: TE and TM polarizations behave identically; we can use scalar Fresnel/transfer-matrix formulas.</li>
          <li><strong>Thin-film interference</strong>: phase thickness δ controls interference. Special cases δ = π/2 (quarter-wave) and δ = π (half-wave) give especially simple matrices.</li>
        </ul>

        <h3>Common models / approximations (why we use them)</h3>
        <ul>
          <li><strong>Transfer-matrix model:</strong> exact for stratified, planar, lossless layers; tracks forward/backward waves through the stack.</li>
          <li><strong>Design-wavelength simplification:</strong> at λ = λ<sub>0</sub>, quarter-wave and half-wave layers turn trig functions into 0 and ±1, making the product matrix easy.</li>
          <li><strong>Equal optical thickness:</strong> n<sub>1</sub>d<sub>1</sub> = n<sub>2</sub>d<sub>2</sub> ensures both layers have the same phase thickness at any given λ, differing only in impedance/admittance factors.</li>
        </ul>

        <h3>Mini intuition examples (conceptual)</h3>
        <ul>
          <li><strong>Quarter-wave mirror intuition:</strong> If reflections from many interfaces return with nearly the same phase, they add → large reflected amplitude → R close to 1.</li>
          <li><strong>Half-wave “invisibility” intuition:</strong> A half-wave layer returns the wave with a π phase shift after one pass, but because the sine term vanishes at δ = π, the layer behaves like a simple sign flip (global phase) → no change in reflectance.</li>
        </ul>

        <div class="callout mist">
          <strong>What to watch for (pitfalls)</strong>
          <ul>
            <li><strong>Order of layers matters</strong> (which index is adjacent to the incident medium changes the result).</li>
            <li>Don’t confuse <strong>optical thickness</strong> (n d) with physical thickness d.</li>
            <li>At design wavelength, quarter-wave stacks give a <strong>real</strong> effective admittance and r is real; away from design wavelength, r is complex.</li>
            <li>Be consistent about <strong>incident medium</strong> index n<sub>0</sub> and <strong>substrate</strong> index n<sub>s</sub>.</li>
          </ul>
        </div>
      </article>

      <article id="p1" class="fadeIn">
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

        <h3>Restate the problem (in plain words)</h3>
        <p>
          We have a multilayer dielectric stack made of <em>N</em> repeating <strong>double layers</strong>:
          layer 1 has refractive index n<sub>1</sub> and thickness d<sub>1</sub>, layer 2 has refractive index n<sub>2</sub> and thickness d<sub>2</sub>.
          The layers are designed so that they have the same optical thickness, n<sub>1</sub>d<sub>1</sub> = n<sub>2</sub>d<sub>2</sub>, and that optical thickness is either λ<sub>0</sub>/4 (quarter-wave design) or λ<sub>0</sub>/2 (half-wave design).
          Derive expressions for the stack reflectance at the design wavelength.
        </p>

        <div class="grid2">
          <div class="callout assump">
            <strong>Given</strong>
            <ul>
              <li>Two dielectrics with indices n<sub>1</sub>, n<sub>2</sub></li>
              <li>Thicknesses d<sub>1</sub>, d<sub>2</sub> such that n<sub>1</sub>d<sub>1</sub> = n<sub>2</sub>d<sub>2</sub></li>
              <li>That common optical thickness equals λ<sub>0</sub>/4 or λ<sub>0</sub>/2</li>
              <li><em>N</em> identical repeating pairs (n<sub>1</sub>, d<sub>1</sub>) then (n<sub>2</sub>, d<sub>2</sub>)</li>
              <li>Incident medium index n<sub>0</sub> and substrate index n<sub>s</sub> (needed to compute r)</li>
            </ul>
          </div>
          <div class="callout keyeq">
            <strong>Unknowns / what to find</strong>
            <ul>
              <li>Closed-form reflection coefficient r (and reflectance R = |r|²) of the entire stack</li>
              <li>Separate expressions for quarter-wave and half-wave designs</li>
              <li>Explicit dependence on n<sub>0</sub>, n<sub>s</sub>, n<sub>1</sub>, n<sub>2</sub>, and N</li>
            </ul>
          </div>
        </div>

        <h3>Relevant principles (and why they apply)</h3>
        <ul>
          <li><strong>Fresnel boundary conditions</strong> at each interface: continuity of tangential E and H.</li>
          <li><strong>Transfer/characteristic matrix</strong> for a stratified medium: combines many interfaces and phases efficiently.</li>
          <li><strong>Equal optical thickness + design wavelength</strong> makes each layer’s phase thickness identical and simple (π/2 or π), turning the product matrix into a power of a simple matrix.</li>
        </ul>
        <p>
          Other tools (e.g., coupled-mode theory or Bloch-wave band-structure) can also describe periodic stacks, but the transfer matrix is the most direct for an exact closed-form reflectance at the design wavelength.
        </p>

        <div class="callout assump">
          <strong>Assumptions (explicit)</strong>
          <ul>
            <li>Normal incidence (no angle dependence; TE/TM same).</li>
            <li>Lossless, non-magnetic dielectrics (μ = μ<sub>0</sub>, real n).</li>
            <li>Perfectly planar, infinite transverse extent, no scattering/roughness.</li>
            <li>Coherent monochromatic wave at λ = λ<sub>0</sub> for the symbolic “design-wavelength” formulas.</li>
          </ul>
        </div>

        <h3>Possible approaches (compare)</h3>
        <ul>
          <li><strong>(A) Transfer-matrix (chosen):</strong> exact, systematic, and gives a clean closed form at δ = π/2 or π. Best for this problem.</li>
          <li><strong>(B) Multiple-reflection summation:</strong> conceptually intuitive but becomes algebraically messy for many layers; hard to get a neat N-pair expression.</li>
          <li><strong>(C) Bloch-wave / bandgap view:</strong> powerful for stop-band physics, but requires more machinery (Bloch impedance) to connect directly to finite-stack reflectance.</li>
        </ul>
        <p><strong>Choice:</strong> We use (A) because the special quarter-wave and half-wave phase conditions make the matrix product almost trivial.</p>
      </article>

      <article id="p2" class="fadeIn">
        <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>

        <ol>
          <li>
            <strong>Goal:</strong> represent each layer by a matrix that maps (E,H) at one side to the other.
            <br><strong>Tool:</strong> characteristic matrix at normal incidence.
            <br><strong>Meaning:</strong> compresses propagation + interface effects into one object.
          </li>
          <li>
            <strong>Goal:</strong> write phase thickness δ in terms of optical thickness n d and wavelength.
            <br><strong>Tool:</strong> δ = (2π/λ) n d.
            <br><strong>Meaning:</strong> interference comes from δ.
          </li>
          <li>
            <strong>Goal:</strong> specialize to λ = λ<sub>0</sub> and to n d = λ<sub>0</sub>/4 or λ<sub>0</sub>/2.
            <br><strong>Tool:</strong> trig values at δ = π/2 and δ = π.
            <br><strong>Meaning:</strong> matrices simplify drastically.
          </li>
          <li>
            <strong>Goal:</strong> compute the matrix of one <em>pair</em> (n<sub>1</sub> then n<sub>2</sub>), then raise to power N.
            <br><strong>Tool:</strong> matrix multiplication + powers of diagonal matrices.
            <br><strong>Meaning:</strong> periodicity becomes an exponent.
          </li>
          <li>
            <strong>Goal:</strong> convert total matrix into an effective input admittance Y<sub>in</sub>.
            <br><strong>Tool:</strong> Y<sub>in</sub> = (M<sub>11</sub>Y<sub>s</sub> + M<sub>12</sub>)/(M<sub>21</sub>Y<sub>s</sub> + M<sub>22</sub>).
            <br><strong>Meaning:</strong> the multilayer behaves like a single interface with admittance Y<sub>in</sub>.
          </li>
          <li>
            <strong>Goal:</strong> compute reflection coefficient and reflectance.
            <br><strong>Tool:</strong> r = (Y<sub>in</sub> − Y<sub>0</sub>)/(Y<sub>in</sub> + Y<sub>0</sub>), R = |r|².
            <br><strong>Meaning:</strong> how much power is reflected.
          </li>
        </ol>

        <div class="callouts">
          <div class="callout mist">
            <strong>Common mistakes</strong>
            <ul>
              <li>Using n instead of admittance (at normal incidence they coincide for non-magnetic media, but keep the idea clear).</li>
              <li>Forgetting that the <strong>pair order</strong> matters: (n<sub>1</sub>→n<sub>2</sub>) is not the same as (n<sub>2</sub>→n<sub>1</sub>).</li>
              <li>Mixing “design wavelength” simplifications with “arbitrary wavelength” formulas.</li>
            </ul>
          </div>
          <div class="callout keyeq">
            <strong>Quick tips</strong>
            <ul>
              <li>At λ = λ<sub>0</sub>, quarter-wave gives cosδ=0 and sinδ=1; half-wave gives sinδ=0.</li>
              <li>If M becomes diagonal, <em>powers are easy</em>: diag(a,b)<sup>N</sup> = diag(a<sup>N</sup>, b<sup>N</sup>).</li>
              <li>Do a limiting-case check: N=0 should reduce to bare substrate reflectance.</li>
            </ul>
          </div>
        </div>
      </article>

      <article id="p3" class="fadeIn">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Qualitative expectation (before math)</h3>
        <ul>
          <li><strong>Quarter-wave stack:</strong> A periodic alternation of impedance (index) produces a stop-band around λ<sub>0</sub>. As N increases, reflection at λ<sub>0</sub> should increase rapidly (Bragg mirror behavior).</li>
          <li><strong>Half-wave stack:</strong> Each layer is an integer multiple of half-wavelength in optical path at λ<sub>0</sub>, so the layer’s effect should mostly be a global phase; reflectance should match the bare substrate (for lossless layers at normal incidence).</li>
        </ul>

        <div class="callout keyeq">
          <strong>Key equation set (normal incidence, non-magnetic)</strong>
          <p style="margin:6px 0 8px;color:var(--muted)">
            We use the optical admittance Y = n (for μ = μ<sub>0</sub> and normal incidence). Define incident admittance Y<sub>0</sub>=n<sub>0</sub>, substrate admittance Y<sub>s</sub>=n<sub>s</sub>.
          </p>
          <div class="eqbox">
            <button class="copyBtn" data-copy="#eqKey">Copy</button>
            <pre id="eqKey">Layer phase thickness:  δ = (2π/λ) n d

Characteristic matrix of one layer (index n, phase δ):
M(n,δ) = [ [ cosδ,  i sinδ / n ],
          [ i n sinδ,  cosδ ] ]

For total matrix M = Π layers:
Y_in = (M11*Y_s + M12) / (M21*Y_s + M22)
r = (Y_in - Y_0) / (Y_in + Y_0)
R = |r|^2</pre>
          </div>
        </div>

        <h3>Step 1 — Use the “equal optical thickness” condition</h3>
        <p>
          The problem states:
          <strong>n<sub>1</sub>d<sub>1</sub> = n<sub>2</sub>d<sub>2</sub></strong>, and that common value equals either λ<sub>0</sub>/4 or λ<sub>0</sub>/2.
          Therefore, at λ = λ<sub>0</sub>, the phase thickness of <em>both</em> layers is the same:
        </p>

        <div class="eqbox">
          <button class="copyBtn" data-copy="#eqDelta">Copy</button>
          <pre id="eqDelta">At λ = λ0:

If n1 d1 = n2 d2 = λ0/4  ⇒  δ1 = δ2 = (2π/λ0)(λ0/4) = π/2

If n1 d1 = n2 d2 = λ0/2  ⇒  δ1 = δ2 = (2π/λ0)(λ0/2) = π</pre>
        </div>

        <p>
          <em>Interpretation:</em> the two materials differ in their “impedance/admittance” factor (n), but they imprint the same propagation phase at the design wavelength.
        </p>

        <h3>Step 2 — Quarter-wave design (n d = λ<sub>0</sub>/4)</h3>
        <p>
          For δ = π/2, we have cosδ = 0 and sinδ = 1. Plugging into the layer matrix:
        </p>

        <div class="eqbox">
          <button class="copyBtn" data-copy="#eqQuarterLayer">Copy</button>
          <pre id="eqQuarterLayer">Quarter-wave layer at λ0 (δ = π/2):

M(n, π/2) = [ [ 0,   i / n ],
             [ i n,  0     ] ]</pre>
        </div>

        <p>
          Now define one <strong>double layer (pair)</strong> as: first (n<sub>1</sub>, d<sub>1</sub>), then (n<sub>2</sub>, d<sub>2</sub>).
          The pair matrix is:
        </p>

        <div class="eqbox">
          <button class="copyBtn" data-copy="#eqPairQ">Copy</button>
          <pre id="eqPairQ">Quarter-wave pair (n1 then n2) at λ0:

M1 = M(n1, π/2) = [ [0, i/n1], [i n1, 0] ]
M2 = M(n2, π/2) = [ [0, i/n2], [i n2, 0] ]

M_pair = M2 * M1
       = [ [ -(n1/n2),   0 ],
           [   0,     -(n2/n1) ] ]</pre>
        </div>

        <p>
          <em>What we did and why:</em> multiplying matrices corresponds to stacking layers. The miracle here is that the pair matrix becomes <strong>diagonal</strong>,
          meaning the pair simply scales the forward/backward field components by fixed factors.
        </p>

        <h3>Step 3 — N identical quarter-wave pairs</h3>
        <p>
          With <em>N</em> identical pairs, the total matrix is just the Nth power:
          because M<sub>pair</sub> is diagonal, the power is immediate.
        </p>

        <div class="eqbox">
          <button class="copyBtn" data-copy="#eqTotalQ">Copy</button>
          <pre id="eqTotalQ">For N quarter-wave pairs:

M_total = (M_pair)^N
        = (-1)^N * [ [ (n1/n2)^N, 0 ],
                     [ 0, (n2/n1)^N ] ]</pre>
        </div>

        <p>
          The global factor (-1)<sup>N</sup> multiplies the whole matrix and does not affect reflectance (it’s a global phase sign).
          Next compute the input admittance:
        </p>

        <p>
          Since M<sub>12</sub> = M<sub>21</sub> = 0, the formula simplifies:
          Y<sub>in</sub> = (M<sub>11</sub>/M<sub>22</sub>) Y<sub>s</sub>.
        </p>

        <div class="eqbox">
          <button class="copyBtn" data-copy="#eqYinQ">Copy</button>
          <pre id="eqYinQ">Quarter-wave stack input admittance at λ0:

Y_in = (M11*Y_s + M12) / (M21*Y_s + M22)
     = (M11/M22) * Y_s
     = [ ( (n1/n2)^N ) / ( (n2/n1)^N ) ] * n_s
     = n_s * (n1/n2)^(2N)</pre>
        </div>

        <p>
          Finally,
          r = (Y<sub>in</sub> − n<sub>0</sub>)/(Y<sub>in</sub> + n<sub>0</sub>), and R = |r|².
          At the design wavelength this r is real (lossless + diagonal admittance scaling).
        </p>

        <div class="callout final">
          <strong>Final (Quarter-wave, at λ = λ<sub>0</sub>, stack starts with n<sub>1</sub>)</strong>
          <div class="eqbox" style="border-color:rgba(134,239,172,.35); background: rgba(134,239,172,.06);">
            <button class="copyBtn" data-copy="#eqFinalQ">Copy</button>
            <pre id="eqFinalQ">Let Y0 = n0 and Ys = ns. For N pairs (n1 then n2), with n1 d1 = n2 d2 = λ0/4:

Y_in(λ0) = ns * (n1/n2)^(2N)

r(λ0) = [ ns*(n1/n2)^(2N) - n0 ] / [ ns*(n1/n2)^(2N) + n0 ]

R(λ0) = |r(λ0)|^2  (here r is real, so R = r^2)</pre>
          </div>
          <p style="margin:8px 0 0;color:var(--muted)">
            If the stack starts with n<sub>2</sub> instead, swap n<sub>1</sub> ↔ n<sub>2</sub> in the (n<sub>1</sub>/n<sub>2</sub>) factor.
          </p>
        </div>

        <h3>Step 4 — Half-wave design (n d = λ<sub>0</sub>/2)</h3>
        <p>
          For δ = π, we have sinδ = 0 and cosδ = −1. Then each layer matrix becomes:
        </p>

        <div class="eqbox">
          <button class="copyBtn" data-copy="#eqHalfLayer">Copy</button>
          <pre id="eqHalfLayer">Half-wave layer at λ0 (δ = π):

M(n, π) = [ [ -1,  0 ],
            [  0, -1 ] ] = -I</pre>
        </div>

        <p>
          A pair is M<sub>pair</sub> = (−I)(−I) = I. For N pairs, M<sub>total</sub> = I.
          Therefore the stack’s input admittance equals the substrate admittance:
        </p>

        <div class="eqbox">
          <button class="copyBtn" data-copy="#eqFinalH">Copy</button>
          <pre id="eqFinalH">Half-wave stack at λ0 (n1 d1 = n2 d2 = λ0/2):

Each layer: M = -I
Each pair:  M_pair = I
N pairs:    M_total = I

Thus Y_in(λ0) = Ys = ns

r(λ0) = (ns - n0)/(ns + n0)
R(λ0) = | (ns - n0)/(ns + n0) |^2</pre>
        </div>

        <div class="callout final">
          <strong>Final (Half-wave, at λ = λ<sub>0</sub>)</strong>
          <p style="margin:6px 0 0">
            The multilayer does <em>not</em> change the reflectance at λ<sub>0</sub> compared to the bare substrate interface (it only adds a net phase delay).
          </p>
        </div>

        <h3>Sanity checks</h3>
        <ul>
          <li><strong>Units:</strong> n, r, R are dimensionless; δ is dimensionless (radians). All formulas are dimensionally consistent.</li>
          <li><strong>N = 0 limit:</strong> quarter-wave expression gives Y<sub>in</sub> = n<sub>s</sub> and r reduces to the bare substrate reflectance — correct.</li>
          <li><strong>Large N (quarter-wave):</strong> if n<sub>1</sub> &gt; n<sub>2</sub>, then (n<sub>1</sub>/n<sub>2</sub>)<sup>2N</sup> grows quickly, so Y<sub>in</sub> ≫ n<sub>0</sub> and r → +1 ⇒ R → 1 — strong mirror behavior.</li>
          <li><strong>Half-wave:</strong> independent of n<sub>1</sub>, n<sub>2</sub> at λ<sub>0</sub>, consistent with M = −I removing impedance dependence.</li>
        </ul>

        <p>
          <strong>Connection to the diagram/plots:</strong> In the visualization below, the diagram shows the periodic stack. The main plot shows R(λ) computed by the full transfer matrix.
          At λ/λ<sub>0</sub> = 1, you will see the quarter-wave curve peak (high R) while the half-wave curve collapses to the bare-interface value.
        </p>
      </article>

      <article id="p4" class="fadeIn">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpreting the quarter-wave formula</h3>
        <p>
          The quarter-wave design-wavelength result can be read as:
          the stack transforms the substrate admittance n<sub>s</sub> into an <strong>effective input admittance</strong>
          Y<sub>in</sub> = n<sub>s</sub>(n<sub>1</sub>/n<sub>2</sub>)<sup>2N</sup> (for a stack starting with n<sub>1</sub>).
        </p>
        <ul>
          <li>The ratio (n<sub>1</sub>/n<sub>2</sub>) is the “contrast” of the periodic impedance modulation.</li>
          <li>The exponent 2N shows why adding more pairs quickly increases reflectivity (exponential in N for the admittance scaling).</li>
          <li>The surrounding medium index n<sub>0</sub> controls how strongly that effective admittance mismatch reflects.</li>
        </ul>

        <h3>How parameters affect outcomes (connect to plots)</h3>
        <ul>
          <li><strong>Increase N:</strong> quarter-wave stop-band deepens → higher peak R and wider high-R region; half-wave stays near the bare-interface value at λ/λ<sub>0</sub>=1.</li>
          <li><strong>Increase index contrast (n<sub>1</sub>/n<sub>2</sub>):</strong> quarter-wave mirror becomes much stronger at the same N.</li>
          <li><strong>Move wavelength away from λ<sub>0</sub>:</strong> interference detunes → reflectance oscillates and generally decreases, showing band-edge structure.</li>
        </ul>

        <h3>Alternative derivation idea (brief)</h3>
        <p>
          A periodic infinite stack supports Bloch waves. At quarter-wave design, the Bloch wavevector becomes imaginary in the stop band (evanescent),
          and the <em>Bloch impedance</em> becomes strongly mismatched to the incident medium, yielding high reflection.
          A finite stack of N periods approximates this by an exponentially growing/decaying field inside the stack—consistent with the (n<sub>1</sub>/n<sub>2</sub>)<sup>2N</sup> scaling.
        </p>

        <h3>Concept checks (self-test)</h3>
        <ul>
          <li><strong>Q:</strong> Why does half-wave layering not change reflectance at λ<sub>0</sub>? <strong>A:</strong> Because sin(π)=0, each layer matrix becomes −I, so pairs multiply to I; the stack only adds a global phase.</li>
          <li><strong>Q:</strong> If the first layer next to air is the low-index layer instead of high-index, what happens? <strong>A:</strong> The effective admittance scaling flips (n<sub>1</sub>/n<sub>2</sub>) → (n<sub>2</sub>/n<sub>1</sub>), changing the design-wavelength reflectance.</li>
          <li><strong>Q:</strong> What does “equal optical thickness” guarantee? <strong>A:</strong> Both layers accrue the same phase thickness δ at a given λ, simplifying periodic interference and enabling the quarter-wave diagonal pair matrix at λ<sub>0</sub>.</li>
          <li><strong>Q:</strong> What is the simplest way to confirm your formula numerically? <strong>A:</strong> Use the full transfer matrix at λ=λ<sub>0</sub> and compare to the closed form; they should match exactly (lossless, normal incidence).</li>
        </ul>
      </article>

      <article id="p5" class="fadeIn">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

        <div class="grid2">
          <div>
            <h3>Canvas 1 — Labeled setup diagram</h3>
            <ul>
              <li>Shows incident medium (n<sub>0</sub>), alternating layers (n<sub>1</sub>, n<sub>2</sub>) repeated N times, and substrate (n<sub>s</sub>).</li>
              <li>Arrows indicate incident and reflected waves.</li>
              <li>The diagram updates with N and the selected stack type (quarter/half) in the label.</li>
            </ul>
          </div>
          <div>
            <h3>Canvas 2 — Main quantitative plot</h3>
            <ul>
              <li>Plots <strong>Reflectance R</strong> versus <strong>normalized wavelength</strong> λ/λ<sub>0</sub> over a range (example: 0.6 to 1.4).</li>
              <li>A vertical marker shows the current wavelength slider value; the readout shows R at that point.</li>
              <li>This plot is computed with the <strong>full transfer matrix</strong>, so it is valid away from λ<sub>0</sub>.</li>
            </ul>
          </div>
        </div>

        <h3>Canvas 3 — Secondary plot (parameter sweep)</h3>
        <ul>
          <li>Shows <strong>R versus N</strong> at the currently selected wavelength (λ/λ<sub>0</sub> slider).</li>
          <li>This reveals how adding more pairs changes the reflectance at a fixed wavelength.</li>
        </ul>

        <div class="callout keyeq">
          <strong>Interactive controls</strong>
          <ul>
            <li><strong>Stack type:</strong> Quarter-wave or Half-wave (changes optical thickness design).</li>
            <li><strong>N pairs:</strong> changes the number of (n<sub>1</sub>, n<sub>2</sub>) repetitions.</li>
            <li><strong>Wavelength λ/λ<sub>0</sub>:</strong> detunes from design; updates both plots and the R-vs-N sweep.</li>
            <li><strong>Indices:</strong> example values can be changed to see how index contrast affects the mirror.</li>
          </ul>
        </div>
      </article>

      <section id="viz" class="fadeIn">
        <h2>Interactive Visualizations (Transfer-Matrix Simulation)</h2>
        <p style="color:var(--muted); margin-top:0">
          The formulas derived above are exact at λ = λ<sub>0</sub>. The plots below use the full transfer matrix to show what happens for any λ.
          <strong>Example values</strong> are used for plotting and can be changed.
        </p>

        <div class="controls" role="group" aria-label="Interactive controls">
          <div class="control">
            <label for="stackType">Stack type (optical thickness at λ0)</label>
            <select id="stackType">
              <option value="quarter" selected>Quarter-wave (nd = λ0/4)</option>
              <option value="half">Half-wave (nd = λ0/2)</option>
            </select>
            <div class="readout" id="typeReadout"></div>
          </div>

          <div class="control">
            <label for="N">Number of pairs N</label>
            <input id="N" type="range" min="0" max="12" step="1" value="6"/>
            <div class="readout" id="Nreadout"></div>
          </div>

          <div class="control">
            <label for="lamRatio">Wavelength ratio λ/λ0</label>
            <input id="lamRatio" type="range" min="0.60" max="1.40" step="0.002" value="1.00"/>
            <div class="readout" id="lamReadout"></div>
          </div>

          <div class="control">
            <label for="preset">Example material preset</label>
            <select id="preset">
              <option value="bragg" selected>Bragg-like: n0=1.00, n1=2.10, n2=1.45, ns=1.52</option>
              <option value="lowContrast">Low contrast: n0=1.00, n1=1.70, n2=1.45, ns=1.52</option>
              <option value="highContrast">High contrast: n0=1.00, n1=2.40, n2=1.38, ns=1.52</option>
            </select>
            <div class="readout" id="presetReadout"></div>
          </div>

          <div class="control">
            <label for="n0">n0 (incident medium)</label>
            <input id="n0" type="number" min="1" max="3" step="0.01" value="1.00"/>
            <div class="readout" id="n0r"></div>
          </div>

          <div class="control">
            <label for="n1">n1 (layer 1)</label>
            <input id="n1" type="number" min="1" max="4" step="0.01" value="2.10"/>
            <div class="readout" id="n1r"></div>
          </div>

          <div class="control">
            <label for="n2">n2 (layer 2)</label>
            <input id="n2" type="number" min="1" max="4" step="0.01" value="1.45"/>
            <div class="readout" id="n2r"></div>
          </div>

          <div class="control">
            <label for="ns">ns (substrate)</label>
            <input id="ns" type="number" min="1" max="4" step="0.01" value="1.52"/>
            <div class="readout" id="nsr"></div>
          </div>
        </div>

        <div class="vizWrap" style="margin-top:12px;">
          <figure style="margin:0">
            <canvas id="diagram" class="canvasShort" aria-label="Stack diagram"></canvas>
          </figure>

          <figure style="margin:0">
            <canvas id="plotMain" class="canvasTall" aria-label="Reflectance vs wavelength plot"></canvas>
          </figure>

          <figure style="margin:0">
            <canvas id="plotSecondary" class="canvasMid" aria-label="Reflectance vs N plot"></canvas>
          </figure>
        </div>

        <div class="callout final" style="margin-top:12px;">
          <strong>Copy-ready “final answers” (design-wavelength closed forms)</strong>
          <div class="eqbox" style="border-color:rgba(134,239,172,.35); background: rgba(134,239,172,.06);">
            <button class="copyBtn" data-copy="#eqAnswers">Copy</button>
            <pre id="eqAnswers">Assume normal incidence, non-magnetic, lossless layers. Let incident index be n0 and substrate index ns.
Stack consists of N pairs: (n1,d1) followed by (n2,d2), repeated N times.

Quarter-wave design: n1 d1 = n2 d2 = λ0/4  (so δ1=δ2=π/2 at λ0)
Y_in(λ0) = ns * (n1/n2)^(2N)
r(λ0) = [ ns*(n1/n2)^(2N) - n0 ] / [ ns*(n1/n2)^(2N) + n0 ]
R(λ0) = |r(λ0)|^2

Half-wave design: n1 d1 = n2 d2 = λ0/2  (so δ1=δ2=π at λ0)
Y_in(λ0) = ns
r(λ0) = (ns - n0)/(ns + n0)
R(λ0) = |(ns - n0)/(ns + n0)|^2</pre>
          </div>
        </div>
      </section>
    </div>
  </main>

  <footer>
    <div>
      <strong>Note:</strong> The interactive plots compute reflectance by the full transfer matrix at arbitrary λ, while the boxed symbolic results are the exact simplifications at λ = λ<sub>0</sub>.
      Example indices are provided for visualization and can be edited.
    </div>
  </footer>

  <script>
    // ---------- Smooth scroll for TOC ----------
    document.querySelectorAll('[data-scroll]').forEach(a=>{
      a.addEventListener('click', (e)=>{
        e.preventDefault();
        const id = a.getAttribute('href');
        const el = document.querySelector(id);
        if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
      });
    });

    // ---------- Copy buttons ----------
    function copyTextFrom(selector){
      const el = document.querySelector(selector);
      if(!el) return;
      const txt = el.innerText;
      navigator.clipboard.writeText(txt).then(()=> {
        // small non-intrusive feedback
        const btn = document.querySelector(`.copyBtn[data-copy="${selector}"]`);
        if(btn){
          const old = btn.textContent;
          btn.textContent = "Copied!";
          setTimeout(()=>btn.textContent = old, 900);
        }
      }).catch(()=>{ /* ignore */ });
    }
    document.querySelectorAll('.copyBtn').forEach(btn=>{
      btn.addEventListener('click', ()=> copyTextFrom(btn.getAttribute('data-copy')));
    });

    // ---------- Complex arithmetic ----------
    function C(re, im){ return {re, im}; }
    function cAdd(a,b){ return C(a.re+b.re, a.im+b.im); }
    function cSub(a,b){ return C(a.re-b.re, a.im-b.im); }
    function cMul(a,b){ return C(a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re); }
    function cDiv(a,b){
      const den = b.re*b.re + b.im*b.im;
      return C((a.re*b.re + a.im*b.im)/den, (a.im*b.re - a.re*b.im)/den);
    }
    function cAbs2(a){ return a.re*a.re + a.im*a.im; }

    // ---------- 2x2 complex matrices ----------
    function M2(a,b,c,d){ return [[a,b],[c,d]]; }
    function mMul(A,B){
      return [
        [ cAdd(cMul(A[0][0],B[0][0]), cMul(A[0][1],B[1][0])),
          cAdd(cMul(A[0][0],B[0][1]), cMul(A[0][1],B[1][1])) ],
        [ cAdd(cMul(A[1][0],B[0][0]), cMul(A[1][1],B[1][0])),
          cAdd(cMul(A[1][0],B[0][1]), cMul(A[1][1],B[1][1])) ]
      ];
    }

    // Characteristic matrix at normal incidence with admittance Y=n (non-magnetic)
    function layerMatrix(n, delta){
      const cd = Math.cos(delta);
      const sd = Math.sin(delta);
      const i = C(0,1);
      // cosδ is real
      const m11 = C(cd,0);
      const m22 = C(cd,0);
      // i sinδ / n
      const m12 = cMul(i, C(sd/n, 0));
      // i n sinδ
      const m21 = cMul(i, C(n*sd, 0));
      return M2(m11,m12,m21,m22);
    }

    // Compute reflectance for a stack of N pairs (n1 then n2), equal optical thickness.
    // type: 'quarter' => optical thickness = λ0/4; 'half' => λ0/2
    // lamRatio = λ/λ0
    function reflectance(lamRatio, N, n0, n1, n2, ns, type){
      const m = (type === 'half') ? 0.5 : 0.25; // nd/λ0
      // delta = 2π*(nd)/λ = 2π*m*(λ0/λ) = 2π*m*(1/lamRatio)
      const delta = 2*Math.PI*m*(1/lamRatio);

      // build total matrix for 2N layers: [n1,n2] repeated
      let M = M2(C(1,0), C(0,0), C(0,0), C(1,0));
      for(let k=0;k<N;k++){
        // order: first n1 then n2 (incident -> ... -> substrate)
        const M1 = layerMatrix(n1, delta);
        const M2l = layerMatrix(n2, delta);
        M = mMul(M, M1);
        M = mMul(M, M2l);
      }

      // input admittance Yin = (M11*Ys + M12)/(M21*Ys + M22)
      const Ys = C(ns,0);
      const num = cAdd(cMul(M[0][0], Ys), M[0][1]);
      const den = cAdd(cMul(M[1][0], Ys), M[1][1]);
      const Yin = cDiv(num, den);

      // r = (Yin - Y0)/(Yin + Y0)
      const Y0 = C(n0,0);
      const r = cDiv(cSub(Yin, Y0), cAdd(Yin, Y0));
      const R = cAbs2(r);
      return {R, r, Yin};
    }

    // Closed-form design-wavelength reflectance for teaching comparisons
    function closedFormAtLam0(N, n0, n1, n2, ns, type){
      if(type === 'half'){
        const r = (ns - n0)/(ns + n0);
        return {R: r*r, r: r};
      }else{
        const Yin = ns * Math.pow(n1/n2, 2*N);
        const r = (Yin - n0)/(Yin + n0);
        return {R: r*r, r: r, Yin: Yin};
      }
    }

    // ---------- Canvas helpers ----------
    function setupCanvas(canvas){
      const ctx = canvas.getContext('2d');
      function resize(){
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.round(rect.width * dpr);
        canvas.height = Math.round(rect.height * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);
        return {w: rect.width, h: rect.height};
      }
      return {ctx, resize};
    }

    function drawGridAxes(ctx, x, y, w, h, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
      // background
      ctx.save();
      ctx.clearRect(x, y, w, h);

      // title
      ctx.fillStyle = 'rgba(230,234,242,.95)';
      ctx.font = '600 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(title, x+12, y+20);

      const plotPad = {l:56, r:16, t:34, b:44};
      const px = x + plotPad.l, py = y + plotPad.t;
      const pw = w - plotPad.l - plotPad.r, ph = h - plotPad.t - plotPad.b;

      // plot area
      ctx.strokeStyle = 'rgba(255,255,255,.10)';
      ctx.lineWidth = 1;
      ctx.strokeRect(px, py, pw, ph);

      // gridlines + ticks
      const xTicks = 6;
      const yTicks = 5;
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.fillStyle = 'rgba(152,162,179,.95)';
      ctx.strokeStyle = 'rgba(255,255,255,.08)';

      for(let i=0;i<=xTicks;i++){
        const t = i/xTicks;
        const xx = px + t*pw;
        ctx.beginPath();
        ctx.moveTo(xx, py);
        ctx.lineTo(xx, py+ph);
        ctx.stroke();
        const val = xMin + t*(xMax-xMin);
        ctx.fillText(val.toFixed(2), xx-14, py+ph+18);
      }
      for(let j=0;j<=yTicks;j++){
        const t = j/yTicks;
        const yy = py + (1-t)*ph;
        ctx.beginPath();
        ctx.moveTo(px, yy);
        ctx.lineTo(px+pw, yy);
        ctx.stroke();
        const val = yMin + t*(yMax-yMin);
        ctx.fillText(val.toFixed(2), px-46, yy+4);
      }

      // axis labels
      ctx.fillStyle = 'rgba(230,234,242,.88)';
      ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(xLabel, px + pw/2 - ctx.measureText(xLabel).width/2, py+ph+36);

      ctx.save();
      ctx.translate(px-44, py + ph/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
      ctx.restore();

      ctx.restore();

      function X(xv){ return px + (xv - xMin)/(xMax-xMin)*pw; }
      function Y(yv){ return py + (1-(yv - yMin)/(yMax-yMin))*ph; }
      return {px,py,pw,ph, X, Y};
    }

    function drawLegend(ctx, items, x, y){
      ctx.save();
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      let yy = y;
      items.forEach(it=>{
        ctx.fillStyle = it.color;
        ctx.fillRect(x, yy-9, 14, 3);
        ctx.fillStyle = 'rgba(230,234,242,.90)';
        ctx.fillText(it.label, x+20, yy-4);
        yy += 16;
      });
      ctx.restore();
    }

    // ---------- Draw diagram ----------
    function drawDiagram(ctx, W, H, state){
      ctx.clearRect(0,0,W,H);

      // title band
      ctx.fillStyle = 'rgba(0,0,0,.25)';
      ctx.fillRect(0,0,W,34);
      ctx.fillStyle = 'rgba(230,234,242,.95)';
      ctx.font = '600 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('Multilayer stack geometry (normal incidence)', 12, 22);

      const pad = 16;
      const y0 = 52;
      const h = H - y0 - 16;
      const x0 = pad;
      const x1 = W - pad;

      // region widths
      const leftW = Math.max(90, W*0.18);
      const rightW = Math.max(90, W*0.18);
      const stackW = (x1-x0) - leftW - rightW;

      // draw incident medium
      ctx.fillStyle = 'rgba(125,211,252,.10)';
      ctx.strokeStyle = 'rgba(125,211,252,.22)';
      ctx.lineWidth = 1;
      ctx.fillRect(x0, y0, leftW, h);
      ctx.strokeRect(x0, y0, leftW, h);

      // draw substrate
      ctx.fillStyle = 'rgba(167,243,208,.10)';
      ctx.strokeStyle = 'rgba(167,243,208,.22)';
      ctx.fillRect(x1-rightW, y0, rightW, h);
      ctx.strokeRect(x1-rightW, y0, rightW, h);

      // draw stack layers
      const N = state.N;
      const nLayers = Math.max(1, 2*Math.max(N,1));
      const layerW = stackW / nLayers;
      let x = x0 + leftW;

      for(let i=0;i<nLayers;i++){
        const isN1 = (i%2===0);
        ctx.fillStyle = isN1 ? 'rgba(125,211,252,.14)' : 'rgba(167,243,208,.12)';
        ctx.strokeStyle = 'rgba(255,255,255,.08)';
        ctx.fillRect(x, y0, layerW, h);
        ctx.strokeRect(x, y0, layerW, h);
        x += layerW;
      }

      // interface lines
      ctx.strokeStyle = 'rgba(255,255,255,.12)';
      ctx.beginPath();
      ctx.moveTo(x0+leftW, y0);
      ctx.lineTo(x0+leftW, y0+h);
      ctx.moveTo(x1-rightW, y0);
      ctx.lineTo(x1-rightW, y0+h);
      ctx.stroke();

      // labels
      ctx.fillStyle = 'rgba(230,234,242,.92)';
      ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(`Incident medium: n0 = ${state.n0.toFixed(2)}`, x0+10, y0+18);
      ctx.fillText(`Substrate: ns = ${state.ns.toFixed(2)}`, x1-rightW+10, y0+18);

      // stack label
      const typeLabel = state.type === 'half' ? 'Half-wave (nd=λ0/2)' : 'Quarter-wave (nd=λ0/4)';
      ctx.fillText(`Stack: N = ${state.N} pairs (n1=${state.n1.toFixed(2)}, n2=${state.n2.toFixed(2)}) — ${typeLabel}`, x0+leftW+10, y0+18);

      // arrows for waves
      const midY = y0 + h*0.62;
      ctx.strokeStyle = 'rgba(230,234,242,.85)';
      ctx.lineWidth = 2;

      // incident arrow
      drawArrow(ctx, x0+12, midY, x0+leftW-16, midY);
      ctx.fillStyle = 'rgba(230,234,242,.85)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.fillText('incident', x0+14, midY-10);

      // reflected arrow
      drawArrow(ctx, x0+leftW-16, midY-30, x0+20, midY-30);
      ctx.fillText('reflected', x0+24, midY-40);

      // transmitted arrow
      drawArrow(ctx, x1-rightW+16, midY, x1-12, midY);
      ctx.fillText('transmitted', x1-rightW+16, midY-10);

      // small legend for n1/n2 colors
      ctx.fillStyle = 'rgba(125,211,252,.8)';
      ctx.fillRect(x0+leftW+12, y0+h-26, 18, 6);
      ctx.fillStyle = 'rgba(230,234,242,.85)';
      ctx.fillText('n1 layer', x0+leftW+36, y0+h-20);

      ctx.fillStyle = 'rgba(167,243,208,.75)';
      ctx.fillRect(x0+leftW+110, y0+h-26, 18, 6);
      ctx.fillStyle = 'rgba(230,234,242,.85)';
      ctx.fillText('n2 layer', x0+leftW+134, y0+h-20);
    }

    function drawArrow(ctx, x1,y1,x2,y2){
      const head = 8;
      const dx = x2-x1, dy = y2-y1;
      const ang = Math.atan2(dy,dx);
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x2,y2);
      ctx.lineTo(x2 - head*Math.cos(ang-Math.PI/6), y2 - head*Math.sin(ang-Math.PI/6));
      ctx.lineTo(x2 - head*Math.cos(ang+Math.PI/6), y2 - head*Math.sin(ang+Math.PI/6));
      ctx.closePath();
      ctx.fillStyle = 'rgba(230,234,242,.85)';
      ctx.fill();
    }

    // ---------- Plotting ----------
    function drawMainPlot(ctx, W, H, state){
      const xMin = 0.60, xMax = 1.40;
      const yMin = 0.0, yMax = 1.0;
      const ax = drawGridAxes(ctx, 0, 0, W, H, xMin, xMax, yMin, yMax,
                             'λ / λ0 (dimensionless)', 'Reflectance R (dimensionless)',
                             'Main plot: Reflectance spectrum R(λ) (full transfer matrix)');

      // compute curve
      const nPts = 360;
      const pts = [];
      for(let i=0;i<=nPts;i++){
        const t = i/nPts;
        const lamR = xMin + t*(xMax-xMin);
        const res = reflectance(lamR, state.N, state.n0, state.n1, state.n2, state.ns, state.type);
        pts.push({x: lamR, y: Math.max(0, Math.min(1, res.R))});
      }

      // draw curve
      ctx.save();
      ctx.strokeStyle = 'rgba(125,211,252,.90)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      pts.forEach((p, idx)=>{
        const X = ax.X(p.x), Y = ax.Y(p.y);
        if(idx===0) ctx.moveTo(X,Y);
        else ctx.lineTo(X,Y);
      });
      ctx.stroke();

      // marker at current wavelength
      const lam = state.lamRatio;
      const resM = reflectance(lam, state.N, state.n0, state.n1, state.n2, state.ns, state.type);
      const Rm = Math.max(0, Math.min(1, resM.R));

      // vertical line
      ctx.strokeStyle = 'rgba(255,255,255,.30)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(ax.X(lam), ax.py);
      ctx.lineTo(ax.X(lam), ax.py+ax.ph);
      ctx.stroke();

      // point
      ctx.fillStyle = 'rgba(167,243,208,.95)';
      ctx.beginPath();
      ctx.arc(ax.X(lam), ax.Y(Rm), 4.5, 0, Math.PI*2);
      ctx.fill();

      // legend
      drawLegend(ctx, [{label:`R(λ) — ${state.type==='half'?'half-wave':'quarter-wave'} stack`, color:'rgba(125,211,252,.90)'},
                       {label:`marker at λ/λ0=${lam.toFixed(3)} → R=${Rm.toFixed(4)}`, color:'rgba(167,243,208,.95)'}],
                 ax.px+10, ax.py+24);

      // show design-wavelength closed-form value as a horizontal dashed line at λ/λ0=1 (for reference)
      const resDesignClosed = closedFormAtLam0(state.N, state.n0, state.n1, state.n2, state.ns, state.type);
      const Rdesign = Math.max(0, Math.min(1, resDesignClosed.R));
      ctx.setLineDash([6,5]);
      ctx.strokeStyle = 'rgba(255,255,255,.18)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(ax.px, ax.Y(Rdesign));
      ctx.lineTo(ax.px+ax.pw, ax.Y(Rdesign));
      ctx.stroke();
      ctx.setLineDash([]);

      // label
      ctx.fillStyle = 'rgba(255,255,255,.65)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.fillText(`Closed-form at λ=λ0: R(λ0) ≈ ${Rdesign.toFixed(4)}`, ax.px+12, ax.Y(Rdesign)-8);

      ctx.restore();

      return {Rm, resM};
    }

    function drawSecondaryPlot(ctx, W, H, state){
      const xMin = 0, xMax = 12;
      const yMin = 0, yMax = 1;
      const ax = drawGridAxes(ctx, 0, 0, W, H, xMin, xMax, yMin, yMax,
                             'Number of pairs N (dimensionless)', 'Reflectance R (dimensionless)',
                             'Secondary plot: R versus N at the selected wavelength');

      // compute for N=0..12
      const lam = state.lamRatio;
      const vals = [];
      for(let N=0; N<=12; N++){
        const res = reflectance(lam, N, state.n0, state.n1, state.n2, state.ns, state.type);
        vals.push({N, R: Math.max(0, Math.min(1, res.R))});
      }

      // draw line
      ctx.save();
      ctx.strokeStyle = 'rgba(167,243,208,.90)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      vals.forEach((p, idx)=>{
        const X = ax.X(p.N), Y = ax.Y(p.R);
        if(idx===0) ctx.moveTo(X,Y);
        else ctx.lineTo(X,Y);
      });
      ctx.stroke();

      // dots
      ctx.fillStyle = 'rgba(167,243,208,.90)';
      vals.forEach(p=>{
        ctx.beginPath();
        ctx.arc(ax.X(p.N), ax.Y(p.R), 3.2, 0, Math.PI*2);
        ctx.fill();
      });

      // highlight current N
      const curr = vals[state.N] || vals[0];
      ctx.fillStyle = 'rgba(125,211,252,.95)';
      ctx.beginPath();
      ctx.arc(ax.X(curr.N), ax.Y(curr.R), 5, 0, Math.PI*2);
      ctx.fill();

      drawLegend(ctx, [
        {label:`R(N) at λ/λ0=${lam.toFixed(3)} — ${state.type==='half'?'half-wave':'quarter-wave'}`, color:'rgba(167,243,208,.90)'},
        {label:`current N=${state.N} → R=${curr.R.toFixed(4)}`, color:'rgba(125,211,252,.95)'}
      ], ax.px+10, ax.py+24);

      ctx.restore();
    }

    // ---------- UI state ----------
    const el = {
      stackType: document.getElementById('stackType'),
      N: document.getElementById('N'),
      lamRatio: document.getElementById('lamRatio'),
      preset: document.getElementById('preset'),
      n0: document.getElementById('n0'),
      n1: document.getElementById('n1'),
      n2: document.getElementById('n2'),
      ns: document.getElementById('ns'),
      typeReadout: document.getElementById('typeReadout'),
      Nreadout: document.getElementById('Nreadout'),
      lamReadout: document.getElementById('lamReadout'),
      presetReadout: document.getElementById('presetReadout'),
      n0r: document.getElementById('n0r'),
      n1r: document.getElementById('n1r'),
      n2r: document.getElementById('n2r'),
      nsr: document.getElementById('nsr'),
      diagram: document.getElementById('diagram'),
      plotMain: document.getElementById('plotMain'),
      plotSecondary: document.getElementById('plotSecondary')
    };

    const canv = {
      diagram: setupCanvas(el.diagram),
      main: setupCanvas(el.plotMain),
      secondary: setupCanvas(el.plotSecondary)
    };

    function getState(){
      const type = el.stackType.value;
      const N = parseInt(el.N.value,10);
      const lamRatio = parseFloat(el.lamRatio.value);
      const n0 = parseFloat(el.n0.value);
      const n1 = parseFloat(el.n1.value);
      const n2 = parseFloat(el.n2.value);
      const ns = parseFloat(el.ns.value);
      return {type, N, lamRatio, n0, n1, n2, ns};
    }

    function setPreset(name){
      if(name === 'bragg'){
        el.n0.value = "1.00"; el.n1.value="2.10"; el.n2.value="1.45"; el.ns.value="1.52";
      }else if(name === 'lowContrast'){
        el.n0.value = "1.00"; el.n1.value="1.70"; el.n2.value="1.45"; el.ns.value="1.52";
      }else if(name === 'highContrast'){
        el.n0.value = "1.00"; el.n1.value="2.40"; el.n2.value="1.38"; el.ns.value="1.52";
      }
    }

    function updateReadouts(state){
      el.typeReadout.textContent = (state.type==='half')
        ? "Design: nd = λ0/2 (δ=π at λ0)"
        : "Design: nd = λ0/4 (δ=π/2 at λ0)";
      el.Nreadout.textContent = `N = ${state.N}`;
      el.lamReadout.textContent = `λ/λ0 = ${state.lamRatio.toFixed(3)}`;

      el.n0r.textContent = `n0 = ${state.n0.toFixed(2)}`;
      el.n1r.textContent = `n1 = ${state.n1.toFixed(2)}`;
      el.n2r.textContent = `n2 = ${state.n2.toFixed(2)}`;
      el.nsr.textContent = `ns = ${state.ns.toFixed(2)}`;

      const cf = closedFormAtLam0(state.N, state.n0, state.n1, state.n2, state.ns, state.type);
      el.presetReadout.textContent = `Closed-form at λ=λ0 (current N): R(λ0) ≈ ${cf.R.toFixed(4)}`;
    }

    function render(){
      const state = getState();
      updateReadouts(state);

      // resize and draw
      const d = canv.diagram.resize();
      drawDiagram(canv.diagram.ctx, d.w, d.h, state);

      const m = canv.main.resize();
      drawMainPlot(canv.main.ctx, m.w, m.h, state);

      const s = canv.secondary.resize();
      drawSecondaryPlot(canv.secondary.ctx, s.w, s.h, state);
    }

    // ---------- Event wiring ----------
    ['change','input'].forEach(evt=>{
      el.stackType.addEventListener(evt, render);
      el.N.addEventListener(evt, render);
      el.lamRatio.addEventListener(evt, render);
      el.n0.addEventListener(evt, render);
      el.n1.addEventListener(evt, render);
      el.n2.addEventListener(evt, render);
      el.ns.addEventListener(evt, render);
    });

    el.preset.addEventListener('change', ()=>{
      setPreset(el.preset.value);
      render();
    });

    window.addEventListener('resize', ()=>{
      // debounced-ish
      clearTimeout(window.__rz);
      window.__rz = setTimeout(render, 80);
    });

    // initial render
    render();
  </script>
</body>
</html>
