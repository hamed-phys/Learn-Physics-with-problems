<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Bragg Grating (Dielectric Stack): Transfer Matrix + Angular & Spectral Reflectance</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#0f1833;
      --card2:#0c142c;
      --text:#eaf0ff;
      --muted:#b8c4e6;
      --muted2:#95a4cf;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 700px at 20% -10%, rgba(125,211,252,.20), transparent 60%),
        radial-gradient(1000px 700px at 100% 10%, rgba(167,139,250,.18), transparent 55%),
        radial-gradient(900px 600px at 60% 120%, rgba(52,211,153,.12), transparent 60%),
        var(--bg);
      color:var(--text);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:38px 18px 16px;
      max-width:1200px;
      margin:0 auto;
    }
    .hero{
      display:grid;
      gap:14px;
      grid-template-columns: 1.35fr .65fr;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns:1fr}
    }
    .titleCard{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:22px 22px 18px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .titleCard:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(600px 180px at 20% 0%, rgba(125,211,252,.14), transparent 70%),
                  radial-gradient(600px 180px at 90% 30%, rgba(167,139,250,.12), transparent 70%);
      pointer-events:none;
      filter: blur(0px);
      opacity:.95;
    }
    .titleCard > *{position:relative}
    h1{
      margin:0 0 10px;
      font-size:clamp(22px, 2.3vw, 34px);
      letter-spacing:.2px;
      line-height:1.2;
    }
    .subtitle{
      color:var(--muted);
      font-size: 15px;
      margin:0;
      max-width: 70ch;
    }
    .meta{
      display:flex; flex-wrap:wrap; gap:10px;
      margin-top:14px;
    }
    .pill{
      font-size:12px;
      color:var(--muted);
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      padding:6px 10px;
      border-radius:999px;
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
    }
    .dot{width:7px; height:7px; border-radius:50%}
    .dot.a{background:var(--accent)}
    .dot.b{background:var(--accent2)}
    .dot.c{background:var(--good)}
    .tocCard{
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:14px 14px;
      box-shadow: var(--shadow);
      position:sticky;
      top:14px;
      align-self:start;
      max-height: calc(100vh - 28px);
      overflow:auto;
    }
    .tocTitle{
      display:flex;
      align-items:center;
      gap:10px;
      margin:0 0 10px;
      color:var(--muted);
      font-size:13px;
      letter-spacing:.12em;
      text-transform:uppercase;
    }
    .toc a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      color:var(--text);
      font-size:13px;
      border:1px solid transparent;
    }
    .toc a:hover{
      background: rgba(255,255,255,.04);
      border-color: rgba(255,255,255,.08);
      text-decoration:none;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding:0 18px 56px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
      .tocCard{position:relative; top:auto}
    }

    section{
      background:rgba(255,255,255,.03);
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:18px 18px;
      box-shadow: var(--shadow);
      margin:16px 0;
      overflow:hidden;
    }
    section h2{
      margin:0 0 10px;
      font-size:18px;
      letter-spacing:.2px;
    }
    section h3{
      margin:14px 0 8px;
      font-size:15px;
      color:var(--accent);
    }
    p{margin:10px 0; color:var(--text)}
    ul{margin:10px 0 10px 22px; color:var(--text)}
    li{margin:6px 0}
    .muted{color:var(--muted)}
    .small{font-size:13px; color:var(--muted)}
    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    @media (max-width: 760px){ .callouts{grid-template-columns:1fr} }

    .box{
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(15,24,51,.92), rgba(12,20,44,.9));
      border-radius:16px;
      padding:12px 12px;
    }
    .box strong{color:var(--accent)}
    .box.warn strong{color:var(--warn)}
    .box.good strong{color:var(--good)}
    .box.bad strong{color:var(--bad)}

    .equation{
      position:relative;
      border:1px solid rgba(125,211,252,.22);
      background: rgba(125,211,252,.06);
      border-radius:16px;
      padding:12px 12px 12px;
      margin:12px 0;
      overflow:hidden;
    }
    .equation pre{
      margin:0;
      font-family:var(--mono);
      font-size:13px;
      white-space:pre-wrap;
      word-break:break-word;
      color:var(--text);
    }
    .copyBtn{
      position:absolute;
      top:10px;
      right:10px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:var(--text);
      border-radius:12px;
      padding:6px 10px;
      font-size:12px;
      cursor:pointer;
      transition: transform .08s ease, background .2s ease;
      user-select:none;
    }
    .copyBtn:hover{background: rgba(255,255,255,.10)}
    .copyBtn:active{transform: translateY(1px)}
    .toast{
      position:fixed;
      bottom:14px; left:50%;
      transform: translateX(-50%);
      background: rgba(15,24,51,.95);
      border:1px solid rgba(255,255,255,.15);
      padding:10px 12px;
      border-radius:999px;
      color:var(--text);
      font-size:13px;
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: opacity .25s ease, transform .25s ease;
      z-index:50;
    }
    .toast.show{opacity:1; transform: translateX(-50%) translateY(-6px)}
    .vizWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .vizCard{
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(15,24,51,.9), rgba(12,20,44,.92));
      border-radius:16px;
      padding:12px 12px;
      overflow:hidden;
    }
    .vizHeader{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .vizHeader h3{
      margin:0;
      color:var(--text);
      font-size:14px;
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 760px){ .controls{grid-template-columns:1fr} }
    .ctrl{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      border-radius:14px;
      padding:10px 10px;
    }
    .ctrl label{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      font-size:12px;
      color:var(--muted);
      margin-bottom:6px;
      letter-spacing:.02em;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    select, button{
      width:100%;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:var(--text);
      border-radius:12px;
      padding:8px 10px;
      font-size:13px;
    }
    button{
      cursor:pointer;
      transition: transform .08s ease, background .2s ease;
    }
    button:hover{background: rgba(255,255,255,.10)}
    button:active{transform: translateY(1px)}
    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .kbd{
      font-family:var(--mono);
      font-size:12px;
      color:var(--muted);
      border:1px solid rgba(255,255,255,.12);
      border-bottom-color: rgba(255,255,255,.18);
      background: rgba(0,0,0,.18);
      padding:3px 8px;
      border-radius:10px;
    }
    figure{margin:0}
    canvas{
      width:100%;
      height:280px;
      display:block;
      border-radius:14px;
      background: rgba(0,0,0,.15);
      border:1px solid rgba(255,255,255,.10);
    }
    .twoCanv{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    footer{
      max-width:1200px;
      margin:0 auto;
      padding:18px 18px 40px;
      color:var(--muted2);
      font-size:13px;
    }

    /* subtle animation */
    @media (prefers-reduced-motion: no-preference){
      section{animation: fadeIn .55s ease both}
      @keyframes fadeIn{
        from{opacity:0; transform: translateY(8px)}
        to{opacity:1; transform: translateY(0)}
      }
    }

    /* print */
    @media print{
      body{background:#fff; color:#000}
      section, .titleCard, .tocCard, .vizCard{box-shadow:none}
      .tocCard{display:none}
      .copyBtn, .controls, button{display:none !important}
      canvas{border:1px solid #999}
      a{color:#000; text-decoration:none}
    }
  </style>
</head>

<body>
  <header>
    <div class="hero">
      <div class="titleCard">
        <h1>Dielectric Bragg Grating (Alternating Stack): Transfer Matrix + Angular & Spectral Reflectance</h1>
        <p class="subtitle">
          We derive the <span class="muted">wave-transfer (characteristic) matrix</span> for an <b>N-layer alternating dielectric Bragg grating</b>,
          then compute the <b>power reflectance</b> versus <b>frequency</b> and <b>incident angle</b> for <b>TE</b> and <b>TM</b> polarizations.
          The interactive plots below let you reproduce the qualitative behavior of the classic spectral/angle reflectance graphs.
        </p>
        <div class="meta">
          <span class="pill"><span class="dot a"></span> Transfer-matrix method (TMM)</span>
          <span class="pill"><span class="dot b"></span> TE/TM polarization</span>
          <span class="pill"><span class="dot c"></span> Stopband & Bragg condition</span>
        </div>
      </div>

      <aside class="tocCard" aria-label="Table of Contents">
        <div class="tocTitle">Contents</div>
        <nav class="toc">
          <a href="#quick" data-scroll>Quick Summary</a>
          <a href="#p0" data-scroll>PART 0 — Concept Primer</a>
          <a href="#p1" data-scroll>PART 1 — Problem Analysis</a>
          <a href="#p2" data-scroll>PART 2 — Strategy & Tips</a>
          <a href="#p3" data-scroll>PART 3 — Full Solution</a>
          <a href="#p4" data-scroll>PART 4 — Deeper Understanding</a>
          <a href="#p5" data-scroll>PART 5 — Visualization Guide</a>
        </nav>
      </aside>
    </div>
  </header>

  <main>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>What this problem is about:</b> Find the transfer matrix of an alternating dielectric (Bragg) stack and compute its <b>reflectance</b> versus <b>frequency</b> and <b>angle</b>.</li>
        <li><b>Key physics idea:</b> Multiple reflections inside a periodic stack interfere; near the <b>Bragg condition</b> they add constructively to create a <b>stopband</b> with high reflectance.</li>
        <li><b>Governing tool:</b> The <b>2×2 characteristic matrix</b> of each layer, multiplied across layers to obtain the whole stack matrix.</li>
        <li><b>Polarization dependence:</b> TE and TM use different <b>optical admittance</b> (effective impedance), which makes the stopband vary with angle and can shrink for TM near Brewster-like behavior.</li>
        <li><b>Main equations:</b> Layer matrix
          <span class="muted">M<sub>j</sub> = [[cosδ<sub>j</sub>, i sinδ<sub>j</sub>/q<sub>j</sub>],[i q<sub>j</sub> sinδ<sub>j</sub>, cosδ<sub>j</sub>]]</span>,
          total <span class="muted">M = ∏ M<sub>j</sub></span>,
          reflection coefficient <span class="muted">r = (q0 A − B)/(q0 A + B)</span> with A,B built from M and substrate admittance.
        </li>
        <li><b>Result type:</b> Symbolic formulas for <b>M</b> and <b>r</b>, and numeric/graphical reflectance <b>R(ν,θ)</b> and <b>R(θ)</b> for chosen parameters.</li>
      </ul>
    </section>

    <div class="grid">
      <div>
        <section id="p0">
          <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

          <h3>0.1 Core definitions (symbols & units)</h3>
          <ul>
            <li><b>Refractive index</b> <span class="muted">n</span> (dimensionless): relates phase velocity to c.</li>
            <li><b>Vacuum wavelength</b> <span class="muted">λ</span> (m) and <b>frequency</b> <span class="muted">ν</span> (Hz), with <span class="muted">λ = c/ν</span>.</li>
            <li><b>Incidence angle</b> <span class="muted">θ</span> (rad or deg): measured from the layer normal.</li>
            <li><b>Snell’s law</b>: <span class="muted">n₀ sinθ₀ = nⱼ sinθⱼ</span>.</li>
            <li><b>Layer thickness</b> <span class="muted">dⱼ</span> (m) and <b>phase thickness</b> <span class="muted">δⱼ = k₀ nⱼ dⱼ cosθⱼ</span> (rad), with <span class="muted">k₀ = 2π/λ</span>.</li>
            <li><b>Power reflectance</b> <span class="muted">R</span> (unitless): <span class="muted">R = |r|²</span>.</li>
          </ul>

          <h3>0.2 Physical meaning of key quantities</h3>
          <ul>
            <li><span class="muted">δⱼ</span> controls how much phase accumulates while traversing layer <span class="muted">j</span>. In a periodic stack, the accumulated phase sets whether reflections add or cancel.</li>
            <li><span class="muted">qⱼ</span> is an “optical admittance” (impedance-like factor) that connects tangential field components across interfaces. It differs for TE vs TM.</li>
            <li>The <b>2×2 matrix</b> is powerful because it propagates fields through a layer via linear algebra: stack = product of matrices.</li>
          </ul>

          <h3>0.3 Key principles & validity</h3>
          <div class="callouts">
            <div class="box good">
              <strong>Maxwell + boundary conditions</strong><br/>
              For plane waves in linear, isotropic, non-magnetic layers (μ≈μ₀), tangential E and H are continuous at interfaces.
              This yields a linear map between fields on either side → the transfer matrix.
            </div>
            <div class="box warn">
              <strong>Assumptions</strong><br/>
              Homogeneous layers, flat parallel interfaces, steady-state harmonic waves (e^{-iωt}), no diffraction (1D stack),
              and typically lossless indices for the simplest Bragg-grating reflectance.
            </div>
          </div>

          <h3>0.4 Common models/approximations (and why)</h3>
          <ul>
            <li><b>Quarter-wave stack</b>: choose <span class="muted">n₁ d₁ = n₂ d₂ = λB/4</span> at a design wavelength <span class="muted">λB</span>. This makes reflections from each interface add constructively near <span class="muted">λB</span>.</li>
            <li><b>Matched outer media</b>: set incident medium index <span class="muted">n₀</span> and substrate index <span class="muted">n_s</span> equal (or equal to one of the layer indices). This isolates the Bragg physics from trivial Fresnel mismatch.</li>
            <li><b>Normalized frequency</b>: use <span class="muted">ν/νB = λB/λ</span>. Then the design point is <span class="muted">ν/νB = 1</span>.</li>
          </ul>

          <h3>0.5 Mini intuition examples</h3>
          <ul>
            <li><b>Example A (on-Bragg):</b> If each layer is quarter-wave, a round trip between similar interfaces accumulates near π phase, causing many partial reflections to line up → high reflectance (stopband).</li>
            <li><b>Example B (off-Bragg):</b> If frequency shifts so δ differs, reflections become out of phase and cancel → transmission increases and reflectance shows ripples.</li>
          </ul>

          <h3>0.6 What to watch for (pitfalls)</h3>
          <ul>
            <li>Mixing TE/TM admittances (they are not the same at oblique incidence).</li>
            <li>Forgetting Snell’s law inside each layer (θ changes with n).</li>
            <li>Confusing <b>amplitude reflection</b> r with <b>power reflectance</b> R = |r|².</li>
            <li>Design thickness (quarter-wave) is usually defined at a chosen reference angle; if you design at normal incidence, the stopband shifts with angle.</li>
          </ul>
        </section>

        <section id="p1">
          <h2>PART 1 — Problem Analysis (no solving yet)</h2>

          <h3>1.1 Restate the problem</h3>
          <p>
            We have a one-dimensional dielectric Bragg grating: <b>N alternating layers</b> with refractive indices
            <span class="muted">n₁</span> and <span class="muted">n₂</span> (and thicknesses <span class="muted">d₁</span>, <span class="muted">d₂</span>),
            illuminated by a plane wave at incident angle <span class="muted">θ₀</span>. Using matrix algebra, we must:
          </p>
          <ul>
            <li>Derive the <b>wave-transfer matrix</b> for the stack.</li>
            <li>Compute the <b>reflectance</b> as a function of <b>frequency</b> (spectral dependence) and <b>angle</b> (angular dependence).</li>
            <li>Check TE and TM behavior and reproduce the qualitative trends of classic reflectance plots.</li>
          </ul>

          <h3>1.2 Given quantities</h3>
          <ul>
            <li>Alternating indices <span class="muted">n₁</span>, <span class="muted">n₂</span> and number of layers (or “segments”) <span class="muted">N</span>.</li>
            <li>Layer thicknesses <span class="muted">d₁</span>, <span class="muted">d₂</span> (often quarter-wave at design frequency).</li>
            <li>Incident medium index <span class="muted">n₀</span> and substrate index <span class="muted">n_s</span>.</li>
            <li>Incident angle <span class="muted">θ₀</span>, polarization TE or TM, and frequency <span class="muted">ν</span>.</li>
          </ul>

          <h3>1.3 Unknowns / what must be found</h3>
          <ul>
            <li>The <b>total characteristic matrix</b> <span class="muted">M</span> of the N-layer stack.</li>
            <li>The amplitude reflection coefficient <span class="muted">r(ν,θ₀)</span> and power reflectance <span class="muted">R(ν,θ₀)=|r|²</span>.</li>
          </ul>

          <h3>1.4 Why these principles apply (and why others don’t)</h3>
          <ul>
            <li>Because the structure is <b>planar and layered</b>, fields depend on z only (1D), so the <b>transfer matrix method</b> is exact (within linear, homogeneous-layer assumptions).</li>
            <li>We do <b>not</b> need diffraction grating theory (no lateral periodicity); we also do <b>not</b> need coupled-mode theory unless we want approximate analytic band edges.</li>
          </ul>

          <div class="callouts">
            <div class="box warn">
              <strong>Explicit assumptions</strong><br/>
              Layers are isotropic, non-magnetic, lossless (for clarity), interfaces are perfect planes, and the incident wave is a single plane wave.
            </div>
            <div class="box">
              <strong>What “verify graphs” means</strong><br/>
              Use the derived formula/program to compute <b>R vs ν</b> for fixed angles and <b>R vs θ</b> for fixed frequencies, then compare the trends (stopband width, angle shift, TE vs TM differences).
            </div>
          </div>

          <h3>1.5 Possible approaches (compare)</h3>
          <ul>
            <li><b>(A) Transfer matrix (chosen):</b> Exact for layered media, straightforward numerically, works for any N, angle, TE/TM. <span class="muted">Best for reproducing plots.</span></li>
            <li><b>(B) Bloch-wave band structure:</b> Elegant for infinite periodic stacks (gives stopband condition), but finite-N reflectance needs extra work (interfaces/finite size).</li>
            <li><b>(C) Coupled-mode theory:</b> Gives intuitive analytic forms near Bragg; great for weak index contrast, but less exact for high contrast or short stacks.</li>
          </ul>

          <p><b>Choice:</b> We use <b>(A) Transfer matrix</b> because the prompt asks for “based on matrix algebra” and because it directly produces the spectral and angular reflectance curves for finite N.</p>
        </section>

        <section id="p2">
          <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

          <ol>
            <li>
              <b>Set geometry & angles</b><br/>
              Goal: get <span class="muted">θⱼ</span> in every layer.<br/>
              Tool: Snell’s law <span class="muted">n₀ sinθ₀ = nⱼ sinθⱼ</span>.<br/>
              Meaning: oblique incidence changes phase accumulation via <span class="muted">cosθⱼ</span>.
            </li>
            <li>
              <b>Define polarization-dependent admittance</b><br/>
              Goal: get <span class="muted">qⱼ</span> for TE and TM.<br/>
              Tool: boundary-condition-based “optical admittance”.<br/>
              Meaning: TE/TM “see” different effective impedances at oblique angles.
            </li>
            <li>
              <b>Write each layer matrix</b><br/>
              Goal: map fields across a single layer.<br/>
              Tool: <span class="muted">Mⱼ</span> with phase thickness <span class="muted">δⱼ</span>.<br/>
              Meaning: combines propagation and interface physics compactly.
            </li>
            <li>
              <b>Multiply matrices to get total stack matrix</b><br/>
              Goal: obtain <span class="muted">M = ∏ Mⱼ</span>.<br/>
              Tool: matrix product (order matters).<br/>
              Meaning: stack response is the chained linear map.
            </li>
            <li>
              <b>Convert total matrix to reflection coefficient</b><br/>
              Goal: compute <span class="muted">r</span> and <span class="muted">R</span>.<br/>
              Tool: match to substrate admittance <span class="muted">q_s</span> and incident admittance <span class="muted">q₀</span>.<br/>
              Meaning: r tells how much returns to the source.
            </li>
            <li>
              <b>Sweep frequency and angle</b><br/>
              Goal: make <span class="muted">R(ν)</span> and <span class="muted">R(θ)</span> plots for TE/TM.<br/>
              Tool: numerical evaluation (fast, stable for moderate N).<br/>
              Meaning: visualize stopbands and polarization differences.
            </li>
          </ol>

          <div class="callouts">
            <div class="box warn">
              <strong>Common mistakes</strong><br/>
              Using θ₀ inside every layer, forgetting cosθⱼ in δⱼ, or mixing TE/TM qⱼ.
            </div>
            <div class="box good">
              <strong>Quick tips</strong><br/>
              Normalize frequency by νB; pick quarter-wave thickness at νB for clean plots; test normal incidence first as a sanity check.
            </div>
          </div>
        </section>

        <section id="p3">
          <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

          <h3>3.1 Physical intuition first</h3>
          <p>
            A Bragg stack is like a “distributed mirror.” Each interface reflects a little; if the round-trip phase between
            interfaces makes those reflected waves return in phase, they add up. Near the design (Bragg) frequency, many small
            reflections coherently sum, producing a high-reflectance band (stopband). Off-Bragg, phases misalign and the net reflection
            drops, often with ripple-like Fabry–Pérot oscillations because the finite stack behaves like a multi-cavity system.
          </p>

          <h3>3.2 Define geometry, angles, and phase thickness</h3>
          <p>
            Let the incident medium have index <span class="muted">n₀</span> and the substrate have index <span class="muted">n_s</span>.
            A plane wave strikes the stack at angle <span class="muted">θ₀</span> (from the normal).
            In layer <span class="muted">j</span> with index <span class="muted">nⱼ</span>, Snell’s law gives:
          </p>

          <div class="equation" id="eq-snell">
            <button class="copyBtn" data-copy="#eq-snell pre">Copy</button>
            <pre>Snell:  n0 sin(θ0) = nj sin(θj)    ⇒    sin(θj) = (n0/nj) sin(θ0)</pre>
          </div>

          <p>
            The phase accumulated across thickness <span class="muted">dⱼ</span> is determined by the z-component of the wavevector:
          </p>

          <div class="equation" id="eq-delta">
            <button class="copyBtn" data-copy="#eq-delta pre">Copy</button>
            <pre>k0 = 2π/λ
δj = k0 nj dj cos(θj)      (phase thickness of layer j)</pre>
          </div>

          <p class="small">
            <b>Why cos(θj)?</b> Because only the component normal to the layers contributes to phase advance across the thickness.
          </p>

          <h3>3.3 TE/TM optical admittance (impedance-like factor)</h3>
          <p>
            In the characteristic-matrix method, we relate tangential field components using an “optical admittance” <span class="muted">q</span>.
            For non-magnetic media (μ≈μ₀), a standard convenient choice is:
          </p>

          <div class="equation" id="eq-adm">
            <button class="copyBtn" data-copy="#eq-adm pre">Copy</button>
            <pre>Optical admittance qj (non-magnetic layers):

TE (s-pol):  qj = nj cos(θj)

TM (p-pol):  qj = nj / cos(θj)</pre>
          </div>

          <p class="small">
            <b>Interpretation:</b> at oblique incidence, TE “weights” by cosθ, while TM “weights” by 1/cosθ, so the effective
            impedance mismatch evolves differently with angle → different reflectance behavior.
          </p>

          <h3>3.4 The characteristic (transfer) matrix of a single layer</h3>
          <p>
            For layer <span class="muted">j</span>, define a field vector <span class="muted">[E; H]</span> using appropriate tangential components
            (the same convention consistently across the stack). The layer maps the fields at its entrance to its exit via:
          </p>

          <div class="equation" id="eq-layerM">
            <button class="copyBtn" data-copy="#eq-layerM pre">Copy</button>
            <pre>Layer j characteristic matrix:

Mj = [  cos(δj)            i sin(δj)/qj
       i qj sin(δj)        cos(δj)       ]</pre>
          </div>

          <p>
            <b>What did we do?</b> We combined propagation through the layer (phase δj) with the field relationship governed by qj.
            This 2×2 matrix is the building block for the entire multilayer.
          </p>

          <h3>3.5 Total matrix for an N-layer alternating Bragg stack</h3>
          <p>
            For N layers in sequence (layer 1 first encountered by the incoming wave), the total matrix is the ordered product:
          </p>

          <div class="equation" id="eq-totalM">
            <button class="copyBtn" data-copy="#eq-totalM pre">Copy</button>
            <pre>Total stack matrix:

M = M1 M2 M3 ... MN

(order matters: the rightmost matrix is the last layer)</pre>
          </div>

          <p>
            For an alternating Bragg stack, you set <span class="muted">nⱼ = n₁</span> for odd j and <span class="muted">nⱼ = n₂</span> for even j
            (or vice versa), and similarly <span class="muted">dⱼ = d₁</span>, <span class="muted">d₂</span>.
          </p>

          <h3>3.6 Reflection coefficient from the total matrix</h3>
          <p>
            Let the incident medium have admittance <span class="muted">q₀</span> and the substrate have admittance <span class="muted">q_s</span>
            (computed using the same TE/TM formula with their indices and angles).
            Write the total matrix as:
            <span class="muted">M = [[m11, m12],[m21, m22]]</span>.
            Define:
          </p>

          <div class="equation" id="eq-AB">
            <button class="copyBtn" data-copy="#eq-AB pre">Copy</button>
            <pre>A = m11 + m12 qs
B = m21 + m22 qs</pre>
          </div>

          <p>
            Then the amplitude reflection coefficient at the input is:
          </p>

          <div class="equation" id="eq-r">
            <button class="copyBtn" data-copy="#eq-r pre">Copy</button>
            <pre>r = (q0 A - B) / (q0 A + B)
R = |r|^2</pre>
          </div>

          <p>
            <b>Why this form?</b> The matrix maps fields at the entrance to the substrate side; enforcing that the substrate supports only
            a forward-transmitted wave leads to a linear relation that yields r.
          </p>

          <h3>3.7 Quarter-wave Bragg design (for clean “textbook” plots)</h3>
          <p>
            If you pick a design wavelength <span class="muted">λB</span> (or frequency <span class="muted">νB</span>) and enforce quarter-wave optical thickness at
            <b>normal incidence</b>:
          </p>

          <div class="equation" id="eq-qw">
            <button class="copyBtn" data-copy="#eq-qw pre">Copy</button>
            <pre>Quarter-wave design (normal incidence):

n1 d1 = λB/4
n2 d2 = λB/4

⇒ d1 = λB/(4 n1),  d2 = λB/(4 n2)</pre>
          </div>

          <p class="small">
            This sets δ1=δ2=π/2 at ν=νB for θ=0. At oblique angles, δ changes through cosθj, shifting the stopband.
          </p>

          <h3>3.8 Sanity checks</h3>
          <ul>
            <li><b>Units:</b> δ is dimensionless (k0 has 1/m, n is unitless, d is m). q has index-like scaling; r is unitless.</li>
            <li><b>Limiting case:</b> If N=0 (no layers), M is identity → r reduces to the single interface reflection between n0 and ns.</li>
            <li><b>Contrast:</b> If n1≈n2, the stopband becomes weak (R smaller, narrower).</li>
          </ul>

          <div class="box good" style="margin-top:12px">
            <strong>FINAL ANSWER (symbolic)</strong><br/>
            The Bragg stack is fully characterized by:
            <div class="equation" id="finalAns" style="margin-top:10px">
              <button class="copyBtn" data-copy="#finalAns pre">Copy</button>
              <pre>For each layer j:
  δj = (2π/λ) nj dj cos(θj),  with  n0 sinθ0 = nj sinθj
  qj = nj cosθj   (TE),   qj = nj/cosθj  (TM)
  Mj = [[cosδj, i sinδj/qj],
        [i qj sinδj, cosδj]]

Total matrix:
  M = Π_{j=1..N} Mj = [[m11, m12],[m21, m22]]

With substrate admittance qs and input admittance q0:
  A = m11 + m12 qs
  B = m21 + m22 qs
  r = (q0 A - B)/(q0 A + B)
  R = |r|^2</pre>
            </div>
            <div class="small muted">
              Use the interactive plots (right) to evaluate R(ν,θ) and reproduce spectral/angle dependence for TE and TM.
            </div>
          </div>
        </section>

        <section id="p4">
          <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

          <h3>4.1 Re-interpret the formula: what controls reflectance?</h3>
          <ul>
            <li><b>Phase thickness δj:</b> controls interference. Changing frequency (via k0) or angle (via cosθj) slides δj and shifts the stopband.</li>
            <li><b>Admittance qj:</b> controls impedance mismatch per layer. TE vs TM differences are entirely encoded here (for non-magnetic media).</li>
            <li><b>Number of layers N:</b> increases the “strength” of the distributed mirror: higher peak reflectance and sharper band edges.</li>
            <li><b>Index contrast n2/n1:</b> broadens and deepens the stopband (stronger reflections at each interface).</li>
          </ul>

          <h3>4.2 Parameter effects (connect to plots)</h3>
          <ul>
            <li>Increase <b>N</b> → the stopband becomes flatter near R≈1 and band edges become steeper; ripple density increases (finite-size resonances).</li>
            <li>Increase <b>index contrast</b> (n2/n1) → stopband widens and unity-reflectance extends over a larger frequency interval.</li>
            <li>Increase <b>angle θ0</b> → the stopband center shifts (because δj ∝ cosθj) and TE/TM curves separate more.</li>
            <li><b>TM</b> often shows a reduced reflectance near certain angles because effective impedance mismatch can diminish (Brewster-like tendencies).</li>
          </ul>

          <h3>4.3 Alternative derivation idea (brief)</h3>
          <p>
            For an <b>infinite periodic stack</b>, you can compute a unit-cell matrix <span class="muted">Mcell = M1 M2</span> and use Bloch theory:
            the Bloch phase satisfies <span class="muted">cos(KΛ) = (Tr(Mcell))/2</span>, where Λ is the period.
            When <span class="muted">|Tr(Mcell)| &gt; 2</span>, K becomes complex → an evanescent Bloch mode → a stopband. A finite stack then inherits high reflectance
            in that band, with finite-length ripples.
          </p>

          <h3>4.4 Concept checks (quick self-test)</h3>
          <ul>
            <li><b>Q:</b> Why does reflectance depend on angle even if thicknesses are fixed? <br/><b>A:</b> Because inside each layer, δj includes cosθj and θj changes by Snell’s law.</li>
            <li><b>Q:</b> What makes TE and TM different in TMM? <br/><b>A:</b> The polarization-dependent admittance qj (and thus interface mismatch) differs.</li>
            <li><b>Q:</b> What happens as N → large? <br/><b>A:</b> Stopband reflectance approaches 1 over a wider region and edges sharpen; transmission in band decays exponentially.</li>
            <li><b>Q:</b> If n1 = n2, what do you expect? <br/><b>A:</b> No periodic mismatch → no Bragg mirror; reflectance reduces to outer-interface Fresnel reflections only.</li>
          </ul>
        </section>

        <section id="p5">
          <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

          <h3>5.1 What each canvas shows</h3>
          <ul>
            <li><b>Diagram:</b> Incident ray at angle θ0 striking an alternating stack (n1/n2). Labels show input medium n0, substrate ns, and layer thicknesses d1/d2.</li>
            <li><b>Main plot:</b> <b>Reflectance R vs normalized frequency ν/νB</b> at the current angle θ0. This is the “spectral dependence” plot.</li>
            <li><b>Secondary plot:</b> <b>Reflectance R vs angle θ0</b> at the current normalized frequency ν/νB. This is the “angular dependence” plot.</li>
          </ul>

          <h3>5.2 Interactive controls</h3>
          <ul>
            <li><b>Angle slider (θ0):</b> updates both plots (spectral curve changes and the marker on the angular plot moves).</li>
            <li><b>Frequency slider (ν/νB):</b> updates both plots (angular curve changes and the marker on the spectral plot moves).</li>
            <li><b>Polarization selector:</b> choose TE, TM, or BOTH (plots show one or two curves).</li>
            <li><b>N segments:</b> controls how many alternating layers are used (finite stack strength and ripple density).</li>
            <li><b>Index contrast:</b> adjust n2 while keeping n1 fixed (stopband width and strength).</li>
            <li><b>Matched vs air substrate:</b> toggles whether outer media are matched (n0=ns=n1) or “air” (n0=ns=1), changing overall reflectance behavior.</li>
          </ul>

          <p class="small muted">
            All plotted symbols match the equations in the text. Thicknesses are set to quarter-wave at νB using example values
            (dimensionless normalization with λB = 1 unit for plotting clarity).
          </p>
        </section>
      </div>

      <div class="vizWrap" aria-label="Interactive visualizations">
        <section class="vizCard">
          <div class="vizHeader">
            <h3>Interactive Bragg Stack Visualizations</h3>
            <div class="row">
              <span class="kbd">Drag sliders</span>
              <span class="kbd">TE/TM</span>
            </div>
          </div>

          <div class="twoCanv">
            <figure>
              <canvas id="cDiagram" aria-label="Bragg stack diagram"></canvas>
              <figcaption class="small muted" style="margin-top:8px">
                Diagram: geometry + alternating layers (n1/n2), incidence angle θ0, and media (n0, ns).
              </figcaption>
            </figure>

            <figure>
              <canvas id="cMain" aria-label="Reflectance vs normalized frequency plot"></canvas>
              <figcaption class="small muted" style="margin-top:8px">
                Main plot: R(ν/νB) at current θ0 (spectral dependence).
              </figcaption>
            </figure>

            <figure>
              <canvas id="cSecondary" aria-label="Reflectance vs incident angle plot"></canvas>
              <figcaption class="small muted" style="margin-top:8px">
                Secondary plot: R(θ0) at current ν/νB (angular dependence).
              </figcaption>
            </figure>
          </div>

          <div class="controls" aria-label="Controls">
            <div class="ctrl">
              <label>
                <span>Incident angle θ0 (deg)</span>
                <span id="valTheta" class="muted">30°</span>
              </label>
              <input id="theta" type="range" min="0" max="80" step="1" value="30"/>
            </div>

            <div class="ctrl">
              <label>
                <span>Normalized frequency ν/νB</span>
                <span id="valFreq" class="muted">1.00</span>
              </label>
              <input id="freq" type="range" min="0.70" max="1.30" step="0.005" value="1.00"/>
            </div>

            <div class="ctrl">
              <label><span>Polarization</span><span class="muted">TE/TM</span></label>
              <select id="pol">
                <option value="both" selected>BOTH (TE & TM)</option>
                <option value="te">TE (s)</option>
                <option value="tm">TM (p)</option>
              </select>
            </div>

            <div class="ctrl">
              <label>
                <span>N segments (layers)</span>
                <span id="valN" class="muted">10</span>
              </label>
              <input id="N" type="range" min="2" max="40" step="1" value="10"/>
              <div class="small muted" style="margin-top:6px">“Segments” = number of layers. Alternates n1, n2, n1, n2, …</div>
            </div>

            <div class="ctrl">
              <label>
                <span>n1 (fixed)</span>
                <span id="valN1" class="muted">1.50</span>
              </label>
              <input id="n1" type="range" min="1.10" max="2.20" step="0.01" value="1.50"/>
            </div>

            <div class="ctrl">
              <label>
                <span>n2 (contrast)</span>
                <span id="valN2" class="muted">2.00</span>
              </label>
              <input id="n2" type="range" min="1.15" max="3.00" step="0.01" value="2.00"/>
            </div>

            <div class="ctrl">
              <label><span>Outer media</span><span id="valEnv" class="muted">Matched</span></label>
              <select id="env">
                <option value="matched" selected>Matched (n0 = ns = n1)</option>
                <option value="air">Air (n0 = ns = 1.00)</option>
              </select>
            </div>

            <div class="ctrl">
              <label><span>Quick actions</span><span class="muted">presets</span></label>
              <button id="preset">Preset: Strong stopband</button>
              <div class="small muted" style="margin-top:6px">
                Sets a higher contrast and more layers to clearly reveal the Bragg stopband.
              </div>
            </div>
          </div>
        </section>

        <section class="vizCard">
          <h3 style="margin:0 0 8px">Notes for matching classic figures</h3>
          <p class="small muted" style="margin:0">
            The original textbook figures often use a specific stack (e.g., a fixed number of layers, particular indices, and matched vs air surroundings).
            Here, you can tune <b>N</b>, <b>n1</b>, <b>n2</b>, and the environment to reproduce the same qualitative outcomes:
            stopband broadening with contrast, TE/TM separation with angle, and near-unity-reflectance bands for sufficiently strong stacks.
          </p>
        </section>
      </div>
    </div>
  </main>

  <footer>
    Built as a self-contained learning article (vanilla HTML/CSS/JS). Equations are plain text; plots are computed live with the transfer matrix method.
  </footer>

  <div class="toast" id="toast">Copied.</div>

  <script>
    // ---------- Smooth scrolling for TOC ----------
    (function(){
      document.querySelectorAll('[data-scroll]').forEach(a=>{
        a.addEventListener('click', (e)=>{
          e.preventDefault();
          const id = a.getAttribute('href');
          const el = document.querySelector(id);
          if(!el) return;
          const y = el.getBoundingClientRect().top + window.scrollY - 12;
          window.scrollTo({top:y, behavior:'smooth'});
        });
      });
    })();

    // ---------- Copy buttons ----------
    (function(){
      const toast = document.getElementById('toast');
      let t = null;
      function showToast(msg){
        toast.textContent = msg;
        toast.classList.add('show');
        clearTimeout(t);
        t = setTimeout(()=>toast.classList.remove('show'), 1100);
      }

      document.addEventListener('click', async (e)=>{
        const btn = e.target.closest('.copyBtn');
        if(!btn) return;
        const sel = btn.getAttribute('data-copy');
        const node = document.querySelector(sel);
        if(!node) return;
        const text = node.innerText.trim();
        try{
          await navigator.clipboard.writeText(text);
          showToast('Copied to clipboard.');
        }catch(err){
          // Fallback
          const ta = document.createElement('textarea');
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          try{ document.execCommand('copy'); showToast('Copied.'); }
          catch(e2){ showToast('Copy failed (browser permission).'); }
          document.body.removeChild(ta);
        }
      });
    })();

    // ---------- Math / physics core: Transfer Matrix Method ----------
    function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
    function deg2rad(d){ return d*Math.PI/180; }

    // Complex numbers (minimal)
    function C(re, im){ return {re, im}; }
    function cAdd(a,b){ return C(a.re+b.re, a.im+b.im); }
    function cSub(a,b){ return C(a.re-b.re, a.im-b.im); }
    function cMul(a,b){ return C(a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re); }
    function cDiv(a,b){
      const den = b.re*b.re + b.im*b.im;
      return C((a.re*b.re + a.im*b.im)/den, (a.im*b.re - a.re*b.im)/den);
    }
    function cAbs2(a){ return a.re*a.re + a.im*a.im; }

    // 2x2 complex matrix multiplication
    function mMul(A,B){
      // A,B are [[C,C],[C,C]]
      return [
        [ cAdd(cMul(A[0][0],B[0][0]), cMul(A[0][1],B[1][0])),
          cAdd(cMul(A[0][0],B[0][1]), cMul(A[0][1],B[1][1])) ],
        [ cAdd(cMul(A[1][0],B[0][0]), cMul(A[1][1],B[1][0])),
          cAdd(cMul(A[1][0],B[0][1]), cMul(A[1][1],B[1][1])) ]
      ];
    }

    function mIdentity(){
      return [[C(1,0), C(0,0)], [C(0,0), C(1,0)]];
    }

    // Optical admittance (non-magnetic)
    function admittance(n, theta, pol){
      // theta in radians
      const ct = Math.cos(theta);
      if(pol === 'te') return n * ct;
      // tm
      return n / ct;
    }

    // Snell: n0 sinθ0 = n sinθ
    function angleInLayer(n0, theta0, n){
      const s0 = Math.sin(theta0);
      const s = (n0/n)*s0;
      if(Math.abs(s) > 1) {
        // Total internal reflection region (complex angle). For simplicity,
        // clamp to avoid NaN; this article focuses on typical Bragg mirror cases
        // where n0 <= n or angles small enough.
        const sc = clamp(s, -1, 1);
        return Math.asin(sc);
      }
      return Math.asin(s);
    }

    // Layer characteristic matrix
    function layerMatrix(n0, theta0, n, d, k0, pol){
      const th = angleInLayer(n0, theta0, n);
      const q = admittance(n, th, pol);
      const delta = k0 * n * d * Math.cos(th);
      const cd = Math.cos(delta);
      const sd = Math.sin(delta);
      // M = [[cosδ, i sinδ/q],[ i q sinδ, cosδ]]
      return [
        [ C(cd,0), C(0, sd/q) ],
        [ C(0, q*sd), C(cd,0) ]
      ];
    }

    // Total matrix for N layers alternating n1/n2
    function stackMatrix(params, k0, pol){
      const {n0, theta0, ns, N, n1, n2, d1, d2} = params;
      let M = mIdentity();
      for(let j=1; j<=N; j++){
        const n = (j%2===1) ? n1 : n2;
        const d = (j%2===1) ? d1 : d2;
        const Lj = layerMatrix(n0, theta0, n, d, k0, pol);
        M = mMul(M, Lj);
      }
      return M;
    }

    // Reflection coefficient r and reflectance R
    function reflectance(params, freqRatio, pol){
      // Normalize: choose lambdaB = 1 (unit), so k0B = 2π.
      // freqRatio = ν/νB = λB/λ, so k0 = k0B * freqRatio.
      const k0 = 2*Math.PI * freqRatio;

      const {n0, theta0, ns} = params;
      const ths = angleInLayer(n0, theta0, ns);
      const q0 = admittance(n0, theta0, pol);
      const qs = admittance(ns, ths, pol);

      const M = stackMatrix(params, k0, pol);
      const m11 = M[0][0], m12 = M[0][1], m21 = M[1][0], m22 = M[1][1];

      // A = m11 + m12*qs ; B = m21 + m22*qs
      const A = cAdd(m11, cMul(m12, C(qs,0)));
      const B = cAdd(m21, cMul(m22, C(qs,0)));

      const num = cSub(cMul(C(q0,0), A), B);
      const den = cAdd(cMul(C(q0,0), A), B);
      const r = cDiv(num, den);
      return cAbs2(r);
    }

    // ---------- Plotting helpers (canvas) ----------
    function setupCanvas(canvas){
      const ctx = canvas.getContext('2d');
      function resize(){
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        const w = Math.max(2, Math.floor(rect.width * dpr));
        const h = Math.max(2, Math.floor(rect.height * dpr));
        if(canvas.width !== w || canvas.height !== h){
          canvas.width = w;
          canvas.height = h;
        }
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
      resize();
      return {ctx, resize};
    }

    function drawAxes(ctx, W, H, opts){
      const {
        title, xLabel, yLabel,
        xMin, xMax, yMin, yMax,
        grid=true
      } = opts;

      const padL = 56, padR = 18, padT = 34, padB = 48;
      const x0 = padL, y0 = H - padB;
      const x1 = W - padR, y1 = padT;

      // background
      ctx.clearRect(0,0,W,H);

      // title
      ctx.save();
      ctx.fillStyle = 'rgba(234,240,255,.95)';
      ctx.font = '600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText(title, padL, 18);
      ctx.restore();

      // gridlines
      function niceTicks(min,max,approx=6){
        const span = max-min;
        const raw = span/approx;
        const p = Math.pow(10, Math.floor(Math.log10(raw)));
        const m = raw/p;
        let step = (m<1.5)?1 : (m<3)?2 : (m<7)?5 : 10;
        step *= p;
        const t0 = Math.ceil(min/step)*step;
        const ticks=[];
        for(let t=t0; t<=max+1e-12; t+=step) ticks.push(t);
        return {step, ticks};
      }
      const xt = niceTicks(xMin,xMax,6);
      const yt = niceTicks(yMin,yMax,5);

      if(grid){
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,.08)';
        ctx.lineWidth = 1;
        // vertical
        xt.ticks.forEach(t=>{
          const x = x0 + (t-xMin)/(xMax-xMin)*(x1-x0);
          ctx.beginPath();
          ctx.moveTo(x, y0);
          ctx.lineTo(x, y1);
          ctx.stroke();
        });
        // horizontal
        yt.ticks.forEach(t=>{
          const y = y0 - (t-yMin)/(yMax-yMin)*(y0-y1);
          ctx.beginPath();
          ctx.moveTo(x0, y);
          ctx.lineTo(x1, y);
          ctx.stroke();
        });
        ctx.restore();
      }

      // axes
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,.28)';
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y0);
      ctx.lineTo(x1, y1);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x0, y1);
      ctx.stroke();
      ctx.restore();

      // ticks + labels
      ctx.save();
      ctx.fillStyle = 'rgba(234,240,255,.80)';
      ctx.strokeStyle = 'rgba(234,240,255,.35)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';

      xt.ticks.forEach(t=>{
        const x = x0 + (t-xMin)/(xMax-xMin)*(x1-x0);
        ctx.beginPath();
        ctx.moveTo(x, y0);
        ctx.lineTo(x, y0+6);
        ctx.stroke();
        const s = (Math.abs(t) < 1e-9) ? "0" : (Math.round(t*1000)/1000).toString();
        ctx.fillText(s, x-10, y0+20);
      });

      yt.ticks.forEach(t=>{
        const y = y0 - (t-yMin)/(yMax-yMin)*(y0-y1);
        ctx.beginPath();
        ctx.moveTo(x0-6, y);
        ctx.lineTo(x0, y);
        ctx.stroke();
        const s = (Math.round(t*1000)/1000).toString();
        ctx.fillText(s, 8, y+4);
      });

      // axis labels
      ctx.font = '13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillStyle = 'rgba(184,196,230,.95)';
      ctx.fillText(xLabel, (x0+x1)/2 - ctx.measureText(xLabel).width/2, H-14);

      // y label rotated
      ctx.save();
      ctx.translate(16, (y0+y1)/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
      ctx.restore();

      ctx.restore();

      return {padL, padR, padT, padB, x0, x1, y0, y1};
    }

    function plotLine(ctx, frame, xs, ys, style){
      const {xMin,xMax,yMin,yMax,color='rgba(125,211,252,.95)', width=2} = style;
      const {x0,x1,y0,y1} = frame;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.beginPath();
      for(let i=0;i<xs.length;i++){
        const x = x0 + (xs[i]-xMin)/(xMax-xMin)*(x1-x0);
        const y = y0 - (ys[i]-yMin)/(yMax-yMin)*(y0-y1);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawLegend(ctx, items, x, y){
      ctx.save();
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillStyle = 'rgba(234,240,255,.9)';
      items.forEach((it, idx)=>{
        const yy = y + idx*18;
        ctx.strokeStyle = it.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x, yy-4);
        ctx.lineTo(x+18, yy-4);
        ctx.stroke();
        ctx.fillText(it.label, x+24, yy);
      });
      ctx.restore();
    }

    function drawMarker(ctx, frame, xMin,xMax,yMin,yMax, x, y, color){
      const {x0,x1,y0,y1} = frame;
      const px = x0 + (x-xMin)/(xMax-xMin)*(x1-x0);
      const py = y0 - (y-yMin)/(yMax-yMin)*(y0-y1);
      ctx.save();
      ctx.fillStyle = color;
      ctx.strokeStyle = 'rgba(0,0,0,.35)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(px, py, 5, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    // ---------- Diagram drawing ----------
    function drawDiagram(ctx, W, H, state){
      const {thetaDeg, n0, ns, n1, n2, N} = state;

      ctx.clearRect(0,0,W,H);

      const pad = 18;
      const left = pad, right = W-pad, top = pad, bottom = H-pad;

      // Title
      ctx.save();
      ctx.fillStyle = 'rgba(234,240,255,.95)';
      ctx.font = '600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Setup diagram (layered Bragg stack)', left, top);
      ctx.restore();

      // Draw stack region
      const stackX0 = left + 90;
      const stackX1 = right - 70;
      const stackY0 = top + 26;
      const stackY1 = bottom - 18;

      // incident medium block (left)
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,.04)';
      ctx.strokeStyle = 'rgba(255,255,255,.16)';
      ctx.lineWidth = 1;
      ctx.fillRect(left, stackY0, stackX0-left, stackY1-stackY0);
      ctx.strokeRect(left, stackY0, stackX0-left, stackY1-stackY0);
      ctx.restore();

      // substrate block (right)
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,.04)';
      ctx.strokeStyle = 'rgba(255,255,255,.16)';
      ctx.lineWidth = 1;
      ctx.fillRect(stackX1, stackY0, right-stackX1, stackY1-stackY0);
      ctx.strokeRect(stackX1, stackY0, right-stackX1, stackY1-stackY0);
      ctx.restore();

      // stack layers
      const layers = N;
      const stackW = stackX1 - stackX0;
      const w = stackW / layers;
      for(let i=0;i<layers;i++){
        const x = stackX0 + i*w;
        const isN1 = (i%2===0);
        ctx.save();
        ctx.fillStyle = isN1 ? 'rgba(125,211,252,.10)' : 'rgba(167,139,250,.10)';
        ctx.strokeStyle = 'rgba(255,255,255,.10)';
        ctx.fillRect(x, stackY0, w, stackY1-stackY0);
        ctx.strokeRect(x, stackY0, w, stackY1-stackY0);
        ctx.restore();
      }

      // layer labels n1/n2
      ctx.save();
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      ctx.fillStyle = 'rgba(234,240,255,.85)';
      ctx.fillText(`n0 = ${n0.toFixed(2)}`, left+10, stackY0+16);
      ctx.fillText(`ns = ${ns.toFixed(2)}`, stackX1+10, stackY0+16);
      ctx.fillStyle = 'rgba(125,211,252,.95)';
      ctx.fillText(`n1 = ${n1.toFixed(2)}`, stackX0+10, stackY0+16);
      ctx.fillStyle = 'rgba(167,139,250,.95)';
      ctx.fillText(`n2 = ${n2.toFixed(2)}`, stackX0+10, stackY0+34);
      ctx.restore();

      // Incident ray
      const theta = deg2rad(thetaDeg);
      const midY = (stackY0+stackY1)/2;
      const incStart = {x: left+20, y: midY + 70};
      const incEnd   = {x: stackX0, y: midY};
      // Construct direction to match theta relative to normal (normal points +x in this diagram)
      // We'll draw the ray so that it hits at (stackX0, midY) with angle theta from normal.
      // So slope = tan(theta) but downward/upward sign chosen from start point.
      const L = 160;
      const dx = -Math.cos(theta)*L;
      const dy =  Math.sin(theta)*L; // positive -> downward in canvas
      const hit = {x: stackX0, y: midY};
      const start = {x: hit.x + dx, y: hit.y + dy};

      // ray line
      ctx.save();
      ctx.strokeStyle = 'rgba(234,240,255,.85)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(hit.x, hit.y);
      ctx.stroke();

      // arrow head
      const ang = Math.atan2(hit.y-start.y, hit.x-start.x);
      const ah = 10;
      ctx.beginPath();
      ctx.moveTo(hit.x, hit.y);
      ctx.lineTo(hit.x - ah*Math.cos(ang-0.35), hit.y - ah*Math.sin(ang-0.35));
      ctx.lineTo(hit.x - ah*Math.cos(ang+0.35), hit.y - ah*Math.sin(ang+0.35));
      ctx.closePath();
      ctx.fillStyle = 'rgba(234,240,255,.85)';
      ctx.fill();

      // normal line
      ctx.strokeStyle = 'rgba(52,211,153,.7)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(hit.x, hit.y - 60);
      ctx.lineTo(hit.x, hit.y + 60);
      ctx.stroke();

      // angle arc
      ctx.strokeStyle = 'rgba(52,211,153,.85)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      const r = 34;
      // Normal is vertical; ray is at angle relative to normal.
      // We'll draw arc from normal direction toward ray direction around hit point.
      const a0 = -Math.PI/2;             // normal upwards
      const a1 = a0 + theta;             // rotate clockwise by theta
      ctx.arc(hit.x, hit.y, r, a0, a1, false);
      ctx.stroke();

      // angle label
      ctx.fillStyle = 'rgba(52,211,153,.95)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      ctx.fillText(`θ0 = ${thetaDeg.toFixed(0)}°`, hit.x + 10, hit.y - 40);

      // annotations
      ctx.fillStyle = 'rgba(184,196,230,.95)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('incident wave', start.x - 10, start.y + 18);
      ctx.fillText('normal', hit.x + 8, hit.y + 58);
      ctx.restore();

      // small thickness markers (schematic)
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,.25)';
      ctx.lineWidth = 1.5;
      const bx = stackX0 + w*1.2;
      ctx.beginPath();
      ctx.moveTo(bx, stackY1-10);
      ctx.lineTo(bx+w, stackY1-10);
      ctx.stroke();
      ctx.fillStyle = 'rgba(184,196,230,.9)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      ctx.fillText('d1 / d2 (alternating)', stackX0 + 10, stackY1 + 10);
      ctx.restore();
    }

    // ---------- App state and rendering ----------
    const cDiagram = document.getElementById('cDiagram');
    const cMain = document.getElementById('cMain');
    const cSecondary = document.getElementById('cSecondary');

    const D = setupCanvas(cDiagram);
    const M = setupCanvas(cMain);
    const S = setupCanvas(cSecondary);

    const ui = {
      theta: document.getElementById('theta'),
      freq: document.getElementById('freq'),
      pol: document.getElementById('pol'),
      N: document.getElementById('N'),
      n1: document.getElementById('n1'),
      n2: document.getElementById('n2'),
      env: document.getElementById('env'),
      preset: document.getElementById('preset'),

      valTheta: document.getElementById('valTheta'),
      valFreq: document.getElementById('valFreq'),
      valN: document.getElementById('valN'),
      valN1: document.getElementById('valN1'),
      valN2: document.getElementById('valN2'),
      valEnv: document.getElementById('valEnv')
    };

    const colors = {
      te: 'rgba(125,211,252,.95)',
      tm: 'rgba(167,139,250,.95)',
      marker: 'rgba(251,191,36,.95)'
    };

    function getParams(){
      const thetaDeg = parseFloat(ui.theta.value);
      const theta0 = deg2rad(thetaDeg);
      const freqRatio = parseFloat(ui.freq.value);
      const N = parseInt(ui.N.value, 10);
      const n1 = parseFloat(ui.n1.value);
      const n2 = parseFloat(ui.n2.value);

      // Environment
      let n0, ns;
      const env = ui.env.value;
      if(env === 'matched'){
        n0 = n1;
        ns = n1;
      }else{
        n0 = 1.0;
        ns = 1.0;
      }

      // Quarter-wave design at λB=1 (example normalization):
      // d1 = 1/(4 n1), d2 = 1/(4 n2)
      const d1 = 1/(4*n1);
      const d2 = 1/(4*n2);

      return {thetaDeg, theta0, freqRatio, N, n1, n2, n0, ns, d1, d2, env};
    }

    function updateLabels(st){
      ui.valTheta.textContent = `${st.thetaDeg.toFixed(0)}°`;
      ui.valFreq.textContent  = `${st.freqRatio.toFixed(3)}`;
      ui.valN.textContent     = `${st.N}`;
      ui.valN1.textContent    = `${st.n1.toFixed(2)}`;
      ui.valN2.textContent    = `${st.n2.toFixed(2)}`;
      ui.valEnv.textContent   = (st.env === 'matched') ? 'Matched' : 'Air';
    }

    function computeSpectralCurve(params, polMode){
      const xMin = 0.70, xMax = 1.30;
      const Npts = 360;
      const xs = new Array(Npts);
      const te = new Array(Npts);
      const tm = new Array(Npts);
      for(let i=0;i<Npts;i++){
        const x = xMin + (xMax-xMin)*i/(Npts-1);
        xs[i] = x;
        if(polMode === 'te' || polMode === 'both') te[i] = reflectance(params, x, 'te');
        if(polMode === 'tm' || polMode === 'both') tm[i] = reflectance(params, x, 'tm');
      }
      return {xs, te, tm, xMin, xMax};
    }

    function computeAngularCurve(params, polMode){
      const xMin = 0, xMax = 80;
      const Npts = 321;
      const xs = new Array(Npts);
      const te = new Array(Npts);
      const tm = new Array(Npts);

      // Make a copy of params but allow theta sweep
      const base = Object.assign({}, params);
      for(let i=0;i<Npts;i++){
        const thDeg = xMin + (xMax-xMin)*i/(Npts-1);
        xs[i] = thDeg;
        base.theta0 = deg2rad(thDeg);
        if(polMode === 'te' || polMode === 'both') te[i] = reflectance(base, params.freqRatio, 'te');
        if(polMode === 'tm' || polMode === 'both') tm[i] = reflectance(base, params.freqRatio, 'tm');
      }
      return {xs, te, tm, xMin, xMax};
    }

    function renderAll(){
      const st = getParams();
      updateLabels(st);

      // Diagram
      D.resize();
      const dRect = cDiagram.getBoundingClientRect();
      drawDiagram(D.ctx, dRect.width, dRect.height, st);

      const polMode = ui.pol.value;

      // Main plot: R vs freq
      M.resize();
      const mRect = cMain.getBoundingClientRect();
      const mCtx = M.ctx;
      const spec = computeSpectralCurve(st, polMode);

      const frameMain = drawAxes(mCtx, mRect.width, mRect.height, {
        title: 'Reflectance vs normalized frequency (spectral dependence)',
        xLabel: 'ν/νB (dimensionless)',
        yLabel: 'R (power reflectance)',
        xMin: spec.xMin, xMax: spec.xMax,
        yMin: 0, yMax: 1,
        grid:true
      });

      // Plot lines
      const frameStyle = {xMin: spec.xMin, xMax: spec.xMax, yMin:0, yMax:1};
      const legendItems = [];
      if(polMode === 'te' || polMode === 'both'){
        plotLine(mCtx, frameMain, spec.xs, spec.te, Object.assign({}, frameStyle, {color: colors.te, width:2.4}));
        legendItems.push({label:'TE', color: colors.te});
      }
      if(polMode === 'tm' || polMode === 'both'){
        plotLine(mCtx, frameMain, spec.xs, spec.tm, Object.assign({}, frameStyle, {color: colors.tm, width:2.4}));
        legendItems.push({label:'TM', color: colors.tm});
      }
      drawLegend(mCtx, legendItems, mRect.width-140, 26);

      // Marker at current freqRatio for current theta (choose TE if single else average marker)
      let Rmark = 0;
      if(polMode === 'te') Rmark = reflectance(st, st.freqRatio, 'te');
      else if(polMode === 'tm') Rmark = reflectance(st, st.freqRatio, 'tm');
      else {
        const r1 = reflectance(st, st.freqRatio, 'te');
        const r2 = reflectance(st, st.freqRatio, 'tm');
        Rmark = 0.5*(r1+r2);
      }
      drawMarker(mCtx, frameMain, spec.xMin, spec.xMax, 0, 1, st.freqRatio, Rmark, colors.marker);

      // Secondary plot: R vs angle
      S.resize();
      const sRect = cSecondary.getBoundingClientRect();
      const sCtx = S.ctx;
      const ang = computeAngularCurve(st, polMode);

      const frameSec = drawAxes(sCtx, sRect.width, sRect.height, {
        title: 'Reflectance vs incident angle (angular dependence)',
        xLabel: 'θ0 (deg)',
        yLabel: 'R (power reflectance)',
        xMin: ang.xMin, xMax: ang.xMax,
        yMin: 0, yMax: 1,
        grid:true
      });

      const secStyle = {xMin: ang.xMin, xMax: ang.xMax, yMin:0, yMax:1};
      const legend2 = [];
      if(polMode === 'te' || polMode === 'both'){
        plotLine(sCtx, frameSec, ang.xs, ang.te, Object.assign({}, secStyle, {color: colors.te, width:2.4}));
        legend2.push({label:'TE', color: colors.te});
      }
      if(polMode === 'tm' || polMode === 'both'){
        plotLine(sCtx, frameSec, ang.xs, ang.tm, Object.assign({}, secStyle, {color: colors.tm, width:2.4}));
        legend2.push({label:'TM', color: colors.tm});
      }
      drawLegend(sCtx, legend2, sRect.width-140, 26);

      // Marker at current theta for current freqRatio (same marker logic)
      drawMarker(sCtx, frameSec, ang.xMin, ang.xMax, 0, 1, st.thetaDeg, Rmark, colors.marker);

      // Add a small annotation with current parameters (bottom-right)
      function annotate(ctx, W, H){
        ctx.save();
        const txt = `N=${st.N}, n1=${st.n1.toFixed(2)}, n2=${st.n2.toFixed(2)}, env=${st.env}`;
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
        const w = ctx.measureText(txt).width + 14;
        ctx.fillStyle = 'rgba(0,0,0,.25)';
        ctx.strokeStyle = 'rgba(255,255,255,.12)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.roundRect(W - w - 10, H - 28, w, 20, 10);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = 'rgba(184,196,230,.95)';
        ctx.fillText(txt, W - w - 3, H - 14);
        ctx.restore();
      }
      annotate(mCtx, mRect.width, mRect.height);
      annotate(sCtx, sRect.width, sRect.height);
    }

    // RoundRect polyfill for older canvas implementations
    if(!CanvasRenderingContext2D.prototype.roundRect){
      CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
        r = Math.min(r, w/2, h/2);
        this.beginPath();
        this.moveTo(x+r, y);
        this.arcTo(x+w, y, x+w, y+h, r);
        this.arcTo(x+w, y+h, x, y+h, r);
        this.arcTo(x, y+h, x, y, r);
        this.arcTo(x, y, x+w, y, r);
        this.closePath();
        return this;
      };
    }

    // ---------- Events ----------
    const controls = ['theta','freq','pol','N','n1','n2','env'];
    controls.forEach(id=>{
      document.getElementById(id).addEventListener('input', renderAll);
      document.getElementById(id).addEventListener('change', renderAll);
    });

    ui.preset.addEventListener('click', ()=>{
      ui.N.value = 18;
      ui.n1.value = 1.45;
      ui.n2.value = 2.30;
      ui.theta.value = 30;
      ui.freq.value = 1.00;
      ui.pol.value = 'both';
      ui.env.value = 'matched';
      renderAll();
    });

    // Responsive redraw
    window.addEventListener('resize', ()=>{
      renderAll();
    });

    // First render
    renderAll();
  </script>
</body>
</html>
