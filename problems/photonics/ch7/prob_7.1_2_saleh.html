<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beamsplitter Slab at 45° — TM Transmittance/Reflectance with Spectral Dependence</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --card:#111c3a;
      --ink:#e9eeff;
      --muted:#b7c2ffcc;
      --faint:#b7c2ff66;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#86efac;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:#2a3a72;
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 700px at 15% 10%, rgba(125,211,252,.22), transparent 55%),
                  radial-gradient(900px 600px at 70% 5%, rgba(167,139,250,.18), transparent 55%),
                  radial-gradient(900px 600px at 70% 80%, rgba(134,239,172,.12), transparent 60%),
                  var(--bg);
      color:var(--ink);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding: clamp(18px, 2.6vw, 28px) clamp(16px, 3.2vw, 46px);
      border-bottom: 1px solid rgba(183,194,255,.12);
      background: linear-gradient(180deg, rgba(15,23,48,.88), rgba(15,23,48,.55));
      position: sticky;
      top: 0;
      z-index: 50;
      backdrop-filter: blur(10px);
    }
    header .toprow{
      display:flex;
      gap:16px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-size: clamp(20px, 2.1vw, 30px);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:6px 0 0 0;
      color:var(--muted);
      max-width: 68ch;
      font-size: 0.98rem;
    }
    .badgeRow{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      margin-top: 10px;
    }
    .badge{
      border: 1px solid rgba(183,194,255,.18);
      background: rgba(17,28,58,.5);
      padding: 6px 10px;
      border-radius: 999px;
      color: var(--muted);
      font-size:.86rem;
      display:flex; gap:8px; align-items:center;
    }
    .dot{width:8px; height:8px; border-radius:999px; background:var(--accent)}
    main{
      padding: clamp(18px, 2.6vw, 30px) clamp(16px, 3.2vw, 46px) 80px;
    }
    .layout{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns:1fr}
      aside.toc{position:relative; top:auto}
    }
    aside.toc{
      position: sticky;
      top: 98px;
      align-self:start;
      background: rgba(17,28,58,.62);
      border: 1px solid rgba(183,194,255,.14);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .toc h2{
      margin: 0 0 8px 0;
      font-size: 1rem;
      color: var(--ink);
    }
    .toc nav a{
      display:block;
      padding: 9px 10px;
      border-radius: 12px;
      color: var(--muted);
      border: 1px solid transparent;
      transition: .2s ease;
      font-size:.94rem;
    }
    .toc nav a:hover{
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.22);
      color: var(--ink);
      text-decoration:none;
      transform: translateX(2px);
    }

    section{
      background: rgba(17,28,58,.55);
      border: 1px solid rgba(183,194,255,.14);
      border-radius: var(--radius);
      padding: clamp(14px, 2vw, 22px);
      box-shadow: var(--shadow);
      margin-bottom: 16px;
      overflow:hidden;
    }
    section h2{
      margin: 0 0 10px 0;
      font-size: clamp(18px, 1.55vw, 22px);
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 920px){
      .grid2{grid-template-columns:1fr}
    }
    .callout{
      background: linear-gradient(180deg, rgba(125,211,252,.12), rgba(167,139,250,.08));
      border: 1px solid rgba(125,211,252,.22);
      border-radius: 16px;
      padding: 12px 14px;
    }
    .callout h3{
      margin:0 0 6px 0;
      font-size: 1rem;
    }
    .muted{color:var(--muted)}
    .faint{color:var(--faint)}
    ul{margin: 10px 0 0 20px}
    li{margin: 6px 0}
    .kpiRow{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin-top: 12px;
    }
    @media(max-width: 860px){
      .kpiRow{grid-template-columns: repeat(2, 1fr);}
    }
    .kpi{
      background: rgba(15,23,48,.65);
      border: 1px solid rgba(183,194,255,.14);
      border-radius: 16px;
      padding: 10px 12px;
    }
    .kpi .label{color:var(--muted); font-size:.86rem}
    .kpi .value{font-family:var(--mono); font-size:1rem; margin-top:4px}
    .eq{
      background: rgba(15,23,48,.75);
      border: 1px solid rgba(183,194,255,.16);
      border-radius: 16px;
      padding: 12px 12px;
      overflow:auto;
      position:relative;
    }
    pre{
      margin:0;
      white-space:pre-wrap;
      word-break:break-word;
      font-family:var(--mono);
      font-size: .93rem;
      color: #f2f6ff;
    }
    .copyBtn{
      position:absolute;
      top:10px;
      right:10px;
      border-radius: 12px;
      border: 1px solid rgba(183,194,255,.22);
      background: rgba(17,28,58,.65);
      color: var(--ink);
      padding: 6px 10px;
      cursor:pointer;
      font-size: .85rem;
      transition: .18s ease;
    }
    .copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(125,211,252,.14);
      border-color: rgba(125,211,252,.28);
    }
    .miniNote{
      margin-top:10px;
      font-size:.92rem;
      color: var(--muted);
    }

    .vizWrap{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap: 14px;
      align-items:stretch;
    }
    @media (max-width: 1050px){
      .vizWrap{grid-template-columns:1fr}
    }
    figure{
      margin:0;
      background: rgba(15,23,48,.65);
      border: 1px solid rgba(183,194,255,.14);
      border-radius: 16px;
      padding: 12px;
      overflow:hidden;
    }
    figcaption{
      margin-top: 10px;
      color: var(--muted);
      font-size: .92rem;
    }
    canvas{
      width: 100%;
      height: 320px;
      display:block;
      border-radius: 12px;
      background: rgba(7,10,18,.55);
      border: 1px solid rgba(183,194,255,.10);
    }
    .controls{
      display:grid;
      gap: 10px;
      padding: 12px;
      border-radius: 16px;
      background: rgba(15,23,48,.70);
      border: 1px solid rgba(183,194,255,.14);
    }
    .controlRow{
      display:grid;
      grid-template-columns: 140px 1fr 84px;
      gap: 10px;
      align-items:center;
    }
    @media (max-width: 560px){
      .controlRow{grid-template-columns: 1fr; align-items:start}
    }
    label{color:var(--muted); font-size:.92rem}
    input[type="range"]{width:100%}
    select, button.small{
      width:100%;
      background: rgba(17,28,58,.65);
      color: var(--ink);
      border: 1px solid rgba(183,194,255,.22);
      border-radius: 12px;
      padding: 8px 10px;
      font-size:.92rem;
    }
    button.small{cursor:pointer}
    button.small:hover{border-color: rgba(125,211,252,.32); background: rgba(125,211,252,.12)}
    .pill{
      display:inline-flex; gap:8px; align-items:center;
      padding: 6px 10px; border-radius:999px;
      border: 1px solid rgba(183,194,255,.18);
      background: rgba(17,28,58,.50);
      color: var(--muted);
      font-size:.86rem;
    }
    .legendHint{
      display:flex; flex-wrap:wrap; gap:8px;
      margin-top:10px;
    }
    .swatch{
      width: 14px; height: 6px; border-radius:999px; background: var(--accent);
      display:inline-block;
    }
    .swatch.alt{background: var(--accent2)}
    .swatch.good{background: var(--good)}
    .swatch.warn{background: var(--warn)}
    .swatch.bad{background: var(--bad)}
    .foot{
      margin-top: 16px;
      color: var(--muted);
      font-size:.92rem;
    }

    .fadeIn{
      animation: fadeIn .55s ease both;
    }
    @keyframes fadeIn{
      from{opacity:0; transform: translateY(6px)}
      to{opacity:1; transform: translateY(0)}
    }

    /* Print-friendly */
    @media print{
      header{position:relative; background:#fff; color:#000; border-bottom:1px solid #ddd}
      body{background:#fff; color:#000}
      section, aside.toc, figure{box-shadow:none; border:1px solid #ddd; background:#fff}
      .copyBtn, .controls{display:none !important}
      canvas{border:1px solid #ddd; background:#fff}
      a{color:#000; text-decoration:underline}
    }
  </style>
</head>

<body>
<header>
  <div class="toprow">
    <div>
      <h1>7.1-2 — Beamsplitter Slab at 45° (TM): Reflectance/Transmittance & Spectral Response</h1>
      <p class="subtitle">
        A lossless dielectric slab (index <span class="pill"><span class="dot"></span>n</span>) of thickness
        <span class="pill"><span class="dot"></span>d</span> is tilted so the beam hits at 45°. We derive the
        full Fabry–Perot expressions for TM (p) polarization, show the wavelength dependence, and compare with TE (s).
      </p>
      <div class="badgeRow">
        <div class="badge"><span class="dot"></span>Thin-film interference</div>
        <div class="badge"><span class="dot" style="background:var(--accent2)"></span>Oblique Fresnel (TE/TM)</div>
        <div class="badge"><span class="dot" style="background:var(--good)"></span>Energy conservation (lossless)</div>
      </div>
    </div>
    <div class="badge" title="Angle is fixed by the problem statement.">Incidence: θ₀ = 45°</div>
  </div>
</header>

<main class="layout">
  <aside class="toc fadeIn" aria-label="Table of contents">
    <h2>Table of Contents</h2>
    <nav>
      <a href="#quick">Quick Summary</a>
      <a href="#part0">PART 0 — Concept Primer</a>
      <a href="#part1">PART 1 — Problem Analysis</a>
      <a href="#part2">PART 2 — Strategy & Tips</a>
      <a href="#part3">PART 3 — Full Solution</a>
      <a href="#part4">PART 4 — Deeper Understanding</a>
      <a href="#part5">PART 5 — Visualization Guide</a>
    </nav>
    <div class="foot faint" style="margin-top:10px">
      Tip: Use the thickness/index controls in the visualization section—every plot updates live.
    </div>
  </aside>

  <article>
    <section id="quick" class="fadeIn">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>What this is:</b> A tilted dielectric slab acting as a <b>beamsplitter</b> via <b>two-interface interference</b> (Fabry–Perot).</li>
        <li><b>Key idea:</b> Multiple internal reflections create a wavelength-dependent phase <b>δ</b>, causing oscillations in <b>R(λ)</b> and <b>T(λ)</b>.</li>
        <li><b>Governing physics:</b> Fresnel coefficients at oblique incidence + coherent summation (or transfer-matrix) for a single layer.</li>
        <li><b>Phase thickness:</b> δ = (2π/λ)·n·d·cosθ₁ (with θ₁ from Snell’s law).</li>
        <li><b>TM vs TE:</b> Same interference structure, but different effective admittance (<b>TM: Y = n/cosθ</b>, <b>TE: Y = n cosθ</b>) → different r and therefore different spectral contrast.</li>
        <li><b>Result type:</b> Fully <b>symbolic expressions</b> for r(λ), t(λ) and power <b>R(λ)=|r|²</b>, <b>T(λ)=|t|²</b> (for air–slab–air).</li>
        <li><b>Lossless check:</b> For the symmetric (air on both sides) slab, <b>R(λ)+T(λ)=1</b> at all wavelengths (coherent, no absorption).</li>
      </ul>
    </section>

    <section id="part0" class="fadeIn">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="grid2">
        <div class="callout">
          <h3>Core definitions (symbols & units)</h3>
          <ul>
            <li><b>n</b> — refractive index of slab (dimensionless), assumed real (lossless).</li>
            <li><b>d</b> — slab thickness (m).</li>
            <li><b>λ</b> — vacuum wavelength (m); spectral variable.</li>
            <li><b>θ₀</b> — incidence angle in air (rad or °), here fixed at 45°.</li>
            <li><b>θ₁</b> — refraction angle inside slab, from Snell: n₀ sinθ₀ = n sinθ₁ (n₀=1).</li>
            <li><b>δ</b> — phase accumulated in one pass through the slab: δ = (2π/λ) n d cosθ₁.</li>
            <li><b>r, t</b> — complex amplitude reflection/transmission coefficients (electric-field ratios).</li>
            <li><b>R, T</b> — power reflectance/transmittance (dimensionless), typically R=|r|², T=|t|² in a symmetric lossless air–slab–air case.</li>
          </ul>
        </div>

        <div class="callout">
          <h3>Physical meaning</h3>
          <ul>
            <li><b>Fresnel coefficients</b> determine how much of a plane wave reflects/transmits at an interface for a given polarization and angle.</li>
            <li><b>Interference</b>: inside a slab, the transmitted wave is a sum of many partial beams (multiple internal reflections) with relative phase 2δ per round trip.</li>
            <li><b>Spectral dependence</b> arises because δ ∝ 1/λ: changing wavelength changes constructive/destructive interference.</li>
            <li><b>Polarization dependence</b> arises because boundary conditions differ for TE (s) and TM (p), effectively changing the “optical admittance” seen by the wave.</li>
          </ul>
        </div>
      </div>

      <div class="grid2" style="margin-top:14px">
        <div class="callout">
          <h3>Key principles & validity conditions</h3>
          <ul>
            <li>Plane-wave, monochromatic, coherent illumination (coherence length ≫ 2nd).</li>
            <li>Linear, isotropic, homogeneous slab; <b>no absorption</b> (n real).</li>
            <li>Specular reflections (interfaces are flat compared to λ).</li>
            <li>Steady state: all multiple reflections have built up.</li>
          </ul>
          <div class="miniNote"><b>When this fails:</b> rough surfaces, thick wedges (fringes wash out), broadband incoherent light, absorption, or significant beam divergence.</div>
        </div>

        <div class="callout">
          <h3>Common models/approximations</h3>
          <ul>
            <li><b>Two-beam approximation</b> (ignore multiple bounces): fast but misses sharp spectral features.</li>
            <li><b>Fabry–Perot / transfer-matrix</b> (full multiple-beam sum): exact for a single uniform layer.</li>
            <li><b>Energy conservation check</b>: lossless symmetric slab should satisfy <b>R+T=1</b>.</li>
          </ul>
          <div class="miniNote"><b>We use:</b> the full transfer-matrix (equivalent to summing the infinite geometric series).</div>
        </div>
      </div>

      <div class="callout" style="margin-top:14px">
        <h3>Mini intuition examples (conceptual)</h3>
        <ul>
          <li><b>Very thin slab</b> (d → 0): δ → 0, the two interfaces “merge” and the slab becomes almost invisible → R small, T ≈ 1.</li>
          <li><b>Thickness tuned so 2δ = 2πm</b>: internal round-trip adds in-phase, producing strong resonance behavior (either high T or high R depending on r and phase).</li>
        </ul>
        <h3 style="margin-top:10px">What to watch for (pitfalls)</h3>
        <ul>
          <li>Mixing up TE vs TM formulas for r and the effective admittance.</li>
          <li>For oblique incidence, forgetting the <b>cosθ₁</b> factor in δ.</li>
          <li>Using intensity formulas without ensuring a consistent definition of t; the symmetric air–slab–air case simplifies many prefactors.</li>
          <li>Confusing “geometric thickness” d with “optical thickness” n d cosθ₁.</li>
        </ul>
      </div>
    </section>

    <section id="part1" class="fadeIn">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <div class="callout">
        <h3>Problem restatement</h3>
        <p class="muted">
          A lossless dielectric slab of refractive index <b>n</b> and thickness <b>d</b> is used as a beamsplitter.
          The slab is oriented so an incoming beam in air hits the first surface at <b>θ₀ = 45°</b>.
          Derive expressions for the <b>TM-polarized</b> reflectance and transmittance, including their wavelength dependence,
          and compare qualitatively with the TE case.
        </p>
      </div>

      <div class="grid2" style="margin-top:14px">
        <div class="callout">
          <h3>Given</h3>
          <ul>
            <li>Lossless slab: n (real), thickness d.</li>
            <li>Incidence angle: θ₀ = 45° in air (n₀ = 1).</li>
            <li>Polarization: TM (p) for the main derivation.</li>
          </ul>
        </div>
        <div class="callout">
          <h3>Unknowns / what to find</h3>
          <ul>
            <li>Complex amplitude coefficients r(λ), t(λ) for the slab.</li>
            <li>Power reflectance <b>R(λ)</b> and transmittance <b>T(λ)</b> for TM.</li>
            <li>A comparison statement: how/why TE differs from TM.</li>
          </ul>
        </div>
      </div>

      <div class="callout" style="margin-top:14px">
        <h3>Relevant physics & why it applies</h3>
        <ul>
          <li><b>Fresnel boundary conditions</b> apply at each planar interface because the slab is homogeneous and the wave is treated as a plane wave.</li>
          <li><b>Coherent multiple reflections</b> are important because a slab has two reflecting surfaces and (in general) produces interference fringes vs λ.</li>
          <li><b>Transfer-matrix / Fabry–Perot theory</b> is ideal here: a single uniform layer between two identical media (air) gives compact closed-form r(λ), t(λ).</li>
        </ul>
        <p class="miniNote"><b>Why not geometric optics only?</b> A pure ray model gives only two beams (one reflection, one transmission) and misses the wavelength-dependent interference that the problem explicitly asks for.</p>
      </div>

      <div class="callout">
        <h3>Assumptions (explicit)</h3>
        <ul>
          <li>n is real (no absorption), slab is lossless.</li>
          <li>Interfaces are parallel, flat, and smooth.</li>
          <li>Coherent illumination; steady-state interference is observed.</li>
          <li>We neglect walk-off and finite-beam effects (treat as plane wave).</li>
          <li>External media on both sides are air (n₀ = n₂ = 1), so θ₂ = θ₀.</li>
        </ul>
      </div>

      <div class="callout">
        <h3>Possible approaches (and choice)</h3>
        <ul>
          <li><b>Infinite-beam summation (Fabry–Perot series):</b> physically intuitive; shows how the geometric series arises. Can get algebra-heavy but yields classic formulas.</li>
          <li><b>Transfer-matrix method:</b> systematic, compact, and handles TE/TM by swapping an admittance parameter. Best for clean derivation and plotting.</li>
          <li><b>Numerical EM solver:</b> overkill; not needed for a uniform planar slab.</li>
        </ul>
        <p class="miniNote"><b>We choose:</b> the <b>transfer-matrix</b> method because it gives both TM and TE results with minimal extra work and makes energy checks easy.</p>
      </div>
    </section>

    <section id="part2" class="fadeIn">
      <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

      <ol>
        <li>
          <b>Find the refraction angle θ₁.</b><br>
          <span class="muted">Tool:</span> Snell’s law (n₀ sinθ₀ = n sinθ₁).<br>
          <span class="muted">Meaning:</span> sets the propagation direction inside the slab and determines cosθ₁ used in the phase.
        </li>
        <li>
          <b>Define polarization-dependent admittances Y.</b><br>
          <span class="muted">Tool:</span> TE: Y = n cosθ; TM: Y = n / cosθ (relative admittance).<br>
          <span class="muted">Meaning:</span> encodes boundary conditions compactly.
        </li>
        <li>
          <b>Compute the phase thickness δ(λ).</b><br>
          <span class="muted">Tool:</span> δ = (2π/λ) n d cosθ₁.<br>
          <span class="muted">Meaning:</span> controls interference; changing λ sweeps δ.
        </li>
        <li>
          <b>Write the single-layer characteristic matrix M.</b><br>
          <span class="muted">Tool:</span> M = [[cosδ, i sinδ / Y₁],[i Y₁ sinδ, cosδ]].<br>
          <span class="muted">Meaning:</span> relates fields across the slab.
        </li>
        <li>
          <b>Compute r and t from M and the surrounding medium admittance Y₀ (and substrate Y₂).</b><br>
          <span class="muted">Tool:</span> standard thin-film formulas for r,t using (A,B,C,D).<br>
          <span class="muted">Meaning:</span> gives wavelength-dependent complex amplitudes.
        </li>
        <li>
          <b>Convert to power R,T and check R+T=1.</b><br>
          <span class="muted">Tool:</span> R=|r|²; T=(Y₂/Y₀)|t|² (for real admittances). Here Y₂=Y₀ → T=|t|².<br>
          <span class="muted">Meaning:</span> energy conservation validates the derivation.
        </li>
        <li>
          <b>Compare TM with TE.</b><br>
          <span class="muted">Tool:</span> repeat with TE admittance; compare interface reflection magnitude and fringe visibility.<br>
          <span class="muted">Meaning:</span> explains polarization dependence of beamsplitting.
        </li>
      </ol>

      <div class="callout">
        <h3>Common mistakes & quick tips</h3>
        <ul>
          <li><b>Tip:</b> compute cosθ₁ = √(1 − (sinθ₀/n)²) to avoid inverse trig noise in code.</li>
          <li><b>Mistake:</b> using δ = (2π/λ) n d without cosθ₁ at oblique incidence.</li>
          <li><b>Mistake:</b> mixing TE/TM: remember <b>TE uses n cosθ</b>, <b>TM uses n/cosθ</b>.</li>
          <li><b>Tip:</b> always verify <b>R+T≈1</b> numerically (lossless sanity check).</li>
        </ul>
      </div>
    </section>

    <section id="part3" class="fadeIn">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <div class="callout">
        <h3>Qualitative expectation (before math)</h3>
        <ul>
          <li>Because there are <b>two interfaces</b>, the reflected field is the sum of a “front-surface” reflection plus contributions that bounce inside the slab and leak out.</li>
          <li>The relative phase between these contributions changes with <b>λ</b>, so <b>R(λ)</b> and <b>T(λ)</b> will oscillate (fringes).</li>
          <li>TM and TE differ mainly in how strongly each interface reflects at 45°; therefore the <b>fringe contrast</b> (and average split ratio) depends on polarization.</li>
        </ul>
      </div>

      <div class="callout">
        <h3>Step 1 — Geometry: Snell’s law</h3>
        <p class="muted">Define indices: n₀ = 1 (air), n₁ = n (slab), n₂ = 1 (air). Incidence: θ₀ = 45°.</p>
        <div class="eq">
          <button class="copyBtn" data-copy="snell">Copy</button>
          <pre id="snell">Snell: n0 sin(theta0) = n sin(theta1)
Here n0 = 1, theta0 = 45°  =>  sin(theta1) = sin(45°)/n
cos(theta1) = sqrt(1 - (sin(45°)/n)^2)</pre>
        </div>
        <p class="miniNote">
          <b>Why:</b> θ₁ controls the internal propagation direction and the optical path length. The phase depends on <b>cosθ₁</b>.
        </p>
      </div>

      <div class="callout">
        <h3>Step 2 — Define polarization-dependent admittances (TE vs TM)</h3>
        <p class="muted">
          A convenient thin-film formalism uses the (relative) optical admittance Y, which packages boundary conditions.
          For nonmagnetic media (μ≈μ₀) at oblique incidence:
        </p>
        <div class="eq">
          <button class="copyBtn" data-copy="admittance">Copy</button>
          <pre id="admittance">Relative admittance (nonmagnetic):

TE (s):  Y_TE = n cos(theta)
TM (p):  Y_TM = n / cos(theta)</pre>
        </div>
        <p class="miniNote">
          <b>Meaning:</b> TE has E ⟂ plane of incidence; TM has E in the plane. The different field component continuity changes the effective impedance/admittance.
        </p>
      </div>

      <div class="callout">
        <h3>Step 3 — Phase thickness δ(λ)</h3>
        <p class="muted">Inside the slab, the normal component of the wavevector is k₀ n cosθ₁, where k₀=2π/λ.</p>
        <div class="eq">
          <button class="copyBtn" data-copy="delta">Copy</button>
          <pre id="delta">Phase thickness (one pass):

k0 = 2π/λ
δ(λ) = k0 * n * d * cos(theta1) = (2π/λ) n d cos(theta1)</pre>
        </div>
        <p class="miniNote"><b>Why:</b> each internal round trip contributes a phase factor exp(i·2δ). This is the source of spectral fringes.</p>
      </div>

      <div class="callout">
        <h3>Step 4 — Transfer matrix for a single layer</h3>
        <p class="muted">
          For one uniform layer (the slab) of admittance Y₁ and phase δ, the characteristic matrix is:
        </p>
        <div class="eq">
          <button class="copyBtn" data-copy="matrix">Copy</button>
          <pre id="matrix">Characteristic matrix (single layer):

M = |  A   B |
    |  C   D |

A = cos δ
B = i sin δ / Y1
C = i Y1 sin δ
D = cos δ</pre>
        </div>
        <p class="miniNote">
          <b>Interpretation:</b> M relates tangential (E,H) just before the slab to those just after it, while automatically tracking phase accumulation.
        </p>
      </div>

      <div class="callout">
        <h3>Step 5 — Reflection and transmission amplitudes r(λ), t(λ)</h3>
        <p class="muted">
          Let Y₀ be the admittance in air at angle θ₀ and Y₂ the admittance in the exit medium (air) at θ₂=θ₀.
          For a single layer with matrix entries A,B,C,D, the standard thin-film results are:
        </p>
        <div class="eq">
          <button class="copyBtn" data-copy="rt_general">Copy</button>
          <pre id="rt_general">Let denom = Y0 (A + B Y2) + (C + D Y2)

r(λ) = [ Y0 (A + B Y2) - (C + D Y2) ] / denom
t(λ) = [ 2 Y0 ] / denom

Power:
R(λ) = |r(λ)|^2
T(λ) = (Y2/Y0) |t(λ)|^2   (for real admittances)</pre>
        </div>
        <p class="miniNote">
          <b>Important simplification here:</b> air–slab–air gives Y₂ = Y₀ (and θ₂=θ₀). Thus <b>T(λ)=|t(λ)|²</b> and <b>R+T=1</b> for a lossless slab.
        </p>
      </div>

      <div class="callout">
        <h3>Step 6 — Specialize to TM polarization (the asked case)</h3>
        <p class="muted">
          For TM (p), use Y_TM = n/cosθ in each region (with the region’s n and angle).
          Define:
        </p>
        <div class="eq">
          <button class="copyBtn" data-copy="tm_defs">Copy</button>
          <pre id="tm_defs">Angles:
theta0 = 45°
sin(theta1) = sin(theta0)/n
cos(theta1) = sqrt(1 - (sin(theta0)/n)^2)

TM admittances:
Y0 = (n0)/cos(theta0) = 1/cos(theta0)
Y1 = n/cos(theta1)
Y2 = 1/cos(theta0) = Y0

Phase:
δ(λ) = (2π/λ) n d cos(theta1)</pre>
        </div>
        <p class="miniNote">
          Substitute these into the matrix A,B,C,D and then into r(λ), t(λ). That is the complete closed-form solution.
        </p>

        <div class="callout" style="margin-top:12px; border-color: rgba(134,239,172,.28); background: linear-gradient(180deg, rgba(134,239,172,.12), rgba(17,28,58,.55));">
          <h3>Final Answer (TM, air–slab–air, θ₀=45°)</h3>
          <div class="eq">
            <button class="copyBtn" data-copy="final_answer">Copy</button>
            <pre id="final_answer">Given n (real), thickness d, incidence theta0=45°, wavelength λ:

1) Snell:
sin(theta1) = sin(theta0)/n
cos(theta1) = sqrt(1 - (sin(theta0)/n)^2)

2) TM admittances:
Y0 = 1/cos(theta0)
Y1 = n/cos(theta1)
Y2 = Y0

3) Phase thickness:
δ(λ) = (2π/λ) n d cos(theta1)

4) Layer matrix:
A = cosδ
B = i sinδ / Y1
C = i Y1 sinδ
D = cosδ

5) Denominator:
den = Y0 (A + B Y2) + (C + D Y2)

6) Amplitudes:
r_TM(λ) = [Y0 (A + B Y2) - (C + D Y2)] / den
t_TM(λ) = [2 Y0] / den

7) Power (lossless, symmetric air–slab–air):
R_TM(λ) = |r_TM(λ)|^2
T_TM(λ) = |t_TM(λ)|^2
and R_TM(λ) + T_TM(λ) = 1</pre>
          </div>
          <p class="miniNote"><b>What “spectral dependence” means:</b> the wavelength enters primarily through δ(λ) ∝ 1/λ, producing fringes in R and T.</p>
        </div>
      </div>

      <div class="callout">
        <h3>Comparison with TE (as in the referenced example)</h3>
        <p class="muted">
          The interference structure (same δ and same matrix form) is identical; only the admittances change.
          For TE:
        </p>
        <div class="eq">
          <button class="copyBtn" data-copy="te_swap">Copy</button>
          <pre id="te_swap">To get TE (s) results, keep the same steps but use:

Y_TE = n cos(theta)

So:
Y0 = 1 * cos(theta0)
Y1 = n cos(theta1)
Y2 = cos(theta0)

Then compute r_TE(λ), t_TE(λ) with the same matrix formulas,
and R_TE = |r_TE|^2, T_TE = |t_TE|^2 (air–slab–air).</pre>
        </div>

        <div class="miniNote">
          <b>Physical takeaway:</b> at 45°, TM reflection at a single interface often differs significantly from TE.
          That changes (i) the average split ratio and (ii) the fringe visibility (how deep the oscillations are).
        </div>
      </div>

      <div class="grid2">
        <div class="callout">
          <h3>Sanity checks</h3>
          <ul>
            <li><b>Units:</b> δ is dimensionless because it is k·(length).</li>
            <li><b>Lossless energy:</b> with n real and symmetric air–slab–air, numerically you should get <b>R+T=1</b> across λ.</li>
            <li><b>Thin limit:</b> d→0 ⇒ δ→0 ⇒ r→0 ⇒ R→0 and T→1 (slab vanishes).</li>
            <li><b>Fringe period:</b> increasing d increases δ, producing more oscillations vs λ (denser fringes).</li>
          </ul>
        </div>
        <div class="callout">
          <h3>Connection to the geometry (diagram/plots)</h3>
          <ul>
            <li>The diagram shows the internal angle θ₁ and the slab thickness d—together they set the optical path n d cosθ₁.</li>
            <li>The main plot shows <b>R(λ)</b> and <b>T(λ)</b> oscillating as δ(λ) sweeps with wavelength.</li>
            <li>The secondary plot shows how, at a fixed design wavelength, changing d moves you through constructive/destructive conditions.</li>
          </ul>
        </div>
      </div>
    </section>

    <section class="fadeIn">
      <h2>Interactive Visualizations</h2>

      <div class="vizWrap">
        <figure>
          <canvas id="diag" aria-label="Setup diagram canvas"></canvas>
          <figcaption>
            Labeled setup: air → dielectric slab (index <b>n</b>, thickness <b>d</b>) at incidence θ₀=45°. Refraction angle θ₁ follows Snell’s law.
          </figcaption>
        </figure>

        <div class="controls" aria-label="Interactive controls">
          <div class="controlRow">
            <label for="nSlider">Index n</label>
            <input id="nSlider" type="range" min="1.2" max="2.2" step="0.01" value="1.50" />
            <div class="pill"><span class="dot" style="background:var(--accent2)"></span><span id="nVal">1.50</span></div>
          </div>
          <div class="controlRow">
            <label for="dSlider">Thickness d (µm)</label>
            <input id="dSlider" type="range" min="0.10" max="5.00" step="0.01" value="1.00" />
            <div class="pill"><span class="dot" style="background:var(--accent)"></span><span id="dVal">1.00</span></div>
          </div>
          <div class="controlRow">
            <label for="lam0">Marker λ₀ (nm)</label>
            <input id="lam0" type="range" min="400" max="800" step="1" value="633" />
            <div class="pill"><span class="dot" style="background:var(--good)"></span><span id="lam0Val">633</span></div>
          </div>
          <div class="controlRow">
            <label for="showMode">Curves shown</label>
            <select id="showMode">
              <option value="both" selected>TM & TE (compare)</option>
              <option value="tm">TM only</option>
              <option value="te">TE only</option>
            </select>
            <button class="small" id="resetBtn" title="Reset example values">Reset</button>
          </div>

          <div class="legendHint">
            <span class="pill"><span class="swatch"></span> TM: R,T (solid)</span>
            <span class="pill"><span class="swatch alt"></span> TE: R,T (dashed)</span>
            <span class="pill"><span class="swatch good"></span> Marker at λ₀</span>
          </div>

          <p class="miniNote">
            <b>Example values for plotting:</b> λ range 400–800 nm, θ₀=45°. These controls do not change the symbolic derivation—only the visualization.
          </p>
        </div>
      </div>

      <div class="grid2" style="margin-top:14px">
        <figure>
          <canvas id="plot1" aria-label="Main spectrum plot canvas"></canvas>
          <figcaption>
            <b>Main plot:</b> Spectral response R(λ) and T(λ). Interference fringes tighten as d increases because δ(λ) grows.
          </figcaption>
        </figure>
        <figure>
          <canvas id="plot2" aria-label="Secondary thickness sweep plot canvas"></canvas>
          <figcaption>
            <b>Secondary plot:</b> Parameter sweep of reflectance at the chosen marker wavelength λ₀: R(λ₀, d).
            The marker shows the current d value.
          </figcaption>
        </figure>
      </div>

      <div class="kpiRow" aria-label="Computed readouts">
        <div class="kpi">
          <div class="label">θ₁ inside slab (deg)</div>
          <div class="value" id="theta1Out">—</div>
        </div>
        <div class="kpi">
          <div class="label">cosθ₁</div>
          <div class="value" id="cos1Out">—</div>
        </div>
        <div class="kpi">
          <div class="label">At λ₀: R<sub>TM</sub>, T<sub>TM</sub></div>
          <div class="value" id="rtmOut">—</div>
        </div>
        <div class="kpi">
          <div class="label">At λ₀: R<sub>TE</sub>, T<sub>TE</sub></div>
          <div class="value" id="rteOut">—</div>
        </div>
      </div>
    </section>

    <section id="part4" class="fadeIn">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <div class="callout">
        <h3>Re-interpreting the final formula: what controls what?</h3>
        <ul>
          <li><b>δ(λ) = (2π/λ) n d cosθ₁</b> sets the interference condition. Changing <b>λ</b>, <b>d</b>, or <b>n</b> shifts fringes.</li>
          <li><b>Y₀ and Y₁</b> (thus polarization) set the “mismatch” at the interfaces. Strong mismatch → larger interface reflection → higher fringe contrast.</li>
          <li>The denominator <b>den</b> contains terms with sinδ and cosδ. Resonant behavior occurs when the internal field build-up is large (Fabry–Perot effect).</li>
        </ul>
      </div>

      <div class="grid2">
        <div class="callout">
          <h3>Parameter effects (connect to plots)</h3>
          <ul>
            <li><b>Increase d:</b> more rapid oscillations vs λ (denser fringes). In the secondary plot, R(λ₀,d) cycles periodically.</li>
            <li><b>Increase n:</b> θ₁ decreases (ray bends toward normal), cosθ₁ increases, and interface mismatch changes → fringe period and contrast both change.</li>
            <li><b>TM vs TE:</b> the same δ(λ), but different admittances → different r,t → different average beamsplit ratio and fringe visibility.</li>
          </ul>
        </div>
        <div class="callout">
          <h3>An alternative derivation idea</h3>
          <p class="muted">
            Instead of transfer matrices, you can sum the infinite series of partial reflections.
            The reflected amplitude is:
          </p>
          <div class="eq">
            <button class="copyBtn" data-copy="series">Copy</button>
            <pre id="series">Fabry–Perot summation idea (concept):

r_total = r01 + t01 t10 r12 e^{i2δ} + t01 t10 r12 (r10 r12) e^{i4δ} + ...

This is a geometric series in (r10 r12 e^{i2δ}),
leading to a closed form consistent with the matrix result.</pre>
          </div>
          <p class="miniNote">
            The matrix approach is essentially a compact way to package this infinite series while handling TE/TM cleanly.
          </p>
        </div>
      </div>

      <div class="callout">
        <h3>Concept checks (quick self-test)</h3>
        <ul>
          <li><b>Q:</b> Why does R(λ) oscillate even though the slab is lossless? <b>A:</b> Because energy is redistributed between reflected and transmitted beams by interference; no energy is lost.</li>
          <li><b>Q:</b> What happens to fringes if the light’s coherence length is shorter than 2nd? <b>A:</b> Interference washes out; you get incoherent averaging (much weaker spectral structure).</li>
          <li><b>Q:</b> What parameter primarily sets the fringe spacing in wavelength? <b>A:</b> Optical thickness n d cosθ₁ (larger → tighter fringes).</li>
          <li><b>Q:</b> Why do TM and TE differ at the same angle? <b>A:</b> Boundary conditions differ; effective admittances differ, changing the interface reflection strength.</li>
        </ul>
      </div>
    </section>

    <section id="part5" class="fadeIn">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="callout">
        <h3>What each canvas shows</h3>
        <ul>
          <li><b>Diagram:</b> incidence θ₀=45°, refraction θ₁ in the slab, thickness d, and the three main rays (incident, reflected, transmitted).</li>
          <li><b>Main plot:</b> R(λ) and T(λ) from 400–800 nm. Solid curves are TM; dashed curves are TE (unless you change the “Curves shown” selector).</li>
          <li><b>Secondary plot:</b> a thickness sweep: R(λ₀, d) for the currently selected λ₀, showing periodic dependence on d.</li>
        </ul>
      </div>

      <div class="callout">
        <h3>Interactive controls (and what should change)</h3>
        <ul>
          <li><b>Index n:</b> changes θ₁ via Snell’s law and changes interface mismatch; you should see both fringe spacing and contrast change.</li>
          <li><b>Thickness d:</b> changes δ linearly; fringes move faster vs λ and the marker on the thickness sweep moves.</li>
          <li><b>Marker λ₀:</b> moves the green vertical marker on the main plot and changes the secondary sweep curve (because it’s R at that λ₀).</li>
          <li><b>Curves shown:</b> toggles between TM/TE/both to help you compare polarizations.</li>
        </ul>
        <p class="miniNote">
          The plotted symbols match the derivation: the code uses the same θ₀, θ₁, δ(λ), and the same admittance definitions for TE/TM.
        </p>
      </div>
    </section>

    <footer class="foot">
      <p>
        Built as a learning-focused derivation: Fresnel + interference → transfer matrix → spectral R(λ), T(λ), with live visualization.
      </p>
    </footer>
  </article>
</main>

<script>
(function(){
  // ---------- Clipboard copy ----------
  function copyTextFrom(id){
    const el = document.getElementById(id);
    const txt = el ? el.innerText : '';
    navigator.clipboard.writeText(txt).then(()=>{
      // subtle UI feedback
      const btn = document.querySelector('.copyBtn[data-copy="'+id+'"]');
      if(btn){
        const prev = btn.textContent;
        btn.textContent = "Copied ✓";
        setTimeout(()=>btn.textContent = prev, 900);
      }
    }).catch(()=>{ /* ignore */ });
  }
  document.querySelectorAll('.copyBtn').forEach(btn=>{
    btn.addEventListener('click', ()=>copyTextFrom(btn.dataset.copy));
  });

  // ---------- Controls ----------
  const nSlider = document.getElementById('nSlider');
  const dSlider = document.getElementById('dSlider');
  const lam0Slider = document.getElementById('lam0');
  const showMode = document.getElementById('showMode');
  const resetBtn = document.getElementById('resetBtn');

  const nVal = document.getElementById('nVal');
  const dVal = document.getElementById('dVal');
  const lam0Val = document.getElementById('lam0Val');

  const theta1Out = document.getElementById('theta1Out');
  const cos1Out = document.getElementById('cos1Out');
  const rtmOut = document.getElementById('rtmOut');
  const rteOut = document.getElementById('rteOut');

  resetBtn.addEventListener('click', ()=>{
    nSlider.value = 1.50;
    dSlider.value = 1.00;
    lam0Slider.value = 633;
    showMode.value = 'both';
    updateAll();
  });

  // ---------- Canvas helpers ----------
  function setupCanvas(canvas){
    const ctx = canvas.getContext('2d');
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect.width * dpr));
      const h = Math.max(2, Math.floor(rect.height * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    const ro = new ResizeObserver(()=>{ resize(); drawAll(); });
    ro.observe(canvas);
    resize();
    return ctx;
  }

  // Canvases
  const diag = document.getElementById('diag');
  const plot1 = document.getElementById('plot1');
  const plot2 = document.getElementById('plot2');

  const ctxD = setupCanvas(diag);
  const ctx1 = setupCanvas(plot1);
  const ctx2 = setupCanvas(plot2);

  // ---------- Math ----------
  const deg = Math.PI/180;
  const theta0 = 45*deg;
  const n0 = 1.0;
  const n2 = 1.0;

  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

  function snellTheta1(n){
    const s1 = Math.sin(theta0)/n;
    const s1c = clamp(s1, -0.999999, 0.999999);
    const th1 = Math.asin(s1c);
    const c1 = Math.sqrt(Math.max(0, 1 - s1c*s1c));
    return {theta1: th1, cos1: c1, sin1: s1c};
  }

  function admittance(pol, n, theta){
    // Relative admittance for nonmagnetic media:
    // TE: Y = n cosθ
    // TM: Y = n / cosθ
    const c = Math.cos(theta);
    if(pol === 'TE') return n * c;
    return n / Math.max(1e-9, c);
  }

  function layerRT(pol, n, d_m, lambda_m){
    // Transfer matrix for a single layer between identical media (air on both sides),
    // but we keep general formula with Y0 and Y2; here n0=n2=1 and theta2=theta0.
    const {theta1, cos1} = snellTheta1(n);
    const theta2 = theta0;

    const Y0 = admittance(pol, n0, theta0);
    const Y1 = admittance(pol, n,  theta1);
    const Y2 = admittance(pol, n2, theta2);

    const delta = (2*Math.PI/lambda_m) * n * d_m * cos1;
    const c = Math.cos(delta);
    const s = Math.sin(delta);

    // Matrix elements
    const A = c;
    const B = {re: 0, im: s / Y1};      // i sinδ / Y1
    const C = {re: 0, im: Y1 * s};      // i Y1 sinδ
    const D = c;

    // Complex arithmetic helpers
    function cAdd(a,b){ return {re:a.re+b.re, im:a.im+b.im}; }
    function cSub(a,b){ return {re:a.re-b.re, im:a.im-b.im}; }
    function cMul(a,b){ return {re:a.re*b.re - a.im*b.im, im:a.re*b.im + a.im*b.re}; }
    function cDiv(a,b){
      const den = b.re*b.re + b.im*b.im;
      return {re:(a.re*b.re + a.im*b.im)/den, im:(a.im*b.re - a.re*b.im)/den};
    }
    function cAbs2(a){ return a.re*a.re + a.im*a.im; }
    function cReal(x){ return {re:x, im:0}; }

    // Compute (A + B Y2) and (C + D Y2)
    const BY2 = cMul(B, cReal(Y2));
    const AplusBY2 = cAdd(cReal(A), BY2);

    const DY2 = cMul(cReal(D), cReal(Y2));
    const CplusDY2 = cAdd(C, DY2);

    // denom = Y0(A+BY2) + (C+DY2)
    const Y0A = cMul(cReal(Y0), AplusBY2);
    const denom = cAdd(Y0A, CplusDY2);

    // r = [Y0(A+BY2) - (C+DY2)] / denom
    const numerR = cSub(Y0A, CplusDY2);
    const r = cDiv(numerR, denom);

    // t = [2 Y0] / denom
    const t = cDiv(cReal(2*Y0), denom);

    // Power: R=|r|^2, T=(Y2/Y0)|t|^2 for real Y; here Y2=Y0 (air-air), so T=|t|^2
    const R = cAbs2(r);
    const T = (Y2/Y0) * cAbs2(t);

    return {R, T, theta1, cos1, delta};
  }

  // ---------- Plotting ----------
  function clear(ctx){
    const w = ctx.canvas.getBoundingClientRect().width;
    const h = ctx.canvas.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);
  }

  function drawPanelBG(ctx){
    const w = ctx.canvas.getBoundingClientRect().width;
    const h = ctx.canvas.getBoundingClientRect().height;
    // background
    ctx.save();
    ctx.fillStyle = 'rgba(7,10,18,0.55)';
    ctx.fillRect(0,0,w,h);
    // subtle grid vignette
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,'rgba(255,255,255,0.04)');
    g.addColorStop(1,'rgba(255,255,255,0.00)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
    ctx.restore();
  }

  function plotAxes(ctx, rect, xMin,xMax,yMin,yMax, xLabel, yLabel, title){
    const {x,y,w,h} = rect;
    ctx.save();
    // Title
    ctx.fillStyle = 'rgba(233,238,255,0.92)';
    ctx.font = '600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(title, x+8, y+16);

    // Plot area
    const padL=54, padR=14, padT=26, padB=38;
    const px = x+padL, py=y+padT, pw=w-padL-padR, ph=h-padT-padB;

    // Grid
    ctx.strokeStyle = 'rgba(183,194,255,0.12)';
    ctx.lineWidth = 1;

    function niceTicks(min,max,count){
      const span = max-min;
      const raw = span/Math.max(1,count);
      const pow = Math.pow(10, Math.floor(Math.log10(raw)));
      const f = raw/pow;
      let step = 1;
      if(f>=5) step=5;
      else if(f>=2) step=2;
      else step=1;
      step *= pow;
      const start = Math.ceil(min/step)*step;
      const ticks=[];
      for(let v=start; v<=max+1e-9; v+=step) ticks.push(v);
      return {step, ticks};
    }

    const xT = niceTicks(xMin,xMax,6);
    const yT = niceTicks(yMin,yMax,5);

    // grid lines + ticks
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';
    ctx.fillStyle = 'rgba(183,194,255,0.82)';

    // vertical grid
    xT.ticks.forEach(v=>{
      const tx = px + (v-xMin)/(xMax-xMin)*pw;
      ctx.beginPath();
      ctx.moveTo(tx, py);
      ctx.lineTo(tx, py+ph);
      ctx.stroke();
      // tick label
      ctx.fillText(String(Math.round(v)), tx-10, py+ph+18);
    });

    // horizontal grid
    yT.ticks.forEach(v=>{
      const ty = py+ph - (v-yMin)/(yMax-yMin)*ph;
      ctx.beginPath();
      ctx.moveTo(px, ty);
      ctx.lineTo(px+pw, ty);
      ctx.stroke();
      ctx.fillText(v.toFixed(1), px-44, ty+4);
    });

    // axes
    ctx.strokeStyle = 'rgba(183,194,255,0.28)';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(px, py+ph);
    ctx.lineTo(px+pw, py+ph);
    ctx.stroke();

    // labels
    ctx.fillStyle = 'rgba(233,238,255,0.90)';
    ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(xLabel, px+pw-2-ctx.measureText(xLabel).width, y+h-10);
    // rotate y label
    ctx.save();
    ctx.translate(x+14, py+ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    ctx.restore();
    return {px,py,pw,ph, xMin,xMax,yMin,yMax};
  }

  function mapX(g, x){ return g.px + (x-g.xMin)/(g.xMax-g.xMin)*g.pw; }
  function mapY(g, y){ return g.py+g.ph - (y-g.yMin)/(g.yMax-g.yMin)*g.ph; }

  function drawLine(ctx, g, xs, ys, style, dashed){
    ctx.save();
    ctx.strokeStyle = style;
    ctx.lineWidth = 2;
    if(dashed) ctx.setLineDash([8,6]);
    ctx.beginPath();
    for(let i=0;i<xs.length;i++){
      const X = mapX(g, xs[i]);
      const Y = mapY(g, ys[i]);
      if(i===0) ctx.moveTo(X,Y);
      else ctx.lineTo(X,Y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawLegend(ctx, rect, entries){
    const {x,y,w} = rect;
    ctx.save();
    const boxY = y+28;
    let cx = x+56;
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    entries.forEach(e=>{
      // line sample
      ctx.strokeStyle = e.color;
      ctx.lineWidth = 2;
      ctx.setLineDash(e.dashed ? [8,6] : []);
      ctx.beginPath();
      ctx.moveTo(cx, boxY);
      ctx.lineTo(cx+18, boxY);
      ctx.stroke();
      ctx.setLineDash([]);
      // text
      ctx.fillStyle = 'rgba(233,238,255,0.88)';
      ctx.fillText(e.label, cx+24, boxY+4);
      cx += 24 + ctx.measureText(e.label).width + 18;
      if(cx > x+w-40){ cx = x+56; }
    });
    ctx.restore();
  }

  function drawVMarker(ctx, g, xValue, color){
    const X = mapX(g, xValue);
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.8;
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(X, g.py);
    ctx.lineTo(X, g.py+g.ph);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  function drawPoint(ctx, g, xValue, yValue, color){
    const X = mapX(g, xValue);
    const Y = mapY(g, yValue);
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(X, Y, 4.2, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // ---------- Diagram ----------
  function drawDiagram(ctx, n, d_um){
    const w = ctx.canvas.getBoundingClientRect().width;
    const h = ctx.canvas.getBoundingClientRect().height;
    clear(ctx); drawPanelBG(ctx);

    const margin = 16;
    const cx = w*0.52, cy = h*0.52;
    const slabLen = Math.min(w*0.58, 420);
    const slabThk = Math.min(h*0.22, 68);

    // slab rotated
    const angle = -18*deg; // visual tilt (not incidence)
    const x1 = cx - slabLen/2, x2 = cx + slabLen/2;
    const y1 = cy - slabThk/2, y2 = cy + slabThk/2;

    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(angle);

    // slab body
    ctx.fillStyle = 'rgba(125,211,252,0.10)';
    ctx.strokeStyle = 'rgba(125,211,252,0.40)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(-slabLen/2, -slabThk/2, slabLen, slabThk, 14);
    ctx.fill();
    ctx.stroke();

    // inner hint lines
    ctx.strokeStyle = 'rgba(183,194,255,0.18)';
    ctx.lineWidth = 1;
    for(let i=-2;i<=2;i++){
      const yy = i*(slabThk/5);
      ctx.beginPath();
      ctx.moveTo(-slabLen/2+10, yy);
      ctx.lineTo(slabLen/2-10, yy);
      ctx.stroke();
    }

    // thickness arrow d
    ctx.strokeStyle = 'rgba(134,239,172,0.9)';
    ctx.fillStyle = 'rgba(134,239,172,0.95)';
    ctx.lineWidth = 1.6;
    const ax = -slabLen*0.10;
    ctx.beginPath();
    ctx.moveTo(ax, -slabThk/2);
    ctx.lineTo(ax, slabThk/2);
    ctx.stroke();
    // arrowheads
    ctx.beginPath();
    ctx.moveTo(ax-6, -slabThk/2+10); ctx.lineTo(ax, -slabThk/2); ctx.lineTo(ax+6, -slabThk/2+10);
    ctx.moveTo(ax-6, slabThk/2-10);  ctx.lineTo(ax, slabThk/2);  ctx.lineTo(ax+6, slabThk/2-10);
    ctx.stroke();

    ctx.font = '600 12px ui-sans-serif, system-ui';
    ctx.fillText('d', ax+10, 0);

    // label n
    ctx.fillStyle = 'rgba(233,238,255,0.92)';
    ctx.fillText('slab (n)', 10, -slabThk/2-10);

    ctx.restore();

    // beams: incidence at 45° relative to surface normal in air (diagram stylized)
    const hitX = cx - slabLen*0.15*Math.cos(angle);
    const hitY = cy - slabLen*0.15*Math.sin(angle);

    function arrow(xa,ya, xb,yb, color, label){
      ctx.save();
      ctx.strokeStyle = color; ctx.lineWidth = 2.2;
      ctx.beginPath(); ctx.moveTo(xa,ya); ctx.lineTo(xb,yb); ctx.stroke();
      // arrowhead
      const ang = Math.atan2(yb-ya, xb-xa);
      const L=10;
      ctx.beginPath();
      ctx.moveTo(xb, yb);
      ctx.lineTo(xb - L*Math.cos(ang-0.35), yb - L*Math.sin(ang-0.35));
      ctx.lineTo(xb - L*Math.cos(ang+0.35), yb - L*Math.sin(ang+0.35));
      ctx.closePath();
      ctx.fillStyle = color; ctx.fill();
      // label
      ctx.fillStyle = 'rgba(233,238,255,0.92)';
      ctx.font = '600 12px ui-sans-serif, system-ui';
      if(label) ctx.fillText(label, (xa+xb)/2+6, (ya+yb)/2-6);
      ctx.restore();
    }

    // incident
    arrow(margin, h*0.20, hitX, hitY, 'rgba(125,211,252,0.95)', 'incident');
    // reflected
    arrow(hitX, hitY, margin, h*0.38, 'rgba(251,113,133,0.92)', 'reflected');
    // transmitted
    arrow(hitX+20, hitY+10, w-margin, h*0.68, 'rgba(134,239,172,0.92)', 'transmitted');

    // angle arcs (stylized)
    ctx.save();
    ctx.strokeStyle = 'rgba(183,194,255,0.50)';
    ctx.lineWidth = 1.4;
    ctx.beginPath();
    ctx.arc(hitX, hitY, 26, -0.95, -0.45);
    ctx.stroke();
    ctx.fillStyle = 'rgba(233,238,255,0.88)';
    ctx.font = '600 12px ui-sans-serif, system-ui';
    ctx.fillText('θ₀=45°', hitX+22, hitY-18);

    // theta1 label
    ctx.fillStyle = 'rgba(233,238,255,0.88)';
    ctx.fillText('θ₁ (inside)', hitX+70, hitY+30);
    ctx.restore();

    // bottom info strip
    ctx.save();
    ctx.fillStyle = 'rgba(15,23,48,0.75)';
    ctx.fillRect(0, h-34, w, 34);
    ctx.fillStyle = 'rgba(183,194,255,0.92)';
    ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;
    ctx.fillText(`Example for plots: n=${n.toFixed(2)}, d=${d_um.toFixed(2)} µm, θ₀=45°`, 12, h-12);
    ctx.restore();
  }

  // ---------- Main plot: spectra ----------
  function computeSpectra(n, d_um){
    const d_m = d_um * 1e-6;
    const lamMin = 400, lamMax = 800; // nm
    const N = 401;
    const xs = new Array(N);
    const Rtm = new Array(N), Ttm = new Array(N), Rte = new Array(N), Tte = new Array(N);
    for(let i=0;i<N;i++){
      const lam_nm = lamMin + (lamMax-lamMin)*i/(N-1);
      const lam_m  = lam_nm * 1e-9;
      xs[i] = lam_nm;
      const tm = layerRT('TM', n, d_m, lam_m);
      const te = layerRT('TE', n, d_m, lam_m);
      Rtm[i]=tm.R; Ttm[i]=tm.T;
      Rte[i]=te.R; Tte[i]=te.T;
    }
    return {xs, Rtm, Ttm, Rte, Tte, lamMin, lamMax};
  }

  function drawMainPlot(ctx, n, d_um, lam0, mode){
    const w = ctx.canvas.getBoundingClientRect().width;
    const h = ctx.canvas.getBoundingClientRect().height;
    clear(ctx); drawPanelBG(ctx);

    const data = computeSpectra(n, d_um);
    const rect = {x:0,y:0,w,h};
    const g = plotAxes(ctx, rect, data.lamMin, data.lamMax, 0, 1, 'λ (nm)', 'R, T (power)', 'Spectral Beamsplitting: R(λ), T(λ)');

    // Legend depends on mode
    const entries = [];
    if(mode==='both' || mode==='tm'){
      entries.push({label:'TM R', color:'rgba(125,211,252,0.95)', dashed:false});
      entries.push({label:'TM T', color:'rgba(134,239,172,0.92)', dashed:false});
    }
    if(mode==='both' || mode==='te'){
      entries.push({label:'TE R', color:'rgba(167,139,250,0.92)', dashed:true});
      entries.push({label:'TE T', color:'rgba(251,191,36,0.92)', dashed:true});
    }
    drawLegend(ctx, rect, entries);

    // Draw curves
    if(mode==='both' || mode==='tm'){
      drawLine(ctx, g, data.xs, data.Rtm, 'rgba(125,211,252,0.95)', false);
      drawLine(ctx, g, data.xs, data.Ttm, 'rgba(134,239,172,0.92)', false);
    }
    if(mode==='both' || mode==='te'){
      drawLine(ctx, g, data.xs, data.Rte, 'rgba(167,139,250,0.92)', true);
      drawLine(ctx, g, data.xs, data.Tte, 'rgba(251,191,36,0.92)', true);
    }

    // Marker at lam0
    drawVMarker(ctx, g, lam0, 'rgba(134,239,172,0.95)');

    // marker values (interpolate nearest)
    const i = Math.round((lam0 - data.lamMin)/(data.lamMax-data.lamMin)*(data.xs.length-1));
    const idx = clamp(i, 0, data.xs.length-1)|0;
    if(mode==='both' || mode==='tm'){
      drawPoint(ctx, g, lam0, data.Rtm[idx], 'rgba(125,211,252,0.98)');
      drawPoint(ctx, g, lam0, data.Ttm[idx], 'rgba(134,239,172,0.98)');
    }
    if(mode==='both' || mode==='te'){
      drawPoint(ctx, g, lam0, data.Rte[idx], 'rgba(167,139,250,0.98)');
      drawPoint(ctx, g, lam0, data.Tte[idx], 'rgba(251,191,36,0.98)');
    }
  }

  // ---------- Secondary plot: R(lam0, d) sweep ----------
  function drawSweepPlot(ctx, n, d_um_current, lam0, mode){
    const w = ctx.canvas.getBoundingClientRect().width;
    const h = ctx.canvas.getBoundingClientRect().height;
    clear(ctx); drawPanelBG(ctx);

    const dMin = 0.10, dMax = 5.00; // µm
    const N = 300;
    const xs = new Array(N);
    const RTM = new Array(N);
    const RTE = new Array(N);
    const lam_m = lam0 * 1e-9;

    for(let i=0;i<N;i++){
      const d_um = dMin + (dMax-dMin)*i/(N-1);
      xs[i]=d_um;
      const tm = layerRT('TM', n, d_um*1e-6, lam_m);
      const te = layerRT('TE', n, d_um*1e-6, lam_m);
      RTM[i]=tm.R;
      RTE[i]=te.R;
    }

    const rect = {x:0,y:0,w,h};
    const g = plotAxes(ctx, rect, dMin, dMax, 0, 1, 'd (µm)', `R at λ₀=${lam0} nm`, 'Thickness Sweep: R(λ₀, d)');

    // legend
    const entries=[];
    if(mode==='both' || mode==='tm') entries.push({label:'TM R(λ₀)', color:'rgba(125,211,252,0.95)', dashed:false});
    if(mode==='both' || mode==='te') entries.push({label:'TE R(λ₀)', color:'rgba(167,139,250,0.92)', dashed:true});
    drawLegend(ctx, rect, entries);

    if(mode==='both' || mode==='tm') drawLine(ctx, g, xs, RTM, 'rgba(125,211,252,0.95)', false);
    if(mode==='both' || mode==='te') drawLine(ctx, g, xs, RTE, 'rgba(167,139,250,0.92)', true);

    // marker at current d
    drawVMarker(ctx, g, d_um_current, 'rgba(134,239,172,0.95)');

    // marker points
    // nearest index
    const j = Math.round((d_um_current - dMin)/(dMax-dMin)*(N-1));
    const jj = clamp(j,0,N-1)|0;
    if(mode==='both' || mode==='tm') drawPoint(ctx, g, d_um_current, RTM[jj], 'rgba(125,211,252,0.98)');
    if(mode==='both' || mode==='te') drawPoint(ctx, g, d_um_current, RTE[jj], 'rgba(167,139,250,0.98)');
  }

  // ---------- Readouts ----------
  function updateReadouts(n, d_um, lam0){
    const {theta1, cos1} = snellTheta1(n);
    theta1Out.textContent = (theta1/deg).toFixed(2);
    cos1Out.textContent = cos1.toFixed(5);

    const lam_m = lam0 * 1e-9;
    const tm = layerRT('TM', n, d_um*1e-6, lam_m);
    const te = layerRT('TE', n, d_um*1e-6, lam_m);

    function fmtPair(R,T){
      return `${R.toFixed(4)}, ${T.toFixed(4)} (sum=${(R+T).toFixed(4)})`;
    }
    rtmOut.textContent = fmtPair(tm.R, tm.T);
    rteOut.textContent = fmtPair(te.R, te.T);
  }

  // ---------- Draw all ----------
  function drawAll(){
    const n = parseFloat(nSlider.value);
    const d_um = parseFloat(dSlider.value);
    const lam0 = parseFloat(lam0Slider.value);
    const mode = showMode.value;

    drawDiagram(ctxD, n, d_um);
    drawMainPlot(ctx1, n, d_um, lam0, mode);
    drawSweepPlot(ctx2, n, d_um, lam0, mode);
  }

  function updateAll(){
    nVal.textContent = parseFloat(nSlider.value).toFixed(2);
    dVal.textContent = parseFloat(dSlider.value).toFixed(2);
    lam0Val.textContent = String(parseInt(lam0Slider.value,10));
    const n = parseFloat(nSlider.value);
    const d_um = parseFloat(dSlider.value);
    const lam0 = parseFloat(lam0Slider.value);
    updateReadouts(n, d_um, lam0);
    drawAll();
  }

  // events
  [nSlider, dSlider, lam0Slider, showMode].forEach(el=>{
    el.addEventListener('input', updateAll);
    el.addEventListener('change', updateAll);
  });

  // initial render
  updateAll();

  // extra: redraw on dpr change (zoom) and resize
  window.addEventListener('resize', ()=>drawAll());

})();
</script>
</body>
</html>
