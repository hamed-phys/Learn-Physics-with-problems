<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>7.2-4 Omnidirectional Reflector ‚Äî Projected Dispersion & Omnidirectional Stop Band</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#101827;
      --card:#0f1a2b;
      --ink:#e9eef7;
      --muted:#b7c3d9;
      --faint:#8fa0bb;
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.16);
      --accent:#66d9ff;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 14px 35px rgba(0,0,0,.38);
      --radius:18px;
      --radius2:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(102,217,255,.15), transparent 60%),
        radial-gradient(1000px 700px at 90% 10%, rgba(167,139,250,.12), transparent 55%),
        radial-gradient(900px 700px at 30% 110%, rgba(52,211,153,.10), transparent 55%),
        linear-gradient(180deg, #070a10, var(--bg));
      line-height:1.55;
    }

    header{
      padding:28px 18px 8px;
      max-width:1200px;
      margin:0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.3fr .7fr;
      gap:16px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns:1fr}
    }
    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:18px 18px 16px;
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .titleCard:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(600px 200px at 40% 0%, rgba(102,217,255,.18), transparent 60%);
      pointer-events:none;
    }
    h1{
      margin:0 0 8px;
      font-size: clamp(1.25rem, 2.4vw, 2.05rem);
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      margin:0;
      max-width:70ch;
      font-size: 0.98rem;
    }

    .controlCard{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:16px;
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .controlCard:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(520px 220px at 70% 0%, rgba(167,139,250,.16), transparent 60%);
      pointer-events:none;
    }
    .controls{
      display:grid;
      gap:12px;
      position:relative;
      z-index:1;
    }
    .row{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
    }
    label{
      color:var(--muted);
      font-size:.92rem;
    }
    input[type="range"]{width:100%}
    select{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--line2);
      background: rgba(0,0,0,.18);
      color:var(--ink);
      outline:none;
    }
    .pill{
      font-family:var(--mono);
      font-size:.86rem;
      padding:6px 10px;
      border:1px solid var(--line2);
      border-radius:999px;
      color:var(--ink);
      background: rgba(0,0,0,.18);
      white-space:nowrap;
    }
    .smallHint{
      color:var(--faint);
      font-size:.86rem;
      margin-top:6px;
    }

    main{
      max-width:1200px;
      margin: 10px auto 40px;
      padding:0 18px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
    }

    aside{
      position:sticky;
      top:12px;
      align-self:start;
      border-radius:var(--radius);
      border:1px solid var(--line);
      background: rgba(16,24,39,.78);
      backdrop-filter: blur(8px);
      padding:14px;
      box-shadow: var(--shadow);
    }
    @media (max-width: 980px){
      aside{position:relative; top:auto}
    }
    .tocTitle{
      display:flex;
      gap:10px;
      align-items:center;
      margin:0 0 10px;
      font-size:0.98rem;
      color:var(--muted);
    }
    .toc ul{list-style:none; margin:0; padding:0; display:grid; gap:8px}
    .toc a{
      display:block;
      text-decoration:none;
      color:var(--ink);
      padding:8px 10px;
      border-radius:12px;
      border:1px solid transparent;
      background: rgba(255,255,255,.03);
      transition: transform .15s ease, border-color .15s ease, background .15s ease;
      font-size:.94rem;
    }
    .toc a:hover{
      transform: translateY(-1px);
      border-color: var(--line2);
      background: rgba(255,255,255,.06);
    }

    article{
      background: rgba(16,24,39,.62);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    section{
      padding:18px 18px 16px;
      border-top:1px solid var(--line);
    }
    section:first-child{border-top:none}
    h2{
      margin:0 0 10px;
      font-size: 1.18rem;
      letter-spacing:.2px;
    }
    h3{
      margin:14px 0 8px;
      font-size: 1.02rem;
      color: var(--ink);
    }
    p{margin: 8px 0; color: var(--muted)}
    ul{margin:8px 0 8px 20px; color:var(--muted)}
    li{margin:6px 0}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 860px){
      .grid2{grid-template-columns:1fr}
    }

    .callout{
      border-radius: var(--radius2);
      border: 1px solid var(--line2);
      background: rgba(255,255,255,.04);
      padding:12px 12px 10px;
      margin:10px 0;
      position:relative;
      overflow:hidden;
    }
    .callout:before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(480px 140px at 20% 0%, rgba(102,217,255,.10), transparent 55%);
      pointer-events:none;
    }
    .callout h4{
      margin:0 0 6px;
      font-size:.95rem;
      color:var(--ink);
      letter-spacing:.2px;
      position:relative;
      z-index:1;
    }
    .callout .body{position:relative; z-index:1}

    .eq{
      font-family: var(--mono);
      color: #eaf2ff;
      background: rgba(0,0,0,.22);
      border:1px solid var(--line2);
      border-radius: 14px;
      padding:12px 12px;
      overflow:auto;
      position:relative;
    }
    .eq .copyBtn{
      position:absolute;
      top:10px; right:10px;
      border:1px solid var(--line2);
      background: rgba(255,255,255,.06);
      color: var(--ink);
      border-radius: 12px;
      padding:6px 10px;
      font-size:.84rem;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease;
    }
    .eq .copyBtn:hover{transform: translateY(-1px); background: rgba(255,255,255,.10)}
    .eq .copyBtn:active{transform: translateY(0px)}
    .eq pre{
      margin:0;
      white-space:pre-wrap;
      word-break:break-word;
      line-height:1.45;
    }

    .vizWrap{
      display:grid;
      gap:12px;
    }
    .canvasCard{
      border-radius: var(--radius);
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      overflow:hidden;
    }
    .canvasHeader{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:10px;
    }
    .canvasHeader .t{
      margin:0;
      font-size:0.98rem;
      color:var(--ink);
    }
    .canvasHeader .meta{
      color:var(--faint);
      font-size:.84rem;
      font-family:var(--mono);
      text-align:right;
      line-height:1.25;
    }
    canvas{
      width:100%;
      height:340px;
      display:block;
    }
    @media (max-width: 980px){
      canvas{height:320px}
    }
    @media print{
      body{background:white; color:black}
      header, main{max-width:none}
      aside{display:none}
      article, .titleCard, .controlCard{box-shadow:none}
      canvas{height:280px}
      .copyBtn{display:none}
    }

    footer{
      max-width:1200px;
      margin:0 auto 22px;
      padding:0 18px;
      color:var(--faint);
      font-size:.88rem;
    }

    /* subtle motion */
    @media (prefers-reduced-motion: no-preference){
      .titleCard, .controlCard, article, aside{
        animation: floatIn .45s ease both;
      }
      .controlCard{animation-delay:.05s}
      aside{animation-delay:.08s}
      article{animation-delay:.10s}
      @keyframes floatIn{
        from{opacity:0; transform: translateY(10px)}
        to{opacity:1; transform: translateY(0px)}
      }
    }

    .badge{
      display:inline-flex; gap:8px; align-items:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line2);
      background: rgba(255,255,255,.05);
      color: var(--muted);
      font-size:.86rem;
    }
    .dot{
      width:9px; height:9px; border-radius:50%;
      background: var(--good);
      box-shadow: 0 0 0 3px rgba(52,211,153,.15);
    }
    .dot.warn{background: var(--warn); box-shadow: 0 0 0 3px rgba(251,191,36,.16)}
    .dot.bad{background: var(--bad); box-shadow: 0 0 0 3px rgba(251,113,133,.16)}
  </style>
</head>

<body>
<header>
  <div class="hero">
    <div class="titleCard">
      <h1>7.2-4 ‚Äî Omnidirectional Reflector (1D Photonic Crystal)</h1>
      <p class="subtitle">
        A periodic bilayer dielectric stack (indices <span class="pill">n‚ÇÇ = 2 n‚ÇÅ</span>) with equal optical thickness
        <span class="pill">n‚ÇÅ d‚ÇÅ = n‚ÇÇ d‚ÇÇ</span> is used as an <b>omnidirectional reflector in air</b>.
        We will build the <b>projected dispersion relation</b> (œâ vs in-plane k‚Çì), overlay the <b>air light line</b>,
        and extract the <b>frequency band</b> (in units of œâ<sub>B</sub>) where reflection occurs for <b>all angles</b> (and both polarizations).
      </p>
    </div>

    <div class="controlCard">
      <div class="controls">
        <div class="row">
          <label for="n1">Index n‚ÇÅ (example, for plotting)</label>
          <span class="pill" id="n1Read">1.50</span>
        </div>
        <input id="n1" type="range" min="1.20" max="2.40" step="0.01" value="1.50"/>

        <div class="row">
          <label for="polView">Main plot view</label>
          <span class="pill" id="n2Read">n‚ÇÇ = 3.00</span>
        </div>
        <select id="polView">
          <option value="both" selected>Show ‚Äúgap if TE and TM are both in gap‚Äù (ODR criterion)</option>
          <option value="te">Show TE only (Bloch propagating vs gap)</option>
          <option value="tm">Show TM only (Bloch propagating vs gap)</option>
        </select>

        <div class="row">
          <label for="gridRes">Plot resolution</label>
          <span class="pill" id="resRead">240√ó220</span>
        </div>
        <input id="gridRes" type="range" min="140" max="360" step="10" value="240"/>

        <div class="smallHint">
          The slider changes <b>absolute indices</b> (keeping the ratio n‚ÇÇ/n‚ÇÅ = 2).
          This matters for omnidirectionality because Snell‚Äôs law controls how ‚Äúgrazing in air‚Äù maps into the layers.
        </div>

        <div class="badge" id="statusBadge" title="Computed from the current slider values">
          <span class="dot warn" id="statusDot"></span>
          <span id="statusText">Computing omnidirectional band‚Ä¶</span>
        </div>
      </div>
    </div>
  </div>
</header>

<main>
  <aside>
    <div class="tocTitle">üìå Sticky mini Table of Contents</div>
    <nav class="toc">
      <ul>
        <li><a href="#quick" data-scroll>Quick Summary</a></li>
        <li><a href="#primer" data-scroll>PART 0 ‚Äî Concept Primer</a></li>
        <li><a href="#analysis" data-scroll>PART 1 ‚Äî Problem Analysis</a></li>
        <li><a href="#strategy" data-scroll>PART 2 ‚Äî Strategy & Tips</a></li>
        <li><a href="#solution" data-scroll>PART 3 ‚Äî Full Solution</a></li>
        <li><a href="#deeper" data-scroll>PART 4 ‚Äî Deeper Understanding</a></li>
        <li><a href="#vizguide" data-scroll>PART 5 ‚Äî Visualization Guide</a></li>
      </ul>
    </nav>
  </aside>

  <article>
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><b>Topic:</b> A 1D periodic dielectric bilayer (a Bragg mirror / 1D photonic crystal) used as an <b>omnidirectional reflector</b> in air.</li>
        <li><b>Key idea:</b> The stack reflects when the <b>Bloch wavevector</b> becomes complex ‚Üí a <b>photonic band gap</b> where <span class="pill">|cos(KŒõ)| &gt; 1</span>.</li>
        <li><b>Governing dispersion (Bloch condition):</b> <span class="pill">cos(KŒõ)=cosŒ¥‚ÇÅcosŒ¥‚ÇÇ ‚àí ¬Ω(p+1/p)sinŒ¥‚ÇÅsinŒ¥‚ÇÇ</span> with angle- and polarization-dependent <span class="pill">p</span>.</li>
        <li><b>Projected dispersion:</b> Plot œâ vs in-plane wavevector k‚Çì; only the region under the <b>air light line</b> (|k‚Çì| ‚â§ œâ/c) corresponds to incidence from air.</li>
        <li><b>Given constraints:</b> equal optical thickness <span class="pill">n‚ÇÅd‚ÇÅ=n‚ÇÇd‚ÇÇ</span>, index ratio <span class="pill">n‚ÇÇ=2n‚ÇÅ</span>, period <span class="pill">Œõ=d‚ÇÅ+d‚ÇÇ</span>.</li>
        <li><b>Normalization:</b> Define Bragg frequency by <span class="pill">Œ¥‚ÇÅ+Œ¥‚ÇÇ=œÄ ‚áî œâ=œâ<sub>B</sub></span>, so results are reported in <span class="pill">œâ/œâ<sub>B</sub></span>.</li>
        <li><b>Result type:</b> An <b>omnidirectional reflection band</b> (a frequency interval) found by enforcing the gap for <b>all</b> k‚Çì in the air cone and for <b>both</b> TE and TM.</li>
        <li><b>Example (typical n‚ÇÅ‚âà1.5):</b> The computed omnidirectional band is approximately <b id="omniTextInline">œâ/œâ<sub>B</sub> ‚âà [1.02, 1.216]</b> (updates live with the slider).</li>
      </ul>
    </section>

    <section id="primer">
      <h2>PART 0 ‚Äî Concept Primer (Theory Before Solving)</h2>

      <h3>Core definitions (symbols + units)</h3>
      <ul>
        <li><b>Refractive index</b> n (dimensionless): relates phase velocity <span class="pill">v = c/n</span>.</li>
        <li><b>Layer thickness</b> d (m): physical thickness of each dielectric slab.</li>
        <li><b>Period</b> Œõ (m): one unit cell length along z: <span class="pill">Œõ = d‚ÇÅ + d‚ÇÇ</span>.</li>
        <li><b>Free-space wavenumber</b> <span class="pill">k‚ÇÄ = œâ/c</span> (rad/m).</li>
        <li><b>In-plane wavevector</b> k‚Çì (rad/m): conserved across planar interfaces; set by incidence angle in air: <span class="pill">k‚Çì = k‚ÇÄ sinŒ∏‚ÇÄ</span>.</li>
        <li><b>Bloch wavevector</b> K (rad/m): describes propagation in a periodic medium: fields repeat up to a phase <span class="pill">E(z+Œõ)=E(z)e^{iKŒõ}</span>.</li>
        <li><b>Phase thickness</b> in layer j: <span class="pill">Œ¥‚±º = k‚ÇÄ n‚±º d‚±º cosŒ∏‚±º</span> (radians).</li>
      </ul>

      <h3>Physical meaning of key quantities</h3>
      <ul>
        <li><b>K real</b> ‚Üí Bloch waves propagate (pass band).</li>
        <li><b>K complex</b> ‚Üí fields decay exponentially (stop band / band gap) ‚Üí strong reflection for a finite stack.</li>
        <li><b>Projected dispersion</b> means: instead of plotting œâ vs K (inside the crystal), we plot œâ vs k‚Çì (set by the outside world). This tells you which external angles can couple to propagating Bloch modes.</li>
      </ul>

      <div class="callout">
        <h4>Key principle: When does a 1D photonic crystal reflect?</h4>
        <div class="body">
          <p>
            For a periodic bilayer, the transfer matrix of one period has a trace related to Bloch propagation:
            if the trace forces <b>|cos(KŒõ)| &gt; 1</b>, then K becomes complex and the wave is evanescent in the stack.
            A finite number of periods then yields a high reflectance (Bragg mirror behavior).
          </p>
        </div>
      </div>

      <h3>Key laws/principles and validity conditions</h3>
      <ul>
        <li><b>Snell‚Äôs law</b>: <span class="pill">n‚ÇÄ sinŒ∏‚ÇÄ = n‚±º sinŒ∏‚±º</span> (planar, isotropic, linear media).</li>
        <li><b>Conservation of k‚Çì</b>: the tangential component of the wavevector is continuous across interfaces.</li>
        <li><b>Transfer-matrix method</b>: valid for stratified (z-only varying) media, harmonic time dependence, no scattering/roughness, and linear dielectrics.</li>
        <li><b>Polarizations:</b> TE (s) and TM (p) behave differently at oblique angles because their effective wave impedances differ.</li>
      </ul>

      <h3>Common models/approximations and why we use them</h3>
      <ul>
        <li><b>Lossless dielectrics</b> (real n): isolates photonic band structure without absorption masking the gap.</li>
        <li><b>Infinite periodic stack</b> for dispersion: the band gap of an infinite crystal predicts high reflection of a long finite stack.</li>
        <li><b>Bragg frequency œâ<sub>B</sub></b>: a convenient normalization around the first stop band (near KŒõ‚âàœÄ).</li>
      </ul>

      <h3>Mini intuition examples</h3>
      <ul>
        <li><b>Normal incidence:</b> The ‚Äúquarter-wave‚Äù idea: when each layer contributes a suitable phase, reflections from many interfaces add in phase ‚Üí strong stop band.</li>
        <li><b>Oblique incidence:</b> Even if a gap exists at Œ∏=0, it can shrink for TM waves near Brewster-like conditions; an <b>omnidirectional</b> reflector needs the gap to survive for all Œ∏ in air.</li>
      </ul>

      <div class="callout">
        <h4>What to watch for (pitfalls)</h4>
        <div class="body">
          <ul>
            <li>Confusing <b>Bloch K</b> (inside the periodic medium) with <b>k‚ÇÄ</b> or <b>k‚Çì</b> (set by incidence).</li>
            <li>Forgetting that TE/TM have different impedance ratios ‚Üí different gaps at oblique angles.</li>
            <li>Calling a band ‚Äúomnidirectional‚Äù by looking only at Œ∏=0; you must check the full air cone <span class="pill">|k‚Çì|‚â§œâ/c</span>.</li>
            <li>Using the same Œ¥‚±º for all angles: remember the <span class="pill">cosŒ∏‚±º</span> factor.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="analysis">
      <h2>PART 1 ‚Äî Problem Analysis (No Solving Yet)</h2>

      <h3>Restate the problem (in plain words)</h3>
      <p>
        We have an infinite periodic stack of two dielectric layers (n‚ÇÅ, d‚ÇÅ) and (n‚ÇÇ, d‚ÇÇ), repeated with period Œõ = d‚ÇÅ + d‚ÇÇ.
        The optical thicknesses are equal: n‚ÇÅ d‚ÇÅ = n‚ÇÇ d‚ÇÇ, and the indices satisfy n‚ÇÇ = 2 n‚ÇÅ.
        The stack sits in air (n‚ÇÄ=1) and should act as an <b>omnidirectional reflector</b>.
        We must:
      </p>
      <ul>
        <li>Plot the <b>projected dispersion relation</b> (œâ vs k‚Çì), including the <b>air light line</b>.</li>
        <li>Determine the <b>frequency range</b> (in units of œâ<sub>B</sub>) where <b>omnidirectional reflection</b> occurs.</li>
      </ul>

      <h3>Given quantities</h3>
      <ul>
        <li>n‚ÇÇ = 2 n‚ÇÅ</li>
        <li>n‚ÇÅ d‚ÇÅ = n‚ÇÇ d‚ÇÇ ‚â° a (define a as the common optical thickness in meters)</li>
        <li>Œõ = d‚ÇÅ + d‚ÇÇ</li>
        <li>Incident medium: air, n‚ÇÄ = 1</li>
      </ul>

      <h3>Unknowns / what must be found</h3>
      <ul>
        <li>The projected dispersion diagram œâ(k‚Çì) with air light line.</li>
        <li>The frequency interval in œâ/œâ<sub>B</sub> where no Bloch propagation occurs for <b>any</b> k‚Çì inside the air cone, for both TE and TM.</li>
      </ul>

      <h3>Relevant physics and why it applies</h3>
      <ul>
        <li><b>Transfer matrix + Bloch theorem</b> applies because the medium is 1D periodic along z.</li>
        <li><b>k‚Çì conservation + Snell‚Äôs law</b> map external incidence angles into internal angles and phase thicknesses Œ¥‚±º.</li>
        <li><b>Band gap criterion</b> <span class="pill">|cos(KŒõ)| &gt; 1</span> identifies stop bands of the infinite periodic structure, which correspond to strong reflection in finite stacks.</li>
      </ul>

      <div class="callout">
        <h4>Assumptions (explicit)</h4>
        <div class="body">
          <ul>
            <li>Lossless, isotropic, linear dielectrics (real n, no absorption).</li>
            <li>Planar, infinite transverse extent (no edge diffraction).</li>
            <li>Time-harmonic fields exp(‚àíiœât) and steady-state propagation.</li>
            <li>We interpret ‚Äúomnidirectional reflector‚Äù as: within the air light cone, <b>both TE and TM</b> have no propagating Bloch modes (stop band).</li>
          </ul>
        </div>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ul>
        <li><b>(A) Transfer-matrix + Bloch trace</b> (best): directly yields band condition <span class="pill">|cos(KŒõ)|</span> for any angle and polarization.</li>
        <li><b>(B) Quarter-wave/Bragg interference heuristics</b>: good intuition near normal incidence but not reliable for omnidirectional (must handle oblique TM properly).</li>
        <li><b>(C) Full reflectance of a finite N-period stack</b>: physically direct, but adds parameters (N, terminations) and obscures the clean band-gap criterion.</li>
      </ul>

      <p><b>Chosen approach:</b> (A) because it produces the projected dispersion and a crisp omnidirectional gap test over the entire air cone.</p>
    </section>

    <section id="strategy">
      <h2>PART 2 ‚Äî Strategy & Tips (Roadmap Only)</h2>

      <ol style="color:var(--muted); margin-left: 20px;">
        <li>
          <b>Parameterize external incidence</b> using (œâ, k‚Çì) with the air constraint |k‚Çì| ‚â§ œâ/c.
          <br/><span class="pill">Tool:</span> k‚Çì = k‚ÇÄ sinŒ∏‚ÇÄ, k‚ÇÄ=œâ/c.
          <br/><span class="pill">Meaning:</span> this defines the ‚Äúaccessible‚Äù region from air in the projected diagram.
        </li>
        <li>
          <b>Use Snell‚Äôs law</b> to compute internal cosŒ∏‚ÇÅ, cosŒ∏‚ÇÇ for a given k‚Çì.
          <br/><span class="pill">Tool:</span> sinŒ∏‚±º = (sinŒ∏‚ÇÄ)/n‚±º.
          <br/><span class="pill">Meaning:</span> oblique rays in air may be less oblique inside high-index layers.
        </li>
        <li>
          <b>Compute phase thicknesses</b> Œ¥‚±º = k‚ÇÄ n‚±º d‚±º cosŒ∏‚±º.
          <br/><span class="pill">Tool:</span> equal optical thickness n‚ÇÅd‚ÇÅ=n‚ÇÇd‚ÇÇ=a simplifies Œ¥‚±º = (œâa/c) cosŒ∏‚±º.
          <br/><span class="pill">Meaning:</span> angle reduces effective optical thickness by cosŒ∏‚±º.
        </li>
        <li>
          <b>Build the Bloch dispersion</b> from the bilayer trace formula.
          <br/><span class="pill">Tool:</span> cos(KŒõ)=cosŒ¥‚ÇÅcosŒ¥‚ÇÇ ‚àí ¬Ω(p+1/p)sinŒ¥‚ÇÅsinŒ¥‚ÇÇ.
          <br/><span class="pill">Meaning:</span> determines pass band vs stop band.
        </li>
        <li>
          <b>Insert polarization dependence</b> via p = Y‚ÇÇ/Y‚ÇÅ (admittance ratio).
          <br/><span class="pill">TE:</span> Y ‚àù n cosŒ∏,  <span class="pill">TM:</span> Y ‚àù n / cosŒ∏.
          <br/><span class="pill">Meaning:</span> TM gaps often shrink first at large angles.
        </li>
        <li>
          <b>Identify the stop band</b> region: |cos(KŒõ)| &gt; 1.
          <br/><span class="pill">Meaning:</span> K is complex ‚Üí evanescent Bloch waves ‚Üí reflection.
        </li>
        <li>
          <b>Omnidirectional criterion</b>: for a given œâ, check all k‚Çì in the air cone and require stop band for both TE and TM.
          <br/><span class="pill">Meaning:</span> ensures reflection for every incidence angle and polarization.
        </li>
      </ol>

      <div class="callout">
        <h4>Common mistakes & quick tips</h4>
        <div class="body">
          <ul>
            <li><b>Tip:</b> Work in projected variables (œâ, k‚Çì) and enforce the air cone explicitly (|k‚Çì| ‚â§ œâ/c).</li>
            <li><b>Mistake:</b> Using the TE admittance ratio for TM (or vice versa). They differ by cosŒ∏ factors.</li>
            <li><b>Tip:</b> Normalize frequency by œâ<sub>B</sub> so the first stop band is centered near œâ/œâ<sub>B</sub>‚âà1.</li>
            <li><b>Mistake:</b> Declaring ‚Äúomnidirectional‚Äù after checking only Œ∏‚ÇÄ=0 and Œ∏‚ÇÄ=90¬∞‚Äîyou must check the continuum of angles in between (our plots do this).</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="solution">
      <h2>PART 3 ‚Äî Full Solution (Detailed + Teaching)</h2>

      <h3>Physical intuition (before math)</h3>
      <p>
        A periodic alternation of refractive index causes repeated partial reflections.
        Near the Bragg condition (roughly ‚Äúhalf a wavelength per period‚Äù in optical path), these reflections add coherently,
        producing a stop band (photonic band gap).
        However, at oblique incidence, the effective phase accumulation decreases (cosŒ∏‚±º) and TM polarization can become
        less reflective due to impedance matching effects.
        An <b>omnidirectional reflector</b> is achieved only if the stop band remains open for <b>all angles in air</b> and for <b>both TE and TM</b>.
      </p>

      <h3>Step 1 ‚Äî Geometry, k‚Çì conservation, and Snell mapping</h3>
      <p>
        Let the stack be periodic along z. The in-plane component k‚Çì is conserved:
      </p>
      <div class="eq" id="eq_kx">
        <button class="copyBtn" data-copy="kx = k0 sin(theta0),   k0 = omega/c">Copy</button>
        <pre>k‚Çì = k‚ÇÄ sinŒ∏‚ÇÄ,   where k‚ÇÄ = œâ/c   (air: n‚ÇÄ=1)</pre>
      </div>
      <p>
        Snell‚Äôs law gives internal angles:
      </p>
      <div class="eq" id="eq_snell">
        <button class="copyBtn" data-copy="sin(theta_j) = sin(theta0)/n_j,   cos(theta_j) = sqrt(1 - (sin(theta0)/n_j)^2)">Copy</button>
        <pre>sinŒ∏‚±º = (sinŒ∏‚ÇÄ)/n‚±º,
cosŒ∏‚±º = ‚àö(1 ‚àí (sinŒ∏‚ÇÄ/n‚±º)¬≤)     (j = 1,2)</pre>
      </div>
      <p>
        In the projected diagram, instead of using Œ∏‚ÇÄ directly, we use (œâ, k‚Çì). Since sinŒ∏‚ÇÄ = k‚Çì/k‚ÇÄ, we have:
      </p>
      <div class="eq" id="eq_sin">
        <button class="copyBtn" data-copy="sin(theta0) = kx/k0 = (c kx)/omega">Copy</button>
        <pre>sinŒ∏‚ÇÄ = k‚Çì/k‚ÇÄ = (c k‚Çì)/œâ</pre>
      </div>
      <p>
        Only <b>incident waves from air</b> are allowed, so we must enforce the ‚Äúair cone‚Äù constraint:
      </p>
      <div class="eq" id="eq_aircone">
        <button class="copyBtn" data-copy="Air light cone: |kx| <= omega/c">Copy</button>
        <pre>Air light cone:   |k‚Çì| ‚â§ œâ/c</pre>
      </div>

      <h3>Step 2 ‚Äî Phase thickness Œ¥‚±º using equal optical thickness</h3>
      <p>
        The phase accumulated across layer j is:
      </p>
      <div class="eq" id="eq_delta">
        <button class="copyBtn" data-copy="delta_j = k0 n_j d_j cos(theta_j) = (omega/c) n_j d_j cos(theta_j)">Copy</button>
        <pre>Œ¥‚±º = k‚ÇÄ n‚±º d‚±º cosŒ∏‚±º = (œâ/c) n‚±º d‚±º cosŒ∏‚±º</pre>
      </div>
      <p>
        The problem gives <span class="pill">n‚ÇÅd‚ÇÅ = n‚ÇÇd‚ÇÇ</span>. Define that common optical thickness as <span class="pill">a</span>:
      </p>
      <div class="eq" id="eq_a">
        <button class="copyBtn" data-copy="Define a = n1 d1 = n2 d2">Copy</button>
        <pre>a ‚â° n‚ÇÅ d‚ÇÅ = n‚ÇÇ d‚ÇÇ</pre>
      </div>
      <p>
        Then both phase thicknesses become especially simple:
      </p>
      <div class="eq" id="eq_delta_simplified">
        <button class="copyBtn" data-copy="delta1 = (omega a/c) cos(theta1),   delta2 = (omega a/c) cos(theta2)">Copy</button>
        <pre>Œ¥‚ÇÅ = (œâa/c) cosŒ∏‚ÇÅ,
Œ¥‚ÇÇ = (œâa/c) cosŒ∏‚ÇÇ</pre>
      </div>

      <h3>Step 3 ‚Äî Bloch dispersion for one period (transfer-matrix trace)</h3>
      <p>
        For a lossless bilayer with one period Œõ=d‚ÇÅ+d‚ÇÇ, the Bloch condition can be written in terms of the trace of the
        one-period transfer matrix:
      </p>
      <div class="eq" id="eq_bloch">
        <button class="copyBtn" data-copy="cos(K Lambda) = cos(delta1)cos(delta2) - 0.5*(p + 1/p)*sin(delta1)sin(delta2)">Copy</button>
        <pre>cos(KŒõ) = cosŒ¥‚ÇÅ cosŒ¥‚ÇÇ ‚àí ¬Ω (p + 1/p) sinŒ¥‚ÇÅ sinŒ¥‚ÇÇ</pre>
      </div>
      <p>
        Here p is the <b>admittance ratio</b> p = Y‚ÇÇ/Y‚ÇÅ, which depends on polarization:
      </p>
      <div class="grid2">
        <div class="eq" id="eq_p_te">
          <button class="copyBtn" data-copy="TE: Y ~ n cos(theta) => p_TE = (n2 cos(theta2)) / (n1 cos(theta1))">Copy</button>
          <pre>TE (s):  Y ‚àù n cosŒ∏
p_TE = (n‚ÇÇ cosŒ∏‚ÇÇ)/(n‚ÇÅ cosŒ∏‚ÇÅ)</pre>
        </div>
        <div class="eq" id="eq_p_tm">
          <button class="copyBtn" data-copy="TM: Y ~ n / cos(theta) => p_TM = (n2/cos(theta2)) / (n1/cos(theta1))">Copy</button>
          <pre>TM (p):  Y ‚àù n / cosŒ∏
p_TM = (n‚ÇÇ / cosŒ∏‚ÇÇ)/(n‚ÇÅ / cosŒ∏‚ÇÅ)</pre>
        </div>
      </div>

      <h3>Step 4 ‚Äî Stop band (band gap) criterion</h3>
      <p>
        Since K is obtained from KŒõ = arccos(cos(KŒõ)), the character of K depends on the magnitude of cos(KŒõ):
      </p>
      <div class="eq" id="eq_gap">
        <button class="copyBtn" data-copy="Pass band: |cos(K Lambda)| <= 1 (K real).  Stop band: |cos(K Lambda)| > 1 (K complex).">Copy</button>
        <pre>Pass band: |cos(KŒõ)| ‚â§ 1   ‚Üí K real (propagating Bloch wave)
Stop band: |cos(KŒõ)|  > 1  ‚Üí K complex (evanescent Bloch wave)</pre>
      </div>

      <h3>Step 5 ‚Äî Define œâ<sub>B</sub> and normalize frequency</h3>
      <p>
        A standard ‚ÄúBragg frequency‚Äù for the first stop band is defined by the condition that the total normal-incidence phase per period equals œÄ:
      </p>
      <div class="eq" id="eq_wB">
        <button class="copyBtn" data-copy="Define omega_B by (delta1+delta2)|theta0=0 = (omega_B/c)*(n1 d1 + n2 d2) = pi">Copy</button>
        <pre>Define œâ_B by:  (Œ¥‚ÇÅ+Œ¥‚ÇÇ)|Œ∏‚ÇÄ=0 = (œâ_B/c) (n‚ÇÅd‚ÇÅ + n‚ÇÇd‚ÇÇ) = œÄ</pre>
      </div>
      <p>
        But n‚ÇÅd‚ÇÅ+n‚ÇÇd‚ÇÇ = a+a = 2a, so:
      </p>
      <div class="eq" id="eq_wB2">
        <button class="copyBtn" data-copy="omega_B = (pi c)/(2 a)">Copy</button>
        <pre>œâ_B = (œÄ c)/(2a)</pre>
      </div>
      <p>
        Define the dimensionless frequency:
      </p>
      <div class="eq" id="eq_x">
        <button class="copyBtn" data-copy="x = omega/omega_B">Copy</button>
        <pre>x ‚â° œâ/œâ_B</pre>
      </div>
      <p>
        Then œâa/c = (œâ/œâ_B)(œâ_B a/c) = x¬∑(œÄ/2), giving:
      </p>
      <div class="eq" id="eq_delta_norm">
        <button class="copyBtn" data-copy="delta1 = (pi/2) x cos(theta1),   delta2 = (pi/2) x cos(theta2)">Copy</button>
        <pre>Œ¥‚ÇÅ = (œÄ/2) x cosŒ∏‚ÇÅ,
Œ¥‚ÇÇ = (œÄ/2) x cosŒ∏‚ÇÇ</pre>
      </div>

      <h3>Step 6 ‚Äî Projected dispersion + air light line</h3>
      <p>
        To build the projected diagram, we sweep (x, k‚Çì) and compute whether TE/TM are in a pass band or gap.
        The air light line is:
      </p>
      <div class="eq" id="eq_lightline">
        <button class="copyBtn" data-copy="Air light line: omega = c |kx|  (equivalently |kx| = omega/c)">Copy</button>
        <pre>Air light line:  œâ = c |k‚Çì|</pre>
      </div>

      <p>
        In the visualization we use a dimensionless horizontal axis
        <span class="pill">u ‚â° k‚Çì / (œÄ/Œõ)</span>, so u=1 corresponds to k‚Çì=œÄ/Œõ.
        The plots compute Œõ from the constraints:
      </p>
      <div class="eq" id="eq_Lambda">
        <button class="copyBtn" data-copy="Lambda = d1 + d2 = a/n1 + a/n2 = a(1/n1 + 1/n2), with n2=2 n1 => Lambda = (3a)/(2 n1)">Copy</button>
        <pre>Œõ = d‚ÇÅ + d‚ÇÇ = a/n‚ÇÅ + a/n‚ÇÇ = a(1/n‚ÇÅ + 1/n‚ÇÇ)
With n‚ÇÇ = 2n‚ÇÅ ‚Üí Œõ = (3a)/(2n‚ÇÅ)</pre>
      </div>

      <h3>Step 7 ‚Äî Omnidirectional reflection band</h3>
      <p>
        <b>Definition used here:</b> the stack is omnidirectionally reflecting (in air) over frequencies where, for every
        k‚Çì inside the air light cone (|k‚Çì|‚â§œâ/c), <b>both TE and TM</b> satisfy the stop-band condition:
        <span class="pill">|cos(KŒõ)| &gt; 1</span>.
      </p>

      <div class="callout">
        <h4>Final Answer (updates with the interactive plots)</h4>
        <div class="body">
          <p id="finalAnswerP" style="margin:8px 0 10px; color: var(--ink);">
            Omnidirectional reflection band (in air): <b id="finalAnswerText">computing‚Ä¶</b>
          </p>
          <div class="eq" id="eq_final">
            <button class="copyBtn" id="copyFinal" data-copy="">Copy final answer</button>
            <pre id="finalAnswerPre">computing‚Ä¶</pre>
          </div>
          <p style="margin-top:10px; color:var(--faint)">
            Note: the <b>upper edge</b> of the first stop band for this index ratio (n‚ÇÇ/n‚ÇÅ=2) is close to <b>œâ/œâ<sub>B</sub> ‚âà 1.216</b> even at normal incidence; the <b>lower</b> omnidirectional edge is controlled by oblique-angle TM behavior and depends on the absolute index level (Snell mapping).
          </p>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><b>Dimensions:</b> Œ¥‚±º is dimensionless (phase), œâ/œâ<sub>B</sub> is dimensionless, K has units rad/m.</li>
        <li><b>Limiting case (normal incidence):</b> Œ∏‚ÇÄ=0 ‚Üí Œ∏‚ÇÅ=Œ∏‚ÇÇ=0; TE and TM coincide, and the gap reduces to the standard Bragg-mirror stop band.</li>
        <li><b>Physical interpretation:</b> In the omnidirectional band, any plane wave from air cannot couple to a propagating Bloch mode ‚Üí energy decays in the crystal ‚Üí strong reflection for a finite stack.</li>
      </ul>

      <p>
        Connect to the plots: the <b>projected dispersion heatmap</b> shows where propagation is allowed (pass bands) or forbidden (gaps) as a function of (œâ, k‚Çì).
        The <b>secondary plot</b> shows, for each œâ, the fraction of air angles that lie in a gap for TE and for TM; omnidirectional reflection requires both fractions to reach 1 simultaneously.
      </p>
    </section>

    <section id="deeper">
      <h2>PART 4 ‚Äî Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the formula</h3>
      <p>
        The key object is the one-period trace encoded in:
        <span class="pill">cos(KŒõ)=cosŒ¥‚ÇÅcosŒ¥‚ÇÇ ‚àí ¬Ω(p+1/p)sinŒ¥‚ÇÅsinŒ¥‚ÇÇ</span>.
        The phases Œ¥‚±º set the <b>interference condition</b> (Bragg-like), while the factor (p+1/p)/2 measures
        the <b>impedance mismatch strength</b> between layers (larger mismatch ‚Üí stronger gaps).
      </p>

      <h3>How changing parameters affects the outcome</h3>
      <ul>
        <li><b>Increasing n‚ÇÅ (keeping n‚ÇÇ=2n‚ÇÅ):</b> ‚Äúgrazing in air‚Äù maps to less extreme angles inside the layers (Snell), which tends to preserve the TM gap better ‚Üí the <b>lower omnidirectional edge moves downward</b> (wider ODR band).</li>
        <li><b>Changing optical thickness ratio (not allowed here):</b> would shift œâ<sub>B</sub> and reshape the band structure (gap position and width).</li>
        <li><b>Polarization:</b> TM is typically the ‚Äúweak link‚Äù at large angles; if TM loses the gap anywhere in the air cone, omnidirectionality is lost even if TE stays gapped.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        Instead of transfer matrices, one can derive the same Bloch condition from continuity conditions and Floquet theory,
        or compute the band structure by solving the Helmholtz equation in each layer and enforcing periodic boundary conditions.
        Transfer matrices are favored because they provide a compact trace formula and handle oblique TE/TM cleanly.
      </p>

      <h3>Concept-check Q&A (with answers)</h3>
      <ul>
        <li><b>Q:</b> Why do we draw the air light line on œâ‚Äìk‚Çì plots? <br/><b>A:</b> It marks the set of (œâ,k‚Çì) that correspond to real incidence angles from air (|k‚Çì|‚â§œâ/c). Outside it, fields are evanescent in air.</li>
        <li><b>Q:</b> What does |cos(KŒõ)|&gt;1 mean physically? <br/><b>A:</b> K becomes complex, so Bloch waves decay exponentially‚Äîno power-carrying propagation in the periodic stack.</li>
        <li><b>Q:</b> Why can TE and TM differ at oblique angles? <br/><b>A:</b> Their boundary conditions lead to different effective wave impedances (admittances), changing p and therefore the band edges.</li>
        <li><b>Q:</b> If the stack has a stop band at normal incidence, is it automatically omnidirectional? <br/><b>A:</b> No. Oblique TM waves can close the gap; omnidirectional requires the gap across the full air cone for both polarizations.</li>
      </ul>
    </section>

    <section id="vizguide">
      <h2>PART 5 ‚Äî Visualization Guide (How to Read the Plots)</h2>

      <div class="vizWrap">
        <div class="canvasCard">
          <div class="canvasHeader">
            <div>
              <div class="t">Diagram ‚Äî Bilayer unit cell and incidence geometry</div>
              <div class="smallHint">Shows one period Œõ = d‚ÇÅ + d‚ÇÇ, with n‚ÇÅ,d‚ÇÅ and n‚ÇÇ,d‚ÇÇ, and the incident wave from air at angle Œ∏‚ÇÄ (with conserved k‚Çì).</div>
            </div>
            <div class="meta" id="metaDiagram">n‚ÇÅ=1.50, n‚ÇÇ=3.00</div>
          </div>
          <canvas id="cDiagram"></canvas>
        </div>

        <div class="canvasCard">
          <div class="canvasHeader">
            <div>
              <div class="t">Main plot ‚Äî Projected dispersion (œâ/œâ<sub>B</sub> vs k‚Çì/(œÄ/Œõ)) + air light line</div>
              <div class="smallHint">
                Bright regions: propagating Bloch modes (pass bands). Dark regions: band gaps (evanescent).
                The display mode can show TE only, TM only, or the stricter ‚ÄúTE and TM both gapped‚Äù region.
              </div>
            </div>
            <div class="meta" id="metaMain">Mode: both</div>
          </div>
          <canvas id="cMain"></canvas>
        </div>

        <div class="canvasCard">
          <div class="canvasHeader">
            <div>
              <div class="t">Secondary plot ‚Äî ‚ÄúGap coverage‚Äù vs frequency (angle sweep inside air cone)</div>
              <div class="smallHint">
                For each œâ/œâ<sub>B</sub>, we sweep all air angles (all k‚Çì within the cone) and compute the fraction that lies in a stop band for TE and for TM.
                Omnidirectional reflection requires both curves to hit 1 simultaneously over a band.
              </div>
            </div>
            <div class="meta" id="metaSecondary">computed live</div>
          </div>
          <canvas id="cSecondary"></canvas>
        </div>
      </div>

      <h3>Interactive controls (what changes and why)</h3>
      <ul>
        <li><b>n‚ÇÅ slider:</b> changes absolute indices while keeping n‚ÇÇ=2n‚ÇÅ and n‚ÇÅd‚ÇÅ=n‚ÇÇd‚ÇÇ. This changes Snell mapping (Œ∏‚ÇÄ ‚Üí Œ∏‚±º), which strongly affects the <b>lower omnidirectional edge</b> (TM at oblique angles).</li>
        <li><b>Main plot view:</b> choose TE, TM, or ‚Äúboth‚Äù. Omnidirectional reflection corresponds to the ‚Äúboth‚Äù gap region under the air light line.</li>
        <li><b>Resolution:</b> increases/decreases grid sampling for the heatmap (quality vs speed).</li>
      </ul>
    </section>
  </article>
</main>

<footer>
  Built as a self-contained learning article with interactive canvases (vanilla JS). All numeric bands shown are computed from the Bloch trace criterion for an ideal, lossless infinite periodic stack.
</footer>

<script>
(function(){
  // ---------------------------
  // Smooth scroll for TOC links
  // ---------------------------
  document.querySelectorAll('[data-scroll]').forEach(a=>{
    a.addEventListener('click', (e)=>{
      e.preventDefault();
      const id = a.getAttribute('href');
      const el = document.querySelector(id);
      if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
    });
  });

  // ---------------------------
  // Copy buttons
  // ---------------------------
  function copyText(txt){
    if(!txt) return;
    if(navigator.clipboard && navigator.clipboard.writeText){
      navigator.clipboard.writeText(txt).catch(()=>fallbackCopy(txt));
    } else {
      fallbackCopy(txt);
    }
  }
  function fallbackCopy(txt){
    const ta = document.createElement('textarea');
    ta.value = txt;
    ta.style.position='fixed';
    ta.style.left='-9999px';
    ta.style.top='-9999px';
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    try{ document.execCommand('copy'); }catch(err){}
    document.body.removeChild(ta);
  }
  document.querySelectorAll('.copyBtn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const txt = btn.getAttribute('data-copy') || '';
      copyText(txt);
      const old = btn.textContent;
      btn.textContent = 'Copied!';
      setTimeout(()=>btn.textContent = old, 850);
    });
  });

  // ---------------------------
  // Math helpers for the model
  // ---------------------------
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  function safeSqrt(x){ return x<=0 ? 0 : Math.sqrt(x); }

  // Given: n2 = 2 n1, and n1 d1 = n2 d2 = a.
  // Choose 'a' arbitrary; it cancels in normalized formulas.
  // Define x = omega/omegaB, with omegaB = pi c /(2a).
  // Then delta1 = (pi/2) x cos(theta1), delta2=(pi/2) x cos(theta2).
  // Use projected axis u = kx/(pi/Lambda). Here Lambda = a(1/n1 + 1/n2) = (3a)/(2n1).
  // We compute sin(theta0) from (x,u) as:
  // kx/k0 = sin(theta0) = (2u)/(x * (Lambda/a)), where (Lambda/a) = 1/n1 + 1/n2.
  function lambdaOverA(n1){
    const n2 = 2*n1;
    return (1/n1 + 1/n2);
  }

  function sinTheta0_from_xu(x,u,n1){
    const La = lambdaOverA(n1);
    // ratio = kx/k0
    return (2*u)/(x*La);
  }

  function cosTheta_inLayer(sinT0, n){
    const s = sinT0 / n;
    if(Math.abs(s) >= 1) return 0;
    return Math.sqrt(1 - s*s);
  }

  function cosBloch(x,u,n1, pol){ // returns cos(KŒõ) for TE or TM, or null if outside air cone
    const n2 = 2*n1;
    if(x <= 0) return null;
    const sinT0 = sinTheta0_from_xu(x,u,n1);
    if(Math.abs(sinT0) > 1) return null; // outside air light cone (no propagating incidence from air)
    const c1 = cosTheta_inLayer(sinT0, n1);
    const c2 = cosTheta_inLayer(sinT0, n2);

    const d1 = 0.5*Math.PI * x * c1; // (pi/2) x cos(theta1)
    const d2 = 0.5*Math.PI * x * c2;

    // Admittance ratio p = Y2/Y1
    let p;
    if(pol === 'te'){
      // Y ~ n cos(theta)
      // avoid divide by zero
      const denom = n1*c1;
      p = (denom===0) ? 1e9 : (n2*c2)/(denom);
    } else {
      // TM: Y ~ n / cos(theta)
      const denom = n1/(c1 || 1e-12);
      p = (n2/(c2 || 1e-12)) / denom;
    }
    // cos(KŒõ)
    const cosKL = Math.cos(d1)*Math.cos(d2) - 0.5*(p + 1/p)*Math.sin(d1)*Math.sin(d2);
    return cosKL;
  }

  function isGap(x,u,n1, pol){
    const v = cosBloch(x,u,n1,pol);
    if(v === null) return null;
    return Math.abs(v) > 1;
  }

  // Omnidirectional band: for each x, check all u in air cone: |sinT0|<=1 => |u| <= x*(Lambda/a)/2
  // And require TE gap and TM gap at all those u.
  function computeOmniBand(n1){
    const La = lambdaOverA(n1);
    const xs = [];
    const xMin = 0.55, xMax = 1.55, N = 800; // focus around 1st band
    for(let i=0;i<N;i++){
      xs.push(xMin + (xMax-xMin)*i/(N-1));
    }
    const uSamples = 180;

    const ok = xs.map(x=>{
      const umax = x*La/2;
      for(let j=0;j<uSamples;j++){
        const u = umax * j/(uSamples-1);
        const gTE = isGap(x,u,n1,'te');
        const gTM = isGap(x,u,n1,'tm');
        // if null should not happen for u in [0,umax] but keep safe
        if(gTE === null || gTM === null) return false;
        if(!(gTE && gTM)) return false;
      }
      return true;
    });

    // Find contiguous segments of ok==true, pick one closest to x=1
    let segments = [];
    let inSeg = false, s = 0;
    for(let i=0;i<ok.length;i++){
      if(ok[i] && !inSeg){ inSeg=true; s=i; }
      if((!ok[i] || i===ok.length-1) && inSeg){
        let e = ok[i] ? i : i-1;
        inSeg=false;
        segments.push([s,e]);
      }
    }
    if(segments.length===0) return null;

    // choose segment that contains x=1 if possible, else nearest
    let best = segments[0], bestDist = 1e9;
    for(const seg of segments){
      const xS = xs[seg[0]], xE = xs[seg[1]];
      let dist = 0;
      if(1 < xS) dist = xS - 1;
      else if(1 > xE) dist = 1 - xE;
      else dist = 0;
      if(dist < bestDist){ bestDist = dist; best = seg; }
    }
    return {x1: xs[best[0]], x2: xs[best[1]]};
  }

  // Gap coverage curves: for each x, what fraction of air cone is in gap for TE/TM?
  function gapCoverageCurves(n1){
    const La = lambdaOverA(n1);
    const xMin = 0.60, xMax = 1.50, Nx = 250;
    const uSamples = 220;
    let xs = new Array(Nx);
    let fTE = new Array(Nx);
    let fTM = new Array(Nx);

    for(let i=0;i<Nx;i++){
      const x = xMin + (xMax-xMin)*i/(Nx-1);
      xs[i]=x;
      const umax = x*La/2;
      let count=0, gapTE=0, gapTM=0;
      for(let j=0;j<uSamples;j++){
        const u = umax * j/(uSamples-1);
        const gTE = isGap(x,u,n1,'te');
        const gTM = isGap(x,u,n1,'tm');
        if(gTE===null || gTM===null) continue;
        count++;
        if(gTE) gapTE++;
        if(gTM) gapTM++;
      }
      fTE[i] = count? gapTE/count : 0;
      fTM[i] = count? gapTM/count : 0;
    }
    return {xs, fTE, fTM};
  }

  // ---------------------------
  // Canvas utilities (HiDPI + resize)
  // ---------------------------
  function setupCanvas(canvas){
    const ctx = canvas.getContext('2d');
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width * dpr));
      const h = Math.max(1, Math.floor(rect.height * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {w: rect.width, h: rect.height, dpr};
    }
    return {ctx, resize};
  }

  function drawAxes(ctx, x0,y0,w,h, xMin,xMax,yMin,yMax, xLabel,yLabel, title){
    // background
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.10)';
    ctx.fillRect(x0,y0,w,h);

    // title
    ctx.fillStyle = 'rgba(233,238,247,0.92)';
    ctx.font = '600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(title, x0+10, y0+20);

    // plot area margins
    const m = {l:56, r:18, t:34, b:42};
    const px0 = x0 + m.l, py0 = y0 + m.t;
    const pw = w - m.l - m.r, ph = h - m.t - m.b;

    // grid + ticks
    const gridN = 6;
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 1;

    function xToPx(x){ return px0 + (x - xMin) * pw / (xMax - xMin); }
    function yToPx(y){ return py0 + ph - (y - yMin) * ph / (yMax - yMin); }

    for(let i=0;i<=gridN;i++){
      const tx = xMin + (xMax-xMin)*i/gridN;
      const x = xToPx(tx);
      ctx.beginPath(); ctx.moveTo(x, py0); ctx.lineTo(x, py0+ph); ctx.stroke();
    }
    for(let i=0;i<=gridN;i++){
      const ty = yMin + (yMax-yMin)*i/gridN;
      const y = yToPx(ty);
      ctx.beginPath(); ctx.moveTo(px0, y); ctx.lineTo(px0+pw, y); ctx.stroke();
    }

    // axes frame
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1.2;
    ctx.strokeRect(px0,py0,pw,ph);

    // tick labels
    ctx.fillStyle = 'rgba(183,195,217,0.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    for(let i=0;i<=gridN;i++){
      const tx = xMin + (xMax-xMin)*i/gridN;
      const x = xToPx(tx);
      ctx.fillText(tx.toFixed(2), x-14, py0+ph+18);
    }
    for(let i=0;i<=gridN;i++){
      const ty = yMin + (yMax-yMin)*i/gridN;
      const y = yToPx(ty);
      ctx.fillText(ty.toFixed(2), px0-48, y+4);
    }

    // axis labels
    ctx.fillStyle = 'rgba(233,238,247,0.92)';
    ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(xLabel, px0 + pw/2 - ctx.measureText(xLabel).width/2, py0+ph+36);

    ctx.save();
    ctx.translate(x0+16, py0 + ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
    ctx.restore();

    ctx.restore();
    return {m, px0, py0, pw, ph, xToPx, yToPx};
  }

  function drawLegend(ctx, x,y, items){
    ctx.save();
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    const pad=10, lineH=16;
    let w=0;
    items.forEach(it=>{ w = Math.max(w, ctx.measureText(it.label).width + 40); });
    const h = pad*2 + items.length*lineH;
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.strokeStyle = 'rgba(255,255,255,0.16)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    roundRect(ctx, x, y, w+pad*2, h, 12);
    ctx.fill(); ctx.stroke();

    items.forEach((it,i)=>{
      const yy = y + pad + i*lineH + 12;
      ctx.strokeStyle = it.stroke;
      ctx.lineWidth = it.width || 2;
      ctx.beginPath();
      ctx.moveTo(x+pad, yy-4);
      ctx.lineTo(x+pad+22, yy-4);
      ctx.stroke();
      if(it.dash){
        ctx.setLineDash(it.dash);
      } else ctx.setLineDash([]);
      ctx.setLineDash([]);
      ctx.fillStyle = 'rgba(233,238,247,0.92)';
      ctx.fillText(it.label, x+pad+30, yy);
    });
    ctx.restore();
  }

  function roundRect(ctx,x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  // ---------------------------
  // Draw diagram canvas
  // ---------------------------
  function drawDiagram(ctx, W, H, n1){
    const n2 = 2*n1;
    ctx.clearRect(0,0,W,H);

    // background
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.fillRect(0,0,W,H);

    // layout
    const pad = 18;
    const x0 = pad, y0 = pad, w = W - 2*pad, h = H - 2*pad;
    const midY = y0 + h*0.52;

    // draw air region + stack block
    const stackX = x0 + w*0.30;
    const stackW = w*0.62;
    const stackY = y0 + h*0.18;
    const stackH = h*0.66;

    // Air left
    ctx.fillStyle = 'rgba(102,217,255,0.06)';
    ctx.fillRect(x0, stackY, stackX-x0, stackH);
    ctx.strokeStyle = 'rgba(255,255,255,0.14)';
    ctx.strokeRect(x0, stackY, stackX-x0, stackH);

    // Stack
    ctx.fillStyle = 'rgba(167,139,250,0.06)';
    ctx.fillRect(stackX, stackY, stackW, stackH);
    ctx.strokeStyle = 'rgba(255,255,255,0.14)';
    ctx.strokeRect(stackX, stackY, stackW, stackH);

    // Draw a few periods with two colors
    const periods = 6;
    const cellW = stackW/periods;
    for(let i=0;i<periods;i++){
      const x = stackX + i*cellW;
      // d1 region (n1)
      ctx.fillStyle = 'rgba(52,211,153,0.10)';
      ctx.fillRect(x, stackY, cellW*0.62, stackH);
      // d2 region (n2)
      ctx.fillStyle = 'rgba(251,191,36,0.10)';
      ctx.fillRect(x+cellW*0.62, stackY, cellW*0.38, stackH);

      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.beginPath();
      ctx.moveTo(x, stackY);
      ctx.lineTo(x, stackY+stackH);
      ctx.stroke();
    }

    // Labels
    ctx.fillStyle = 'rgba(233,238,247,0.92)';
    ctx.font = '600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Air (n‚ÇÄ = 1)', x0+10, stackY-8);
    ctx.fillText('Periodic bilayer stack (1D photonic crystal)', stackX+10, stackY-8);

    // Draw one unit cell bracket for Œõ
    const ux = stackX + cellW*1.2;
    const uy = stackY + stackH + 18;
    const uW = cellW;
    ctx.strokeStyle = 'rgba(233,238,247,0.75)';
    ctx.lineWidth = 1.4;
    ctx.beginPath();
    ctx.moveTo(ux, uy);
    ctx.lineTo(ux, uy+10);
    ctx.moveTo(ux, uy+10);
    ctx.lineTo(ux+uW, uy+10);
    ctx.moveTo(ux+uW, uy+10);
    ctx.lineTo(ux+uW, uy);
    ctx.stroke();
    ctx.fillStyle = 'rgba(183,195,217,0.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    ctx.fillText('Œõ = d‚ÇÅ + d‚ÇÇ', ux + 6, uy+28);

    // d1 and d2 arrows in the bracket cell
    const d1W = uW*0.62, d2W = uW*0.38;
    const ay = uy - 22;
    // d1 arrow
    arrow(ctx, ux, ay, ux+d1W, ay, 'rgba(52,211,153,0.95)');
    ctx.fillStyle = 'rgba(52,211,153,0.95)';
    ctx.fillText('d‚ÇÅ', ux + d1W/2 - 9, ay-6);
    // d2 arrow
    arrow(ctx, ux+d1W, ay, ux+uW, ay, 'rgba(251,191,36,0.95)');
    ctx.fillStyle = 'rgba(251,191,36,0.95)';
    ctx.fillText('d‚ÇÇ', ux + d1W + d2W/2 - 9, ay-6);

    // Incidence ray
    const rayX0 = x0 + w*0.10;
    const rayY0 = midY + h*0.22;
    const rayX1 = stackX - 6;
    const rayY1 = midY;
    arrow(ctx, rayX0, rayY0, rayX1, rayY1, 'rgba(102,217,255,0.95)');

    // normal line at interface
    ctx.strokeStyle = 'rgba(233,238,247,0.35)';
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(stackX, stackY);
    ctx.lineTo(stackX, stackY+stackH);
    ctx.stroke();
    ctx.setLineDash([]);

    // theta0 arc
    const cx = stackX, cy = midY;
    const r = 42;
    ctx.strokeStyle = 'rgba(102,217,255,0.75)';
    ctx.lineWidth = 1.3;
    ctx.beginPath();
    ctx.arc(cx, cy, r, Math.PI/2, Math.atan2(rayY1-rayY0, rayX1-rayX0), true);
    ctx.stroke();
    ctx.fillStyle = 'rgba(102,217,255,0.95)';
    ctx.fillText('Œ∏‚ÇÄ', cx - 20, cy + 48);

    // kx arrow along interface
    arrow(ctx, stackX-60, midY+60, stackX+60, midY+60, 'rgba(233,238,247,0.75)');
    ctx.fillStyle = 'rgba(233,238,247,0.85)';
    ctx.fillText('k‚Çì conserved', stackX-30, midY+82);

    // parameter text
    ctx.fillStyle = 'rgba(183,195,217,0.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    ctx.fillText(`n‚ÇÅ = ${n1.toFixed(2)} ,  n‚ÇÇ = ${n2.toFixed(2)} (given n‚ÇÇ=2n‚ÇÅ)`, x0+10, stackY+18);
    ctx.fillText(`Constraint: n‚ÇÅ d‚ÇÅ = n‚ÇÇ d‚ÇÇ (equal optical thickness)`, x0+10, stackY+36);
  }

  function arrow(ctx, x0,y0,x1,y1, stroke){
    const dx = x1-x0, dy = y1-y0;
    const L = Math.hypot(dx,dy) || 1;
    const ux = dx/L, uy = dy/L;
    const head = 10;
    const hx = x1 - ux*head, hy = y1 - uy*head;
    ctx.save();
    ctx.strokeStyle = stroke;
    ctx.fillStyle = stroke;
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(x1,y1);
    ctx.stroke();
    // head triangle
    const px = -uy, py = ux;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(hx + px*5, hy + py*5);
    ctx.lineTo(hx - px*5, hy - py*5);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // ---------------------------
  // Draw main projected dispersion heatmap
  // ---------------------------
  function drawMain(ctx, W, H, n1, viewMode, gridN){
    // axis ranges
    const xMin = 0.60, xMax = 1.50; // omega/omegaB
    const uMin = 0.00, uMax = 1.00; // kx/(pi/Lambda), show positive side; symmetry implied

    const ax = drawAxes(
      ctx, 0,0,W,H,
      uMin,uMax,xMin,xMax,
      'u = k‚Çì / (œÄ/Œõ)  (dimensionless)',
      'x = œâ / œâ_B  (dimensionless)',
      'Projected dispersion (computed from |cos(KŒõ)|)'
    );

    const {px0,py0,pw,ph, xToPx, yToPx} = ax;

    // heatmap grid
    const Nx = gridN;
    const Ny = Math.round(gridN*0.92);
    const img = ctx.createImageData(Nx, Ny);
    const data = img.data;

    const La = lambdaOverA(n1);

    // color mapping:
    // bright => pass band; dark => gap; outside air cone => transparent/very dark
    for(let j=0;j<Ny;j++){
      const x = xMax - (xMax-xMin) * j/(Ny-1);
      const umaxCone = x*La/2; // in u-units
      for(let i=0;i<Nx;i++){
        const u = uMin + (uMax-uMin) * i/(Nx-1);
        const idx = (j*Nx + i)*4;

        let inside = (u <= umaxCone + 1e-9);
        if(!inside){
          data[idx+0]=5; data[idx+1]=8; data[idx+2]=14; data[idx+3]=220;
          continue;
        }

        let val;
        if(viewMode === 'te'){
          const g = isGap(x,u,n1,'te');
          val = g ? 0.12 : 0.92;
        } else if(viewMode === 'tm'){
          const g = isGap(x,u,n1,'tm');
          val = g ? 0.12 : 0.92;
        } else { // both (ODR criterion)
          const gTE = isGap(x,u,n1,'te');
          const gTM = isGap(x,u,n1,'tm');
          const bothGap = (gTE && gTM);
          val = bothGap ? 0.12 : 0.92;
        }

        // slight emphasis near transitions by checking |cos|-1 margin (optional)
        // We'll keep clean.
        const base = val;
        const r = Math.floor(20 + 200*base);
        const g = Math.floor(25 + 190*base);
        const b = Math.floor(40 + 170*base);

        data[idx+0]=r;
        data[idx+1]=g;
        data[idx+2]=b;
        data[idx+3]=255;
      }
    }

    // draw image into plot area
    // map image to plot rectangle
    const tmp = document.createElement('canvas');
    tmp.width = Nx; tmp.height = Ny;
    tmp.getContext('2d').putImageData(img,0,0);

    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(tmp, px0, py0, pw, ph);
    ctx.restore();

    // Draw air light line boundary in u-x coordinates:
    // air cone boundary corresponds to sin(theta0)=1 => |kx|=k0 => in u terms: u = x*(Lambda/a)/2 = x*La/2
    // so x = 2u/La.
    ctx.save();
    ctx.strokeStyle = 'rgba(102,217,255,0.9)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    let first = true;
    const steps=220;
    for(let s=0;s<=steps;s++){
      const u = uMin + (uMax-uMin)*s/steps;
      const x = (2*u)/La;
      if(x < xMin || x > xMax) continue;
      const X = xToPx(u);
      const Y = yToPx(x);
      if(first){ ctx.moveTo(X,Y); first=false; }
      else ctx.lineTo(X,Y);
    }
    ctx.stroke();

    // label
    ctx.fillStyle='rgba(102,217,255,0.95)';
    ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    ctx.fillText('air light line (|k‚Çì|=œâ/c)', px0 + 10, py0 + 18);

    // legend
    let labelMode = (viewMode==='both') ? 'Gap if TE & TM both gapped' : (viewMode==='te'?'TE view':'TM view');
    drawLegend(ctx, px0+pw-240, py0+10, [
      {label:'Pass band (propagating Bloch)', stroke:'rgba(240,246,255,0.85)', width:6},
      {label:'Band gap (evanescent)', stroke:'rgba(30,40,60,0.95)', width:6},
      {label: labelMode, stroke:'rgba(102,217,255,0.95)', width:2}
    ]);

    ctx.restore();
  }

  // ---------------------------
  // Draw secondary plot (gap coverage)
  // ---------------------------
  function drawSecondary(ctx, W, H, n1){
    const xMin = 0.60, xMax = 1.50;
    const yMin = 0.00, yMax = 1.00;

    const ax = drawAxes(
      ctx, 0,0,W,H,
      xMin,xMax,yMin,yMax,
      'x = œâ / œâ_B',
      'gap coverage fraction (0‚Ä¶1)',
      'Angle sweep: fraction of air cone in the band gap'
    );

    const {px0,py0,pw,ph, xToPx, yToPx} = ax;

    const curves = gapCoverageCurves(n1);
    const xs = curves.xs, fTE = curves.fTE, fTM = curves.fTM;

    function drawCurve(arr, stroke){
      ctx.save();
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      for(let i=0;i<xs.length;i++){
        const X = xToPx(xs[i]);
        const Y = yToPx(arr[i]);
        if(i===0) ctx.moveTo(X,Y);
        else ctx.lineTo(X,Y);
      }
      ctx.stroke();
      ctx.restore();
    }

    // curves
    drawCurve(fTE, 'rgba(52,211,153,0.95)'); // TE
    drawCurve(fTM, 'rgba(251,191,36,0.95)'); // TM

    // highlight omni band if exists
    const band = computeOmniBand(n1);
    if(band){
      const x1=band.x1, x2=band.x2;
      ctx.save();
      ctx.fillStyle='rgba(102,217,255,0.10)';
      const X1=xToPx(x1), X2=xToPx(x2);
      ctx.fillRect(X1, py0, X2-X1, ph);
      ctx.strokeStyle='rgba(102,217,255,0.65)';
      ctx.lineWidth=1.4;
      ctx.strokeRect(X1, py0, X2-X1, ph);
      ctx.fillStyle='rgba(102,217,255,0.95)';
      ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      ctx.fillText('ODR band', X1+6, py0+18);
      ctx.restore();
    }

    // legend
    drawLegend(ctx, px0+pw-220, py0+10, [
      {label:'TE gap coverage', stroke:'rgba(52,211,153,0.95)', width:2},
      {label:'TM gap coverage', stroke:'rgba(251,191,36,0.95)', width:2},
      {label:'ODR band (both=1)', stroke:'rgba(102,217,255,0.75)', width:2}
    ]);
  }

  // ---------------------------
  // UI + render loop
  // ---------------------------
  const elN1 = document.getElementById('n1');
  const elN1Read = document.getElementById('n1Read');
  const elN2Read = document.getElementById('n2Read');
  const elMode = document.getElementById('polView');
  const elRes = document.getElementById('gridRes');
  const elResRead = document.getElementById('resRead');

  const statusDot = document.getElementById('statusDot');
  const statusText = document.getElementById('statusText');

  const metaDiagram = document.getElementById('metaDiagram');
  const metaMain = document.getElementById('metaMain');
  const metaSecondary = document.getElementById('metaSecondary');

  const finalAnswerText = document.getElementById('finalAnswerText');
  const finalAnswerPre = document.getElementById('finalAnswerPre');
  const copyFinal = document.getElementById('copyFinal');
  const omniTextInline = document.getElementById('omniTextInline');

  const cDiagram = setupCanvas(document.getElementById('cDiagram'));
  const cMain = setupCanvas(document.getElementById('cMain'));
  const cSecondary = setupCanvas(document.getElementById('cSecondary'));

  const ro = new ResizeObserver(()=>render());
  ro.observe(document.getElementById('cDiagram'));
  ro.observe(document.getElementById('cMain'));
  ro.observe(document.getElementById('cSecondary'));

  function setBadge(state, text){
    statusText.textContent = text;
    statusDot.classList.remove('warn','bad');
    if(state==='good'){
      statusDot.classList.add(''); // green default
    } else if(state==='warn'){
      statusDot.classList.add('warn');
    } else {
      statusDot.classList.add('bad');
    }
  }

  function render(){
    const n1 = parseFloat(elN1.value);
    const n2 = 2*n1;
    const mode = elMode.value;
    const res = parseInt(elRes.value, 10);

    elN1Read.textContent = n1.toFixed(2);
    elN2Read.textContent = `n‚ÇÇ = ${n2.toFixed(2)}`;
    elResRead.textContent = `${res}√ó${Math.round(res*0.92)}`;

    metaDiagram.textContent = `n‚ÇÅ=${n1.toFixed(2)}, n‚ÇÇ=${n2.toFixed(2)}`;
    metaMain.textContent = `Mode: ${mode.toUpperCase()}`;
    metaSecondary.textContent = `n‚ÇÅ=${n1.toFixed(2)} (n‚ÇÇ=2n‚ÇÅ)`;

    // compute band
    setBadge('warn', 'Computing omnidirectional band‚Ä¶');
    const band = computeOmniBand(n1);

    // Update final answer text
    let answerPlain;
    if(!band){
      finalAnswerText.innerHTML = `<span style="color:var(--bad)">No omnidirectional band found (for this n‚ÇÅ range)</span>`;
      finalAnswerPre.textContent = `For n‚ÇÅ=${n1.toFixed(2)} (n‚ÇÇ=2n‚ÇÅ):\nNo omnidirectional reflection band detected in x=œâ/œâ_B ‚àà [0.55, 1.55].\n(TE and TM do not remain simultaneously gapped across the full air cone.)`;
      answerPlain = finalAnswerPre.textContent;
      copyFinal.setAttribute('data-copy', answerPlain);
      omniTextInline.innerHTML = `œâ/œâ<sub>B</sub>: none (for this n‚ÇÅ)`;
      setBadge('bad', 'No ODR band for current n‚ÇÅ (TM closes gap somewhere in air cone).');
    } else {
      const x1 = band.x1, x2 = band.x2;
      const bandStr = `œâ/œâ_B ‚àà [${x1.toFixed(3)}, ${x2.toFixed(3)}]`;
      finalAnswerText.innerHTML = `<span style="color:var(--good)">${bandStr}</span>`;
      finalAnswerPre.textContent =
`Omnidirectional reflection band (air, TE & TM):
${bandStr}

Meaning:
For every incidence angle in air (i.e., all |k_x| ‚â§ œâ/c), the bilayer stack has |cos(KŒõ)| > 1 for both TE and TM,
so Bloch waves are evanescent and the structure reflects (for a sufficiently many periods).`;

      answerPlain = finalAnswerPre.textContent;
      copyFinal.setAttribute('data-copy', answerPlain);
      omniTextInline.innerHTML = `œâ/œâ<sub>B</sub> ‚âà [${x1.toFixed(2)}, ${x2.toFixed(3)}]`;
      setBadge('good', `ODR band found: ${bandStr}`);
    }

    // Draw canvases
    const rD = cDiagram.resize();
    drawDiagram(cDiagram.ctx, rD.w, rD.h, n1);

    const rM = cMain.resize();
    drawMain(cMain.ctx, rM.w, rM.h, n1, mode, res);

    const rS = cSecondary.resize();
    drawSecondary(cSecondary.ctx, rS.w, rS.h, n1);
  }

  elN1.addEventListener('input', render);
  elMode.addEventListener('change', render);
  elRes.addEventListener('input', render);

  // initial render
  render();
})();
</script>
</body>
</html>
