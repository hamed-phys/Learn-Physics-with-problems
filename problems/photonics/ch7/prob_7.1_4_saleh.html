<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Multilayer Device in an Unmatched Medium — Amplitude Reflectance Composition</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101936;
      --panel2:#0f1730;
      --text:#e9eefc;
      --muted:#b8c2e6;
      --faint:#7f8ab7;
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.16);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 18px 45px rgba(0,0,0,.35);
      --radius:18px;
      --radius2:24px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    html,body{height:100%;}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 15% 10%, rgba(125,211,252,.16), transparent 55%),
        radial-gradient(900px 650px at 85% 25%, rgba(167,139,250,.12), transparent 60%),
        radial-gradient(1000px 800px at 50% 95%, rgba(52,211,153,.08), transparent 60%),
        linear-gradient(180deg, #070a14, var(--bg) 25%, #070a14);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none;}
    a:hover{text-decoration:underline;}
    header{
      position:relative;
      padding: clamp(18px, 2.5vw, 30px) clamp(16px, 4vw, 56px);
      border-bottom:1px solid var(--line);
      overflow:hidden;
    }
    header .kicker{
      color:var(--muted);
      letter-spacing:.10em;
      text-transform:uppercase;
      font-size:.80rem;
    }
    header h1{
      margin:.35rem 0 .6rem;
      font-size: clamp(1.35rem, 3vw, 2.2rem);
      line-height:1.15;
    }
    header p{
      margin:0;
      max-width: 78ch;
      color:var(--muted);
    }

    main{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 18px;
      padding: 18px clamp(12px, 3vw, 40px) 42px;
      max-width: 1240px;
      margin: 0 auto;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr;}
    }

    nav.toc{
      position: sticky;
      top: 14px;
      align-self: start;
      background: linear-gradient(180deg, rgba(16,25,54,.92), rgba(15,23,48,.88));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
      backdrop-filter: blur(10px);
    }
    nav.toc h2{
      font-size: .95rem;
      margin: 4px 0 10px;
      color: var(--text);
      letter-spacing:.02em;
    }
    nav.toc ol{
      margin: 0;
      padding-left: 18px;
      color: var(--muted);
      font-size:.95rem;
    }
    nav.toc li{margin: 8px 0;}
    nav.toc a{color: var(--muted);}
    nav.toc a:hover{color: var(--text);}

    .content{
      display:flex;
      flex-direction:column;
      gap: 16px;
      min-width: 0;
    }

    section{
      background: linear-gradient(180deg, rgba(16,25,54,.78), rgba(15,23,48,.72));
      border: 1px solid var(--line);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      padding: clamp(14px, 2.2vw, 22px);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    section h2{
      margin: 0 0 10px;
      font-size: 1.2rem;
      letter-spacing:.01em;
    }
    section h3{
      margin: 18px 0 8px;
      font-size: 1.05rem;
      color: var(--text);
    }
    p{margin: 8px 0;}
    ul{margin: 8px 0 8px 1.1rem;}
    li{margin: 6px 0;}
    .grid2{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      .grid2{grid-template-columns: 1fr;}
    }
    .callouts{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
      margin-top: 10px;
    }
    .card{
      grid-column: span 6;
      background: rgba(255,255,255,.04);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 12px 12px 10px;
    }
    @media (max-width: 760px){
      .card{grid-column: span 12;}
    }
    .card h4{
      margin: 0 0 6px;
      font-size: .98rem;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-size:.72rem;
      padding: 3px 8px;
      border-radius:999px;
      border:1px solid var(--line2);
      color: var(--muted);
      background: rgba(255,255,255,.03);
      letter-spacing:.04em;
      text-transform:uppercase;
    }
    .pill.good{border-color: rgba(52,211,153,.35); color: rgba(52,211,153,.95);}
    .pill.warn{border-color: rgba(251,191,36,.35); color: rgba(251,191,36,.95);}
    .pill.bad{border-color: rgba(251,113,133,.35); color: rgba(251,113,133,.95);}

    .eqbox{
      margin: 10px 0;
      padding: 12px 12px 10px;
      border-radius: var(--radius);
      border: 1px solid var(--line2);
      background: rgba(0,0,0,.22);
      overflow:auto;
    }
    .eqrow{
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
    }
    .eq{
      font-family: var(--mono);
      font-size: .95rem;
      white-space: pre-wrap;
      color: var(--text);
    }
    .copybtn{
      flex:0 0 auto;
      cursor:pointer;
      border:1px solid var(--line2);
      background: rgba(255,255,255,.05);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: .85rem;
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
      user-select:none;
    }
    .copybtn:hover{background: rgba(255,255,255,.08); border-color: rgba(125,211,252,.35);}
    .copybtn:active{transform: translateY(1px);}

    .vizWrap{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap: 12px;
      align-items: stretch;
      margin-top: 10px;
    }
    @media (max-width: 980px){
      .vizWrap{grid-template-columns: 1fr;}
    }
    figure{
      margin:0;
      border-radius: var(--radius2);
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      overflow:hidden;
    }
    figcaption{
      padding: 10px 12px;
      border-top: 1px solid var(--line);
      color: var(--muted);
      font-size: .92rem;
    }
    canvas{
      width: 100%;
      height: 340px;
      display:block;
    }
    .plot canvas{height: 320px;}
    .controls{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 10px;
      margin-top: 12px;
    }
    .ctrl{
      grid-column: span 6;
      background: rgba(0,0,0,.18);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 10px 10px 8px;
    }
    @media (max-width: 760px){
      .ctrl{grid-column: span 12;}
    }
    .ctrl label{
      display:flex;
      justify-content:space-between;
      gap: 12px;
      font-size: .92rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .ctrl .val{
      font-family: var(--mono);
      color: var(--text);
      font-size: .90rem;
      opacity:.95;
    }
    input[type="range"]{width:100%;}
    select, button.smallbtn{
      width:100%;
      padding: 9px 10px;
      border-radius: 12px;
      border: 1px solid var(--line2);
      background: rgba(255,255,255,.05);
      color: var(--text);
      font-size: .92rem;
      outline:none;
    }
    button.smallbtn{
      cursor:pointer;
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
    }
    button.smallbtn:hover{background: rgba(255,255,255,.08); border-color: rgba(167,139,250,.35);}
    button.smallbtn:active{transform: translateY(1px);}

    .note{
      color: var(--faint);
      font-size: .92rem;
    }

    .final{
      border: 1px solid rgba(52,211,153,.25);
      background: radial-gradient(900px 260px at 20% 0%, rgba(52,211,153,.16), transparent 60%),
                  rgba(0,0,0,.18);
    }
    .final h3{margin-top:0;}
    .twoCols{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 900px){
      .twoCols{grid-template-columns: 1fr;}
    }

    footer{
      padding: 18px clamp(12px, 4vw, 40px) 30px;
      color: var(--faint);
      text-align:center;
    }

    /* Print-friendly */
    @media print{
      body{background:#fff; color:#000;}
      header, section, nav.toc, figure{box-shadow:none; background:#fff; border-color:#ddd;}
      nav.toc{position:static;}
      a{color:#000; text-decoration:underline;}
      .copybtn, .controls{display:none !important;}
      canvas{display:none;}
    }

    /* Subtle entrance animation */
    @media (prefers-reduced-motion: no-preference){
      section{
        animation: fadeUp .45s ease both;
      }
      @keyframes fadeUp{
        from{opacity:0; transform: translateY(10px);}
        to{opacity:1; transform: translateY(0);}
      }
    }
  </style>
</head>
<body>
<header>
  <div class="kicker">Photonics / Thin-Film Optics</div>
  <h1>7.1-4 — Multilayer Device in an Unmatched Medium</h1>
  <p>
    We derive how a known multilayer reflectance (defined in a matched embedding medium) transforms when you place the same device
    in a <em>different</em> incident medium. The key idea is that the new entrance boundary and the multilayer act like two reflectors
    separated by (effectively) zero thickness, so their amplitude reflectances combine by a geometric multiple-reflection sum.
  </p>
</header>

<main>
  <nav class="toc" aria-label="Table of Contents">
    <h2>On this page</h2>
    <ol>
      <li><a href="#quick">Quick Summary</a></li>
      <li><a href="#part0">PART 0 — Concept Primer</a></li>
      <li><a href="#part1">PART 1 — Problem Analysis</a></li>
      <li><a href="#part2">PART 2 — Strategy & Tips</a></li>
      <li><a href="#part3">PART 3 — Full Solution</a></li>
      <li><a href="#part4">PART 4 — Deeper Understanding</a></li>
      <li><a href="#part5">PART 5 — Visualization Guide</a></li>
    </ol>
    <p class="note" style="margin:10px 0 0;">
      Tip: use the sliders in the visualization section to see how <span style="font-family:var(--mono);">r</span> changes with
      the entrance mismatch and the multilayer’s complex reflectance.
    </p>
  </nav>

  <div class="content">

    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><strong>What this is about:</strong> A multilayer device has a known complex amplitude reflectance <span style="font-family:var(--mono);">r_m</span> when the incident medium matches its front-layer index <span style="font-family:var(--mono);">n1</span>. What happens if the incident medium index becomes <span style="font-family:var(--mono);">n</span>?</li>
        <li><strong>Key physics idea:</strong> The new entrance boundary (between <span style="font-family:var(--mono);">n</span> and <span style="font-family:var(--mono);">n1</span>) and the “rest of the multilayer” behave like two reflectors with infinite multiple reflections between them (a geometric series).</li>
        <li><strong>Governing equations:</strong> Fresnel amplitude reflectance at normal incidence and multiple-reflection summation.</li>
        <li><strong>Main result (symbolic):</strong> <span style="font-family:var(--mono);">r = (r_b + r_m)/(1 + r_b r_m)</span>, where <span style="font-family:var(--mono);">r_b = (n - n1)/(n + n1)</span>.</li>
        <li><strong>Limiting cases:</strong> We evaluate <span style="font-family:var(--mono);">r</span> for <span style="font-family:var(--mono);">r_b=0</span>, <span style="font-family:var(--mono);">r_b=1</span>, <span style="font-family:var(--mono);">r_m=0</span>, <span style="font-family:var(--mono);">r_m=1</span> and interpret each physically.</li>
        <li><strong>What type of answer:</strong> Fully symbolic, with physical interpretation; plots use <em>example values</em> to build intuition.</li>
      </ul>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

      <div class="grid2">
        <article>
          <h3>Core definitions (symbols & meaning)</h3>
          <ul>
            <li><strong>Refractive index</strong> <span style="font-family:var(--mono);">n</span> (dimensionless): sets phase velocity and impedance in a dielectric (non-magnetic case assumed, <span style="font-family:var(--mono);">μ≈μ0</span>).</li>
            <li><strong>Complex amplitude reflectance</strong> <span style="font-family:var(--mono);">r</span> (dimensionless): ratio of reflected to incident <em>field amplitude</em> at a reference plane.
              It is complex because reflection can add a phase shift.</li>
            <li><strong>Power (intensity) reflectance</strong> <span style="font-family:var(--mono);">R = |r|^2</span> (dimensionless): fraction of incident power reflected (at normal incidence in lossless media).</li>
            <li><strong>Fresnel amplitude reflectance</strong> at a single interface (normal incidence):
              <span style="font-family:var(--mono);">r_12 = (n1 - n2)/(n1 + n2)</span> for a wave going from medium 1 to 2.</li>
          </ul>

          <h3>Physical meaning of key quantities</h3>
          <ul>
            <li><span style="font-family:var(--mono);">r_b</span>: reflection from the <em>new</em> entrance boundary between the external medium <span style="font-family:var(--mono);">n</span> and the device’s front layer <span style="font-family:var(--mono);">n1</span>.</li>
            <li><span style="font-family:var(--mono);">r_m</span>: “effective” reflection coefficient of the multilayer <em>as seen from inside medium</em> <span style="font-family:var(--mono);">n1</span>. It already includes all internal multiple reflections of the stack.</li>
            <li><span style="font-family:var(--mono);">r</span>: total reflection seen by an observer in the external medium <span style="font-family:var(--mono);">n</span> once the device is placed there.</li>
          </ul>
        </article>

        <article>
          <h3>Key laws/principles and validity</h3>
          <div class="callouts">
            <div class="card" style="grid-column:span 12;">
              <h4><span class="pill good">valid when</span> Fresnel + superposition</h4>
              <ul>
                <li>Linear optics (fields add).</li>
                <li>Single-frequency steady-state (monochromatic or narrowband) so complex amplitudes are meaningful.</li>
                <li>Plane-wave at <strong>normal incidence</strong> (the provided <span style="font-family:var(--mono);">r_b=(n-n1)/(n+n1)</span> is the normal-incidence Fresnel form).</li>
                <li>All reflections referenced at the same plane (or include phase factors if separated).</li>
              </ul>
            </div>
          </div>

          <h3>Common models/approximations (why we use them)</h3>
          <ul>
            <li><strong>“Effective reflector” model:</strong> A complex multilayer can be replaced by its net reflectance <span style="font-family:var(--mono);">r_m</span> as seen from the front layer. This collapses many layers into one complex number.</li>
            <li><strong>Geometric series for multiple reflections:</strong> Light can bounce between the entrance boundary and the multilayer. Each additional round trip contributes a factor like <span style="font-family:var(--mono);">(r_b r_m)</span> (up to transmission factors), creating a sum you can evaluate exactly.</li>
          </ul>

          <h3>Mini intuition examples (no long algebra)</h3>
          <ul>
            <li><strong>Matched entrance:</strong> If <span style="font-family:var(--mono);">n=n1</span>, then <span style="font-family:var(--mono);">r_b=0</span> and the outside world simply “sees” <span style="font-family:var(--mono);">r=r_m</span>.</li>
            <li><strong>Perfect mirror stack:</strong> If the multilayer behaves like a perfect mirror (<span style="font-family:var(--mono);">r_m≈1</span>), then adding an entrance boundary can’t make it reflect <em>less</em> than a mirror; you still get <span style="font-family:var(--mono);">r→1</span>.</li>
          </ul>

          <h3>What to watch for (pitfalls)</h3>
          <ul>
            <li>Confusing <strong>amplitude</strong> reflectance <span style="font-family:var(--mono);">r</span> with <strong>power</strong> reflectance <span style="font-family:var(--mono);">R=|r|^2</span>.</li>
            <li>Using the wrong Fresnel sign convention (make sure the wave direction matches your <span style="font-family:var(--mono);">r</span> formula).</li>
            <li>Forgetting that <span style="font-family:var(--mono);">r_m</span> is defined as seen from medium <span style="font-family:var(--mono);">n1</span>, not from <span style="font-family:var(--mono);">n</span>.</li>
            <li>If there were a physical gap or thickness between reflectors, extra phase factors would appear; here it’s “at the boundary,” so the composition is algebraic.</li>
          </ul>
        </article>
      </div>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>Rewriting the problem in plain words</h3>
      <p>
        A multilayer optical device has complex amplitude reflectance <span style="font-family:var(--mono);">r_m</span> when the surrounding
        medium matches its front layer refractive index <span style="font-family:var(--mono);">n1</span>. If we place the same device in a
        different medium of refractive index <span style="font-family:var(--mono);">n</span>, show that the new overall amplitude reflectance is
        <span style="font-family:var(--mono);">r = (r_b + r_m)/(1 + r_b r_m)</span>, where the boundary reflectance is
        <span style="font-family:var(--mono);">r_b = (n - n1)/(n + n1)</span>. Then evaluate <span style="font-family:var(--mono);">r</span> in several limiting cases.
      </p>

      <div class="callouts">
        <div class="card">
          <h4><span class="pill">given</span></h4>
          <ul>
            <li>Front-layer index <span style="font-family:var(--mono);">n1</span> (real, positive).</li>
            <li>External medium index <span style="font-family:var(--mono);">n</span> (real, positive).</li>
            <li>Known complex multilayer reflectance <span style="font-family:var(--mono);">r_m</span> when incident medium matches <span style="font-family:var(--mono);">n1</span>.</li>
            <li>Definition <span style="font-family:var(--mono);">r_b=(n-n1)/(n+n1)</span> for the new entrance boundary.</li>
          </ul>
        </div>
        <div class="card">
          <h4><span class="pill">unknowns</span></h4>
          <ul>
            <li>Total amplitude reflectance <span style="font-family:var(--mono);">r</span> seen from medium <span style="font-family:var(--mono);">n</span>.</li>
            <li>Limiting-case results for specified values of <span style="font-family:var(--mono);">r_b</span> and <span style="font-family:var(--mono);">r_m</span>.</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles and why they apply</h3>
      <ul>
        <li><strong>Fresnel reflection at a boundary:</strong> The new external medium introduces an additional interface reflection <span style="font-family:var(--mono);">r_b</span>. This is unavoidable because impedance changes at <span style="font-family:var(--mono);">n↔n1</span>.</li>
        <li><strong>Superposition + multiple reflections:</strong> The entrance boundary and the multilayer reflect light back and forth; total reflection is a coherent sum of infinitely many contributions (geometric series).</li>
        <li><strong>Why not full transfer matrices?</strong> You could re-derive everything with a 2×2 characteristic matrix, but the problem specifically gives <span style="font-family:var(--mono);">r_m</span> as an already-computed effective reflectance, so a simpler composition method is best.</li>
      </ul>

      <div class="callouts">
        <div class="card" style="grid-column:span 12;">
          <h4><span class="pill warn">assumptions</span></h4>
          <ul>
            <li>Normal incidence plane wave.</li>
            <li>Linear, time-harmonic fields (complex amplitudes valid).</li>
            <li>Reference plane is at the entrance boundary; no extra propagation phase between the boundary and the multilayer “effective reflector.”</li>
            <li>Indices are real for the limiting-case intuition (lossless); the algebraic formula for complex <span style="font-family:var(--mono);">r_m</span> still holds.</li>
          </ul>
        </div>
      </div>

      <h3>Possible approaches (compare)</h3>
      <ol>
        <li><strong>Geometric series of multiple reflections</strong> (best here): fast, transparent, uses <span style="font-family:var(--mono);">r_m</span> directly.</li>
        <li><strong>Scattering-matrix (S-parameter) composition</strong>: very clean conceptually; essentially the same as (1) but more formal.</li>
        <li><strong>Transfer matrix for the whole system</strong>: general and powerful (handles thickness/angles), but overkill since <span style="font-family:var(--mono);">r_m</span> is already known.</li>
      </ol>
      <p><strong>Chosen approach:</strong> multiple-reflection summation, because it directly expresses the new <span style="font-family:var(--mono);">r</span> in terms of the known <span style="font-family:var(--mono);">r_m</span> plus the added boundary <span style="font-family:var(--mono);">r_b</span>, and it makes limiting cases obvious.</p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>
      <ol>
        <li>
          <strong>Goal:</strong> Model the system as two reflectors: boundary (<span style="font-family:var(--mono);">r_b</span>) + multilayer (<span style="font-family:var(--mono);">r_m</span>).<br/>
          <strong>Tool:</strong> Effective reflectance concept.<br/>
          <strong>Meaning:</strong> Replace the complicated stack by a single complex number seen from medium <span style="font-family:var(--mono);">n1</span>.
        </li>
        <li>
          <strong>Goal:</strong> Write the first few reflected-field contributions at the entrance plane.<br/>
          <strong>Tool:</strong> Superposition and reflection/transmission factors.<br/>
          <strong>Meaning:</strong> Identify the repeating “round-trip” multiplier that generates a geometric series.
        </li>
        <li>
          <strong>Goal:</strong> Sum the infinite series to get a closed form for <span style="font-family:var(--mono);">r</span>.<br/>
          <strong>Tool:</strong> Geometric series sum <span style="font-family:var(--mono);">1 + x + x^2 + ... = 1/(1-x)</span> (when it converges).<br/>
          <strong>Meaning:</strong> Captures all multiple bounces between boundary and stack.
        </li>
        <li>
          <strong>Goal:</strong> Simplify to the required expression <span style="font-family:var(--mono);">r=(r_b+r_m)/(1+r_b r_m)</span>.<br/>
          <strong>Tool:</strong> Fresnel identities and symmetry for normal incidence.<br/>
          <strong>Meaning:</strong> Shows the “composition law” for reflectances.
        </li>
        <li>
          <strong>Goal:</strong> Test limiting cases and interpret physically.<br/>
          <strong>Tool:</strong> Plug in values, check plausibility (<span style="font-family:var(--mono);">|r|≤1</span> in lossless cases).<br/>
          <strong>Meaning:</strong> Confirms sign/phase and builds intuition.
        </li>
      </ol>

      <div class="callouts">
        <div class="card">
          <h4><span class="pill bad">common mistakes</span></h4>
          <ul>
            <li>Dropping transmission factors incorrectly when summing multiple reflections.</li>
            <li>Mixing up <span style="font-family:var(--mono);">r_b</span> with <span style="font-family:var(--mono);">r_m</span> (they are defined in different embedding media).</li>
            <li>Checking power limits using <span style="font-family:var(--mono);">r</span> instead of <span style="font-family:var(--mono);">R=|r|^2</span>.</li>
          </ul>
        </div>
        <div class="card">
          <h4><span class="pill good">quick tips</span></h4>
          <ul>
            <li>Write the first 2–3 terms explicitly; the repeating pattern becomes obvious.</li>
            <li>At normal incidence in non-magnetic media, transmission amplitudes satisfy a handy identity: <span style="font-family:var(--mono);">t_12 t_21 = 1 - r_12^2</span>.</li>
            <li>Use limiting cases (<span style="font-family:var(--mono);">r_b=0</span>, <span style="font-family:var(--mono);">r_m=0</span>) as “unit tests” for your algebra.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

      <h3>Physical intuition first (before math)</h3>
      <p>
        You already know how strongly the multilayer reflects <em>when it is illuminated from a medium that matches its first layer</em>:
        that is <span style="font-family:var(--mono);">r_m</span>. Now you place it in a different medium <span style="font-family:var(--mono);">n</span>.
        Immediately, the entrance boundary <span style="font-family:var(--mono);">n ↔ n1</span> reflects some light (<span style="font-family:var(--mono);">r_b</span>)
        even before the wave “feels” the multilayer. But the wave that transmits into <span style="font-family:var(--mono);">n1</span> can reflect off the multilayer
        and come back, and that returned wave can reflect again at the boundary, and so on. So the total reflectance is a coherent sum of infinitely many
        back-and-forth bounces. That’s why a compact “composition law” should exist.
      </p>

      <h3>Step-by-step derivation</h3>

      <p><strong>Step 1 — Define the reflectors and Fresnel coefficients.</strong></p>
      <p>
        Let the external medium be <span style="font-family:var(--mono);">n</span> and the device’s front layer be <span style="font-family:var(--mono);">n1</span>.
        The amplitude reflectance of this new boundary (for a wave incident from medium <span style="font-family:var(--mono);">n</span>) is given (normal incidence):
      </p>

      <div class="eqbox" role="group" aria-label="Equation rb">
        <div class="eqrow">
          <div class="eq" id="eq_rb">r_b = (n - n1)/(n + n1)</div>
          <div class="copybtn" data-copy="#eq_rb" title="Copy equation">Copy</div>
        </div>
      </div>

      <p>
        The multilayer device (everything after the first layer) is characterized, <em>as seen from inside medium</em> <span style="font-family:var(--mono);">n1</span>,
        by a complex amplitude reflectance <span style="font-family:var(--mono);">r_m</span>.
        This means: if a wave travels in medium <span style="font-family:var(--mono);">n1</span> toward the stack, the reflected amplitude (back into <span style="font-family:var(--mono);">n1</span>) is <span style="font-family:var(--mono);">r_m</span> times the incident amplitude at that reference plane.
      </p>

      <p><strong>Step 2 — Include transmission through the entrance boundary.</strong></p>
      <p>
        Multiple-bounce sums require transmission factors across the boundary. For normal incidence (non-magnetic), the amplitude transmission coefficients are:
      </p>

      <div class="eqbox" role="group" aria-label="Equations t12 t21">
        <div class="eqrow">
          <div class="eq" id="eq_t">
t_01 = 2n/(n + n1)   (from n → n1)
t_10 = 2n1/(n + n1)  (from n1 → n)</div>
          <div class="copybtn" data-copy="#eq_t" title="Copy equations">Copy</div>
        </div>
      </div>

      <p>
        A very useful identity follows directly from these Fresnel forms and <span style="font-family:var(--mono);">r_b=(n-n1)/(n+n1)</span>:
      </p>

      <div class="eqbox" role="group" aria-label="Identity t01t10">
        <div class="eqrow">
          <div class="eq" id="eq_id">t_01 t_10 = 1 - r_b^2</div>
          <div class="copybtn" data-copy="#eq_id" title="Copy identity">Copy</div>
        </div>
      </div>

      <p>
        <em>Why this matters:</em> once we sum the series, the transmissions collapse neatly into a simple function of <span style="font-family:var(--mono);">r_b</span>.
      </p>

      <p><strong>Step 3 — Write the first few reflected contributions at the entrance plane.</strong></p>
      <p>
        Let the incident field amplitude in medium <span style="font-family:var(--mono);">n</span> be <span style="font-family:var(--mono);">E_i</span>.
        The total reflected field in medium <span style="font-family:var(--mono);">n</span> is the sum of:
      </p>
      <ul>
        <li><strong>(A) Immediate boundary reflection:</strong> <span style="font-family:var(--mono);">E_r^(0) = r_b E_i</span></li>
        <li><strong>(B) Paths that enter the front layer, reflect from the multilayer, and exit:</strong></li>
      </ul>

      <p>
        The wave transmits into <span style="font-family:var(--mono);">n1</span> with amplitude <span style="font-family:var(--mono);">t_01 E_i</span>, reflects off the multilayer as
        <span style="font-family:var(--mono);">r_m (t_01 E_i)</span>, and transmits back into medium <span style="font-family:var(--mono);">n</span> with <span style="font-family:var(--mono);">t_10</span>.
        So the first “multilayer” contribution is:
      </p>

      <div class="eqbox" role="group" aria-label="First multilayer contribution">
        <div class="eqrow">
          <div class="eq" id="eq_first">E_r^(1) = (t_01)(r_m)(t_10) E_i</div>
          <div class="copybtn" data-copy="#eq_first" title="Copy equation">Copy</div>
        </div>
      </div>

      <p>
        Now consider one extra round trip between the boundary and the multilayer before exiting. When a wave in <span style="font-family:var(--mono);">n1</span> reaches the boundary from inside,
        its reflection amplitude is <span style="font-family:var(--mono);">r_10</span>. At normal incidence with our sign convention, <span style="font-family:var(--mono);">r_10 = -r_b</span>
        (swap indices flips the sign).
        So each additional “bounce cycle” multiplies the internal amplitude by <span style="font-family:var(--mono);">(r_m)(r_10) = (r_m)(-r_b)</span>.
      </p>

      <p>
        Therefore the sequence of multilayer-originated reflected fields (that eventually exit into <span style="font-family:var(--mono);">n</span>) is:
      </p>

      <div class="eqbox" role="group" aria-label="Geometric series">
        <div class="eqrow">
          <div class="eq" id="eq_series">
E_r^(1) = t_01 r_m t_10 E_i
E_r^(2) = t_01 r_m (r_10 r_m) t_10 E_i
E_r^(3) = t_01 r_m (r_10 r_m)^2 t_10 E_i
...</div>
          <div class="copybtn" data-copy="#eq_series" title="Copy series">Copy</div>
        </div>
      </div>

      <p><strong>Step 4 — Sum the infinite series.</strong></p>
      <p>
        Summing all multilayer-originated terms:
      </p>

      <div class="eqbox" role="group" aria-label="Summed multilayer term">
        <div class="eqrow">
          <div class="eq" id="eq_sum">
E_r^(ML) = t_01 r_m t_10 [ 1 + (r_10 r_m) + (r_10 r_m)^2 + ... ] E_i
        = t_01 r_m t_10 / (1 - r_10 r_m)  · E_i</div>
          <div class="copybtn" data-copy="#eq_sum" title="Copy equation">Copy</div>
        </div>
      </div>

      <p>
        Using <span style="font-family:var(--mono);">r_10 = -r_b</span>, the denominator becomes <span style="font-family:var(--mono);">1 - (-r_b) r_m = 1 + r_b r_m</span>.
        So:
      </p>

      <div class="eqbox" role="group" aria-label="Multilayer reflected field in terms of rb">
        <div class="eqrow">
          <div class="eq" id="eq_ml">E_r^(ML) = (t_01 t_10) r_m / (1 + r_b r_m) · E_i</div>
          <div class="copybtn" data-copy="#eq_ml" title="Copy equation">Copy</div>
        </div>
      </div>

      <p><strong>Step 5 — Add the direct boundary reflection and simplify to get r.</strong></p>
      <p>
        Total reflected field: <span style="font-family:var(--mono);">E_r = E_r^(0) + E_r^(ML)</span>. Divide by <span style="font-family:var(--mono);">E_i</span> to get total amplitude reflectance
        <span style="font-family:var(--mono);">r = E_r/E_i</span>:
      </p>

      <div class="eqbox" role="group" aria-label="Total r before simplification">
        <div class="eqrow">
          <div class="eq" id="eq_r_pre">r = r_b + (t_01 t_10) r_m / (1 + r_b r_m)</div>
          <div class="copybtn" data-copy="#eq_r_pre" title="Copy equation">Copy</div>
        </div>
      </div>

      <p>
        Now use the identity <span style="font-family:var(--mono);">t_01 t_10 = 1 - r_b^2</span>:
      </p>

      <div class="eqbox" role="group" aria-label="Simplification step">
        <div class="eqrow">
          <div class="eq" id="eq_simplify">
r = r_b + (1 - r_b^2) r_m / (1 + r_b r_m)
  = [ r_b(1 + r_b r_m) + (1 - r_b^2) r_m ] / (1 + r_b r_m)
  = [ r_b + r_b^2 r_m + r_m - r_b^2 r_m ] / (1 + r_b r_m)
  = (r_b + r_m) / (1 + r_b r_m)</div>
          <div class="copybtn" data-copy="#eq_simplify" title="Copy derivation">Copy</div>
        </div>
      </div>

      <div class="callouts">
        <div class="card final" style="grid-column:span 12;">
          <h3>✅ Final symbolic result</h3>
          <div class="eqbox" role="group" aria-label="Final answer equation">
            <div class="eqrow">
              <div class="eq" id="eq_final">r = (r_b + r_m) / (1 + r_b r_m),    where   r_b = (n - n1)/(n + n1)</div>
              <div class="copybtn" data-copy="#eq_final" title="Copy final answer">Copy</div>
            </div>
          </div>
          <p class="note">
            This is a standard “reflectance composition” (a Möbius transform) for two reflectors with internal multiple reflections included coherently.
          </p>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <div class="twoCols">
        <div class="card">
          <h4><span class="pill">units</span> Dimensions</h4>
          <p>
            <span style="font-family:var(--mono);">r_b</span>, <span style="font-family:var(--mono);">r_m</span>, and <span style="font-family:var(--mono);">r</span> are ratios of field amplitudes, hence dimensionless.
            The formula uses only sums and products of dimensionless quantities → consistent.
          </p>
        </div>
        <div class="card">
          <h4><span class="pill">limits</span> Limiting cases (required)</h4>
          <p>We now plug in the requested limits and interpret them.</p>
        </div>
      </div>

      <h3>Limiting cases</h3>
      <div class="callouts">
        <div class="card">
          <h4><span class="pill good">case</span> 1) <span style="font-family:var(--mono);">r_b = 0</span></h4>
          <p>
            <span style="font-family:var(--mono);">r = (0 + r_m)/(1 + 0) = r_m</span>.
          </p>
          <p class="note">Matched entrance (<span style="font-family:var(--mono);">n=n1</span>) → no extra boundary reflection, so the outside sees exactly the multilayer reflectance.</p>
        </div>

        <div class="card">
          <h4><span class="pill warn">case</span> 2) <span style="font-family:var(--mono);">r_b = 1</span></h4>
          <p>
            <span style="font-family:var(--mono);">r = (1 + r_m)/(1 + r_m) = 1</span> (provided <span style="font-family:var(--mono);">1+r_m ≠ 0</span>).
          </p>
          <p class="note">
            A boundary with <span style="font-family:var(--mono);">r_b=1</span> is a perfect reflector by itself (idealized limit). The total must be a perfect reflector regardless of what’s behind it.
          </p>
        </div>

        <div class="card">
          <h4><span class="pill good">case</span> 3) <span style="font-family:var(--mono);">r_m = 0</span></h4>
          <p>
            <span style="font-family:var(--mono);">r = (r_b + 0)/(1 + 0) = r_b</span>.
          </p>
          <p class="note">
            If the multilayer is perfectly impedance-matched/anti-reflective when viewed from <span style="font-family:var(--mono);">n1</span>, then the only reflection comes from the new entrance boundary.
          </p>
        </div>

        <div class="card">
          <h4><span class="pill warn">case</span> 4) <span style="font-family:var(--mono);">r_m = 1</span></h4>
          <p>
            <span style="font-family:var(--mono);">r = (r_b + 1)/(1 + r_b) = 1</span> (for <span style="font-family:var(--mono);">r_b ≠ -1</span>).
          </p>
          <p class="note">
            If the multilayer behaves like a perfect mirror, the whole device must reflect perfectly; the entrance boundary cannot reduce that.
          </p>
        </div>
      </div>

      <p class="note">
        <strong>Extra physical note:</strong> The special algebraic singularity occurs when <span style="font-family:var(--mono);">1 + r_b r_m = 0</span>.
        In a lossless physical system, this corresponds to a resonant condition where the “effective cavity” between reflectors can create large internal fields.
        The combined <span style="font-family:var(--mono);">r</span> remains bounded when you model the full physical constraints correctly (including losses/dispersion and proper reference planes).
      </p>

      <h3>Connect result to the diagram & plots</h3>
      <p>
        In the diagram below, the external mismatch creates <span style="font-family:var(--mono);">r_b</span>. The multilayer contributes <span style="font-family:var(--mono);">r_m</span>.
        The formula <span style="font-family:var(--mono);">r=(r_b+r_m)/(1+r_b r_m)</span> is exactly the coherent sum of all back-and-forth paths between them.
        In the plots, you can vary <span style="font-family:var(--mono);">n</span> (hence <span style="font-family:var(--mono);">r_b</span>) and the complex <span style="font-family:var(--mono);">r_m</span> to see how both the magnitude and phase of <span style="font-family:var(--mono);">r</span> respond.
      </p>

      <div class="vizWrap">
        <figure>
          <canvas id="cnvDiagram" aria-label="Physical setup diagram"></canvas>
          <figcaption>
            <strong>Diagram:</strong> External medium <span style="font-family:var(--mono);">n</span> meets front layer <span style="font-family:var(--mono);">n1</span> (boundary reflectance <span style="font-family:var(--mono);">r_b</span>).
            The rest of the multilayer is summarized by an effective reflectance <span style="font-family:var(--mono);">r_m</span> seen from within <span style="font-family:var(--mono);">n1</span>.
          </figcaption>
        </figure>

        <figure class="plot">
          <canvas id="cnvPlot1" aria-label="Main plot reflectance vs n"></canvas>
          <figcaption>
            <strong>Main plot:</strong> Example power reflectance <span style="font-family:var(--mono);">R=|r|^2</span> versus external index <span style="font-family:var(--mono);">n</span>,
            using the exact formula for <span style="font-family:var(--mono);">r</span>. A marker shows the current slider value.
          </figcaption>
        </figure>

        <figure class="plot" style="grid-column: 1 / -1;">
          <canvas id="cnvPlot2" aria-label="Secondary plot complex plane locus"></canvas>
          <figcaption>
            <strong>Secondary plot:</strong> Complex-plane locus of <span style="font-family:var(--mono);">r</span> as <span style="font-family:var(--mono);">n</span> sweeps the shown range.
            This makes phase behavior intuitive: angle = phase, radius = magnitude.
          </figcaption>
        </figure>
      </div>

      <div class="controls" aria-label="Interactive controls">
        <div class="ctrl">
          <label>
            External index <span style="font-family:var(--mono);">n</span> (example)
            <span class="val" id="val_n"></span>
          </label>
          <input id="slN" type="range" min="1.00" max="3.00" step="0.01" value="1.20"/>
        </div>

        <div class="ctrl">
          <label>
            Front-layer index <span style="font-family:var(--mono);">n1</span> (example)
            <span class="val" id="val_n1"></span>
          </label>
          <input id="slN1" type="range" min="1.10" max="2.20" step="0.01" value="1.50"/>
        </div>

        <div class="ctrl">
          <label>
            Multilayer magnitude <span style="font-family:var(--mono);">|r_m|</span> (example)
            <span class="val" id="val_rmMag"></span>
          </label>
          <input id="slRmMag" type="range" min="0.00" max="0.999" step="0.001" value="0.70"/>
        </div>

        <div class="ctrl">
          <label>
            Multilayer phase <span style="font-family:var(--mono);">arg(r_m)</span> (rad)
            <span class="val" id="val_rmPh"></span>
          </label>
          <input id="slRmPh" type="range" min="-3.1416" max="3.1416" step="0.001" value="1.20"/>
        </div>

        <div class="ctrl" style="grid-column: span 6;">
          <label>
            Sweep range for <span style="font-family:var(--mono);">n</span> in plots
            <span class="val" id="val_range"></span>
          </label>
          <select id="selRange" aria-label="Sweep range selection">
            <option value="1.0,2.0">n ∈ [1.0, 2.0]</option>
            <option value="1.0,2.5" selected>n ∈ [1.0, 2.5]</option>
            <option value="1.0,3.0">n ∈ [1.0, 3.0]</option>
          </select>
        </div>

        <div class="ctrl" style="grid-column: span 6;">
          <label>
            One-click presets (for intuition)
            <span class="val" id="val_preset">—</span>
          </label>
          <button class="smallbtn" id="btnPreset">Cycle preset</button>
        </div>
      </div>

      <div class="eqbox" role="group" aria-label="Current numeric example readout">
        <div class="eqrow">
          <div class="eq" id="eq_readout">Example readout will appear here.</div>
          <div class="copybtn" data-copy="#eq_readout" title="Copy readout">Copy</div>
        </div>
      </div>

    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

      <h3>Re-interpreting the final formula</h3>
      <p>
        The composition
        <span style="font-family:var(--mono);">r = (r_b + r_m)/(1 + r_b r_m)</span>
        is a <em>fractional linear transform</em> (Möbius transform). It tells you:
      </p>
      <ul>
        <li><strong>Numerator (<span style="font-family:var(--mono);">r_b + r_m</span>):</strong> direct “in-phase” addition of the two reflectors’ amplitudes.</li>
        <li><strong>Denominator (<span style="font-family:var(--mono);">1 + r_b r_m</span>):</strong> correction due to <em>multiple reflections between</em> the boundary and the multilayer. When <span style="font-family:var(--mono);">|r_b r_m|</span> is large, repeated bounces strongly matter.</li>
        <li><strong>Phase sensitivity:</strong> because <span style="font-family:var(--mono);">r_m</span> is complex, changing its phase changes the interference of all bounce paths—this is why the complex-plane locus is so revealing.</li>
      </ul>

      <h3>How parameters affect outcomes (connect to plots)</h3>
      <ul>
        <li>Increasing mismatch between <span style="font-family:var(--mono);">n</span> and <span style="font-family:var(--mono);">n1</span> increases <span style="font-family:var(--mono);">|r_b|</span>, typically raising <span style="font-family:var(--mono);">|r|</span> unless destructive interference with <span style="font-family:var(--mono);">r_m</span> occurs.</li>
        <li>Increasing <span style="font-family:var(--mono);">|r_m|</span> makes the stack more mirror-like; in the limit <span style="font-family:var(--mono);">r_m → 1</span>, the combined <span style="font-family:var(--mono);">r → 1</span>.</li>
        <li>Changing <span style="font-family:var(--mono);">arg(r_m)</span> rotates the complex contribution of the stack, moving the locus of <span style="font-family:var(--mono);">r</span> in the complex plane and shifting phase rapidly near points where <span style="font-family:var(--mono);">1 + r_b r_m</span> becomes small.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        You can derive the same composition law using <strong>2-port scattering matrices</strong>.
        Treat the entrance boundary as an S-matrix and the multilayer as another S-matrix referenced to the same plane.
        Cascading these two networks yields the same closed-form fractional expression for the net reflection seen at the input port.
        This is the optics analogue of combining two reflectors in microwave engineering.
      </p>

      <h3>Concept checks (self-test)</h3>
      <ul>
        <li><strong>Q:</strong> If <span style="font-family:var(--mono);">n=n1</span>, why must <span style="font-family:var(--mono);">r=r_m</span>? <strong>A:</strong> Because the entrance boundary disappears (<span style="font-family:var(--mono);">r_b=0</span>), so the only reflector is the multilayer.</li>
        <li><strong>Q:</strong> If <span style="font-family:var(--mono);">r_m=0</span>, what reflects? <strong>A:</strong> Only the new boundary: <span style="font-family:var(--mono);">r=r_b</span>.</li>
        <li><strong>Q:</strong> What does the denominator represent physically? <strong>A:</strong> The infinite series of repeated round trips between boundary and multilayer.</li>
        <li><strong>Q:</strong> Why is <span style="font-family:var(--mono);">r</span> generally complex? <strong>A:</strong> The multilayer introduces phase shifts (optical thickness), so the reflected field can be phase-shifted relative to the incident field.</li>
      </ul>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

      <h3>What each canvas shows</h3>
      <ul>
        <li><strong>Diagram canvas:</strong> A wave comes from medium <span style="font-family:var(--mono);">n</span> to the front layer <span style="font-family:var(--mono);">n1</span>.
          The boundary reflectance is <span style="font-family:var(--mono);">r_b</span>. Inside <span style="font-family:var(--mono);">n1</span>, the multilayer is represented by an effective reflector with reflectance <span style="font-family:var(--mono);">r_m</span>.</li>
        <li><strong>Main plot:</strong> <span style="font-family:var(--mono);">R=|r|^2</span> vs. <span style="font-family:var(--mono);">n</span> for a selected <span style="font-family:var(--mono);">n</span>-range (example sweep). A marker shows the current slider value of <span style="font-family:var(--mono);">n</span>.</li>
        <li><strong>Secondary plot:</strong> Complex-plane path traced by <span style="font-family:var(--mono);">r</span> as <span style="font-family:var(--mono);">n</span> sweeps. The point’s distance from the origin is <span style="font-family:var(--mono);">|r|</span>, and the angle is the phase <span style="font-family:var(--mono);">arg(r)</span>.</li>
      </ul>

      <h3>Interactive controls</h3>
      <ul>
        <li><strong><span style="font-family:var(--mono);">n</span> slider:</strong> changes the entrance mismatch and thus <span style="font-family:var(--mono);">r_b=(n-n1)/(n+n1)</span>. Expect the plots to shift as boundary reflection grows or shrinks.</li>
        <li><strong><span style="font-family:var(--mono);">n1</span> slider:</strong> changes the device’s front-layer index; this also changes <span style="font-family:var(--mono);">r_b</span> for a given <span style="font-family:var(--mono);">n</span>.</li>
        <li><strong><span style="font-family:var(--mono);">|r_m|</span> and phase sliders:</strong> change the multilayer’s effective reflectance strength and phase. Watch the complex-plane locus rotate and stretch.</li>
        <li><strong>Preset button:</strong> cycles through illustrative regimes (matched entrance, anti-reflective stack, mirror-like stack, phase-flip cases) to rapidly build intuition.</li>
      </ul>

      <p class="note">
        All plotted values are <strong>example values</strong> for learning. The final answer of the problem is symbolic and does not depend on the particular numeric choices used in the visualization.
      </p>
    </section>

  </div>
</main>

<footer>
  Built as a self-contained learning article (vanilla HTML/CSS/JS). Copy buttons copy plain text equations.
</footer>

<script>
  // ---------- Utilities ----------
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function fmt(x, d=3){
    if (!isFinite(x)) return "NaN";
    const s = x.toFixed(d);
    return s.replace(/-0\.000/, "0.000");
  }
  function cfmt(re, im, d=3){
    const sign = im >= 0 ? "+" : "−";
    const absIm = Math.abs(im);
    return `${fmt(re,d)} ${sign} ${fmt(absIm,d)}i`;
  }
  function complex(re, im){ return {re, im}; }
  function cadd(a,b){ return {re:a.re+b.re, im:a.im+b.im}; }
  function cmul(a,b){ return {re:a.re*b.re - a.im*b.im, im:a.re*b.im + a.im*b.re}; }
  function cdiv(a,b){
    const den = b.re*b.re + b.im*b.im;
    return {re:(a.re*b.re + a.im*b.im)/den, im:(a.im*b.re - a.re*b.im)/den};
  }
  function cabs(a){ return Math.hypot(a.re, a.im); }
  function carg(a){ return Math.atan2(a.im, a.re); }

  // r = (rb + rm)/(1 + rb*rm), rb real for real n,n1
  function computeAll(n, n1, rm){
    const rb = (n - n1)/(n + n1);
    const rbC = complex(rb, 0);
    const num = cadd(rbC, rm);
    const den = cadd(complex(1,0), cmul(rbC, rm));
    const r = cdiv(num, den);
    return {rb, r};
  }

  // ---------- Copy buttons ----------
  function setupCopy(){
    document.querySelectorAll(".copybtn").forEach(btn=>{
      btn.addEventListener("click", async ()=>{
        const sel = btn.getAttribute("data-copy");
        const el = document.querySelector(sel);
        if(!el) return;
        const txt = el.textContent.trim();
        try{
          await navigator.clipboard.writeText(txt);
          const old = btn.textContent;
          btn.textContent = "Copied ✓";
          setTimeout(()=>btn.textContent = old, 900);
        }catch(e){
          // Fallback
          const ta = document.createElement("textarea");
          ta.value = txt;
          document.body.appendChild(ta);
          ta.select();
          try{ document.execCommand("copy"); }catch(_){}
          document.body.removeChild(ta);
          const old = btn.textContent;
          btn.textContent = "Copied ✓";
          setTimeout(()=>btn.textContent = old, 900);
        }
      });
    });
  }

  // ---------- Canvas helpers ----------
  function setupCanvas(canvas){
    const ctx = canvas.getContext("2d");
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect.width * dpr));
      const h = Math.max(2, Math.floor(rect.height * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    }
    return {ctx, resize};
  }

  function drawPanelTitle(ctx, w, title){
    ctx.save();
    ctx.fillStyle = "rgba(233,238,252,0.92)";
    ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(title, 12, 18);
    ctx.restore();
  }

  function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, grid=true){
    const {x,y,w,h} = box;
    ctx.save();
    // background
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.fillRect(x,y,w,h);

    // grid + ticks
    const nTicks = 6;
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;

    if(grid){
      for(let i=0;i<=nTicks;i++){
        const tx = x + (i/nTicks)*w;
        ctx.beginPath(); ctx.moveTo(tx,y); ctx.lineTo(tx,y+h); ctx.stroke();
      }
      for(let i=0;i<=nTicks;i++){
        const ty = y + (i/nTicks)*h;
        ctx.beginPath(); ctx.moveTo(x,ty); ctx.lineTo(x+w,ty); ctx.stroke();
      }
    }

    // axes border
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.strokeRect(x,y,w,h);

    // tick labels
    ctx.fillStyle = "rgba(184,194,230,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";

    for(let i=0;i<=nTicks;i++){
      const xv = xMin + (i/nTicks)*(xMax-xMin);
      const tx = x + (i/nTicks)*w;
      ctx.fillText(xv.toFixed(2), tx-16, y+h+16);
    }
    for(let i=0;i<=nTicks;i++){
      const yv = yMax - (i/nTicks)*(yMax-yMin);
      const ty = y + (i/nTicks)*h;
      ctx.fillText(yv.toFixed(2), x-46, ty+4);
    }

    // axis labels
    ctx.fillStyle = "rgba(233,238,252,0.92)";
    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(xLabel, x + w/2 - ctx.measureText(xLabel).width/2, y + h + 38);

    ctx.save();
    ctx.translate(x-58, y + h/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
    ctx.restore();

    ctx.restore();

    function X(u){ return x + (u - xMin)/(xMax-xMin)*w; }
    function Y(v){ return y + (yMax - v)/(yMax-yMin)*h; }
    return {X,Y};
  }

  // ---------- Draw diagram ----------
  function drawDiagram(ctx, W, H, state){
    ctx.clearRect(0,0,W,H);

    drawPanelTitle(ctx, W, "Setup diagram (normal incidence)");

    const pad = 14;
    const yMid = H*0.56;

    // Regions
    const leftX = pad;
    const midX = W*0.45;
    const rightX = W - pad;
    const h = H*0.55;

    // medium blocks
    ctx.save();
    // left medium n
    ctx.fillStyle = "rgba(125,211,252,0.10)";
    ctx.strokeStyle = "rgba(125,211,252,0.22)";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.rect(leftX, yMid - h/2, midX-leftX, h);
    ctx.fill(); ctx.stroke();

    // front layer n1
    ctx.fillStyle = "rgba(167,139,250,0.10)";
    ctx.strokeStyle = "rgba(167,139,250,0.22)";
    ctx.beginPath();
    ctx.rect(midX, yMid - h/2, (W*0.18), h);
    ctx.fill(); ctx.stroke();

    // multilayer effective region
    ctx.fillStyle = "rgba(52,211,153,0.08)";
    ctx.strokeStyle = "rgba(52,211,153,0.18)";
    ctx.beginPath();
    ctx.rect(midX + W*0.18, yMid - h/2, rightX-(midX+W*0.18), h);
    ctx.fill(); ctx.stroke();

    // boundary line
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(midX, yMid - h/2);
    ctx.lineTo(midX, yMid + h/2);
    ctx.stroke();

    // effective reflector line for rm
    const rmX = midX + W*0.18 + (rightX-(midX+W*0.18))*0.62;
    ctx.strokeStyle = "rgba(255,255,255,0.30)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(rmX, yMid - h/2 + 10);
    ctx.lineTo(rmX, yMid + h/2 - 10);
    ctx.stroke();
    // hatch
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1;
    for(let i=0;i<12;i++){
      const yy = (yMid - h/2 + 12) + i*(h-24)/11;
      ctx.beginPath();
      ctx.moveTo(rmX, yy);
      ctx.lineTo(rmX+10, yy-8);
      ctx.stroke();
    }

    // incident arrow
    ctx.strokeStyle = "rgba(233,238,252,0.9)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(leftX+18, yMid);
    ctx.lineTo(midX-10, yMid);
    ctx.stroke();
    ctx.beginPath(); // arrow head
    ctx.moveTo(midX-10, yMid);
    ctx.lineTo(midX-24, yMid-7);
    ctx.lineTo(midX-24, yMid+7);
    ctx.closePath();
    ctx.fillStyle = "rgba(233,238,252,0.9)";
    ctx.fill();

    // reflected arrow
    ctx.strokeStyle = "rgba(251,113,133,0.9)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(midX-10, yMid-28);
    ctx.lineTo(leftX+28, yMid-28);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(leftX+28, yMid-28);
    ctx.lineTo(leftX+40, yMid-35);
    ctx.lineTo(leftX+40, yMid-21);
    ctx.closePath();
    ctx.fillStyle = "rgba(251,113,133,0.9)";
    ctx.fill();

    // bounce arrows inside
    ctx.strokeStyle = "rgba(255,255,255,0.30)";
    ctx.setLineDash([5,5]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(midX+18, yMid+26);
    ctx.lineTo(rmX-12, yMid+26);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(rmX-12, yMid+26);
    ctx.lineTo(rmX-24, yMid+19);
    ctx.lineTo(rmX-24, yMid+33);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,255,255,0.30)";
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(rmX-12, yMid+52);
    ctx.lineTo(midX+18, yMid+52);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(midX+18, yMid+52);
    ctx.lineTo(midX+30, yMid+45);
    ctx.lineTo(midX+30, yMid+59);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,255,255,0.30)";
    ctx.fill();
    ctx.setLineDash([]);

    // labels
    ctx.fillStyle = "rgba(233,238,252,0.92)";
    ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText("incident medium", leftX+10, yMid - h/2 + 18);
    ctx.fillText("front layer", midX+10, yMid - h/2 + 18);
    ctx.fillText("multilayer (effective)", midX + W*0.18 + 10, yMid - h/2 + 18);

    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
    ctx.fillStyle = "rgba(184,194,230,0.95)";
    ctx.fillText(`n = ${fmt(state.n,2)}`, leftX+10, yMid - h/2 + 40);
    ctx.fillText(`n1 = ${fmt(state.n1,2)}`, midX+10, yMid - h/2 + 40);

    ctx.fillStyle = "rgba(125,211,252,0.95)";
    ctx.fillText(`r_b = ${fmt(state.rb,3)}`, midX - 80, yMid + h/2 + 22);

    ctx.fillStyle = "rgba(52,211,153,0.95)";
    ctx.fillText(`r_m = ${cfmt(state.rm.re, state.rm.im, 3)}`, rmX - 90, yMid + h/2 + 22);

    ctx.fillStyle = "rgba(233,238,252,0.92)";
    ctx.fillText("E_i", midX-54, yMid-6);
    ctx.fillStyle = "rgba(251,113,133,0.92)";
    ctx.fillText("E_r", midX-54, yMid-34);
    ctx.fillStyle = "rgba(184,194,230,0.95)";
    ctx.fillText("multiple internal bounces", midX+20, yMid+78);

    ctx.restore();
  }

  // ---------- Draw plot 1: R vs n ----------
  function drawPlot1(ctx, W, H, state, sweep){
    ctx.clearRect(0,0,W,H);
    drawPanelTitle(ctx, W, "Main plot: Power reflectance R = |r|² vs external index n (example)");

    const margin = {l:64, r:16, t:30, b:50};
    const box = {x:margin.l, y:margin.t, w:W - margin.l - margin.r, h:H - margin.t - margin.b};

    // Precompute
    let Rmax = 1.02;
    const N = 420;
    const pts = [];
    for(let i=0;i<N;i++){
      const n = sweep.min + (i/(N-1))*(sweep.max - sweep.min);
      const {r} = computeAll(n, state.n1, state.rm);
      const R = Math.min(1.2, cabs(r)**2);
      pts.push({n, R});
      if(isFinite(R)) Rmax = Math.max(Rmax, R);
    }
    Rmax = clamp(Rmax, 1.02, 1.2);

    const ax = drawAxes(ctx, box, sweep.min, sweep.max, 0, Rmax, "n (dimensionless)", "R = |r|² (dimensionless)", true);

    // Curve
    ctx.save();
    ctx.strokeStyle = "rgba(125,211,252,0.95)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    pts.forEach((p, idx)=>{
      const x = ax.X(p.n), y = ax.Y(p.R);
      if(idx===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();

    // Marker at current n
    const {r} = computeAll(state.n, state.n1, state.rm);
    const Rcur = cabs(r)**2;
    const xM = ax.X(state.n);
    const yM = ax.Y(Math.min(Rmax, Rcur));

    ctx.fillStyle = "rgba(251,113,133,0.95)";
    ctx.beginPath();
    ctx.arc(xM, yM, 4.8, 0, Math.PI*2);
    ctx.fill();

    // Legend
    ctx.fillStyle = "rgba(233,238,252,0.92)";
    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    const legX = box.x + 10, legY = box.y + 10;
    ctx.fillText("—  R(n) curve", legX+18, legY+12);
    ctx.strokeStyle = "rgba(125,211,252,0.95)";
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(legX, legY+9); ctx.lineTo(legX+14, legY+9); ctx.stroke();

    ctx.fillStyle = "rgba(233,238,252,0.92)";
    ctx.fillText("•  current n", legX+18, legY+30);
    ctx.fillStyle = "rgba(251,113,133,0.95)";
    ctx.beginPath(); ctx.arc(legX+7, legY+27, 4, 0, Math.PI*2); ctx.fill();

    // note
    ctx.fillStyle = "rgba(184,194,230,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
    ctx.fillText(`current R = ${fmt(Rcur,4)}`, box.x + box.w - 190, box.y + 18);

    ctx.restore();
  }

  // ---------- Draw plot 2: complex plane locus ----------
  function drawPlot2(ctx, W, H, state, sweep){
    ctx.clearRect(0,0,W,H);
    drawPanelTitle(ctx, W, "Secondary plot: Complex plane of r (Re{r} vs Im{r}) as n sweeps (example)");

    const margin = {l:64, r:20, t:30, b:50};
    const box = {x:margin.l, y:margin.t, w:W - margin.l - margin.r, h:H - margin.t - margin.b};

    // Compute locus
    const N = 520;
    const pts = [];
    let maxAbs = 1.05;
    for(let i=0;i<N;i++){
      const n = sweep.min + (i/(N-1))*(sweep.max - sweep.min);
      const {r} = computeAll(n, state.n1, state.rm);
      pts.push(r);
      maxAbs = Math.max(maxAbs, cabs(r));
    }
    maxAbs = clamp(maxAbs*1.08, 1.05, 1.35);

    // Axes centered
    const xMin = -maxAbs, xMax = maxAbs, yMin = -maxAbs, yMax = maxAbs;
    const ax = drawAxes(ctx, box, xMin, xMax, yMin, yMax, "Re{r} (dimensionless)", "Im{r} (dimensionless)", true);

    ctx.save();
    // unit circle for reference
    ctx.strokeStyle = "rgba(255,255,255,0.22)";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    const cx = ax.X(0), cy = ax.Y(0);
    const rad = Math.abs(ax.X(1) - ax.X(0));
    ctx.arc(cx, cy, rad, 0, Math.PI*2);
    ctx.stroke();

    // axes crosshair
    ctx.strokeStyle = "rgba(255,255,255,0.20)";
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(ax.X(0), box.y); ctx.lineTo(ax.X(0), box.y+box.h); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(box.x, ax.Y(0)); ctx.lineTo(box.x+box.w, ax.Y(0)); ctx.stroke();

    // locus curve
    ctx.strokeStyle = "rgba(167,139,250,0.95)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    pts.forEach((p, idx)=>{
      const x = ax.X(p.re), y = ax.Y(p.im);
      if(idx===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();

    // current point
    const {r} = computeAll(state.n, state.n1, state.rm);
    ctx.fillStyle = "rgba(251,113,133,0.95)";
    ctx.beginPath();
    ctx.arc(ax.X(r.re), ax.Y(r.im), 5, 0, Math.PI*2);
    ctx.fill();

    // Legend / labels
    ctx.fillStyle = "rgba(233,238,252,0.92)";
    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    const lx = box.x + 10, ly = box.y + 10;
    ctx.fillText("—  locus r(n)", lx+18, ly+12);
    ctx.strokeStyle = "rgba(167,139,250,0.95)";
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(lx, ly+9); ctx.lineTo(lx+14, ly+9); ctx.stroke();

    ctx.fillStyle = "rgba(233,238,252,0.92)";
    ctx.fillText("•  current r", lx+18, ly+30);
    ctx.fillStyle = "rgba(251,113,133,0.95)";
    ctx.beginPath(); ctx.arc(lx+7, ly+27, 4, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = "rgba(184,194,230,0.95)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
    ctx.fillText(`|r| = ${fmt(cabs(r),4)}   arg(r) = ${fmt(carg(r),4)} rad`, box.x + box.w - 340, box.y + 18);

    ctx.restore();
  }

  // ---------- State + UI ----------
  const state = {
    n: 1.20,
    n1: 1.50,
    rmMag: 0.70,
    rmPh: 1.20,
    rm: complex(0.70*Math.cos(1.2), 0.70*Math.sin(1.2)),
    rb: (1.20-1.50)/(1.20+1.50),
    sweep: {min:1.0, max:2.5},
    presetIndex: 0
  };

  const presets = [
    {name:"Matched entrance (rb≈0)", n:1.50, n1:1.50, rmMag:0.70, rmPh:1.20},
    {name:"Anti-reflective stack (rm≈0)", n:1.25, n1:1.50, rmMag:0.00, rmPh:0.00},
    {name:"Mirror-like stack (rm→1)", n:1.10, n1:1.50, rmMag:0.98, rmPh:0.00},
    {name:"Phase-flip stack (rm≈-0.7)", n:1.35, n1:1.50, rmMag:0.70, rmPh:Math.PI},
    {name:"Strong mismatch (rb large)", n:2.20, n1:1.30, rmMag:0.65, rmPh:-1.10}
  ];

  // Elements
  const slN = document.getElementById("slN");
  const slN1 = document.getElementById("slN1");
  const slRmMag = document.getElementById("slRmMag");
  const slRmPh = document.getElementById("slRmPh");
  const selRange = document.getElementById("selRange");
  const btnPreset = document.getElementById("btnPreset");

  const valN = document.getElementById("val_n");
  const valN1 = document.getElementById("val_n1");
  const valRmMag = document.getElementById("val_rmMag");
  const valRmPh = document.getElementById("val_rmPh");
  const valRange = document.getElementById("val_range");
  const valPreset = document.getElementById("val_preset");
  const readout = document.getElementById("eq_readout");

  // Canvases
  const cd = setupCanvas(document.getElementById("cnvDiagram"));
  const cp1 = setupCanvas(document.getElementById("cnvPlot1"));
  const cp2 = setupCanvas(document.getElementById("cnvPlot2"));

  function syncStateFromUI(){
    state.n = parseFloat(slN.value);
    state.n1 = parseFloat(slN1.value);
    state.rmMag = parseFloat(slRmMag.value);
    state.rmPh = parseFloat(slRmPh.value);
    state.rm = complex(state.rmMag*Math.cos(state.rmPh), state.rmMag*Math.sin(state.rmPh));
    const range = selRange.value.split(",").map(parseFloat);
    state.sweep = {min: range[0], max: range[1]};
    const {rb} = computeAll(state.n, state.n1, state.rm);
    state.rb = rb;

    valN.textContent = fmt(state.n,2);
    valN1.textContent = fmt(state.n1,2);
    valRmMag.textContent = fmt(state.rmMag,3);
    valRmPh.textContent = fmt(state.rmPh,3);
    valRange.textContent = `[${fmt(state.sweep.min,2)}, ${fmt(state.sweep.max,2)}]`;
  }

  function updateReadout(){
    const {rb, r} = computeAll(state.n, state.n1, state.rm);
    const R = cabs(r)**2;
    const text =
`Example numeric readout (for intuition only):
n  = ${fmt(state.n,3)}
n1 = ${fmt(state.n1,3)}

r_b = (n - n1)/(n + n1) = ${fmt(rb,6)}
r_m = ${cfmt(state.rm.re, state.rm.im, 6)}   (|r_m|=${fmt(cabs(state.rm),6)}, arg=${fmt(carg(state.rm),6)} rad)

r   = (r_b + r_m)/(1 + r_b r_m) = ${cfmt(r.re, r.im, 6)}
|r| = ${fmt(cabs(r),6)}
R   = |r|^2 = ${fmt(R,6)}`;
    readout.textContent = text;
  }

  function redraw(){
    cd.resize(); cp1.resize(); cp2.resize();

    const dRect = document.getElementById("cnvDiagram").getBoundingClientRect();
    const p1Rect = document.getElementById("cnvPlot1").getBoundingClientRect();
    const p2Rect = document.getElementById("cnvPlot2").getBoundingClientRect();

    // draw in CSS px coordinates due to ctx transform in setupCanvas
    drawDiagram(cd.ctx, dRect.width, dRect.height, state);
    drawPlot1(cp1.ctx, p1Rect.width, p1Rect.height, state, state.sweep);
    drawPlot2(cp2.ctx, p2Rect.width, p2Rect.height, state, state.sweep);
  }

  function onChange(){
    syncStateFromUI();
    updateReadout();
    redraw();
  }

  // Preset cycling
  btnPreset.addEventListener("click", ()=>{
    state.presetIndex = (state.presetIndex + 1) % presets.length;
    const p = presets[state.presetIndex];
    slN.value = p.n.toFixed(2);
    slN1.value = p.n1.toFixed(2);
    slRmMag.value = p.rmMag.toFixed(3);
    slRmPh.value = p.rmPh.toFixed(3);
    valPreset.textContent = p.name;
    onChange();
  });

  [slN, slN1, slRmMag, slRmPh, selRange].forEach(el=>{
    el.addEventListener("input", onChange);
    el.addEventListener("change", onChange);
  });

  // Scroll-to-section behavior (smooth)
  document.querySelectorAll('nav.toc a[href^="#"]').forEach(a=>{
    a.addEventListener("click", (e)=>{
      const id = a.getAttribute("href");
      const target = document.querySelector(id);
      if(target){
        e.preventDefault();
        target.scrollIntoView({behavior:"smooth", block:"start"});
      }
    });
  });

  // Initialize
  setupCopy();
  syncStateFromUI();
  updateReadout();
  redraw();
  window.addEventListener("resize", ()=>{ redraw(); }, {passive:true});
</script>
</body>
</html>
