<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <meta name="theme-color" content="#07090f" />
  <title>Ray-Transfer Matrix of a Convex–Concave Thin-Lens System</title>
  <style>
    :root{
      --bg:#07090f;
      --panel:#0e1220;
      --panel2:#0b0f1c;
      --text:#e9edf7;
      --muted:#aab3c7;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    @media (prefers-color-scheme: light){
      :root{
        --bg:#f6f7fb;
        --panel:#ffffff;
        --panel2:#fbfcff;
        --text:#0b1020;
        --muted:#4b5563;
        --line:rgba(10,20,40,.12);
        --shadow: 0 10px 30px rgba(10,20,40,.12);
      }
    }

    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1100px 600px at 20% -10%, rgba(125,211,252,.12), transparent 55%),
                  radial-gradient(900px 500px at 95% 15%, rgba(167,139,250,.10), transparent 60%),
                  var(--bg);
      color:var(--text);
      line-height:1.55;
    }

    header{
      padding: 28px 18px 18px;
      max-width: 1150px;
      margin: 0 auto;
    }
    .title{
      display:flex;
      gap:14px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    h1{
      font-size: clamp(1.45rem, 2.3vw, 2.2rem);
      margin:0;
      letter-spacing:-.02em;
    }
    .subtitle{
      margin-top:8px;
      color:var(--muted);
      max-width: 70ch;
    }
    .badgeRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-top: 12px;
    }
    .pill{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      padding:7px 10px;
      border-radius:999px;
      font-size:.88rem;
      color:var(--muted);
      box-shadow: 0 6px 18px rgba(0,0,0,.10);
      backdrop-filter: blur(6px);
    }

    main{
      max-width:1150px;
      margin:0 auto;
      padding: 0 18px 60px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 18px;
      align-items:start;
    }

    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
    }

    /* Sticky TOC */
    nav.toc{
      position: sticky;
      top: 12px;
      align-self:start;
      background: color-mix(in oklab, var(--panel) 88%, transparent);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .tocHeader{
      padding: 14px 14px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .tocHeader strong{letter-spacing:.02em}
    .toc small{color:var(--muted)}
    .tocList{
      padding: 8px 8px 12px;
      display:flex;
      flex-direction:column;
      gap: 4px;
    }
    .toc a{
      text-decoration:none;
      color:var(--text);
      padding: 9px 10px;
      border-radius: 12px;
      border:1px solid transparent;
      font-size: .95rem;
      display:flex;
      gap:10px;
      align-items:center;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .toc a:hover{
      background: rgba(125,211,252,.08);
      border-color: rgba(125,211,252,.22);
      transform: translateX(2px);
    }
    .dot{
      width:9px;height:9px;border-radius:99px;
      background: linear-gradient(180deg, var(--accent), color-mix(in oklab, var(--accent2) 55%, var(--accent)));
      box-shadow: 0 0 0 3px rgba(125,211,252,.12);
      flex: 0 0 auto;
    }

    /* Content cards */
    .content{
      display:flex;
      flex-direction:column;
      gap: 18px;
    }

    section.card{
      background: color-mix(in oklab, var(--panel) 92%, transparent);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardHeader{
      padding: 16px 16px 12px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.05), transparent);
    }
    .cardHeader h2{
      margin:0;
      font-size: 1.15rem;
      letter-spacing:-.01em;
    }
    .cardBody{
      padding: 16px;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap: 14px;
    }
    @media (max-width: 900px){ .grid2{grid-template-columns:1fr} }

    .callout{
      border:1px solid var(--line);
      background: color-mix(in oklab, var(--panel2) 78%, transparent);
      border-radius: 16px;
      padding: 12px 12px;
    }
    .callout h3{
      margin:0 0 6px 0;
      font-size: 1.02rem;
    }
    .callout ul{margin: 8px 0 0 18px; color: var(--muted)}
    .callout li{margin: 6px 0}

    .equation{
      position:relative;
      margin: 10px 0;
      padding: 12px 12px 12px 12px;
      border-radius: 16px;
      border:1px solid rgba(125,211,252,.22);
      background: linear-gradient(180deg, rgba(125,211,252,.10), rgba(125,211,252,.04));
      overflow:auto;
    }
    .equation pre{
      margin:0;
      font-family:var(--mono);
      font-size: .95rem;
      white-space: pre-wrap;
      word-break: break-word;
      color: var(--text);
    }
    .copyBtn{
      position:absolute;
      right:10px;
      top:10px;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--text);
      font-size:.85rem;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .copyBtn:hover{
      transform: translateY(-1px);
      border-color: rgba(125,211,252,.35);
      background: rgba(125,211,252,.10);
    }
    .copyBtn:active{transform: translateY(0px) scale(.99)}
    .copyNote{
      margin-top: 8px;
      color: var(--muted);
      font-size:.92rem;
    }

    .vizWrap{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
      align-items:stretch;
    }
    @media (max-width: 980px){ .vizWrap{grid-template-columns:1fr} }

    figure{
      margin:0;
      padding: 12px;
      border:1px solid var(--line);
      border-radius: 18px;
      background: color-mix(in oklab, var(--panel2) 78%, transparent);
      overflow:hidden;
    }
    figcaption{
      margin-top: 10px;
      color: var(--muted);
      font-size: .92rem;
    }

    canvas{
      width:100%;
      height: 320px;
      display:block;
      border-radius: 14px;
      background: rgba(0,0,0,.10);
      border:1px solid rgba(255,255,255,.08);
    }
    .wide canvas{height: 360px;}
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap: 10px 12px;
      align-items:center;
      justify-content:space-between;
      margin-top: 10px;
      padding-top: 10px;
      border-top:1px solid var(--line);
    }
    .control{
      display:flex;
      flex-direction:column;
      gap: 6px;
      min-width: 230px;
      flex: 1 1 260px;
    }
    label{
      font-size: .92rem;
      color: var(--muted);
      display:flex;
      justify-content:space-between;
      gap: 10px;
    }
    input[type="range"]{width:100%}
    .readout{
      font-family:var(--mono);
      font-size:.92rem;
      color: var(--text);
      opacity:.95;
    }

    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 8px 12px;
      padding: 10px 12px;
      border-radius: 16px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      margin-top: 10px;
    }
    .kv div:nth-child(odd){color: var(--muted)}
    .kv div:nth-child(even){font-family:var(--mono)}

    .hr{
      height:1px;
      background: var(--line);
      margin: 14px 0;
    }

    .finalBox{
      border:1px solid rgba(52,211,153,.28);
      background: linear-gradient(180deg, rgba(52,211,153,.12), rgba(52,211,153,.05));
      border-radius: 18px;
      padding: 14px 14px;
    }
    .finalBox h3{
      margin: 0 0 8px 0;
      font-size: 1.05rem;
    }

    .printHint{
      color:var(--muted);
      font-size:.92rem;
    }

    footer{
      max-width:1150px;
      margin: 0 auto;
      padding: 18px;
      color: var(--muted);
    }

    /* Subtle reveal */
    .card{animation: rise .35s ease both}
    @keyframes rise{
      from{transform: translateY(6px); opacity:.0}
      to{transform: translateY(0); opacity:1}
    }

    @media print{
      nav.toc{display:none}
      body{background:#fff}
      section.card{box-shadow:none}
      canvas{border:1px solid #ccc}
      .copyBtn{display:none}
      a{color:#000; text-decoration:none}
    }
  </style>
</head>

<body>
  <header>
    <div class="title">
      <div>
        <h1>Ray-Transfer Matrix of a Convex–Concave Thin-Lens System</h1>
        <div class="subtitle">
          Two thin lenses: a convex lens with focal length <span style="font-family:var(--mono)">f</span>
          followed by a concave lens with focal length <span style="font-family:var(--mono)">−f</span>,
          separated by distance <span style="font-family:var(--mono)">f</span>.
          We compute the composite ABCD matrix and interpret its imaging behavior.
        </div>
        <div class="badgeRow">
          <span class="pill">Paraxial optics</span>
          <span class="pill">ABCD / ray-transfer matrices</span>
          <span class="pill">Principal planes & effective focal length</span>
          <span class="pill">Interactive ray tracing</span>
        </div>
      </div>
      <div class="pill" title="Conventions used">
        Ray vector: <span style="font-family:var(--mono)">[ y ; θ ]</span>, small-angle <span style="font-family:var(--mono)">θ ≈ dy/dz</span>
      </div>
    </div>
  </header>

  <main>
    <!-- Sticky TOC -->
    <nav class="toc" aria-label="Table of contents">
      <div class="tocHeader">
        <div>
          <strong>Contents</strong><br/>
          <small>Jump to a section</small>
        </div>
        <div class="pill" style="font-size:.82rem">ABCD</div>
      </div>
      <div class="tocList">
        <a href="#quick"><span class="dot"></span>Quick Summary</a>
        <a href="#part1"><span class="dot"></span>Part 1 — Problem Analysis</a>
        <a href="#part2"><span class="dot"></span>Part 2 — Strategy & Tips</a>
        <a href="#part3"><span class="dot"></span>Part 3 — Full Solution</a>
        <a href="#viz"><span class="dot"></span>Interactive Visualizations</a>
        <a href="#checks"><span class="dot"></span>Sanity Checks</a>
      </div>
    </nav>

    <div class="content">
      <!-- Quick Summary -->
      <section class="card" id="quick">
        <div class="cardHeader"><h2>Quick Summary</h2></div>
        <div class="cardBody">
          <ul style="margin:0 0 0 18px;">
            <li>The system matrix for separation <span style="font-family:var(--mono)">d</span> is
              <span style="font-family:var(--mono)">M(d)= [[1−d/f, d], [−d/f², 1+d/f]]</span>.
            </li>
            <li>For the given separation <span style="font-family:var(--mono)">d=f</span>:
              <span style="font-family:var(--mono)">M = [[0, f], [−1/f, 2]]</span>.
            </li>
            <li>The effective focal length (EFL) is
              <span style="font-family:var(--mono)">f_eff = −1/C = f²/d</span>, so at <span style="font-family:var(--mono)">d=f</span> it equals <span style="font-family:var(--mono)">f</span>.
            </li>
            <li>The principal planes are shifted: at <span style="font-family:var(--mono)">d=f</span>,
              <span style="font-family:var(--mono)">H1</span> lies at the second lens plane and <span style="font-family:var(--mono)">H2</span> lies at the first lens plane (they “swap”).
            </li>
            <li>Collimated light focuses right at the second lens plane (zero working distance beyond the concave lens), then diverges.</li>
          </ul>
          <div class="copyNote">Tip: Use the sliders below to change the lens separation and see how the matrix and focusing change.</div>
        </div>
      </section>

      <!-- PART 1 -->
      <section class="card" id="part1">
        <div class="cardHeader"><h2>PART 1 — Problem Analysis (no solving yet)</h2></div>
        <div class="cardBody">
          <div class="grid2">
            <div class="callout">
              <h3>Restated problem</h3>
              <p style="margin:0;color:var(--muted)">
                We have an optical system made of two thin lenses in air:
                a <strong>convex</strong> lens with focal length <span style="font-family:var(--mono)">f</span>,
                then a <strong>concave</strong> lens with focal length <span style="font-family:var(--mono)">−f</span>,
                separated by distance <span style="font-family:var(--mono)">f</span>.
                Find the overall <strong>ray-transfer (ABCD) matrix</strong>, and discuss what kind of imaging (or non-imaging)
                behavior this “composite lens” has.
              </p>
            </div>
            <div class="callout">
              <h3>Given / Unknowns</h3>
              <ul>
                <li><strong>Given:</strong> thin lens 1: <span style="font-family:var(--mono)">f</span>; thin lens 2: <span style="font-family:var(--mono)">−f</span>; separation <span style="font-family:var(--mono)">f</span>.</li>
                <li><strong>Unknown:</strong> system ABCD matrix <span style="font-family:var(--mono)">M</span>.</li>
                <li><strong>Also asked:</strong> imaging properties (effective focal length, principal planes, where collimated rays focus, etc.).</li>
              </ul>
            </div>
          </div>

          <div class="hr"></div>

          <div class="callout">
            <h3>Relevant principles (and why)</h3>
            <ul>
              <li><strong>Paraxial approximation:</strong> rays make small angles with the optical axis so <span style="font-family:var(--mono)">tan θ ≈ θ</span>.</li>
              <li><strong>Ray-transfer matrices:</strong> each element (free-space propagation, thin lens) is a 2×2 linear map on the ray vector <span style="font-family:var(--mono)">[y; θ]</span>.</li>
              <li><strong>System composition:</strong> cascading elements multiplies matrices in the order the ray encounters them.</li>
              <li><strong>Imaging interpretation:</strong> from <span style="font-family:var(--mono)">M=[[A,B],[C,D]]</span> we infer effective focal length, principal planes, and focusing behavior.</li>
            </ul>
          </div>

          <div class="hr"></div>

          <div class="callout">
            <h3>Possible approaches (choose 1)</h3>
            <ul>
              <li><strong>ABCD multiplication (best):</strong> write matrices for lens–space–lens and multiply directly. Fast, exact (within paraxial model), and naturally yields imaging parameters.</li>
              <li><strong>Ray tracing with lens formula:</strong> track a generic ray (or two rays) using <span style="font-family:var(--mono)">1/s+1/s'=1/f</span> across each lens. Works but is more case-dependent and less systematic.</li>
              <li><strong>Equivalent thick-lens analysis:</strong> extract effective focal length & principal planes using standard formulas. Powerful, but still needs ABCD (or equivalent) first.</li>
            </ul>
            <p style="margin:10px 0 0;color:var(--muted)">
              We will use <strong>ABCD multiplication</strong> because it gives the system matrix cleanly and makes the imaging discussion straightforward.
            </p>
          </div>
        </div>
      </section>

      <!-- PART 2 -->
      <section class="card" id="part2">
        <div class="cardHeader"><h2>PART 2 — Strategy & Tips (roadmap only)</h2></div>
        <div class="cardBody">
          <div class="callout">
            <h3>Plan (5–10 steps)</h3>
            <ol style="margin: 8px 0 0 18px; color: var(--muted)">
              <li><strong>Choose ray vector</strong> <span style="font-family:var(--mono)">[y; θ]</span> and sign convention (positive z to the right).</li>
              <li><strong>Write element matrices:</strong> thin lens <span style="font-family:var(--mono)">L(f)</span> and free-space <span style="font-family:var(--mono)">T(d)</span>.</li>
              <li><strong>Compose system</strong> in encounter order: <span style="font-family:var(--mono)">M = L(−f) · T(d) · L(f)</span>.</li>
              <li><strong>Multiply symbolically</strong> to get <span style="font-family:var(--mono)">A,B,C,D</span> as functions of <span style="font-family:var(--mono)">d</span> and <span style="font-family:var(--mono)">f</span>.</li>
              <li><strong>Substitute the given separation</strong> <span style="font-family:var(--mono)">d=f</span> to get the requested numeric-in-symbols matrix.</li>
              <li><strong>Extract imaging parameters:</strong> effective focal length <span style="font-family:var(--mono)">f_eff = −1/C</span> and principal-plane shifts from a decomposition into translations + thin lens.</li>
              <li><strong>Discuss behavior:</strong> where collimated rays focus, whether the system is afocal, and what “composite lens” it mimics.</li>
              <li><strong>Sanity checks:</strong> units, special cases (<span style="font-family:var(--mono)">d→0</span>, <span style="font-family:var(--mono)">d→∞</span>), physical interpretation.</li>
            </ol>
          </div>

          <div class="hr"></div>

          <div class="callout">
            <h3>Common mistakes & quick tips</h3>
            <ul>
              <li><strong>Matrix order:</strong> multiply in the same order the ray encounters elements (rightmost is first).</li>
              <li><strong>Lens sign:</strong> a diverging (concave) lens has negative focal length; its matrix uses <span style="font-family:var(--mono)">−1/f</span> in the C-entry, so if <span style="font-family:var(--mono)">f2=−f</span> then C becomes <span style="font-family:var(--mono)">−1/(−f)=+1/f</span>.</li>
              <li><strong>Imaging condition:</strong> “perfect imaging between two chosen planes” corresponds to <span style="font-family:var(--mono)">B=0</span> for those planes (not automatically true here).</li>
              <li><strong>Working distance:</strong> effective focal length can be <span style="font-family:var(--mono)">f</span> while the focus sits right on an element because principal planes can shift.</li>
            </ul>
          </div>
        </div>
      </section>

      <!-- PART 3 -->
      <section class="card" id="part3">
        <div class="cardHeader"><h2>PART 3 — Full Solution</h2></div>
        <div class="cardBody">
          <div class="callout">
            <h3>Physical intuition first</h3>
            <p style="margin:0;color:var(--muted)">
              A convex lens of focal length <span style="font-family:var(--mono)">f</span> takes parallel rays and brings them to a focus at distance <span style="font-family:var(--mono)">f</span>.
              If we place a concave lens exactly at that focus (separation <span style="font-family:var(--mono)">f</span>), all rays converge to the concave lens plane (they “meet” there),
              but because the beam height at the concave lens is essentially zero at the crossing, the concave lens cannot “undo” the convergence at that instant; it mainly changes angles afterward.
              So we expect the system to have a <em>focus right at the second lens plane</em>, followed by divergence.
            </p>
          </div>

          <div class="hr"></div>

          <article>
            <h3 style="margin:0 0 10px 0;">Step 1 — Element matrices</h3>
            <p style="margin:0;color:var(--muted)">
              Use the paraxial ray vector <span style="font-family:var(--mono)">r = [y; θ]</span>, where
              <span style="font-family:var(--mono)">y</span> is transverse height and <span style="font-family:var(--mono)">θ</span> is the (small) angle to the optical axis.
            </p>

            <div class="equation" id="eq-elements">
              <button class="copyBtn" data-copy-target="eq-elements">Copy</button>
              <pre>Free space over distance d:
T(d) = [ 1   d ]
       [ 0   1 ]

Thin lens of focal length f:
L(f) = [ 1    0  ]
       [ -1/f 1 ]</pre>
            </div>

            <p style="margin:0;color:var(--muted)">
              For the concave lens with focal length <span style="font-family:var(--mono)">f2 = −f</span>:
              <span style="font-family:var(--mono)">L(−f) = [[1,0],[+1/f,1]]</span>.
            </p>

            <div class="hr"></div>

            <h3 style="margin:0 0 10px 0;">Step 2 — Compose the system matrix</h3>
            <p style="margin:0;color:var(--muted)">
              The ray encounters: convex lens → free space (distance <span style="font-family:var(--mono)">d</span>) → concave lens.
              Therefore,
              <span style="font-family:var(--mono)">M(d) = L(−f) · T(d) · L(f)</span>.
            </p>

            <div class="equation" id="eq-compose">
              <button class="copyBtn" data-copy-target="eq-compose">Copy</button>
              <pre>M(d) = [ 1   0 ] [ 1  d ] [ 1   0 ]
       [ 1/f 1 ] [ 0  1 ] [ -1/f 1 ]</pre>
            </div>

            <div class="hr"></div>

            <h3 style="margin:0 0 10px 0;">Step 3 — Multiply (symbolic, step-by-step)</h3>
            <p style="margin:0;color:var(--muted)">First multiply the middle and first-lens matrices: <span style="font-family:var(--mono)">T(d)L(f)</span>.</p>

            <div class="equation" id="eq-mult1">
              <button class="copyBtn" data-copy-target="eq-mult1">Copy</button>
              <pre>T(d)L(f) =
[ 1  d ] [ 1    0  ] = [ 1 - d/f   d ]
[ 0  1 ] [ -1/f 1 ]   [   -1/f     1 ]</pre>
            </div>

            <p style="margin:0;color:var(--muted)">Now multiply by the second lens matrix <span style="font-family:var(--mono)">L(−f)</span> on the left:</p>

            <div class="equation" id="eq-mult2">
              <button class="copyBtn" data-copy-target="eq-mult2">Copy</button>
              <pre>M(d) = L(−f) · (T(d)L(f)) =
[ 1   0 ] [ 1 - d/f   d ] = [ 1 - d/f      d ]
[ 1/f 1 ] [  -1/f     1 ]   [  -d/f^2   1 + d/f ]</pre>
            </div>

            <div class="finalBox">
              <h3>Final symbolic ray-transfer matrix (separation d)</h3>
              <div class="equation" id="eq-final-symbolic" style="margin:10px 0 0 0;">
                <button class="copyBtn" data-copy-target="eq-final-symbolic">Copy</button>
                <pre>M(d) =
[ A  B ] = [ 1 - d/f        d      ]
[ C  D ]   [  -d/f^2     1 + d/f   ]</pre>
              </div>
            </div>

            <div class="hr"></div>

            <h3 style="margin:0 0 10px 0;">Step 4 — Substitute the given separation d = f</h3>
            <p style="margin:0;color:var(--muted)">
              Plug <span style="font-family:var(--mono)">d=f</span> into the entries:
              <span style="font-family:var(--mono)">A=0</span>, <span style="font-family:var(--mono)">B=f</span>, <span style="font-family:var(--mono)">C=−1/f</span>, <span style="font-family:var(--mono)">D=2</span>.
            </p>

            <div class="finalBox" style="margin-top:12px;">
              <h3>Requested matrix for separation f</h3>
              <div class="equation" id="eq-final-df" style="margin:10px 0 0 0;">
                <button class="copyBtn" data-copy-target="eq-final-df">Copy</button>
                <pre>M(d=f) =
[ 0    f ]
[ -1/f 2 ]</pre>
              </div>
            </div>

            <div class="hr"></div>

            <h3 style="margin:0 0 10px 0;">Step 5 — Imaging properties of the composite lens</h3>
            <p style="margin:0;color:var(--muted)">
              For a general first-order system <span style="font-family:var(--mono)">M=[[A,B],[C,D]]</span> (in air), a convenient “equivalent lens” description uses:
            </p>

            <div class="equation" id="eq-efl">
              <button class="copyBtn" data-copy-target="eq-efl">Copy</button>
              <pre>Effective focal length (EFL):  f_eff = −1/C  (when C ≠ 0)

Principal-plane shifts (relative to the chosen input/output reference planes):
h1 = (A − 1)/C     (input plane → first principal plane H1)
h2 = (D − 1)/C     (output plane → second principal plane H2)

Then: M = T(−h2) · L(f_eff) · T(h1)</pre>
            </div>

            <p style="margin:0;color:var(--muted)">
              Here, from <span style="font-family:var(--mono)">C = −d/f²</span> we get
              <span style="font-family:var(--mono)">f_eff = f²/d</span>.
              For the specific problem <span style="font-family:var(--mono)">d=f</span>, <span style="font-family:var(--mono)">f_eff = f</span>.
            </p>

            <div class="equation" id="eq-hs">
              <button class="copyBtn" data-copy-target="eq-hs">Copy</button>
              <pre>Using M(d=f): A=0, C=−1/f, D=2

h1 = (A−1)/C = (−1)/(−1/f) = +f
h2 = (D−1)/C = ( +1)/(−1/f) = −f

Interpretation:
• H1 is f to the right of the first lens plane → at the second lens plane.
• H2 is f to the left of the output plane (second lens plane) → at the first lens plane.</pre>
            </div>

            <div class="callout">
              <h3>What this means (plain language)</h3>
              <ul>
                <li>The system behaves like an equivalent lens with focal length <span style="font-family:var(--mono)">f_eff=f</span> <em>but</em> its principal planes are not at the physical lenses.</li>
                <li>At <span style="font-family:var(--mono)">d=f</span>, the principal planes “swap”: <span style="font-family:var(--mono)">H1</span> sits at the concave lens plane, while <span style="font-family:var(--mono)">H2</span> sits at the convex lens plane.</li>
                <li>Therefore, collimated light (object at infinity) forms its image one focal length to the right of <span style="font-family:var(--mono)">H2</span>, i.e. at the <em>second lens plane</em>. After the concave lens, the beam diverges.</li>
                <li>The system is <strong>not</strong> afocal (since <span style="font-family:var(--mono)">C≠0</span>), and it is <strong>not</strong> an imaging system between the two lens planes (since <span style="font-family:var(--mono)">B=f≠0</span>).</li>
              </ul>
            </div>

            <div class="finalBox" style="margin-top:12px;">
              <h3>Boxed takeaway</h3>
              <div class="equation" id="eq-takeaway" style="margin:10px 0 0 0;">
                <button class="copyBtn" data-copy-target="eq-takeaway">Copy</button>
                <pre>For d = f:

M = [ 0    f ]
    [ -1/f 2 ]

Equivalent-lens view:
f_eff = f
H1 at the concave lens plane
H2 at the convex lens plane
Collimated light focuses at the concave lens plane, then diverges.</pre>
              </div>
            </div>
          </article>
        </div>
      </section>

      <!-- Visualizations -->
      <section class="card" id="viz">
        <div class="cardHeader"><h2>Interactive Visualizations</h2></div>
        <div class="cardBody">
          <div class="callout">
            <h3>How to use</h3>
            <p style="margin:0;color:var(--muted)">
              The slider changes the lens separation <span style="font-family:var(--mono)">d</span> (shown as a multiple of <span style="font-family:var(--mono)">f</span>).
              All three canvases update live: (1) setup diagram, (2) ray-trace plot, (3) parameter-sweep plot of the effective focal length and the special point where <span style="font-family:var(--mono)">A=0</span>.
            </p>
          </div>

          <div class="vizWrap" style="margin-top:12px;">
            <figure class="wide">
              <canvas id="cDiagram" aria-label="Diagram of two-lens system"></canvas>
              <figcaption>
                <strong>Diagram.</strong> Convex lens (<span style="font-family:var(--mono)">f</span>) then concave lens (<span style="font-family:var(--mono)">−f</span>) separated by <span style="font-family:var(--mono)">d</span>.
                Principal-plane locations for the current <span style="font-family:var(--mono)">d</span> are shown as dashed lines.
              </figcaption>
            </figure>

            <figure class="wide">
              <canvas id="cRayPlot" aria-label="Ray height versus z plot"></canvas>
              <figcaption>
                <strong>Main quantitative plot.</strong> Ray height <span style="font-family:var(--mono)">y(z)</span> for several input rays with the same entrance angle (default: parallel to axis).
                The crossing (focus) location predicted by the equivalent-lens model is indicated.
              </figcaption>
            </figure>
          </div>

          <div class="vizWrap" style="margin-top:14px;">
            <figure>
              <canvas id="cSweep" aria-label="Effective focal length vs separation"></canvas>
              <figcaption>
                <strong>Secondary plot (parameter sweep).</strong> Effective focal length <span style="font-family:var(--mono)">f_eff(d)=f²/d</span> and the special separation <span style="font-family:var(--mono)">d=f</span> where <span style="font-family:var(--mono)">A=0</span>.
              </figcaption>
            </figure>

            <figure>
              <div class="callout" style="margin:0;">
                <h3>Interactive controls</h3>
                <div class="controls">
                  <div class="control">
                    <label for="sep">
                      Lens separation
                      <span class="readout" id="sepRead">d = 1.00 f</span>
                    </label>
                    <input id="sep" type="range" min="0.20" max="2.00" step="0.01" value="1.00" />
                    <div class="printHint">Range: <span style="font-family:var(--mono)">0.2f</span> to <span style="font-family:var(--mono)">2f</span></div>
                  </div>

                  <div class="control">
                    <label for="fval">
                      Example focal length (for units on plots)
                      <span class="readout" id="fRead">f = 100 mm</span>
                    </label>
                    <input id="fval" type="range" min="25" max="250" step="1" value="100" />
                    <div class="printHint">This is just for visualization; final results remain symbolic.</div>
                  </div>

                  <div class="control">
                    <label for="mode">
                      Input ray set
                      <span class="readout" id="modeRead">Parallel bundle (θ_in = 0)</span>
                    </label>
                    <select id="mode" style="padding:10px;border-radius:12px;border:1px solid var(--line);background:rgba(255,255,255,.05);color:var(--text)">
                      <option value="parallel" selected>Parallel bundle (θ_in = 0)</option>
                      <option value="tilted">Tilted bundle (fixed θ_in)</option>
                      <option value="point">Point source at first lens plane (y_in = 0, various θ_in)</option>
                    </select>
                    <div class="printHint">Choose a different input condition and watch how rays propagate.</div>
                  </div>
                </div>

                <div class="kv" id="kvOut" aria-label="Matrix and derived quantities readout">
                  <div>Matrix A</div><div id="Aout">—</div>
                  <div>Matrix B</div><div id="Bout">—</div>
                  <div>Matrix C</div><div id="Cout">—</div>
                  <div>Matrix D</div><div id="Dout">—</div>

                  <div>Effective focal length</div><div id="feffOut">—</div>
                  <div>h1 (to H1)</div><div id="h1Out">—</div>
                  <div>h2 (to H2)</div><div id="h2Out">—</div>
                </div>

                <div class="equation" id="eq-live" style="margin-top:12px;">
                  <button class="copyBtn" data-copy-target="eq-live">Copy</button>
                  <pre id="liveText">M(d)= ...</pre>
                </div>
              </div>
            </figure>
          </div>
        </div>
      </section>

      <!-- Sanity Checks -->
      <section class="card" id="checks">
        <div class="cardHeader"><h2>Sanity Checks</h2></div>
        <div class="cardBody">
          <div class="callout">
            <h3>1) Units</h3>
            <ul>
              <li><span style="font-family:var(--mono)">A</span> and <span style="font-family:var(--mono)">D</span> are dimensionless.</li>
              <li><span style="font-family:var(--mono)">B</span> has units of length (here it equals <span style="font-family:var(--mono)">d</span>).</li>
              <li><span style="font-family:var(--mono)">C</span> has units of 1/length (here <span style="font-family:var(--mono)">−d/f²</span>).</li>
              <li><span style="font-family:var(--mono)">f_eff = −1/C = f²/d</span> has units of length ✔</li>
            </ul>
          </div>

          <div class="hr"></div>

          <div class="callout">
            <h3>2) Limiting cases</h3>
            <ul>
              <li><strong>d → 0:</strong> the lenses coincide. Then <span style="font-family:var(--mono)">C→0</span> and <span style="font-family:var(--mono)">M→I</span>.
                Physically, a lens of +f and a lens of −f at the same plane cancel (net optical power ≈ 0).</li>
              <li><strong>d → ∞:</strong> the lenses are far apart. Then <span style="font-family:var(--mono)">|C| = d/f²</span> grows, so <span style="font-family:var(--mono)">f_eff = f²/d → 0</span>.
                Interpreting “effective focal length” becomes tricky because the reference planes are extremely separated; the system strongly mixes height/angle at the output plane.</li>
              <li><strong>d = f (this problem):</strong> <span style="font-family:var(--mono)">A=0</span>, meaning an input height maps entirely into output angle (a hallmark of being at a focal condition between reference planes).
                Collimated rays converge at the second lens plane.</li>
            </ul>
          </div>

          <div class="hr"></div>

          <div class="callout">
            <h3>3) Physical interpretation</h3>
            <ul>
              <li>The system has a well-defined EFL (<span style="font-family:var(--mono)">f_eff=f</span> when <span style="font-family:var(--mono)">d=f</span>), but its principal planes are shifted substantially.</li>
              <li>At the designed spacing <span style="font-family:var(--mono)">d=f</span>, the “image of infinity” lands right on the concave lens plane — effectively <em>no back working distance</em>.</li>
              <li>This is a classic example where “focal length” alone does not tell you where the focus physically appears; you also need principal-plane locations.</li>
            </ul>
          </div>
        </div>
      </section>

      <footer>
        <div style="border-top:1px solid var(--line); padding-top:14px;">
          <div><strong>Notes:</strong> All results assume thin lenses, paraxial rays, and air on both sides.</div>
          <div class="printHint">You can paste this HTML directly into your site. No external libraries required.</div>
        </div>
      </footer>
    </div>
  </main>

  <script>
    // --------------------------
    // Utility: copy buttons
    // --------------------------
    function copyPlainTextFromEquation(eqEl){
      const pre = eqEl.querySelector("pre");
      const txt = pre ? pre.innerText : eqEl.innerText;
      navigator.clipboard.writeText(txt).then(()=>{
        const btn = eqEl.querySelector(".copyBtn");
        if(!btn) return;
        const old = btn.textContent;
        btn.textContent = "Copied!";
        setTimeout(()=>btn.textContent = old, 900);
      }).catch(()=>{
        // fallback
        const ta = document.createElement("textarea");
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        try{ document.execCommand("copy"); }catch(e){}
        document.body.removeChild(ta);
      });
    }
    document.addEventListener("click", (e)=>{
      const b = e.target.closest(".copyBtn");
      if(!b) return;
      const id = b.getAttribute("data-copy-target");
      const el = document.getElementById(id);
      if(el) copyPlainTextFromEquation(el);
    });

    // --------------------------
    // Math model (ABCD)
    // --------------------------
    function matrixFor(f, d){
      // M(d) = L(-f)*T(d)*L(f) = [[1-d/f, d],[-d/f^2, 1+d/f]]
      const A = 1 - d/f;
      const B = d;
      const C = -d/(f*f);
      const D = 1 + d/f;
      return {A,B,C,D};
    }
    function fmt(x, digits=4){
      if(!isFinite(x)) return "∞";
      const ax = Math.abs(x);
      if(ax !== 0 && (ax < 1e-3 || ax > 1e4)) return x.toExponential(3);
      return x.toFixed(digits);
    }
    function fmtLenMM(x){
      if(!isFinite(x)) return "∞";
      return `${fmt(x,2)} mm`;
    }

    // principal plane shifts and effective focal length
    function derived(M){
      const {A,B,C,D} = M;
      let feff = (C !== 0) ? (-1/C) : Infinity;
      let h1 = (C !== 0) ? ((A - 1)/C) : Infinity;
      let h2 = (C !== 0) ? ((D - 1)/C) : Infinity;
      return {feff, h1, h2};
    }

    // --------------------------
    // Canvas helpers
    // --------------------------
    function setupCanvas(canvas){
      const ctx = canvas.getContext("2d");
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {ctx, w: rect.width, h: rect.height, dpr};
    }

    function clear(ctx, w, h){
      ctx.clearRect(0,0,w,h);
    }

    function drawGrid(ctx, w, h, x0, y0, x1, y1, xTicks, yTicks){
      // Draw a light grid in plot area
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.lineWidth = 1;
      for(let i=0;i<=xTicks;i++){
        const x = x0 + (x1-x0)*i/xTicks;
        ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y1); ctx.stroke();
      }
      for(let j=0;j<=yTicks;j++){
        const y = y0 + (y1-y0)*j/yTicks;
        ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke();
      }
      ctx.restore();
    }

    function drawAxes(ctx, w, h, plot, title, xlabel, ylabel){
      const {x0,y0,x1,y1} = plot;
      ctx.save();
      // Panel border
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 1;
      ctx.strokeRect(x0,y0,x1-x0,y1-y0);

      // Title
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(title, x0, y0 - 10);

      // Labels
      ctx.fillStyle = "rgba(255,255,255,0.70)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(xlabel, x0, y1 + 22);

      // y label rotated
      ctx.save();
      ctx.translate(x0 - 28, (y0+y1)/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(ylabel, 0, 0);
      ctx.restore();
      ctx.restore();
    }

    function ticksLinear(min, max, n){
      const out = [];
      for(let i=0;i<=n;i++){
        out.push(min + (max-min)*i/n);
      }
      return out;
    }

    function mapX(x, xmin, xmax, x0, x1){ return x0 + (x - xmin) * (x1-x0) / (xmax-xmin); }
    function mapY(y, ymin, ymax, y0, y1){ return y1 - (y - ymin) * (y1-y0) / (ymax-ymin); }

    function drawTickLabels(ctx, plot, xmin, xmax, ymin, ymax, xTickCount, yTickCount, xUnit, yUnit){
      const {x0,y0,x1,y1} = plot;
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.65)";
      ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";

      // x ticks
      for(let i=0;i<=xTickCount;i++){
        const xVal = xmin + (xmax-xmin)*i/xTickCount;
        const x = mapX(xVal, xmin, xmax, x0, x1);
        ctx.strokeStyle = "rgba(255,255,255,0.25)";
        ctx.beginPath(); ctx.moveTo(x,y1); ctx.lineTo(x,y1+6); ctx.stroke();
        const label = `${Math.round(xVal)}${xUnit}`;
        ctx.fillText(label, x-10, y1+18);
      }

      // y ticks
      for(let j=0;j<=yTickCount;j++){
        const yVal = ymin + (ymax-ymin)*j/yTickCount;
        const y = mapY(yVal, ymin, ymax, y0, y1);
        ctx.strokeStyle = "rgba(255,255,255,0.25)";
        ctx.beginPath(); ctx.moveTo(x0-6,y); ctx.lineTo(x0,y); ctx.stroke();
        const label = `${Math.round(yVal)}${yUnit}`;
        ctx.fillText(label, x0-44, y+4);
      }

      ctx.restore();
    }

    // --------------------------
    // Ray tracing helpers
    // --------------------------
    function propagateRay(y, th, L){ return {y: y + L*th, th}; }
    function lensRay(y, th, f){ return {y, th: th - y/f}; } // thin lens f (can be negative)
    function systemRay(y, th, f, d){
      // y,th at just before first lens plane
      // pass through convex lens (f), then free space d, then concave lens (-f)
      let r1 = lensRay(y, th, f);
      let r2 = propagateRay(r1.y, r1.th, d);
      let r3 = lensRay(r2.y, r2.th, -f);
      return r3; // just after second lens
    }

    // --------------------------
    // Drawing: Diagram
    // --------------------------
    function drawDiagram(canvas, fmm, dmm){
      const {ctx,w,h} = setupCanvas(canvas);
      clear(ctx,w,h);

      const pad = 28;
      const x0 = pad, x1 = w-pad;
      const yMid = h*0.52;

      // coordinate mapping along z
      const zMin = -0.35*dmm, zMax = dmm + 0.45*dmm + 0.35*fmm;
      const mapZ = (z)=> mapX(z, zMin, zMax, x0, x1);

      // background glow band
      ctx.save();
      ctx.fillStyle = "rgba(125,211,252,0.06)";
      ctx.fillRect(x0, yMid-70, x1-x0, 140);
      ctx.restore();

      // Optical axis
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.lineWidth = 1;
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(x0, yMid);
      ctx.lineTo(x1, yMid);
      ctx.stroke();
      ctx.restore();

      const zL1 = 0;
      const zL2 = dmm;

      // Lenses: draw as stylized shapes
      function drawLens(x, type){
        ctx.save();
        const lensH = 160;
        const yTop = yMid - lensH/2;
        const yBot = yMid + lensH/2;

        // body
        ctx.fillStyle = type==="convex" ? "rgba(125,211,252,0.22)" : "rgba(167,139,250,0.22)";
        ctx.strokeStyle = "rgba(255,255,255,0.28)";
        ctx.lineWidth = 1.2;

        ctx.beginPath();
        if(type==="convex"){
          // bulge out both sides
          ctx.moveTo(x-6, yTop);
          ctx.quadraticCurveTo(x+22, yMid, x-6, yBot);
          ctx.lineTo(x+6, yBot);
          ctx.quadraticCurveTo(x-22, yMid, x+6, yTop);
          ctx.closePath();
        }else{
          // concave (pinched)
          ctx.moveTo(x-6, yTop);
          ctx.quadraticCurveTo(x-22, yMid, x-6, yBot);
          ctx.lineTo(x+6, yBot);
          ctx.quadraticCurveTo(x+22, yMid, x+6, yTop);
          ctx.closePath();
        }
        ctx.fill();
        ctx.stroke();

        // center line
        ctx.strokeStyle = "rgba(255,255,255,0.22)";
        ctx.beginPath(); ctx.moveTo(x, yTop); ctx.lineTo(x, yBot); ctx.stroke();
        ctx.restore();
      }

      drawLens(mapZ(zL1), "convex");
      drawLens(mapZ(zL2), "concave");

      // Labels
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.88)";
      ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Convex lens", mapZ(zL1)-40, yMid-95);
      ctx.fillText("Concave lens", mapZ(zL2)-45, yMid-95);

      ctx.fillStyle = "rgba(255,255,255,0.72)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillText("f", mapZ(zL1)-3, yMid-75);
      ctx.fillText("−f", mapZ(zL2)-8, yMid-75);
      ctx.restore();

      // Separation arrow
      ctx.save();
      const xA = mapZ(zL1), xB = mapZ(zL2);
      const yA = yMid + 92;
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.lineWidth = 1.2;
      ctx.beginPath(); ctx.moveTo(xA, yA); ctx.lineTo(xB, yA); ctx.stroke();
      // arrow heads
      ctx.beginPath(); ctx.moveTo(xA, yA); ctx.lineTo(xA+10, yA-5); ctx.lineTo(xA+10, yA+5); ctx.closePath(); ctx.fillStyle="rgba(255,255,255,0.55)"; ctx.fill();
      ctx.beginPath(); ctx.moveTo(xB, yA); ctx.lineTo(xB-10, yA-5); ctx.lineTo(xB-10, yA+5); ctx.closePath(); ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillText(`d = ${fmt(dmm,1)} mm`, (xA+xB)/2 - 48, yA - 10);
      ctx.restore();

      // Principal planes (for current d)
      const M = matrixFor(fmm, dmm);
      const {feff, h1, h2} = derived(M);

      // H1 at z = h1 from input plane (first lens plane)
      // H2 at z = d - h2 from input plane (because h2 is measured from output plane back toward input if negative)
      const zH1 = h1;            // measured from z=0
      const zH2 = dmm - h2;      // output plane is at z=d

      function drawPrincipal(z, label){
        const x = mapZ(z);
        ctx.save();
        ctx.strokeStyle = "rgba(52,211,153,0.70)";
        ctx.lineWidth = 1.2;
        ctx.setLineDash([5,5]);
        ctx.beginPath(); ctx.moveTo(x, yMid-95); ctx.lineTo(x, yMid+95); ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = "rgba(52,211,153,0.85)";
        ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText(label, x+6, yMid-78);
        ctx.restore();
      }

      if(isFinite(h1) && isFinite(h2)){
        drawPrincipal(zH1, "H1");
        drawPrincipal(zH2, "H2");
      }

      // Show example rays (parallel) and where they cross (approx)
      // We'll draw rays through the system pieces for a few entrance heights.
      const ys = [-10, -5, 5, 10]; // mm at first lens
      const zAfter = dmm + 0.55*dmm + 0.7*fmm;
      ctx.save();
      ctx.lineWidth = 1.4;
      ctx.strokeStyle = "rgba(125,211,252,0.85)";
      for(const yIn of ys){
        let y = yIn, th = 0;
        // segment before L1
        const zStart = -0.25*dmm;
        const xS = mapZ(zStart), yS = yMid - y;
        const xL1 = mapZ(0), yL1 = yMid - y;
        ctx.beginPath(); ctx.moveTo(xS,yS); ctx.lineTo(xL1,yL1); ctx.stroke();

        // through lens1
        ({y, th} = lensRay(y, th, fmm));

        // propagate to lens2
        const yAtL2 = y + dmm*th;
        const xL2 = mapZ(dmm), yL2 = yMid - yAtL2;
        ctx.beginPath(); ctx.moveTo(xL1, yMid - y); ctx.lineTo(xL2, yL2); ctx.stroke();
        y = yAtL2;

        // through lens2
        ({y, th} = lensRay(y, th, -fmm));

        // propagate after lens2
        const L = zAfter - dmm;
        const yEnd = y + L*th;
        const xE = mapZ(zAfter), yE = yMid - yEnd;
        ctx.strokeStyle = "rgba(167,139,250,0.85)";
        ctx.beginPath(); ctx.moveTo(xL2, yMid - y); ctx.lineTo(xE, yE); ctx.stroke();
        ctx.strokeStyle = "rgba(125,211,252,0.85)";
      }
      ctx.restore();

      // caption inside diagram
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      const info = `ABCD: A=${fmt(M.A,3)}  B=${fmt(M.B,1)}mm  C=${fmt(M.C,5)}  D=${fmt(M.D,3)}   |   f_eff=${fmt(feff,2)} mm`;
      ctx.fillText(info, x0, h-14);
      ctx.restore();
    }

    // --------------------------
    // Drawing: Main Ray plot y(z)
    // --------------------------
    function drawRayPlot(canvas, fmm, dmm, mode){
      const {ctx,w,h} = setupCanvas(canvas);
      clear(ctx,w,h);

      const plot = {x0:64, y0:44, x1:w-18, y1:h-52};
      const zMax = dmm + 2.2*fmm;         // show beyond second lens
      const zMin = -0.6*fmm;              // show some space before first lens
      const ySpan = 16;                   // +/- mm
      const yMin = -ySpan, yMax = ySpan;

      drawAxes(ctx,w,h,plot,"Ray height vs z (paraxial ray tracing)","z (mm)","y (mm)");
      drawGrid(ctx,w,h,plot.x0,plot.y0,plot.x1,plot.y1,10,8);
      drawTickLabels(ctx,plot, zMin, zMax, yMin, yMax, 6, 4, "", "");

      // draw optical element markers
      const xL1 = mapX(0, zMin, zMax, plot.x0, plot.x1);
      const xL2 = mapX(dmm, zMin, zMax, plot.x0, plot.x1);
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.50)";
      ctx.lineWidth = 1.2;
      ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(xL1, plot.y0); ctx.lineTo(xL1, plot.y1); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(xL2, plot.y0); ctx.lineTo(xL2, plot.y1); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillText("Lens 1", xL1-20, plot.y0-8);
      ctx.fillText("Lens 2", xL2-20, plot.y0-8);
      ctx.restore();

      // Equivalent-lens "focus" marker for collimated input (where rays cross after lens2).
      // For a bundle with theta_in fixed, crossing distance after lens2 is L = -y2/theta2 if theta2 != 0.
      // We'll compute for the "parallel bundle" using y_in !=0, theta_in=0.
      const M = matrixFor(fmm, dmm);

      function focusDistanceAfterLens2(yIn, thIn){
        // after second lens plane, the ray is y2, th2
        const r2 = systemRay(yIn, thIn, fmm, dmm);
        if(Math.abs(r2.th) < 1e-12) return Infinity;
        return -r2.y / r2.th; // distance from z=d to reach y=0
      }

      let thInBase = 0;
      if(mode === "tilted") thInBase = 0.03; // rad (~1.7°) for demo
      if(mode === "point") thInBase = 0; // we'll vary theta

      // choose rays
      let rays = [];
      if(mode === "parallel"){
        const ys = [-12,-6,6,12];
        rays = ys.map(y=>({yIn:y, thIn:0, label:`y=${y}mm`}));
      }else if(mode === "tilted"){
        const ys = [-12,-6,6,12];
        rays = ys.map(y=>({yIn:y, thIn:thInBase, label:`y=${y}mm`}));
      }else{
        // point at first lens plane: y=0, vary theta
        const ths = [-0.06,-0.03,0.03,0.06];
        rays = ths.map(t=>({yIn:0, thIn:t, label:`θ=${(t*1000).toFixed(0)} mrad`}));
      }

      // draw rays piecewise: before L1, between lenses, after L2
      ctx.save();
      ctx.lineWidth = 1.6;
      const colors = [
        "rgba(125,211,252,0.90)",
        "rgba(167,139,250,0.90)",
        "rgba(52,211,153,0.90)",
        "rgba(251,191,36,0.90)"
      ];

      // Determine a reasonable focus marker by averaging a couple of rays if mode is parallel
      let Lfocus = Infinity;
      if(mode === "parallel"){
        const Ls = rays.map(r=>focusDistanceAfterLens2(r.yIn, r.thIn)).filter(v=>isFinite(v));
        if(Ls.length) Lfocus = Ls.reduce((a,b)=>a+b,0)/Ls.length;
      }

      for(let i=0;i<rays.length;i++){
        const {yIn, thIn} = rays[i];
        const col = colors[i % colors.length];
        ctx.strokeStyle = col;

        // segment before lens 1
        const zA = zMin;
        const zB = 0;
        const yA = yIn + (zA - 0)*thIn; // back-propagate linearly (for display)
        const yB = yIn;

        // through lens1 and propagate to lens2
        let r1 = lensRay(yIn, thIn, fmm);
        let rAtL2 = propagateRay(r1.y, r1.th, dmm);

        // through lens2 and propagate to zMax
        let r2 = lensRay(rAtL2.y, rAtL2.th, -fmm);
        let rEnd = propagateRay(r2.y, r2.th, zMax - dmm);

        // draw three segments
        function line(z0, y0, z1, y1){
          const X0 = mapX(z0, zMin, zMax, plot.x0, plot.x1);
          const Y0 = mapY(y0, yMin, yMax, plot.y0, plot.y1);
          const X1 = mapX(z1, zMin, zMax, plot.x0, plot.x1);
          const Y1 = mapY(y1, yMin, yMax, plot.y0, plot.y1);
          ctx.beginPath(); ctx.moveTo(X0,Y0); ctx.lineTo(X1,Y1); ctx.stroke();
        }
        line(zA, yA, zB, yB);
        line(0, r1.y, dmm, rAtL2.y);
        line(dmm, r2.y, zMax, rEnd.y);
      }
      ctx.restore();

      // focus marker (only meaningful for parallel bundle demo)
      if(isFinite(Lfocus) && Lfocus > 0 && Lfocus < (zMax-dmm)){
        const zF = dmm + Lfocus;
        const xF = mapX(zF, zMin, zMax, plot.x0, plot.x1);
        const yF = mapY(0, yMin, yMax, plot.y0, plot.y1);
        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,0.70)";
        ctx.lineWidth = 1.2;
        ctx.setLineDash([4,4]);
        ctx.beginPath(); ctx.moveTo(xF, plot.y0); ctx.lineTo(xF, plot.y1); ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = "rgba(255,255,255,0.80)";
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
        ctx.fillText(`Ray crossing at z ≈ ${fmt(zF,1)} mm`, xF-85, plot.y0+16);
        ctx.beginPath(); ctx.arc(xF, yF, 4.2, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      } else if(mode === "parallel"){
        // show if crossing is at lens plane (d=f gives crossing at lens2)
        const testL = focusDistanceAfterLens2(10,0);
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.72)";
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
        if(Math.abs(testL) < 1e-6){
          ctx.fillText("Rays cross at Lens 2 plane (z = d).", plot.x0, plot.y1+40);
        }else if(!isFinite(testL)){
          ctx.fillText("Rays remain collimated after Lens 2 (no crossing).", plot.x0, plot.y1+40);
        }else{
          ctx.fillText("Ray crossing lies outside current plot window.", plot.x0, plot.y1+40);
        }
        ctx.restore();
      }

      // Legend
      ctx.save();
      const lx = plot.x1 - 190, ly = plot.y0 + 12;
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(lx, ly, 175, 86, 12);
      ctx.fill(); ctx.stroke();
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.fillText("Legend", lx+12, ly+18);
      ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      for(let i=0;i<Math.min(4, rays.length);i++){
        ctx.strokeStyle = ["rgba(125,211,252,0.90)","rgba(167,139,250,0.90)","rgba(52,211,153,0.90)","rgba(251,191,36,0.90)"][i];
        ctx.beginPath(); ctx.moveTo(lx+12, ly+30+ i*14); ctx.lineTo(lx+34, ly+30+ i*14); ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,0.70)";
        ctx.fillText(rays[i].label, lx+42, ly+34+ i*14);
      }
      ctx.restore();
    }

    // --------------------------
    // Drawing: Sweep plot f_eff vs d
    // --------------------------
    function drawSweep(canvas, fmm, dmm){
      const {ctx,w,h} = setupCanvas(canvas);
      clear(ctx,w,h);

      const plot = {x0:64, y0:44, x1:w-18, y1:h-52};
      const dMin = 0.2*fmm, dMax = 2.0*fmm;

      // feff(d)=f^2/d -> ranges from 5f down to 0.5f over this domain
      const feMin = (fmm*fmm)/dMax; // 0.5 f
      const feMax = (fmm*fmm)/dMin; // 5 f

      drawAxes(ctx,w,h,plot,"Effective focal length sweep","d (mm)","f_eff (mm)");
      drawGrid(ctx,w,h,plot.x0,plot.y0,plot.x1,plot.y1,10,8);

      // ticks
      drawTickLabels(ctx, plot, dMin, dMax, feMin, feMax, 4, 4, "", "");

      // curve
      ctx.save();
      ctx.lineWidth = 2.0;
      ctx.strokeStyle = "rgba(125,211,252,0.90)";
      ctx.beginPath();
      const N = 240;
      for(let i=0;i<=N;i++){
        const d = dMin + (dMax-dMin)*i/N;
        const fe = (fmm*fmm)/d;
        const x = mapX(d, dMin, dMax, plot.x0, plot.x1);
        const y = mapY(fe, feMin, feMax, plot.y0, plot.y1);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();

      // mark current point
      const feCurr = (fmm*fmm)/dmm;
      const xC = mapX(dmm, dMin, dMax, plot.x0, plot.x1);
      const yC = mapY(feCurr, feMin, feMax, plot.y0, plot.y1);
      ctx.save();
      ctx.fillStyle = "rgba(167,139,250,0.95)";
      ctx.beginPath(); ctx.arc(xC, yC, 5.2, 0, Math.PI*2); ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillText(`current: d=${fmt(dmm,1)}mm → f_eff=${fmt(feCurr,1)}mm`, plot.x0, plot.y1+40);
      ctx.restore();

      // highlight special point d=f where A=0
      const xF = mapX(fmm, dMin, dMax, plot.x0, plot.x1);
      ctx.save();
      ctx.strokeStyle = "rgba(52,211,153,0.75)";
      ctx.lineWidth = 1.3;
      ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(xF, plot.y0); ctx.lineTo(xF, plot.y1); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(52,211,153,0.85)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("d = f (A = 0)", xF+6, plot.y0+16);
      ctx.restore();

      // legend
      ctx.save();
      const lx = plot.x1 - 190, ly = plot.y0 + 12;
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.roundRect(lx, ly, 175, 62, 12); ctx.fill(); ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Legend", lx+12, ly+18);

      ctx.strokeStyle = "rgba(125,211,252,0.90)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(lx+12, ly+34); ctx.lineTo(lx+34, ly+34); ctx.stroke();
      ctx.fillStyle = "rgba(255,255,255,0.70)";
      ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillText("f_eff = f²/d", lx+42, ly+38);

      ctx.strokeStyle = "rgba(52,211,153,0.75)";
      ctx.lineWidth = 1.3;
      ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(lx+12, ly+50); ctx.lineTo(lx+34, ly+50); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(255,255,255,0.70)";
      ctx.fillText("d=f (A=0)", lx+42, ly+54);

      ctx.restore();
    }

    // --------------------------
    // UI wiring
    // --------------------------
    const sepEl = document.getElementById("sep");
    const fEl = document.getElementById("fval");
    const modeEl = document.getElementById("mode");

    const sepRead = document.getElementById("sepRead");
    const fRead = document.getElementById("fRead");
    const modeRead = document.getElementById("modeRead");

    const Aout = document.getElementById("Aout");
    const Bout = document.getElementById("Bout");
    const Cout = document.getElementById("Cout");
    const Dout = document.getElementById("Dout");
    const feffOut = document.getElementById("feffOut");
    const h1Out = document.getElementById("h1Out");
    const h2Out = document.getElementById("h2Out");
    const liveText = document.getElementById("liveText");

    const cDiagram = document.getElementById("cDiagram");
    const cRayPlot = document.getElementById("cRayPlot");
    const cSweep = document.getElementById("cSweep");

    function update(){
      const fmm = Number(fEl.value);        // example focal length in mm
      const ratio = Number(sepEl.value);    // d/f
      const dmm = ratio * fmm;
      const mode = modeEl.value;

      sepRead.textContent = `d = ${ratio.toFixed(2)} f`;
      fRead.textContent = `f = ${fmm.toFixed(0)} mm`;
      modeRead.textContent =
        mode==="parallel" ? "Parallel bundle (θ_in = 0)" :
        mode==="tilted" ? "Tilted bundle (fixed θ_in)" :
        "Point source at Lens 1 plane";

      const M = matrixFor(fmm, dmm);
      const {feff, h1, h2} = derived(M);

      Aout.textContent = fmt(M.A,4);
      Bout.textContent = `${fmt(M.B,2)} mm`;
      Cout.textContent = `${fmt(M.C,6)} 1/mm`;
      Dout.textContent = fmt(M.D,4);

      feffOut.textContent = fmtLenMM(feff);
      h1Out.textContent = fmtLenMM(h1);
      h2Out.textContent = fmtLenMM(h2);

      liveText.textContent =
`Using thin-lens + free-space matrices:

M(d)=L(−f)·T(d)·L(f)

Numerically (example f=${fmm.toFixed(0)} mm, d=${dmm.toFixed(1)} mm):
A = ${fmt(M.A,6)}
B = ${fmt(M.B,6)} mm
C = ${fmt(M.C,8)} 1/mm
D = ${fmt(M.D,6)}

Derived:
f_eff = −1/C = ${isFinite(feff)? fmt(feff,3)+' mm' : '∞'}
h1 = (A−1)/C = ${isFinite(h1)? fmt(h1,3)+' mm' : '∞'}
h2 = (D−1)/C = ${isFinite(h2)? fmt(h2,3)+' mm' : '∞'}`;

      drawDiagram(cDiagram, fmm, dmm);
      drawRayPlot(cRayPlot, fmm, dmm, mode);
      drawSweep(cSweep, fmm, dmm);
    }

    sepEl.addEventListener("input", update);
    fEl.addEventListener("input", update);
    modeEl.addEventListener("change", update);
    window.addEventListener("resize", update);

    // kick off
    update();
  </script>
</body>
</html>
