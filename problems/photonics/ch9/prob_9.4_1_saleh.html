<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Coupling Coefficient Between Two Identical Slab Waveguides (TE0) — Coupled-Mode Tutorial + Interactive Plots</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101a33;
      --card:#0f1730;
      --text:#e9ecf6;
      --muted:#b8c0dd;
      --faint:#7f8ab3;
      --accent:#7dd3fc;
      --accent2:#a7f3d0;
      --warn:#fbbf24;
      --good:#34d399;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --line2:rgba(125,211,252,.22);
      --shadow: 0 18px 50px rgba(0,0,0,.45);
      --radius:18px;
      --radius2:26px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1100px 600px at 20% -10%, rgba(125,211,252,.18), transparent 60%),
        radial-gradient(900px 650px at 90% 0%, rgba(167,243,208,.14), transparent 55%),
        radial-gradient(800px 600px at 60% 110%, rgba(251,191,36,.10), transparent 60%),
        linear-gradient(180deg, #060914, #050716 40%, #060a18);
      line-height:1.55;
    }

    header{
      position:relative;
      padding: 56px 18px 22px;
      border-bottom:1px solid var(--line);
      overflow:hidden;
    }
    header .wrap{
      max-width:1150px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 900px){
      header .wrap{grid-template-columns:1fr}
    }
    h1{
      margin:0 0 10px;
      font-size: clamp(1.55rem, 2.4vw, 2.35rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      max-width:72ch;
      font-size:1.02rem;
    }

    .meta{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:14px 14px 12px;
      box-shadow: var(--shadow);
    }
    .meta h3{
      margin:0 0 8px;
      font-size:1.02rem;
      letter-spacing:.2px;
      color:#dbe6ff;
    }
    .meta .row{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:6px 0;
      border-top:1px dashed rgba(255,255,255,.10);
      font-size:.95rem;
      color:var(--muted);
    }
    .meta .row:first-of-type{border-top:none}
    .meta .k{
      color:#d8e2ff;
      font-weight:600;
    }

    main{
      max-width:1150px;
      margin: 0 auto;
      padding: 18px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
    }

    nav.toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding: 14px 12px;
      box-shadow: var(--shadow);
    }
    nav.toc .title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    nav.toc h2{
      margin:0;
      font-size:1.02rem;
      color:#dbe6ff;
      letter-spacing:.2px;
    }
    .toc small{color:var(--faint)}
    .toc a{
      display:block;
      color:var(--muted);
      text-decoration:none;
      padding:8px 10px;
      border-radius:12px;
      transition: transform .12s ease, background .12s ease;
      border:1px solid transparent;
      font-size:.95rem;
    }
    .toc a:hover{
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.18);
      transform: translateY(-1px);
      color:#eaf3ff;
    }

    .content{
      display:flex;
      flex-direction:column;
      gap:18px;
    }

    section{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    section > header{
      padding: 16px 18px 12px;
      border-bottom:1px solid var(--line);
      background: rgba(0,0,0,.10);
    }
    section > header h2{
      margin:0;
      font-size:1.18rem;
      letter-spacing:.2px;
    }
    section > header p{
      margin:6px 0 0;
      color:var(--muted);
      max-width: 90ch;
    }
    section .body{
      padding: 16px 18px 18px;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 900px){
      .grid2{grid-template-columns:1fr}
    }

    .callout{
      background: rgba(0,0,0,.16);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      padding: 12px 12px 10px;
    }
    .callout h3{
      margin:0 0 8px;
      font-size:1.02rem;
      color:#dbe6ff;
    }
    .callout ul{margin:8px 0 0 18px; color:var(--muted)}
    .callout p{margin:8px 0 0; color:var(--muted)}
    .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:4px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(125,211,252,.10);
      color:#eaf6ff;
      font-size:.88rem;
      margin: 0 8px 8px 0;
      white-space:nowrap;
    }
    .tag .dot{
      width:8px;height:8px;border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(125,211,252,.12);
    }

    .eq{
      font-family: var(--mono);
      font-size: .96rem;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(125,211,252,.18);
      border-radius: 14px;
      padding: 10px 10px;
      color: #eaf3ff;
      overflow:auto;
      position:relative;
    }
    .eq .copyBtn{
      position:absolute;
      top:10px;
      right:10px;
    }

    .copyBtn{
      appearance:none;
      border:none;
      padding:8px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:650;
      color:#06101f;
      background: linear-gradient(180deg, rgba(125,211,252,.95), rgba(125,211,252,.70));
      box-shadow: 0 10px 26px rgba(0,0,0,.25);
      transition: transform .12s ease, filter .12s ease;
      font-size:.86rem;
      letter-spacing:.2px;
    }
    .copyBtn:hover{transform: translateY(-1px); filter: brightness(1.05)}
    .copyBtn:active{transform: translateY(0px); filter: brightness(.98)}
    .copyBtn.alt{
      background: linear-gradient(180deg, rgba(167,243,208,.92), rgba(167,243,208,.68));
    }
    .copyBtn.ghost{
      background: rgba(255,255,255,.06);
      color: var(--text);
      border:1px solid rgba(255,255,255,.14);
      box-shadow:none;
    }

    .mathline{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin:10px 0 0;
      color:var(--muted);
      font-size:.96rem;
    }
    .mathline code{
      font-family: var(--mono);
      background: rgba(255,255,255,.06);
      padding:2px 6px;
      border-radius: 9px;
      border:1px solid rgba(255,255,255,.10);
      color:#eaf3ff;
    }

    figure{
      margin:0;
      padding: 12px;
    }
    .vizCard{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.16);
      border-radius: 18px;
      overflow:hidden;
    }
    .vizTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 12px 12px 10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.10);
    }
    .vizTop h3{
      margin:0;
      font-size:1.02rem;
      color:#dbe6ff;
    }
    .vizTop .small{
      color:var(--faint);
      font-size:.9rem;
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
      background: radial-gradient(800px 360px at 15% 10%, rgba(125,211,252,.08), transparent 55%),
                  radial-gradient(700px 320px at 85% 20%, rgba(167,243,208,.06), transparent 55%),
                  rgba(0,0,0,.10);
    }
    .canvasTall{height: 360px;}
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      align-items:center;
      padding: 12px;
      border-top:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.10);
    }
    .control{
      flex: 1 1 220px;
      min-width: 220px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 10px 10px 8px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:.92rem;
      color:var(--muted);
      margin-bottom:8px;
    }
    .control input[type="range"]{width:100%}
    .readout{
      font-family: var(--mono);
      color:#eaf3ff;
      font-size:.95rem;
    }
    .pill{
      display:inline-block;
      font-family: var(--mono);
      padding: 2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:#eaf3ff;
    }

    .finalBox{
      border:1px solid rgba(52,211,153,.22);
      background: linear-gradient(180deg, rgba(52,211,153,.12), rgba(0,0,0,.18));
      border-radius: 18px;
      padding: 12px 12px 10px;
      position:relative;
      overflow:hidden;
    }
    .finalBox h3{
      margin:0 0 8px;
      color:#dcfff2;
      letter-spacing:.2px;
    }
    .finalBox .copyBtn{position:absolute; top:12px; right:12px;}
    .finalBox .lines{
      font-family: var(--mono);
      color:#eafff7;
      font-size: .98rem;
      white-space: pre-wrap;
    }

    .note{
      color:var(--muted);
      font-size:.98rem;
    }

    .cols{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 980px){
      .cols{grid-template-columns:1fr}
    }

    footer{
      max-width:1150px;
      margin: 0 auto;
      padding: 18px 18px 40px;
      color: var(--faint);
      font-size:.95rem;
    }

    /* Subtle animation */
    @media (prefers-reduced-motion: no-preference){
      section{
        animation: floatIn .45s ease both;
        transform-origin: 50% 0%;
      }
      @keyframes floatIn{
        from{opacity:0; transform: translateY(10px) scale(.99)}
        to{opacity:1; transform: translateY(0) scale(1)}
      }
    }

    /* Print-friendly */
    @media print{
      body{background:#fff; color:#000}
      header, nav.toc{position:static; box-shadow:none}
      section, .meta{box-shadow:none}
      .copyBtn{display:none !important}
      canvas{height:260px}
      a{color:#000; text-decoration:underline}
    }
  </style>
</head>

<body>
<header>
  <div class="wrap">
    <div>
      <h1>Coupling Coefficient Between Two Identical Slab Waveguides (TE<sub>0</sub>)</h1>
      <p class="subtitle">
        A mini-lecture + full worked solution using coupled-mode theory for two parallel identical slab waveguides.
        You’ll compute the coupling coefficient <span class="pill">κ</span> from an overlap integral, then find the
        3-dB coupler length. Interactive plots let you vary the separation and see how power transfer changes.
      </p>
      <div class="mathline">
        <span class="tag"><span class="dot"></span>Coupled-mode theory</span>
        <span class="tag"><span class="dot" style="background:var(--accent2)"></span>Slab TE modes</span>
        <span class="tag"><span class="dot" style="background:var(--warn)"></span>3-dB directional coupler</span>
      </div>
    </div>

    <aside class="meta" aria-label="Problem parameters">
      <h3>Given (default)</h3>
      <div class="row"><span class="k">Core index</span><span>n<sub>1</sub>=n<sub>2</sub>=1.48</span></div>
      <div class="row"><span class="k">Cladding index</span><span>n=1.46</span></div>
      <div class="row"><span class="k">Slab width</span><span>d=0.5 μm</span></div>
      <div class="row"><span class="k">Separation</span><span>2a=1.0 μm (a=0.5 μm)</span></div>
      <div class="row"><span class="k">Wavelength</span><span>λ<sub>0</sub>=0.85 μm</span></div>
      <div class="row"><span class="k">Mode</span><span>TE, m=0 (even)</span></div>
      <div class="row"><span class="k">Goal</span><span>κ and 3-dB length</span></div>
    </aside>
  </div>
</header>

<main>
  <nav class="toc" aria-label="Table of contents">
    <div class="title">
      <h2>Contents</h2>
      <small>sticky</small>
    </div>
    <a href="#quick">Quick Summary</a>
    <a href="#primer">PART 0 — Concept Primer</a>
    <a href="#analysis">PART 1 — Problem Analysis</a>
    <a href="#strategy">PART 2 — Strategy & Tips</a>
    <a href="#solution">PART 3 — Full Solution</a>
    <a href="#deeper">PART 4 — Deeper Understanding</a>
    <a href="#vizguide">PART 5 — Visualization Guide</a>
  </nav>

  <div class="content">

    <!-- QUICK SUMMARY -->
    <section id="quick">
      <header>
        <h2>Quick Summary</h2>
        <p>What we’re doing, the key physics, and what we will output (numeric + reusable formulas).</p>
      </header>
      <div class="body">
        <ul>
          <li><b>Problem:</b> Two <b>identical</b> slab waveguides (TE<sub>0</sub>) are placed side-by-side. Find the <b>coupling coefficient</b> between them using an overlap integral, then find the <b>3-dB coupler length</b>.</li>
          <li><b>Key idea:</b> Weak evanescent overlap makes the modal amplitudes exchange energy; coupled-mode theory models this with <b>first-order ODEs</b>.</li>
          <li><b>Governing equations (identical guides):</b> <span class="pill">P<sub>2</sub>(z)=sin²(κz)</span>, <span class="pill">P<sub>1</sub>(z)=cos²(κz)</span> (when Δβ=0 and power starts in guide 1).</li>
          <li><b>Coupling coefficient (from the text’s Eq. 9.4-6):</b> κ is proportional to <b>(n<sub>core</sub>²−n<sub>clad</sub>²)</b> times an <b>overlap integral</b> of the isolated-guide transverse fields over the other core.</li>
          <li><b>Mode shapes used:</b> TE slab even mode: <b>cosine in the core</b> and <b>exponential decay in the cladding</b>; we normalize the transverse field.</li>
          <li><b>Numeric result for the given parameters:</b> κ ≈ <b>0.0165 μm⁻¹</b> (≈16.5 mm⁻¹), giving a <b>3-dB length</b> L<sub>3dB</sub> = π/(4κ) ≈ <b>47.6 μm</b>.</li>
          <li><b>Final result type:</b> (i) a computed κ from a defined integral, (ii) a computed device length for 3-dB power split.</li>
        </ul>
      </div>
    </section>

    <!-- PART 0: PRIMER -->
    <section id="primer">
      <header>
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>
        <p>A short textbook-style mini-lecture: what κ means, how slab TE modes look, and what assumptions make coupled-mode theory valid.</p>
      </header>
      <div class="body">
        <div class="grid2">
          <article class="callout">
            <h3>Core definitions (symbols & units)</h3>
            <ul>
              <li><b>Propagation constant</b> β (units: m⁻¹ or μm⁻¹): phase advance per unit length along z.</li>
              <li><b>Effective index</b> n<sub>eff</sub> = β/k<sub>0</sub> (dimensionless), where k<sub>0</sub> = 2π/λ<sub>0</sub>.</li>
              <li><b>Coupling coefficient</b> κ (units: m⁻¹ or μm⁻¹): rate at which amplitude transfers between guides (larger κ → faster transfer).</li>
              <li><b>Phase mismatch</b> Δβ = β<sub>1</sub> − β<sub>2</sub> (units: m⁻¹). For <b>identical</b> guides, Δβ = 0.</li>
              <li><b>Transverse field</b> u(y): normalized mode profile in the y-direction (dimension: 1/√length if normalized so ∫|u|²dy=1).</li>
            </ul>
          </article>

          <article class="callout">
            <h3>Physical meaning</h3>
            <p>
              Each isolated waveguide supports a bound mode whose field leaks evanescently into the cladding.
              When a second guide is nearby, this evanescent “tail” overlaps the other core and can <b>drive</b>
              its mode. The result is <b>periodic power exchange</b>, like two weakly coupled oscillators.
            </p>
            <ul>
              <li>κ is essentially “how much of guide 1’s field lives inside guide 2’s core” (weighted by index contrast).</li>
              <li>For identical guides, the coupling is strongest when Δβ=0 → clean sinusoidal swapping.</li>
            </ul>
          </article>
        </div>

        <div class="grid2" style="margin-top:14px;">
          <article class="callout">
            <h3>Key laws / validity conditions</h3>
            <ul>
              <li><b>Linear, lossless, weak coupling</b>: modal shapes of each isolated guide are only slightly perturbed by the other.</li>
              <li><b>Single-mode per guide</b> (here TE<sub>0</sub>): no coupling to higher modes is considered.</li>
              <li><b>Slowly varying amplitudes</b>: a<sub>1</sub>(z), a<sub>2</sub>(z) change slowly compared with the optical period.</li>
              <li><b>Scalar TE slab model</b>: for TE, E is transverse; using a scalar Helmholtz form is accurate for planar guides under standard approximations.</li>
            </ul>
          </article>

          <article class="callout">
            <h3>Common models / approximations (why we use them)</h3>
            <ul>
              <li><b>Piecewise-constant index</b>: slab core n<sub>1</sub>, cladding n. Makes mode shapes analytic: cosine + exponential.</li>
              <li><b>Weak guidance</b> (small Δn): n<sub>eff</sub> close to n, and field penetrates cladding noticeably. This often increases coupling sensitivity to separation.</li>
              <li><b>Overlap-integral κ</b>: avoids solving the full 2-core eigenproblem; good when coupling is not too strong.</li>
            </ul>
          </article>
        </div>

        <article class="callout" style="margin-top:14px;">
          <h3>Mini intuition examples (no long algebra)</h3>
          <ul>
            <li><b>If you increase separation</b> (bigger gap), the evanescent tails decay more before reaching the other core → κ drops roughly <b>exponentially</b> → power transfer length grows.</li>
            <li><b>If you increase index contrast</b> (bigger n<sub>1</sub>−n), the mode becomes more confined (smaller tail) which can <b>reduce</b> coupling, even though the coupling prefactor contains (n<sub>1</sub>²−n²). Net effect depends on confinement vs prefactor.</li>
          </ul>
        </article>

        <article class="callout" style="margin-top:14px;">
          <h3>What to watch for (pitfalls)</h3>
          <ul>
            <li><b>Normalization:</b> κ depends on how u(y) is normalized. Use a consistent normalization (here ∫|u|²dy=1).</li>
            <li><b>Geometry bookkeeping:</b> clearly define where each core begins/ends (the limits in the integral matter).</li>
            <li><b>Units:</b> mixing μm and m will cause huge errors. Keep everything in μm (then κ is in μm⁻¹).</li>
            <li><b>Δβ:</b> identical guides → Δβ=0; if not, the maximum transferable power can be <b>&lt; 100%</b>.</li>
          </ul>
        </article>
      </div>
    </section>

    <!-- PART 1: PROBLEM ANALYSIS -->
    <section id="analysis">
      <header>
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>
        <p>We restate the task in clear language, list givens/unknowns, identify the governing physics, and choose an approach.</p>
      </header>
      <div class="body">
        <article class="callout">
          <h3>Restatement (in plain words)</h3>
          <p>
            Two identical dielectric slab waveguides (each thickness <b>d=0.5 μm</b>) are separated by a cladding gap of width <b>2a=1.0 μm</b>.
            They sit in a medium of index <b>n=1.46</b>, while the cores have <b>n<sub>1</sub>=n<sub>2</sub>=1.48</b>.
            At wavelength <b>λ<sub>0</sub>=0.85 μm</b>, each guide supports the <b>TE, m=0</b> mode.
            (a) Use the overlap-integral formula (Eq. 9.4-6) to find the coupling coefficient κ. (b) Find the length that yields a <b>3-dB coupler</b> (equal power split).
          </p>
        </article>

        <div class="grid2" style="margin-top:14px;">
          <article class="callout">
            <h3>Given quantities</h3>
            <ul>
              <li>d = 0.5 μm (core width)</li>
              <li>2a = 1.0 μm → a = 0.5 μm (half-gap in the book’s coordinate convention)</li>
              <li>n<sub>1</sub> = n<sub>2</sub> = 1.48 (core indices)</li>
              <li>n = 1.46 (surrounding medium)</li>
              <li>λ<sub>0</sub> = 0.85 μm</li>
              <li>Mode: TE, m=0 (even)</li>
            </ul>
          </article>

          <article class="callout">
            <h3>Unknowns (what we must find)</h3>
            <ul>
              <li>(a) Coupling coefficient κ (μm⁻¹)</li>
              <li>(b) 3-dB length L<sub>3dB</sub> (μm), where output powers are equal</li>
            </ul>
          </article>
        </div>

        <article class="callout" style="margin-top:14px;">
          <h3>Relevant principles & why they apply</h3>
          <ul>
            <li><b>Slab waveguide eigenmodes:</b> we need u(y) and β for the isolated TE<sub>0</sub> mode to evaluate the overlap integral.</li>
            <li><b>Coupled-mode theory (CMT):</b> the interaction is weak (separated guides), so we can treat coupling as a perturbation → first-order ODEs for modal amplitudes.</li>
            <li><b>Why not full 2-core eigenproblem?</b> It’s heavier; CMT gives κ directly and is standard for directional couplers when coupling is not extremely strong.</li>
          </ul>
        </article>

        <article class="callout" style="margin-top:14px;">
          <h3>Assumptions (explicit)</h3>
          <ul>
            <li>Lossless, linear dielectrics; time-harmonic steady state.</li>
            <li>Single guided mode per slab (TE<sub>0</sub> only).</li>
            <li>Weak coupling: each mode shape is close to the isolated-guide mode.</li>
            <li>Identical guides → β<sub>1</sub>=β<sub>2</sub> → Δβ=0.</li>
            <li>Scalar TE slab model for u(y): cosine in core, exponential in cladding.</li>
          </ul>
        </article>

        <article class="callout" style="margin-top:14px;">
          <h3>Possible approaches (compare & choose)</h3>
          <ul>
            <li><b>(A) Overlap-integral CMT (Eq. 9.4-6):</b> compute isolated mode, normalize, integrate overlap over the other core. <b>Best</b> for fast, interpretable κ.</li>
            <li><b>(B) Supermode splitting:</b> solve the two-core structure for even/odd supermodes and use κ ≈ (β<sub>+</sub>−β<sub>−</sub>)/2. Accurate but requires solving a more complex eigenproblem.</li>
            <li><b>(C) Full numerical EM simulation:</b> most general, but overkill for a textbook problem and not “hand-calculable”.</li>
          </ul>
          <p><b>Chosen:</b> (A) because the problem explicitly requests Eq. (9.4-6) and provides the single-slab mode as the ingredient.</p>
        </article>
      </div>
    </section>

    <!-- PART 2: STRATEGY -->
    <section id="strategy">
      <header>
        <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>
        <p>A short plan you can reuse for similar coupler problems.</p>
      </header>
      <div class="body">
        <ol style="margin:0 0 0 18px; color:var(--muted)">
          <li><b>Compute k<sub>0</sub></b> from λ<sub>0</sub> (keep units consistent, here μm).</li>
          <li><b>Solve the single-slab TE<sub>0</sub> dispersion</b> to get β and transverse parameters (core oscillation k<sub>y</sub> and cladding decay α).</li>
          <li><b>Write the isolated mode profile</b> u(y): cosine in the core, exponential outside; define the core half-width t=d/2.</li>
          <li><b>Normalize u(y)</b> using ∫|u(y)|²dy = 1 (so κ comes out with the right magnitude).</li>
          <li><b>Shift the coordinate</b> so guide 1 is centered at y=−(a+t) and guide 2 at y=+(a+t).</li>
          <li><b>Evaluate the overlap integral</b> over the second core region y∈[a, a+d] (as in Eq. 9.4-6) using u<sub>1</sub>(y)u<sub>2</sub>(y).</li>
          <li><b>Compute κ</b> from Eq. 9.4-6. For identical guides, κ = C<sub>12</sub> = C<sub>21</sub>.</li>
          <li><b>Use power-exchange law</b> for Δβ=0: P<sub>2</sub>(z)=sin²(κz). Set P<sub>2</sub>=0.5 to get L<sub>3dB</sub>=π/(4κ).</li>
          <li><b>Sanity checks</b>: units, limiting case a→∞ gives κ→0, and the resulting length scales like 1/κ.</li>
        </ol>

        <div class="grid2" style="margin-top:14px;">
          <article class="callout">
            <h3>Quick tips</h3>
            <ul>
              <li>Use μm everywhere: then k<sub>0</sub>, β, κ are in μm⁻¹ and lengths come out in μm.</li>
              <li>For large separations, you can approximate the overlap by the exponential tail inside the other core (explains the near-exponential κ vs gap).</li>
              <li>For identical guides, the 3-dB length is always <b>π/(4κ)</b> (easy to remember).</li>
            </ul>
          </article>
          <article class="callout">
            <h3>Common mistakes</h3>
            <ul>
              <li>Forgetting that the overlap integral in Eq. 9.4-6 is over the <b>core region</b> of the other guide.</li>
              <li>Using an unnormalized u(y) and getting κ off by a large factor.</li>
              <li>Mixing meters and micrometers when computing k<sub>0</sub>.</li>
              <li>Using L<sub>3dB</sub>=π/(2κ) (that’s the <b>full transfer</b> length, not 3-dB).</li>
            </ul>
          </article>
        </div>
      </div>
    </section>

    <!-- PART 3: FULL SOLUTION -->
    <section id="solution">
      <header>
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>
        <p>We first build intuition, then compute the TE<sub>0</sub> mode, then evaluate κ and the 3-dB length with checks.</p>
      </header>
      <div class="body">

        <article class="callout">
          <h3>Qualitative expectation (before math)</h3>
          <p>
            Because the slabs are separated by a finite cladding gap, the guided fields leak into the gap and overlap.
            That overlap should be <b>small</b> (weak coupling) and should shrink fast as separation increases. Therefore:
          </p>
          <ul>
            <li>κ should be <b>positive</b> and <b>small</b> (μm⁻¹),</li>
            <li>Power exchange should be <b>sinusoidal</b> with z,</li>
            <li>3-dB length should be on the order of <b>tens of μm</b> for these micron-scale dimensions (we’ll confirm).</li>
          </ul>
        </article>

        <div class="callout" style="margin-top:14px;">
          <h3>Step 1 — Constants and single-slab parameters</h3>
          <p>We work in <b>μm</b>. The free-space wavenumber is:</p>
          <div class="eq" data-copy="k0 = 2π/λ0">
            <button class="copyBtn" type="button" data-copy-btn>Copy</button>
            <div><b>k0</b> = 2π / λ0</div>
          </div>

          <p class="note" style="margin-top:10px;">
            With λ<sub>0</sub>=0.85 μm, we have k<sub>0</sub> = 2π/0.85 ≈ 7.392 μm⁻¹.
          </p>
        </div>

        <div class="callout" style="margin-top:14px;">
          <h3>Step 2 — TE slab mode shape and dispersion</h3>
          <p>
            Let the <b>single</b> slab have core index n<sub>1</sub> and cladding n, and thickness d. Define half-thickness
            t = d/2. For the even TE<sub>0</sub> mode, the transverse field (scalar TE profile) is:
          </p>

          <div class="eq" data-copy="u(y) = A cos(ky y), |y|≤t;  u(y) = A cos(ky t) exp[-α(|y|-t)], |y|>t">
            <button class="copyBtn" type="button" data-copy-btn>Copy</button>
            <div><b>Mode profile (even TE0)</b></div>
            <div style="margin-top:6px;">
              u(y) = A cos(k<sub>y</sub> y), &nbsp; |y| ≤ t<br/>
              u(y) = A cos(k<sub>y</sub> t) exp[ −α(|y|−t) ], &nbsp; |y| &gt; t
            </div>
          </div>

          <p style="margin-top:10px;">
            Here k<sub>y</sub> is the oscillation constant in the core, and α is the cladding decay constant.
            They relate to β via:
          </p>

          <div class="eq" data-copy="ky^2 = (n1 k0)^2 - β^2,   α^2 = β^2 - (n k0)^2">
            <button class="copyBtn" type="button" data-copy-btn>Copy</button>
            <div><b>Core/Cladding relations</b></div>
            <div style="margin-top:6px;">
              k<sub>y</sub><sup>2</sup> = (n<sub>1</sub>k<sub>0</sub>)<sup>2</sup> − β<sup>2</sup>, &nbsp;&nbsp;
              α<sup>2</sup> = β<sup>2</sup> − (n k<sub>0</sub>)<sup>2</sup>
            </div>
          </div>

          <p style="margin-top:10px;">
            The boundary conditions for TE fields lead to the standard even-mode dispersion:
          </p>

          <div class="eq" data-copy="u tan u = w,  where u=ky t, w=α t, and u^2+w^2 = V^2 with V=k0 t sqrt(n1^2-n^2)">
            <button class="copyBtn" type="button" data-copy-btn>Copy</button>
            <div><b>Even TE dispersion (single slab)</b></div>
            <div style="margin-top:6px;">
              u tan u = w<br/>
              u = k<sub>y</sub> t, &nbsp; w = α t, &nbsp; u² + w² = V²<br/>
              V = k<sub>0</sub> t √(n<sub>1</sub><sup>2</sup> − n<sup>2</sup>)
            </div>
          </div>

          <p class="note" style="margin-top:10px;">
            For the given numbers (n<sub>1</sub>=1.48, n=1.46, d=0.5 μm ⇒ t=0.25 μm, λ<sub>0</sub>=0.85 μm),
            the normalized frequency is V ≈ 0.448 (small), so only the fundamental TE<sub>0</sub> mode exists.
          </p>
        </div>

        <div class="callout" style="margin-top:14px;">
          <h3>Step 3 — Normalization of u(y)</h3>
          <p>
            We normalize the isolated mode so that:
            <span class="pill">∫<sub>−∞</sub><sup>∞</sup> |u(y)|² dy = 1</span>.
            With the cosine+exponential form, the integral can be done in closed form:
          </p>

          <div class="eq" data-copy="I = ∫|u|^2 dy = A^2[ t + sin(2ky t)/(2ky) + cos^2(ky t)/α ] = 1  ⇒  A = 1/sqrt( t + sin(2ky t)/(2ky) + cos^2(ky t)/α )">
            <button class="copyBtn" type="button" data-copy-btn>Copy</button>
            <div><b>Normalization constant</b></div>
            <div style="margin-top:6px;">
              1 = ∫ |u(y)|² dy = A²<span style="white-space:nowrap;">[ t + sin(2k<sub>y</sub>t)/(2k<sub>y</sub>) + cos²(k<sub>y</sub>t)/α ]</span><br/>
              ⇒ A = 1 / √( t + sin(2k<sub>y</sub>t)/(2k<sub>y</sub>) + cos²(k<sub>y</sub>t)/α )
            </div>
          </div>

          <p class="note" style="margin-top:10px;">
            Physically: the first two terms are the energy in the oscillatory core; the last term is the energy in the evanescent tails.
          </p>
        </div>

        <div class="callout" style="margin-top:14px;">
          <h3>Step 4 — Coupled-mode coefficient κ from Eq. (9.4-6)</h3>
          <p>
            The book’s coupling coefficient between guide 1 and guide 2 (for the geometry shown in the problem statement) is:
          </p>

          <div class="eq" data-copy="C21 = (1/2)*((n2^2 - n^2) k0^2 / β1) * ∫_{y=a}^{a+d} u1(y) u2(y) dy   (identical: κ = C12 = C21)">
            <button class="copyBtn" type="button" data-copy-btn>Copy</button>
            <div><b>Eq. (9.4-6) (specialized wording)</b></div>
            <div style="margin-top:6px;">
              C<sub>21</sub> = ½ · (n<sub>2</sub><sup>2</sup> − n<sup>2</sup>) · k<sub>0</sub><sup>2</sup> / β<sub>1</sub> ·
              ∫<sub>a</sub><sup>a+d</sup> u<sub>1</sub>(y) u<sub>2</sub>(y) dy<br/>
              (identical guides ⇒ κ = C<sub>12</sub> = C<sub>21</sub>)
            </div>
          </div>

          <p style="margin-top:10px;">
            Geometry bookkeeping (matching the integral limits):
          </p>
          <ul style="margin:8px 0 0 18px; color:var(--muted)">
            <li>Guide 2 core occupies y ∈ [a, a+d].</li>
            <li>Guide 1 core occupies y ∈ [−a−d, −a].</li>
            <li>The cladding gap is between y = −a and y = +a, so the total separation between inner core faces is 2a.</li>
          </ul>

          <p class="note" style="margin-top:10px;">
            Since the guides are identical (n<sub>1</sub>=n<sub>2</sub> and same d), we also have β<sub>1</sub>=β<sub>2</sub> so Δβ=0,
            and coupling is symmetric.
          </p>
        </div>

        <div class="callout" style="margin-top:14px;">
          <h3>Step 5 — Power transfer and 3-dB length</h3>
          <p>
            With identical guides (Δβ=0) and initial condition a<sub>1</sub>(0)=1, a<sub>2</sub>(0)=0, the coupled-mode solution is:
          </p>

          <div class="eq" data-copy="P2(z) = sin^2(κ z),  P1(z) = cos^2(κ z)   (Δβ=0)">
            <button class="copyBtn" type="button" data-copy-btn>Copy</button>
            <div><b>Power exchange (identical guides)</b></div>
            <div style="margin-top:6px;">
              P<sub>2</sub>(z) = sin²(κ z), &nbsp; P<sub>1</sub>(z) = cos²(κ z) &nbsp; (Δβ = 0)
            </div>
          </div>

          <p style="margin-top:10px;">
            A <b>3-dB coupler</b> means equal power split: P<sub>1</sub>=P<sub>2</sub>=1/2. That occurs when:
            sin²(κL)=1/2 ⇒ κL = π/4. Therefore:
          </p>

          <div class="eq" data-copy="L3dB = π/(4 κ)   (identical, phase-matched coupler)">
            <button class="copyBtn alt" type="button" data-copy-btn>Copy</button>
            <div><b>3-dB length</b></div>
            <div style="margin-top:6px;">
              L<sub>3dB</sub> = π / (4κ)
            </div>
          </div>
        </div>

        <div class="finalBox" style="margin-top:14px;">
          <button class="copyBtn alt" type="button" id="copyFinal">Copy final answer</button>
          <h3>Final numeric answer (for the given parameters)</h3>
          <div class="lines" id="finalText">Loading…</div>
        </div>

        <article class="callout" style="margin-top:14px;">
          <h3>Sanity checks</h3>
          <ul>
            <li><b>Units:</b> k<sub>0</sub>²/β has units 1/length; the integral contributes length; κ ends up 1/length ✅</li>
            <li><b>Limiting case a→∞:</b> overlap integral → 0 ⇒ κ→0 ⇒ L<sub>3dB</sub>→∞ ✅</li>
            <li><b>Sign:</b> with positive index contrast and positive overlap, κ &gt; 0; power oscillations depend on κ magnitude, not sign ✅</li>
            <li><b>Scale:</b> κ ~ 0.01–0.02 μm⁻¹ implies L<sub>3dB</sub> ~ (π)/(4·0.01–0.02) ≈ 40–80 μm → plausible ✅</li>
          </ul>
          <p class="note">
            The plots below connect directly: κ sets the oscillation period of power exchange and the 3-dB point.
          </p>
        </article>

        <!-- VISUALIZATIONS -->
        <figure class="vizCard" aria-label="Interactive visualizations">
          <div class="vizTop">
            <div>
              <h3>Interactive Visualizations</h3>
              <div class="small">Adjust separation and see κ, L<sub>3dB</sub>, and power transfer update live.</div>
            </div>
            <button class="copyBtn ghost" type="button" id="resetBtn">Reset</button>
          </div>

          <canvas id="diag" class="canvasTall" aria-label="Diagram canvas"></canvas>

          <canvas id="plotMain" aria-label="Main plot canvas"></canvas>

          <canvas id="plotSweep" aria-label="Secondary plot canvas"></canvas>

          <div class="controls" aria-label="Controls">
            <div class="control">
              <label>
                <span>Separation <b>2a</b> (μm)</span>
                <span class="readout" id="sepRead">1.00</span>
              </label>
              <input id="sep" type="range" min="0.60" max="2.00" value="1.00" step="0.01" />
              <div class="note" style="margin-top:6px;">
                Larger 2a → smaller overlap → smaller κ → longer L<sub>3dB</sub>.
              </div>
            </div>

            <div class="control">
              <label>
                <span>z-range multiplier (× L<sub>c</sub>)</span>
                <span class="readout" id="zRead">2.0</span>
              </label>
              <input id="zmul" type="range" min="0.8" max="4.0" value="2.0" step="0.1" />
              <div class="note" style="margin-top:6px;">
                L<sub>c</sub> = π/(2κ) is the full transfer length (guide 1 → guide 2).
              </div>
            </div>

            <div class="control">
              <label>
                <span>Sweep max <b>2a</b> (μm)</span>
                <span class="readout" id="smaxRead">2.00</span>
              </label>
              <input id="smax" type="range" min="1.00" max="3.50" value="2.00" step="0.05" />
              <div class="note" style="margin-top:6px;">
                Secondary plot: κ and L<sub>3dB</sub> vs separation.
              </div>
            </div>
          </div>
        </figure>

        <article class="callout" style="margin-top:14px;">
          <h3>Connection to the diagram and plots</h3>
          <p>
            The overlap integral in Eq. (9.4-6) samples u<sub>1</sub>(y) inside the <b>core region of guide 2</b>.
            In the diagram, that corresponds to the right slab. As 2a increases, the left slab’s evanescent tail becomes
            smaller by the time it reaches the right core, so κ decreases and the power-transfer curve stretches out
            (longer distance to reach 50% power).
          </p>
        </article>

      </div>
    </section>

    <!-- PART 4: DEEPER UNDERSTANDING -->
    <section id="deeper">
      <header>
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>
        <p>Interpret κ, see parameter sensitivities, and test your understanding with quick concept checks.</p>
      </header>
      <div class="body">

        <div class="grid2">
          <article class="callout">
            <h3>Re-interpreting the final formula</h3>
            <p>
              In Eq. (9.4-6), κ has two main “knobs”:
            </p>
            <ul>
              <li><b>Material weighting:</b> (n<sub>1</sub>² − n²)k<sub>0</sub>²/β — stronger index perturbation and shorter wavelength (larger k<sub>0</sub>) generally increase coupling strength.</li>
              <li><b>Field overlap:</b> ∫ u<sub>1</sub>(y)u<sub>2</sub>(y) dy over the other core — this is often the dominant sensitivity, and it tends to decay nearly exponentially with separation.</li>
            </ul>
            <p class="note">
              In many practical couplers, designers tune coupling mostly by changing the gap because it gives a strong, monotonic control.
            </p>
          </article>

          <article class="callout">
            <h3>How changing parameters affects outcome</h3>
            <ul>
              <li><b>Increase 2a:</b> κ ↓ → L<sub>3dB</sub> ↑; power oscillations slow down (main plot stretches).</li>
              <li><b>Increase d (thicker core):</b> mode is more confined (tails smaller) → κ often ↓ (but depends on V and confinement).</li>
              <li><b>Increase Δn = n<sub>1</sub>−n:</b> stronger confinement → tails smaller → κ tends to ↓; however the prefactor (n<sub>1</sub>²−n²) increases, so net effect is a balance.</li>
              <li><b>Change λ<sub>0</sub>:</b> affects k<sub>0</sub> and V; often longer wavelengths increase penetration depth and can increase coupling for a fixed geometry.</li>
            </ul>
          </article>
        </div>

        <article class="callout" style="margin-top:14px;">
          <h3>Alternative derivation idea (brief)</h3>
          <p>
            Instead of computing κ from an overlap integral, you can solve the <b>two-slab structure</b> directly and obtain
            the even/odd <b>supermodes</b> with propagation constants β<sub>+</sub>, β<sub>−</sub>. For identical guides,
            the coupling coefficient relates to the splitting:
          </p>
          <div class="eq" data-copy="κ ≈ (β+ − β−)/2   (identical, weak coupling)">
            <button class="copyBtn" type="button" data-copy-btn>Copy</button>
            <div><b>Supermode splitting relation</b></div>
            <div style="margin-top:6px;">
              κ ≈ (β<sub>+</sub> − β<sub>−</sub>)/2
            </div>
          </div>
          <p class="note" style="margin-top:10px;">
            This viewpoint emphasizes that coupling is really “mode hybridization”: even/odd combinations propagate with slightly different β.
          </p>
        </article>

        <article class="callout" style="margin-top:14px;">
          <h3>Concept checks (with answers)</h3>
          <ul>
            <li><b>Q:</b> If κ doubles, what happens to L<sub>3dB</sub>? <b>A:</b> It halves, since L<sub>3dB</sub>=π/(4κ).</li>
            <li><b>Q:</b> Why does identical-guide coupling reach 100% transfer? <b>A:</b> Because Δβ=0 (phase matched), so energy exchange is perfectly resonant.</li>
            <li><b>Q:</b> What geometric change most strongly tunes κ? <b>A:</b> The separation 2a, because overlap depends exponentially on evanescent decay.</li>
            <li><b>Q:</b> If Δβ≠0, can you still make a 3-dB coupler? <b>A:</b> Yes in some cases, but the max transferred power can drop below 1 and the required length changes (you’d use the general CMT solution with mismatch).</li>
          </ul>
        </article>
      </div>
    </section>

    <!-- PART 5: VISUALIZATION GUIDE -->
    <section id="vizguide">
      <header>
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>
        <p>What each canvas shows, what the sliders change, and what patterns to expect.</p>
      </header>
      <div class="body">
        <div class="cols">
          <article class="callout">
            <h3>Diagram canvas</h3>
            <ul>
              <li>Shows two slab cores (width d) with cladding between them.</li>
              <li>Labels d, 2a, indices (n<sub>1</sub>, n), and z direction.</li>
              <li>As you change 2a, the slabs move apart/together in the drawing.</li>
            </ul>
          </article>

          <article class="callout">
            <h3>Main plot: Power vs z</h3>
            <ul>
              <li>Plots P<sub>1</sub>(z)=cos²(κz) and P<sub>2</sub>(z)=sin²(κz).</li>
              <li>Marks the 3-dB point at z=L<sub>3dB</sub>=π/(4κ).</li>
              <li>Also indicates L<sub>c</sub>=π/(2κ) (full transfer) as a reference scale.</li>
            </ul>
          </article>

          <article class="callout">
            <h3>Secondary plot: κ and L<sub>3dB</sub> vs separation</h3>
            <ul>
              <li>Sweeps 2a from a minimum up to the “Sweep max 2a”.</li>
              <li>Shows how κ decreases strongly with separation.</li>
              <li>Shows how L<sub>3dB</sub> grows as κ shrinks.</li>
            </ul>
          </article>
        </div>

        <article class="callout" style="margin-top:14px;">
          <h3>Interactive controls (what changes and why)</h3>
          <ul>
            <li><b>Separation 2a:</b> Changes the overlap integral → updates κ → updates both plots and the final numeric answers.</li>
            <li><b>z-range multiplier:</b> Only changes how far in z the main plot displays (scaled by L<sub>c</sub>).</li>
            <li><b>Sweep max 2a:</b> Extends the x-range of the secondary sweep plot.</li>
          </ul>
          <p class="note">
            All plotted symbols match the text: κ is the coupling coefficient from Eq. (9.4-6), and the 3-dB length is π/(4κ).
          </p>
        </article>
      </div>
    </section>

  </div>
</main>

<footer>
  <div>
    Built as a self-contained learning article (vanilla HTML/CSS/JS). Numeric results are computed from the TE<sub>0</sub> slab dispersion
    and the overlap integral in Eq. (9.4-6), using the exact problem parameters by default.
  </div>
</footer>

<script>
/* ============================================================
   Utilities: clipboard, DOM helpers, formatting
   ============================================================ */
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function fmt(x, digits=4){
  if (!isFinite(x)) return "—";
  const ax = Math.abs(x);
  if (ax !== 0 && (ax < 1e-3 || ax >= 1e4)) return x.toExponential(digits);
  return x.toFixed(digits);
}
function copyText(txt){
  if (navigator.clipboard && navigator.clipboard.writeText){
    navigator.clipboard.writeText(txt).catch(()=>{ fallbackCopy(txt); });
  } else fallbackCopy(txt);
}
function fallbackCopy(txt){
  const ta=document.createElement('textarea');
  ta.value=txt;
  ta.style.position='fixed';
  ta.style.left='-9999px';
  document.body.appendChild(ta);
  ta.select();
  try{ document.execCommand('copy'); }catch(e){}
  document.body.removeChild(ta);
}
document.querySelectorAll('[data-copy-btn]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const eq = btn.closest('.eq');
    const txt = eq.getAttribute('data-copy') || eq.innerText.trim();
    copyText(txt);
    btn.textContent="Copied!";
    setTimeout(()=>btn.textContent="Copy", 900);
  });
});

/* ============================================================
   Physics core: TE0 slab mode + coupling (all in μm units)
   ============================================================ */
const params = {
  n1: 1.48,
  n: 1.46,
  d: 0.5,      // μm
  lambda0: 0.85 // μm
};

// Solve even TE mode: u tan u = w with u^2+w^2=V^2
function solveTE0(n1, n, d, lambda0){
  const t = d/2;
  const k0 = 2*Math.PI/lambda0;
  const V = k0*t*Math.sqrt(Math.max(0, n1*n1 - n*n));
  // For TE0 even: root in (0, min(V, π/2))
  const uMax = Math.min(V*0.999999, Math.PI/2 - 1e-8);
  const f = (u)=>{
    const w = Math.sqrt(Math.max(0, V*V - u*u));
    return u*Math.tan(u) - w;
  };
  // Bisection: find sign change. For small V, f(0) ~ -V < 0, f(uMax) usually > 0.
  let a = 1e-10, b = uMax;
  let fa = f(a), fb = f(b);
  if (!(fa <= 0 && fb >= 0)){
    // If something odd happens, try scanning.
    let found = false;
    let prevU = a, prevF = fa;
    const N=2000;
    for (let i=1;i<=N;i++){
      const u = a + (b-a)*i/N;
      const fu = f(u);
      if (prevF<=0 && fu>=0){
        a=prevU; fa=prevF; b=u; fb=fu; found=true; break;
      }
      prevU=u; prevF=fu;
    }
    if (!found){
      // fallback: return a weakly-guided approximate (won't happen for this problem)
      return {k0,V,t, u:Math.min(0.4, uMax), w:Math.sqrt(Math.max(0,V*V - Math.min(0.4,uMax)**2)), ky:NaN, alpha:NaN, beta:NaN, neff:NaN, A:NaN};
    }
  }
  // bisection refine
  for (let it=0; it<80; it++){
    const m = 0.5*(a+b);
    const fm = f(m);
    if (fm===0) { a=b=m; break; }
    if (fm>0){ b=m; fb=fm; } else { a=m; fa=fm; }
  }
  const u = 0.5*(a+b);
  const w = Math.sqrt(Math.max(0, V*V - u*u));
  const ky = u/t;
  const alpha = w/t;

  // beta from ky^2 = (n1 k0)^2 - beta^2
  const beta = Math.sqrt(Math.max(0, (n1*k0)*(n1*k0) - ky*ky));
  const neff = beta/k0;

  // Normalization: ∫|u|^2 dy = 1 for u(y)=A cos(ky y) in core, A cos(ky t) exp(-alpha(|y|-t)) outside
  const C = Math.cos(ky*t);
  const Icore = t + Math.sin(2*ky*t)/(2*ky); // from ∫_{-t}^t cos^2
  const Iclad = (C*C)/alpha; // from 2 * ∫_{t}^∞ C^2 exp(-2alpha(y-t)) dy
  const Itot = Icore + Iclad;
  const A = 1/Math.sqrt(Itot);

  return {k0, V, t, u, w, ky, alpha, beta, neff, A};
}

// Normalized mode field centered at y0
function uField(y, y0, mode){
  const yy = y - y0;
  const ay = Math.abs(yy);
  if (ay <= mode.t){
    return mode.A * Math.cos(mode.ky*yy);
  }
  return mode.A * Math.cos(mode.ky*mode.t) * Math.exp(-mode.alpha*(ay - mode.t));
}

// Compute coupling κ using Eq. (9.4-6) for identical slabs
function couplingKappa(sep2a, mode){
  const a = sep2a/2;
  const d = params.d;
  // centers at ±(a+t) so that core2 is [a, a+d] and core1 is [-a-d, -a]
  const y02 = (a + mode.t);
  const y01 = -(a + mode.t);

  // numeric integral over core2: y in [a, a+d]
  const yStart = a;
  const yEnd = a + d;
  const N = 2500; // good accuracy
  let sum = 0;
  for (let i=0;i<=N;i++){
    const y = yStart + (yEnd - yStart)*i/N;
    const wgt = (i===0 || i===N) ? 0.5 : 1.0; // trapezoid
    const u1 = uField(y, y01, mode);
    const u2 = uField(y, y02, mode);
    sum += wgt * (u1*u2);
  }
  const integral = sum * (yEnd - yStart)/N; // μm

  // Eq 9.4-6: C21 = 0.5 * (n2^2 - n^2) * k0^2 / beta1 * integral
  const n2 = params.n1; // identical
  const kappa = 0.5 * ((n2*n2 - params.n*params.n) * (mode.k0*mode.k0) / mode.beta) * integral; // μm^-1
  return {kappa, integral, a, y01, y02};
}

// Power exchange for identical, phase-matched coupler
function P2(z, kappa){ return Math.sin(kappa*z)**2; }
function P1(z, kappa){ return Math.cos(kappa*z)**2; }

/* ============================================================
   Canvas helpers: HiDPI, axes, ticks, grid, line plotting
   ============================================================ */
function setupCanvas(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.max(2, Math.floor(rect.width * dpr));
  canvas.height = Math.max(2, Math.floor(rect.height * dpr));
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  return {ctx, w:rect.width, h:rect.height, dpr};
}

function clear(ctx, w, h){
  ctx.clearRect(0,0,w,h);
}

function roundRect(ctx,x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}

function drawPanel(ctx, x,y,w,h){
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.16)';
  ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  ctx.lineWidth = 1;
  roundRect(ctx,x,y,w,h,16);
  ctx.fill();
  ctx.stroke();
  ctx.restore();
}

function drawAxes(ctx, box, xMin,xMax, yMin,yMax, xLabel, yLabel, title, legendItems){
  const {x,y,w,h, padL, padR, padT, padB} = box;

  // panel
  drawPanel(ctx, x,y,w,h);

  // plot area
  const px = x+padL, py = y+padT, pw = w-padL-padR, ph = h-padT-padB;

  // grid + ticks
  ctx.save();
  ctx.beginPath();
  ctx.rect(px,py,pw,ph);
  ctx.clip();

  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  ctx.fillRect(px,py,pw,ph);

  const nGridX = 8, nGridY = 6;
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;

  for (let i=0;i<=nGridX;i++){
    const xx = px + pw*i/nGridX;
    ctx.beginPath(); ctx.moveTo(xx,py); ctx.lineTo(xx,py+ph); ctx.stroke();
  }
  for (let j=0;j<=nGridY;j++){
    const yy = py + ph*j/nGridY;
    ctx.beginPath(); ctx.moveTo(px,yy); ctx.lineTo(px+pw,yy); ctx.stroke();
  }

  ctx.restore();

  // axes
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.22)';
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(px, py+ph);
  ctx.lineTo(px+pw, py+ph);
  ctx.moveTo(px, py);
  ctx.lineTo(px, py+ph);
  ctx.stroke();
  ctx.restore();

  // labels and title
  ctx.save();
  ctx.fillStyle = 'rgba(233,236,246,0.95)';
  ctx.font = '600 14px ui-sans-serif, system-ui';
  ctx.fillText(title, x+14, y+22);

  ctx.fillStyle = 'rgba(184,192,221,0.95)';
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillText(xLabel, px + pw - ctx.measureText(xLabel).width, y+h-10);

  // y label rotated
  ctx.save();
  ctx.translate(x+14, py+ph/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  // tick labels
  const nTicksX = 5, nTicksY = 5;
  ctx.fillStyle = 'rgba(184,192,221,0.85)';
  ctx.font = '11px ui-sans-serif, system-ui';

  for (let i=0;i<=nTicksX;i++){
    const t = i/nTicksX;
    const xv = xMin + (xMax-xMin)*t;
    const xx = px + pw*t;
    const s = fmt(xv, (Math.abs(xMax-xMin) < 2 ? 2 : 1));
    ctx.fillText(s, xx - ctx.measureText(s).width/2, py+ph+16);
  }
  for (let j=0;j<=nTicksY;j++){
    const t = j/nTicksY;
    const yv = yMax - (yMax-yMin)*t;
    const yy = py + ph*t;
    const s = fmt(yv, 2);
    ctx.fillText(s, px-8-ctx.measureText(s).width, yy+4);
  }

  // legend
  if (legendItems && legendItems.length){
    const lx = x+w-14, ly = y+18;
    let maxW=0;
    legendItems.forEach(it=>{ maxW = Math.max(maxW, ctx.measureText(it.label).width); });
    const boxW = maxW + 48, boxH = 18*legendItems.length + 12;
    drawPanel(ctx, lx-boxW, ly, boxW, boxH);
    legendItems.forEach((it, idx)=>{
      const yy = ly + 10 + idx*18;
      ctx.strokeStyle = it.stroke;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(lx-boxW+12, yy);
      ctx.lineTo(lx-boxW+28, yy);
      ctx.stroke();
      ctx.fillStyle = 'rgba(233,236,246,0.90)';
      ctx.fillText(it.label, lx-boxW+34, yy+4);
    });
  }

  ctx.restore();

  function xToPx(xv){ return px + (xv-xMin)/(xMax-xMin)*pw; }
  function yToPx(yv){ return py + (yMax-yv)/(yMax-yMin)*ph; }

  return {px,py,pw,ph, xToPx, yToPx};
}

function plotLine(ctx, map, xs, ys, stroke, width=2){
  ctx.save();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = width;
  ctx.beginPath();
  for (let i=0;i<xs.length;i++){
    const X = map.xToPx(xs[i]);
    const Y = map.yToPx(ys[i]);
    if (i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
  }
  ctx.stroke();
  ctx.restore();
}

function plotMarkersV(ctx, map, xVal, stroke, label){
  ctx.save();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.setLineDash([6,6]);
  const X = map.xToPx(xVal);
  ctx.beginPath();
  ctx.moveTo(X, map.py);
  ctx.lineTo(X, map.py+map.ph);
  ctx.stroke();
  ctx.setLineDash([]);

  if (label){
    ctx.fillStyle = 'rgba(233,236,246,0.9)';
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillText(label, X+6, map.py+14);
  }
  ctx.restore();
}

/* ============================================================
   Draw: diagram
   ============================================================ */
function drawDiagram(canvas, sep2a, mode, kappa){
  const {ctx,w,h} = setupCanvas(canvas);
  clear(ctx,w,h);

  // Title
  ctx.fillStyle = 'rgba(233,236,246,0.95)';
  ctx.font = '700 15px ui-sans-serif, system-ui';
  ctx.fillText('Geometry: Two identical slab waveguides', 14, 22);

  const margin = 18;
  const x0 = margin, y0 = 40, W = w-2*margin, H = h-54;

  drawPanel(ctx, x0,y0,W,H);

  // Map physical y to drawing x (we draw cross-section horizontally)
  // We'll show y range that comfortably contains both slabs.
  const d = params.d;
  const t = d/2;
  const a = sep2a/2;
  const yMin = -(a + d + 0.9);
  const yMax = +(a + d + 0.9);

  function yToX(y){
    return x0 + 14 + (y - yMin)/(yMax-yMin) * (W-28);
  }
  // Regions:
  const core1 = [-a-d, -a];
  const core2 = [ a, a+d];

  const yMid = y0 + H*0.55;
  const slabH = H*0.22;

  // cladding background band
  ctx.fillStyle = 'rgba(125,211,252,0.06)';
  ctx.fillRect(x0+14, yMid-slabH*1.2, W-28, slabH*2.4);

  // Draw cores
  function drawCore(yA,yB,label){
    const xA=yToX(yA), xB=yToX(yB);
    ctx.fillStyle = 'rgba(167,243,208,0.18)';
    ctx.strokeStyle = 'rgba(167,243,208,0.35)';
    ctx.lineWidth = 2;
    roundRect(ctx, xA, yMid-slabH/2, xB-xA, slabH, 12);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = 'rgba(233,236,246,0.95)';
    ctx.font = '600 12px ui-sans-serif, system-ui';
    ctx.fillText(label, (xA+xB)/2 - ctx.measureText(label).width/2, yMid - slabH/2 - 10);
  }
  drawCore(core1[0], core1[1], 'Core 1 (n1)');
  drawCore(core2[0], core2[1], 'Core 2 (n2)');

  // Gap marker 2a between inner faces: from -a to +a
  const xGapL = yToX(-a), xGapR = yToX(a);
  ctx.strokeStyle = 'rgba(251,191,36,0.70)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(xGapL, yMid + slabH*0.75);
  ctx.lineTo(xGapR, yMid + slabH*0.75);
  ctx.stroke();
  // arrows
  ctx.beginPath();
  ctx.moveTo(xGapL, yMid + slabH*0.75);
  ctx.lineTo(xGapL+8, yMid + slabH*0.75 - 5);
  ctx.lineTo(xGapL+8, yMid + slabH*0.75 + 5);
  ctx.closePath();
  ctx.fillStyle='rgba(251,191,36,0.80)';
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(xGapR, yMid + slabH*0.75);
  ctx.lineTo(xGapR-8, yMid + slabH*0.75 - 5);
  ctx.lineTo(xGapR-8, yMid + slabH*0.75 + 5);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle='rgba(251,191,36,0.95)';
  ctx.font='600 12px ui-sans-serif, system-ui';
  const gapLabel = `2a = ${fmt(sep2a,2)} μm`;
  ctx.fillText(gapLabel, (xGapL+xGapR)/2 - ctx.measureText(gapLabel).width/2, yMid + slabH*0.75 + 18);

  // d marker on core2
  const xD1 = yToX(a), xD2 = yToX(a+d);
  ctx.strokeStyle='rgba(125,211,252,0.70)';
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(xD1, yMid - slabH*0.85);
  ctx.lineTo(xD2, yMid - slabH*0.85);
  ctx.stroke();
  // arrows
  ctx.fillStyle='rgba(125,211,252,0.85)';
  ctx.beginPath();
  ctx.moveTo(xD1, yMid - slabH*0.85);
  ctx.lineTo(xD1+8, yMid - slabH*0.85 - 5);
  ctx.lineTo(xD1+8, yMid - slabH*0.85 + 5);
  ctx.closePath(); ctx.fill();

  ctx.beginPath();
  ctx.moveTo(xD2, yMid - slabH*0.85);
  ctx.lineTo(xD2-8, yMid - slabH*0.85 - 5);
  ctx.lineTo(xD2-8, yMid - slabH*0.85 + 5);
  ctx.closePath(); ctx.fill();

  ctx.fillStyle='rgba(125,211,252,0.95)';
  ctx.font='600 12px ui-sans-serif, system-ui';
  const dLabel = `d = ${fmt(params.d,2)} μm`;
  ctx.fillText(dLabel, (xD1+xD2)/2 - ctx.measureText(dLabel).width/2, yMid - slabH*0.85 - 10);

  // z direction
  ctx.strokeStyle='rgba(233,236,246,0.55)';
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(x0+W-110, y0+H-22);
  ctx.lineTo(x0+W-30, y0+H-22);
  ctx.stroke();
  ctx.fillStyle='rgba(233,236,246,0.75)';
  ctx.beginPath();
  ctx.moveTo(x0+W-30, y0+H-22);
  ctx.lineTo(x0+W-42, y0+H-28);
  ctx.lineTo(x0+W-42, y0+H-16);
  ctx.closePath(); ctx.fill();
  ctx.font='600 12px ui-sans-serif, system-ui';
  ctx.fillText('z', x0+W-22, y0+H-18);

  // Summary text
  ctx.fillStyle='rgba(184,192,221,0.95)';
  ctx.font='12px ui-sans-serif, system-ui';
  const line1 = `TE0: n_eff ≈ ${fmt(mode.neff,6)}   β ≈ ${fmt(mode.beta,6)} μm⁻¹`;
  const line2 = `κ ≈ ${fmt(kappa,6)} μm⁻¹   L3dB = π/(4κ) ≈ ${fmt(Math.PI/(4*kappa),3)} μm`;
  ctx.fillText(line1, x0+14, y0+H-46);
  ctx.fillText(line2, x0+14, y0+H-28);
}

/* ============================================================
   Draw: main plot (power vs z)
   ============================================================ */
function drawMainPlot(canvas, kappa, zmul){
  const {ctx,w,h} = setupCanvas(canvas);
  clear(ctx,w,h);

  const Lc = Math.PI/(2*kappa);
  const zMax = zmul * Lc;
  const N=600;
  const zs = new Array(N);
  const p1 = new Array(N);
  const p2 = new Array(N);
  for (let i=0;i<N;i++){
    const z = zMax*i/(N-1);
    zs[i]=z;
    p1[i]=P1(z,kappa);
    p2[i]=P2(z,kappa);
  }

  const box = {x:12,y:10,w:w-24,h:h-20,padL:58,padR:18,padT:34,padB:42};
  const map = drawAxes(
    ctx, box,
    0, zMax,
    0, 1,
    'z (μm)',
    'Power (normalized)',
    'Main Plot: Power exchange between guides (Δβ=0)',
    [
      {label:'P1(z)', stroke:'rgba(125,211,252,0.95)'},
      {label:'P2(z)', stroke:'rgba(167,243,208,0.95)'}
    ]
  );

  plotLine(ctx, map, zs, p1, 'rgba(125,211,252,0.95)', 2.6);
  plotLine(ctx, map, zs, p2, 'rgba(167,243,208,0.95)', 2.6);

  // Mark L3dB and Lc
  const L3 = Math.PI/(4*kappa);
  plotMarkersV(ctx, map, L3, 'rgba(251,191,36,0.95)', 'L3dB');
  plotMarkersV(ctx, map, Lc, 'rgba(233,236,246,0.45)', 'Lc');

  // annotate
  ctx.save();
  ctx.fillStyle='rgba(184,192,221,0.95)';
  ctx.font='12px ui-sans-serif, system-ui';
  const txt = `κ=${fmt(kappa,6)} μm⁻¹,  L3dB=${fmt(L3,3)} μm,  Lc=${fmt(Lc,3)} μm`;
  ctx.fillText(txt, box.x+16, box.y+box.h-14);
  ctx.restore();
}

/* ============================================================
   Draw: sweep plot (kappa and L3dB vs separation)
   ============================================================ */
function drawSweepPlot(canvas, mode, sMax){
  const {ctx,w,h} = setupCanvas(canvas);
  clear(ctx,w,h);

  const sMin = 0.6;
  const N=70;
  const seps = [];
  const kappas = [];
  const L3s = [];

  let kMax = 0, LMax = 0;
  for (let i=0;i<N;i++){
    const sep = sMin + (sMax-sMin)*i/(N-1);
    const {kappa} = couplingKappa(sep, mode);
    const L3 = Math.PI/(4*kappa);
    seps.push(sep);
    kappas.push(kappa);
    L3s.push(L3);
    kMax = Math.max(kMax, kappa);
    LMax = Math.max(LMax, L3);
  }

  // We'll plot kappa on left y-axis and L3 on right y-axis (scaled into same canvas).
  // For clarity, scale L3 to a normalized axis and label both in legend text.
  const yMin = 0;
  const yMax = kMax*1.15;

  const box = {x:12,y:10,w:w-24,h:h-20,padL:58,padR:58,padT:34,padB:42};
  const map = drawAxes(
    ctx, box,
    sMin, sMax,
    yMin, yMax,
    'Separation 2a (μm)',
    'κ (μm⁻¹)',
    'Secondary Plot: Coupling vs separation (and implied L3dB)',
    [
      {label:'κ(2a)', stroke:'rgba(251,191,36,0.95)'},
      {label:'L3dB(2a) (scaled)', stroke:'rgba(233,236,246,0.70)'}
    ]
  );

  // Plot kappa
  plotLine(ctx, map, seps, kappas, 'rgba(251,191,36,0.95)', 2.6);

  // Plot L3 scaled to same y axis: y = yMax * (L3/LMax)
  const Lscaled = L3s.map(v => yMax * (v / LMax));
  plotLine(ctx, map, seps, Lscaled, 'rgba(233,236,246,0.70)', 2.2);

  // Right axis labels (L3dB)
  ctx.save();
  const px = map.px, py = map.py, pw = map.pw, ph = map.ph;
  ctx.strokeStyle='rgba(255,255,255,0.22)';
  ctx.lineWidth=1.2;
  ctx.beginPath();
  ctx.moveTo(px+pw, py);
  ctx.lineTo(px+pw, py+ph);
  ctx.stroke();

  ctx.fillStyle='rgba(184,192,221,0.85)';
  ctx.font='11px ui-sans-serif, system-ui';
  const nTicks = 5;
  for (let j=0;j<=nTicks;j++){
    const t = j/nTicks;
    const Lval = LMax*(1 - t);
    const yy = py + ph*t;
    const s = fmt(Lval, (LMax<200 ? 1 : 0));
    ctx.fillText(s, px+pw+8, yy+4);
  }
  ctx.fillStyle='rgba(184,192,221,0.95)';
  ctx.font='12px ui-sans-serif, system-ui';
  ctx.save();
  ctx.translate(px+pw+40, py+ph/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText('L3dB (μm)', 0, 0);
  ctx.restore();

  // Footer note
  ctx.fillStyle='rgba(184,192,221,0.95)';
  ctx.font='12px ui-sans-serif, system-ui';
  ctx.fillText(`Right-axis curve shows L3dB=π/(4κ) (scaled into left axis for plotting).`, box.x+16, box.y+box.h-14);
  ctx.restore();
}

/* ============================================================
   Orchestrate: compute, update UI, draw all
   ============================================================ */
const elSep = document.getElementById('sep');
const elSepRead = document.getElementById('sepRead');
const elZmul = document.getElementById('zmul');
const elZRead = document.getElementById('zRead');
const elSmax = document.getElementById('smax');
const elSmaxRead = document.getElementById('smaxRead');
const diag = document.getElementById('diag');
const plotMain = document.getElementById('plotMain');
const plotSweep = document.getElementById('plotSweep');
const finalText = document.getElementById('finalText');
const copyFinal = document.getElementById('copyFinal');
const resetBtn = document.getElementById('resetBtn');

let modeCache = null;

function computeAndRender(){
  const sep2a = parseFloat(elSep.value);
  const zmul = parseFloat(elZmul.value);
  const sMax = parseFloat(elSmax.value);

  elSepRead.textContent = fmt(sep2a,2);
  elZRead.textContent = fmt(zmul,1);
  elSmaxRead.textContent = fmt(sMax,2);

  // Solve TE0 once (doesn't depend on separation)
  if (!modeCache){
    modeCache = solveTE0(params.n1, params.n, params.d, params.lambda0);
  }
  const mode = modeCache;

  // Coupling
  const {kappa, integral} = couplingKappa(sep2a, mode);
  const L3 = Math.PI/(4*kappa);
  const Lc = Math.PI/(2*kappa);

  // Fill final result block (also includes the default-problem numeric values)
  const txt =
`(a) Coupling coefficient (identical slabs, TE0):
k0 = 2π/λ0 = ${fmt(mode.k0,6)} μm⁻¹
β ≈ ${fmt(mode.beta,6)} μm⁻¹  (n_eff ≈ ${fmt(mode.neff,6)})
Overlap integral  I = ∫_{a}^{a+d} u1(y)u2(y) dy ≈ ${fmt(integral,6)}  (dimensionless with our normalization)
κ = ½ (n1² − n²) (k0²/β) I ≈ ${fmt(kappa,6)} μm⁻¹  (= ${fmt(1000*kappa,3)} mm⁻¹)

(b) 3-dB coupler length (Δβ=0):
L3dB = π/(4κ) ≈ ${fmt(L3,3)} μm
(Full transfer length: Lc = π/(2κ) ≈ ${fmt(Lc,3)} μm)`;
  finalText.textContent = txt;

  // Update canvases
  drawDiagram(diag, sep2a, mode, kappa);
  drawMainPlot(plotMain, kappa, zmul);
  drawSweepPlot(plotSweep, mode, sMax);

  // Hook copy final
  copyFinal.onclick = ()=>{
    copyText(txt);
    copyFinal.textContent = "Copied!";
    setTimeout(()=>copyFinal.textContent="Copy final answer", 900);
  };
}

function reset(){
  elSep.value = "1.00";
  elZmul.value = "2.0";
  elSmax.value = "2.00";
  computeAndRender();
}

elSep.addEventListener('input', computeAndRender);
elZmul.addEventListener('input', computeAndRender);
elSmax.addEventListener('input', computeAndRender);
resetBtn.addEventListener('click', reset);

window.addEventListener('resize', ()=>{
  // Re-render for responsive canvases
  computeAndRender();
});

// Initial render
computeAndRender();
</script>
</body>
</html>
