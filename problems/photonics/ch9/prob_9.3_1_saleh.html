<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Modes of a Rectangular Dielectric Waveguide — TE Mode Count vs Frequency</title>
  <style>
    :root{
      --bg:#0b0f19;
      --panel:#0f1629;
      --card:#111b33;
      --ink:#eaf0ff;
      --muted:#b8c3e6;
      --soft:#93a4d6;
      --accent:#7dd3fc;
      --accent2:#a7f3d0;
      --warn:#fbbf24;
      --bad:#fb7185;
      --ok:#34d399;
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.16);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1200px 800px at 15% 10%, rgba(125,211,252,.12), transparent 60%),
        radial-gradient(1000px 700px at 85% 15%, rgba(167,243,208,.10), transparent 55%),
        radial-gradient(900px 700px at 40% 90%, rgba(251,191,36,.08), transparent 55%),
        linear-gradient(180deg, var(--bg), #070a12 70%);
      line-height:1.55;
    }

    header{
      position:relative;
      padding:32px 18px 16px;
      border-bottom:1px solid var(--line);
      overflow:hidden;
    }
    header .wrap{
      max-width:1100px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 1.4fr .6fr;
      gap:18px;
      align-items:start;
    }
    h1{
      margin:0 0 8px 0;
      font-weight:800;
      letter-spacing:.2px;
      line-height:1.15;
      font-size: clamp(1.5rem, 2.4vw, 2.2rem);
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size: clamp(.98rem, 1.5vw, 1.05rem);
      max-width:70ch;
    }

    .topCards{
      margin-top:16px;
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:12px;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:14px 14px;
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .card::before{
      content:"";
      position:absolute;
      inset:-2px -2px auto -2px;
      height:3px;
      background: linear-gradient(90deg, transparent, rgba(125,211,252,.9), rgba(167,243,208,.7), transparent);
      opacity:.6;
      transform: translateX(-25%);
      animation: shimmer 6s linear infinite;
    }
    @keyframes shimmer{
      0%{transform:translateX(-35%)}
      100%{transform:translateX(35%)}
    }

    .card h3{
      margin:0 0 8px 0;
      font-size:1rem;
      letter-spacing:.15px;
    }
    .card p{margin:0;color:var(--muted);font-size:.95rem}
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      font-size:.88rem;
      color:var(--muted);
      background: rgba(0,0,0,.18);
      width:max-content;
    }
    .dot{width:8px;height:8px;border-radius:50%}
    .dot.accent{background:var(--accent)}
    .dot.acc2{background:var(--accent2)}
    .dot.warn{background:var(--warn)}

    .toc{
      position: sticky;
      top: 10px;
      align-self:start;
      background: rgba(17,27,51,.78);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:12px 12px;
      backdrop-filter: blur(10px);
    }
    .toc h2{
      margin:0 0 8px 0;
      font-size:.95rem;
      color:var(--ink);
      letter-spacing:.2px;
    }
    .toc a{
      display:block;
      text-decoration:none;
      color:var(--muted);
      font-size:.92rem;
      padding:6px 8px;
      border-radius:10px;
      border:1px solid transparent;
    }
    .toc a:hover{
      color:var(--ink);
      background: rgba(125,211,252,.08);
      border-color: rgba(125,211,252,.18);
    }

    main{
      max-width:1100px;
      margin: 0 auto;
      padding: 16px 18px 64px;
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:18px;
      align-items:start;
    }

    .content{
      display:flex;
      flex-direction:column;
      gap:14px;
      min-width:0;
    }

    section{
      background: rgba(17,27,51,.55);
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:18px 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      position:relative;
      overflow:hidden;
    }
    section h2{
      margin:0 0 10px 0;
      font-size:1.2rem;
      letter-spacing:.15px;
    }
    section h3{
      margin:14px 0 8px 0;
      font-size:1.02rem;
      color: var(--ink);
    }
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
    }
    @media (max-width: 980px){
      header .wrap{grid-template-columns:1fr}
      main{grid-template-columns:1fr}
      .toc{position:relative; top:auto}
    }
    @media (max-width: 760px){
      .grid2{grid-template-columns:1fr}
      .topCards{grid-template-columns:1fr}
    }

    .callouts{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:12px;
      margin-top:10px;
    }
    .callout{
      grid-column: span 12;
      border-radius: 16px;
      border:1px solid var(--line2);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      padding:12px 12px;
      position:relative;
      overflow:hidden;
    }
    .callout strong{display:block;margin-bottom:6px}
    .callout.assump{border-color: rgba(125,211,252,.25)}
    .callout.keyeq{border-color: rgba(167,243,208,.25)}
    .callout.mist{border-color: rgba(251,191,36,.25)}
    .callout.final{border-color: rgba(52,211,153,.25)}
    .callout .small{color:var(--muted);font-size:.93rem;margin:0}

    .eq{
      font-family: var(--mono);
      font-size: .96rem;
      padding:10px 10px;
      border-radius: 14px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      overflow:auto;
      margin:8px 0;
      position:relative;
    }

    .copyRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-top:8px;
    }
    button.copy{
      appearance:none;
      border:1px solid var(--line2);
      background: rgba(125,211,252,.10);
      color: var(--ink);
      padding:8px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:650;
      letter-spacing:.1px;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    button.copy:hover{transform: translateY(-1px); background: rgba(125,211,252,.14); border-color: rgba(125,211,252,.30)}
    button.copy:active{transform: translateY(0px)}
    .toast{
      display:inline-block;
      padding:7px 10px;
      border-radius: 12px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.22);
      color: var(--muted);
      font-size:.9rem;
      min-height: 34px;
    }

    /* Viz layout */
    .vizPanel{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .vizCard{
      background: rgba(17,27,51,.55);
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }
    .vizHeader{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      margin-bottom:8px;
    }
    .vizHeader h3{margin:0;font-size:1.02rem}
    .vizHeader .hint{color:var(--muted);font-size:.86rem}
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius: 14px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.15);
    }
    .controls{
      display:grid;
      grid-template-columns:1fr;
      gap:10px;
      margin-top:10px;
    }
    .control{
      border:1px solid var(--line);
      border-radius: 16px;
      padding:10px 10px;
      background: rgba(0,0,0,.18);
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:.92rem;
      color:var(--muted);
      margin-bottom:6px;
    }
    input[type="range"]{width:100%}
    select{
      width:100%;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--line2);
      background: rgba(17,27,51,.55);
      color: var(--ink);
      outline:none;
    }
    .miniStats{
      margin-top:10px;
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:8px;
    }
    .stat{
      border:1px solid var(--line);
      border-radius: 14px;
      padding:10px;
      background: rgba(0,0,0,.16);
    }
    .stat .k{color:var(--muted);font-size:.85rem}
    .stat .v{font-weight:800;margin-top:4px;font-family:var(--mono);font-size:.98rem}

    footer{
      max-width:1100px;
      margin:0 auto;
      padding: 0 18px 28px;
      color: var(--muted);
      font-size:.92rem;
    }

    /* Print-friendly */
    @media print{
      body{background:#fff;color:#000}
      header, main, section, .vizCard, .toc, .card{box-shadow:none; backdrop-filter:none}
      header{border-bottom:1px solid #ddd}
      section, .vizCard, .toc, .card{border:1px solid #ddd;background:#fff}
      .eq{background:#f7f7f7;border-color:#ddd}
      button.copy, .toast, input, select{display:none !important}
      a{color:#000;text-decoration:none}
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div>
        <h1>9.3-1 — Modes of a Rectangular Dielectric Waveguide (Square Core): TE Mode Count vs Frequency</h1>
        <p class="subtitle">
          We use the standard <em>k-space lattice counting</em> approximation (Eq. 9.3-3) to estimate the number of guided TE modes
          in a square dielectric waveguide and visualize how the mode count grows with optical frequency.
        </p>

        <div class="topCards">
          <div class="card" style="grid-column: span 12;">
            <div class="pill"><span class="dot accent"></span>Given</div>
            <p>
              Square cross-section area <span style="font-family:var(--mono)">A = 10<sup>−2</sup> mm<sup>2</sup></span> (so side <span style="font-family:var(--mono)">d</span>),
              numerical aperture <span style="font-family:var(--mono)">NA = 0.1</span>.
              Plot <span style="font-family:var(--mono)">M</span> vs frequency <span style="font-family:var(--mono)">ν</span> and compare to the step-like behavior in Fig. 9.2-4.
            </p>
          </div>
        </div>
      </div>

      <nav class="toc" aria-label="Table of contents">
        <h2>On this page</h2>
        <a href="#quick">Quick Summary</a>
        <a href="#part0">PART 0 — Concept Primer</a>
        <a href="#part1">PART 1 — Problem Analysis</a>
        <a href="#part2">PART 2 — Strategy &amp; Tips</a>
        <a href="#part3">PART 3 — Full Solution</a>
        <a href="#part4">PART 4 — Deeper Understanding</a>
        <a href="#part5">PART 5 — Visualization Guide</a>
      </nav>
    </div>
  </header>

  <main>
    <div class="content">

      <section id="quick">
        <h2>Quick Summary</h2>
        <ul>
          <li><strong>What this is about:</strong> estimating the <span style="font-family:var(--mono)">number of guided TE modes M</span> in a <em>square</em> dielectric waveguide as frequency changes.</li>
          <li><strong>Key physics idea:</strong> allowed transverse field patterns correspond to a <em>lattice of transverse wavevectors</em> in <span style="font-family:var(--mono)">k</span>-space; guiding limits transverse <span style="font-family:var(--mono)">k</span> to a disk set by <span style="font-family:var(--mono)">NA</span>.</li>
          <li><strong>Governing relation (Eq. 9.3-3):</strong> mode count ≈ (area of allowed <span style="font-family:var(--mono)">k</span>-space region)/(area per lattice point).</li>
          <li><strong>Result used:</strong> <span style="font-family:var(--mono)">M ≈ (π/4) (2d/λ0)^2 (NA)^2</span> for a square of side <span style="font-family:var(--mono)">d</span>.</li>
          <li><strong>Converted to frequency:</strong> since <span style="font-family:var(--mono)">λ0 = c/ν</span>, we get <span style="font-family:var(--mono)">M(ν) ≈ π (d·NA·ν / c)^2</span>.</li>
          <li><strong>What the plot should look like:</strong> smooth quadratic growth in the approximation; a more realistic “integer” count rises in <em>steps</em> (like Fig. 9.2-4).</li>
          <li><strong>Numeric geometry:</strong> <span style="font-family:var(--mono)">A = 10^−2 mm^2 ⇒ d = 0.1 mm = 100 μm</span>.</li>
        </ul>

        <div class="callouts">
          <div class="callout keyeq">
            <strong>Key equation to copy</strong>
            <div class="eq" id="eqKey">M ≈ (π/4)·(2d/λ0)^2·(NA)^2  =  π·(d·NA·ν / c)^2</div>
            <div class="copyRow">
              <button class="copy" data-copy="#eqKey">Copy key equation</button>
              <span class="toast" id="toast0">Clipboard status: ready</span>
            </div>
          </div>
        </div>
      </section>

      <section id="part0">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <article>
          <h3>0.1 Core definitions (symbols &amp; units)</h3>
          <ul>
            <li><strong>Free-space wavelength</strong> <span style="font-family:var(--mono)">λ0</span> (meters): <span style="font-family:var(--mono)">λ0 = c/ν</span>, where <span style="font-family:var(--mono)">c</span> is the speed of light.</li>
            <li><strong>Optical frequency</strong> <span style="font-family:var(--mono)">ν</span> (Hz) and angular frequency <span style="font-family:var(--mono)">ω</span> (rad/s): <span style="font-family:var(--mono)">ω = 2πν</span>.</li>
            <li><strong>Numerical aperture</strong> <span style="font-family:var(--mono)">NA</span> (dimensionless): sets the maximum acceptance/guidance angle and thus the maximum transverse spatial frequency supported.</li>
            <li><strong>Waveguide size</strong> <span style="font-family:var(--mono)">d</span> (meters): side length of the square core cross-section (here computed from area).</li>
            <li><strong>Transverse wavevector</strong> <span style="font-family:var(--mono)">k_t</span> (1/m): magnitude of the wavevector component perpendicular to propagation (encodes transverse variation of the mode).</li>
            <li><strong>Mode count</strong> <span style="font-family:var(--mono)">M</span> (dimensionless): number of guided TE modes supported at a given frequency.</li>
          </ul>

          <h3>0.2 Physical meaning: why modes “count” points in k-space</h3>
          <p class="muted">
            In a rectangular waveguide, transverse field patterns resemble standing waves across the cross-section.
            Standing waves come with discrete transverse spatial frequencies:
            <span style="font-family:var(--mono)">k_x ≈ mπ/d</span> and <span style="font-family:var(--mono)">k_y ≈ nπ/d</span>
            (with integers <span style="font-family:var(--mono)">m,n</span>).
            Each pair <span style="font-family:var(--mono)">(m,n)</span> corresponds to one transverse pattern (one mode family).
          </p>
          <p class="muted">
            A dielectric waveguide does not guide arbitrarily large transverse wavevectors:
            total internal reflection limits which ray angles (or equivalently which <span style="font-family:var(--mono)">k_t</span>) remain confined.
            That confinement condition creates a disk in <span style="font-family:var(--mono)">(k_x,k_y)</span> space:
            only lattice points inside the disk correspond to guided modes.
          </p>

          <h3>0.3 Key principle and validity conditions</h3>
          <div class="callout assump">
            <strong>Assumptions behind Eq. (9.3-3)</strong>
            <p class="small">
              (i) Weak guidance / small NA so polarization families (TE/TM) are approximately separable. <br/>
              (ii) High-mode or “geometric optics” counting: replace discrete lattice counting by area in k-space. <br/>
              (iii) Square cross-section with side <span style="font-family:var(--mono)">d</span> so lattice spacing is <span style="font-family:var(--mono)">π/d</span> in each transverse direction. <br/>
              (iv) Using free-space wavelength <span style="font-family:var(--mono)">λ0</span> and NA to parameterize the maximum transverse wavevector.
            </p>
          </div>

          <h3>0.4 Common models/approximations and why we use them</h3>
          <ul>
            <li><strong>Exact mode solving</strong> (vector Maxwell eigenproblem) is accurate but heavy: requires boundary matching and numerical eigenvalue search.</li>
            <li><strong>Lattice (k-space) counting</strong> is fast and reveals scaling: <span style="font-family:var(--mono)">M ∝ (d/λ0)^2 NA^2</span>. It is ideal for design intuition and quick plots.</li>
            <li><strong>Stepwise “integer” mode count</strong> acknowledges discreteness: <span style="font-family:var(--mono)">M</span> jumps when the next lattice point enters the allowed k-disk—this is what Fig. 9.2-4 illustrates.</li>
          </ul>

          <h3>0.5 Mini intuition examples (no long algebra)</h3>
          <ul>
            <li><strong>Make the guide bigger:</strong> larger <span style="font-family:var(--mono)">d</span> → lattice points are closer in k-space → more points fit in the allowed disk → more modes.</li>
            <li><strong>Increase frequency:</strong> higher <span style="font-family:var(--mono)">ν</span> means smaller <span style="font-family:var(--mono)">λ0</span> → the allowed disk radius in k-space grows → more modes (roughly quadratic in <span style="font-family:var(--mono)">ν</span>).</li>
          </ul>

          <h3>0.6 What to watch for (pitfalls)</h3>
          <div class="callout mist">
            <strong>Typical mistakes</strong>
            <p class="small">
              • Confusing area <span style="font-family:var(--mono)">A</span> with side <span style="font-family:var(--mono)">d</span> (here <span style="font-family:var(--mono)">d = √A</span> for a square).<br/>
              • Mixing units (mm, μm, m) when converting to frequency plots.<br/>
              • Expecting the approximate formula to produce steps: it is a <em>smooth</em> area approximation; the steps appear when you count integer lattice points (or take <span style="font-family:var(--mono)">floor</span>).<br/>
              • Interpreting NA too literally outside weak guidance—Eq. (9.3-3) is a designed approximation.
            </p>
          </div>
        </article>
      </section>

      <section id="part1">
        <h2>PART 1 — Problem Analysis (no solving yet)</h2>

        <article>
          <h3>1.1 Restate the problem</h3>
          <p class="muted">
            A rectangular dielectric waveguide has a <em>square</em> cross-section of area
            <span style="font-family:var(--mono)">A = 10^−2 mm^2</span> and numerical aperture <span style="font-family:var(--mono)">NA = 0.1</span>.
            Using Eq. (9.3-3), plot the number of guided TE modes <span style="font-family:var(--mono)">M</span> as a function of frequency <span style="font-family:var(--mono)">ν</span>,
            and compare the behavior to the step-like mode-count plot in Fig. 9.2-4.
          </p>

          <h3>1.2 Given quantities</h3>
          <ul>
            <li><span style="font-family:var(--mono)">A = 10^−2 mm^2</span> (square cross-section)</li>
            <li><span style="font-family:var(--mono)">NA = 0.1</span></li>
            <li>Use Eq. (9.3-3): <span style="font-family:var(--mono)">M ≈ (π/4)(2d/λ0)^2(NA)^2</span></li>
          </ul>

          <h3>1.3 Unknowns / what to find</h3>
          <ul>
            <li>Compute the side length <span style="font-family:var(--mono)">d</span> from the area.</li>
            <li>Write <span style="font-family:var(--mono)">M</span> as a function of frequency <span style="font-family:var(--mono)">ν</span>.</li>
            <li>Produce a plot <span style="font-family:var(--mono)">M(ν)</span> and discuss how it compares to a step-like integer mode count (Fig. 9.2-4).</li>
          </ul>

          <h3>1.4 Relevant physical principle (and why)</h3>
          <p class="muted">
            Eq. (9.3-3) comes from counting how many discrete transverse spatial frequencies fit within the maximum
            guided transverse wavevector set by the numerical aperture. Since the problem explicitly requests Eq. (9.3-3),
            we should use the <em>k-space counting approximation</em> rather than a full electromagnetic eigenmode solver.
          </p>

          <h3>1.5 Assumptions</h3>
          <div class="callout assump">
            <strong>Assumptions we will use</strong>
            <p class="small">
              • Square core of side <span style="font-family:var(--mono)">d</span>, so transverse wavenumber spacing is <span style="font-family:var(--mono)">Δk = π/d</span> in both x and y. <br/>
              • Weak guidance / small NA → approximate TE/TM counting is meaningful. <br/>
              • Use free-space wavelength <span style="font-family:var(--mono)">λ0 = c/ν</span>. <br/>
              • “Approximate mode count” is continuous; a discrete (“exact within this model”) count is step-like.
            </p>
          </div>

          <h3>1.6 Possible approaches (compare & choose)</h3>
          <ul>
            <li><strong>(A) Direct use of Eq. (9.3-3):</strong> fastest; gives smooth <span style="font-family:var(--mono)">M(ν)</span> scaling; ideal for plotting trends.</li>
            <li><strong>(B) Discrete lattice counting:</strong> count integer pairs <span style="font-family:var(--mono)">(m,n)</span> satisfying <span style="font-family:var(--mono)">k_x^2+k_y^2 ≤ k_max^2</span>; produces steps like Fig. 9.2-4.</li>
            <li><strong>(C) Full vector eigenmode solver:</strong> most accurate, but far beyond what’s requested and needs numerical EM tooling.</li>
          </ul>
          <p class="muted">
            <strong>Best choice:</strong> Use (A) as the requested solution, then include (B) as a “comparison” to explain the step behavior in Fig. 9.2-4.
            That teaches both the approximation and the origin of the steps.
          </p>
        </article>
      </section>

      <section id="part2">
        <h2>PART 2 — Strategy &amp; Tips (roadmap only)</h2>
        <ol>
          <li><strong>Convert geometry:</strong> compute side <span style="font-family:var(--mono)">d</span> from <span style="font-family:var(--mono)">A</span>. <em>Tool:</em> algebra + unit conversion. <em>Meaning:</em> sets transverse mode spacing.</li>
          <li><strong>Write Eq. (9.3-3):</strong> <span style="font-family:var(--mono)">M ≈ (π/4)(2d/λ0)^2(NA)^2</span>. <em>Meaning:</em> area ratio in k-space.</li>
          <li><strong>Convert λ to frequency:</strong> use <span style="font-family:var(--mono)">λ0 = c/ν</span>. <em>Meaning:</em> shows <span style="font-family:var(--mono)">M ∝ ν^2</span>.</li>
          <li><strong>Plot M(ν):</strong> pick a frequency range appropriate for optics (example) and compute <span style="font-family:var(--mono)">M</span>.</li>
          <li><strong>Explain step behavior:</strong> optionally compute integer-mode staircase by counting lattice points or using <span style="font-family:var(--mono)">floor(M)</span>. <em>Meaning:</em> connects smooth approximation to Fig. 9.2-4.</li>
          <li><strong>Sanity checks:</strong> confirm dimensionless mode count, correct scaling with <span style="font-family:var(--mono)">d</span>, <span style="font-family:var(--mono)">NA</span>, and <span style="font-family:var(--mono)">ν</span>.</li>
        </ol>

        <div class="callouts">
          <div class="callout mist">
            <strong>Quick tips</strong>
            <p class="small">
              • Convert <span style="font-family:var(--mono)">mm → m</span> early and stick with SI. <br/>
              • Expect a quadratic curve in <span style="font-family:var(--mono)">ν</span>. If it looks linear, you likely forgot the square. <br/>
              • If comparing to Fig. 9.2-4, show a staircase (integer) curve in addition to the smooth approximation.
            </p>
          </div>
        </div>
      </section>

      <section id="part3">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <article>
          <h3>3.1 Physical intuition first (qualitative expectation)</h3>
          <p class="muted">
            A mode is essentially a transverse standing-wave pattern across the square core.
            The larger the core and the shorter the wavelength (higher frequency), the more transverse “wiggles” can fit.
            Numerical aperture controls how steeply rays can bounce while still being guided—higher NA permits larger transverse wavevector components.
            Therefore, we expect <span style="font-family:var(--mono)">M</span> to increase when <span style="font-family:var(--mono)">d</span>, <span style="font-family:var(--mono)">NA</span>, or <span style="font-family:var(--mono)">ν</span> increases, and to do so roughly quadratically in frequency.
          </p>

          <h3>3.2 Step 1: Compute the side length d from the given area</h3>
          <p class="muted">
            The cross-section is a square of area <span style="font-family:var(--mono)">A</span>, so
            <span style="font-family:var(--mono)">A = d^2</span>.
          </p>
          <div class="eq" id="eqD">
A = 10^−2 mm^2  ⇒  d = √A = √(10^−2) mm = 10^−1 mm = 0.1 mm = 100 μm = 1.0×10^−4 m
          </div>
          <p class="muted">
            <strong>What we did and why:</strong> we converted the geometric information into the single length scale <span style="font-family:var(--mono)">d</span>,
            because Eq. (9.3-3) depends on the waveguide width through <span style="font-family:var(--mono)">d/λ0</span>.
          </p>

          <h3>3.3 Step 2: Start from Eq. (9.3-3) for TE mode count</h3>
          <p class="muted">
            The problem provides (9.3-3) in the form
          </p>
          <div class="eq" id="eq933">
M ≈ (π/4) · (2d/λ0)^2 · (NA)^2
          </div>
          <p class="muted">
            <strong>Meaning:</strong> the allowed transverse wavevector region is approximated as a quarter of a disk (factor <span style="font-family:var(--mono)">π/4</span>)
            and the density of modes in k-space is set by the lattice spacing <span style="font-family:var(--mono)">π/d</span>.
          </p>

          <h3>3.4 Step 3: Convert to a function of frequency ν</h3>
          <p class="muted">
            Use <span style="font-family:var(--mono)">λ0 = c/ν</span>. Then
            <span style="font-family:var(--mono)">(2d/λ0) = 2dν/c</span>.
            Substitute into Eq. (9.3-3):
          </p>
          <div class="eq" id="eqMnu">
M(ν) ≈ (π/4) · (2dν/c)^2 · (NA)^2
     = (π/4) · (4 d^2 ν^2 / c^2) · (NA)^2
     = π · (d·NA·ν / c)^2
          </div>
          <p class="muted">
            <strong>What we did and why:</strong> rewriting in terms of <span style="font-family:var(--mono)">ν</span> makes plotting straightforward and reveals the scaling:
            <span style="font-family:var(--mono)">M ∝ ν^2</span>.
          </p>

          <h3>3.5 Step 4: Insert the given numbers (optional numeric form)</h3>
          <p class="muted">
            With <span style="font-family:var(--mono)">d = 1.0×10^−4 m</span>, <span style="font-family:var(--mono)">NA = 0.1</span>, and <span style="font-family:var(--mono)">c = 2.99792458×10^8 m/s</span>:
          </p>
          <div class="eq" id="eqNumeric">
M(ν) ≈ π · ( (1.0×10^−4 m) · 0.1 · ν / (2.99792458×10^8 m/s) )^2
     = π · ( (1.0×10^−5) · ν / 2.99792458×10^8 )^2
          </div>
          <p class="muted">
            This expression is most useful when you plug in a frequency (e.g., in THz) to estimate how many TE modes are guided.
          </p>

          <div class="callouts">
            <div class="callout final">
              <strong>Final answer (symbolic) — mode count vs frequency</strong>
              <div class="eq" id="eqFinal">
For a square dielectric waveguide (side d) using Eq. (9.3-3):
M(ν) ≈ (π/4)(2d/λ0)^2(NA)^2,  with λ0 = c/ν
⇒  M(ν) ≈ π (d·NA·ν / c)^2.

Given A = 10^−2 mm^2 ⇒ d = 0.1 mm = 100 μm.
              </div>
              <div class="copyRow">
                <button class="copy" data-copy="#eqFinal">Copy final answer</button>
                <span class="toast" id="toast1">Clipboard status: ready</span>
              </div>
            </div>
          </div>

          <h3>3.6 Sanity checks</h3>
          <ul>
            <li><strong>Units:</strong> <span style="font-family:var(--mono)">d·ν/c</span> is dimensionless (m·s<sup>−1</sup> / (m·s<sup>−1</sup>)), so <span style="font-family:var(--mono)">M</span> is dimensionless ✔</li>
            <li><strong>Limiting cases:</strong> <span style="font-family:var(--mono)">NA → 0</span> gives <span style="font-family:var(--mono)">M → 0</span> (no guidance) ✔; <span style="font-family:var(--mono)">ν → 0</span> gives <span style="font-family:var(--mono)">M → 0</span> ✔</li>
            <li><strong>Scaling:</strong> doubling <span style="font-family:var(--mono)">d</span> increases <span style="font-family:var(--mono)">M</span> by 4; doubling <span style="font-family:var(--mono)">ν</span> increases <span style="font-family:var(--mono)">M</span> by 4 ✔</li>
            <li><strong>Why steps appear in Fig. 9.2-4:</strong> the true/discrete count changes only when a new integer pair <span style="font-family:var(--mono)">(m,n)</span> becomes allowed, so <span style="font-family:var(--mono)">M</span> jumps in steps even though the area estimate is smooth.</li>
          </ul>

          <h3>3.7 Connection to the diagram and plots</h3>
          <p class="muted">
            The diagram shows a square core of side <span style="font-family:var(--mono)">d</span> and an acceptance cone set by <span style="font-family:var(--mono)">NA</span>.
            In k-space this corresponds to a disk of allowed transverse wavevectors of radius <span style="font-family:var(--mono)">k_max</span>.
            The main plot shows both the smooth approximation <span style="font-family:var(--mono)">M(ν)</span> and a step-like discrete count obtained by explicitly counting lattice points—mirroring Fig. 9.2-4’s staircase trend.
          </p>
        </article>
      </section>

      <section id="part4">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <article>
          <h3>4.1 Re-interpreting the formula term-by-term</h3>
          <ul>
            <li><span style="font-family:var(--mono)">π</span>: comes from the area of a circle in k-space (disk of allowed transverse wavevectors).</li>
            <li><span style="font-family:var(--mono)">d^2</span>: larger cross-section packs more modes (transverse lattice spacing decreases).</li>
            <li><span style="font-family:var(--mono)">NA^2</span>: larger NA expands the allowed k-disk radius (more transverse angles/spatial frequencies guided).</li>
            <li><span style="font-family:var(--mono)">ν^2</span>: higher frequency (shorter wavelength) increases available k-space radius.</li>
            <li><span style="font-family:var(--mono)">1/c^2</span>: just unit normalization linking frequency to wavelength.</li>
          </ul>

          <h3>4.2 Parameter effects (connect to interactive plots)</h3>
          <p class="muted">
            In the interactive panel, changing <span style="font-family:var(--mono)">NA</span> rescales <span style="font-family:var(--mono)">M</span> by <span style="font-family:var(--mono)">NA^2</span>,
            so both the smooth curve and staircase rise dramatically with NA.
            Changing <span style="font-family:var(--mono)">d</span> rescales <span style="font-family:var(--mono)">M</span> by <span style="font-family:var(--mono)">d^2</span>.
            The “staircase” becomes denser for larger <span style="font-family:var(--mono)">d</span> or NA because many lattice points enter the disk over a smaller frequency increment.
          </p>

          <h3>4.3 Alternative derivation idea (brief)</h3>
          <p class="muted">
            Another route is to define a 2D “V-number” for the square guide:
            the maximum transverse spatial frequency scales like <span style="font-family:var(--mono)">k0·NA</span> with <span style="font-family:var(--mono)">k0 = 2π/λ0</span>,
            while the quantized spacing is <span style="font-family:var(--mono)">π/d</span>.
            Mode count then becomes “how many integer pairs fit under <span style="font-family:var(--mono)">m^2+n^2 ≤ (2d·NA/λ0)^2</span>,”
            whose area approximation yields Eq. (9.3-3).
          </p>

          <h3>4.4 Concept checks (quick self-test)</h3>
          <ul>
            <li><strong>Q:</strong> If you double frequency, how does <span style="font-family:var(--mono)">M</span> change? <strong>A:</strong> It quadruples (∝ <span style="font-family:var(--mono)">ν^2</span>).</li>
            <li><strong>Q:</strong> Why doesn’t the approximate curve show steps? <strong>A:</strong> It replaces discrete counting by continuous k-space area.</li>
            <li><strong>Q:</strong> What parameter most strongly affects multimode behavior? <strong>A:</strong> Both <span style="font-family:var(--mono)">d</span> and <span style="font-family:var(--mono)">NA</span> enter squared, so modest increases can strongly increase <span style="font-family:var(--mono)">M</span>.</li>
            <li><strong>Q:</strong> In the discrete model, what triggers a step? <strong>A:</strong> A new integer pair <span style="font-family:var(--mono)">(m,n)</span> crosses into the allowed k-disk as frequency increases.</li>
          </ul>
        </article>
      </section>

      <section id="part5">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>
        <article>
          <h3>5.1 Diagram canvas (geometry &amp; meaning)</h3>
          <p class="muted">
            The first canvas sketches the square core (side <span style="font-family:var(--mono)">d</span>) and an acceptance cone angle related to <span style="font-family:var(--mono)">NA</span>.
            Conceptually, the NA controls the maximum guided ray angle and thus the maximum transverse wavevector.
          </p>

          <h3>5.2 Main plot (mode count vs frequency)</h3>
          <p class="muted">
            The main plot shows:
            <strong>(i)</strong> the smooth approximation <span style="font-family:var(--mono)">M(ν) = π(d·NA·ν/c)^2</span> and
            <strong>(ii)</strong> a step-like “discrete” count obtained by explicitly counting lattice points
            satisfying <span style="font-family:var(--mono)">k_x^2+k_y^2 ≤ k_max^2</span> with
            <span style="font-family:var(--mono)">k_x=mπ/d</span>, <span style="font-family:var(--mono)">k_y=nπ/d</span>, and <span style="font-family:var(--mono)">k_max=(2π/λ0)NA</span>.
            The staircase is the analog of Fig. 9.2-4.
          </p>

          <h3>5.3 Secondary plot (difference / “step error”)</h3>
          <p class="muted">
            The secondary plot shows the difference between the discrete count and the smooth estimate (as an absolute difference and a relative error indicator).
            At low mode numbers the discrepancy is larger because “area ≈ counting” is a crude approximation; at high mode numbers it improves.
          </p>

          <h3>5.4 Interactive controls</h3>
          <p class="muted">
            Use the slider to change <span style="font-family:var(--mono)">NA</span> and the dropdown to change <span style="font-family:var(--mono)">d</span>.
            Both will update <em>all</em> canvases live. Watch how increasing NA expands the staircase upward (more modes at the same frequency),
            and how increasing <span style="font-family:var(--mono)">d</span> similarly increases the density of steps.
          </p>
        </article>
      </section>

    </div>

    <aside class="vizPanel">
      <div class="vizCard">
        <div class="vizHeader">
          <h3>Interactive Visualizations</h3>
          <div class="hint">Updates live (high-DPI, responsive)</div>
        </div>

        <div class="controls" aria-label="Interactive controls">
          <div class="control">
            <label for="naRange">
              <span>Numerical Aperture <span style="font-family:var(--mono)">NA</span></span>
              <span style="font-family:var(--mono)" id="naRead">0.10</span>
            </label>
            <input id="naRange" type="range" min="0.02" max="0.50" step="0.01" value="0.10" />
            <div class="muted" style="font-size:.86rem;margin-top:6px">
              Higher NA → larger allowed transverse k → more guided modes.
            </div>
          </div>

          <div class="control">
            <label for="dSelect">
              <span>Square side <span style="font-family:var(--mono)">d</span> (example options)</span>
              <span style="font-family:var(--mono)" id="dRead">100 μm</span>
            </label>
            <select id="dSelect">
              <option value="50">50 μm</option>
              <option value="100" selected>100 μm (given)</option>
              <option value="200">200 μm</option>
              <option value="500">500 μm</option>
            </select>
            <div class="muted" style="font-size:.86rem;margin-top:6px">
              Changing d shows scaling; the given problem uses d = 100 μm.
            </div>
          </div>

          <div class="control">
            <label for="nuMaxRange">
              <span>Max frequency on plots <span style="font-family:var(--mono)">ν_max</span></span>
              <span style="font-family:var(--mono)" id="nuMaxRead">300 THz</span>
            </label>
            <input id="nuMaxRange" type="range" min="50" max="600" step="10" value="300" />
            <div class="muted" style="font-size:.86rem;margin-top:6px">
              Adjust the frequency window to see low-mode steps or high-mode scaling.
            </div>
          </div>
        </div>

        <div class="miniStats" aria-label="Live computed stats">
          <div class="stat">
            <div class="k">Given area</div>
            <div class="v">10<sup>−2</sup> mm<sup>2</sup></div>
          </div>
          <div class="stat">
            <div class="k">Computed d (given)</div>
            <div class="v">0.1 mm</div>
          </div>
          <div class="stat">
            <div class="k">At ν = 200 THz (example)</div>
            <div class="v" id="m200">—</div>
          </div>
          <div class="stat">
            <div class="k">Discrete modes at 200 THz</div>
            <div class="v" id="m200disc">—</div>
          </div>
        </div>
      </div>

      <div class="vizCard">
        <div class="vizHeader">
          <h3>1) Geometry diagram</h3>
          <div class="hint">Square core + NA cone</div>
        </div>
        <canvas id="cDiagram" width="640" height="420" aria-label="Waveguide geometry diagram"></canvas>
      </div>

      <div class="vizCard">
        <div class="vizHeader">
          <h3>2) Main plot</h3>
          <div class="hint">M vs ν (smooth + staircase)</div>
        </div>
        <canvas id="cMain" width="640" height="420" aria-label="Main plot of mode count vs frequency"></canvas>
      </div>

      <div class="vizCard">
        <div class="vizHeader">
          <h3>3) Secondary plot</h3>
          <div class="hint">Discrete − Approx difference</div>
        </div>
        <canvas id="cSecond" width="640" height="360" aria-label="Secondary plot comparing discrete and approximate mode counts"></canvas>
      </div>
    </aside>
  </main>

  <footer>
    <div class="pill"><span class="dot warn"></span>Note</div>
    <p style="margin-top:10px">
      The discrete staircase here is a <em>didactic</em> integer-lattice implementation of the same counting model behind Eq. (9.3-3).
      A full dielectric vector-mode solver would refine cutoff behavior, polarization degeneracies, and boundary conditions—
      but the scaling and the “step origin” are captured well for learning and comparison to Fig. 9.2-4.
    </p>
  </footer>

  <script>
    // ---------- Clipboard helpers ----------
    function setToast(el, msg, ok=true){
      el.textContent = msg;
      el.style.color = ok ? getComputedStyle(document.documentElement).getPropertyValue('--muted') : getComputedStyle(document.documentElement).getPropertyValue('--bad');
    }
    async function copyText(text){
      try{
        await navigator.clipboard.writeText(text);
        return true;
      }catch(e){
        // fallback
        try{
          const ta = document.createElement('textarea');
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
          return true;
        }catch(e2){
          return false;
        }
      }
    }
    document.querySelectorAll('button.copy').forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        const sel = btn.getAttribute('data-copy');
        const el = document.querySelector(sel);
        const text = (el ? el.textContent : '').trim();
        const toast = document.getElementById(btn.getAttribute('data-copy') === '#eqKey' ? 'toast0' : 'toast1');
        const ok = await copyText(text);
        setToast(toast, ok ? 'Copied!' : 'Copy failed (browser blocked clipboard)', ok);
        setTimeout(()=>setToast(toast, 'Clipboard status: ready', true), 1500);
      });
    });

    // ---------- Numeric model ----------
    const C = 2.99792458e8; // m/s

    function approxM(nuHz, d_m, NA){
      // M(ν) ≈ π (d·NA·ν / c)^2
      const x = (d_m * NA * nuHz) / C;
      return Math.PI * x * x;
    }

    function discreteCount(nuHz, d_m, NA){
      // Educational lattice count:
      // kmax = (2π/λ0) NA = (2π ν / c) NA
      // allowed integer pairs (m,n) with kx=mπ/d, ky=nπ/d inside circle.
      // Count in first quadrant including axes, excluding (0,0).
      const kmax = (2*Math.PI*nuHz/C) * NA;
      const dk = Math.PI / d_m;
      const mMax = Math.floor(kmax / dk);
      let count = 0;
      for(let m=0; m<=mMax; m++){
        const kx = m*dk;
        const rem2 = kmax*kmax - kx*kx;
        if(rem2 < 0) continue;
        const nMax = Math.floor(Math.sqrt(rem2) / dk);
        // include n=0..nMax
        count += (nMax + 1);
      }
      // exclude (0,0)
      count -= 1;
      return Math.max(0, count);
    }

    // ---------- Canvas utilities ----------
    function fitCanvasToCSS(canvas, cssHeightPx){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(320, Math.floor(rect.width));
      const h = Math.max(220, Math.floor(cssHeightPx || rect.height || 300));
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.height = h + "px";
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {ctx, w, h, dpr};
    }

    function niceTicks(min, max, n=6){
      const span = max - min;
      if(span <= 0) return {ticks:[min], step:1};
      const raw = span / Math.max(2, n);
      const pow = Math.pow(10, Math.floor(Math.log10(raw)));
      const f = raw / pow;
      let step;
      if(f < 1.5) step = 1*pow;
      else if(f < 3) step = 2*pow;
      else if(f < 7) step = 5*pow;
      else step = 10*pow;
      const t0 = Math.ceil(min/step)*step;
      const ticks = [];
      for(let t=t0; t<=max+1e-12; t+=step) ticks.push(t);
      return {ticks, step};
    }

    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
      const {x,y,w,h} = box;

      // Background
      ctx.save();
      ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
      ctx.fillStyle = "rgba(0,0,0,0.10)";
      ctx.fillRect(x,y,w,h);

      // Title
      ctx.fillStyle = "rgba(234,240,255,.95)";
      ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(title, x+10, y+18);

      // Plot area
      const padL=54, padR=14, padT=28, padB=44;
      const px = x+padL, py=y+padT, pw=w-padL-padR, ph=h-padT-padB;

      // Axes box
      ctx.strokeStyle = "rgba(255,255,255,.16)";
      ctx.lineWidth = 1;
      ctx.strokeRect(px, py, pw, ph);

      // Ticks & grid
      const xt = niceTicks(xMin, xMax, 7);
      const yt = niceTicks(yMin, yMax, 6);

      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillStyle = "rgba(184,195,230,.95)";

      // gridlines
      ctx.strokeStyle = "rgba(255,255,255,.08)";
      ctx.lineWidth = 1;

      // x ticks
      for(const t of xt.ticks){
        const u = (t-xMin)/(xMax-xMin);
        const X = px + u*pw;
        ctx.beginPath(); ctx.moveTo(X, py); ctx.lineTo(X, py+ph); ctx.stroke();
        ctx.strokeStyle="rgba(255,255,255,.10)";
        ctx.beginPath(); ctx.moveTo(X, py+ph); ctx.lineTo(X, py+ph+5); ctx.stroke();
        ctx.strokeStyle="rgba(255,255,255,.08)";
        const label = (Math.abs(t) >= 1000 || Math.abs(t) < 0.01) ? t.toExponential(1) : (Math.round(t*100)/100).toString();
        const tw = ctx.measureText(label).width;
        ctx.fillText(label, X - tw/2, py+ph+18);
      }

      // y ticks
      for(const t of yt.ticks){
        const v = (t-yMin)/(yMax-yMin);
        const Y = py+ph - v*ph;
        ctx.strokeStyle="rgba(255,255,255,.08)";
        ctx.beginPath(); ctx.moveTo(px, Y); ctx.lineTo(px+pw, Y); ctx.stroke();
        ctx.strokeStyle="rgba(255,255,255,.10)";
        ctx.beginPath(); ctx.moveTo(px-5, Y); ctx.lineTo(px, Y); ctx.stroke();
        ctx.fillStyle="rgba(184,195,230,.95)";
        const label = (Math.abs(t) >= 1000 || Math.abs(t) < 0.01) ? t.toExponential(1) : (Math.round(t*100)/100).toString();
        const tw = ctx.measureText(label).width;
        ctx.fillText(label, px - 10 - tw, Y + 4);
      }

      // Axis labels
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(xLabel, px + pw/2 - ctx.measureText(xLabel).width/2, y + h - 12);

      ctx.save();
      ctx.translate(x + 14, py + ph/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
      ctx.restore();

      ctx.restore();

      return {px, py, pw, ph};
    }

    function toCanvasX(t, xMin, xMax, px, pw){
      return px + (t-xMin)/(xMax-xMin) * pw;
    }
    function toCanvasY(v, yMin, yMax, py, ph){
      return py + ph - (v-yMin)/(yMax-yMin) * ph;
    }

    function drawLegend(ctx, items, x, y){
      ctx.save();
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textBaseline = "middle";
      const pad = 8;
      const lineH = 18;
      let w = 0;
      for(const it of items){
        w = Math.max(w, 22 + ctx.measureText(it.label).width);
      }
      const h = pad*2 + items.length*lineH;
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.strokeStyle = "rgba(255,255,255,.14)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      roundRect(ctx, x, y, w+pad*2, h, 12);
      ctx.fill(); ctx.stroke();

      for(let i=0;i<items.length;i++){
        const it = items[i];
        const yy = y + pad + i*lineH + lineH/2;
        ctx.strokeStyle = it.stroke;
        ctx.lineWidth = it.width || 2;
        ctx.setLineDash(it.dash || []);
        ctx.beginPath(); ctx.moveTo(x+pad, yy); ctx.lineTo(x+pad+16, yy); ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = "rgba(234,240,255,.92)";
        ctx.fillText(it.label, x+pad+22, yy);
      }
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    // ---------- Drawers ----------
    function drawDiagram(state){
      const canvas = document.getElementById('cDiagram');
      const {ctx, w, h} = fitCanvasToCSS(canvas, 330);

      // scene
      ctx.clearRect(0,0,w,h);

      // Title strip
      ctx.fillStyle = "rgba(255,255,255,.03)";
      ctx.fillRect(0,0,w,34);
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Square dielectric waveguide geometry (side d) and NA-limited acceptance", 10, 22);

      const margin = 18;
      const gx = margin, gy = 52, gw = w - 2*margin, gh = h - 70;

      // draw core box on left
      const coreSize = Math.min(gh*0.62, gw*0.46);
      const cx = gx + 10;
      const cy = gy + (gh - coreSize)/2;

      // background panel
      ctx.fillStyle = "rgba(0,0,0,.12)";
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      roundRect(ctx, gx, gy, gw, gh, 16);
      ctx.fill(); ctx.stroke();

      // core
      ctx.fillStyle = "rgba(125,211,252,.10)";
      ctx.strokeStyle = "rgba(125,211,252,.40)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      roundRect(ctx, cx, cy, coreSize, coreSize, 14);
      ctx.fill(); ctx.stroke();

      // label d
      ctx.strokeStyle = "rgba(234,240,255,.35)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(cx, cy + coreSize + 16);
      ctx.lineTo(cx + coreSize, cy + coreSize + 16);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx, cy + coreSize + 12);
      ctx.lineTo(cx, cy + coreSize + 20);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx + coreSize, cy + coreSize + 12);
      ctx.lineTo(cx + coreSize, cy + coreSize + 20);
      ctx.stroke();

      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(`d = ${state.d_um.toFixed(0)} μm`, cx + coreSize/2 - 34, cy + coreSize + 36);

      // ray zigzag inside
      ctx.strokeStyle = "rgba(167,243,208,.70)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      const p0x = cx + coreSize*0.18, p0y = cy + coreSize*0.25;
      ctx.moveTo(p0x, p0y);
      ctx.lineTo(cx + coreSize*0.85, cy + coreSize*0.40);
      ctx.lineTo(cx + coreSize*0.20, cy + coreSize*0.58);
      ctx.lineTo(cx + coreSize*0.80, cy + coreSize*0.74);
      ctx.stroke();

      // propagation arrow (z)
      ctx.strokeStyle = "rgba(234,240,255,.55)";
      ctx.lineWidth = 2;
      const ax0 = cx + coreSize + 40, ay0 = cy + coreSize*0.50;
      const ax1 = ax0 + 120, ay1 = ay0;
      ctx.beginPath(); ctx.moveTo(ax0, ay0); ctx.lineTo(ax1, ay1); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(ax1, ay1);
      ctx.lineTo(ax1-10, ay1-6);
      ctx.lineTo(ax1-10, ay1+6);
      ctx.closePath();
      ctx.fillStyle = "rgba(234,240,255,.55)";
      ctx.fill();
      ctx.fillStyle="rgba(234,240,255,.92)";
      ctx.font="600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Propagation (z)", ax0+10, ay0-10);

      // acceptance cone on right
      const coneCx = gx + gw*0.72;
      const coneCy = gy + gh*0.50;
      const coneR = Math.min(gw*0.22, gh*0.36);

      // cone axis
      ctx.strokeStyle = "rgba(234,240,255,.30)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(coneCx - coneR*0.9, coneCy);
      ctx.lineTo(coneCx + coneR*0.9, coneCy);
      ctx.stroke();

      // angle from NA: NA = sin(theta_c) in the simplest ray picture (in air)
      const theta = Math.asin(Math.max(0, Math.min(0.999, state.NA)));
      const a1 = -theta;
      const a2 = theta;

      ctx.fillStyle = "rgba(125,211,252,.10)";
      ctx.strokeStyle = "rgba(125,211,252,.42)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(coneCx - coneR*0.85, coneCy);
      ctx.lineTo(coneCx + coneR*Math.cos(a1), coneCy + coneR*Math.sin(a1));
      ctx.lineTo(coneCx + coneR*Math.cos(a2), coneCy + coneR*Math.sin(a2));
      ctx.closePath();
      ctx.fill(); ctx.stroke();

      // angle arc
      ctx.strokeStyle = "rgba(251,191,36,.60)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(coneCx - coneR*0.85, coneCy, coneR*0.45, -theta, theta);
      ctx.stroke();

      ctx.fillStyle="rgba(234,240,255,.92)";
      ctx.font="600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(`NA = ${state.NA.toFixed(2)}`, coneCx - 30, coneCy - coneR*0.55);
      ctx.fillText(`θc ≈ asin(NA) = ${(theta*180/Math.PI).toFixed(1)}°`, coneCx - 78, coneCy + coneR*0.62);

      // small note
      ctx.fillStyle="rgba(184,195,230,.92)";
      ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("In k-space, NA sets the radius of allowed transverse wavevectors (guiding condition).", gx+16, gy+gh-14);
    }

    function drawMainPlot(state){
      const canvas = document.getElementById('cMain');
      const {ctx, w, h} = fitCanvasToCSS(canvas, 340);

      const nuMaxTHz = state.nuMaxTHz;
      const nuMinTHz = 0;
      const N = 240;

      const d_m = state.d_um * 1e-6;
      const NA = state.NA;

      const nus = [];
      const Mapp = [];
      const Mdisc = [];

      let yMax = 1;
      for(let i=0;i<=N;i++){
        const nuTHz = nuMinTHz + (nuMaxTHz-nuMinTHz)*i/N;
        const nuHz = nuTHz * 1e12;
        const ma = approxM(nuHz, d_m, NA);
        const md = discreteCount(nuHz, d_m, NA);
        nus.push(nuTHz);
        Mapp.push(ma);
        Mdisc.push(md);
        yMax = Math.max(yMax, ma, md);
      }
      // pad yMax
      yMax = yMax * 1.08;

      const box = {x:0,y:0,w:w,h:h};
      const plot = drawAxes(
        ctx, box,
        nuMinTHz, nuMaxTHz,
        0, yMax,
        "Frequency ν (THz)",
        "Number of TE modes M (count)",
        "TE mode count vs frequency (approximation + discrete staircase)"
      );

      // lines
      const {px,py,pw,ph} = plot;

      // Smooth approximation line
      ctx.save();
      ctx.strokeStyle = "rgba(125,211,252,.90)";
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      for(let i=0;i<nus.length;i++){
        const X = toCanvasX(nus[i], nuMinTHz, nuMaxTHz, px, pw);
        const Y = toCanvasY(Mapp[i], 0, yMax, py, ph);
        if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
      }
      ctx.stroke();

      // Staircase line
      ctx.strokeStyle = "rgba(167,243,208,.90)";
      ctx.lineWidth = 2.5;
      ctx.setLineDash([6,4]);
      ctx.beginPath();
      // draw as step function
      let prevX = toCanvasX(nus[0], nuMinTHz, nuMaxTHz, px, pw);
      let prevY = toCanvasY(Mdisc[0], 0, yMax, py, ph);
      ctx.moveTo(prevX, prevY);
      for(let i=1;i<nus.length;i++){
        const X = toCanvasX(nus[i], nuMinTHz, nuMaxTHz, px, pw);
        const Y = toCanvasY(Mdisc[i], 0, yMax, py, ph);
        // horizontal then vertical
        ctx.lineTo(X, prevY);
        ctx.lineTo(X, Y);
        prevY = Y;
      }
      ctx.stroke();
      ctx.setLineDash([]);

      // legend
      drawLegend(ctx, [
        {label:"Approx: M ≈ π(d·NA·ν/c)^2", stroke:"rgba(125,211,252,.90)", width:3, dash:[]},
        {label:"Discrete: lattice count (steps)", stroke:"rgba(167,243,208,.90)", width:3, dash:[6,4]},
      ], px + 10, py + 10);

      ctx.restore();
    }

    function drawSecondaryPlot(state){
      const canvas = document.getElementById('cSecond');
      const {ctx, w, h} = fitCanvasToCSS(canvas, 300);

      const nuMaxTHz = state.nuMaxTHz;
      const nuMinTHz = 0;
      const N = 220;
      const d_m = state.d_um * 1e-6;
      const NA = state.NA;

      const nus = [];
      const diff = [];
      const rel = [];

      let yMax = 1;
      for(let i=0;i<=N;i++){
        const nuTHz = nuMinTHz + (nuMaxTHz-nuMinTHz)*i/N;
        const nuHz = nuTHz * 1e12;
        const ma = approxM(nuHz, d_m, NA);
        const md = discreteCount(nuHz, d_m, NA);
        const dff = md - ma;
        const r = (Math.abs(ma) < 1e-9) ? 0 : dff/ma;
        nus.push(nuTHz);
        diff.push(dff);
        rel.push(r);
        yMax = Math.max(yMax, Math.abs(dff));
      }
      yMax = Math.max(1, yMax*1.15);

      const box = {x:0,y:0,w:w,h:h};
      const plot = drawAxes(
        ctx, box,
        nuMinTHz, nuMaxTHz,
        -yMax, yMax,
        "Frequency ν (THz)",
        "Discrete − Approx (modes)",
        "Difference between staircase count and smooth approximation"
      );
      const {px,py,pw,ph} = plot;

      // zero line
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.lineWidth = 1.2;
      const y0 = toCanvasY(0, -yMax, yMax, py, ph);
      ctx.beginPath();
      ctx.moveTo(px, y0);
      ctx.lineTo(px+pw, y0);
      ctx.stroke();

      // difference curve
      ctx.strokeStyle = "rgba(251,191,36,.90)";
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      for(let i=0;i<nus.length;i++){
        const X = toCanvasX(nus[i], nuMinTHz, nuMaxTHz, px, pw);
        const Y = toCanvasY(diff[i], -yMax, yMax, py, ph);
        if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
      }
      ctx.stroke();

      // small relative-error cue (scaled)
      // Map rel (roughly) to +/-0.25*yMax for a second faint curve
      ctx.strokeStyle = "rgba(251,113,133,.75)";
      ctx.lineWidth = 1.6;
      ctx.setLineDash([4,4]);
      ctx.beginPath();
      for(let i=0;i<nus.length;i++){
        const X = toCanvasX(nus[i], nuMinTHz, nuMaxTHz, px, pw);
        const Y = toCanvasY(rel[i]*0.25*yMax, -yMax, yMax, py, ph);
        if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
      }
      ctx.stroke();
      ctx.setLineDash([]);

      drawLegend(ctx, [
        {label:"ΔM = M_discrete − M_approx", stroke:"rgba(251,191,36,.90)", width:3, dash:[]},
        {label:"Relative cue (scaled)", stroke:"rgba(251,113,133,.75)", width:2, dash:[4,4]},
      ], px + 10, py + 10);

      ctx.restore();
    }

    // ---------- State + UI wiring ----------
    const naRange = document.getElementById('naRange');
    const naRead  = document.getElementById('naRead');
    const dSelect = document.getElementById('dSelect');
    const dRead   = document.getElementById('dRead');
    const nuMaxRange = document.getElementById('nuMaxRange');
    const nuMaxRead  = document.getElementById('nuMaxRead');

    const m200 = document.getElementById('m200');
    const m200disc = document.getElementById('m200disc');

    const state = {
      NA: parseFloat(naRange.value),
      d_um: parseFloat(dSelect.value),
      nuMaxTHz: parseFloat(nuMaxRange.value),
    };

    function updateStats(){
      const nuHz = 200e12;
      const d_m = state.d_um * 1e-6;
      const ma = approxM(nuHz, d_m, state.NA);
      const md = discreteCount(nuHz, d_m, state.NA);
      m200.textContent = ma.toFixed(1);
      m200disc.textContent = md.toString();
    }

    function renderAll(){
      naRead.textContent = state.NA.toFixed(2);
      dRead.textContent = `${state.d_um.toFixed(0)} μm`;
      nuMaxRead.textContent = `${state.nuMaxTHz.toFixed(0)} THz`;
      updateStats();
      drawDiagram(state);
      drawMainPlot(state);
      drawSecondaryPlot(state);
    }

    naRange.addEventListener('input', ()=>{
      state.NA = parseFloat(naRange.value);
      renderAll();
    });
    dSelect.addEventListener('change', ()=>{
      state.d_um = parseFloat(dSelect.value);
      renderAll();
    });
    nuMaxRange.addEventListener('input', ()=>{
      state.nuMaxTHz = parseFloat(nuMaxRange.value);
      renderAll();
    });

    window.addEventListener('resize', ()=>{
      // debounce-ish
      clearTimeout(window.__rz);
      window.__rz = setTimeout(renderAll, 80);
    });

    // Initial render
    renderAll();
  </script>
</body>
</html>
