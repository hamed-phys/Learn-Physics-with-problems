<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Parameters of a Dielectric Slab Waveguide (Planar Film): Critical Angle, NA, TE Modes, Bounce Angle, Group Velocity</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1b33;
      --card:#101f3d;
      --ink:#eaf0ff;
      --muted:#b9c6ea;
      --faint:#7f92c8;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --ok:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line: rgba(255,255,255,.10);
      --shadow: 0 18px 50px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 800px at 10% 15%, rgba(125,211,252,.13), transparent 55%),
        radial-gradient(900px 700px at 85% 25%, rgba(167,139,250,.12), transparent 55%),
        radial-gradient(1000px 800px at 60% 90%, rgba(52,211,153,.10), transparent 55%),
        var(--bg);
      color:var(--ink);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:28px 18px 10px;
      max-width:1200px;
      margin:0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.3fr .7fr;
      gap:16px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns:1fr}
    }
    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:18px 18px 16px;
      position:relative;
      overflow:hidden;
    }
    .titleCard:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(600px 250px at 20% 0%, rgba(125,211,252,.18), transparent 60%),
                  radial-gradient(500px 250px at 90% 10%, rgba(167,139,250,.14), transparent 60%);
      pointer-events:none;
      filter: blur(2px);
      opacity:.85;
    }
    .titleCard > *{position:relative}
    h1{
      margin:0 0 6px;
      font-size: clamp(1.35rem, 1.2rem + 1.2vw, 2.1rem);
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      margin:0;
      font-size: .98rem;
    }

    .toc{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:14px 14px;
      position: sticky;
      top: 14px;
      align-self:start;
      height: fit-content;
    }
    .toc h2{
      margin:0 0 8px;
      font-size: .95rem;
      color: var(--muted);
      letter-spacing:.3px;
      text-transform:uppercase;
    }
    .toc nav a{
      display:block;
      padding:6px 10px;
      border-radius: 12px;
      color: var(--ink);
      font-size: .95rem;
      opacity:.92;
      border:1px solid transparent;
    }
    .toc nav a:hover{
      background: rgba(125,211,252,.08);
      border-color: rgba(125,211,252,.22);
      text-decoration:none;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding: 10px 18px 40px;
      display:grid;
      grid-template-columns: 1fr 340px;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
      .toc{position:relative; top:auto}
    }

    section{
      background: linear-gradient(180deg, rgba(255,255,255,.045), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:16px 16px;
      margin-bottom:14px;
      overflow:hidden;
    }
    section h2{
      margin:0 0 10px;
      font-size:1.2rem;
      letter-spacing:.2px;
    }
    section h3{
      margin:14px 0 8px;
      font-size:1.03rem;
      color: var(--muted);
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 860px){
      .grid2{grid-template-columns:1fr}
    }

    .callout{
      border-radius: 16px;
      padding:12px 12px;
      border:1px solid var(--line);
      background: rgba(16,31,61,.65);
    }
    .callout strong{color:var(--accent)}
    .callout.warn strong{color:var(--warn)}
    .callout.ok strong{color:var(--ok)}
    .callout.bad strong{color:var(--bad)}

    .eqRow{
      display:flex;
      gap:10px;
      align-items:stretch;
      flex-wrap:wrap;
    }
    .eq{
      flex: 1 1 320px;
      background: rgba(0,0,0,.18);
      border:1px solid var(--line);
      border-radius: 14px;
      padding:10px 10px;
      font-family: var(--mono);
      color: #e9f3ff;
      position:relative;
      overflow:auto;
    }
    .eq .label{
      font-family: var(--sans);
      color: var(--muted);
      font-size:.85rem;
      margin-bottom:6px;
    }
    .copyBtn{
      border:1px solid rgba(125,211,252,.35);
      background: rgba(125,211,252,.10);
      color: var(--ink);
      padding:7px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-size:.9rem;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
      user-select:none;
      white-space:nowrap;
    }
    .copyBtn:hover{
      background: rgba(125,211,252,.16);
      border-color: rgba(125,211,252,.55);
    }
    .copyBtn:active{transform: translateY(1px) scale(.99)}
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      color: var(--muted);
      font-size:.92rem;
    }

    .sidePanel{
      position: sticky;
      top: 14px;
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    @media (max-width: 980px){
      .sidePanel{position:relative; top:auto}
    }
    .widget{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:14px 14px;
    }
    .widget h3{
      margin:0 0 10px;
      font-size: 1.02rem;
      color: var(--muted);
    }
    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px 10px;
      align-items:baseline;
      font-size:.95rem;
    }
    .kv div:nth-child(odd){color: var(--muted)}
    .kv div:nth-child(even){font-family: var(--mono)}
    .hr{
      height:1px;
      background: var(--line);
      margin:10px 0;
    }

    .controls{
      display:grid;
      gap:10px;
    }
    .control{
      border:1px solid var(--line);
      background: rgba(0,0,0,.14);
      border-radius: 16px;
      padding:10px 10px;
    }
    label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:baseline;
      color: var(--muted);
      font-size:.92rem;
      margin-bottom:8px;
    }
    input[type="range"]{width:100%}
    select{
      width:100%;
      background: rgba(0,0,0,.20);
      color: var(--ink);
      border:1px solid var(--line);
      border-radius: 12px;
      padding:8px 10px;
      outline:none;
    }

    figure{
      margin:0;
      border:1px solid var(--line);
      border-radius: 18px;
      overflow:hidden;
      background: rgba(0,0,0,.14);
    }
    figcaption{
      padding:10px 12px;
      color: var(--muted);
      font-size:.92rem;
      border-top:1px solid var(--line);
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      background: radial-gradient(900px 380px at 30% 15%, rgba(125,211,252,.10), transparent 60%),
                  radial-gradient(800px 360px at 80% 30%, rgba(167,139,250,.08), transparent 60%),
                  rgba(0,0,0,.18);
    }
    .canvasTall canvas{height:360px}
    .canvasShort canvas{height:280px}

    ul{margin:8px 0 0 20px}
    li{margin:4px 0}

    .finalBox{
      border:1px solid rgba(52,211,153,.35);
      background: rgba(52,211,153,.10);
      border-radius: 18px;
      padding:12px 12px;
    }
    .finalBox h3{margin:0 0 8px; color: var(--ok)}
    .finalBox .mono{font-family: var(--mono); white-space:pre-wrap}
    .note{
      color: var(--faint);
      font-size:.92rem;
    }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding: 4px 18px 28px;
      color: var(--faint);
      font-size:.92rem;
    }

    @media print{
      body{background:#fff; color:#000}
      header,main,footer{max-width:unset}
      section,.widget,.toc,.titleCard{box-shadow:none}
      .toc,.sidePanel{position:relative; top:auto}
      canvas{background:#fff}
      .copyBtn{display:none}
      a{color:#000; text-decoration:underline}
    }

    /* subtle animation */
    @keyframes floatIn{
      from{transform: translateY(6px); opacity:.0}
      to{transform: translateY(0); opacity:1}
    }
    section,.widget,.titleCard{animation: floatIn .35s ease both}
  </style>
</head>
<body>
  <header>
    <div class="hero">
      <div class="titleCard">
        <h1>9.2–3 — Parameters of a Dielectric Slab Waveguide</h1>
        <p class="subtitle">
          A thin planar film (core) of refractive index <span class="pill">n<sub>1</sub>=1.6</span> and thickness <span class="pill">d=2&nbsp;µm</span>
          guides light of free-space wavelength <span class="pill">λ<sub>0</sub>=0.87&nbsp;µm</span>, surrounded by cladding <span class="pill">n<sub>2</sub>=1.4</span>.
          We compute critical angle, numerical aperture, acceptance angle (from air), number of TE modes, and the TE<sub>0</sub> bounce angle and group velocity.
        </p>
      </div>
      <aside class="toc" aria-label="Table of contents">
        <h2>On this page</h2>
        <nav>
          <a href="#quick">Quick Summary</a>
          <a href="#part0">PART 0 — Concept Primer</a>
          <a href="#part1">PART 1 — Problem Analysis</a>
          <a href="#part2">PART 2 — Strategy &amp; Tips</a>
          <a href="#part3">PART 3 — Full Solution</a>
          <a href="#part4">PART 4 — Deeper Understanding</a>
          <a href="#part5">PART 5 — Visualization Guide</a>
        </nav>
      </aside>
    </div>
  </header>

  <main>
    <article>
      <section id="quick">
        <h2>Quick Summary</h2>
        <ul>
          <li><strong>What this is about:</strong> a symmetric dielectric <em>slab (planar)</em> waveguide and its guiding/dispersion parameters.</li>
          <li><strong>Key physics idea:</strong> guiding occurs by <em>total internal reflection</em> (TIR) and discrete modes satisfy a <em>transverse resonance</em> condition.</li>
          <li><strong>Governing ingredients:</strong> Snell’s law for the critical angle, <span class="pill">NA = √(n<sub>1</sub><sup>2</sup>−n<sub>2</sub><sup>2</sup>)</span> (for air launch), and TE slab eigenvalue equations.</li>
          <li><strong>Mode-count control:</strong> the normalized frequency <span class="pill">V = k<sub>0</sub>a√(n<sub>1</sub><sup>2</sup>−n<sub>2</sub><sup>2</sup>)</span> with <span class="pill">a=d/2</span>.</li>
          <li><strong>Final results (numeric):</strong>
            θ<sub>c</sub>≈61.0° (from the normal), its complement ≈29.0° (from the interface),
            NA≈0.7746, acceptance half-angle in air ≈50.7°.</li>
          <li><strong>Number of TE modes:</strong> for these parameters, <span class="pill">N<sub>TE</sub>=4</span> guided TE modes.</li>
          <li><strong>TE<sub>0</sub> bounce angle &amp; group velocity:</strong> θ≈83.4° (from normal; grazing angle ≈6.6°), and v<sub>g</sub>≈1.87×10<sup>8</sup> m/s.</li>
        </ul>

        <div class="eqRow" style="margin-top:12px">
          <div class="eq" id="eq1">
            <div class="label">Key equations (copy-ready)</div>
            <div>sin(θc) = n2/n1</div>
            <div>NA = √(n1² − n2²)  (air launch: n0=1)</div>
            <div>V = (2π/λ0)(d/2)√(n1² − n2²)</div>
            <div>TE even: u tan u = w,  TE odd: −u cot u = w,  u²+w²=V²</div>
            <div>β = √((n1k0)² − (u/a)²),  neff = β/k0</div>
            <div>vg = (dβ/dω)⁻¹</div>
          </div>
          <button class="copyBtn" data-copy="#eq1" title="Copy equations as plain text">Copy equations</button>
        </div>
      </section>

      <section id="part0">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <h3>Core definitions (symbols &amp; units)</h3>
        <div class="grid2">
          <div class="callout">
            <strong>Slab waveguide geometry</strong><br/>
            A planar core (index <span class="pill">n<sub>1</sub></span>) of thickness <span class="pill">d</span> surrounded by cladding (index <span class="pill">n<sub>2</sub></span>), with <span class="pill">n<sub>1</sub> &gt; n<sub>2</sub></span>.
            Propagation is along <span class="pill">z</span>, confinement is along <span class="pill">x</span>.
          </div>
          <div class="callout">
            <strong>Wavenumbers</strong><br/>
            Free-space: <span class="pill">k<sub>0</sub> = 2π/λ<sub>0</sub></span> (units: 1/length).<br/>
            In core: <span class="pill">k<sub>1</sub>=n<sub>1</sub>k<sub>0</sub></span>, in cladding: <span class="pill">k<sub>2</sub>=n<sub>2</sub>k<sub>0</sub></span>.
          </div>
        </div>

        <h3>Physical meaning of key quantities</h3>
        <div class="grid2">
          <div class="callout">
            <strong>Critical angle θ<sub>c</sub></strong><br/>
            The minimum internal incidence angle (measured from the <em>normal</em> to the interface) for TIR at the core–cladding boundary.
            If a ray inside the core hits the boundary with θ &gt; θ<sub>c</sub>, the field reflects and an evanescent tail penetrates the cladding.
          </div>
          <div class="callout">
            <strong>Propagation constant β &amp; effective index n<sub>eff</sub></strong><br/>
            Guided modes vary as exp(iβz). Define <span class="pill">n<sub>eff</sub> = β/k<sub>0</sub></span>.
            For guided modes in a dielectric slab: <span class="pill">n<sub>2</sub> &lt; n<sub>eff</sub> &lt; n<sub>1</sub></span>.
          </div>
        </div>

        <h3>Key laws/principles and validity</h3>
        <div class="callout ok">
          <strong>Principles we use</strong>
          <ul>
            <li><strong>Snell’s law</strong> at the interface → critical angle for TIR, valid for linear, isotropic dielectrics and planar boundaries.</li>
            <li><strong>Mode quantization</strong> from boundary conditions of Maxwell’s equations → discrete TE modes.</li>
            <li><strong>Waveguide dispersion</strong>: even if material indices are constant, <em>n<sub>eff</sub></em> depends on wavelength through the guiding condition.</li>
          </ul>
        </div>

        <h3>Common models/approximations (and why)</h3>
        <div class="grid2">
          <div class="callout">
            <strong>Ray (geometric) picture</strong><br/>
            Treat a mode as a zig-zagging ray undergoing TIR.
            Great for intuition: “bounce angle,” acceptance angles, qualitative mode count.
          </div>
          <div class="callout">
            <strong>Wave (modal) picture</strong><br/>
            Solve TE eigenvalue equations (even/odd) from boundary conditions.
            Needed for accurate β, n<sub>eff</sub>, and group velocity.
          </div>
        </div>

        <h3>Mini intuition examples</h3>
        <ul>
          <li>If <strong>d</strong> is very small or the index contrast is tiny, <strong>V</strong> is small → only the fundamental mode fits (single-mode behavior).</li>
          <li>If <strong>d</strong> increases, more transverse oscillations “fit” in the core → the number of guided modes increases roughly linearly with <strong>d</strong>.</li>
        </ul>

        <h3>What to watch for (pitfalls)</h3>
        <div class="callout warn">
          <strong>Typical mistakes</strong>
          <ul>
            <li>Mixing angle conventions: “from the normal” vs “from the interface.” (We compute both when helpful.)</li>
            <li>Using fiber formulas blindly: the <em>mode-count factor</em> differs for a slab because modes come in even/odd families.</li>
            <li>Confusing <strong>phase velocity</strong> (ω/β) with <strong>group velocity</strong> (dω/dβ).</li>
          </ul>
        </div>
      </section>

      <section id="part1">
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

        <h3>Restate the problem (in plain words)</h3>
        <p>
          A symmetric planar film waveguide has core index <strong>n<sub>1</sub>=1.6</strong>, cladding index <strong>n<sub>2</sub>=1.4</strong>,
          and thickness <strong>d=2&nbsp;µm</strong>. Light of free-space wavelength <strong>λ<sub>0</sub>=0.87&nbsp;µm</strong> is guided.
          We must:
          (a) find the core–cladding critical angle and its complement, the numerical aperture, and the maximum acceptance angle for light launched from air (n=1);
          (b) determine the number of guided TE modes;
          (c) find the internal bounce angle and group velocity of the TE<sub>0</sub> (m=0) mode.
        </p>

        <div class="grid2">
          <div class="callout">
            <strong>Given</strong>
            <ul>
              <li>λ<sub>0</sub> = 0.87 µm</li>
              <li>d = 2 µm (so half-thickness a = d/2 = 1 µm)</li>
              <li>n<sub>1</sub> = 1.6 (core), n<sub>2</sub> = 1.4 (cladding)</li>
              <li>launch medium (air): n<sub>0</sub>=1</li>
            </ul>
          </div>
          <div class="callout">
            <strong>Unknowns</strong>
            <ul>
              <li>θ<sub>c</sub>, complement angle (from interface)</li>
              <li>NA and acceptance half-angle in air</li>
              <li>Number of TE guided modes N<sub>TE</sub></li>
              <li>TE<sub>0</sub>: bounce angle θ and group velocity v<sub>g</sub></li>
            </ul>
          </div>
        </div>

        <h3>Relevant principles (why they apply)</h3>
        <ul>
          <li><strong>Snell’s law</strong> gives the critical angle at a planar dielectric boundary; this directly addresses (a).</li>
          <li><strong>Slab waveguide eigenvalue conditions</strong> for TE polarization determine allowed β values and count modes; this addresses (b) and (c).</li>
          <li><strong>Group velocity</strong> comes from dispersion: v<sub>g</sub> = (dβ/dω)<sup>−1</sup>. Even if n<sub>1</sub>, n<sub>2</sub> are treated constant (no material dispersion), the waveguide itself is dispersive.</li>
        </ul>

        <div class="callout">
          <strong>Assumptions</strong>
          <ul>
            <li>Lossless, isotropic dielectrics; sharp planar interfaces; symmetric cladding (same n<sub>2</sub> above/below).</li>
            <li>Material dispersion neglected unless explicitly stated (we treat n<sub>1</sub>, n<sub>2</sub> as constants at λ<sub>0</sub>).</li>
            <li>TE modes: electric field polarized transverse to the plane of incidence (standard slab TE definition).</li>
          </ul>
        </div>

        <h3>Possible approaches (compare)</h3>
        <ul>
          <li><strong>Geometric/ray optics</strong>: quick θ<sub>c</sub>, NA, acceptance; approximate mode count.
            <span class="note">Pro: fast intuition. Con: less accurate for β and v<sub>g</sub>.</span></li>
          <li><strong>Full modal (eigenvalue) solution</strong>: solve TE transcendental equations for each mode.
            <span class="note">Pro: accurate β, n<sub>eff</sub>, v<sub>g</sub>. Con: requires numerical solving.</span></li>
          <li><strong>Approximate “phase condition”</strong> with reflection phase shifts:
            <span class="note">Pro: bridges ray and wave. Con: still needs care with phase shifts.</span></li>
        </ul>

        <div class="callout ok">
          <strong>Chosen approach</strong><br/>
          Use Snell’s law for (a), the normalized frequency V plus cutoff structure for (b),
          and the TE eigenvalue equation (numerically) for TE<sub>0</sub> in (c), then compute v<sub>g</sub> from numerical differentiation.
        </div>
      </section>

      <section id="part2">
        <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>
        <ol>
          <li><strong>Compute the critical angle</strong> using sin(θ<sub>c</sub>) = n<sub>2</sub>/n<sub>1</sub>.
            <span class="note">Physically: threshold for TIR inside the core.</span></li>
          <li><strong>Compute the complement</strong> θ̄<sub>c</sub> = 90° − θ<sub>c</sub>.
            <span class="note">This is the grazing angle from the interface.</span></li>
          <li><strong>Compute numerical aperture</strong> NA = √(n<sub>1</sub><sup>2</sup> − n<sub>2</sub><sup>2</sup>) for air launch.
            <span class="note">This sets the max external launch angle.</span></li>
          <li><strong>Acceptance half-angle in air</strong>: θ<sub>max</sub> = arcsin(NA/n<sub>0</sub>) with n<sub>0</sub>=1.</li>
          <li><strong>Compute normalized frequency</strong> V = k<sub>0</sub>a√(n<sub>1</sub><sup>2</sup>−n<sub>2</sub><sup>2</sup>), where a=d/2.</li>
          <li><strong>Count TE modes</strong> by comparing V to cutoff sequence at u = π/2, π, 3π/2, ... (even/odd alternation).
            <span class="note">Common slip: using fiber’s mode count directly.</span></li>
          <li><strong>Solve TE<sub>0</sub> eigenvalue</strong> (even mode): u tan u = w with u²+w²=V² to get u, hence β and n<sub>eff</sub>.</li>
          <li><strong>Get bounce angle</strong> from sin θ = β/(n<sub>1</sub>k<sub>0</sub>) = n<sub>eff</sub>/n<sub>1</sub>.</li>
          <li><strong>Compute group velocity</strong> v<sub>g</sub> = (dβ/dω)<sup>−1</sup> by a small numerical derivative around λ<sub>0</sub>.
            <span class="note">Tip: keep units consistent (convert µm ↔ m).</span></li>
        </ol>

        <div class="callout warn">
          <strong>Quick tips</strong>
          <ul>
            <li>Angles: internal θ is measured from the <strong>normal</strong> unless stated; “complement” is from the <strong>interface</strong>.</li>
            <li>For TE eigenvalue solving, always bracket roots between tangent/cotangent singularities.</li>
            <li>Sanity check: guided modes must satisfy n<sub>2</sub> &lt; n<sub>eff</sub> &lt; n<sub>1</sub>.</li>
          </ul>
        </div>
      </section>

      <section id="part3">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <h3>Physical intuition before calculation</h3>
        <p>
          Since <span class="pill">n<sub>1</sub> &gt; n<sub>2</sub></span>, light can be trapped by total internal reflection.
          A thicker core (<span class="pill">d=2&nbsp;µm</span>) relative to the wavelength (<span class="pill">λ<sub>0</sub>=0.87&nbsp;µm</span>)
          suggests several TE modes may fit. The fundamental TE<sub>0</sub> mode usually has an effective index close to n<sub>1</sub>,
          meaning its energy is strongly concentrated in the core and its “ray angle” is close to grazing.
        </p>

        <h3>(a) Critical angle, complement, NA, acceptance angle (air launch)</h3>

        <div class="eqRow">
          <div class="eq" id="eqCritical">
            <div class="label">Critical angle (inside the core, from the normal)</div>
            <div>sin(θc) = n2 / n1</div>
          </div>
          <button class="copyBtn" data-copy="#eqCritical">Copy</button>
        </div>

        <p>
          Insert n<sub>1</sub>=1.6 and n<sub>2</sub>=1.4:
        </p>

        <div class="eq" id="eqCriticalCalc">
          <div class="label">Numerical evaluation</div>
          <div>n2/n1 = 1.4/1.6 = 0.875</div>
          <div>θc = arcsin(0.875) ≈ 61.0°</div>
          <div>θ̄c = 90° − θc ≈ 29.0°</div>
        </div>
        <div style="margin-top:8px" class="eqRow">
          <button class="copyBtn" data-copy="#eqCriticalCalc">Copy values</button>
        </div>

        <p class="note">
          Interpretation: rays inside the core must hit the boundary with θ &gt; 61° (from the normal) to be totally internally reflected.
          Equivalently, the angle from the interface must be less than 29°.
        </p>

        <div class="eqRow">
          <div class="eq" id="eqNA">
            <div class="label">Numerical aperture and acceptance half-angle (launch from air n0=1)</div>
            <div>NA = √(n1² − n2²)</div>
            <div>sin(θmax) = NA / n0  (here n0=1)</div>
          </div>
          <button class="copyBtn" data-copy="#eqNA">Copy</button>
        </div>

        <p>
          Compute:
          n<sub>1</sub><sup>2</sup> − n<sub>2</sub><sup>2</sup> = 2.56 − 1.96 = 0.60, so
        </p>

        <div class="eq" id="eqNACalc">
          <div class="label">Numerical evaluation</div>
          <div>NA = √0.60 ≈ 0.7746</div>
          <div>θmax = arcsin(0.7746) ≈ 50.7°  (in air)</div>
        </div>
        <div style="margin-top:8px" class="eqRow">
          <button class="copyBtn" data-copy="#eqNACalc">Copy values</button>
        </div>

        <div class="callout">
          <strong>Sanity check</strong>
          <ul>
            <li>NA must be ≤ n<sub>1</sub>. Here NA ≈ 0.77, reasonable.</li>
            <li>Acceptance angle in air must be ≤ 90°. Here 50.7° is plausible.</li>
          </ul>
        </div>

        <h3>(b) Number of TE modes</h3>

        <div class="eqRow">
          <div class="eq" id="eqV">
            <div class="label">Normalized frequency for a symmetric slab</div>
            <div>a = d/2</div>
            <div>V = k0 a √(n1² − n2²) = (2π/λ0)(d/2)√(n1² − n2²)</div>
          </div>
          <button class="copyBtn" data-copy="#eqV">Copy</button>
        </div>

        <p>
          First compute k<sub>0</sub> and V:
        </p>

        <div class="eq" id="eqVCalc">
          <div class="label">Numerical evaluation</div>
          <div>k0 = 2π/λ0 = 2π / (0.87 µm) ≈ 7.223 µm⁻¹</div>
          <div>a = d/2 = 1 µm</div>
          <div>√(n1² − n2²) = √0.60 ≈ 0.7746</div>
          <div>V ≈ (7.223)(1)(0.7746) ≈ 5.594</div>
        </div>
        <div style="margin-top:8px" class="eqRow">
          <button class="copyBtn" data-copy="#eqVCalc">Copy values</button>
        </div>

        <p>
          For a symmetric slab, TE modes alternate in parity (even, odd, even, odd, ...).
          At cutoff, the cladding decay parameter w → 0 and the core parameter u → V.
          The cutoff values are:
        </p>

        <div class="eq" id="eqCutoff">
          <div class="label">Cutoff sequence (TE)</div>
          <div>Even modes:  w=0 ⇒ tan(u)=0 ⇒ u = mπ</div>
          <div>Odd modes:   w=0 ⇒ cot(u)=0 ⇒ u = (m + 1/2)π</div>
          <div>Modes exist when the corresponding cutoff u is &lt; V.</div>
        </div>
        <div style="margin-top:8px" class="eqRow">
          <button class="copyBtn" data-copy="#eqCutoff">Copy</button>
        </div>

        <p>
          Now compare V = 5.594 to the cutoff points:
          π/2 ≈ 1.571, π ≈ 3.142, 3π/2 ≈ 4.712, 2π ≈ 6.283.
          We have:
        </p>
        <ul>
          <li>V &gt; π/2 → TE<sub>1</sub> exists,</li>
          <li>V &gt; π → TE<sub>2</sub> exists,</li>
          <li>V &gt; 3π/2 → TE<sub>3</sub> exists,</li>
          <li>but V &lt; 2π → TE<sub>4</sub> does <em>not</em> exist.</li>
        </ul>

        <div class="finalBox" id="finalModes">
          <h3>Result (b): Number of TE modes</h3>
          <div class="mono">N_TE = 4 guided TE modes (TE0, TE1, TE2, TE3).</div>
          <div style="margin-top:10px">
            <button class="copyBtn" data-copy="#finalModes">Copy</button>
          </div>
        </div>

        <h3>(c) Bounce angle and group velocity of the m = 0 TE mode</h3>

        <p>
          For a symmetric slab, define:
          <span class="pill">a=d/2</span>,
          <span class="pill">u = a√(n<sub>1</sub><sup>2</sup>k<sub>0</sub><sup>2</sup> − β<sup>2</sup>)</span>,
          <span class="pill">w = a√(β<sup>2</sup> − n<sub>2</sub><sup>2</sup>k<sub>0</sub><sup>2</sup>)</span>,
          and <span class="pill">u²+w²=V²</span>.
          The TE<sub>0</sub> mode is <strong>even</strong>, so the eigenvalue equation is:
        </p>

        <div class="eqRow">
          <div class="eq" id="eqTE0">
            <div class="label">TE0 (even) eigenvalue equation</div>
            <div>u tan(u) = w</div>
            <div>with w = √(V² − u²)</div>
          </div>
          <button class="copyBtn" data-copy="#eqTE0">Copy</button>
        </div>

        <p>
          For our V=5.594, the TE<sub>0</sub> solution lies in the interval 0 &lt; u &lt; π/2.
          Solving numerically gives:
        </p>

        <div class="eq" id="eqTE0Calc">
          <div class="label">Numerical mode solution (TE0)</div>
          <div>u ≈ 1.3306</div>
          <div>β = √((n1 k0)² − (u/a)²)  ⇒  n_eff = β/k0 ≈ 1.5894</div>
        </div>
        <div style="margin-top:8px" class="eqRow">
          <button class="copyBtn" data-copy="#eqTE0Calc">Copy values</button>
        </div>

        <h4>Bounce angle θ</h4>
        <p>
          In the ray picture, inside the core the wavevector magnitude is k<sub>1</sub>=n<sub>1</sub>k<sub>0</sub>.
          The propagation constant is the z-component:
          <span class="pill">β = k<sub>1</sub> sin θ</span> if θ is measured from the <strong>normal</strong> to the interface (x-axis),
          i.e., larger θ means more grazing propagation.
          Therefore:
        </p>

        <div class="eqRow">
          <div class="eq" id="eqAngle">
            <div class="label">Angle from β (θ measured from the normal)</div>
            <div>sin(θ) = β/(n1 k0) = n_eff / n1</div>
          </div>
          <button class="copyBtn" data-copy="#eqAngle">Copy</button>
        </div>

        <p>
          Using n<sub>eff</sub>≈1.5894 and n<sub>1</sub>=1.6:
        </p>

        <div class="eq" id="eqAngleCalc">
          <div class="label">Numerical bounce angle</div>
          <div>sin(θ) ≈ 1.5894/1.6 ≈ 0.99335</div>
          <div>θ ≈ 83.4° (from the normal)</div>
          <div>Grazing angle from interface: 90° − θ ≈ 6.6°</div>
        </div>
        <div style="margin-top:8px" class="eqRow">
          <button class="copyBtn" data-copy="#eqAngleCalc">Copy values</button>
        </div>

        <div class="callout">
          <strong>Angle sanity check</strong>
          <ul>
            <li>We must have θ &gt; θ<sub>c</sub> = 61.0° for TIR. Here θ≈83.4°, so the mode is safely guided.</li>
            <li>Because TE<sub>0</sub> is strongly confined, n<sub>eff</sub> is close to n<sub>1</sub> → θ is close to 90° (grazing), which matches our result.</li>
          </ul>
        </div>

        <h4>Group velocity v<sub>g</sub></h4>
        <p>
          Group velocity measures the speed of an envelope (energy/information) along z:
        </p>

        <div class="eqRow">
          <div class="eq" id="eqVg">
            <div class="label">Definition of group velocity</div>
            <div>v_g = dω/dβ = (dβ/dω)⁻¹</div>
            <div>ω = 2πc/λ0</div>
          </div>
          <button class="copyBtn" data-copy="#eqVg">Copy</button>
        </div>

        <p>
          Here n<sub>1</sub>, n<sub>2</sub> are treated constant (no material dispersion), but β still depends on ω through the eigenvalue equation,
          so we compute dβ/dω numerically (a small wavelength step around λ<sub>0</sub>).
          The result for the given parameters is:
        </p>

        <div class="finalBox" id="finalC">
          <h3>Result (c): TE0 bounce angle &amp; group velocity</h3>
          <div class="mono">θ ≈ 83.4° (from the normal),  (90°−θ) ≈ 6.6° (from the interface)
v_g ≈ 1.87 × 10^8 m/s</div>
          <div style="margin-top:10px">
            <button class="copyBtn" data-copy="#finalC">Copy</button>
          </div>
          <p class="note" style="margin:10px 0 0">
            Equivalent group index: n_g = c/v_g ≈ 1.607 (slightly larger than n_eff due to waveguide dispersion).
          </p>
        </div>

        <h3>Connection to the diagram and plots</h3>
        <p>
          The diagram shows the core film of thickness d and the zig-zag “ray” for the TE<sub>0</sub> mode.
          The main plot below sweeps thickness and shows how <em>n<sub>eff</sub></em> for each TE mode rises toward n<sub>1</sub> as confinement strengthens.
          The secondary plot shows how v<sub>g</sub> for TE<sub>0</sub> changes with thickness—capturing <em>waveguide dispersion</em>.
        </p>

        <div class="grid2">
          <figure class="canvasShort">
            <canvas id="diagram"></canvas>
            <figcaption>
              <strong>Diagram:</strong> Symmetric dielectric slab waveguide (core n<sub>1</sub>, cladding n<sub>2</sub>), thickness d, guided propagation along z.
            </figcaption>
          </figure>
          <figure class="canvasShort">
            <canvas id="plotMain"></canvas>
            <figcaption>
              <strong>Main plot:</strong> Effective index n<sub>eff</sub>(d) for all guided TE modes at the selected wavelength.
            </figcaption>
          </figure>
        </div>

        <figure class="canvasTall" style="margin-top:12px">
          <canvas id="plotSecondary"></canvas>
          <figcaption>
            <strong>Secondary plot:</strong> Group velocity v<sub>g</sub>(d) for TE<sub>0</sub> (waveguide dispersion) at the selected wavelength.
          </figcaption>
        </figure>
      </section>

      <section id="part4">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <h3>Re-interpret the final formulas</h3>
        <div class="grid2">
          <div class="callout">
            <strong>What controls NA?</strong><br/>
            NA = √(n<sub>1</sub><sup>2</sup> − n<sub>2</sub><sup>2</sup>).
            Increasing index contrast (larger n<sub>1</sub>−n<sub>2</sub>) increases NA, meaning the waveguide can accept a wider range of launch angles.
          </div>
          <div class="callout">
            <strong>What controls mode count?</strong><br/>
            V = (2π/λ<sub>0</sub>)(d/2)√(n<sub>1</sub><sup>2</sup>−n<sub>2</sub><sup>2</sup>).
            Bigger d, shorter λ<sub>0</sub>, or larger index contrast → bigger V → more TE modes.
          </div>
        </div>

        <h3>How changing parameters affects the outcome (tie to interactive plots)</h3>
        <ul>
          <li><strong>Increase d</strong>: V increases → more TE modes appear (new curves emerge in the main plot) and n<sub>eff</sub> for existing modes tends to rise toward n<sub>1</sub>.</li>
          <li><strong>Increase λ<sub>0</sub></strong>: V decreases → fewer guided modes; n<sub>eff</sub> drops toward n<sub>2</sub> as confinement weakens.</li>
          <li><strong>Increase n<sub>1</sub>−n<sub>2</sub></strong>: stronger confinement → higher n<sub>eff</sub> and typically weaker waveguide dispersion (v<sub>g</sub> changes more gently).</li>
        </ul>

        <h3>Alternative derivation idea (brief)</h3>
        <p>
          Instead of solving u tan u = w directly, you can start from a <strong>transverse resonance condition</strong>:
          the round-trip phase across the core plus reflection phase shifts at both interfaces must equal 2πm.
          This “phase matching” route cleanly connects ray optics (bounces) to modal dispersion.
        </p>

        <h3>Concept checks (quick self-test)</h3>
        <ul>
          <li><strong>Q:</strong> Why must n<sub>eff</sub> lie between n<sub>2</sub> and n<sub>1</sub>? <strong>A:</strong> Because the mode must propagate in the core (β &lt; n<sub>1</sub>k<sub>0</sub>) while decaying evanescently in the cladding (β &gt; n<sub>2</sub>k<sub>0</sub>).</li>
          <li><strong>Q:</strong> If d halves, what happens to the number of modes? <strong>A:</strong> V halves, so fewer modes fit; some higher-order modes cut off.</li>
          <li><strong>Q:</strong> Can v<sub>g</sub> differ from c/n<sub>eff</sub> even if n<sub>1</sub>, n<sub>2</sub> are constant? <strong>A:</strong> Yes—waveguide dispersion makes n<sub>eff</sub> frequency-dependent, affecting dβ/dω.</li>
          <li><strong>Q:</strong> Does a larger bounce angle θ (from the normal) mean better confinement? <strong>A:</strong> Generally yes; larger θ implies more grazing propagation and larger β, pushing n<sub>eff</sub> toward n<sub>1</sub>.</li>
        </ul>
      </section>

      <section id="part5">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

        <h3>What each canvas shows</h3>
        <ul>
          <li><strong>Diagram canvas:</strong> the slab (core thickness d, indices n<sub>1</sub>, n<sub>2</sub>), a sample zig-zag ray, and angle labels (θ from normal, 90°−θ from interface).</li>
          <li><strong>Main plot:</strong> n<sub>eff</sub> vs thickness d for each guided TE mode at the chosen λ<sub>0</sub>. Curves appear/disappear at cutoff thicknesses.</li>
          <li><strong>Secondary plot:</strong> v<sub>g</sub> vs thickness d for TE<sub>0</sub>. This highlights waveguide dispersion.</li>
        </ul>

        <h3>Interactive controls</h3>
        <div class="callout">
          <strong>Controls change a meaningful parameter and update everything live</strong>
          <ul>
            <li><strong>Thickness d slider:</strong> changes confinement strength (through V). You should see the number of guided modes change and the curves shift.</li>
            <li><strong>Wavelength selector:</strong> changes k<sub>0</sub> and V. Longer λ reduces V → fewer modes and lower n<sub>eff</sub>.</li>
          </ul>
        </div>

        <p class="note">
          All symbols and parameters used in the plots match those used in the text: n<sub>1</sub>, n<sub>2</sub>, d, λ<sub>0</sub>, V, n<sub>eff</sub>, v<sub>g</sub>.
        </p>
      </section>
    </article>

    <aside class="sidePanel" aria-label="Interactive panel and computed values">
      <div class="widget">
        <h3>Interactive Controls</h3>
        <div class="controls">
          <div class="control">
            <label>
              <span>Core thickness d (µm)</span>
              <span class="pill"><span id="dVal">2.00</span></span>
            </label>
            <input id="dSlider" type="range" min="0.2" max="6.0" step="0.01" value="2.0" />
          </div>
          <div class="control">
            <label>
              <span>Wavelength λ<sub>0</sub> (µm)</span>
              <span class="pill"><span id="lamVal">0.87</span></span>
            </label>
            <select id="lamSelect">
              <option value="0.60">0.60</option>
              <option value="0.87" selected>0.87</option>
              <option value="1.00">1.00</option>
              <option value="1.30">1.30</option>
              <option value="1.55">1.55</option>
            </select>
          </div>
        </div>
        <div class="hr"></div>
        <div class="note">Indices fixed (problem values): n<sub>1</sub>=1.6, n<sub>2</sub>=1.4, launch medium n<sub>0</sub>=1.</div>
      </div>

      <div class="widget">
        <h3>Computed (updates live)</h3>
        <div class="kv" id="kvLive">
          <!-- filled by JS -->
        </div>
        <div class="hr"></div>
        <button class="copyBtn" id="copyFinalBtn" title="Copy the live final answers as plain text">Copy live answers</button>
      </div>

      <div class="widget">
        <h3>Problem’s numeric answers (at d=2 µm, λ0=0.87 µm)</h3>
        <div class="kv">
          <div>θc (from normal)</div><div>≈ 61.0°</div>
          <div>θ̄c (from interface)</div><div>≈ 29.0°</div>
          <div>NA</div><div>≈ 0.7746</div>
          <div>θmax in air</div><div>≈ 50.7°</div>
          <div>N_TE</div><div>4</div>
          <div>TE0 θ</div><div>≈ 83.4°</div>
          <div>TE0 v_g</div><div>≈ 1.87×10^8 m/s</div>
        </div>
      </div>
    </aside>
  </main>

  <footer>
    Built as a single, self-contained HTML learning article. Interactive numerics use the symmetric TE slab eigenvalue equations (even/odd) and finite-difference group velocity.
  </footer>

  <script>
    // ---------- Utilities ----------
    function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
    function rad(deg){ return deg*Math.PI/180; }
    function deg(rad){ return rad*180/Math.PI; }
    function fmt(x, digits=4){
      if(!isFinite(x)) return "—";
      const ax = Math.abs(x);
      if(ax !== 0 && (ax >= 1e5 || ax < 1e-3)) return x.toExponential(3);
      return x.toFixed(digits);
    }
    function fmtDeg(x){ return isFinite(x) ? x.toFixed(1) + "°" : "—"; }
    function copyText(text){
      navigator.clipboard.writeText(text).then(()=>flashToast("Copied ✓")).catch(()=>flashToast("Copy failed"));
    }
    function flashToast(msg){
      const t = document.createElement("div");
      t.textContent = msg;
      t.style.position="fixed";
      t.style.left="50%"; t.style.top="14px";
      t.style.transform="translateX(-50%)";
      t.style.padding="10px 12px";
      t.style.borderRadius="999px";
      t.style.background="rgba(0,0,0,.65)";
      t.style.border="1px solid rgba(255,255,255,.18)";
      t.style.color="#fff";
      t.style.zIndex="9999";
      t.style.fontSize="14px";
      t.style.backdropFilter="blur(8px)";
      document.body.appendChild(t);
      setTimeout(()=>{ t.style.transition="opacity .25s ease"; t.style.opacity="0"; }, 850);
      setTimeout(()=>t.remove(), 1150);
    }

    // Copy buttons for equations / final answer blocks
    document.querySelectorAll(".copyBtn[data-copy]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const sel = btn.getAttribute("data-copy");
        const el = document.querySelector(sel);
        if(!el) return;
        const text = el.innerText.replace(/\n{3,}/g,"\n\n").trim();
        copyText(text);
      });
    });

    // ---------- Physics core (symmetric TE slab) ----------
    const c0 = 299792458; // m/s
    const n1 = 1.6;
    const n2 = 1.4;
    const n0 = 1.0;

    function k0_um(lam_um){ return 2*Math.PI/lam_um; } // rad/µm

    function V_of(lam_um, d_um){
      const a = d_um/2;
      const k0 = k0_um(lam_um);
      return k0*a*Math.sqrt(n1*n1 - n2*n2);
    }

    // Even (TE): f(u)= u tan u - w, with w=sqrt(V^2-u^2)
    // Odd  (TE): f(u)= -u cot u - w = -u/tan u - w
    function f_even(u, V){
      const w = Math.sqrt(Math.max(0, V*V - u*u));
      return u*Math.tan(u) - w;
    }
    function f_odd(u, V){
      const w = Math.sqrt(Math.max(0, V*V - u*u));
      return (-u/Math.tan(u)) - w;
    }

    function bisectRoot(func, V, lo, hi, maxIter=80){
      let fLo = func(lo, V), fHi = func(hi, V);
      if(!isFinite(fLo) || !isFinite(fHi) || fLo*fHi > 0) return NaN;
      for(let i=0;i<maxIter;i++){
        const mid = 0.5*(lo+hi);
        const fMid = func(mid, V);
        if(!isFinite(fMid)) return NaN;
        if(Math.abs(fMid) < 1e-10) return mid;
        if(fLo*fMid <= 0){ hi = mid; fHi = fMid; }
        else { lo = mid; fLo = fMid; }
      }
      return 0.5*(lo+hi);
    }

    // Solve u for TE mode index p (p=0,1,2... for TE0, TE1, ...)
    // parity alternates: p even => even equation, p odd => odd equation.
    // Bracketing intervals:
    // even (m): u in (mπ, mπ+π/2)
    // odd  (m): u in (mπ+π/2, (m+1)π)
    function solve_u_for_mode(p, V){
      const eps = 1e-6;
      if(V <= 0) return NaN;

      const even = (p % 2 === 0);
      const m = even ? (p/2) : ((p-1)/2);

      let lo, hi, func;

      if(even){
        lo = m*Math.PI + (m===0 ? eps : eps);
        hi = m*Math.PI + Math.PI/2 - eps;
        func = f_even;
        // Fundamental even mode exists for any V>0; but if V < hi, cap interval at V-eps
        if(V < hi) hi = V - eps;
      } else {
        lo = m*Math.PI + Math.PI/2 + eps;
        hi = (m+1)*Math.PI - eps;
        func = f_odd;
        if(V < lo) return NaN; // cutoff not reached
        if(V < hi) hi = V - eps;
      }

      if(!(hi > lo)) return NaN;

      // ensure sign change: if not, try to find a sub-interval by scanning
      let fLo = func(lo, V), fHi = func(hi, V);
      if(!isFinite(fLo) || !isFinite(fHi)) return NaN;

      if(fLo*fHi > 0){
        // scan for bracket
        const N = 80;
        let prevU = lo, prevF = fLo;
        for(let i=1;i<=N;i++){
          const u = lo + (hi-lo)*i/N;
          const f = func(u, V);
          if(isFinite(f) && isFinite(prevF) && prevF*f <= 0){
            return bisectRoot(func, V, prevU, u);
          }
          prevU = u; prevF = f;
        }
        return NaN;
      }
      return bisectRoot(func, V, lo, hi);
    }

    function beta_neff_from_u(u, lam_um, d_um){
      const a = d_um/2;
      const k0 = k0_um(lam_um);
      // beta = sqrt( (n1 k0)^2 - (u/a)^2 )
      const term = (n1*k0)*(n1*k0) - (u/a)*(u/a);
      if(term <= 0) return {beta:NaN, neff:NaN};
      const beta = Math.sqrt(term);
      return {beta, neff: beta/k0};
    }

    function count_TE_modes(V){
      // Count modes by checking cutoff sequence: π/2, π, 3π/2, 2π, ...; plus fundamental always.
      // Equivalent: N = floor(2V/π) + 1
      return Math.max(0, Math.floor(2*V/Math.PI) + 1);
    }

    function criticalAngles(){
      const s = n2/n1;
      const th_c = deg(Math.asin(clamp(s,0,1)));
      return {theta_c: th_c, theta_c_comp: 90 - th_c};
    }

    function NA_air(){ return Math.sqrt(Math.max(0, n1*n1 - n2*n2)); }

    function acceptanceAngleAir(){
      const NA = NA_air();
      const s = clamp(NA/n0, 0, 1);
      return deg(Math.asin(s));
    }

    function te0_solution(lam_um, d_um){
      const V = V_of(lam_um, d_um);
      const u = solve_u_for_mode(0, V);
      const {beta, neff} = beta_neff_from_u(u, lam_um, d_um);
      return {V, u, beta, neff};
    }

    function bounceAngleFromNeff(neff){
      // sin θ = neff / n1 (θ from normal)
      const s = clamp(neff/n1, 0, 1);
      const th = deg(Math.asin(s));
      return {theta: th, grazing: 90 - th};
    }

    function vg_TE0(lam_um, d_um){
      // v_g = (dβ/dω)^-1, use finite difference in wavelength
      // Keep indices constant, so β depends on λ through eigenvalue.
      const h = 1e-4; // µm
      const lam1 = Math.max(0.2, lam_um - h);
      const lam2 = lam_um + h;

      const s1 = te0_solution(lam1, d_um);
      const s2 = te0_solution(lam2, d_um);

      if(!isFinite(s1.beta) || !isFinite(s2.beta)) return NaN;

      // Convert beta from rad/µm to rad/m
      const beta1 = s1.beta * 1e6;
      const beta2 = s2.beta * 1e6;

      const lam1_m = lam1 * 1e-6;
      const lam2_m = lam2 * 1e-6;
      const lam0_m = lam_um * 1e-6;

      const dBeta_dLam = (beta2 - beta1) / (lam2_m - lam1_m);

      // ω = 2πc/λ -> dω/dλ = -2πc/λ^2
      const dOmega_dLam = -2*Math.PI*c0/(lam0_m*lam0_m);

      const dBeta_dOmega = dBeta_dLam / dOmega_dLam;
      const vg = 1 / dBeta_dOmega;
      return vg; // m/s
    }

    // ---------- Canvas drawing helpers ----------
    function setupCanvas(canvas){
      const ctx = canvas.getContext("2d");
      function resize(){
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.max(2, Math.floor(rect.width * dpr));
        canvas.height = Math.max(2, Math.floor(rect.height * dpr));
        ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
        return {w: rect.width, h: rect.height, dpr};
      }
      return {ctx, resize};
    }

    function drawGrid(ctx, x0,y0,w,h, nx=8, ny=6){
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,.08)";
      ctx.lineWidth = 1;
      for(let i=0;i<=nx;i++){
        const x = x0 + w*i/nx;
        ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+h); ctx.stroke();
      }
      for(let j=0;j<=ny;j++){
        const y = y0 + h*j/ny;
        ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+w,y); ctx.stroke();
      }
      ctx.restore();
    }

    function drawAxes(ctx, plot){
      const {x,y,w,h} = plot;
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,.22)";
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(x, y+h);
      ctx.lineTo(x+w, y+h);
      ctx.moveTo(x, y);
      ctx.lineTo(x, y+h);
      ctx.stroke();
      ctx.restore();
    }

    function drawTicks(ctx, plot, xTicks, yTicks, xLabel, yLabel, title){
      const {x,y,w,h} = plot;
      ctx.save();
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.strokeStyle = "rgba(255,255,255,.22)";
      ctx.lineWidth = 1;
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";

      // Title
      ctx.font = "13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(title, x, y-10);

      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";

      // X ticks
      xTicks.forEach(t=>{
        const px = x + w*t.p;
        ctx.beginPath();
        ctx.moveTo(px, y+h);
        ctx.lineTo(px, y+h+6);
        ctx.stroke();
        ctx.fillStyle = "rgba(185,198,234,.95)";
        ctx.fillText(t.label, px-10, y+h+18);
      });

      // Y ticks
      yTicks.forEach(t=>{
        const py = y + h*(1-t.p);
        ctx.beginPath();
        ctx.moveTo(x-6, py);
        ctx.lineTo(x, py);
        ctx.stroke();
        ctx.fillStyle = "rgba(185,198,234,.95)";
        ctx.fillText(t.label, x-44, py+4);
      });

      // Labels
      ctx.font = "13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillStyle = "rgba(234,240,255,.90)";
      ctx.fillText(xLabel, x + w*0.35, y+h+42);

      ctx.save();
      ctx.translate(x-58, y + h*0.62);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();

      ctx.restore();
    }

    function mapX(x, xmin, xmax, plot){
      return plot.x + plot.w*(x - xmin)/(xmax - xmin);
    }
    function mapY(y, ymin, ymax, plot){
      return plot.y + plot.h*(1 - (y - ymin)/(ymax - ymin));
    }

    function drawLine(ctx, pts, plot){
      ctx.beginPath();
      let started=false;
      for(const p of pts){
        if(!p.ok){
          started=false;
          continue;
        }
        const px = mapX(p.x, plot.xmin, plot.xmax, plot);
        const py = mapY(p.y, plot.ymin, plot.ymax, plot);
        if(!started){ ctx.moveTo(px,py); started=true; }
        else ctx.lineTo(px,py);
      }
      ctx.stroke();
    }

    // ---------- Canvases ----------
    const diagramC = setupCanvas(document.getElementById("diagram"));
    const mainC = setupCanvas(document.getElementById("plotMain"));
    const secC = setupCanvas(document.getElementById("plotSecondary"));

    // ---------- UI ----------
    const dSlider = document.getElementById("dSlider");
    const lamSelect = document.getElementById("lamSelect");
    const dVal = document.getElementById("dVal");
    const lamVal = document.getElementById("lamVal");
    const kvLive = document.getElementById("kvLive");
    const copyFinalBtn = document.getElementById("copyFinalBtn");

    function buildLiveTable(state){
      const rows = [
        ["θc (from normal)", fmtDeg(state.theta_c)],
        ["θ̄c (from interface)", fmtDeg(state.theta_c_comp)],
        ["NA (air launch)", fmt(state.NA, 4)],
        ["θmax in air", fmtDeg(state.theta_max_air)],
        ["V", fmt(state.V, 4)],
        ["N_TE", String(state.N_TE)],
        ["TE0 n_eff", fmt(state.neff0, 6)],
        ["TE0 θ (from normal)", fmtDeg(state.theta0)],
        ["TE0 grazing (from interface)", fmtDeg(state.grazing0)],
        ["TE0 v_g", isFinite(state.vg0) ? (fmt(state.vg0/1e8,3) + "×10^8 m/s") : "—"],
      ];
      kvLive.innerHTML = "";
      rows.forEach(([k,v])=>{
        const a = document.createElement("div"); a.textContent = k;
        const b = document.createElement("div"); b.textContent = v;
        kvLive.appendChild(a); kvLive.appendChild(b);
      });
    }

    copyFinalBtn.addEventListener("click", ()=>{
      const state = computeState();
      const txt =
`Given: n1=1.6, n2=1.4, n0=1, d=${state.d.toFixed(2)} µm, λ0=${state.lam.toFixed(2)} µm

(a)
θc = ${state.theta_c.toFixed(1)}° (from normal)
θ̄c = ${state.theta_c_comp.toFixed(1)}° (from interface)
NA = ${state.NA.toFixed(4)}
θmax (air) = ${state.theta_max_air.toFixed(1)}°

(b)
V = ${state.V.toFixed(4)}
N_TE = ${state.N_TE}

(c) TE0
n_eff = ${state.neff0.toFixed(6)}
θ = ${state.theta0.toFixed(1)}° (from normal), grazing = ${(state.grazing0).toFixed(1)}°
v_g ≈ ${isFinite(state.vg0) ? state.vg0.toExponential(3) : "—"} m/s`;
      copyText(txt);
    });

    // ---------- Drawing: Diagram ----------
    function drawDiagram(state){
      const {ctx, resize} = diagramC;
      const {w,h} = resize();
      ctx.clearRect(0,0,w,h);

      // Frame padding
      const pad = 18;
      const x0 = pad, y0 = pad, W = w-2*pad, H = h-2*pad;

      // Regions
      const coreH = H*0.28;
      const coreY = y0 + H*0.36;
      const coreX = x0 + W*0.08;
      const coreW = W*0.84;

      // Labels
      ctx.save();
      ctx.fillStyle = "rgba(234,240,255,.95)";
      ctx.font = "13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";

      // Draw cladding background subtly
      ctx.fillStyle = "rgba(255,255,255,.03)";
      ctx.fillRect(x0, y0, W, H);

      // Core rectangle
      ctx.fillStyle = "rgba(125,211,252,.12)";
      ctx.strokeStyle = "rgba(125,211,252,.35)";
      ctx.lineWidth = 2;
      ctx.fillRect(coreX, coreY, coreW, coreH);
      ctx.strokeRect(coreX, coreY, coreW, coreH);

      // Core label
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.fillText(`core: n1=${n1.toFixed(1)}`, coreX+10, coreY+18);
      ctx.fillStyle = "rgba(185,198,234,.9)";
      ctx.fillText(`cladding: n2=${n2.toFixed(1)}`, coreX+10, y0+18);
      ctx.fillText(`cladding: n2=${n2.toFixed(1)}`, coreX+10, y0+H-10);

      // Thickness d arrow
      ctx.strokeStyle = "rgba(167,139,250,.55)";
      ctx.lineWidth = 2;
      const ax = coreX + coreW + 16;
      const yTop = coreY;
      const yBot = coreY + coreH;
      ctx.beginPath();
      ctx.moveTo(ax, yTop);
      ctx.lineTo(ax, yBot);
      ctx.stroke();
      // arrowheads
      function arrowHead(x,y,dir){
        ctx.beginPath();
        ctx.moveTo(x,y);
        ctx.lineTo(x-6, y+6*dir);
        ctx.lineTo(x+6, y+6*dir);
        ctx.closePath();
        ctx.fillStyle = "rgba(167,139,250,.70)";
        ctx.fill();
      }
      arrowHead(ax, yTop, -1);
      arrowHead(ax, yBot, +1);
      ctx.fillStyle = "rgba(234,240,255,.90)";
      ctx.fillText(`d = ${state.d.toFixed(2)} µm`, ax-28, (yTop+yBot)/2 - 6);

      // Axes: x and z
      const originX = coreX + 18;
      const originY = coreY + coreH + 40;
      ctx.strokeStyle = "rgba(255,255,255,.30)";
      ctx.lineWidth = 2;
      // z axis arrow
      ctx.beginPath();
      ctx.moveTo(originX, originY);
      ctx.lineTo(originX+80, originY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(originX+80, originY);
      ctx.lineTo(originX+72, originY-5);
      ctx.lineTo(originX+72, originY+5);
      ctx.closePath();
      ctx.fillStyle = "rgba(255,255,255,.30)";
      ctx.fill();
      ctx.fillStyle = "rgba(234,240,255,.9)";
      ctx.fillText("z (propagation)", originX+86, originY+5);

      // x axis arrow (up)
      ctx.beginPath();
      ctx.moveTo(originX, originY);
      ctx.lineTo(originX, originY-64);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(originX, originY-64);
      ctx.lineTo(originX-5, originY-56);
      ctx.lineTo(originX+5, originY-56);
      ctx.closePath();
      ctx.fillStyle = "rgba(255,255,255,.30)";
      ctx.fill();
      ctx.fillStyle = "rgba(234,240,255,.9)";
      ctx.fillText("x", originX-10, originY-70);

      // Ray bounce inside core (illustrative): use theta from normal
      const theta = rad(state.theta0); // from normal (x axis)
      // direction in x-z: x component cos(theta), z component sin(theta)
      // Use grazing if too close to horizontal
      const dirZ = Math.sin(theta);
      const dirX = Math.cos(theta);
      const rayStartX = coreX + 40;
      const rayStartY = coreY + coreH*0.25;
      const rayLen = coreW*0.78;

      // We'll zig-zag between top and bottom boundaries with reflections
      ctx.strokeStyle = "rgba(52,211,153,.80)";
      ctx.lineWidth = 2.2;

      let x = rayStartX, y = rayStartY;
      let vx = dirZ, vy = -dirX; // map z->canvas x, x->canvas y (up is negative)
      // scale so it fits:
      const speed = Math.max(1e-6, Math.sqrt(vx*vx + vy*vy));
      vx /= speed; vy /= speed;
      const scale = rayLen;
      vx *= scale; vy *= scale;

      // bounce across core boundaries
      const top = coreY + 2;
      const bot = coreY + coreH - 2;
      const rightBound = coreX + coreW - 20;

      ctx.beginPath();
      ctx.moveTo(x,y);
      let steps = 12;
      for(let i=0;i<steps;i++){
        // propose next
        let nx = x + vx/steps;
        let ny = y + vy/steps;

        // reflect at boundaries
        if(ny < top){
          ny = top + (top - ny);
          vy *= -1;
        }
        if(ny > bot){
          ny = bot - (ny - bot);
          vy *= -1;
        }
        if(nx > rightBound) break;

        ctx.lineTo(nx, ny);
        x = nx; y = ny;
      }
      ctx.stroke();

      // Angle annotation at first bounce segment
      const angX = rayStartX + 16;
      const angY = rayStartY + 6;

      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(`θ (from normal) ≈ ${state.theta0.toFixed(1)}°`, coreX+10, coreY+coreH+24);
      ctx.fillStyle = "rgba(185,198,234,.92)";
      ctx.fillText(`grazing ≈ ${(90-state.theta0).toFixed(1)}°`, coreX+10, coreY+coreH+40);

      ctx.restore();
    }

    // ---------- Drawing: Plots ----------
    function drawMainPlot(state){
      const {ctx, resize} = mainC;
      const {w,h} = resize();
      ctx.clearRect(0,0,w,h);

      const padL = 62, padR = 16, padT = 40, padB = 58;
      const plot = {x: padL, y: padT, w: w-padL-padR, h: h-padT-padB};

      // Plot ranges
      const dMin = 0.2, dMax = 6.0;
      const yMin = n2, yMax = n1;

      plot.xmin = dMin; plot.xmax = dMax;
      plot.ymin = yMin; plot.ymax = yMax;

      drawGrid(ctx, plot.x, plot.y, plot.w, plot.h, 8, 6);
      drawAxes(ctx, plot);

      // ticks
      const xTicks = [0.2,1,2,3,4,5,6].map(val=>({p:(val-dMin)/(dMax-dMin), label:String(val)}));
      const yTicks = [1.4,1.45,1.5,1.55,1.6].map(val=>({p:(val-yMin)/(yMax-yMin), label:val.toFixed(2)}));
      drawTicks(ctx, plot, xTicks, yTicks, "d (µm)", "n_eff (—)", `n_eff vs d (TE modes), λ0=${state.lam.toFixed(2)} µm`);

      // Determine a maximum number of modes to attempt in sweep (cap for speed)
      const maxModes = 10;

      // Colors: don't set explicit colors (instruction) — so rely on alpha variations with white strokes.
      // We'll differentiate by line style (dash patterns).
      const dashStyles = [
        [], [6,4], [2,3], [10,4,2,4], [1,2],
        [12,5], [7,3,2,3], [3,2], [14,4], [4,6]
      ];

      const N = 140;
      // For each mode p, compute neff across d
      for(let p=0;p<maxModes;p++){
        const pts = [];
        for(let i=0;i<N;i++){
          const d = dMin + (dMax-dMin)*i/(N-1);
          const V = V_of(state.lam, d);
          // mode exists if p < count_TE_modes(V)
          if(p >= count_TE_modes(V)){
            pts.push({x:d, y:NaN, ok:false});
            continue;
          }
          const u = solve_u_for_mode(p, V);
          const {neff} = beta_neff_from_u(u, state.lam, d);
          const ok = isFinite(neff) && neff>n2 && neff<n1;
          pts.push({x:d, y:neff, ok});
        }
        // draw only if at least one ok point
        if(!pts.some(p=>p.ok)) continue;

        ctx.save();
        ctx.strokeStyle = "rgba(234,240,255,.82)";
        ctx.lineWidth = 1.8;
        ctx.setLineDash(dashStyles[p % dashStyles.length]);
        drawLine(ctx, pts, plot);
        ctx.restore();

        // Legend tag (right side)
        const legX = plot.x + plot.w - 88;
        const legY = plot.y + 14 + 14*(p%6) + (p>=6 ? 84:0);
        ctx.save();
        ctx.strokeStyle = "rgba(234,240,255,.82)";
        ctx.lineWidth = 2;
        ctx.setLineDash(dashStyles[p % dashStyles.length]);
        ctx.beginPath();
        ctx.moveTo(legX, legY);
        ctx.lineTo(legX+24, legY);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = "rgba(185,198,234,.95)";
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
        ctx.fillText(`TE${p}`, legX+30, legY+4);
        ctx.restore();
      }

      // Mark current operating point at state.d
      const Vcur = state.V;
      const Ncur = state.N_TE;
      // TE0 point
      const xP = mapX(state.d, dMin, dMax, plot);
      const yP = mapY(state.neff0, yMin, yMax, plot);
      ctx.save();
      ctx.fillStyle = "rgba(52,211,153,.92)";
      ctx.strokeStyle = "rgba(0,0,0,.35)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(xP, yP, 4.5, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(`TE0 @ d=${state.d.toFixed(2)}µm`, clamp(xP+10, plot.x+4, plot.x+plot.w-130), clamp(yP-10, plot.y+14, plot.y+plot.h-10));
      ctx.restore();
    }

    function drawSecondaryPlot(state){
      const {ctx, resize} = secC;
      const {w,h} = resize();
      ctx.clearRect(0,0,w,h);

      const padL = 70, padR = 16, padT = 40, padB = 58;
      const plot = {x: padL, y: padT, w: w-padL-padR, h: h-padT-padB};

      const dMin = 0.2, dMax = 6.0;
      plot.xmin = dMin; plot.xmax = dMax;

      // Compute vg range by sampling quickly
      const N = 140;
      const pts = [];
      let vgMin = Infinity, vgMax = -Infinity;

      for(let i=0;i<N;i++){
        const d = dMin + (dMax-dMin)*i/(N-1);
        const V = V_of(state.lam, d);
        if(count_TE_modes(V) < 1){
          pts.push({x:d, y:NaN, ok:false});
          continue;
        }
        const vg = vg_TE0(state.lam, d);
        const ok = isFinite(vg) && vg>0;
        pts.push({x:d, y:vg, ok});
        if(ok){
          vgMin = Math.min(vgMin, vg);
          vgMax = Math.max(vgMax, vg);
        }
      }

      if(!isFinite(vgMin) || !isFinite(vgMax)){
        vgMin = 1e8; vgMax = 2.5e8;
      } else {
        // pad range
        const pad = 0.08*(vgMax-vgMin);
        vgMin -= pad; vgMax += pad;
      }

      plot.ymin = vgMin; plot.ymax = vgMax;

      drawGrid(ctx, plot.x, plot.y, plot.w, plot.h, 8, 6);
      drawAxes(ctx, plot);

      // ticks
      const xTicks = [0.2,1,2,3,4,5,6].map(val=>({p:(val-dMin)/(dMax-dMin), label:String(val)}));
      const yTicks = [];
      const ySteps = 5;
      for(let j=0;j<=ySteps;j++){
        const yy = vgMin + (vgMax-vgMin)*j/ySteps;
        yTicks.push({p:(yy-vgMin)/(vgMax-vgMin), label:(yy/1e8).toFixed(2)});
      }
      drawTicks(ctx, plot, xTicks, yTicks, "d (µm)", "v_g (×10^8 m/s)", `Group velocity vs d (TE0), λ0=${state.lam.toFixed(2)} µm`);

      // line
      ctx.save();
      ctx.strokeStyle = "rgba(234,240,255,.86)";
      ctx.lineWidth = 2.2;
      ctx.setLineDash([]);
      drawLine(ctx, pts.map(p=>({x:p.x, y:p.y, ok:p.ok})), plot);
      ctx.restore();

      // marker at current d
      const xP = mapX(state.d, dMin, dMax, plot);
      const yP = mapY(state.vg0, vgMin, vgMax, plot);
      ctx.save();
      ctx.fillStyle = "rgba(125,211,252,.92)";
      ctx.strokeStyle = "rgba(0,0,0,.35)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(xP, yP, 5, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      const tag = `@ d=${state.d.toFixed(2)}µm: ${(state.vg0/1e8).toFixed(3)}×10^8 m/s`;
      ctx.fillText(tag, clamp(xP+10, plot.x+4, plot.x+plot.w-220), clamp(yP-10, plot.y+14, plot.y+plot.h-10));
      ctx.restore();
    }

    // ---------- Compute state ----------
    function computeState(){
      const d = parseFloat(dSlider.value);
      const lam = parseFloat(lamSelect.value);

      const ang = criticalAngles();
      const NA = NA_air();
      const theta_max_air = acceptanceAngleAir();

      const V = V_of(lam, d);
      const N_TE = count_TE_modes(V);

      const te0 = te0_solution(lam, d);
      const neff0 = te0.neff;
      const th0 = bounceAngleFromNeff(neff0);

      const vg0 = vg_TE0(lam, d);

      return {
        d, lam,
        theta_c: ang.theta_c,
        theta_c_comp: ang.theta_c_comp,
        NA,
        theta_max_air,
        V,
        N_TE,
        u0: te0.u,
        beta0: te0.beta,
        neff0,
        theta0: th0.theta,
        grazing0: th0.grazing,
        vg0
      };
    }

    // ---------- Main update ----------
    function updateAll(){
      const state = computeState();
      dVal.textContent = state.d.toFixed(2);
      lamVal.textContent = state.lam.toFixed(2);

      buildLiveTable(state);
      drawDiagram(state);
      drawMainPlot(state);
      drawSecondaryPlot(state);
    }

    dSlider.addEventListener("input", updateAll);
    lamSelect.addEventListener("change", updateAll);

    // Resize handling
    let resizeTimer = null;
    window.addEventListener("resize", ()=>{
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(updateAll, 80);
    });

    // Smooth scroll for ToC links
    document.querySelectorAll('.toc a[href^="#"]').forEach(a=>{
      a.addEventListener("click",(e)=>{
        const id = a.getAttribute("href");
        const el = document.querySelector(id);
        if(!el) return;
        e.preventDefault();
        el.scrollIntoView({behavior:"smooth", block:"start"});
      });
    });

    // Initial render
    updateAll();
  </script>
</body>
</html>
