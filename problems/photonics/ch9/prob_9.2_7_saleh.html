<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>9.2-7 Single-Mode Planar Waveguide (TE) — Thickness Limit & Mode Count</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101a33;
      --panel2:#0f1730;
      --text:#e9eefc;
      --muted:#b7c2e6;
      --faint:#7f8ab5;
      --accent:#7aa2ff;
      --accent2:#7dffcb;
      --warn:#ffd36a;
      --bad:#ff7a7a;
      --good:#7dff9a;
      --line:rgba(255,255,255,.12);
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius:18px;
      --radius2:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(900px 500px at 20% -10%, rgba(122,162,255,.25), transparent 60%),
        radial-gradient(900px 500px at 90% 0%, rgba(125,255,203,.14), transparent 55%),
        radial-gradient(900px 500px at 60% 110%, rgba(255,211,106,.10), transparent 60%),
        var(--bg);
      color:var(--text);
      line-height:1.55;
    }

    header{
      padding:26px 18px 14px;
      position:relative;
    }
    .wrap{max-width:1160px;margin:0 auto}
    .hero{
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap:16px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns:1fr}
    }

    .titleCard{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:18px 18px 16px;
      overflow:hidden;
      position:relative;
    }
    .titleCard:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(800px 280px at 15% 0%, rgba(122,162,255,.16), transparent 60%),
                  radial-gradient(700px 260px at 90% 10%, rgba(125,255,203,.10), transparent 60%);
      pointer-events:none;
      filter: blur(0px);
    }
    .titleCard > *{position:relative}
    h1{
      margin:0 0 8px;
      font-size: clamp(1.35rem, 2.4vw, 2.05rem);
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      margin:0;
      font-size: 1.02rem;
      max-width: 70ch;
    }
    .metaRow{
      display:flex; flex-wrap:wrap; gap:10px;
      margin-top:12px;
    }
    .chip{
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      color:var(--muted);
      padding:6px 10px;
      border-radius:999px;
      font-size:.92rem;
    }

    /* Sticky mini TOC */
    .toc{
      position:sticky;
      top:12px;
      align-self:start;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:14px 12px;
    }
    .toc h2{
      font-size: .98rem;
      margin:0 0 8px;
      color:var(--text);
      letter-spacing:.2px;
    }
    .toc a{
      display:block;
      text-decoration:none;
      color:var(--muted);
      padding:7px 8px;
      border-radius:10px;
      font-size:.95rem;
      border:1px solid transparent;
    }
    .toc a:hover{
      background:rgba(122,162,255,.10);
      border-color:rgba(122,162,255,.25);
      color:var(--text);
    }

    main{padding: 10px 18px 50px}
    section{margin-top:16px}

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:16px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }

    article.card{
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:16px;
      overflow:hidden;
    }
    .card h3{
      margin:0 0 10px;
      font-size:1.12rem;
      letter-spacing:.2px;
    }
    .muted{color:var(--muted)}
    .faint{color:var(--faint)}

    .callouts{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:16px;
    }
    @media (max-width: 980px){
      .callouts{grid-template-columns:1fr}
    }

    .callout{
      border-radius:var(--radius2);
      border:1px solid var(--line);
      background:rgba(255,255,255,.035);
      padding:12px 12px 10px;
      position:relative;
      overflow:hidden;
    }
    .callout:before{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(600px 200px at 12% 0%, rgba(122,162,255,.12), transparent 60%);
      pointer-events:none;
      opacity:.9;
    }
    .callout > *{position:relative}
    .callout .label{
      display:flex; align-items:center; gap:8px;
      font-weight:700; letter-spacing:.2px;
      margin-bottom:6px;
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background:var(--accent);
      box-shadow:0 0 0 4px rgba(122,162,255,.18);
      flex:0 0 auto;
    }
    .dot.warn{background:var(--warn); box-shadow:0 0 0 4px rgba(255,211,106,.18)}
    .dot.good{background:var(--accent2); box-shadow:0 0 0 4px rgba(125,255,203,.16)}
    .dot.bad{background:var(--bad); box-shadow:0 0 0 4px rgba(255,122,122,.18)}

    .eq{
      font-family:var(--mono);
      background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      padding:10px 10px;
      margin:10px 0;
      overflow:auto;
      position:relative;
    }
    .eq .copyBtn{
      position:absolute; right:8px; top:8px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.06);
      color:var(--text);
      border-radius:10px;
      padding:6px 9px;
      font-size:.86rem;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease;
    }
    .eq .copyBtn:hover{background:rgba(122,162,255,.12); transform:translateY(-1px)}
    .eq .copyBtn:active{transform:translateY(0px)}
    .eq code{display:block; white-space:pre}

    .twoCol{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .twoCol{grid-template-columns:1fr}
    }

    .vizGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
    }

    figure{
      margin:0;
      border-radius:var(--radius);
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.025));
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    figcaption{
      padding:10px 12px 12px;
      border-top:1px solid var(--line);
      color:var(--muted);
      font-size:.95rem;
    }
    .canvasWrap{
      padding:10px;
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius:14px;
      background:rgba(0,0,0,.20);
      border:1px solid rgba(255,255,255,.10);
    }
    .canvasTall canvas{height:360px}
    .canvasShort canvas{height:300px}

    .controls{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:12px;
      padding:12px;
      border-top:1px solid var(--line);
      background:rgba(0,0,0,.12);
    }
    @media (max-width: 980px){
      .controls{grid-template-columns:1fr}
    }
    .ctl{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
      border-radius:14px;
      padding:10px 10px 8px;
    }
    .ctl label{
      display:flex; justify-content:space-between; gap:10px;
      font-size:.92rem;
      color:var(--muted);
      margin-bottom:6px;
    }
    input[type="range"]{width:100%}
    select, button.small{
      width:100%;
      padding:9px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(0,0,0,.20);
      color:var(--text);
      font-size:.95rem;
      outline:none;
    }
    button.small{
      cursor:pointer;
      transition: transform .12s ease, background .12s ease;
      background:rgba(255,255,255,.06);
    }
    button.small:hover{background:rgba(122,162,255,.12); transform:translateY(-1px)}
    button.small:active{transform:translateY(0px)}

    .badgeRow{
      display:flex; flex-wrap:wrap; gap:8px;
      margin-top:10px;
    }
    .badge{
      border-radius:999px;
      padding:6px 10px;
      font-size:.9rem;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.04);
      color:var(--muted);
    }
    .badge strong{color:var(--text)}
    .badge.good{border-color: rgba(125,255,154,.35); background:rgba(125,255,154,.08)}
    .badge.warn{border-color: rgba(255,211,106,.35); background:rgba(255,211,106,.08)}
    .badge.bad{border-color: rgba(255,122,122,.35); background:rgba(255,122,122,.08)}

    .kbox{
      border-left: 4px solid rgba(122,162,255,.85);
      padding:10px 12px;
      background:rgba(122,162,255,.08);
      border-radius:12px;
      margin:12px 0;
    }
    .kbox.warn{border-left-color: rgba(255,211,106,.95); background:rgba(255,211,106,.08)}
    .kbox.good{border-left-color: rgba(125,255,203,.95); background:rgba(125,255,203,.08)}
    .kbox.bad{border-left-color: rgba(255,122,122,.95); background:rgba(255,122,122,.08)}

    ul{margin:8px 0 0 18px}
    li{margin:5px 0}

    footer{
      padding:18px;
      color:var(--faint);
      text-align:center;
    }

    /* subtle entrance */
    @media (prefers-reduced-motion: no-preference){
      .card, figure, .toc, .titleCard{
        animation: floatIn .55s ease both;
      }
      @keyframes floatIn{
        from{opacity:0; transform:translateY(10px)}
        to{opacity:1; transform:translateY(0)}
      }
    }

    /* print-friendly */
    @media print{
      body{background:#fff;color:#000}
      .toc{display:none}
      .titleCard, .card, figure{box-shadow:none}
      canvas{border:1px solid #ccc; background:#fff}
      .eq{background:#f6f6f6}
      .chip,.badge{color:#000}
      a{color:#000}
    }
  </style>
</head>
<body>
<header>
  <div class="wrap hero">
    <div class="titleCard">
      <h1>Single-Mode Planar Dielectric Waveguide (TE): Largest Thickness & Mode Count at a New Wavelength</h1>
      <p class="subtitle">
        We use the slab waveguide <span class="muted">normalized frequency</span> (V-number) to determine when higher-order TE modes can exist.
        The core insight: <span class="muted">each new TE mode turns on at a cutoff V</span> set by the transverse standing-wave condition.
      </p>
      <div class="metaRow">
        <span class="chip">Core index: <strong>n₁ = 1.50</strong></span>
        <span class="chip">Cladding index: <strong>n₂ = 1.46</strong></span>
        <span class="chip">Case A: <strong>λ₀ = 1.3 μm</strong> (single-mode TE)</span>
        <span class="chip">Case B: <strong>λ₀ = 0.85 μm</strong> (count modes)</span>
      </div>
    </div>

    <nav class="toc" aria-label="Table of contents">
      <h2>Mini Table of Contents</h2>
      <a href="#quick">Quick Summary</a>
      <a href="#primer">PART 0 — Concept Primer</a>
      <a href="#analysis">PART 1 — Problem Analysis</a>
      <a href="#strategy">PART 2 — Strategy & Tips</a>
      <a href="#solution">PART 3 — Full Solution</a>
      <a href="#deeper">PART 4 — Deeper Understanding</a>
      <a href="#vizguide">PART 5 — Visualization Guide</a>
    </nav>
  </div>
</header>

<main>
  <div class="wrap">

    <section id="quick">
      <article class="card">
        <h3>Quick Summary</h3>
        <ul>
          <li><strong>What this is about:</strong> A symmetric slab (planar) dielectric waveguide and the condition for <strong>single-mode TE</strong> guidance.</li>
          <li><strong>Key physics idea:</strong> Guided modes exist when the field forms a transverse standing wave in the core while decaying evanescently in the cladding.</li>
          <li><strong>Governing quantity:</strong> The <strong>normalized frequency</strong> (V-number)
            <span class="muted">V = (2π/λ₀) a √(n₁² − n₂²)</span>, where <span class="muted">a = d/2</span>.</li>
          <li><strong>Cutoff rule (TE in symmetric slab):</strong> the next TE mode appears at <span class="muted">V = π/2</span>; more generally cutoffs occur at <span class="muted">V = m(π/2)</span>.</li>
          <li><strong>Largest thickness for only one TE mode at 1.3 μm:</strong> <strong>d<sub>max</sub> = λ₀ / (2 √(n₁² − n₂²))</strong> → numeric value below.</li>
          <li><strong>With that thickness at 0.85 μm:</strong> compute the new V, then count how many cutoff thresholds are passed → <strong>number of TE modes</strong>.</li>
          <li><strong>Final results:</strong> numeric <strong>d<sub>max</sub> ≈ 1.89 μm</strong> at 1.3 μm; at 0.85 μm the waveguide supports <strong>2 TE modes</strong> (TE₀ and TE₁).</li>
        </ul>
      </article>
    </section>

    <section id="primer" class="grid">
      <article class="card">
        <h3>PART 0 — Concept Primer (Theory Before Solving)</h3>

        <div class="callouts">
          <div class="callout">
            <div class="label"><span class="dot"></span>Core definitions (symbols & units)</div>
            <ul>
              <li><strong>Slab waveguide thickness:</strong> <span class="muted">d</span> (meters). Often use <span class="muted">a = d/2</span> as the half-thickness.</li>
              <li><strong>Refractive indices:</strong> core <span class="muted">n₁</span>, cladding <span class="muted">n₂</span> (dimensionless), with <span class="muted">n₁ &gt; n₂</span> for guiding.</li>
              <li><strong>Free-space wavelength:</strong> <span class="muted">λ₀</span> (meters). Vacuum wavenumber <span class="muted">k₀ = 2π/λ₀</span> (rad/m).</li>
              <li><strong>Propagation constant:</strong> <span class="muted">β</span> along the guide (rad/m). Guided modes satisfy <span class="muted">n₂k₀ &lt; β &lt; n₁k₀</span>.</li>
              <li><strong>Normalized frequency (V-number):</strong> <span class="muted">V = k₀ a √(n₁²−n₂²)</span> (dimensionless).</li>
            </ul>
          </div>

          <div class="callout">
            <div class="label"><span class="dot good"></span>Physical meaning of key quantities</div>
            <ul>
              <li><strong>β</strong> sets the <em>phase advance</em> per unit length along z. Larger β means the mode is more confined (more “core-like”).</li>
              <li><strong>V</strong> measures how many transverse oscillations can “fit” across the core: bigger <span class="muted">d</span>, bigger index contrast, or shorter <span class="muted">λ₀</span> → bigger V → more modes.</li>
              <li><strong>Mode order</strong> (TE₀, TE₁, …) counts transverse field structure: TE₀ has no internal node (single hump), TE₁ has one node, etc.</li>
            </ul>
          </div>
        </div>

        <div class="kbox">
          <strong>Key model:</strong> A <em>symmetric</em> slab guide has identical claddings on both sides, so modes are either <strong>even</strong> or <strong>odd</strong> about the center. This symmetry makes cutoff conditions clean.
        </div>

        <h4 style="margin:12px 0 6px">Key laws/principles & validity (assumptions)</h4>
        <ul>
          <li><strong>Maxwell’s equations → Helmholtz equation</strong> for time-harmonic fields, assuming linear, isotropic, lossless dielectrics.</li>
          <li><strong>Guiding mechanism:</strong> total internal reflection (TIR) in ray language; in wave language: oscillatory field in core + evanescent decay in cladding.</li>
          <li><strong>TE modes:</strong> “transverse electric” to propagation (E field perpendicular to the plane of incidence for the slab), producing a specific boundary condition that leads to TE dispersion relations.</li>
        </ul>

        <h4 style="margin:12px 0 6px">Common approximations (and why)</h4>
        <ul>
          <li>Use the <strong>V-number + cutoff</strong> logic to count modes without solving β precisely. This is ideal when you only need “how many modes?” or “single-mode thickness.”</li>
          <li>At <strong>cutoff</strong>, the cladding decay constant tends to zero, meaning the mode is just barely guided. This simplifies the transcendental dispersion relation into a simple condition like <span class="muted">u = mπ/2</span>.</li>
        </ul>

        <h4 style="margin:12px 0 6px">Mini intuition examples</h4>
        <ul>
          <li>If you <strong>halve the wavelength</strong>, V roughly doubles → you can support more modes at the same thickness.</li>
          <li>If <strong>n₁ ≈ n₂</strong> (tiny index contrast), √(n₁²−n₂²) is small → V is small → it becomes harder to support multiple modes.</li>
        </ul>

        <div class="kbox warn">
          <strong>What to watch for (pitfalls):</strong>
          <ul>
            <li>Using <span class="muted">d</span> vs <span class="muted">a=d/2</span> inconsistently inside V.</li>
            <li>Confusing <strong>“only one TE mode”</strong> with <strong>“only one total mode”</strong> (TE + TM). This problem explicitly talks about TE first; we will count TE modes.</li>
            <li>Mixing <span class="muted">λ₀</span> (free-space) with wavelength inside the medium. Standard V uses free-space <span class="muted">λ₀</span>.</li>
          </ul>
        </div>
      </article>

      <article class="card">
        <h3>Interactive Lab (You can explore as you read)</h3>
        <p class="muted">
          Use the controls to change <strong>thickness d</strong> and <strong>wavelength λ₀</strong>.
          All visuals update live: the slab diagram, the V-number plot with cutoff lines, and the mode field profiles.
        </p>

        <figure class="canvasShort" aria-label="Slab waveguide diagram">
          <div class="canvasWrap"><canvas id="cDiagram"></canvas></div>
          <figcaption>
            <strong>Diagram:</strong> symmetric slab waveguide (core index n₁, cladding index n₂), thickness d, propagation along z.
          </figcaption>
        </figure>

        <figure class="canvasTall" aria-label="Main quantitative plot">
          <div class="canvasWrap"><canvas id="cMain"></canvas></div>
          <div class="controls">
            <div class="ctl">
              <label for="dSlider">
                <span>Thickness <strong>d</strong> (μm)</span>
                <span id="dVal" class="faint"></span>
              </label>
              <input id="dSlider" type="range" min="0.2" max="6.0" step="0.01" value="1.89" />
              <div class="badgeRow" style="margin-top:8px">
                <span class="badge"><strong>V</strong> = <span id="vVal">—</span></span>
                <span class="badge"><strong>NA</strong> = √(n₁²−n₂²) = <span id="naVal">—</span></span>
              </div>
            </div>
            <div class="ctl">
              <label for="lambdaSel">
                <span>Wavelength <strong>λ₀</strong> (μm)</span>
                <span id="lambdaVal" class="faint"></span>
              </label>
              <select id="lambdaSel">
                <option value="1.30">1.30 (problem A)</option>
                <option value="0.85">0.85 (problem B)</option>
                <option value="1.55">1.55 (explore)</option>
                <option value="0.63">0.633 (explore)</option>
              </select>
              <div style="margin-top:10px; display:grid; gap:8px">
                <button id="btnSetDmax" class="small">Set d to TE single-mode limit at selected λ₀</button>
                <button id="btnReset" class="small">Reset to problem values</button>
              </div>
              <div class="badgeRow">
                <span id="modeBadge" class="badge">TE modes: —</span>
                <span id="singleBadge" class="badge">Single-mode TE? —</span>
              </div>
            </div>
          </div>
          <figcaption>
            <strong>Main plot:</strong> V-number versus thickness d with TE cutoff lines at V = m·(π/2). The dot shows the current operating point.
          </figcaption>
        </figure>

        <figure class="canvasTall" aria-label="Secondary plot: mode profiles">
          <div class="canvasWrap"><canvas id="cSecondary"></canvas></div>
          <figcaption>
            <strong>Secondary plot:</strong> approximate TE transverse field profiles E(x) for the guided modes that exist at the current V.
            (Profiles are normalized for shape; exact β is not required for mode counting.)
          </figcaption>
        </figure>
      </article>
    </section>

    <section id="analysis" class="grid">
      <article class="card">
        <h3>PART 1 — Problem Analysis (No solving yet)</h3>

        <h4 style="margin:8px 0 6px">Problem rewritten</h4>
        <p class="muted">
          A symmetric planar dielectric waveguide has core index <strong>n₁ = 1.50</strong>, cladding index <strong>n₂ = 1.46</strong>, and is operated at free-space wavelength <strong>λ₀ = 1.3 μm</strong>.
          Find the <strong>largest thickness d</strong> such that the guide supports <strong>only one TE mode</strong>.
          Then, keeping that thickness, find the <strong>number of guided modes</strong> (TE modes) when operating at <strong>λ₀ = 0.85 μm</strong>.
        </p>

        <div class="twoCol">
          <div>
            <h4 style="margin:8px 0 6px">Given</h4>
            <ul>
              <li>n₁ = 1.50</li>
              <li>n₂ = 1.46</li>
              <li>λ₀,A = 1.3 μm</li>
              <li>λ₀,B = 0.85 μm</li>
              <li>Symmetric slab geometry</li>
            </ul>
          </div>
          <div>
            <h4 style="margin:8px 0 6px">Unknowns / goals</h4>
            <ul>
              <li>Largest thickness <strong>d</strong> for which <strong>only TE₀</strong> exists at λ₀,A.</li>
              <li>With that same <strong>d</strong>, determine <strong>how many TE modes</strong> exist at λ₀,B.</li>
            </ul>
          </div>
        </div>

        <h4 style="margin:12px 0 6px">Relevant principles (and why)</h4>
        <ul>
          <li><strong>Slab waveguide mode theory</strong> applies because the structure is uniform along z and piecewise-uniform in x, so guided modes are separable solutions of the Helmholtz equation.</li>
          <li><strong>Cutoff concept</strong> applies because the “appearance” of higher-order modes happens when the cladding field transitions from evanescent to just barely non-evanescent (decay constant → 0).</li>
          <li>We do <em>not</em> need full β(λ) dispersion here—only the <strong>existence</strong> and <strong>count</strong> of modes—so V-number counting is the most efficient tool.</li>
        </ul>

        <div class="kbox">
          <strong>Assumptions:</strong>
          <ul>
            <li>Lossless, linear, isotropic dielectric materials.</li>
            <li>Perfect planar symmetry (same cladding on both sides).</li>
            <li>We count <strong>TE modes</strong> because the problem explicitly frames “only one TE mode.”</li>
          </ul>
        </div>

        <h4 style="margin:12px 0 6px">Possible approaches (compare & choose)</h4>
        <ul>
          <li><strong>Approach 1: V-number cutoff counting (best here).</strong> Fast, yields thickness limit and mode count without solving β.</li>
          <li><strong>Approach 2: Solve TE dispersion relation for β</strong> (transcendental), then infer mode existence. More work than needed for this question.</li>
          <li><strong>Approach 3: Ray/phase condition</strong> (TIR + phase shift). Good intuition but easier to slip on phase shifts; V-number is cleaner for exact cutoff.</li>
        </ul>
        <p class="muted"><strong>Choice:</strong> We use V-number cutoffs because the question is fundamentally about “how many modes?” and “largest thickness for single-mode,” which is exactly what V summarizes.</p>
      </article>

      <article class="card">
        <h3>Key Equations (with copy buttons)</h3>

        <div class="eq" id="eqV">
          <button class="copyBtn" data-copy="V = (2π/λ0) a √(n1^2 − n2^2) = (π d / λ0) √(n1^2 − n2^2)">Copy</button>
          <code>V = (2π/λ0) a √(n1^2 − n2^2) = (π d / λ0) √(n1^2 − n2^2)</code>
        </div>

        <div class="eq" id="eqCutoff">
          <button class="copyBtn" data-copy="TE mode cutoffs (symmetric slab): Vc(m) = m (π/2), m = 1,2,3,... ; TE0 exists for any V > 0">Copy</button>
          <code>TE mode cutoffs (symmetric slab):
Vc(m) = m (π/2),  m = 1,2,3,...
TE0 exists for any V &gt; 0</code>
        </div>

        <div class="eq" id="eqCount">
          <button class="copyBtn" data-copy="Number of TE modes: N_TE = 1 + floor( 2V / π )">Copy</button>
          <code>Number of TE modes:
N_TE = 1 + floor( 2V / π )</code>
        </div>

        <div class="kbox warn">
          <strong>Why the first cutoff is V = π/2:</strong> The next mode (TE₁) is odd-symmetry. At cutoff the cladding decay → 0, and the odd condition reduces to u = π/2 (a quarter-wave across half-thickness), giving V = u = π/2.
        </div>
      </article>
    </section>

    <section id="strategy">
      <article class="card">
        <h3>PART 2 — Strategy & Tips (Roadmap Only)</h3>
        <ol style="margin:8px 0 0 18px">
          <li><strong>Compute index contrast factor</strong> <span class="muted">NA = √(n₁²−n₂²)</span>.
            <div class="faint">Tool: algebra; Physical meaning: how strong the guide is.</div></li>
          <li><strong>Write V in terms of thickness</strong> using <span class="muted">a = d/2</span> → <span class="muted">V = (π d / λ₀) NA</span>.
            <div class="faint">Meaning: V grows linearly with d and inversely with λ₀.</div></li>
          <li><strong>Impose single-mode TE condition</strong>: require TE₁ not to exist → <span class="muted">V &lt; π/2</span>.
            <div class="faint">Meaning: not enough “room” transversely for a second standing-wave pattern.</div></li>
          <li><strong>Find the largest thickness</strong> by setting <span class="muted">V = π/2</span> and solving for d.
            <div class="faint">Meaning: right at the brink of TE₁ cutoff.</div></li>
          <li><strong>Reuse that thickness at the new wavelength</strong> λ₀ = 0.85 μm and compute the new V.
            <div class="faint">Meaning: shorter wavelength increases V → potentially more modes.</div></li>
          <li><strong>Count modes</strong> using <span class="muted">N_TE = 1 + floor(2V/π)</span>.
            <div class="faint">Meaning: each time V crosses another multiple of π/2, you gain one more TE mode.</div></li>
        </ol>

        <div class="kbox bad">
          <strong>Common mistakes (quick tips):</strong>
          <ul>
            <li><strong>Tip:</strong> Always convert thickness formula using <span class="muted">a=d/2</span> to avoid a factor-of-2 error.</li>
            <li><strong>Tip:</strong> The “single-mode TE” threshold is <span class="muted">π/2</span>, not <span class="muted">π</span>.</li>
            <li><strong>Tip:</strong> Keep λ in <strong>free space</strong> (as given) when using standard V.</li>
          </ul>
        </div>
      </article>
    </section>

    <section id="solution" class="grid">
      <article class="card">
        <h3>PART 3 — Full Solution (Detailed + Teaching)</h3>

        <h4 style="margin:8px 0 6px">Physical intuition first</h4>
        <p class="muted">
          A guided TE mode in a slab is like a standing wave across the thickness:
          the core supports oscillations, while the cladding supports only evanescent decay.
          If the core is too thin (or wavelength too long), only the simplest pattern (TE₀) fits.
          As thickness increases (or wavelength decreases), additional patterns (TE₁, TE₂, …) become possible.
        </p>

        <div class="callout" style="margin-top:10px">
          <div class="label"><span class="dot"></span>Step 1: Compute the “numerical aperture” factor (dimensionless)</div>
          <p class="muted" style="margin:6px 0 0">
            For a symmetric slab, the key contrast appears as:
          </p>
          <div class="eq">
            <button class="copyBtn" data-copy="NA = √(n1^2 − n2^2)">Copy</button>
            <code>NA = √(n1^2 − n2^2)</code>
          </div>
          <p class="muted" style="margin:6px 0 0">
            Insert numbers:
          </p>
          <div class="eq">
            <button class="copyBtn" data-copy="NA = √(1.50^2 − 1.46^2) = √(2.25 − 2.1316) = √(0.1184) ≈ 0.344">Copy</button>
            <code>NA = √(1.50² − 1.46²)
   = √(2.25 − 2.1316)
   = √(0.1184)
   ≈ 0.344</code>
          </div>
          <p class="faint">What we did: extracted the index-contrast scale. Why: it sets how strongly the waveguide confines fields.</p>
        </div>

        <div class="callout" style="margin-top:12px">
          <div class="label"><span class="dot"></span>Step 2: Write the normalized frequency V in terms of thickness d</div>
          <p class="muted" style="margin:6px 0 0">
            For slab half-thickness <span class="muted">a = d/2</span>:
          </p>
          <div class="eq">
            <button class="copyBtn" data-copy="V = (2π/λ0) a √(n1^2 − n2^2) = (π d / λ0) √(n1^2 − n2^2)">Copy</button>
            <code>V = (2π/λ0) a √(n1^2 − n2^2)
  = (π d / λ0) √(n1^2 − n2^2)</code>
          </div>
          <p class="faint">Meaning: V counts transverse oscillation capacity. Bigger d or smaller λ0 → bigger V → more modes.</p>
        </div>

        <div class="callout" style="margin-top:12px">
          <div class="label"><span class="dot warn"></span>Step 3: Apply the single-mode TE condition</div>
          <p class="muted" style="margin:6px 0 0">
            In a symmetric slab, TE<sub>0</sub> exists for any <span class="muted">V &gt; 0</span>.
            The <em>next</em> TE mode (TE<sub>1</sub>, odd) appears at cutoff:
          </p>
          <div class="eq">
            <button class="copyBtn" data-copy="TE1 cutoff: Vc = π/2  ⇒ single-mode TE requires V < π/2">Copy</button>
            <code>TE1 cutoff: Vc = π/2
⇒ single-mode TE requires V &lt; π/2</code>
          </div>
          <p class="muted" style="margin:6px 0 0">
            The <strong>largest</strong> thickness that still guarantees only one TE mode is right at the threshold:
            <span class="muted">V = π/2</span>.
          </p>
        </div>

        <div class="callout" style="margin-top:12px">
          <div class="label"><span class="dot good"></span>Step 4: Solve for d at λ₀ = 1.3 μm</div>
          <p class="muted" style="margin:6px 0 0">
            Start from <span class="muted">V = (π d / λ₀) NA</span> and set <span class="muted">V = π/2</span>:
          </p>
          <div class="eq">
            <button class="copyBtn" data-copy="(π d / λ0) NA = π/2  ⇒  d = λ0 / (2 NA) = λ0 / (2 √(n1^2 − n2^2))">Copy</button>
            <code>(π d / λ0) NA = π/2
⇒ d = λ0 / (2 NA)
⇒ d = λ0 / (2 √(n1^2 − n2^2))</code>
          </div>
          <p class="muted" style="margin:6px 0 0">
            Now plug in <span class="muted">λ₀ = 1.3 μm</span> and <span class="muted">NA ≈ 0.344</span>:
          </p>
          <div class="eq">
            <button class="copyBtn" data-copy="dmax = 1.3 μm / (2 × 0.344) ≈ 1.3 / 0.688 ≈ 1.89 μm">Copy</button>
            <code>dmax = 1.3 μm / (2 × 0.344)
     ≈ 1.3 / 0.688
     ≈ 1.89 μm</code>
          </div>
          <p class="faint">What we did: set the guide exactly at TE1 cutoff. Why: that gives the maximum d that still avoids TE1.</p>
        </div>

        <div class="callout" style="margin-top:12px">
          <div class="label"><span class="dot"></span>Step 5: Use the same thickness at λ₀ = 0.85 μm and count modes</div>
          <p class="muted" style="margin:6px 0 0">
            Compute V at the new wavelength:
          </p>
          <div class="eq">
            <button class="copyBtn" data-copy="V(λ) = (π d / λ) NA">Copy</button>
            <code>V(λ) = (π d / λ) NA</code>
          </div>
          <p class="muted" style="margin:6px 0 0">
            Using <span class="muted">d = λA/(2NA)</span> (from the single-mode limit at λA = 1.3 μm):
          </p>
          <div class="eq">
            <button class="copyBtn" data-copy="V(λB) = (π/2) (λA/λB) = (π/2)(1.3/0.85) ≈ 2.40">Copy</button>
            <code>V(λB) = (π d / λB) NA
      = (π/2)(λA/λB)
      = (π/2)(1.3/0.85)
      ≈ 2.40</code>
          </div>
          <p class="muted" style="margin:6px 0 0">
            Now compare to cutoffs: π/2 ≈ 1.57, π ≈ 3.14.
            Since <span class="muted">π/2 &lt; V ≈ 2.40 &lt; π</span>, the guide supports <strong>two</strong> TE modes: TE<sub>0</sub> and TE<sub>1</sub>.
          </p>
          <div class="eq">
            <button class="copyBtn" data-copy="N_TE = 1 + floor(2V/π) = 1 + floor(2×2.40/π) = 1 + floor(1.53) = 2">Copy</button>
            <code>N_TE = 1 + floor(2V/π)
     = 1 + floor(2×2.40/π)
     = 1 + floor(1.53)
     = 2</code>
          </div>
        </div>

        <div class="kbox good" id="finalBox">
          <strong>Final Answer (copy-ready):</strong>
          <div class="eq" style="margin-top:10px">
            <button class="copyBtn" data-copy="NA = √(n1^2 − n2^2) = √(1.50^2 − 1.46^2) ≈ 0.344
Largest thickness for only one TE mode at λ0 = 1.3 μm:
d_max = λ0 / (2√(n1^2 − n2^2)) ≈ 1.89 μm
Using this thickness at λ0 = 0.85 μm:
V ≈ (π/2)(1.3/0.85) ≈ 2.40 → number of TE modes = 2 (TE0 and TE1)">Copy</button>
            <code>NA = √(n1^2 − n2^2) = √(1.50^2 − 1.46^2) ≈ 0.344

Largest thickness for only one TE mode at λ0 = 1.3 μm:
d_max = λ0 / (2√(n1^2 − n2^2)) ≈ 1.89 μm

Using this thickness at λ0 = 0.85 μm:
V ≈ (π/2)(1.3/0.85) ≈ 2.40
⇒ number of TE modes = 2 (TE0 and TE1)</code>
          </div>
        </div>

        <h4 style="margin:12px 0 6px">Sanity checks</h4>
        <ul>
          <li><strong>Units:</strong> d = λ / (dimensionless) → d has units of length ✓</li>
          <li><strong>Limiting case:</strong> If n₁ → n₂, then √(n₁²−n₂²) → 0, so d<sub>max</sub> → ∞ (weak guidance needs a thicker core to allow more modes; conversely it becomes easier to remain single-mode) ✓</li>
          <li><strong>Wavelength effect:</strong> Decreasing λ increases V, so more modes appear—exactly what happens when going from 1.3 μm to 0.85 μm ✓</li>
        </ul>

        <p class="muted">
          Connection to visuals: the diagram shows the core thickness d; the main plot shows where your operating point sits relative to
          the cutoff lines at <span class="muted">V = π/2, π, 3π/2, …</span>. The secondary plot shows how additional modes add transverse nodes.
        </p>
      </article>

      <article class="card">
        <h3>Compact Derivation of the Cutoff Rule (why V = m·π/2)</h3>
        <p class="muted">
          (This is the theory link between “standing wave in the core” and a clean cutoff condition.)
        </p>

        <div class="callout">
          <div class="label"><span class="dot"></span>Set up the transverse wavenumbers</div>
          <p class="muted" style="margin:6px 0 0">
            For guided modes in a slab (propagation along z):
          </p>
          <div class="eq">
            <button class="copyBtn" data-copy="kx = √(n1^2 k0^2 − β^2),   α = √(β^2 − n2^2 k0^2),   with k0 = 2π/λ0">Copy</button>
            <code>kx = √(n1^2 k0^2 − β^2)
α  = √(β^2 − n2^2 k0^2)
k0 = 2π/λ0</code>
          </div>
          <p class="faint">kx sets oscillation in the core; α sets exponential decay in the cladding.</p>
        </div>

        <div class="callout" style="margin-top:12px">
          <div class="label"><span class="dot"></span>Normalize by half-thickness a and define u, w, V</div>
          <div class="eq">
            <button class="copyBtn" data-copy="u = kx a,   w = α a,   V = √(u^2 + w^2) = k0 a √(n1^2 − n2^2)">Copy</button>
            <code>u = kx a
w = α a
V = √(u² + w²) = k0 a √(n1² − n2²)</code>
          </div>
          <p class="faint">This bundles geometry, wavelength, and index contrast into a single “mode capacity” parameter V.</p>
        </div>

        <div class="callout" style="margin-top:12px">
          <div class="label"><span class="dot warn"></span>TE boundary conditions → dispersion relations</div>
          <p class="muted" style="margin:6px 0 0">
            For a symmetric slab, TE modes split into even/odd parity:
          </p>
          <div class="eq">
            <button class="copyBtn" data-copy="TE even:  u tan(u) = w
TE odd:  -u cot(u) = w">Copy</button>
            <code>TE even:  u tan(u) = w
TE odd:  -u cot(u) = w</code>
          </div>
          <p class="muted" style="margin:6px 0 0">
            At <strong>cutoff</strong>, the mode is barely guided, so the cladding decay vanishes: <span class="muted">α → 0 ⇒ w → 0</span>.
            Then:
          </p>
          <ul>
            <li>Even: <span class="muted">u tan(u) = 0</span> ⇒ tan(u)=0 ⇒ <span class="muted">u = mπ</span></li>
            <li>Odd: <span class="muted">-u cot(u) = 0</span> ⇒ cot(u)=0 ⇒ <span class="muted">u = (2m+1)π/2</span></li>
          </ul>
          <p class="muted">
            Since at cutoff <span class="muted">V = √(u²+w²) = u</span>, the combined sequence is
            <span class="muted">V = π/2, π, 3π/2, 2π, …</span>, i.e. <strong>V = m(π/2)</strong> for m = 1,2,3,...
          </p>
        </div>

        <div class="kbox">
          <strong>Takeaway:</strong> TE₀ has no cutoff (it exists for any V&gt;0), while TE₁ turns on at V=π/2. That single fact is enough to solve this problem.
        </div>
      </article>
    </section>

    <section id="deeper">
      <article class="card">
        <h3>PART 4 — Deeper Understanding (Theory Around the Result)</h3>

        <h4 style="margin:8px 0 6px">Re-interpreting the final formula</h4>
        <div class="eq">
          <button class="copyBtn" data-copy="d_max = λ0 / (2 √(n1^2 − n2^2))">Copy</button>
          <code>d_max = λ0 / (2 √(n1^2 − n2^2))</code>
        </div>
        <ul>
          <li><strong>λ₀ in the numerator:</strong> longer wavelength means larger “mode size,” so you can allow a thicker core and still remain single-mode.</li>
          <li><strong>√(n₁²−n₂²) in the denominator:</strong> stronger index contrast confines better and allows more transverse oscillations, so the core must be thinner to stay single-mode.</li>
          <li><strong>The factor 2:</strong> comes from using full thickness d rather than half-thickness a, and from the first cutoff being at V=π/2.</li>
        </ul>

        <h4 style="margin:12px 0 6px">How changing parameters affects the outcome (connect to plots)</h4>
        <ul>
          <li>If you slide <strong>d</strong> up, the dot on the V plot moves up linearly and crosses cutoff lines; each crossing adds a TE mode.</li>
          <li>If you switch to a <strong>smaller λ₀</strong>, the curve steepens (V ∝ 1/λ₀), so the same d produces a larger V and more modes.</li>
          <li>Increasing <strong>index contrast</strong> (not interactive here, but visible through NA) also increases V and mode count.</li>
        </ul>

        <h4 style="margin:12px 0 6px">Alternative derivation idea (brief)</h4>
        <p class="muted">
          A ray-optics picture uses total internal reflection with a round-trip phase condition across the core.
          At cutoff, the glancing angle approaches the critical angle and the transverse phase accumulation matches a half-integer number of π/2 increments,
          leading to the same V cutoff sequence. This is intuitive but requires careful handling of reflection phase shifts; the wave (dispersion) derivation is safer.
        </p>

        <h4 style="margin:12px 0 6px">Concept-check (self-test)</h4>
        <ul>
          <li><strong>Q:</strong> If λ₀ increases, do you get more or fewer modes at fixed d? <strong>A:</strong> Fewer, because V decreases (V ∝ 1/λ₀).</li>
          <li><strong>Q:</strong> What happens to d<sub>max</sub> if n₁ and n₂ get closer? <strong>A:</strong> d<sub>max</sub> increases (weaker confinement → harder to support extra modes).</li>
          <li><strong>Q:</strong> Why does TE₀ have no cutoff in a symmetric slab? <strong>A:</strong> The even fundamental solution can exist with arbitrarily small u as V → 0.</li>
          <li><strong>Q:</strong> At V between π and 3π/2, how many TE modes exist? <strong>A:</strong> 3 modes (TE₀, TE₁, TE₂).</li>
        </ul>
      </article>
    </section>

    <section id="vizguide">
      <article class="card">
        <h3>PART 5 — Visualization Guide (How to Read the Plots)</h3>

        <h4 style="margin:8px 0 6px">What each canvas shows</h4>
        <ul>
          <li><strong>Diagram canvas:</strong> a symmetric slab with core (n₁) and cladding (n₂), thickness d, and propagation along z. It grounds the geometry used in V.</li>
          <li><strong>Main plot (V vs d):</strong> the curve V(d) at the currently selected λ₀, plus horizontal cutoff lines at V = m·(π/2). The dot is your current operating point.</li>
          <li><strong>Secondary plot (field profiles E(x)):</strong> normalized transverse TE field shapes across x. As V increases, additional profiles appear with extra nodes (TE₁, TE₂, ...).</li>
        </ul>

        <h4 style="margin:12px 0 6px">Interactive controls</h4>
        <ul>
          <li><strong>Thickness slider d:</strong> changes V linearly. Expect the dot to move upward and new mode profiles to appear after each cutoff line is crossed.</li>
          <li><strong>Wavelength selector λ₀:</strong> changes the slope of V(d). Smaller λ₀ pushes you into multi-mode behavior for the same d.</li>
          <li><strong>“Set d to TE single-mode limit” button:</strong> sets d so that V = π/2 at the selected λ₀, i.e., the boundary between 1 and 2 TE modes.</li>
        </ul>

        <div class="kbox">
          <strong>Consistency note:</strong> The plots use the same symbols as the text:
          <span class="muted">V = (π d / λ₀) √(n₁²−n₂²)</span> with fixed n₁ = 1.50 and n₂ = 1.46, and d, λ₀ controlled above.
        </div>
      </article>
    </section>

  </div>
</main>

<footer>
  Built as a self-contained learning article (vanilla HTML/CSS/JS). Tip: use the copy buttons to paste equations and final answers into your notes.
</footer>

<script>
(function(){
  // ---------------------------
  // Problem constants
  // ---------------------------
  const n1 = 1.50;
  const n2 = 1.46;

  // Derived
  const NA = Math.sqrt(n1*n1 - n2*n2); // dimensionless

  // ---------------------------
  // Helpers
  // ---------------------------
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const fmt = (x, digits=3)=> {
    if (!isFinite(x)) return "—";
    const p = Math.pow(10,digits);
    return (Math.round(x*p)/p).toFixed(digits);
  };
  const fmt2 = (x, digits=2)=> {
    if (!isFinite(x)) return "—";
    const p = Math.pow(10,digits);
    return (Math.round(x*p)/p).toFixed(digits);
  };

  function copyText(txt){
    if(navigator.clipboard && navigator.clipboard.writeText){
      navigator.clipboard.writeText(txt).catch(()=>fallbackCopy(txt));
    } else {
      fallbackCopy(txt);
    }
  }
  function fallbackCopy(txt){
    const ta=document.createElement('textarea');
    ta.value=txt;
    ta.style.position='fixed';
    ta.style.left='-9999px';
    ta.style.top='-9999px';
    document.body.appendChild(ta);
    ta.select();
    try{ document.execCommand('copy'); }catch(e){}
    document.body.removeChild(ta);
  }

  // Attach copy handlers
  document.querySelectorAll('.copyBtn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const txt = btn.getAttribute('data-copy') || "";
      copyText(txt);
      const prev = btn.textContent;
      btn.textContent = "Copied!";
      setTimeout(()=>btn.textContent=prev, 900);
    });
  });

  // ---------------------------
  // Canvas utilities (HiDPI, axes)
  // ---------------------------
  function setupCanvas(canvas){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width * dpr));
    const h = Math.max(1, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
    }
    const ctx = canvas.getContext('2d');
    ctx.setTransform(1,0,0,1,0,0);
    return {ctx, w, h, dpr};
  }

  function clear(ctx,w,h){
    ctx.clearRect(0,0,w,h);
    // subtle backdrop
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, 'rgba(255,255,255,0.04)');
    g.addColorStop(1, 'rgba(255,255,255,0.015)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
  }

  function drawGrid(ctx, x0, y0, x1, y1, nx=10, ny=8){
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    for(let i=0;i<=nx;i++){
      const x = x0 + (x1-x0)*i/nx;
      ctx.beginPath();
      ctx.moveTo(x,y0);
      ctx.lineTo(x,y1);
      ctx.stroke();
    }
    for(let j=0;j<=ny;j++){
      const y = y0 + (y1-y0)*j/ny;
      ctx.beginPath();
      ctx.moveTo(x0,y);
      ctx.lineTo(x1,y);
      ctx.stroke();
    }
    ctx.restore();
  }

  function axes(ctx, plot, xLabel, yLabel, title){
    const {x0,y0,x1,y1} = plot;
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.lineWidth = 1.3;
    ctx.beginPath();
    ctx.rect(x0,y0,x1-x0,y1-y0);
    ctx.stroke();

    // title
    ctx.fillStyle = 'rgba(233,238,252,0.95)';
    ctx.font = '600 16px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(title, x0+8, y0-10);

    // labels
    ctx.fillStyle = 'rgba(183,194,230,0.95)';
    ctx.font = '12.5px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(xLabel, (x0+x1)/2 - ctx.measureText(xLabel).width/2, y1+28);

    ctx.save();
    ctx.translate(x0-34, (y0+y1)/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
    ctx.restore();

    ctx.restore();
  }

  function ticks(ctx, plot, xMin, xMax, yMin, yMax, nX=6, nY=6){
    const {x0,y0,x1,y1} = plot;
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.20)';
    ctx.fillStyle = 'rgba(183,194,230,0.92)';
    ctx.lineWidth = 1;

    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

    for(let i=0;i<=nX;i++){
      const t = i/nX;
      const x = x0 + (x1-x0)*t;
      const val = xMin + (xMax-xMin)*t;
      ctx.beginPath();
      ctx.moveTo(x,y1);
      ctx.lineTo(x,y1+6);
      ctx.stroke();
      const s = (Math.abs(val) < 10 ? val.toFixed(2) : val.toFixed(1));
      const w = ctx.measureText(s).width;
      ctx.fillText(s, x-w/2, y1+20);
    }

    for(let j=0;j<=nY;j++){
      const t = j/nY;
      const y = y1 - (y1-y0)*t;
      const val = yMin + (yMax-yMin)*t;
      ctx.beginPath();
      ctx.moveTo(x0-6,y);
      ctx.lineTo(x0,y);
      ctx.stroke();
      const s = (Math.abs(val) < 10 ? val.toFixed(2) : val.toFixed(1));
      ctx.fillText(s, x0-10-ctx.measureText(s).width, y+4);
    }

    ctx.restore();
  }

  function mapX(plot, x, xMin, xMax){
    return plot.x0 + (x - xMin) * (plot.x1 - plot.x0) / (xMax - xMin);
  }
  function mapY(plot, y, yMin, yMax){
    return plot.y1 - (y - yMin) * (plot.y1 - plot.y0) / (yMax - yMin);
  }

  // ---------------------------
  // Mode math (TE symmetric slab) for visualization
  // ---------------------------
  // TE even:  u tan u = w
  // TE odd : -u cot u = w = -u / tan u
  // with w = sqrt(V^2 - u^2) >= 0, u in (0, V)
  function solveRootBisection(f, a, b, maxIter=80){
    let fa = f(a), fb = f(b);
    if(!isFinite(fa) || !isFinite(fb)) return null;
    if(fa === 0) return a;
    if(fb === 0) return b;
    if(fa*fb > 0) return null;
    let lo=a, hi=b;
    for(let i=0;i<maxIter;i++){
      const mid = 0.5*(lo+hi);
      const fm = f(mid);
      if(!isFinite(fm)) return null;
      if(Math.abs(fm) < 1e-7) return mid;
      if(fa*fm <= 0){
        hi = mid; fb = fm;
      } else {
        lo = mid; fa = fm;
      }
    }
    return 0.5*(lo+hi);
  }

  function findTEuValues(V){
    // returns array of {m, parity, u, w} for modes that exist, in order.
    // Cutoff sequence at u = m π/2 when w->0
    // We'll scan intervals of u between singularities of tan/cot.
    const modes = [];
    if(V <= 1e-6) return modes;

    const maxM = Math.min(8, Math.floor(2*V/Math.PI) + 2); // modest for plotting
    // We'll search intervals between k*(π/2) points, but avoid singularities.
    const eps = 1e-4;

    // Fundamental TE0 is even (in symmetric slab)
    // Even solutions reside in intervals: [0, π/2), [π, 3π/2), [2π, 5π/2), ...
    // Odd solutions in: (π/2, π), (3π/2, 2π), ...
    // We'll just scan each half-π interval and test appropriate equation by parity.
    const nIntervals = Math.ceil((V) / (Math.PI/2));
    for(let k=0;k<nIntervals;k++){
      const uL = k*(Math.PI/2);
      const uR = Math.min(V, (k+1)*(Math.PI/2));

      if(uR - uL < 1e-3) continue;

      // Determine if this interval hosts even or odd equation based on k
      // k=0: (0,π/2) -> even
      // k=1: (π/2,π) -> odd
      // k=2: (π,3π/2)-> even
      // k=3: (3π/2,2π)-> odd, etc.
      const isEvenInterval = (k % 2 === 0);

      const parity = isEvenInterval ? "even" : "odd";
      const f = (u)=>{
        const w = Math.sqrt(Math.max(0, V*V - u*u));
        if(isEvenInterval){
          // u tan u - w
          return u*Math.tan(u) - w;
        } else {
          // -u cot u - w = -u*(1/tan u) - w
          return (-u/Math.tan(u)) - w;
        }
      };

      // Avoid endpoints where tan blows up or changes rapidly
      const a = uL + (k===0 ? eps : eps);
      const b = uR - eps;
      if(!(a < b)) continue;

      // Check sign change by sampling
      const fa = f(a), fb = f(b);
      if(!isFinite(fa) || !isFinite(fb)) continue;

      // Some intervals may have no root for current V
      if(fa*fb > 0) continue;

      const root = solveRootBisection(f, a, b);
      if(root === null) continue;

      const w = Math.sqrt(Math.max(0, V*V - root*root));
      // Determine mode index m by ordering
      modes.push({parity, u:root, w});
    }

    // Sort by u (increasing), then assign TE index m = 0,1,2,...
    modes.sort((A,B)=>A.u - B.u);
    for(let i=0;i<modes.length;i++){
      modes[i].m = i; // TE0, TE1, ...
    }
    return modes;
  }

  function countTEModes(V){
    // TE0 always exists for V>0, then each cutoff at V = m π/2 adds one.
    // N_TE = 1 + floor(2V/π)
    if(V <= 0) return 0;
    return 1 + Math.floor((2*V)/Math.PI);
  }

  // ---------------------------
  // UI elements
  // ---------------------------
  const cDiagram = document.getElementById('cDiagram');
  const cMain = document.getElementById('cMain');
  const cSecondary = document.getElementById('cSecondary');

  const dSlider = document.getElementById('dSlider');
  const dVal = document.getElementById('dVal');
  const lambdaSel = document.getElementById('lambdaSel');
  const lambdaVal = document.getElementById('lambdaVal');

  const vVal = document.getElementById('vVal');
  const naVal = document.getElementById('naVal');
  const modeBadge = document.getElementById('modeBadge');
  const singleBadge = document.getElementById('singleBadge');

  const btnSetDmax = document.getElementById('btnSetDmax');
  const btnReset = document.getElementById('btnReset');

  naVal.textContent = fmt(NA,3);

  function getState(){
    const d_um = parseFloat(dSlider.value);
    const lambda_um = parseFloat(lambdaSel.value);
    const d = d_um * 1e-6;
    const lambda0 = lambda_um * 1e-6;
    const V = (Math.PI * d / lambda0) * NA;
    const Nte = countTEModes(V);
    const single = (V < (Math.PI/2) + 1e-12); // allow numerical
    return {d_um, lambda_um, d, lambda0, V, Nte, single};
  }

  function setBadges(state){
    vVal.textContent = fmt(state.V,3);
    dVal.textContent = state.d_um.toFixed(2);
    lambdaVal.textContent = state.lambda_um.toFixed(2);
    modeBadge.textContent = `TE modes: ${state.Nte}`;
    modeBadge.className = "badge " + (state.Nte===1 ? "good" : (state.Nte===2 ? "warn" : "bad"));

    const s = state.single ? "Yes (only TE₀)" : "No (higher-order TE exists)";
    singleBadge.textContent = `Single-mode TE? ${s}`;
    singleBadge.className = "badge " + (state.single ? "good" : "bad");
  }

  // ---------------------------
  // Drawing: Diagram
  // ---------------------------
  function drawDiagram(state){
    const {ctx,w,h} = setupCanvas(cDiagram);
    clear(ctx,w,h);

    // layout
    const pad = 14 * (window.devicePixelRatio||1);
    const x0 = pad, x1 = w-pad;
    const y0 = pad+10, y1 = h-pad;

    // draw core slab centered
    const midY = (y0+y1)/2;
    const slabH = (y1-y0)*0.28;
    const slabY0 = midY - slabH/2;
    const slabY1 = midY + slabH/2;

    // cladding regions
    ctx.save();
    ctx.fillStyle = 'rgba(122,162,255,0.10)';
    ctx.fillRect(x0, y0, x1-x0, slabY0-y0);
    ctx.fillRect(x0, slabY1, x1-x0, y1-slabY1);

    // core
    ctx.fillStyle = 'rgba(125,255,203,0.14)';
    ctx.fillRect(x0, slabY0, x1-x0, slabH);

    // boundary lines
    ctx.strokeStyle = 'rgba(255,255,255,0.28)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x0, slabY0); ctx.lineTo(x1, slabY0);
    ctx.moveTo(x0, slabY1); ctx.lineTo(x1, slabY1);
    ctx.stroke();

    // arrows for z and x
    const axX = x0 + (x1-x0)*0.14;
    const axY = y1 - (y1-y0)*0.12;

    ctx.strokeStyle = 'rgba(255,255,255,0.55)';
    ctx.lineWidth = 2;
    // z arrow (right)
    ctx.beginPath();
    ctx.moveTo(axX, axY);
    ctx.lineTo(axX+120*(window.devicePixelRatio||1), axY);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(axX+120*(window.devicePixelRatio||1), axY);
    ctx.lineTo(axX+110*(window.devicePixelRatio||1), axY-6*(window.devicePixelRatio||1));
    ctx.lineTo(axX+110*(window.devicePixelRatio||1), axY+6*(window.devicePixelRatio||1));
    ctx.closePath();
    ctx.fillStyle = 'rgba(255,255,255,0.55)';
    ctx.fill();

    // x arrow (up)
    ctx.beginPath();
    ctx.moveTo(axX, axY);
    ctx.lineTo(axX, axY-90*(window.devicePixelRatio||1));
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(axX, axY-90*(window.devicePixelRatio||1));
    ctx.lineTo(axX-6*(window.devicePixelRatio||1), axY-80*(window.devicePixelRatio||1));
    ctx.lineTo(axX+6*(window.devicePixelRatio||1), axY-80*(window.devicePixelRatio||1));
    ctx.closePath();
    ctx.fill();

    // thickness bracket
    const bx = x1 - (x1-x0)*0.12;
    ctx.strokeStyle = 'rgba(255,211,106,0.85)';
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    ctx.moveTo(bx, slabY0);
    ctx.lineTo(bx, slabY1);
    ctx.stroke();
    // little end ticks
    ctx.beginPath();
    ctx.moveTo(bx-14*(window.devicePixelRatio||1), slabY0);
    ctx.lineTo(bx+14*(window.devicePixelRatio||1), slabY0);
    ctx.moveTo(bx-14*(window.devicePixelRatio||1), slabY1);
    ctx.lineTo(bx+14*(window.devicePixelRatio||1), slabY1);
    ctx.stroke();

    // labels
    ctx.fillStyle = 'rgba(233,238,252,0.95)';
    ctx.font = `${14*(window.devicePixelRatio||1)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
    ctx.fillText("core (n₁ = 1.50)", x0 + (x1-x0)*0.04, midY + 6*(window.devicePixelRatio||1));
    ctx.fillStyle = 'rgba(183,194,230,0.95)';
    ctx.fillText("cladding (n₂ = 1.46)", x0 + (x1-x0)*0.04, y0 + (y1-y0)*0.13);
    ctx.fillText("cladding (n₂ = 1.46)", x0 + (x1-x0)*0.04, y1 - (y1-y0)*0.10);

    ctx.fillStyle = 'rgba(255,211,106,0.95)';
    ctx.fillText(`d = ${state.d_um.toFixed(2)} μm`, bx - 120*(window.devicePixelRatio||1), midY - 6*(window.devicePixelRatio||1));

    ctx.fillStyle = 'rgba(233,238,252,0.85)';
    ctx.fillText("z", axX + 128*(window.devicePixelRatio||1), axY + 4*(window.devicePixelRatio||1));
    ctx.fillText("x", axX - 10*(window.devicePixelRatio||1), axY - 96*(window.devicePixelRatio||1));

    // hint of a mode profile inside core
    ctx.strokeStyle = 'rgba(125,255,203,0.95)';
    ctx.lineWidth = 2;
    const cx0 = x0 + (x1-x0)*0.52;
    const cx1 = x1 - (x1-x0)*0.20;
    const samples = 90;
    ctx.beginPath();
    for(let i=0;i<=samples;i++){
      const t = i/samples;
      const x = cx0 + (cx1-cx0)*t;
      const y = midY + (slabH*0.38)*Math.cos(2*Math.PI*t); // illustrative
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    ctx.restore();
  }

  // ---------------------------
  // Drawing: Main plot (V vs d with cutoffs)
  // ---------------------------
  function drawMain(state){
    const {ctx,w,h} = setupCanvas(cMain);
    clear(ctx,w,h);

    const margin = 54*(window.devicePixelRatio||1);
    const plot = {
      x0: margin,
      y0: 44*(window.devicePixelRatio||1),
      x1: w - 18*(window.devicePixelRatio||1),
      y1: h - 58*(window.devicePixelRatio||1)
    };

    // x: d(um) range aligned with slider
    const dMin = parseFloat(dSlider.min);
    const dMax = parseFloat(dSlider.max);
    // y: V range dynamic but stable
    const lambda_um = state.lambda_um;
    const Vmax = (Math.PI * (dMax*1e-6) / (lambda_um*1e-6)) * NA;
    const yMin = 0;
    const yMax = Math.max(3.5, Vmax*1.05);

    // grid
    drawGrid(ctx, plot.x0, plot.y0, plot.x1, plot.y1, 10, 8);

    // cutoffs lines V = m π/2
    ctx.save();
    ctx.lineWidth = 2;
    const cutoff = Math.PI/2;
    let m=1;
    while(m*cutoff <= yMax){
      const Vc = m*cutoff;
      const y = mapY(plot, Vc, yMin, yMax);
      ctx.strokeStyle = (m===1) ? 'rgba(255,211,106,0.85)' : 'rgba(255,255,255,0.20)';
      ctx.beginPath();
      ctx.moveTo(plot.x0, y);
      ctx.lineTo(plot.x1, y);
      ctx.stroke();

      // label
      ctx.fillStyle = (m===1) ? 'rgba(255,211,106,0.95)' : 'rgba(183,194,230,0.80)';
      ctx.font = `${12*(window.devicePixelRatio||1)}px ${getComputedStyle(document.body).fontFamily}`;
      const lbl = `V = ${m}·π/2`;
      ctx.fillText(lbl, plot.x0 + 8*(window.devicePixelRatio||1), y - 6*(window.devicePixelRatio||1));
      m++;
      if(m>10) break;
    }
    ctx.restore();

    // V(d) curve
    ctx.save();
    ctx.strokeStyle = 'rgba(122,162,255,0.95)';
    ctx.lineWidth = 2.6;
    const N = 180;
    ctx.beginPath();
    for(let i=0;i<=N;i++){
      const t=i/N;
      const d_um = dMin + (dMax-dMin)*t;
      const V = (Math.PI * (d_um*1e-6) / (lambda_um*1e-6)) * NA;
      const x = mapX(plot, d_um, dMin, dMax);
      const y = mapY(plot, V, yMin, yMax);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // current point
    const xP = mapX(plot, state.d_um, dMin, dMax);
    const yP = mapY(plot, state.V, yMin, yMax);
    ctx.fillStyle = 'rgba(125,255,203,0.95)';
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(xP, yP, 6*(window.devicePixelRatio||1), 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    // legend
    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.font = `${12.5*(window.devicePixelRatio||1)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
    const lx = plot.x1 - 220*(window.devicePixelRatio||1);
    const ly = plot.y0 + 12*(window.devicePixelRatio||1);
    ctx.fillText("Legend:", lx, ly);
    // curve sample
    ctx.strokeStyle='rgba(122,162,255,0.95)';
    ctx.lineWidth=2.6;
    ctx.beginPath(); ctx.moveTo(lx, ly+10*(window.devicePixelRatio||1)); ctx.lineTo(lx+34*(window.devicePixelRatio||1), ly+10*(window.devicePixelRatio||1)); ctx.stroke();
    ctx.fillStyle='rgba(183,194,230,0.95)';
    ctx.fillText("V(d) at selected λ₀", lx+42*(window.devicePixelRatio||1), ly+14*(window.devicePixelRatio||1));
    // point sample
    ctx.fillStyle='rgba(125,255,203,0.95)';
    ctx.beginPath(); ctx.arc(lx+10*(window.devicePixelRatio||1), ly+30*(window.devicePixelRatio||1), 5*(window.devicePixelRatio||1), 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='rgba(183,194,230,0.95)';
    ctx.fillText("Current operating point", lx+42*(window.devicePixelRatio||1), ly+34*(window.devicePixelRatio||1));

    ctx.restore();

    // axes frame + ticks
    axes(ctx, plot, "Thickness d (μm)", "V (dimensionless)", `V-number vs thickness (λ₀ = ${lambda_um.toFixed(2)} μm)`);
    ticks(ctx, plot, dMin, dMax, yMin, yMax, 6, 6);
  }

  // ---------------------------
  // Drawing: Secondary plot (mode profiles E(x))
  // ---------------------------
  function drawSecondary(state){
    const {ctx,w,h} = setupCanvas(cSecondary);
    clear(ctx,w,h);

    const margin = 54*(window.devicePixelRatio||1);
    const plot = {
      x0: margin,
      y0: 44*(window.devicePixelRatio||1),
      x1: w - 18*(window.devicePixelRatio||1),
      y1: h - 58*(window.devicePixelRatio||1)
    };

    // x axis: x/a from -3 to 3 (dimensionless)
    const xMin = -3, xMax = 3;
    const yMin = -1.25, yMax = 1.25;

    drawGrid(ctx, plot.x0, plot.y0, plot.x1, plot.y1, 12, 8);

    // Draw core boundaries at x/a = ±1
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.28)';
    ctx.lineWidth = 2;
    const xL = mapX(plot, -1, xMin, xMax);
    const xR = mapX(plot,  1, xMin, xMax);
    ctx.beginPath();
    ctx.moveTo(xL, plot.y0); ctx.lineTo(xL, plot.y1);
    ctx.moveTo(xR, plot.y0); ctx.lineTo(xR, plot.y1);
    ctx.stroke();

    ctx.fillStyle = 'rgba(183,194,230,0.9)';
    ctx.font = `${12*(window.devicePixelRatio||1)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
    ctx.fillText("core region", (xL+xR)/2 - 28*(window.devicePixelRatio||1), plot.y0 + 16*(window.devicePixelRatio||1));
    ctx.restore();

    // Compute modes for shape plotting (solve u from dispersion)
    const modes = findTEuValues(state.V);

    // If the simple solver returns fewer than countTEModes (happens very near cutoff),
    // we still plot up to Nte using approximate u = mπ/2 + small offset.
    const targetN = state.Nte;
    while(modes.length < targetN && modes.length < 5){
      const m = modes.length;
      const uApprox = Math.min(state.V*0.98, (m===0 ? Math.min(1.0, state.V*0.6) : m*(Math.PI/2) + 0.08));
      const wApprox = Math.sqrt(Math.max(0, state.V*state.V - uApprox*uApprox));
      const parity = (m%2===0) ? "even" : "odd";
      modes.push({m, parity, u:uApprox, w:wApprox});
    }

    // Plot each mode profile
    // E(x) normalized by max absolute in window; shape:
    // for |x|<=a: even => cos(u x/a), odd => sin(u x/a)
    // for |x|>a: match value at boundary and decay exp(-w(|x|/a - 1))
    const colors = [
      'rgba(125,255,203,0.95)',
      'rgba(122,162,255,0.95)',
      'rgba(255,211,106,0.95)',
      'rgba(255,122,122,0.92)',
      'rgba(180,140,255,0.92)'
    ];

    const sampleN = 600;
    modes.slice(0,5).forEach((mode, idx)=>{
      const col = colors[idx % colors.length];
      const u = mode.u;
      const wdec = Math.max(1e-6, mode.w);

      // sample & normalize
      const ys = new Array(sampleN+1);
      let yAbsMax = 1e-9;

      for(let i=0;i<=sampleN;i++){
        const xa = xMin + (xMax-xMin)*i/sampleN; // x/a
        let E;
        if(Math.abs(xa) <= 1){
          const arg = u*xa;
          E = (mode.parity === "even") ? Math.cos(arg) : Math.sin(arg);
        } else {
          const sign = xa>=0 ? 1 : -1;
          const xb = sign*1; // boundary x/a = ±1
          const Eb = (mode.parity === "even") ? Math.cos(u*xb) : Math.sin(u*xb);
          const dist = Math.abs(xa) - 1;
          E = Eb * Math.exp(-wdec*dist);
        }
        ys[i] = E;
        yAbsMax = Math.max(yAbsMax, Math.abs(E));
      }

      ctx.save();
      ctx.strokeStyle = col;
      ctx.lineWidth = 2.4;
      ctx.beginPath();
      for(let i=0;i<=sampleN;i++){
        const xa = xMin + (xMax-xMin)*i/sampleN;
        const E = ys[i]/yAbsMax; // normalized
        const x = mapX(plot, xa, xMin, xMax);
        const y = mapY(plot, E, yMin, yMax);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();
    });

    // Zero line
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1.5;
    const y0line = mapY(plot, 0, yMin, yMax);
    ctx.beginPath();
    ctx.moveTo(plot.x0, y0line);
    ctx.lineTo(plot.x1, y0line);
    ctx.stroke();
    ctx.restore();

    // Legend
    ctx.save();
    const lx = plot.x1 - 230*(window.devicePixelRatio||1);
    const ly = plot.y0 + 12*(window.devicePixelRatio||1);
    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.font = `${12.5*(window.devicePixelRatio||1)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
    ctx.fillText("Legend (normalized E):", lx, ly);
    const show = Math.min(5, modes.length);
    for(let i=0;i<show;i++){
      ctx.strokeStyle = colors[i % colors.length];
      ctx.lineWidth = 2.6;
      ctx.beginPath();
      ctx.moveTo(lx, ly + (16+i*16)*(window.devicePixelRatio||1));
      ctx.lineTo(lx + 34*(window.devicePixelRatio||1), ly + (16+i*16)*(window.devicePixelRatio||1));
      ctx.stroke();
      ctx.fillStyle = 'rgba(183,194,230,0.95)';
      const name = `TE${i}`;
      ctx.fillText(name, lx + 42*(window.devicePixelRatio||1), ly + (20+i*16)*(window.devicePixelRatio||1));
    }
    ctx.restore();

    axes(ctx, plot, "Transverse coordinate x/a (dimensionless)", "Normalized field E (arb.)", `TE mode profiles (V = ${state.V.toFixed(3)})`);
    ticks(ctx, plot, xMin, xMax, yMin, yMax, 6, 6);
  }

  // ---------------------------
  // Update loop
  // ---------------------------
  function render(){
    const state = getState();
    setBadges(state);
    drawDiagram(state);
    drawMain(state);
    drawSecondary(state);
  }

  // Buttons
  btnSetDmax.addEventListener('click', ()=>{
    const lambda_um = parseFloat(lambdaSel.value);
    // single-mode threshold: V = π/2 = (π d / λ) NA => d = λ/(2NA)
    const d_um = (lambda_um) / (2*NA);
    dSlider.value = clamp(d_um, parseFloat(dSlider.min), parseFloat(dSlider.max)).toFixed(2);
    render();
  });

  btnReset.addEventListener('click', ()=>{
    lambdaSel.value = "1.30";
    // dmax at 1.3 μm
    const d_um = 1.30/(2*NA);
    dSlider.value = clamp(d_um, parseFloat(dSlider.min), parseFloat(dSlider.max)).toFixed(2);
    render();
  });

  // Controls
  dSlider.addEventListener('input', render);
  lambdaSel.addEventListener('change', render);

  // Resize handling
  let rAF = null;
  window.addEventListener('resize', ()=>{
    if(rAF) cancelAnimationFrame(rAF);
    rAF = requestAnimationFrame(()=>render());
  });

  // Initialize to problem values:
  (function init(){
    // set d to the computed dmax at λ=1.3 μm
    const d_um = 1.30/(2*NA);
    dSlider.value = clamp(d_um, parseFloat(dSlider.min), parseFloat(dSlider.max)).toFixed(2);
    lambdaSel.value = "1.30";
    render();
  })();

})();
</script>
</body>
</html>
