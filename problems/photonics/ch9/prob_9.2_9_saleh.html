<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TM Mode Bounce Angles in a Planar Dielectric Waveguide (Graphical Solution)</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#0f1624;
      --panel2:#101b2e;
      --text:#e7eefc;
      --muted:#b8c4dd;
      --line:rgba(255,255,255,.12);
      --accent:#7bdcff;
      --accent2:#a6ffcb;
      --warn:#ffd27b;
      --good:#9bff9b;
      --bad:#ff8fa3;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 10% 0%, rgba(123,220,255,.12), transparent 60%),
        radial-gradient(900px 600px at 90% 10%, rgba(166,255,203,.10), transparent 55%),
        linear-gradient(180deg, #070a10 0%, #0b0f17 65%, #070a10 100%);
      line-height:1.55;
    }
    header{
      padding: clamp(18px, 3vw, 34px) clamp(16px, 4vw, 56px);
      border-bottom:1px solid var(--line);
      position:relative;
      overflow:hidden;
    }
    header h1{
      margin:0 0 6px 0;
      font-size:clamp(1.3rem, 2.3vw, 2rem);
      letter-spacing:.2px;
    }
    header p{
      margin:0;
      color:var(--muted);
      max-width: 70ch;
    }

    main{
      display:grid;
      grid-template-columns: 1fr;
      gap:18px;
      padding: 18px clamp(16px, 4vw, 56px) 48px;
      max-width: 1200px;
      margin:0 auto;
    }

    /* Sticky mini TOC */
    .layout{
      display:grid;
      grid-template-columns: 1fr;
      gap:18px;
      align-items:start;
    }
    @media (min-width: 980px){
      .layout{
        grid-template-columns: 1fr 280px;
      }
    }
    nav.toc{
      background: linear-gradient(180deg, rgba(16,27,46,.92), rgba(15,22,36,.92));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:14px 14px 12px;
      position: sticky;
      top: 14px;
      backdrop-filter: blur(8px);
    }
    nav.toc h2{
      font-size:.95rem;
      margin:0 0 10px 0;
      color:var(--text);
      letter-spacing:.2px;
    }
    nav.toc a{
      display:block;
      color:var(--muted);
      text-decoration:none;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, color .12s ease;
      font-size:.92rem;
      line-height:1.25;
    }
    nav.toc a:hover{
      background: rgba(123,220,255,.08);
      border-color: rgba(123,220,255,.18);
      color: var(--text);
      transform: translateX(2px);
    }

    section{
      background: linear-gradient(180deg, rgba(16,27,46,.72), rgba(15,22,36,.72));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: clamp(14px, 2.2vw, 22px);
      overflow:hidden;
    }
    section h2{
      margin:0 0 10px 0;
      font-size:1.12rem;
      letter-spacing:.2px;
    }
    section h3{
      margin:16px 0 8px 0;
      font-size:1rem;
      color: var(--text);
    }
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
    }
    @media (min-width: 860px){
      .grid2{grid-template-columns: 1.15fr .85fr;}
    }

    .callouts{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
      margin-top:10px;
    }
    @media (min-width: 860px){
      .callouts{grid-template-columns: 1fr 1fr;}
    }
    .card{
      background: linear-gradient(180deg, rgba(16,27,46,.88), rgba(12,18,30,.88));
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 12px 12px 10px;
    }
    .card strong{color:var(--text)}
    .tag{
      display:inline-block;
      font-size:.78rem;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      color: var(--muted);
      margin-right:6px;
    }
    .tag.good{border-color:rgba(155,255,155,.25); color:rgba(155,255,155,.9)}
    .tag.warn{border-color:rgba(255,210,123,.30); color:rgba(255,210,123,.95)}
    .tag.bad{border-color:rgba(255,143,163,.30); color:rgba(255,143,163,.95)}

    ul{margin:8px 0 0 18px}
    li{margin:6px 0}

    .eqbox{
      margin: 10px 0;
      padding: 12px 12px 10px;
      border-radius: 16px;
      border: 1px solid rgba(123,220,255,.22);
      background: radial-gradient(900px 220px at 20% 0%, rgba(123,220,255,.10), transparent 60%),
                  linear-gradient(180deg, rgba(16,27,46,.72), rgba(11,16,26,.72));
      position:relative;
      overflow:hidden;
    }
    .eq{
      font-family: var(--mono);
      font-size: .95rem;
      color: #eaf6ff;
      white-space: pre-wrap;
      word-break: break-word;
      margin:0;
    }
    .copyRow{
      display:flex;
      gap:10px;
      align-items:center;
      margin-top:10px;
      flex-wrap:wrap;
    }
    button.copy{
      appearance:none;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:8px 10px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:.88rem;
    }
    button.copy:hover{
      background: rgba(123,220,255,.10);
      border-color: rgba(123,220,255,.24);
      transform: translateY(-1px);
    }
    .toast{
      display:inline-block;
      font-size:.85rem;
      color: var(--accent2);
      opacity:0;
      transform: translateY(2px);
      transition: opacity .18s ease, transform .18s ease;
    }
    .toast.show{
      opacity:1;
      transform: translateY(0);
    }

    .vizPanel{
      background: linear-gradient(180deg, rgba(16,27,46,.90), rgba(10,14,22,.88));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      padding: 12px;
      overflow:hidden;
    }
    .vizHeader{
      display:flex;
      gap:12px;
      align-items:flex-end;
      justify-content:space-between;
      margin-bottom:10px;
      flex-wrap:wrap;
    }
    .vizHeader h3{
      margin:0;
      font-size:1rem;
    }
    .controls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }
    label.ctrl{
      display:flex;
      gap:8px;
      align-items:center;
      font-size:.85rem;
      color: var(--muted);
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 999px;
      padding: 6px 10px;
    }
    input[type="range"]{
      width: 140px;
      accent-color: var(--accent);
    }
    select{
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.14);
      color: var(--text);
      border-radius: 10px;
      padding: 6px 8px;
      font-size:.88rem;
      outline:none;
    }
    .readout{
      font-family: var(--mono);
      font-size: .86rem;
      color:#d9e7ff;
    }

    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius: 14px;
      background: rgba(7,10,16,.55);
      border: 1px solid rgba(255,255,255,.08);
    }
    @media (min-width: 860px){
      canvas.tall{height:360px;}
    }
    .twoCanv{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    @media (min-width: 900px){
      .twoCanv{grid-template-columns: 1fr 1fr;}
    }

    .final{
      border-color: rgba(166,255,203,.24);
      background: radial-gradient(900px 240px at 30% 0%, rgba(166,255,203,.12), transparent 60%),
                  linear-gradient(180deg, rgba(16,27,46,.72), rgba(11,16,26,.72));
    }

    .printNote{display:none}
    @media print{
      body{background:white; color:black}
      header, nav.toc, .controls, button.copy{display:none !important}
      main{max-width:none; padding:0}
      section{box-shadow:none; border:1px solid #ccc; background:white}
      .eqbox{background:#f6f8fb; border-color:#cfe6ef}
      canvas{border:1px solid #bbb; background:white}
      .printNote{display:block; color:#333; font-size:.9rem}
    }
  </style>
</head>
<body>
<header>
  <h1>9.2-9 — TM Mode Bounce Angles (Planar Dielectric Waveguide)</h1>
  <p>
    We derive the <strong>TM</strong> version of the self-consistency (mode) equation, then use a
    <strong>graphical intersection plot</strong> (like the textbook figure) to find the bounce angles and count how many guided TM modes exist for
    <span class="eq" style="display:inline; font-size:.92rem;">sin(θ_c)=0.3</span> and <span class="eq" style="display:inline; font-size:.92rem;">λ/(2d)=0.1</span>.
  </p>
</header>

<main class="layout">
  <article>

    <!-- Quick Summary -->
    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li><strong>Topic:</strong> Guided <strong>TM</strong> modes in a <strong>symmetric planar dielectric waveguide</strong> using the ray/phase picture.</li>
        <li><strong>Key idea:</strong> A guided mode exists when the <strong>round-trip phase</strong> in the core plus the <strong>two total-internal-reflection phase shifts</strong> add up to an integer multiple of <span class="eq" style="display:inline;">2π</span>.</li>
        <li><strong>TE vs TM difference:</strong> TM has a different reflection phase shift; in the final equation it appears as a <strong>multiplicative factor</strong> on the RHS.</li>
        <li><strong>Governing TM self-consistency equation (ray form):</strong> a transcendental equation in <span class="eq" style="display:inline;">sin(θ)</span> that we solve graphically (and numerically).</li>
        <li><strong>Given numbers:</strong> <span class="eq" style="display:inline;">sin(θ_c)=0.3</span>, <span class="eq" style="display:inline;">λ/(2d)=0.1</span> (so <span class="eq" style="display:inline;">πd/λ=π/(2·(λ/2d))=5π</span>).</li>
        <li><strong>Result type:</strong> symbolic TM equation + numerical bounce angles from intersections.</li>
        <li><strong>Mode count:</strong> <strong>4 TM modes</strong> including the highest one at cutoff (<span class="eq" style="display:inline;">sinθ=sinθ_c</span>).</li>
      </ul>
    </section>

    <!-- PART 0 -->
    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <div class="grid2">
        <div>
          <h3>Core definitions (symbols &amp; meaning)</h3>
          <ul>
            <li><strong>Planar waveguide:</strong> a high-index core (index <span class="eq" style="display:inline;">n_1</span>) of thickness <span class="eq" style="display:inline;">2d</span>, surrounded by lower-index cladding (index <span class="eq" style="display:inline;">n_2</span>), with <span class="eq" style="display:inline;">n_1&gt;n_2</span>.</li>
            <li><strong>Propagation axis:</strong> <span class="eq" style="display:inline;">z</span> along the guide; transverse direction <span class="eq" style="display:inline;">x</span> across the thickness.</li>
            <li><strong>Bounce angle:</strong> <span class="eq" style="display:inline;">θ</span> measured from the <strong>axis</strong> (ray makes a small “grazing” angle with the axis for strong guiding).</li>
            <li><strong>Critical (maximum) bounce angle for guiding:</strong> <span class="eq" style="display:inline;">θ_c</span> defined by total internal reflection. In this ray-angle-from-axis convention, guided rays satisfy
              <span class="eq" style="display:inline;">0&lt;sinθ≤sinθ_c</span>.
            </li>
            <li><strong>Wavelength:</strong> <span class="eq" style="display:inline;">λ</span> is the free-space wavelength (the textbook’s ray-form equations are often written with <span class="eq" style="display:inline;">λ</span> after absorbing refractive-index factors into the chosen angle parameterization).</li>
          </ul>

          <h3>Physical meaning of the key quantities</h3>
          <ul>
            <li><span class="eq" style="display:inline;">(πd/λ)sinθ</span> represents the <strong>accumulated phase</strong> associated with the transverse “zig-zag” between reflections.</li>
            <li>The <strong>reflection phase shift</strong> under total internal reflection depends on polarization:
              TE (s-polarized) and TM (p-polarized) reflect with <em>different</em> phase shifts even though the magnitude is 1.</li>
            <li>The <strong>mode index</strong> <span class="eq" style="display:inline;">m=0,1,2,...</span> labels successive branches of the transcendental equation; each branch corresponds to one guided mode.</li>
          </ul>
        </div>

        <div class="card">
          <span class="tag good">Guided modes</span>
          <span class="tag warn">Phase condition</span>
          <span class="tag">TE vs TM</span>
          <h3 style="margin-top:10px;">Key laws &amp; validity</h3>
          <ul>
            <li><strong>Maxwell + boundary conditions</strong> → exact slab eigenvalue problem.</li>
            <li><strong>Ray/phase (WKB) picture</strong> → interprets modes as rays bouncing with a polarization-dependent phase shift at each reflection.</li>
            <li>Valid when the guide is not extremely thin compared to <span class="eq" style="display:inline;">λ</span> and when fields are well confined (still works surprisingly well even near cutoff for teaching/intuition).</li>
          </ul>

          <h3>Common models/approximations</h3>
          <ul>
            <li><strong>Symmetric slab:</strong> same cladding on both sides → identical phase shift at both interfaces.</li>
            <li><strong>Lossless media:</strong> indices real, no absorption → reflection coefficient magnitude 1 under TIR.</li>
            <li><strong>Mode counting:</strong> each allowed branch intersection corresponds to a guided mode.</li>
          </ul>

          <h3>Mini intuition examples</h3>
          <ul>
            <li>If the guide becomes <strong>thicker</strong> (larger <span class="eq" style="display:inline;">d</span>), the phase per bounce increases → <strong>more modes</strong> fit.</li>
            <li>If the index contrast decreases (smaller <span class="eq" style="display:inline;">sinθ_c</span>), the allowed angular range shrinks → <strong>fewer modes</strong>.</li>
          </ul>

          <h3>What to watch for (pitfalls)</h3>
          <ul>
            <li>Mixing angle conventions (from normal vs from axis) changes the inequality for guiding.</li>
            <li>For TM, forgetting the polarization factor in the TIR phase shift is the #1 mistake.</li>
            <li>The highest-order mode may sit <em>at cutoff</em> (<span class="eq" style="display:inline;">sinθ=sinθ_c</span>); whether you “count” it depends on convention—here we include cutoff, matching the textbook style.</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- PART 1 -->
    <section id="part1">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>Problem restatement (in plain words)</h3>
      <p class="muted">
        For a symmetric planar dielectric waveguide, derive the transcendental self-consistency equation that gives the
        <strong>bounce angles</strong> <span class="eq" style="display:inline;">θ_m</span> of the <strong>TM</strong> modes (analogous to the given TE equation).
        Then, for <span class="eq" style="display:inline;">sin(θ_c)=0.3</span> and <span class="eq" style="display:inline;">λ/(2d)=0.1</span>, draw a graphical plot (LHS branches and RHS curve vs <span class="eq" style="display:inline;">sinθ</span>) and determine how many TM modes exist.
      </p>

      <div class="callouts">
        <div class="card">
          <strong>Given</strong>
          <ul>
            <li><span class="eq" style="display:inline;">sin(θ_c)=0.3</span></li>
            <li><span class="eq" style="display:inline;">λ/(2d)=0.1</span>  (so <span class="eq" style="display:inline;">2d=λ/0.1=10λ</span>, <span class="eq" style="display:inline;">d=5λ</span>)</li>
          </ul>
        </div>
        <div class="card">
          <strong>Unknowns / tasks</strong>
          <ul>
            <li>Derive TM bounce-angle equation (symbolic).</li>
            <li>Compute/visualize intersections to get <span class="eq" style="display:inline;">sinθ_m</span> (and <span class="eq" style="display:inline;">θ_m</span>).</li>
            <li>Count number of guided TM modes.</li>
          </ul>
        </div>
      </div>

      <h3>Relevant principles (and why they apply)</h3>
      <ul>
        <li><strong>Total internal reflection:</strong> guided rays reflect at the core–cladding boundary with a phase shift; this is central because guided modes rely on TIR confinement.</li>
        <li><strong>Phase self-consistency / resonance:</strong> after a round trip between interfaces, the field must reproduce itself → quantization condition.</li>
        <li><strong>Polarization dependence (TM):</strong> the Fresnel reflection phase differs for TM, changing the dispersion relation compared with TE.</li>
      </ul>

      <div class="eqbox">
        <div class="tag warn">Assumptions</div>
        <ul style="margin-top:8px">
          <li>Symmetric slab, lossless dielectrics, time-harmonic steady state.</li>
          <li>We use the ray/phase (graphical) form of the mode condition used in the referenced figure.</li>
          <li>Angles use the <strong>bounce-angle-from-axis</strong> convention consistent with the provided TE equation.</li>
        </ul>
      </div>

      <h3>Possible approaches (choose the best)</h3>
      <ul>
        <li><strong>Approach A — Full slab eigenvalue derivation (Maxwell + boundary conditions):</strong> most rigorous; longer algebra; yields standard TE/TM dispersion relations.</li>
        <li><strong>Approach B — Ray/phase (WKB) self-consistency:</strong> directly matches the given TE equation format; fast and intuitive; ideal for “plot like Fig. 9.2-2”.</li>
        <li><strong>Approach C — Numerical eigen-solver:</strong> robust; may obscure the “why” behind the phase condition and the graphical mode-counting interpretation.</li>
      </ul>
      <p><strong>Chosen:</strong> <strong>Approach B</strong>, because the problem explicitly asks for a TM expression “similar to (9.2-4)” and a plot “similar to Fig. 9.2-2”.</p>
    </section>

    <!-- PART 2 -->
    <section id="part2">
      <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>

      <ol>
        <li>
          <strong>Goal:</strong> relate the given TE equation to the TIR phase shift formula.<br/>
          <span class="muted">Tool:</span> Fresnel reflection phase under total internal reflection.<br/>
          <span class="muted">Physical meaning:</span> polarization-dependent “extra phase” at each bounce.
        </li>
        <li>
          <strong>Goal:</strong> write the TM reflection phase shift in the same angle convention.<br/>
          <span class="muted">Tool:</span> known TE/TM phase-shift relation <span class="eq" style="display:inline;">tan(δ_p/2)=(n_1^2/n_2^2)tan(δ_s/2)</span> under TIR.<br/>
          <span class="muted">Meaning:</span> TM experiences a stronger (different) phase shift for the same geometry.
        </li>
        <li>
          <strong>Goal:</strong> insert that phase shift into the self-consistency condition and simplify to a single transcendental equation in <span class="eq" style="display:inline;">sinθ</span>.<br/>
          <span class="muted">Tool:</span> algebra + the same LHS structure as the TE equation.
        </li>
        <li>
          <strong>Goal:</strong> for the given numbers, compute the LHS branches vs <span class="eq" style="display:inline;">sinθ</span> and the RHS curve, and find intersections.<br/>
          <span class="muted">Tool:</span> graphical method; optional root bracketing inside each mode interval.
        </li>
        <li>
          <strong>Goal:</strong> count modes.<br/>
          <span class="muted">Tool:</span> count intersections/branches up to <span class="eq" style="display:inline;">sinθ_c</span>; include cutoff mode if intersection at <span class="eq" style="display:inline;">sinθ=sinθ_c</span>.
        </li>
      </ol>

      <div class="callouts">
        <div class="card">
          <strong>Common mistakes</strong>
          <ul>
            <li>Using angle from the <em>normal</em> instead of from the <em>axis</em>.</li>
            <li>Plotting a single <span class="eq" style="display:inline;">tan</span> without restricting to the correct mode interval (each branch corresponds to one mode).</li>
            <li>Forgetting that the TM RHS has an extra factor related to <span class="eq" style="display:inline;">n_1/n_2</span> (or equivalently <span class="eq" style="display:inline;">θ_c</span>).</li>
          </ul>
        </div>
        <div class="card">
          <strong>Quick tips</strong>
          <ul>
            <li>Use the mode “bin width” <span class="eq" style="display:inline;">Δ(sinθ)=λ/(2d)</span> to organize branches.</li>
            <li>Near cutoff (<span class="eq" style="display:inline;">sinθ→sinθ_c</span>), the RHS → 0, so intersections drift toward where the LHS crosses zero.</li>
            <li>If <span class="eq" style="display:inline;">sinθ_c</span> is exactly an integer multiple of <span class="eq" style="display:inline;">λ/(2d)</span>, the highest mode often sits exactly at cutoff.</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- PART 3 -->
    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Physical intuition first</h3>
      <p class="muted">
        Think of a guided mode as a ray that repeatedly reflects inside the core. If the phase after one round trip matches itself,
        the interference is constructive and a stable mode exists. TM polarization changes the reflection phase shift, so the mode angles
        shift slightly compared with TE. Mode count is mainly set by how many half-wavelength “transverse oscillations” fit into the thickness
        before reaching the critical guidance limit.
      </p>

      <h3>Step 1 — Start from the TE self-consistency equation (given form)</h3>
      <div class="eqbox">
        <p class="eq" id="eqTE">TE (given form):
tan( (π d/λ) sinθ − mπ/2 ) = √( sin²θ_c / sin²θ − 1 )</p>
        <div class="copyRow">
          <button class="copy" data-copy="eqTE">Copy TE equation</button>
          <span class="toast" id="toastEqTE">Copied!</span>
        </div>
      </div>
      <p class="muted">
        Here <span class="eq" style="display:inline;">m</span> labels the mode/branch, and guided solutions require <span class="eq" style="display:inline;">0 &lt; sinθ ≤ sinθ_c</span>.
        The RHS is the (TE) total-internal-reflection phase shift written in a convenient tangent-half-angle form.
      </p>

      <h3>Step 2 — Reflection phase under TIR and the TE→TM modification</h3>
      <p>
        For an interface with incidence from <span class="eq" style="display:inline;">n_1</span> to <span class="eq" style="display:inline;">n_2</span> (<span class="eq" style="display:inline;">n_1&gt;n_2</span>), under total internal reflection the Fresnel reflection coefficient has unit magnitude and a phase:
        <span class="eq" style="display:inline;">r = e^{-jδ}</span>.
        The tangent-half-angle forms satisfy (standard result for TIR):
      </p>

      <div class="eqbox">
        <p class="eq" id="eqPhaseRel">TIR phase relation:
tan(δ_TM/2) = (n1²/n2²) · tan(δ_TE/2)</p>
        <div class="copyRow">
          <button class="copy" data-copy="eqPhaseRel">Copy phase relation</button>
          <span class="toast" id="toastEqPhaseRel">Copied!</span>
        </div>
      </div>

      <p class="muted">
        The given TE RHS is exactly <span class="eq" style="display:inline;">tan(δ_TE/2)</span> expressed using the bounce-angle-from-axis convention.
        So for TM we multiply that TE RHS by <span class="eq" style="display:inline;">(n1²/n2²)</span>.
      </p>

      <h3>Step 3 — Express the factor using the critical angle parameter</h3>
      <p>
        With the bounce-angle-from-axis convention used in the given TE equation, the critical parameter can be written as
        <span class="eq" style="display:inline;">sinθ_c = √(1-(n2/n1)²)</span>, so
        <span class="eq" style="display:inline;">(n1²/n2²) = 1/(n2/n1)² = 1/ cos²θ_c</span>
        because <span class="eq" style="display:inline;">cosθ_c = n2/n1</span>.
      </p>

      <div class="eqbox">
        <p class="eq" id="eqTM">TM (derived, analogous to TE):
tan( (π d/λ) sinθ − mπ/2 ) = (1/cos²θ_c) · √( sin²θ_c / sin²θ − 1 )</p>
        <div class="copyRow">
          <button class="copy" data-copy="eqTM">Copy TM equation</button>
          <span class="toast" id="toastEqTM">Copied!</span>
        </div>
      </div>

      <p class="muted">
        <strong>What we did and why:</strong> We kept the same LHS (which encodes the transverse standing-wave condition),
        and replaced the TE reflection phase shift with the TM one via Fresnel physics.
      </p>

      <h3>Step 4 — Plug in the given numbers (for plotting &amp; mode count)</h3>
      <ul>
        <li>Given <span class="eq" style="display:inline;">λ/(2d)=0.1</span> ⇒ <span class="eq" style="display:inline;">d = λ/(2·0.1)=5λ</span> ⇒ <span class="eq" style="display:inline;">(πd/λ)=5π</span>.</li>
        <li>Given <span class="eq" style="display:inline;">sinθ_c=0.3</span> ⇒ <span class="eq" style="display:inline;">cos²θ_c=1−sin²θ_c=0.91</span> ⇒ <span class="eq" style="display:inline;">1/cos²θ_c≈1.0989</span>.</li>
      </ul>

      <div class="eqbox">
        <p class="eq" id="eqNumeric">With the given parameters:
tan( 5π sinθ − mπ/2 ) = 1.0989 · √( 0.3² / sin²θ − 1 )</p>
        <div class="copyRow">
          <button class="copy" data-copy="eqNumeric">Copy numeric form</button>
          <span class="toast" id="toastEqNumeric">Copied!</span>
        </div>
      </div>

      <h3>Step 5 — Mode counting and the “branch intervals”</h3>
      <p>
        The LHS branches are naturally organized by the “planar-mirror” spacing
        <span class="eq" style="display:inline;">Δ(sinθ)=λ/(2d)</span>.
        Each mode index <span class="eq" style="display:inline;">m</span> corresponds (graphically) to one branch in the interval
        <span class="eq" style="display:inline;">sinθ ∈ [m(λ/2d), (m+1)(λ/2d)]</span>, truncated at <span class="eq" style="display:inline;">sinθ_c</span>.
      </p>

      <div class="card">
        <strong>Here:</strong> <span class="eq" style="display:inline;">λ/(2d)=0.1</span> and <span class="eq" style="display:inline;">sinθ_c=0.3</span> ⇒
        <span class="eq" style="display:inline;">sinθ_c / (λ/2d) = 0.3 / 0.1 = 3</span>.
        Therefore modes can exist for <span class="eq" style="display:inline;">m = 0,1,2,3</span>, with the highest one at cutoff.
      </div>

      <h3>Step 6 — Numerical intersection results (TM)</h3>
      <p class="muted">
        The intersections (filled markers in the plot below) give the guided TM bounce angles.
        For the given parameters, the solutions are approximately:
      </p>

      <div class="eqbox final">
        <p class="eq" id="finalAnswer">TM bounce-angle solutions (sinθm) for sinθc=0.3 and λ/(2d)=0.1:
m=0: sinθ0 ≈ 0.08357  →  θ0 ≈ 4.79°
m=1: sinθ1 ≈ 0.16551  →  θ1 ≈ 9.53°
m=2: sinθ2 ≈ 0.24284  →  θ2 ≈ 14.05°
m=3: sinθ3 = 0.30000 (cutoff) → θ3 ≈ 17.46°

Number of TM modes (including cutoff): M = 4</p>
        <div class="copyRow">
          <button class="copy" data-copy="finalAnswer">Copy final answer</button>
          <span class="toast" id="toastFinal">Copied!</span>
        </div>
      </div>

      <h3>Sanity checks</h3>
      <ul>
        <li><strong>Domain check:</strong> all <span class="eq" style="display:inline;">sinθ_m</span> satisfy <span class="eq" style="display:inline;">0&lt;sinθ_m≤0.3</span>.</li>
        <li><strong>Limiting behavior:</strong> as <span class="eq" style="display:inline;">sinθ→sinθ_c</span>, RHS → 0; indeed the highest solution sits at <span class="eq" style="display:inline;">sinθ=sinθ_c</span>.</li>
        <li><strong>Physics check:</strong> larger <span class="eq" style="display:inline;">d</span> (smaller <span class="eq" style="display:inline;">λ/2d</span>) would create more branch intervals before reaching <span class="eq" style="display:inline;">sinθ_c</span>, hence more modes—exactly what the plot would show.</li>
      </ul>

      <p class="printNote">
        Print note: The interactive plots are designed for screen. For print, use the equations and listed values above.
      </p>
    </section>

    <!-- PART 4 -->
    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the TM formula</h3>
      <p>
        The TM self-consistency condition
        <span class="eq" style="display:inline;">tan( (π d/λ) sinθ − mπ/2 ) = (1/cos²θ_c) √( sin²θ_c/sin²θ − 1 )</span>
        has two “knobs”:
      </p>
      <ul>
        <li><strong>Geometry/wavelength knob:</strong> <span class="eq" style="display:inline;">(π d/λ)</span> controls how quickly the LHS oscillates with <span class="eq" style="display:inline;">sinθ</span>. Thicker guides → more oscillations → more intersections → more modes.</li>
        <li><strong>Index-contrast knob:</strong> <span class="eq" style="display:inline;">θ_c</span> controls both the <em>allowed domain</em> (<span class="eq" style="display:inline;">sinθ≤sinθ_c</span>) and the RHS magnitude. Smaller <span class="eq" style="display:inline;">sinθ_c</span> shrinks the domain and reduces mode count.</li>
        <li><strong>TM polarization effect:</strong> the prefactor <span class="eq" style="display:inline;">1/cos²θ_c = n1²/n2²</span> boosts the RHS relative to TE, shifting intersections (TM angles differ from TE angles).</li>
      </ul>

      <h3>Parameter changes (connect to the interactive plots)</h3>
      <ul>
        <li>Increase <strong>sinθ_c</strong>: the RHS curve extends further right and the domain widens → you usually gain additional high-order modes.</li>
        <li>Decrease <strong>λ/(2d)</strong> (i.e., make the guide thicker): branch spacing shrinks → more branches fit before <span class="eq" style="display:inline;">sinθ_c</span> → more modes.</li>
        <li>Switch <strong>TE ↔ TM</strong>: the RHS rescales; intersections shift. Mode <em>count</em> often stays similar, but exact angles move.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p class="muted">
        You can derive the TE/TM slab dispersion relations by solving Maxwell’s equations with boundary conditions, obtaining an eigenvalue equation in the transverse wavenumber.
        In the large-mode (WKB) limit, that exact eigenvalue equation reduces to a phase integral that matches the ray/phase condition used here—giving the same transcendental form.
      </p>

      <h3>Concept checks (quick self-test)</h3>
      <ul>
        <li><strong>Q:</strong> Why does the RHS go to zero at cutoff? <strong>A:</strong> At the critical condition, the evanescent decay constant in the cladding tends to zero, and the TIR reflection phase shift tends to zero.</li>
        <li><strong>Q:</strong> What sets the approximate mode count? <strong>A:</strong> Roughly how many intervals of width <span class="eq" style="display:inline;">λ/(2d)</span> fit into <span class="eq" style="display:inline;">sinθ_c</span>; i.e., <span class="eq" style="display:inline;">M≈⌊sinθ_c/(λ/2d)⌋+1</span> (including cutoff).</li>
        <li><strong>Q:</strong> What’s the main TE vs TM difference here? <strong>A:</strong> The reflection phase shift, encoded as a multiplicative factor on the RHS for TM.</li>
        <li><strong>Q:</strong> If <span class="eq" style="display:inline;">d</span> doubles, what happens to mode count? <strong>A:</strong> <span class="eq" style="display:inline;">λ/(2d)</span> halves, so about twice as many branches fit → mode count roughly doubles (until limited by material dispersion/other effects).</li>
      </ul>
    </section>

    <!-- PART 5 -->
    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="vizPanel">
        <div class="vizHeader">
          <h3>Interactive visuals (diagram + plots)</h3>
          <div class="controls">
            <label class="ctrl">
              Polarization
              <select id="polSelect">
                <option value="TM" selected>TM</option>
                <option value="TE">TE (compare)</option>
              </select>
            </label>
            <label class="ctrl">
              <span>sin(θ<sub>c</sub>)</span>
              <input id="sinTc" type="range" min="0.12" max="0.90" step="0.01" value="0.30"/>
              <span class="readout" id="sinTcOut">0.30</span>
            </label>
            <label class="ctrl">
              <span>λ/(2d)</span>
              <input id="lam2d" type="range" min="0.04" max="0.25" step="0.01" value="0.10"/>
              <span class="readout" id="lam2dOut">0.10</span>
            </label>
          </div>
        </div>

        <div class="twoCanv">
          <div>
            <canvas id="diagram" class="tall" aria-label="Waveguide diagram"></canvas>
            <p class="muted" style="margin:10px 4px 0;">
              <strong>Diagram:</strong> symmetric slab of thickness <span class="eq" style="display:inline;">2d</span>. A guided ray bounces with angle <span class="eq" style="display:inline;">θ</span> from the axis; each bounce contributes a polarization-dependent phase shift.
            </p>
          </div>
          <div>
            <canvas id="mainPlot" class="tall" aria-label="Graphical solution plot"></canvas>
            <p class="muted" style="margin:10px 4px 0;">
              <strong>Main plot:</strong> LHS branches <span class="eq" style="display:inline;">tan( (π d/λ)sinθ − mπ/2 )</span> (blue) and RHS (dashed) vs <span class="eq" style="display:inline;">sinθ</span>.
              Filled circles are intersections → guided modes.
            </p>
          </div>
        </div>

        <div style="margin-top:12px;">
          <canvas id="secondaryPlot" aria-label="Secondary plot: bounce angle vs mode index"></canvas>
          <p class="muted" style="margin:10px 4px 0;">
            <strong>Secondary plot:</strong> resulting <span class="eq" style="display:inline;">θ_m</span> (degrees) vs mode index <span class="eq" style="display:inline;">m</span>.
            As you change parameters, the curve updates and the mode count can change when a new intersection appears/disappears near cutoff.
          </p>
        </div>
      </div>
    </section>

    <footer style="padding:14px 4px 0; color:var(--muted); font-size:.9rem;">
      <hr style="border:none; border-top:1px solid var(--line); margin:18px 0 12px;">
      <p style="margin:0;">
        Built as a self-contained learning article with interactive canvases (no external libraries). Use the controls to explore how slab thickness and index contrast affect TM/TE modes.
      </p>
    </footer>
  </article>

  <!-- Sticky TOC -->
  <nav class="toc" aria-label="Table of contents">
    <h2>On this page</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy &amp; Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
  </nav>
</main>

<script>
/* ---------- Smooth TOC scrolling ---------- */
(function(){
  const tocLinks = document.querySelectorAll('nav.toc a');
  tocLinks.forEach(a=>{
    a.addEventListener('click', (e)=>{
      const href = a.getAttribute('href');
      if(!href || !href.startsWith('#')) return;
      const el = document.querySelector(href);
      if(!el) return;
      e.preventDefault();
      el.scrollIntoView({behavior:'smooth', block:'start'});
      history.replaceState(null, '', href);
    });
  });
})();

/* ---------- Copy buttons ---------- */
(function(){
  function showToast(id){
    const t = document.getElementById(id);
    if(!t) return;
    t.classList.add('show');
    setTimeout(()=>t.classList.remove('show'), 900);
  }
  document.querySelectorAll('button.copy').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const targetId = btn.getAttribute('data-copy');
      const el = document.getElementById(targetId);
      const txt = el ? el.innerText.trim() : '';
      try{
        await navigator.clipboard.writeText(txt);
        const toastId = 'toast' + targetId.charAt(0).toUpperCase() + targetId.slice(1);
        showToast(toastId);
      }catch(err){
        // fallback
        const ta = document.createElement('textarea');
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        const toastId = 'toast' + targetId.charAt(0).toUpperCase() + targetId.slice(1);
        showToast(toastId);
      }
    });
  });
})();

/* ---------- Canvas utilities ---------- */
function setupHiDPICanvas(canvas){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(2, Math.floor(rect.width * dpr));
  const h = Math.max(2, Math.floor(rect.height * dpr));
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h;
  }
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return {ctx, w: rect.width, h: rect.height, dpr};
}

function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

/* ---------- Plotting primitives ---------- */
function drawAxes(ctx, x0,y0,w,h, xMin,xMax,yMin,yMax, xLabel,yLabel, title){
  // background
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(x0,y0,w,h);

  // frame
  ctx.strokeStyle = 'rgba(255,255,255,0.14)';
  ctx.lineWidth = 1;
  ctx.strokeRect(x0,y0,w,h);

  // grid + ticks
  const nx = 6, ny = 6;
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillStyle = 'rgba(231,238,252,0.85)';
  ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  ctx.lineWidth = 1;

  // title
  ctx.font = '600 13px ui-sans-serif, system-ui';
  ctx.fillStyle = 'rgba(231,238,252,0.92)';
  ctx.fillText(title, x0+8, y0+18);

  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillStyle = 'rgba(231,238,252,0.78)';

  // grid lines
  for(let i=1;i<nx;i++){
    const x = x0 + (i/nx)*w;
    ctx.beginPath(); ctx.moveTo(x, y0); ctx.lineTo(x, y0+h); ctx.stroke();
  }
  for(let j=1;j<ny;j++){
    const y = y0 + (j/ny)*h;
    ctx.beginPath(); ctx.moveTo(x0, y); ctx.lineTo(x0+w, y); ctx.stroke();
  }

  // tick labels
  ctx.fillStyle = 'rgba(231,238,252,0.72)';
  for(let i=0;i<=nx;i++){
    const xv = xMin + (i/nx)*(xMax-xMin);
    const x = x0 + (i/nx)*w;
    ctx.fillText(xv.toFixed(2), x-10, y0+h+16);
  }
  for(let j=0;j<=ny;j++){
    const yv = yMax - (j/ny)*(yMax-yMin);
    const y = y0 + (j/ny)*h;
    ctx.fillText(yv.toFixed(2), x0-38, y+4);
  }

  // axis labels
  ctx.fillStyle = 'rgba(231,238,252,0.82)';
  ctx.fillText(xLabel, x0 + w/2 - ctx.measureText(xLabel).width/2, y0+h+34);

  ctx.save();
  ctx.translate(x0-48, y0 + h/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
  ctx.restore();

  ctx.restore();

  // coordinate transforms
  function X(x){ return x0 + (x - xMin) * w/(xMax-xMin); }
  function Y(y){ return y0 + (yMax - y) * h/(yMax-yMin); }
  return {X,Y};
}

function drawLegend(ctx, x, y, items){
  ctx.save();
  ctx.font = '12px ui-sans-serif, system-ui';
  let maxW = 0;
  items.forEach(it=>{
    maxW = Math.max(maxW, ctx.measureText(it.label).width);
  });
  const boxW = 16 + 8 + maxW + 14;
  const boxH = items.length*18 + 10;
  ctx.fillStyle = 'rgba(15,22,36,0.82)';
  ctx.strokeStyle = 'rgba(255,255,255,0.14)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(x, y, boxW, boxH, 10);
  ctx.fill(); ctx.stroke();

  items.forEach((it, i)=>{
    const yy = y + 18*(i+1);
    ctx.strokeStyle = it.stroke;
    ctx.lineWidth = 2;
    ctx.setLineDash(it.dash || []);
    ctx.beginPath();
    ctx.moveTo(x+10, yy-4);
    ctx.lineTo(x+26, yy-4);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(231,238,252,0.82)';
    ctx.fillText(it.label, x+34, yy);
  });
  ctx.restore();
}

/* ---------- Waveguide math (TE/TM graphical equation) ---------- */
function rhsValue(s, sinTc, pol){
  // RHS = factor * sqrt( sin^2(tc)/s^2 - 1 ), for 0<s<=sinTc
  if(s<=0) return Infinity;
  if(s>sinTc) return NaN;
  const inside = (sinTc*sinTc)/(s*s) - 1;
  if(inside<0) return NaN;
  const base = Math.sqrt(inside);
  const cosTc2 = Math.max(1e-12, 1 - sinTc*sinTc);
  const factor = (pol === 'TM') ? (1/cosTc2) : 1.0;
  return factor * base;
}

function lhsValue(s, lamOver2d, m){
  // LHS = tan( (π d/λ) s - mπ/2 ), with d/λ = 1/(2*(λ/2d))
  const a = Math.PI / (2*lamOver2d); // π d/λ
  return Math.tan(a*s - m*Math.PI/2);
}

function findRootInInterval(f, a, b){
  // robust bisection with sign checks; returns null if no bracket
  let fa = f(a), fb = f(b);
  if(!isFinite(fa) || !isFinite(fb)) return null;
  if(fa === 0) return a;
  if(fb === 0) return b;
  if(fa*fb > 0) return null;
  let lo=a, hi=b;
  for(let i=0;i<70;i++){
    const mid = 0.5*(lo+hi);
    const fm = f(mid);
    if(!isFinite(fm)) { // shrink away from singularities
      hi = mid;
      continue;
    }
    if(Math.abs(fm) < 1e-10) return mid;
    if(fa*fm <= 0){
      hi = mid; fb = fm;
    }else{
      lo = mid; fa = fm;
    }
  }
  return 0.5*(lo+hi);
}

function computeModes(sinTc, lamOver2d, pol){
  const step = lamOver2d;
  // number of "bins" that touch sinTc:
  const ratio = sinTc / step;
  const mMax = Math.floor(ratio + 1e-12); // include cutoff bin when ratio is integer
  const eps = 1e-5;

  const modes = [];
  for(let m=0; m<=mMax; m++){
    const lo = m*step;
    const hi = Math.min((m+1)*step, sinTc);
    if(hi - lo < 5e-6) {
      // possible exact cutoff intersection at sinTc
      if(Math.abs(hi - sinTc) < 1e-9 && Math.abs(lo - sinTc) < 1e-9){
        modes.push({m, s: sinTc, thetaDeg: Math.asin(clamp(sinTc,0,1))*180/Math.PI, cutoff:true});
      }
      continue;
    }

    // Define equation f(s)=LHS-RHS
    const f = (s)=>{
      const L = lhsValue(s, lamOver2d, m);
      const R = rhsValue(s, sinTc, pol);
      return L - R;
    };

    // If cutoff point exactly at hi=sinTc and also equals lo (m==ratio), treat as cutoff mode
    if(Math.abs(hi - sinTc) < 1e-9 && Math.abs(lo - sinTc) < 1e-9){
      modes.push({m, s: sinTc, thetaDeg: Math.asin(clamp(sinTc,0,1))*180/Math.PI, cutoff:true});
      continue;
    }

    // Search for a bracket inside (lo,hi) avoiding tan singularities:
    // We'll sample and find a sign change.
    const N = 180;
    let prevS = lo + eps;
    let prevV = f(prevS);
    let found = null;

    for(let i=1;i<=N;i++){
      const s = lo + eps + (hi - lo - 2*eps) * (i/N);
      const v = f(s);
      if(!isFinite(prevV) || !isFinite(v)){
        prevS = s;
        prevV = v;
        continue;
      }
      if(prevV === 0){
        found = prevS; break;
      }
      if(v === 0){
        found = s; break;
      }
      if(prevV * v < 0){
        const r = findRootInInterval(f, prevS, s);
        if(r !== null){
          found = r; break;
        }
      }
      prevS = s;
      prevV = v;
    }

    if(found !== null && found !== undefined){
      const thetaDeg = Math.asin(clamp(found,0,1))*180/Math.PI;
      const cutoff = Math.abs(found - sinTc) < 5e-4;
      modes.push({m, s: found, thetaDeg, cutoff});
    }else{
      // Also check possibility of exact cutoff intersection at s=sinTc when hi==sinTc
      if(Math.abs(hi - sinTc) < 1e-9){
        const s = sinTc;
        const L = lhsValue(s, lamOver2d, m);
        const R = rhsValue(s, sinTc, pol); // = 0
        if(isFinite(L) && Math.abs(L - R) < 1e-9){
          modes.push({m, s, thetaDeg: Math.asin(clamp(s,0,1))*180/Math.PI, cutoff:true});
        }
      }
    }
  }
  return {modes, mMax};
}

/* ---------- Drawing: diagram ---------- */
function drawDiagram(canvas, sinTc, lamOver2d, pol, modes){
  const {ctx, w, h} = setupHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  // Layout
  const pad = 18;
  const x0 = pad, y0 = pad+8;
  const ww = w - 2*pad, hh = h - 2*pad - 10;

  // Slab rectangle (core)
  const slabX = x0 + ww*0.12;
  const slabW = ww*0.72;
  const slabY = y0 + hh*0.28;
  const slabH = hh*0.36;

  // Draw background subtle
  ctx.save();
  ctx.fillStyle = 'rgba(7,10,16,0.20)';
  ctx.fillRect(x0,y0,ww,hh);
  ctx.restore();

  // Draw cladding labels
  ctx.save();
  ctx.fillStyle = 'rgba(231,238,252,0.70)';
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillText('cladding (n₂)', slabX, slabY - 10);
  ctx.fillText('cladding (n₂)', slabX, slabY + slabH + 18);
  ctx.restore();

  // Draw slab (core)
  ctx.save();
  ctx.fillStyle = 'rgba(123,220,255,0.10)';
  ctx.strokeStyle = 'rgba(123,220,255,0.28)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.roundRect(slabX, slabY, slabW, slabH, 14);
  ctx.fill(); ctx.stroke();
  ctx.fillStyle = 'rgba(231,238,252,0.85)';
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillText('core (n₁)', slabX + 10, slabY + 20);
  ctx.restore();

  // Axes: z to right, x upward
  const axX = slabX + 20, axY = slabY + slabH + 60;
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.20)';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(axX, axY); ctx.lineTo(axX + 90, axY); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(axX, axY); ctx.lineTo(axX, axY - 60); ctx.stroke();
  ctx.fillStyle = 'rgba(231,238,252,0.78)';
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillText('z', axX + 96, axY + 4);
  ctx.fillText('x', axX - 10, axY - 64);
  ctx.restore();

  // Choose a representative bounce angle theta:
  // If modes exist, use first non-cutoff mode; else use 0.6*tc
  let sRep = sinTc*0.6;
  for(const md of modes){
    if(!md.cutoff){ sRep = md.s; break; }
  }
  const theta = Math.asin(clamp(sRep, 0, 0.9999)); // radians

  // Draw bouncing ray inside slab
  const centerY = slabY + slabH/2;
  const left = slabX + 30;
  const right = slabX + slabW - 30;

  // Determine ray slope in x-z plane: tan(theta) = dx/dz? (theta from axis z)
  // So as z increases, x changes with slope tan(theta).
  const slope = Math.tan(theta);

  // We'll create a zigzag with reflections between top and bottom boundaries
  const topY = slabY + 12;
  const botY = slabY + slabH - 12;

  // Start point
  let z = left;
  let x = centerY;
  let dir = 1; // +1 toward top, -1 toward bottom in x-direction (screen y downward, so invert)
  // In screen coordinates, y increases downward; "up" means negative y.
  // We'll implement with target boundary and reflect.

  ctx.save();
  ctx.strokeStyle = (pol === 'TM') ? 'rgba(166,255,203,0.95)' : 'rgba(123,220,255,0.95)';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(z, x);
  for(let bounce=0; bounce<6; bounce++){
    const targetY = (dir>0) ? topY : botY;
    // in screen coords, going to top means decreasing y; slope in terms of dy/dz = ±tan(theta) with sign:
    const dy = targetY - x;
    const dz = Math.abs(dy) / Math.max(1e-6, slope);
    const zNext = z + dz;
    if(zNext > right){
      // draw to right edge
      const dzEdge = right - z;
      const dyEdge = dir>0 ? -slope*dzEdge : +slope*dzEdge; // dir>0 goes up => negative
      const yEdge = x + dyEdge;
      ctx.lineTo(right, yEdge);
      z = right; x = yEdge;
      break;
    }else{
      ctx.lineTo(zNext, targetY);
      z = zNext; x = targetY;
      dir *= -1; // reflect
    }
  }
  ctx.stroke();
  ctx.restore();

  // Draw angle marker θ
  ctx.save();
  const arcCx = left + 40;
  const arcCy = centerY + 40;
  const r = 26;
  ctx.strokeStyle = 'rgba(255,210,123,0.85)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  // reference: axis along +z (to the right)
  const a0 = Math.PI*1.5; // along up? We'll just draw a small arc relative to horizontal axis.
  // Better: draw arc from 0 to -theta in screen coords around a point
  ctx.translate(arcCx, arcCy);
  ctx.beginPath();
  ctx.arc(0,0,r, 0, -theta, true);
  ctx.stroke();
  ctx.fillStyle = 'rgba(255,210,123,0.92)';
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillText('θ', r+6, -theta*r*0.5);
  ctx.restore();

  // Labels
  ctx.save();
  ctx.fillStyle = 'rgba(231,238,252,0.78)';
  ctx.font = '12px ui-sans-serif, system-ui';
  const dText = 'thickness = 2d';
  ctx.fillText(dText, slabX + slabW - ctx.measureText(dText).width - 10, slabY + slabH/2 + 4);

  const polText = `polarization: ${pol}`;
  ctx.fillStyle = 'rgba(231,238,252,0.85)';
  ctx.fillText(polText, x0 + 8, y0 + 16);

  const pText = `example θ from modes: sinθ ≈ ${sRep.toFixed(3)}`;
  ctx.fillStyle = 'rgba(231,238,252,0.70)';
  ctx.fillText(pText, x0 + 8, y0 + 34);
  ctx.restore();

  // Show sinθc and λ/2d
  ctx.save();
  ctx.fillStyle = 'rgba(231,238,252,0.75)';
  ctx.font = '12px ui-sans-serif, system-ui';
  const info = `sin(θc)=${sinTc.toFixed(2)},  λ/(2d)=${lamOver2d.toFixed(2)}`;
  ctx.fillText(info, x0 + 8, y0 + hh - 10);
  ctx.restore();
}

/* ---------- Drawing: main plot (graphical solution) ---------- */
function drawMainPlot(canvas, sinTc, lamOver2d, pol, modes){
  const {ctx, w, h} = setupHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  const margin = {l:52, r:16, t:30, b:46};
  const x0 = margin.l, y0 = margin.t, pw = w - margin.l - margin.r, ph = h - margin.t - margin.b;

  // x-range: 0..sinTc, y-range: choose to show tan branches and RHS
  // We'll cap y-range for readability like textbook (0..10).
  const xMin = 0, xMax = Math.max(0.12, sinTc);
  const yMin = 0, yMax = 10;

  const title = `Graphical solution (${pol}): LHS branches and RHS vs sinθ`;
  const {X,Y} = drawAxes(ctx, x0,y0,pw,ph, xMin,xMax,yMin,yMax, 'sin(θ)', 'value', title);

  // RHS curve
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.75)';
  ctx.lineWidth = 2;
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  let started = false;
  const N = 500;
  for(let i=0;i<=N;i++){
    const s = (i/N) * sinTc;
    const v = rhsValue(Math.max(s, 1e-4), sinTc, pol);
    if(!isFinite(v)) { started=false; continue; }
    const vv = clamp(v, yMin, yMax);
    const xx = X(s), yy = Y(vv);
    if(!started){ ctx.moveTo(xx,yy); started=true; }
    else ctx.lineTo(xx,yy);
  }
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();

  // LHS branches for m=0..mMax+2 (draw a little beyond)
  const step = lamOver2d;
  const mMaxDraw = Math.floor(sinTc/step + 1e-12) + 2;
  for(let m=0; m<=mMaxDraw; m++){
    const lo = m*step;
    const hi = Math.min((m+1)*step, sinTc);
    if(hi <= 0) continue;
    if(lo >= sinTc) continue;

    ctx.save();
    ctx.strokeStyle = 'rgba(123,220,255,0.85)';
    ctx.lineWidth = 2;

    ctx.beginPath();
    let ok=false;
    const M = 240;
    for(let i=0;i<=M;i++){
      const s = lo + (hi-lo)*(i/M);
      const v = lhsValue(s, lamOver2d, m);
      if(!isFinite(v)) { ok=false; continue; }
      const vv = clamp(v, yMin, yMax);
      const xx = X(s), yy = Y(vv);
      if(!ok){ ctx.moveTo(xx,yy); ok=true; }
      else ctx.lineTo(xx,yy);
    }
    ctx.stroke();
    ctx.restore();

    // open circles at planar-mirror points sinθ = m*step (within range)
    if(lo >= 0 && lo <= sinTc + 1e-12){
      ctx.save();
      ctx.strokeStyle = 'rgba(231,238,252,0.65)';
      ctx.fillStyle = 'rgba(7,10,16,0.0)';
      ctx.lineWidth = 2;
      const xx = X(lo);
      const yy = Y(0); // on x-axis
      ctx.beginPath();
      ctx.arc(xx, yy, 4.5, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }
  }

  // Filled circles for modes
  ctx.save();
  ctx.fillStyle = 'rgba(166,255,203,0.95)';
  ctx.strokeStyle = 'rgba(0,0,0,0.0)';
  for(const md of modes){
    const s = md.s;
    const L = lhsValue(s, lamOver2d, md.m);
    const xx = X(s);
    const yy = Y(clamp(L, yMin, yMax));
    ctx.beginPath();
    ctx.arc(xx, yy, 5.5, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();

  // Mark sinθc vertical line
  ctx.save();
  ctx.strokeStyle = 'rgba(255,210,123,0.70)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(X(sinTc), Y(yMin));
  ctx.lineTo(X(sinTc), Y(yMax));
  ctx.stroke();
  ctx.fillStyle = 'rgba(255,210,123,0.92)';
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillText('sinθc', X(sinTc)-16, Y(yMax)+14);
  ctx.restore();

  // Legend
  drawLegend(ctx, x0+10, y0+8, [
    {label:'LHS: tan( (πd/λ)sinθ − mπ/2 )', stroke:'rgba(123,220,255,0.85)'},
    {label:'RHS (TIR phase term)', stroke:'rgba(255,255,255,0.75)', dash:[6,6]},
    {label:'Intersections = modes', stroke:'rgba(166,255,203,0.95)'}
  ]);

  // Text: mode count
  ctx.save();
  ctx.fillStyle = 'rgba(231,238,252,0.82)';
  ctx.font = '12px ui-sans-serif, system-ui';
  const M = modes.length;
  const txt = `Found modes (including cutoff if present): M = ${M}`;
  ctx.fillText(txt, x0 + pw - ctx.measureText(txt).width - 6, y0 + ph - 8);
  ctx.restore();
}

/* ---------- Drawing: secondary plot (theta vs m) ---------- */
function drawSecondaryPlot(canvas, sinTc, lamOver2d, pol, modes){
  const {ctx, w, h} = setupHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  const margin = {l:52, r:16, t:30, b:46};
  const x0 = margin.l, y0 = margin.t, pw = w - margin.l - margin.r, ph = h - margin.t - margin.b;

  const mMax = Math.max(1, ...modes.map(d=>d.m));
  const xMin = -0.2, xMax = mMax + 0.8;

  // y range up to theta_c
  const thetaC = Math.asin(clamp(sinTc,0,1))*180/Math.PI;
  const yMin = 0, yMax = Math.max(10, thetaC*1.15);

  const title = `Mode angles: θm (deg) vs mode index m   (${pol})`;
  const {X,Y} = drawAxes(ctx, x0,y0,pw,ph, xMin,xMax,yMin,yMax, 'mode index m', 'θ (degrees)', title);

  // reference line at cutoff angle
  ctx.save();
  ctx.strokeStyle = 'rgba(255,210,123,0.70)';
  ctx.lineWidth = 2;
  ctx.setLineDash([5,6]);
  ctx.beginPath();
  ctx.moveTo(X(xMin), Y(thetaC));
  ctx.lineTo(X(xMax), Y(thetaC));
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = 'rgba(255,210,123,0.92)';
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillText(`cutoff θc ≈ ${thetaC.toFixed(2)}°`, X(xMin)+8, Y(thetaC)-6);
  ctx.restore();

  if(modes.length){
    // line through points
    ctx.save();
    ctx.strokeStyle = (pol === 'TM') ? 'rgba(166,255,203,0.95)' : 'rgba(123,220,255,0.95)';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    modes.sort((a,b)=>a.m-b.m);
    modes.forEach((d,i)=>{
      const xx = X(d.m);
      const yy = Y(d.thetaDeg);
      if(i===0) ctx.moveTo(xx,yy);
      else ctx.lineTo(xx,yy);
    });
    ctx.stroke();
    ctx.restore();

    // points
    ctx.save();
    ctx.fillStyle = 'rgba(231,238,252,0.92)';
    modes.forEach(d=>{
      const xx = X(d.m);
      const yy = Y(d.thetaDeg);
      ctx.beginPath();
      ctx.arc(xx,yy,5.2,0,Math.PI*2);
      ctx.fill();
      // label sinθ
      ctx.font = '11px ui-sans-serif, system-ui';
      ctx.fillStyle = 'rgba(231,238,252,0.70)';
      const label = `sinθ=${d.s.toFixed(3)}`;
      ctx.fillText(label, xx+8, yy-8);
      ctx.fillStyle = 'rgba(231,238,252,0.92)';
    });
    ctx.restore();
  }else{
    ctx.save();
    ctx.fillStyle = 'rgba(255,143,163,0.92)';
    ctx.font = '13px ui-sans-serif, system-ui';
    ctx.fillText('No guided modes for these parameters.', X(xMin)+10, Y(yMax-0.15*(yMax-yMin)));
    ctx.restore();
  }

  // Legend
  drawLegend(ctx, x0+10, y0+8, [
    {label:'θm from intersections', stroke:(pol === 'TM') ? 'rgba(166,255,203,0.95)' : 'rgba(123,220,255,0.95)'},
    {label:'cutoff θc', stroke:'rgba(255,210,123,0.70)', dash:[5,6]},
  ]);

  // extra info
  ctx.save();
  ctx.fillStyle = 'rgba(231,238,252,0.80)';
  ctx.font = '12px ui-sans-serif, system-ui';
  const txt = `sinθc=${sinTc.toFixed(2)},  λ/(2d)=${lamOver2d.toFixed(2)},  M=${modes.length}`;
  ctx.fillText(txt, x0 + pw - ctx.measureText(txt).width - 6, y0 + ph - 8);
  ctx.restore();
}

/* ---------- Update loop ---------- */
const els = {
  pol: document.getElementById('polSelect'),
  sinTc: document.getElementById('sinTc'),
  lam2d: document.getElementById('lam2d'),
  sinTcOut: document.getElementById('sinTcOut'),
  lam2dOut: document.getElementById('lam2dOut'),
  diagram: document.getElementById('diagram'),
  mainPlot: document.getElementById('mainPlot'),
  secondaryPlot: document.getElementById('secondaryPlot')
};

function updateAll(){
  const pol = els.pol.value;
  const sinTc = parseFloat(els.sinTc.value);
  const lamOver2d = parseFloat(els.lam2d.value);

  els.sinTcOut.textContent = sinTc.toFixed(2);
  els.lam2dOut.textContent = lamOver2d.toFixed(2);

  const {modes} = computeModes(sinTc, lamOver2d, pol);

  drawDiagram(els.diagram, sinTc, lamOver2d, pol, modes);
  drawMainPlot(els.mainPlot, sinTc, lamOver2d, pol, modes);
  drawSecondaryPlot(els.secondaryPlot, sinTc, lamOver2d, pol, modes);

  // Also update the final-answer box text live (so the page stays consistent with controls),
  // but keep the original solved values visible above in the article body.
  const fa = document.getElementById('finalAnswer');
  if(fa){
    const lines = [];
    lines.push(`${pol} bounce-angle solutions (from intersections):`);
    if(modes.length){
      modes.sort((a,b)=>a.m-b.m).forEach(d=>{
        const cut = d.cutoff ? ' (cutoff)' : '';
        lines.push(`m=${d.m}: sinθ ≈ ${d.s.toFixed(5)}  →  θ ≈ ${d.thetaDeg.toFixed(2)}°${cut}`);
      });
      lines.push('');
      lines.push(`Number of ${pol} modes (including cutoff if present): M = ${modes.length}`);
    }else{
      lines.push('No guided modes for these parameters.');
    }
    // Keep original solved statement intact for the specific problem by appending a separator.
    const base = `TM bounce-angle solutions (sinθm) for sinθc=0.3 and λ/(2d)=0.1:
m=0: sinθ0 ≈ 0.08357  →  θ0 ≈ 4.79°
m=1: sinθ1 ≈ 0.16551  →  θ1 ≈ 9.53°
m=2: sinθ2 ≈ 0.24284  →  θ2 ≈ 14.05°
m=3: sinθ3 = 0.30000 (cutoff) → θ3 ≈ 17.46°

Number of TM modes (including cutoff): M = 4`;
    fa.textContent = base + "\n\n— Live explorer (controls above) —\n" + lines.join('\n');
  }
}

['input','change'].forEach(ev=>{
  els.pol.addEventListener(ev, updateAll);
  els.sinTc.addEventListener(ev, updateAll);
  els.lam2d.addEventListener(ev, updateAll);
});

// Handle responsive resize
let resizeTimer = null;
window.addEventListener('resize', ()=>{
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(updateAll, 120);
});

// Initial render
updateAll();
</script>
</body>
</html>
