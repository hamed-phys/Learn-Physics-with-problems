<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Modal Dispersion in a Mirror (Parallel-Plate) Waveguide — TE/TM Mode Count, Group Velocities, Pulse Spreading</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101a33;
      --panel2:#0f1730;
      --text:#e9eefc;
      --muted:#b9c3e6;
      --faint:#7f8ab3;
      --accent:#7aa7ff;
      --accent2:#7dffc7;
      --warn:#ffcf5a;
      --danger:#ff6b8b;
      --line:rgba(255,255,255,.10);
      --shadow: 0 18px 50px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 700px at 18% 12%, rgba(122,167,255,.20), transparent 55%),
        radial-gradient(900px 600px at 88% 20%, rgba(125,255,199,.13), transparent 55%),
        radial-gradient(800px 600px at 50% 95%, rgba(255,207,90,.08), transparent 60%),
        var(--bg);
      color:var(--text);
      line-height:1.55;
    }

    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}

    header{
      padding:28px 18px 18px;
      max-width:1200px;
      margin:0 auto;
    }

    .hero{
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap:16px;
      align-items:stretch;
    }

    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      box-shadow:var(--shadow);
      border-radius:var(--radius);
      padding:18px 18px 14px;
      overflow:hidden;
      position:relative;
    }
    .titleCard:before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(900px 200px at 15% 0%, rgba(122,167,255,.25), transparent 55%),
        radial-gradient(900px 260px at 85% 0%, rgba(125,255,199,.16), transparent 60%);
      pointer-events:none;
      opacity:.9;
    }
    .titleCard > *{position:relative; z-index:1}
    h1{
      margin:0 0 8px;
      font-weight:800;
      letter-spacing:.2px;
      font-size:clamp(22px, 2.6vw, 34px);
      line-height:1.15;
    }
    .subtitle{
      margin:0 0 10px;
      color:var(--muted);
      font-size:clamp(13px, 1.35vw, 15px);
    }
    .metaRow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:10px;
      color:var(--muted);
      font-size:13px;
    }
    .chip{
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      padding:6px 10px;
      border-radius:999px;
      display:inline-flex;
      gap:8px;
      align-items:center;
    }
    .chip b{color:var(--text)}
    .controls{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      box-shadow:var(--shadow);
      border-radius:var(--radius);
      padding:16px 16px 12px;
    }
    .controls h2{
      margin:0 0 8px;
      font-size:15px;
      color:var(--text);
      letter-spacing:.2px;
    }
    .controlGrid{
      display:grid;
      grid-template-columns:1fr;
      gap:12px;
    }
    .control{
      border:1px solid var(--line);
      background: rgba(0,0,0,.14);
      border-radius:14px;
      padding:12px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:12px;
      font-size:13px;
      color:var(--muted);
      margin-bottom:6px;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    select{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(5,10,22,.65);
      color:var(--text);
      outline:none;
    }
    .small{
      font-size:12px;
      color:var(--faint);
      margin-top:6px;
    }

    main{
      max-width:1200px;
      margin:0 auto 60px;
      padding:0 18px;
      display:grid;
      grid-template-columns: 280px 1fr;
      gap:16px;
      align-items:start;
    }

    nav.toc{
      position:sticky;
      top:14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:14px 14px 12px;
    }
    .toc h3{
      margin:0 0 10px;
      font-size:13px;
      letter-spacing:.3px;
      color:var(--muted);
      text-transform:uppercase;
    }
    .toc a{
      display:block;
      padding:8px 10px;
      margin:4px 0;
      border-radius:12px;
      border:1px solid transparent;
      color:var(--text);
      font-size:13px;
    }
    .toc a:hover{
      background: rgba(122,167,255,.10);
      border-color: rgba(122,167,255,.25);
      text-decoration:none;
    }

    .content{
      display:flex;
      flex-direction:column;
      gap:16px;
      min-width:0;
    }

    section{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:18px;
      overflow:hidden;
    }

    section h2{
      margin:0 0 10px;
      font-size:18px;
      letter-spacing:.2px;
    }
    section h3{
      margin:16px 0 8px;
      font-size:15px;
      color:var(--text);
    }
    p{margin:10px 0; color:var(--muted)}
    ul{margin:10px 0 10px 18px; color:var(--muted)}
    li{margin:6px 0}

    .grid2{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
    }
    .grid3{
      display:grid;
      grid-template-columns:1fr 1fr 1fr;
      gap:12px;
    }

    .callout{
      border:1px solid var(--line);
      background: rgba(0,0,0,.16);
      border-radius:16px;
      padding:14px;
      position:relative;
      overflow:hidden;
    }
    .callout:before{
      content:"";
      position:absolute;
      inset:0;
      background: radial-gradient(600px 160px at 10% 0%, rgba(122,167,255,.16), transparent 55%);
      opacity:.9;
      pointer-events:none;
    }
    .callout > *{position:relative; z-index:1}
    .callout h4{
      margin:0 0 8px;
      font-size:13px;
      letter-spacing:.25px;
      text-transform:uppercase;
      color:var(--text);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .tag{
      display:inline-block;
      font-size:11px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      color:var(--muted);
      background: rgba(0,0,0,.18);
    }
    .callout .mono{
      font-family:var(--mono);
      color:var(--text);
      background: rgba(0,0,0,.18);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px;
      overflow:auto;
      white-space:pre-wrap;
      word-break:break-word;
    }
    .assump{border-left:3px solid var(--warn)}
    .keyeq{border-left:3px solid var(--accent)}
    .mist{border-left:3px solid var(--danger)}
    .final{border-left:3px solid var(--accent2)}
    .kpiRow{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:10px;
      margin-top:10px;
    }
    .kpi{
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px;
      background: rgba(0,0,0,.12);
    }
    .kpi .lab{font-size:12px; color:var(--faint)}
    .kpi .val{font-size:17px; font-weight:800; margin-top:2px}
    .kpi .sub{font-size:12px; color:var(--muted); margin-top:4px}

    .btn{
      cursor:pointer;
      border:1px solid rgba(122,167,255,.35);
      background: rgba(122,167,255,.12);
      color:var(--text);
      border-radius:12px;
      padding:8px 10px;
      font-size:12px;
      transition: transform .12s ease, background .12s ease;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .btn:hover{transform: translateY(-1px); background: rgba(122,167,255,.18)}
    .btn:active{transform: translateY(0px)}
    .btn.secondary{
      border-color: rgba(125,255,199,.35);
      background: rgba(125,255,199,.10);
    }
    .copyRow{display:flex; flex-wrap:wrap; gap:10px; margin-top:10px}
    .note{
      font-size:12px;
      color:var(--faint);
      margin-top:8px;
    }

    figure{
      margin:0;
      border:1px solid var(--line);
      border-radius:16px;
      overflow:hidden;
      background: rgba(0,0,0,.15);
    }
    figcaption{
      padding:10px 12px;
      border-top:1px solid var(--line);
      color:var(--muted);
      font-size:12px;
    }
    canvas{display:block; width:100%; height:auto}

    .vizGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    @media (min-width: 980px){
      .vizGrid{grid-template-columns: 1fr 1fr}
      .vizGrid .wide{grid-column: 1 / -1}
    }

    .divider{
      height:1px;
      background: var(--line);
      margin:14px 0;
    }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding: 0 18px 30px;
      color:var(--faint);
      font-size:12px;
    }

    /* subtle entrance */
    .fadeIn{
      animation: rise .35s ease both;
    }
    @keyframes rise{
      from{opacity:0; transform: translateY(6px)}
      to{opacity:1; transform: translateY(0)}
    }

    /* print */
    @media print{
      body{background:#fff; color:#000}
      header, main, section, nav.toc{box-shadow:none}
      nav.toc{position:relative; top:auto}
      .btn, .controls{display:none !important}
      section{break-inside:avoid}
      a{text-decoration:underline; color:#000}
      p, li{color:#111}
      .callout{background:#f7f7f7}
      .titleCard:before, .callout:before{display:none}
    }

    /* single column on small screens */
    @media (max-width: 920px){
      main{grid-template-columns:1fr}
      nav.toc{position:relative}
      .hero{grid-template-columns:1fr}
    }
  </style>
</head>

<body>
<header class="fadeIn">
  <div class="hero">
    <div class="titleCard">
      <h1>Modal Dispersion in a Mirror (Parallel-Plate) Waveguide</h1>
      <p class="subtitle">
        Count the guided TE/TM modes, compute fastest/slowest group velocities, and estimate pulse spreading over distance.
        This page teaches the theory first, then applies it carefully to the given numbers.
      </p>
      <div class="metaRow">
        <div class="chip"><span class="tag">Given</span> <b>&lambda;<sub>0</sub>=0.633&nbsp;&mu;m</b></div>
        <div class="chip"><span class="tag">Given</span> <b>d=10&nbsp;&mu;m</b></div>
        <div class="chip"><span class="tag">Given</span> <b>n=1</b></div>
        <div class="chip"><span class="tag">Distance</span> <b>L=1&nbsp;m</b></div>
      </div>
    </div>

    <aside class="controls">
      <h2>Interactive Controls (updates diagram + both plots)</h2>
      <div class="controlGrid">
        <div class="control">
          <label>
            <span>Mirror separation <b>d</b> (&mu;m)</span>
            <span class="tag"><span id="dRead">10.00</span></span>
          </label>
          <input id="dSlider" type="range" min="2" max="20" step="0.05" value="10" />
          <div class="small">Try changing <b>d</b>: the number of modes and the slowest group velocity change strongly near cutoff.</div>
        </div>

        <div class="control">
          <label>
            <span>Mode index shown in the diagram <b>m</b></span>
            <span class="tag">visual only</span>
          </label>
          <select id="mSelect"></select>
          <div class="small">This highlights one mode’s transverse standing wave and its point on the plots.</div>
        </div>

        <div class="control">
          <div class="small">
            Fixed here: <b>&lambda;<sub>0</sub>=0.633&nbsp;&mu;m</b>, <b>n=1</b>, <b>L=1&nbsp;m</b>.
            (You can easily extend the JS to add more sliders.)
          </div>
        </div>
      </div>
    </aside>
  </div>
</header>

<main class="fadeIn">
  <nav class="toc" aria-label="Table of contents">
    <h3>On this page</h3>
    <a href="#quick" data-jump>Quick Summary</a>
    <a href="#part0" data-jump>PART 0 — Concept Primer</a>
    <a href="#part1" data-jump>PART 1 — Problem Analysis</a>
    <a href="#part2" data-jump>PART 2 — Strategy & Tips</a>
    <a href="#part3" data-jump>PART 3 — Full Solution</a>
    <a href="#part4" data-jump>PART 4 — Deeper Understanding</a>
    <a href="#part5" data-jump>PART 5 — Visualization Guide</a>
  </nav>

  <div class="content">

    <section id="quick">
      <h2>Quick Summary</h2>
      <ul>
        <li>This problem is about <b>modal dispersion</b> in an ideal <b>mirror (parallel-plate) waveguide</b> of separation <b>d</b>.</li>
        <li>Guided modes exist only when the longitudinal propagation constant is real:
          <span class="mono">β_m = sqrt((n k0)^2 − (mπ/d)^2)</span>.</li>
        <li>Mode count comes from the <b>cutoff</b> condition <span class="mono">n k0 &gt; mπ/d</span> ⇒ <span class="mono">m &lt; 2nd/λ0</span>.</li>
        <li>For each guided index <b>m</b>, the <b>group velocity</b> is
          <span class="mono">v_g(m)=dω/dβ=(c/n)·sqrt(1 − (mλ0/(2nd))^2)</span>.</li>
        <li>Fastest mode is the <b>lowest-order</b> guided mode (here <b>m=1</b>), slowest is the <b>highest-order</b> guided mode (here <b>m=m_max</b>).</li>
        <li>Pulse spreading over length <b>L</b> is estimated by
          <span class="mono">Δt ≈ L(1/v_g,slow − 1/v_g,fast)</span>.</li>
        <li>With <b>λ0=0.633 μm</b>, <b>d=10 μm</b>, <b>n=1</b>:
          <b>m_max=31</b> ⇒ <b>31 TE</b> and <b>31 TM</b> propagating modes (62 total, not counting any TEM discussion).</li>
        <li>Numerically: <b>v_g,fast ≈ 0.9995 c</b>, <b>v_g,slow ≈ 0.193 c</b>, giving <b>Δt ≈ 13.9 ns</b> over <b>1 m</b>.</li>
      </ul>

      <div class="kpiRow" aria-label="Live results summary">
        <div class="kpi">
          <div class="lab">Propagating TE modes</div>
          <div class="val" id="kpiTE">—</div>
          <div class="sub">indices m=1…m<sub>max</sub></div>
        </div>
        <div class="kpi">
          <div class="lab">Propagating TM modes</div>
          <div class="val" id="kpiTM">—</div>
          <div class="sub">indices m=1…m<sub>max</sub></div>
        </div>
        <div class="kpi">
          <div class="lab">Fastest group velocity</div>
          <div class="val" id="kpiVFast">—</div>
          <div class="sub">at m=1</div>
        </div>
        <div class="kpi">
          <div class="lab">Pulse spread (time)</div>
          <div class="val" id="kpiDt">—</div>
          <div class="sub">over L=1 m</div>
        </div>
      </div>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

      <article>
        <h3>0.1 What is a mirror (parallel-plate) waveguide?</h3>
        <p>
          A mirror waveguide is a <b>planar cavity-like</b> structure: two perfectly reflecting parallel plates separated by distance
          <b>d</b>, with a uniform medium of refractive index <b>n</b> in between. Light propagates along the <b>z</b>-direction, while the field
          forms a standing wave across the transverse <b>x</b>-direction between the plates.
        </p>

        <div class="grid2">
          <div class="callout keyeq">
            <h4>Core definitions <span class="tag">symbols &amp; units</span></h4>
            <div class="mono" id="eqDefs">
k0 = 2π/λ0        (vacuum wavenumber)        [1/m]
k  = n k0        (wavenumber in medium)     [1/m]
m  = 1,2,3,...   (mode index across plates) [dimensionless]
kx = mπ/d        (transverse wavenumber)    [1/m]
βm = longitudinal propagation constant      [1/m]
ω  = angular frequency                      [rad/s]
vg = group velocity = dω/dβ                 [m/s]
            </div>
            <div class="copyRow">
              <button class="btn" data-copy-target="eqDefs">Copy</button>
            </div>
          </div>

          <div class="callout">
            <h4>Physical meaning <span class="tag">intuition</span></h4>
            <p>
              The mode index <b>m</b> counts how many “half-wavelength” lobes fit between the mirrors (in the transverse direction).
              Larger <b>m</b> means more transverse oscillation, leaving less “budget” for forward propagation. That’s why high-order modes
              have smaller <b>β</b> and smaller <b>v<sub>g</sub></b>.
            </p>
            <p class="note">
              “Modal dispersion” happens because different modes carry energy forward at different group velocities.
            </p>
          </div>
        </div>

        <h3>0.2 Governing wave model and validity</h3>
        <p>
          In a uniform, lossless medium the electric field satisfies the Helmholtz equation (from Maxwell’s equations):
          <span class="mono">∇²E + k²E = 0</span> with <span class="mono">k = nω/c</span>.
          With perfectly conducting mirrors, boundary conditions force certain field components to vanish at the plates, producing discrete
          allowed transverse wavenumbers <span class="mono">kx = mπ/d</span>.
        </p>

        <div class="callout assump">
          <h4>Assumptions &amp; conditions <span class="tag">when this is valid</span></h4>
          <ul>
            <li>Perfectly reflecting (ideal conductor) mirrors: no penetration, no loss.</li>
            <li>Uniform refractive index <b>n</b> in the gap (here <b>n=1</b>).</li>
            <li>Linear, isotropic medium; monochromatic carrier with small-bandwidth pulse for group velocity concept.</li>
            <li>No material dispersion considered (only <b>waveguide dispersion</b> from geometry).</li>
          </ul>
        </div>

        <h3>0.3 TE vs TM in a planar guide (and what the mode index means)</h3>
        <p>
          For propagation along <b>z</b>, a mode is called:
        </p>
        <ul>
          <li><b>TE</b> (transverse electric): <span class="mono">E_z = 0</span>.</li>
          <li><b>TM</b> (transverse magnetic): <span class="mono">H_z = 0</span>.</li>
        </ul>
        <p>
          In an ideal parallel-plate guide, the <b>allowed transverse wavenumbers</b> for TE and TM are the same:
          <span class="mono">kx = mπ/d</span> (with <b>m=1,2,3,…</b> for TE/TM standing-wave families).
          The dispersion relation for both families has the same form, so the <b>mode counts and group velocities match</b> for TE and TM in
          this idealized setting.
        </p>

        <div class="grid2">
          <div class="callout keyeq">
            <h4>Dispersion relation <span class="tag">key equation</span></h4>
            <div class="mono" id="eqDisp">
βm(ω) = sqrt( (nω/c)^2 − (mπ/d)^2 )
propagating if βm is real  ⇔  (nω/c) > mπ/d
            </div>
            <div class="copyRow">
              <button class="btn" data-copy-target="eqDisp">Copy</button>
            </div>
          </div>

          <div class="callout">
            <h4>Mini intuition example <span class="tag">cutoff</span></h4>
            <p>
              If <b>d</b> is very small, only <b>m=1</b> (or even none) can fit across the plates.
              If you increase <b>d</b>, more lobes fit, so more modes become guided. High-order modes live close to cutoff and have strong
              waveguide dispersion.
            </p>
          </div>
        </div>

        <h3>0.4 Group velocity and why it differs by mode</h3>
        <p>
          The pulse envelope travels at the <b>group velocity</b>:
          <span class="mono">v_g = dω/dβ</span>.
          When <span class="mono">β(ω)</span> is not linear in <span class="mono">ω</span>, different frequency components (and in multimode guides,
          different modes) move at different speeds, causing pulse spreading.
        </p>

        <div class="callout keyeq">
          <h4>Group velocity for this waveguide <span class="tag">derived later</span></h4>
          <div class="mono" id="eqVg">
v_g(m) = (c/n) · sqrt( 1 − (ωc,m/ω)^2 )
where ωc,m = (mπc)/(nd)
equivalently, at wavelength λ0:
v_g(m) = (c/n) · sqrt( 1 − (mλ0/(2nd))^2 )
          </div>
          <div class="copyRow">
            <button class="btn" data-copy-target="eqVg">Copy</button>
          </div>
        </div>

        <h3>0.5 What to watch for (common pitfalls)</h3>
        <div class="callout mist">
          <h4>What to watch for <span class="tag">pitfalls</span></h4>
          <ul>
            <li><b>Mixing λ in vacuum vs in medium:</b> here the problem explicitly gives <b>λ0</b> (vacuum wavelength), so use <span class="mono">k = nk0</span>.</li>
            <li><b>Counting m=0 incorrectly:</b> TE/TM standing-wave families typically use <b>m≥1</b>. (A TEM mode discussion is separate and not requested.)</li>
            <li><b>Confusing phase velocity and group velocity:</b> in waveguides, <span class="mono">v_p &gt; c/n</span> while <span class="mono">v_g &lt; c/n</span>.</li>
            <li><b>Cutoff proximity:</b> high-order modes near cutoff have small <span class="mono">v_g</span>, dominating pulse spread.</li>
          </ul>
        </div>
      </article>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <article>
        <h3>1.1 Restate the problem</h3>
        <p>
          Light of vacuum wavelength <b>λ<sub>0</sub>=0.633 μm</b> propagates along a mirror (parallel-plate) waveguide with plate separation
          <b>d=10 μm</b> filled with a medium of refractive index <b>n=1</b>. We must:
        </p>
        <ul>
          <li>Find the <b>number of TE modes</b> and <b>number of TM modes</b> that can propagate.</li>
          <li>Compute the <b>group velocities</b> of the <b>fastest</b> and <b>slowest</b> guided modes.</li>
          <li>Assuming a narrow pulse is carried by <b>all modes</b> over <b>L=1 m</b>, estimate how much the pulse spreads due to differing group velocities.</li>
        </ul>

        <div class="grid2">
          <div class="callout">
            <h4>Given <span class="tag">inputs</span></h4>
            <div class="mono" id="givenBlock">
λ0 = 0.633 μm = 0.633×10^-6 m
d  = 10 μm    = 10×10^-6 m
n  = 1
L  = 1 m
c  = 2.99792458×10^8 m/s
            </div>
            <div class="copyRow">
              <button class="btn" data-copy-target="givenBlock">Copy</button>
            </div>
          </div>

          <div class="callout">
            <h4>Unknowns <span class="tag">targets</span></h4>
            <ul>
              <li><span class="mono">N_TE</span>, <span class="mono">N_TM</span></li>
              <li><span class="mono">v_g,fast</span> and <span class="mono">v_g,slow</span></li>
              <li><span class="mono">Δt</span> pulse spreading over <span class="mono">L=1 m</span></li>
            </ul>
          </div>
        </div>

        <h3>1.2 Relevant physics principles (and why)</h3>
        <ul>
          <li><b>Waveguide mode quantization:</b> boundary conditions at mirrors enforce discrete transverse wavenumbers <span class="mono">kx = mπ/d</span>.</li>
          <li><b>Dispersion relation:</b> the Helmholtz equation in a uniform medium yields <span class="mono">β^2 + kx^2 = k^2</span>.</li>
          <li><b>Group velocity:</b> pulse transport is governed by <span class="mono">v_g = dω/dβ</span>.</li>
        </ul>
        <p>
          We do <b>not</b> need diffraction integrals, Fresnel/Fraunhofer approximations, or material dispersion tables because the problem is
          explicitly about an ideal mirror waveguide and modal (geometric) dispersion.
        </p>

        <div class="callout assump">
          <h4>Assumptions used in the solution <span class="tag">explicit</span></h4>
          <ul>
            <li>Perfect mirrors → lossless guide, sharp cutoffs.</li>
            <li>All guided modes are equally “available” to carry the pulse (worst-case spread estimate).</li>
            <li>Narrowband pulse → group velocity at the carrier wavelength is meaningful.</li>
            <li>Mode families TE and TM share the same cutoff in this ideal planar guide.</li>
          </ul>
        </div>

        <h3>1.3 Possible approaches (compare briefly)</h3>
        <ul>
          <li><b>Approach A: Direct dispersion relation.</b> Use <span class="mono">βm = sqrt(k^2 − (mπ/d)^2)</span>, count modes via cutoff, then compute <span class="mono">v_g=dω/dβ</span>. <b>Best</b>: shortest and most transparent.</li>
          <li><b>Approach B: Use cutoff frequency ω<sub>c,m</sub>.</b> Express everything in terms of <span class="mono">ωc,m = mπc/(nd)</span> and evaluate at ω<sub>0</sub>. Also clean and physical.</li>
          <li><b>Approach C: Ray/angle picture.</b> Treat each mode as a discrete bounce angle and infer group delay from path length. Intuitive, but can hide algebra and is easy to miscount modes.</li>
        </ul>
        <p>
          We will choose <b>Approach B/A</b> (dispersion + cutoff) because it directly yields both the mode count and the group-velocity formula with minimal ambiguity.
        </p>
      </article>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy &amp; Tips (roadmap only)</h2>

      <article>
        <ol>
          <li>
            <b>Compute the in-medium wavenumber.</b><br/>
            Tool: <span class="mono">k = nk0 = n(2π/λ0)</span>.<br/>
            Meaning: sets the total spatial “budget” available for transverse + longitudinal variation.
          </li>
          <li>
            <b>Enforce boundary quantization across the plates.</b><br/>
            Tool: <span class="mono">kx = mπ/d</span> (m = 1,2,… for TE/TM standing-wave families).<br/>
            Meaning: only discrete transverse patterns fit.
          </li>
          <li>
            <b>Write the dispersion relation.</b><br/>
            Tool: <span class="mono">βm = sqrt(k^2 − kx^2)</span>.<br/>
            Meaning: β is the forward propagation constant; if it’s imaginary the mode is evanescent (cutoff).
          </li>
          <li>
            <b>Count propagating modes.</b><br/>
            Tool: require <span class="mono">k &gt; mπ/d</span> ⇒ <span class="mono">m &lt; 2nd/λ0</span>.<br/>
            Meaning: the largest guided index is <span class="mono">m_max = floor(2nd/λ0)</span> (careful near equality).
          </li>
          <li>
            <b>Differentiate to get group velocity.</b><br/>
            Tool: <span class="mono">v_g = dω/dβ</span> using β(ω).<br/>
            Meaning: speed of the pulse envelope for each mode.
          </li>
          <li>
            <b>Identify fastest and slowest modes.</b><br/>
            Tool: monotonic behavior: <span class="mono">v_g</span> decreases as <span class="mono">m</span> increases.<br/>
            Meaning: lowest-order guided mode is fastest, highest-order guided mode is slowest.
          </li>
          <li>
            <b>Compute pulse spread over distance L.</b><br/>
            Tool: <span class="mono">Δt = L(1/v_g,slow − 1/v_g,fast)</span>.<br/>
            Meaning: arrival-time spread between earliest and latest modal components.
          </li>
        </ol>

        <div class="callout mist">
          <h4>Quick tips (avoid mistakes) <span class="tag">practical</span></h4>
          <ul>
            <li>Use <b>vacuum</b> wavelength λ<sub>0</sub> with <span class="mono">k = n(2π/λ0)</span>, not λ in-medium unless you redefine it explicitly.</li>
            <li>When computing <span class="mono">m_max</span>, remember the strict inequality for propagation: <span class="mono">m &lt; 2nd/λ0</span>.</li>
            <li>Expect <span class="mono">v_g</span> to drop sharply for the highest mode near cutoff; it often dominates dispersion.</li>
          </ul>
        </div>
      </article>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

      <article>
        <h3>3.1 Physical intuition before calculating</h3>
        <p>
          The wave inside the guide must “fit” between the mirrors. Each mode uses some of its wavenumber to oscillate across the gap
          (transverse direction). The more transverse oscillation (higher <b>m</b>), the less wavenumber remains for forward propagation,
          so the mode advances more slowly in terms of energy transport (smaller <b>group velocity</b>). Therefore:
        </p>
        <ul>
          <li>Increasing <b>d</b> should allow more TE/TM modes.</li>
          <li>Higher-order modes should have smaller <span class="mono">β</span> and <span class="mono">v_g</span> (and large delays).</li>
        </ul>

        <div class="divider"></div>

        <h3>3.2 Step 1 — Mode quantization and dispersion relation</h3>
        <p>
          Let the plates be at <span class="mono">x=0</span> and <span class="mono">x=d</span>, and propagation be along <span class="mono">z</span>.
          For TE and TM standing-wave families in an ideal parallel-plate waveguide, the transverse dependence is sinusoidal and the
          transverse wavenumber is quantized as:
        </p>
        <div class="callout keyeq">
          <h4>Transverse quantization</h4>
          <div class="mono" id="eqKx">
kx = mπ/d ,   m = 1,2,3,...
          </div>
          <div class="copyRow">
            <button class="btn" data-copy-target="eqKx">Copy</button>
          </div>
        </div>

        <p>
          In the uniform medium, the total wavenumber magnitude is
          <span class="mono">k = nω/c = nk0</span>, where <span class="mono">k0 = 2π/λ0</span>.
          Separation of variables for the Helmholtz equation yields:
        </p>
        <div class="callout keyeq">
          <h4>Waveguide dispersion relation</h4>
          <div class="mono" id="eqBeta">
βm^2 + kx^2 = k^2
⇒ βm(ω) = sqrt( (nω/c)^2 − (mπ/d)^2 )
          </div>
          <div class="copyRow">
            <button class="btn" data-copy-target="eqBeta">Copy</button>
          </div>
        </div>
        <p>
          Explanation: we split the wavevector into a transverse component <span class="mono">kx</span> and a longitudinal component
          <span class="mono">β</span>. Only the longitudinal component drives forward propagation. If the square root becomes negative,
          <span class="mono">β</span> becomes imaginary and the mode cannot propagate (it decays exponentially along <span class="mono">z</span>).
        </p>

        <h3>3.3 Step 2 — Mode count from cutoff</h3>
        <p>
          Propagation requires <span class="mono">βm</span> real:
        </p>
        <div class="callout keyeq">
          <h4>Propagation condition (cutoff)</h4>
          <div class="mono" id="eqCutoff">
(nω/c) > mπ/d
At ω0 = 2πc/λ0:
n(2π/λ0) > mπ/d
⇒ m < 2nd/λ0
          </div>
          <div class="copyRow">
            <button class="btn" data-copy-target="eqCutoff">Copy</button>
          </div>
        </div>

        <p>
          Therefore the largest guided mode index is:
          <span class="mono">m_max = floor(2nd/λ0)</span> (with the understanding that equality corresponds to cutoff, not propagation).
          Plug in the numbers:
        </p>
        <div class="callout">
          <h4>Compute the normalized “mode capacity”</h4>
          <div class="mono" id="calcV">
2nd/λ0 = 2(1)(10 μm)/(0.633 μm) = 20/0.633 ≈ 31.5956
⇒ m_max = 31
          </div>
          <div class="copyRow">
            <button class="btn" data-copy-target="calcV">Copy</button>
          </div>
        </div>

        <p>
          For an ideal mirror waveguide, TE and TM families share the same cutoff indices, so:
        </p>
        <div class="callout final">
          <h4>Mode counts (TE and TM)</h4>
          <div class="mono" id="ansCount">
m_max = 31
N_TE = 31   (m = 1…31)
N_TM = 31   (m = 1…31)
Total guided TE+TM = 62
          </div>
          <div class="copyRow">
            <button class="btn secondary" data-copy-target="ansCount">Copy final</button>
          </div>
          <p class="note">
            Note: A parallel-plate guide can also support a TEM mode under certain conductor interpretations, but the problem asks specifically for TE and TM mode counts, so we report those.
          </p>
        </div>

        <h3>3.4 Step 3 — Group velocity formula</h3>
        <p>
          Start from:
          <span class="mono">β(ω) = sqrt( (nω/c)^2 − (mπ/d)^2 )</span>.
          Differentiate with respect to <span class="mono">ω</span>.
        </p>

        <p class="mono">
          Let A(ω) = (nω/c)^2 − (mπ/d)^2, so β = sqrt(A).<br/>
          Then dβ/dω = (1/(2sqrt(A)))·dA/dω = (1/(2β))·2(n^2 ω/c^2) = (n^2 ω)/(β c^2).
        </p>

        <p>
          Since <span class="mono">v_g = dω/dβ = 1/(dβ/dω)</span>, we get:
        </p>
        <div class="callout keyeq">
          <h4>Group velocity derived</h4>
          <div class="mono" id="eqVgDerive">
dβ/dω = (n^2 ω)/(β c^2)
⇒ v_g = dω/dβ = (β c^2)/(n^2 ω)

Using β/ω = (n/c)·sqrt(1 − (ωc,m/ω)^2),
⇒ v_g(m) = (c/n)·sqrt(1 − (ωc,m/ω)^2)
with ωc,m = (mπc)/(nd).
          </div>
          <div class="copyRow">
            <button class="btn" data-copy-target="eqVgDerive">Copy</button>
          </div>
        </div>

        <p>
          Evaluate at the given vacuum wavelength. Using <span class="mono">ω0 = 2πc/λ0</span>, the ratio becomes:
        </p>
        <div class="callout">
          <h4>Convert cutoff ratio to wavelength form</h4>
          <div class="mono" id="eqRatio">
(ωc,m/ω0) = [ (mπc)/(nd) ] / [ (2πc)/λ0 ]
          = mλ0/(2nd)
⇒ v_g(m) = (c/n)·sqrt(1 − (mλ0/(2nd))^2 )
          </div>
          <div class="copyRow">
            <button class="btn" data-copy-target="eqRatio">Copy</button>
          </div>
        </div>

        <h3>3.5 Step 4 — Fastest and slowest group velocities</h3>
        <p>
          The expression <span class="mono">v_g(m) = (c/n)·sqrt(1 − (m/V)^2)</span> with <span class="mono">V = 2nd/λ0</span> decreases as <span class="mono">m</span> increases.
          Thus:
        </p>
        <ul>
          <li><b>Fastest guided mode:</b> <span class="mono">m=1</span>.</li>
          <li><b>Slowest guided mode:</b> <span class="mono">m=m_max</span> (here 31), the one closest to cutoff.</li>
        </ul>

        <p>
          Compute <span class="mono">V = 2nd/λ0 ≈ 31.5956</span>.
        </p>

        <div class="callout final">
          <h4>Numerical group velocities (at d=10 μm)</h4>
          <div class="mono" id="ansVg">
V = 2nd/λ0 = 31.5956

v_g,fast = v_g(1) = c·sqrt(1 − (1/V)^2)
         ≈ 0.99950 c
         ≈ 2.99642×10^8 m/s

v_g,slow = v_g(31) = c·sqrt(1 − (31/V)^2)
         ≈ 0.19325 c
         ≈ 5.7934×10^7 m/s
          </div>
          <div class="copyRow">
            <button class="btn secondary" data-copy-target="ansVg">Copy final</button>
          </div>
        </div>

        <h3>3.6 Step 5 — Pulse spreading after 1 m</h3>
        <p>
          If a narrow pulse is decomposed into multiple modes, the earliest arriving component is carried by the fastest mode and the latest
          by the slowest. A simple (and common) estimate of the temporal spread is the difference in transit times:
        </p>

        <div class="callout keyeq">
          <h4>Modal-dispersion time spread</h4>
          <div class="mono" id="eqDt">
t(m) = L / v_g(m)
Δt ≈ t_slowest − t_fastest = L(1/v_g,slow − 1/v_g,fast)
          </div>
          <div class="copyRow">
            <button class="btn" data-copy-target="eqDt">Copy</button>
          </div>
        </div>

        <p>
          With <span class="mono">L=1 m</span>, using the values above:
        </p>

        <div class="callout final">
          <h4>Pulse spreading result</h4>
          <div class="mono" id="ansDt">
Δt ≈ 1 m · ( 1/5.7934×10^7  −  1/2.9964×10^8 )
   ≈ 1.392×10^-8 s
   ≈ 13.9 ns

Equivalent pulse-length spread at the output (using v_g,fast as a scale):
Δz ≈ v_g,fast · Δt ≈ 4.17 m
          </div>
          <div class="copyRow">
            <button class="btn secondary" data-copy-target="ansDt">Copy final</button>
          </div>
          <p class="note">
            The “equivalent length” is just a way to visualize how separated the modal packets become; the primary physical result is the <b>time</b> spread.
          </p>
        </div>

        <h3>3.7 Sanity checks</h3>
        <div class="grid3">
          <div class="callout">
            <h4>Units</h4>
            <p>
              In <span class="mono">β = sqrt((nω/c)^2 − (mπ/d)^2)</span>, both terms are <span class="mono">1/m²</span>.
              In <span class="mono">v_g</span>, the result is <span class="mono">m/s</span>. Good.
            </p>
          </div>
          <div class="callout">
            <h4>Limiting cases</h4>
            <p>
              If <span class="mono">d → ∞</span>, then <span class="mono">mλ0/(2nd) → 0</span> and <span class="mono">v_g → c/n</span> (like bulk propagation).
              If <span class="mono">m → m_max</span> near cutoff, the square root approaches 0, so <span class="mono">v_g → 0</span>, giving large delay — consistent.
            </p>
          </div>
          <div class="callout">
            <h4>Physical interpretation</h4>
            <p>
              The highest-order guided mode travels at a much smaller group velocity because most of its wavevector lies transversely
              (it “bounces” at a high angle), so it makes slow forward progress.
            </p>
          </div>
        </div>

        <div class="divider"></div>

        <h3>3.8 Connect to the diagram and plots</h3>
        <p>
          The diagram shows two mirrors separated by <b>d</b> with a standing wave across the gap for the selected <b>m</b>.
          The first plot shows how <b>v<sub>g</sub>/c</b> decreases with <b>m</b> (strongly near cutoff).
          The second plot shows the resulting <b>transit time</b> <span class="mono">t=L/v_g</span>, which grows sharply for high-order modes.
          The pulse spread is essentially the vertical separation between the fastest and slowest points on the transit-time curve.
        </p>
      </article>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

      <article>
        <h3>4.1 Re-interpreting the final formulas</h3>
        <p>
          The group velocity expression
          <span class="mono">v_g(m) = (c/n)·sqrt(1 − (mλ0/(2nd))^2)</span>
          contains a single key dimensionless ratio:
          <span class="mono">mλ0/(2nd)</span>.
        </p>
        <ul>
          <li><b>λ<sub>0</sub> larger</b> → fewer modes and stronger dispersion (because each half-wave “takes more room”).</li>
          <li><b>d larger</b> → more modes, but the highest guided mode becomes less close to cutoff for fixed m; overall you can reduce the worst-case delay for a fixed set of excited modes.</li>
          <li><b>Higher m</b> → slower group velocity, rapidly near cutoff.</li>
        </ul>

        <div class="callout">
          <h4>Why pulse spreading can be huge in multimode guides</h4>
          <p>
            Even if the <b>fastest</b> mode is nearly at <span class="mono">c/n</span>, the <b>slowest</b> guided mode can be a small fraction of that.
            If you excite “all modes,” the tail is dominated by near-cutoff modes. Practical systems often limit excited modes
            (launch conditioning) to reduce dispersion.
          </p>
        </div>

        <h3>4.2 Parameter effects (connect to the interactive plots)</h3>
        <ul>
          <li>Increase <b>d</b> using the slider: <span class="mono">m_max = floor(2nd/λ0)</span> increases stepwise (you’ll see mode count jump by integers).</li>
          <li>As <b>d</b> increases, the curve <span class="mono">v_g(m)</span> shifts upward (for a given m), and the worst-case transit time decreases.</li>
          <li>Near the points where a new mode “appears” (when <span class="mono">2nd/λ0</span> crosses an integer), the newest mode starts extremely close to cutoff and has very small <span class="mono">v_g</span> — a recipe for large spread if excited.</li>
        </ul>

        <h3>4.3 Alternative derivation idea (brief)</h3>
        <p>
          You can derive the same dispersion using a <b>ray-angle picture</b>: each mode corresponds to a discrete bounce angle θ satisfying
          a transverse resonance condition. The longitudinal component is <span class="mono">β = k cosθ</span>, and group delay follows from the
          forward projection of energy flow. This matches the wave result when the boundary quantization is imposed properly.
        </p>

        <h3>4.4 Concept check (self-test)</h3>
        <ul>
          <li><b>Q:</b> Why does <span class="mono">v_g</span> decrease with mode index <span class="mono">m</span>? <b>A:</b> Because higher m requires larger transverse wavenumber, leaving smaller β and reducing forward energy transport.</li>
          <li><b>Q:</b> What happens to the slowest mode as <span class="mono">m</span> approaches cutoff? <b>A:</b> <span class="mono">β→0</span> and <span class="mono">v_g→0</span>, so the transit time grows very large.</li>
          <li><b>Q:</b> Does phase velocity equal group velocity in this guide? <b>A:</b> No; waveguides generally have <span class="mono">v_p &gt; c/n</span> and <span class="mono">v_g &lt; c/n</span>.</li>
          <li><b>Q:</b> If you excite only the lowest few modes, what happens to dispersion? <b>A:</b> It decreases because you avoid the very slow near-cutoff modes.</li>
        </ul>
      </article>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

      <article>
        <div class="vizGrid">
          <figure class="wide">
            <canvas id="cDiagram" width="1100" height="420" aria-label="Waveguide diagram"></canvas>
            <figcaption>
              <b>Diagram:</b> Parallel mirrors separated by <b>d</b>, propagation along <b>z</b>. The curve indicates a transverse standing-wave profile for the selected mode <b>m</b>.
            </figcaption>
          </figure>

          <figure>
            <canvas id="cPlot1" width="820" height="520" aria-label="Group velocity plot"></canvas>
            <figcaption>
              <b>Main plot:</b> Group velocity fraction <b>v<sub>g</sub>/c</b> vs mode index <b>m</b>. High-order modes near cutoff slow down strongly.
            </figcaption>
          </figure>

          <figure>
            <canvas id="cPlot2" width="820" height="520" aria-label="Transit time plot"></canvas>
            <figcaption>
              <b>Secondary plot:</b> Transit time <b>t=L/v<sub>g</sub></b> (ns) vs <b>m</b>. The pulse spread is the difference between the largest and smallest t among excited modes.
            </figcaption>
          </figure>
        </div>

        <div class="callout">
          <h4>How the controls affect the visuals <span class="tag">interactive</span></h4>
          <ul>
            <li><b>d slider:</b> changes plate separation. This updates <b>m<sub>max</sub></b>, the curve shapes, the highlighted fastest/slowest values, and the pulse spread.</li>
            <li><b>m selector:</b> chooses which mode is drawn in the diagram and highlighted on both plots (a dot marker).</li>
          </ul>
          <p class="note">
            All plotted quantities match the symbols used in the text: <span class="mono">d, λ0, n, m, v_g, L</span>.
          </p>
        </div>
      </article>
    </section>

  </div>
</main>

<footer>
  <div class="divider"></div>
  <p>
    Built with vanilla HTML/CSS/JS. Tip: To adapt this page for other problems, change the constants in the JS block (λ0, n, L) or add more sliders.
  </p>
</footer>

<script>
/* -------------------------
   Smooth TOC scrolling
------------------------- */
document.querySelectorAll('[data-jump]').forEach(a=>{
  a.addEventListener('click', (e)=>{
    e.preventDefault();
    const id = a.getAttribute('href');
    const el = document.querySelector(id);
    if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
  });
});

/* -------------------------
   Copy buttons
------------------------- */
async function copyText(txt){
  try{
    await navigator.clipboard.writeText(txt);
    toast('Copied ✔');
  }catch(err){
    // Fallback
    const ta=document.createElement('textarea');
    ta.value=txt; document.body.appendChild(ta);
    ta.select(); document.execCommand('copy');
    document.body.removeChild(ta);
    toast('Copied ✔');
  }
}
function toast(msg){
  let t=document.getElementById('toast');
  if(!t){
    t=document.createElement('div');
    t.id='toast';
    t.style.position='fixed';
    t.style.left='50%';
    t.style.bottom='18px';
    t.style.transform='translateX(-50%)';
    t.style.padding='10px 12px';
    t.style.border='1px solid rgba(255,255,255,.18)';
    t.style.borderRadius='12px';
    t.style.background='rgba(5,10,22,.92)';
    t.style.color='white';
    t.style.fontSize='12px';
    t.style.boxShadow='0 18px 50px rgba(0,0,0,.45)';
    t.style.zIndex='9999';
    t.style.opacity='0';
    t.style.transition='opacity .15s ease';
    document.body.appendChild(t);
  }
  t.textContent=msg;
  t.style.opacity='1';
  clearTimeout(window.__toastTimer);
  window.__toastTimer=setTimeout(()=>{t.style.opacity='0';}, 950);
}
document.querySelectorAll('[data-copy-target]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const id=btn.getAttribute('data-copy-target');
    const el=document.getElementById(id);
    if(!el) return;
    const txt=(el.innerText || el.textContent || '').trim();
    copyText(txt);
  });
});

/* -------------------------
   Physics constants + helpers
------------------------- */
const c = 299792458; // m/s
const lambda0_um = 0.633; // given (μm)
const lambda0 = lambda0_um * 1e-6; // m
const n = 1.0;
const L = 1.0; // m (given for spread)

function fmt(x, digits=3){
  if(!isFinite(x)) return '—';
  return x.toFixed(digits);
}
function fmtSci(x, sig=4){
  if(!isFinite(x)) return '—';
  const ax=Math.abs(x);
  if(ax===0) return '0';
  if(ax>=1e-3 && ax<1e4) return x.toPrecision(sig);
  return x.toExponential(sig-1);
}
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

/* -------------------------
   Mode model (TE/TM families)
   β(ω) = sqrt((nω/c)^2 - (mπ/d)^2)
   vg(m) = (c/n)*sqrt(1 - (mλ0/(2nd))^2)
------------------------- */
function V(d){ // dimensionless 2nd/λ0
  return (2*n*d)/lambda0;
}
function mMax(d){
  const val = V(d);
  // strict inequality m < val; choose floor(val - tiny)
  const eps = 1e-12;
  return Math.max(0, Math.floor(val - eps));
}
function vg(m, d){
  const val = V(d);
  const r = m/val;
  const inside = 1 - r*r;
  if(inside <= 0) return NaN;
  return (c/n) * Math.sqrt(inside);
}
function transitTime(m, d){
  const v = vg(m,d);
  if(!isFinite(v)) return NaN;
  return L / v;
}
function pulseSpread(d){
  const mm = mMax(d);
  if(mm < 1) return {dt:NaN, vfast:NaN, vslow:NaN, mm};
  const vfast = vg(1,d);
  const vslow = vg(mm,d);
  const dt = L*(1/vslow - 1/vfast);
  return {dt, vfast, vslow, mm};
}

/* -------------------------
   Canvas drawing utilities
------------------------- */
function setupHiDPI(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(2, Math.floor(rect.width * dpr));
  const h = Math.max(2, Math.floor((rect.height || rect.width*0.6) * dpr));
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w;
    canvas.height = h;
  }
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  return {ctx, wCSS: rect.width, hCSS: rect.height || rect.width*0.6, dpr};
}

function drawRoundedRect(ctx, x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y, x+w,y+h, rr);
  ctx.arcTo(x+w,y+h, x,y+h, rr);
  ctx.arcTo(x,y+h, x,y, rr);
  ctx.arcTo(x,y, x+w,y, rr);
  ctx.closePath();
}

function drawAxes(ctx, box, xMin, xMax, yMin, yMax, opts){
  const {x,y,w,h} = box;
  const padL = opts.padL ?? 56;
  const padR = opts.padR ?? 14;
  const padT = opts.padT ?? 34;
  const padB = opts.padB ?? 46;
  const plot = {x:x+padL, y:y+padT, w:w-padL-padR, h:h-padT-padB};

  // background
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.12)';
  drawRoundedRect(ctx, x, y, w, h, 16);
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // title
  ctx.fillStyle = 'rgba(233,238,252,0.92)';
  ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText(opts.title ?? '', x+14, y+12);

  // grid + ticks
  const nx = opts.nx ?? 6;
  const ny = opts.ny ?? 6;

  // mapping
  const X = (u)=> plot.x + (u - xMin) * plot.w / (xMax - xMin);
  const Y = (v)=> plot.y + plot.h - (v - yMin) * plot.h / (yMax - yMin);

  // gridlines
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;

  for(let i=0;i<=nx;i++){
    const u = xMin + (xMax-xMin)*i/nx;
    const xx = X(u);
    ctx.beginPath();
    ctx.moveTo(xx, plot.y);
    ctx.lineTo(xx, plot.y+plot.h);
    ctx.stroke();
  }
  for(let j=0;j<=ny;j++){
    const v = yMin + (yMax-yMin)*j/ny;
    const yy = Y(v);
    ctx.beginPath();
    ctx.moveTo(plot.x, yy);
    ctx.lineTo(plot.x+plot.w, yy);
    ctx.stroke();
  }

  // axes lines
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(plot.x, plot.y+plot.h);
  ctx.lineTo(plot.x+plot.w, plot.y+plot.h);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(plot.x, plot.y);
  ctx.lineTo(plot.x, plot.y+plot.h);
  ctx.stroke();

  // ticks + labels
  ctx.fillStyle = 'rgba(185,195,230,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for(let i=0;i<=nx;i++){
    const u = xMin + (xMax-xMin)*i/nx;
    const xx = X(u);
    ctx.beginPath();
    ctx.moveTo(xx, plot.y+plot.h);
    ctx.lineTo(xx, plot.y+plot.h+6);
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.stroke();
    const label = (opts.xTickFmt ? opts.xTickFmt(u) : u.toFixed(0));
    ctx.fillText(label, xx, plot.y+plot.h+10);
  }
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for(let j=0;j<=ny;j++){
    const v = yMin + (yMax-yMin)*j/ny;
    const yy = Y(v);
    ctx.beginPath();
    ctx.moveTo(plot.x-6, yy);
    ctx.lineTo(plot.x, yy);
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.stroke();
    const label = (opts.yTickFmt ? opts.yTickFmt(v) : v.toFixed(2));
    ctx.fillText(label, plot.x-10, yy);
  }

  // axis labels
  ctx.fillStyle = 'rgba(233,238,252,0.86)';
  ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.fillText(opts.xLabel ?? '', plot.x + plot.w/2, y + h - 10);

  ctx.save();
  ctx.translate(x + 16, plot.y + plot.h/2);
  ctx.rotate(-Math.PI/2);
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText(opts.yLabel ?? '', 0, 0);
  ctx.restore();

  ctx.restore();

  return {plot, X, Y};
}

function drawPolyline(ctx, X, Y, xs, ys, strokeStyle){
  ctx.save();
  ctx.strokeStyle = strokeStyle || 'rgba(122,167,255,0.95)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const x = X(xs[i]);
    const y = Y(ys[i]);
    if(i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.restore();
}

function drawPoint(ctx, x, y, style){
  ctx.save();
  ctx.fillStyle = style.fill || 'rgba(125,255,199,0.95)';
  ctx.strokeStyle = style.stroke || 'rgba(0,0,0,0.2)';
  ctx.lineWidth = style.lw ?? 1;
  ctx.beginPath();
  ctx.arc(x, y, style.r ?? 5, 0, Math.PI*2);
  ctx.fill();
  ctx.stroke();
  ctx.restore();
}

function drawLegend(ctx, x, y, items){
  ctx.save();
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  let yy = y;
  items.forEach(it=>{
    ctx.fillStyle = it.color;
    ctx.fillRect(x, yy-6, 12, 12);
    ctx.fillStyle = 'rgba(233,238,252,0.9)';
    ctx.fillText(it.label, x+18, yy);
    yy += 18;
  });
  ctx.restore();
}

/* -------------------------
   Drawing: Diagram
------------------------- */
function drawDiagram(d_um, mSel, mm){
  const canvas = document.getElementById('cDiagram');
  const {ctx, wCSS, hCSS} = setupHiDPI(canvas);
  const W = wCSS, H = hCSS;

  // clear
  ctx.clearRect(0,0,W,H);

  // panel
  ctx.fillStyle = 'rgba(0,0,0,0.12)';
  drawRoundedRect(ctx, 0, 0, W, H, 16);
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // title
  ctx.fillStyle = 'rgba(233,238,252,0.92)';
  ctx.font = '700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText('Mirror waveguide geometry + transverse standing wave', 14, 12);

  // Geometry region
  const gx = 60, gy = 60, gw = W - 110, gh = H - 120;

  // mirrors as horizontal plates (top/bottom)
  const plateT = 10;
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.fillRect(gx, gy, gw, plateT);
  ctx.fillRect(gx, gy + gh - plateT, gw, plateT);

  // gap fill
  ctx.fillStyle = 'rgba(122,167,255,0.06)';
  ctx.fillRect(gx, gy+plateT, gw, gh-2*plateT);

  // axis arrows
  // z to the right
  ctx.strokeStyle = 'rgba(255,255,255,0.55)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(gx+20, gy+gh+22);
  ctx.lineTo(gx+160, gy+gh+22);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(gx+160, gy+gh+22);
  ctx.lineTo(gx+150, gy+gh+16);
  ctx.lineTo(gx+150, gy+gh+28);
  ctx.closePath();
  ctx.fillStyle = 'rgba(255,255,255,0.55)';
  ctx.fill();
  ctx.fillStyle = 'rgba(185,195,230,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillText('z (propagation)', gx+170, gy+gh+16);

  // x axis up
  ctx.strokeStyle = 'rgba(255,255,255,0.55)';
  ctx.beginPath();
  ctx.moveTo(gx-22, gy+gh-20);
  ctx.lineTo(gx-22, gy+gh-140);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(gx-22, gy+gh-140);
  ctx.lineTo(gx-28, gy+gh-130);
  ctx.lineTo(gx-16, gy+gh-130);
  ctx.closePath();
  ctx.fillStyle = 'rgba(255,255,255,0.55)';
  ctx.fill();
  ctx.fillStyle = 'rgba(185,195,230,0.95)';
  ctx.fillText('x', gx-34, gy+gh-156);

  // label mirrors
  ctx.fillStyle = 'rgba(233,238,252,0.82)';
  ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('mirror', gx+10, gy-18);
  ctx.fillText('mirror', gx+10, gy+gh+8);

  // d arrow (vertical)
  const ax = gx + gw - 40;
  const y1 = gy + plateT;
  const y2 = gy + gh - plateT;
  ctx.strokeStyle = 'rgba(125,255,199,0.75)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(ax, y1);
  ctx.lineTo(ax, y2);
  ctx.stroke();
  // arrowheads
  ctx.fillStyle = 'rgba(125,255,199,0.75)';
  ctx.beginPath();
  ctx.moveTo(ax, y1);
  ctx.lineTo(ax-6, y1+10);
  ctx.lineTo(ax+6, y1+10);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(ax, y2);
  ctx.lineTo(ax-6, y2-10);
  ctx.lineTo(ax+6, y2-10);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = 'rgba(233,238,252,0.86)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.textAlign = 'right';
  ctx.fillText(`d = ${d_um.toFixed(2)} μm`, ax-10, (y1+y2)/2 - 6);

  // Standing wave profile across x at some z slice (left side)
  const wx0 = gx + 80;
  const wz0 = gy + plateT;
  const wH  = gh - 2*plateT;
  const wW  = 220;

  // frame
  ctx.strokeStyle = 'rgba(255,255,255,0.16)';
  ctx.lineWidth = 1;
  drawRoundedRect(ctx, wx0, wz0, wW, wH, 14);
  ctx.stroke();

  // plot standing wave: sin(mπ x/d), show lobes; x from 0..d mapped to y
  ctx.save();
  ctx.beginPath();
  drawRoundedRect(ctx, wx0, wz0, wW, wH, 14);
  ctx.clip();

  // center line (zero)
  ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  ctx.beginPath();
  ctx.moveTo(wx0, wz0 + wH/2);
  ctx.lineTo(wx0 + wW, wz0 + wH/2);
  ctx.stroke();

  // curve
  ctx.strokeStyle = 'rgba(122,167,255,0.95)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<=300;i++){
    const u = i/300;        // 0..1 across height
    const x = u;            // normalized x
    const val = Math.sin(mSel*Math.PI*x);
    const xx = wx0 + (0.1 + 0.8*(val+1)/2) * wW; // map to horizontal (amplitude)
    const yy = wz0 + u*wH;
    if(i===0) ctx.moveTo(xx,yy);
    else ctx.lineTo(xx,yy);
  }
  ctx.stroke();

  ctx.restore();

  // labels for wave box
  ctx.fillStyle = 'rgba(233,238,252,0.86)';
  ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.textAlign = 'left';
  ctx.fillText(`Transverse profile ~ sin(mπx/d)`, wx0, wz0-18);
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillStyle = 'rgba(185,195,230,0.95)';
  ctx.fillText(`m = ${mSel} (guided up to m_max=${mm})`, wx0, wz0 + wH + 10);

  // annotation: "guided if m < 2nd/λ0"
  ctx.fillStyle = 'rgba(255,207,90,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.textAlign = 'left';
  ctx.fillText('Guided if: m < 2nd/λ0', gx+340, gy+18);

  // show n and lambda
  ctx.fillStyle = 'rgba(185,195,230,0.95)';
  ctx.fillText(`λ0 = ${lambda0_um.toFixed(3)} μm,  n = ${n.toFixed(2)}`, gx+340, gy+38);

  // simple rays depiction (few slanted lines)
  ctx.strokeStyle = 'rgba(125,255,199,0.22)';
  ctx.lineWidth = 2;
  for(let k=0;k<4;k++){
    const x0 = gx + 350 + k*120;
    const y0 = gy + plateT + 18;
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x0+90, y0 + (gh-2*plateT-36));
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x0, y0 + (gh-2*plateT-36));
    ctx.lineTo(x0+90, y0);
    ctx.stroke();
  }
}

/* -------------------------
   Drawing: Plots
------------------------- */
function drawPlots(d_um, mSel){
  const d = d_um*1e-6;
  const res = pulseSpread(d);
  const mm = res.mm;

  // Prepare data
  const ms = [];
  const vfrac = [];
  const tns = [];
  for(let m=1;m<=mm;m++){
    ms.push(m);
    const v = vg(m,d);
    vfrac.push(v/c);
    tns.push(transitTime(m,d)*1e9); // ns
  }

  // Plot 1: vg/c vs m
  {
    const canvas = document.getElementById('cPlot1');
    const {ctx, wCSS, hCSS} = setupHiDPI(canvas);
    const W=wCSS, H=hCSS;
    ctx.clearRect(0,0,W,H);

    const xMin = 1;
    const xMax = Math.max(2, mm);
    const yMin = 0;
    const yMax = 1.02;

    const {plot, X, Y} = drawAxes(ctx, {x:0,y:0,w:W,h:H}, xMin, xMax, yMin, yMax, {
      title: 'Group velocity vs mode index',
      xLabel: 'mode index m (TE/TM)',
      yLabel: 'v_g / c',
      nx: Math.min(8, Math.max(4, Math.floor(mm/4))),
      ny: 6,
      xTickFmt: (u)=> (Math.round(u)).toString(),
      yTickFmt: (v)=> v.toFixed(2)
    });

    // curve
    drawPolyline(ctx, X, Y, ms, vfrac, 'rgba(122,167,255,0.95)');

    // highlight selected m
    const mH = clamp(mSel, 1, mm);
    const vH = vg(mH, d)/c;
    drawPoint(ctx, X(mH), Y(vH), {r:6, fill:'rgba(125,255,199,0.95)', stroke:'rgba(0,0,0,0.25)', lw:1});

    // fastest and slowest markers
    drawPoint(ctx, X(1), Y(vfrac[0]), {r:5, fill:'rgba(255,207,90,0.95)', stroke:'rgba(0,0,0,0.25)'});
    drawPoint(ctx, X(mm), Y(vfrac[vfrac.length-1]), {r:5, fill:'rgba(255,107,139,0.95)', stroke:'rgba(0,0,0,0.25)'});

    // legend
    drawLegend(ctx, plot.x + 10, plot.y + 10, [
      {color:'rgba(122,167,255,0.95)', label:'v_g(m) curve'},
      {color:'rgba(255,207,90,0.95)', label:'fastest (m=1)'},
      {color:'rgba(255,107,139,0.95)', label:`slowest (m=${mm})`},
      {color:'rgba(125,255,199,0.95)', label:`selected (m=${mH})`}
    ]);

    // annotation
    ctx.fillStyle = 'rgba(185,195,230,0.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'bottom';
    ctx.fillText(`d=${d_um.toFixed(2)} μm,  m_max=${mm}`, plot.x, plot.y + plot.h - 8);
  }

  // Plot 2: transit time (ns) vs m
  {
    const canvas = document.getElementById('cPlot2');
    const {ctx, wCSS, hCSS} = setupHiDPI(canvas);
    const W=wCSS, H=hCSS;
    ctx.clearRect(0,0,W,H);

    const xMin = 1;
    const xMax = Math.max(2, mm);
    const tMin = Math.min(...tns);
    const tMax = Math.max(...tns);
    const pad = 0.06*(tMax - tMin || 1);
    const yMin = Math.max(0, tMin - pad);
    const yMax = tMax + pad;

    const {plot, X, Y} = drawAxes(ctx, {x:0,y:0,w:W,h:H}, xMin, xMax, yMin, yMax, {
      title: 'Transit time vs mode index (L=1 m)',
      xLabel: 'mode index m (TE/TM)',
      yLabel: 't = L / v_g  (ns)',
      nx: Math.min(8, Math.max(4, Math.floor(mm/4))),
      ny: 6,
      xTickFmt: (u)=> (Math.round(u)).toString(),
      yTickFmt: (v)=> v.toFixed(1)
    });

    drawPolyline(ctx, X, Y, ms, tns, 'rgba(125,255,199,0.92)');

    // highlight selected m
    const mH = clamp(mSel, 1, mm);
    const tH = transitTime(mH, d)*1e9;
    drawPoint(ctx, X(mH), Y(tH), {r:6, fill:'rgba(122,167,255,0.95)', stroke:'rgba(0,0,0,0.25)', lw:1});

    // fastest and slowest markers
    drawPoint(ctx, X(1), Y(tns[0]), {r:5, fill:'rgba(255,207,90,0.95)', stroke:'rgba(0,0,0,0.25)'});
    drawPoint(ctx, X(mm), Y(tns[tns.length-1]), {r:5, fill:'rgba(255,107,139,0.95)', stroke:'rgba(0,0,0,0.25)'});

    // indicate delta t as bracket on right side
    const xB = plot.x + plot.w - 6;
    const yFast = Y(tns[0]);
    const ySlow = Y(tns[tns.length-1]);
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(xB, yFast);
    ctx.lineTo(xB, ySlow);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(xB-8, yFast);
    ctx.lineTo(xB+8, yFast);
    ctx.moveTo(xB-8, ySlow);
    ctx.lineTo(xB+8, ySlow);
    ctx.stroke();

    const dt = (tns[tns.length-1] - tns[0]);
    ctx.fillStyle = 'rgba(233,238,252,0.92)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    ctx.fillText(`Δt ≈ ${dt.toFixed(2)} ns`, xB-12, (yFast+ySlow)/2);

    drawLegend(ctx, plot.x + 10, plot.y + 10, [
      {color:'rgba(125,255,199,0.92)', label:'t(m) = L/v_g(m)'},
      {color:'rgba(255,207,90,0.95)', label:'fastest (m=1)'},
      {color:'rgba(255,107,139,0.95)', label:`slowest (m=${mm})`},
      {color:'rgba(122,167,255,0.95)', label:`selected (m=${mH})`}
    ]);
  }
}

/* -------------------------
   UI update
------------------------- */
const dSlider = document.getElementById('dSlider');
const dRead = document.getElementById('dRead');
const mSelect = document.getElementById('mSelect');

function refreshModeSelect(mm, keep){
  mSelect.innerHTML = '';
  if(mm < 1){
    const opt = document.createElement('option');
    opt.value = '1';
    opt.textContent = 'No guided TE/TM modes (increase d)';
    mSelect.appendChild(opt);
    mSelect.disabled = true;
    return;
  }
  mSelect.disabled = false;
  for(let m=1;m<=mm;m++){
    const opt = document.createElement('option');
    opt.value = String(m);
    opt.textContent = `m = ${m}`;
    mSelect.appendChild(opt);
  }
  const want = clamp(keep ?? 1, 1, mm);
  mSelect.value = String(want);
}

function updateKPIs(d_um){
  const d = d_um*1e-6;
  const res = pulseSpread(d);
  const mm = res.mm;
  const N_TE = mm;
  const N_TM = mm;

  document.getElementById('kpiTE').textContent = (mm>=1? String(N_TE): '0');
  document.getElementById('kpiTM').textContent = (mm>=1? String(N_TM): '0');
  document.getElementById('kpiVFast').textContent = (mm>=1? `${(res.vfast/c).toFixed(4)} c` : '—');
  document.getElementById('kpiDt').textContent = (mm>=1? `${(res.dt*1e9).toFixed(2)} ns` : '—');
}

function updateAll(){
  const d_um = parseFloat(dSlider.value);
  dRead.textContent = d_um.toFixed(2);

  const d = d_um*1e-6;
  const mm = mMax(d);
  const keep = parseInt(mSelect.value || '1', 10);
  refreshModeSelect(mm, keep);

  const mSel = parseInt(mSelect.value || '1', 10);

  updateKPIs(d_um);
  drawDiagram(d_um, mSel, mm);
  drawPlots(d_um, mSel);

  // Also update the static "final answer" blocks numerically? Keep as given-problem defaults (d=10 μm).
  // We intentionally do not rewrite the text blocks, but the KPIs + plots give the live results.
}

dSlider.addEventListener('input', updateAll);
mSelect.addEventListener('change', updateAll);
window.addEventListener('resize', ()=>{ updateAll(); });

// init
updateAll();
</script>

</body>
</html>
