<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fraunhofer Diffraction from a Diffraction Grating (Infinitesimal Slits)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#101a33;
      --card2:#0f1730;
      --text:#e8ecff;
      --muted:#b8c2ff;
      --faint:#7f8cff;
      --accent:#7cf0ff;
      --accent2:#b18cff;
      --ok:#79ffa8;
      --warn:#ffd479;
      --danger:#ff7aa2;
      --line:rgba(255,255,255,.12);
      --shadow: 0 18px 50px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 20% 10%, rgba(124,240,255,.12), transparent 60%),
        radial-gradient(1000px 600px at 90% 20%, rgba(177,140,255,.10), transparent 65%),
        linear-gradient(180deg, #070a14, var(--bg));
      line-height:1.55;
    }

    header{
      padding:28px 18px 18px;
      max-width:1200px;
      margin:0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap:18px;
      align-items:stretch;
    }
    @media (max-width: 920px){
      .hero{grid-template-columns:1fr}
    }

    h1{
      margin:0 0 10px 0;
      font-size: clamp(1.35rem, 2.2vw, 2rem);
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      margin:0;
      max-width:75ch;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
    }
    .card.pad{ padding:16px 16px 14px; }

    .quick ul{
      margin:10px 0 0 18px;
      padding:0;
      color:var(--muted);
    }
    .quick li{ margin:6px 0; }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      color:var(--muted);
      font-size:.9rem;
    }
    .pill b{ color:var(--text); font-weight:650; }

    main{
      max-width:1200px;
      margin:0 auto;
      padding: 0 18px 46px;
      display:grid;
      grid-template-columns: 280px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
    }

    nav.toc{
      position:sticky;
      top:14px;
      align-self:start;
      padding:14px;
    }
    nav.toc h2{
      margin:0 0 10px 0;
      font-size:1rem;
      color:var(--text);
      letter-spacing:.2px;
    }
    .toc a{
      display:block;
      padding:8px 10px;
      margin:6px 0;
      border-radius:12px;
      text-decoration:none;
      color:var(--muted);
      border:1px solid transparent;
      transition: transform .18s ease, background .18s ease, border-color .18s ease;
    }
    .toc a:hover{
      background: rgba(124,240,255,.08);
      border-color: rgba(124,240,255,.18);
      transform: translateY(-1px);
      color:var(--text);
    }

    section{
      scroll-margin-top: 18px;
    }
    .content{
      display:flex;
      flex-direction:column;
      gap:18px;
    }

    h2{
      margin:0 0 8px 0;
      font-size:1.25rem;
      letter-spacing:.2px;
    }
    h3{
      margin:16px 0 6px;
      font-size:1.05rem;
      color:var(--text);
    }
    p{ margin:8px 0; color:var(--muted); }
    .small{ font-size:.93rem; color:var(--muted); }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:16px;
    }
    @media (max-width: 920px){
      .grid2{grid-template-columns:1fr}
    }

    .callout{
      background: linear-gradient(180deg, rgba(124,240,255,.08), rgba(124,240,255,.03));
      border:1px solid rgba(124,240,255,.2);
      border-radius: var(--radius);
      padding:14px;
    }
    .callout b{ color:var(--text); }
    .warn{
      background: linear-gradient(180deg, rgba(255,212,121,.11), rgba(255,212,121,.03));
      border-color: rgba(255,212,121,.22);
    }

    .eq{
      border-radius: 16px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.22);
      padding: 12px 12px 10px;
      position: relative;
      overflow:hidden;
    }
    .eq .label{
      font-size:.82rem;
      color:var(--faint);
      margin-bottom:6px;
      letter-spacing:.2px;
    }
    pre, code{ font-family: var(--mono); }
    pre{
      margin:0;
      white-space:pre-wrap;
      word-break:break-word;
      color: var(--text);
      font-size:.95rem;
      line-height:1.45;
    }
    .copyBtn{
      position:absolute;
      top:10px;
      right:10px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 7px 10px;
      cursor:pointer;
      font-size:.88rem;
      transition: transform .18s ease, background .18s ease, border-color .18s ease;
    }
    .copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(124,240,255,.10);
      border-color: rgba(124,240,255,.22);
    }
    .copyNote{
      position:absolute;
      top:44px;
      right:10px;
      font-size:.8rem;
      color:var(--ok);
      opacity:0;
      transform: translateY(-6px);
      transition: opacity .2s ease, transform .2s ease;
      pointer-events:none;
    }
    .copyNote.show{ opacity:1; transform: translateY(0); }

    figure{
      margin:0;
      padding:12px;
      border-radius: var(--radius);
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
    }
    figcaption{
      margin-top:10px;
      color:var(--muted);
      font-size:.92rem;
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    @media (max-width: 920px){
      .controls{grid-template-columns:1fr}
    }
    .control{
      border-radius: 16px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      padding:10px 10px 8px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:.92rem;
      color:var(--muted);
      margin-bottom:8px;
    }
    .control input[type="range"]{ width:100%; }
    .val{
      font-family:var(--mono);
      color:var(--text);
      font-weight:650;
    }

    .badgeRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:10px;
    }

    .hr{
      height:1px;
      background: var(--line);
      margin: 10px 0;
    }

    .boxedFinal{
      border-radius: var(--radius);
      border: 1px solid rgba(121,255,168,.25);
      background: linear-gradient(180deg, rgba(121,255,168,.10), rgba(121,255,168,.03));
      padding: 14px;
    }
    .boxedFinal h3{ margin-top:0; }
    .boxedFinal .eq{ border-color: rgba(121,255,168,.22); }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding: 0 18px 30px;
      color: var(--muted);
      font-size:.92rem;
      opacity:.95;
    }

    /* Print-friendly */
    @media print{
      body{ background:#fff; color:#000; }
      .card, figure, .eq, .callout, .boxedFinal{ box-shadow:none; background:#fff; border-color:#bbb; }
      nav.toc{ display:none; }
      .copyBtn, .copyNote{ display:none !important; }
      p, .small, .subtitle, li{ color:#111; }
      header, main, footer{ max-width: 900px; }
    }
  </style>
</head>

<body>
<header>
  <div class="hero">
    <div class="card pad">
      <div class="pill"><span aria-hidden="true">üî¨</span><b>Topic:</b> Fraunhofer diffraction / grating</div>
      <h1>Fraunhofer Diffraction from a Diffraction Grating (M = 2L + 1 infinitesimal slits)</h1>
      <p class="subtitle">
        We derive the far-field (Fraunhofer) diffraction pattern produced by a set of equally spaced, infinitesimally narrow slits,
        and then sketch/visualize the intensity as a function of observation angle
        <span class="pill" style="margin-left:8px;"><b>Œ∏</b> = x/d</span>.
      </p>
      <div class="hr"></div>
      <div class="quick">
        <h2 style="margin:0 0 6px 0; font-size:1.05rem;">Quick Summary</h2>
        <ul>
          <li>The aperture is a sum of delta-functions: <code>p(x) = Œ£ Œ¥(x - m a)</code> for <code>m = -L‚Ä¶L</code> (so <code>M = 2L+1</code> slits).</li>
          <li>Fraunhofer field is (up to a constant) the Fourier transform of <code>p(x)</code>, giving a geometric sum of phase factors.</li>
          <li>Let <code>Œ≤ = (k a / 2) sinŒ∏</code> with <code>k = 2œÄ/Œª</code>. Then
            <code>I(Œ∏) ‚àù [ sin(MŒ≤) / sin(Œ≤) ]¬≤</code> (no single-slit envelope since slits are infinitesimal).</li>
          <li>Principal maxima occur at <code>sinŒ∏ = n Œª / a</code> (integer n), with peak height ‚àù <code>M¬≤</code> and width ‚àù <code>1/M</code>.</li>
          <li>In this problem <code>a = 10Œª</code>, so maxima are at <code>sinŒ∏ = n/10</code> for <code>n = -10‚Ä¶10</code>.</li>
        </ul>
      </div>
    </div>

    <div class="card pad">
      <h2 style="margin-top:0">Interactive Visuals</h2>
      <p class="small" style="margin-top:0">
        Use the sliders to change <code>L</code> (thus <code>M = 2L+1</code>) and the spacing ratio <code>a/Œª</code>.
        All canvases update live.
      </p>
      <div class="controls" aria-label="Interactive controls">
        <div class="control">
          <label for="Lslider">
            <span>Half-count <b>L</b></span>
            <span class="val" id="Lval">5</span>
          </label>
          <input id="Lslider" type="range" min="1" max="40" step="1" value="5" />
          <div class="small">Total slits: <span class="val" id="Mval">11</span></div>
        </div>
        <div class="control">
          <label for="aslider">
            <span>Spacing ratio <b>a/Œª</b></span>
            <span class="val" id="aval">10.0</span>
          </label>
          <input id="aslider" type="range" min="2" max="30" step="0.1" value="10" />
          <div class="small">Orders within |sinŒ∏|‚â§1: about <span class="val" id="ordersVal">¬±10</span></div>
        </div>
        <div class="control">
          <label for="thetaSpan">
            <span>Angle span (degrees)</span>
            <span class="val" id="spanVal">90</span>
          </label>
          <input id="thetaSpan" type="range" min="20" max="90" step="1" value="90" />
          <div class="small">Plots show Œ∏ ‚àà [‚àíspan, +span]</div>
        </div>
      </div>

      <div class="badgeRow" aria-label="Current parameters">
        <span class="pill"><b>Œª</b> (example) = <span class="val" id="lamVal">632.8 nm</span></span>
        <span class="pill"><b>a</b> = <span class="val" id="aAbsVal">10.0 Œª</span></span>
        <span class="pill"><b>k</b> = 2œÄ/Œª</span>
      </div>
    </div>
  </div>
</header>

<main>
  <nav class="toc card" aria-label="Table of contents">
    <h2>Table of Contents</h2>
    <a href="#viz" data-scroll>Visualizations</a>
    <a href="#part1" data-scroll>PART 1 ‚Äî Problem Analysis</a>
    <a href="#part2" data-scroll>PART 2 ‚Äî Strategy & Tips</a>
    <a href="#part3" data-scroll>PART 3 ‚Äî Full Solution</a>
    <a href="#checks" data-scroll>Sanity Checks</a>
    <a href="#sketch" data-scroll>How to Sketch the Pattern</a>
  </nav>

  <div class="content">
    <section id="viz" class="card pad">
      <h2>Visualizations (live, canvas-based)</h2>
      <div class="grid2">
        <figure>
          <canvas id="diagram" style="width:100%; height:280px; display:block; border-radius:14px;"></canvas>
          <figcaption>
            <b>Diagram:</b> A 1D diffraction grating (slits at <code>x = m a</code>) illuminated by a plane wave.
            The observation point is at distance <code>d</code> and angle <code>Œ∏ ‚âà x/d</code>.
          </figcaption>
        </figure>

        <figure>
          <canvas id="mainPlot" style="width:100%; height:280px; display:block; border-radius:14px;"></canvas>
          <figcaption>
            <b>Main plot:</b> Normalized intensity <code>I(Œ∏)/I_max</code> vs angle <code>Œ∏</code> (degrees),
            using <code>I(Œ∏) ‚àù [sin(MŒ≤)/sinŒ≤]¬≤</code>.
          </figcaption>
        </figure>
      </div>

      <div style="height:14px"></div>

      <div class="grid2">
        <figure>
          <canvas id="secondaryPlot" style="width:100%; height:280px; display:block; border-radius:14px;"></canvas>
          <figcaption>
            <b>Secondary plot:</b> Allowed principal maxima orders <code>n</code> and their locations <code>sinŒ∏_n = n Œª / a</code>.
            (You see how changing <code>a/Œª</code> changes how many orders fit within <code>|sinŒ∏|‚â§1</code>.)
          </figcaption>
        </figure>

        <figure>
          <canvas id="zoomPlot" style="width:100%; height:280px; display:block; border-radius:14px;"></canvas>
          <figcaption>
            <b>Zoom plot:</b> Central region (small angles) to show how increasing <code>M</code> narrows the main peak and sharpens fringes.
          </figcaption>
        </figure>
      </div>
    </section>

    <section id="part1" class="card pad">
      <h2>PART 1 ‚Äî Problem Analysis (no solving yet)</h2>

      <h3>1) Restate the problem</h3>
      <p>
        We have a 1D aperture consisting of <code>M = 2L+1</code> parallel slits of <i>infinitesimal width</i>,
        equally spaced by a distance <code>a</code>. The aperture transmission is modeled as
        <code>p(x) = Œ£ Œ¥(x - m a)</code> for <code>m = -L,‚Ä¶,L</code>.
        We must derive the Fraunhofer (far-field) diffraction pattern, i.e. the field (and intensity) as a function of observation angle <code>Œ∏</code>.
        Then we must sketch the pattern as a function of <code>Œ∏ = x/d</code> (with <code>d</code> the screen distance).
      </p>

      <div class="grid2">
        <div class="callout">
          <b>Given</b>
          <ul style="margin:8px 0 0 18px; color:var(--muted);">
            <li>Number of slits: <code>M = 2L + 1</code></li>
            <li>Slit spacing: <code>a = 10Œª</code></li>
            <li>Aperture: <code>p(x) = Œ£<sub>m=-L</sub><sup>L</sup> Œ¥(x - m a)</code></li>
            <li>Observation angle relation: <code>Œ∏ = x/d</code> (small-angle screen geometry)</li>
          </ul>
        </div>
        <div class="callout">
          <b>Unknowns / What to find</b>
          <ul style="margin:8px 0 0 18px; color:var(--muted);">
            <li>Fraunhofer field amplitude <code>U(Œ∏)</code> (up to an overall constant factor)</li>
            <li>Intensity pattern <code>I(Œ∏) ‚àù |U(Œ∏)|¬≤</code></li>
            <li>Key features for sketching: positions of maxima/minima, scaling with <code>M</code>, dependence on <code>a/Œª</code></li>
          </ul>
        </div>
      </div>

      <h3>2) Relevant physical principles and why they apply</h3>
      <p>
        In the Fraunhofer regime (far field), diffraction is governed by the Fourier transform relationship:
        the angular spectrum of the transmitted field is proportional to the Fourier transform of the aperture function.
        Here the aperture is a sum of delta-functions, so its Fourier transform becomes a finite sum of complex exponentials,
        i.e. a geometric series. This directly produces the standard multi-slit (grating) interference factor.
      </p>

      <h3>3) Possible approaches</h3>
      <div class="grid2">
        <div class="callout">
          <b>Approach A: Fourier transform of the aperture</b>
          <p class="small">
            Use Fraunhofer diffraction: <code>U(Œ∏) ‚àù ‚à´ p(x) e^{i k x sinŒ∏} dx</code>.
            For delta-functions, the integral collapses to a sum.
            Cleanest and most direct here.
          </p>
        </div>
        <div class="callout">
          <b>Approach B: Phasor sum (path difference)</b>
          <p class="small">
            Add <code>M</code> equal-amplitude phasors with phase step
            <code>ŒîœÜ = k a sinŒ∏</code>, then square magnitude for intensity.
            Equivalent to A; emphasizes interference intuition.
          </p>
        </div>
      </div>
      <div class="callout warn" style="margin-top:12px;">
        <b>Approach C: Start from general grating with finite slit width</b>
        <p class="small">
          Usually one writes intensity = (single-slit envelope) √ó (multi-slit interference factor).
          But here slit width is infinitesimal, so the envelope is constant, and this approach adds unnecessary steps.
        </p>
      </div>

      <h3>Chosen approach</h3>
      <p>
        We will use <b>Approach A (Fourier transform / Fraunhofer integral)</b>, because the given aperture is already expressed as delta-functions.
        This turns the diffraction integral into an exact finite sum that can be evaluated analytically.
      </p>
    </section>

    <section id="part2" class="card pad">
      <h2>PART 2 ‚Äî Strategy & Tips (roadmap only)</h2>

      <h3>Roadmap (no algebra yet)</h3>
      <ol style="margin:8px 0 0 20px; color:var(--muted);">
        <li><b>Set up Fraunhofer field formula</b> ‚Äî goal: express far-field amplitude in terms of the aperture; tool: Fraunhofer diffraction integral.</li>
        <li><b>Insert the aperture</b> ‚Äî goal: use the delta-function property to convert the integral into a discrete sum; tool: <code>‚à´ Œ¥(x-x0) f(x) dx = f(x0)</code>.</li>
        <li><b>Recognize a geometric series</b> ‚Äî goal: evaluate the finite sum of exponentials; tool: closed-form sum for equally spaced phases.</li>
        <li><b>Compute intensity</b> ‚Äî goal: obtain <code>I(Œ∏) ‚àù |U(Œ∏)|¬≤</code>; tool: magnitude squared.</li>
        <li><b>Identify maxima/minima conditions</b> ‚Äî goal: where the numerator is maximal and denominator vanishes; tool: phase-step analysis.</li>
        <li><b>Specialize to a = 10Œª</b> ‚Äî goal: locate grating orders and describe the sketch; tool: <code>sinŒ∏ = nŒª/a</code>.</li>
        <li><b>Relate to screen coordinate</b> ‚Äî goal: connect <code>Œ∏</code> to <code>x</code> using small-angle geometry; tool: <code>Œ∏ ‚âà x/d</code>.</li>
      </ol>

      <h3>Common mistakes & quick tips</h3>
      <div class="grid2">
        <div class="callout warn">
          <b>Mistake:</b> forgetting the <code>sinŒ∏</code> (using Œ∏ instead).<br/>
          <span class="small">Tip: The exact Fraunhofer phase is <code>k x sinŒ∏</code>. For small angles, <code>sinŒ∏ ‚âà Œ∏</code>, but keep <code>sinŒ∏</code> in the symbolic result.</span>
        </div>
        <div class="callout warn">
          <b>Mistake:</b> dividing by zero at <code>Œ∏ = 0</code> or principal maxima.<br/>
          <span class="small">Tip: Use the limit <code>sin(MŒ≤)/sinŒ≤ ‚Üí M</code> as <code>Œ≤ ‚Üí 0</code>.</span>
        </div>
      </div>
      <div class="callout">
        <b>Tip:</b> Since the slit width is infinitesimal, there is <b>no single-slit envelope</b>‚Äîthe entire structure comes from interference of the discrete slit positions.
      </div>
    </section>

    <section id="part3" class="card pad">
      <h2>PART 3 ‚Äî Full Solution</h2>

      <h3>Physical intuition first</h3>
      <p>
        Each slit emits the same far-field wave (same amplitude), but with a relative phase determined by the path difference to the observation direction.
        For equally spaced slits, the phase increases by a constant step from slit to slit. The total field is therefore a sum of equally spaced phasors.
        When the phase step corresponds to an integer number of wavelengths, all phasors line up and produce a sharp principal maximum.
        As the number of slits <code>M</code> increases, these maxima become taller (‚àù <code>M¬≤</code>) and narrower (‚àù <code>1/M</code>).
      </p>

      <h3>Step-by-step derivation (Fraunhofer / Fourier transform)</h3>
      <p>
        Consider a monochromatic plane wave of wavelength <code>Œª</code> incident normally on a 1D aperture with transmission <code>p(x)</code>.
        In the Fraunhofer region, the complex field amplitude as a function of observation angle <code>Œ∏</code> is proportional to the Fourier transform of the aperture:
      </p>

      <div class="eq" data-copy="eq1">
        <div class="label">Key Fraunhofer relation (1D)</div>
        <button class="copyBtn" data-copy-btn="eq1">Copy</button>
        <div class="copyNote" data-copy-note="eq1">Copied!</div>
        <pre id="eq1">U(Œ∏) ‚àù ‚à´_{-‚àû}^{‚àû} p(x) ¬∑ exp(i k x sinŒ∏) dx,   where k = 2œÄ/Œª</pre>
      </div>

      <p>
        The given aperture (infinitesimal slits at <code>x = m a</code>) is:
      </p>

      <div class="eq" data-copy="eq2">
        <div class="label">Aperture model</div>
        <button class="copyBtn" data-copy-btn="eq2">Copy</button>
        <div class="copyNote" data-copy-note="eq2">Copied!</div>
        <pre id="eq2">p(x) = Œ£_{m=-L}^{L} Œ¥(x - m a),   with M = 2L + 1</pre>
      </div>

      <p>
        Insert this into the Fraunhofer integral and use the delta-function sampling property
        <code>‚à´ Œ¥(x-x0) f(x) dx = f(x0)</code>:
      </p>

      <div class="eq" data-copy="eq3">
        <div class="label">Integral collapses to a sum</div>
        <button class="copyBtn" data-copy-btn="eq3">Copy</button>
        <div class="copyNote" data-copy-note="eq3">Copied!</div>
        <pre id="eq3">U(Œ∏) ‚àù Œ£_{m=-L}^{L} exp(i k (m a) sinŒ∏)</pre>
      </div>

      <p>
        Define the phase step between adjacent slits:
      </p>

      <div class="eq" data-copy="eq4">
        <div class="label">Phase increment per slit</div>
        <button class="copyBtn" data-copy-btn="eq4">Copy</button>
        <div class="copyNote" data-copy-note="eq4">Copied!</div>
        <pre id="eq4">ŒîœÜ = k a sinŒ∏</pre>
      </div>

      <p>
        Then the field is a finite sum of exponentials with equally spaced phases.
        A standard way to evaluate it is to rewrite the symmetric sum using a centered phase variable.
        Let:
      </p>

      <div class="eq" data-copy="eq5">
        <div class="label">Convenient parameter Œ≤</div>
        <button class="copyBtn" data-copy-btn="eq5">Copy</button>
        <div class="copyNote" data-copy-note="eq5">Copied!</div>
        <pre id="eq5">Œ≤ = (ŒîœÜ)/2 = (k a / 2) sinŒ∏ = (œÄ a / Œª) sinŒ∏</pre>
      </div>

      <p>
        The sum can be expressed in closed form (Dirichlet kernel identity):
      </p>

      <div class="eq" data-copy="eq6">
        <div class="label">Closed-form field amplitude</div>
        <button class="copyBtn" data-copy-btn="eq6">Copy</button>
        <div class="copyNote" data-copy-note="eq6">Copied!</div>
        <pre id="eq6">U(Œ∏) ‚àù exp(i¬∑phase) ¬∑ [ sin(MŒ≤) / sin(Œ≤) ]</pre>
      </div>

      <p>
        The overall phase factor <code>exp(i¬∑phase)</code> does not affect intensity, so we can ignore it when plotting or sketching.
        Therefore the intensity pattern is:
      </p>

      <div class="boxedFinal">
        <h3>Final Result (Intensity)</h3>
        <div class="eq" data-copy="finalEq">
          <div class="label">Fraunhofer diffraction pattern for M infinitesimal slits</div>
          <button class="copyBtn" data-copy-btn="finalEq">Copy</button>
          <div class="copyNote" data-copy-note="finalEq">Copied!</div>
          <pre id="finalEq">I(Œ∏) ‚àù |U(Œ∏)|¬≤ = [ sin(MŒ≤) / sin(Œ≤) ]¬≤,
where Œ≤ = (k a / 2) sinŒ∏ = (œÄ a / Œª) sinŒ∏,  and M = 2L + 1.</pre>
        </div>
        <p class="small" style="margin-bottom:0">
          If you want a normalized form for plotting: <code>I_norm(Œ∏) = (1/M¬≤)[sin(MŒ≤)/sinŒ≤]¬≤</code> so that the peak value is 1.
        </p>
      </div>

      <h3>Maxima and minima (features needed for a sketch)</h3>
      <p>
        Principal maxima occur when all slit contributions add in phase, i.e. when the phase step is an integer multiple of <code>2œÄ</code>:
      </p>

      <div class="eq" data-copy="eq7">
        <div class="label">Principal maxima condition</div>
        <button class="copyBtn" data-copy-btn="eq7">Copy</button>
        <div class="copyNote" data-copy-note="eq7">Copied!</div>
        <pre id="eq7">ŒîœÜ = k a sinŒ∏ = 2œÄ n  ‚áí  a sinŒ∏ = n Œª  ‚áí  sinŒ∏_n = n Œª / a   (n ‚àà ‚Ñ§)</pre>
      </div>

      <p>
        At these angles, the limit gives <code>U(Œ∏_n) ‚àù M</code>, so the peak intensity scales as <code>I(Œ∏_n) ‚àù M¬≤</code>.
        Between principal maxima there are <code>M‚àí1</code> minima (excluding endpoints) where the numerator vanishes:
      </p>

      <div class="eq" data-copy="eq8">
        <div class="label">Minima (zeros of numerator, excluding principal maxima)</div>
        <button class="copyBtn" data-copy-btn="eq8">Copy</button>
        <div class="copyNote" data-copy-note="eq8">Copied!</div>
        <pre id="eq8">sin(MŒ≤) = 0  ‚áí  MŒ≤ = qœÄ  ‚áí  Œ≤ = qœÄ/M,
with q integer, but exclude values where sin(Œ≤)=0 (those are principal maxima).</pre>
      </div>

      <p>
        Finally, the problem asks to sketch as a function of <code>Œ∏ = x/d</code>.
        For small angles on a distant screen, <code>Œ∏ ‚âà tanŒ∏ ‚âà x/d</code>, and also <code>sinŒ∏ ‚âà Œ∏ ‚âà x/d</code>.
        So on the screen the principal maxima are located at:
      </p>

      <div class="eq" data-copy="eq9">
        <div class="label">Screen positions (small-angle approximation)</div>
        <button class="copyBtn" data-copy-btn="eq9">Copy</button>
        <div class="copyNote" data-copy-note="eq9">Copied!</div>
        <pre id="eq9">x_n ‚âà d Œ∏_n ‚âà d sinŒ∏_n = d (n Œª / a)</pre>
      </div>
    </section>

    <section id="checks" class="card pad">
      <h2>Sanity Checks</h2>

      <h3>1) Units</h3>
      <p>
        <code>k = 2œÄ/Œª</code> has units of 1/length, <code>a</code> has units of length, so <code>k a</code> is dimensionless.
        Therefore <code>Œ≤ = (k a / 2) sinŒ∏</code> is dimensionless, and the sine ratio is dimensionless, as required for an intensity ratio.
      </p>

      <h3>2) Limiting cases</h3>
      <div class="grid2">
        <div class="callout">
          <b>Single slit limit (M = 1)</b>
          <p class="small">
            If <code>M=1</code> (i.e. <code>L=0</code>), then <code>sin(MŒ≤)/sinŒ≤ = sinŒ≤/sinŒ≤ = 1</code>,
            so <code>I(Œ∏)</code> is constant. That matches an infinitesimal slit (delta aperture): no angular envelope.
          </p>
        </div>
        <div class="callout">
          <b>Many slits (large M)</b>
          <p class="small">
            Peaks become very sharp and tall: <code>I_peak ‚àù M¬≤</code>.
            The peak angular width shrinks roughly like <code>1/M</code>, which you can see in the zoom plot.
          </p>
        </div>
      </div>

      <h3>3) Physical interpretation</h3>
      <p>
        The pattern is essentially an interference comb: bright, narrow principal maxima at angles where the path difference
        between adjacent slits equals an integer number of wavelengths, with structured weaker fringes in between.
        Because the slit width is infinitesimal, there is no additional single-slit diffraction envelope to suppress higher orders.
      </p>
    </section>

    <section id="sketch" class="card pad">
      <h2>How to Sketch the Pattern for a = 10Œª</h2>

      <p>
        With <code>a = 10Œª</code>, the principal maxima satisfy:
        <code>sinŒ∏_n = n/10</code>.
        Therefore, all integer orders <code>n</code> with <code>|n| ‚â§ 10</code> exist (because <code>|sinŒ∏| ‚â§ 1</code>).
      </p>

      <div class="callout">
        <b>Sketch recipe (what you should draw):</b>
        <ul style="margin:8px 0 0 18px; color:var(--muted);">
          <li>Mark a bright central maximum at <code>Œ∏ = 0</code>.</li>
          <li>Mark symmetric principal maxima at <code>Œ∏ = ¬±arcsin(1/10), ¬±arcsin(2/10), ‚Ä¶, ¬±arcsin(10/10)</code>.</li>
          <li>Make each principal maximum very narrow; increase narrowness and height as <code>M</code> increases.</li>
          <li>Between neighboring principal maxima, show <code>M‚àí1</code> intensity zeros (minima) with smaller secondary maxima in between.</li>
        </ul>
      </div>

      <p class="small">
        If your instructor expects the plot vs <code>Œ∏ = x/d</code> directly, you can label the horizontal axis either in angle (radians or degrees)
        or in screen coordinate <code>x</code>, using <code>x_n ‚âà d n Œª / a</code> for the principal maxima positions.
      </p>
    </section>
  </div>
</main>

<footer>
  <div class="card pad">
    <b>Note on constants:</b> In Fraunhofer diffraction, the absolute prefactor depends on propagation distance, incident field amplitude,
    and phase curvature. Since the problem asks for the diffraction <i>pattern</i>, we report the standard normalized angular dependence
    (the physically meaningful part for sketching and comparison).
  </div>
</footer>

<script>
(function(){
  // ---------- Smooth scrolling for TOC ----------
  document.querySelectorAll('[data-scroll]').forEach(a=>{
    a.addEventListener('click', (e)=>{
      e.preventDefault();
      const id = a.getAttribute('href');
      const el = document.querySelector(id);
      if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
    });
  });

  // ---------- Copy buttons ----------
  function copyText(text){
    if(navigator.clipboard && navigator.clipboard.writeText){
      return navigator.clipboard.writeText(text);
    }
    // fallback
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.position='fixed';
    ta.style.left='-9999px';
    document.body.appendChild(ta);
    ta.select();
    try{ document.execCommand('copy'); }catch(_){}
    document.body.removeChild(ta);
    return Promise.resolve();
  }
  document.querySelectorAll('[data-copy-btn]').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const key = btn.getAttribute('data-copy-btn');
      const pre = document.getElementById(key);
      const note = document.querySelector('[data-copy-note="'+key+'"]');
      if(!pre) return;
      await copyText(pre.innerText.trim());
      if(note){
        note.classList.add('show');
        setTimeout(()=>note.classList.remove('show'), 900);
      }
    });
  });

  // ---------- State ----------
  const state = {
    L: 5,
    aOverLambda: 10.0,
    thetaSpanDeg: 90,
    lambda_nm: 632.8 // example for display; equations remain symbolic
  };

  // ---------- Controls ----------
  const Lslider = document.getElementById('Lslider');
  const aslider = document.getElementById('aslider');
  const thetaSpan = document.getElementById('thetaSpan');

  const Lval = document.getElementById('Lval');
  const Mval = document.getElementById('Mval');
  const aval = document.getElementById('aval');
  const spanVal = document.getElementById('spanVal');
  const ordersVal = document.getElementById('ordersVal');
  const lamVal = document.getElementById('lamVal');
  const aAbsVal = document.getElementById('aAbsVal');

  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

  function updateLabels(){
    const M = 2*state.L + 1;
    Lval.textContent = String(state.L);
    Mval.textContent = String(M);
    aval.textContent = state.aOverLambda.toFixed(1);
    spanVal.textContent = String(state.thetaSpanDeg);
    lamVal.textContent = state.lambda_nm.toFixed(1) + " nm";
    aAbsVal.textContent = state.aOverLambda.toFixed(1) + " Œª";
    // orders: max |n| such that |n| <= a/Œª
    const nMax = Math.floor(state.aOverLambda + 1e-9);
    ordersVal.textContent = "¬±" + nMax;
  }

  Lslider.addEventListener('input', ()=>{
    state.L = parseInt(Lslider.value, 10);
    updateAll();
  });
  aslider.addEventListener('input', ()=>{
    state.aOverLambda = parseFloat(aslider.value);
    updateAll();
  });
  thetaSpan.addEventListener('input', ()=>{
    state.thetaSpanDeg = parseInt(thetaSpan.value, 10);
    updateAll();
  });

  // ---------- Canvas utilities ----------
  function setupCanvas(canvas){
    const ctx = canvas.getContext('2d');
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect.width * dpr));
      const h = Math.max(2, Math.floor(rect.height * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {w: rect.width, h: rect.height, dpr};
    }
    return {ctx, resize};
  }

  function clear(ctx, w, h){
    ctx.clearRect(0,0,w,h);
    // subtle background
    ctx.fillStyle = 'rgba(0,0,0,0.10)';
    ctx.fillRect(0,0,w,h);
  }

  function drawAxes(ctx, box, xLabel, yLabel, title, xTicks, yTicks){
    const {x,y,w,h, padL, padR, padT, padB} = box;
    // frame
    ctx.strokeStyle = 'rgba(255,255,255,0.14)';
    ctx.lineWidth = 1;
    ctx.strokeRect(x+0.5, y+0.5, w-1, h-1);

    // title
    ctx.fillStyle = 'rgba(232,236,255,0.95)';
    ctx.font = '600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(title, x + padL, y + padT - 8);

    // plot area
    const px = x + padL, py = y + padT, pw = w - padL - padR, ph = h - padT - padB;

    // grid
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4,4]);
    // vertical grid + x ticks
    ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillStyle = 'rgba(184,194,255,0.9)';
    ctx.setLineDash([4,4]);
    xTicks.forEach(t=>{
      const gx = px + t.pos * pw;
      ctx.beginPath();
      ctx.moveTo(gx, py);
      ctx.lineTo(gx, py+ph);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillText(t.label, gx - 10, y + h - 10);
      ctx.setLineDash([4,4]);
    });
    // horizontal grid + y ticks
    yTicks.forEach(t=>{
      const gy = py + (1 - t.pos) * ph;
      ctx.beginPath();
      ctx.moveTo(px, gy);
      ctx.lineTo(px+pw, gy);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillText(t.label, x + 10, gy + 4);
      ctx.setLineDash([4,4]);
    });
    ctx.setLineDash([]);

    // axes lines
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(px, py+ph);
    ctx.lineTo(px+pw, py+ph);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(px, py+ph);
    ctx.stroke();

    // labels
    ctx.fillStyle = 'rgba(184,194,255,0.95)';
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(xLabel, px + pw - ctx.measureText(xLabel).width, y + h - 10);
    // y label rotated
    ctx.save();
    ctx.translate(x + 14, py + 4);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    return {px, py, pw, ph};
  }

  function linePlot(ctx, area, xToPx, yToPx, points, strokeStyle){
    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = 1.6;
    ctx.beginPath();
    let started = false;
    for(const p of points){
      const X = xToPx(p.x);
      const Y = yToPx(p.y);
      if(!started){
        ctx.moveTo(X,Y); started=true;
      }else{
        ctx.lineTo(X,Y);
      }
    }
    ctx.stroke();
  }

  function fillUnder(ctx, area, xToPx, yToPx, points, fillStyle){
    const {px, py, pw, ph} = area;
    ctx.fillStyle = fillStyle;
    ctx.beginPath();
    let started = false;
    for(const p of points){
      const X = xToPx(p.x);
      const Y = yToPx(p.y);
      if(!started){ ctx.moveTo(X,Y); started = true; }
      else ctx.lineTo(X,Y);
    }
    // close down to x-axis (y=0 in plot coordinates)
    ctx.lineTo(xToPx(points[points.length-1].x), yToPx(0));
    ctx.lineTo(xToPx(points[0].x), yToPx(0));
    ctx.closePath();
    ctx.fill();
  }

  function drawLegend(ctx, x, y, items){
    const pad = 10;
    const lineH = 16;
    const w = 220;
    const h = pad*2 + items.length*lineH;
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.strokeStyle = 'rgba(255,255,255,0.14)';
    ctx.lineWidth = 1;
    roundRect(ctx, x, y, w, h, 12, true, true);
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    items.forEach((it,i)=>{
      const yy = y + pad + i*lineH + 10;
      ctx.strokeStyle = it.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x+12, yy-4);
      ctx.lineTo(x+34, yy-4);
      ctx.stroke();
      ctx.fillStyle = 'rgba(232,236,255,0.95)';
      ctx.fillText(it.text, x+40, yy);
    });
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }

  // ---------- Physics model ----------
  // Normalized intensity:
  // I_norm(Œ∏) = (1/M^2) [ sin(MŒ≤) / sin(Œ≤) ]^2,  Œ≤ = (œÄ a/Œª) sinŒ∏ = œÄ (a/Œª) sinŒ∏
  function intensityNorm(thetaRad, M, aOverLambda){
    const beta = Math.PI * aOverLambda * Math.sin(thetaRad);
    const denom = Math.sin(beta);
    if(Math.abs(denom) < 1e-12){
      // use limit: sin(MŒ≤)/sinŒ≤ -> M
      return 1.0;
    }
    const val = Math.sin(M*beta) / denom;
    return (val*val)/(M*M);
  }

  function computeCurve(thetaMinDeg, thetaMaxDeg, N, M, aOverLambda){
    const pts = [];
    for(let i=0;i<N;i++){
      const tDeg = thetaMinDeg + (thetaMaxDeg-thetaMinDeg)*i/(N-1);
      const tRad = tDeg * Math.PI/180;
      pts.push({x:tDeg, y:intensityNorm(tRad, M, aOverLambda)});
    }
    return pts;
  }

  function principalOrders(aOverLambda){
    const nMax = Math.floor(aOverLambda + 1e-9);
    const arr = [];
    for(let n=-nMax; n<=nMax; n++){
      const s = n / aOverLambda; // sinŒ∏
      if(Math.abs(s) <= 1+1e-12){
        arr.push({n, sinTheta:s});
      }
    }
    return arr;
  }

  // ---------- Draw: Diagram ----------
  const diagram = setupCanvas(document.getElementById('diagram'));
  const mainPlot = setupCanvas(document.getElementById('mainPlot'));
  const secondaryPlot = setupCanvas(document.getElementById('secondaryPlot'));
  const zoomPlot = setupCanvas(document.getElementById('zoomPlot'));

  function drawDiagram(){
    const {ctx, resize} = diagram;
    const {w,h} = resize();
    clear(ctx, w, h);

    // Layout
    const margin = 16;
    const gx = margin;
    const gy = margin;
    const gw = w - 2*margin;
    const gh = h - 2*margin;

    // Title
    ctx.fillStyle = 'rgba(232,236,255,0.95)';
    ctx.font = '700 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText('Physical setup (1D grating ‚Üí far-field screen)', gx, gy+2);

    // Grating line
    const gratingX = gx + 70;
    const yMid = gy + gh*0.58;
    const gratingTop = gy + 40;
    const gratingBottom = gy + gh - 18;

    // Incoming wave arrows
    ctx.strokeStyle = 'rgba(124,240,255,0.75)';
    ctx.lineWidth = 2;
    for(let i=0;i<6;i++){
      const yy = gratingTop + 10 + i*( (gratingBottom-gratingTop-20)/5 );
      ctx.beginPath();
      ctx.moveTo(gx+5, yy);
      ctx.lineTo(gratingX-14, yy);
      ctx.stroke();
      // arrowhead
      ctx.beginPath();
      ctx.moveTo(gratingX-14, yy);
      ctx.lineTo(gratingX-22, yy-4);
      ctx.lineTo(gratingX-22, yy+4);
      ctx.closePath();
      ctx.fillStyle = 'rgba(124,240,255,0.75)';
      ctx.fill();
    }
    ctx.fillStyle = 'rgba(184,194,255,0.95)';
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText('Incident plane wave', gx+6, gratingTop-6);

    // Grating bar
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(gratingX, gratingTop);
    ctx.lineTo(gratingX, gratingBottom);
    ctx.stroke();

    // Slits (dots) along x = m a (schematic)
    const M = 2*state.L + 1;
    const shown = Math.min(M, 13); // show up to 13 dots for clarity
    for(let i=0;i<shown;i++){
      const yy = gratingTop + (gratingBottom-gratingTop) * (i+0.5)/shown;
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.beginPath();
      ctx.arc(gratingX, yy, 2.8, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.fillStyle = 'rgba(184,194,255,0.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText('slits at x = m a', gratingX-38, gratingBottom+16);

    // Screen
    const screenX = gx + gw - 40;
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(screenX, gratingTop);
    ctx.lineTo(screenX, gratingBottom);
    ctx.stroke();
    ctx.fillStyle = 'rgba(184,194,255,0.95)';
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText('Screen (distance d)', screenX-48, gratingTop-6);

    // Central axis
    ctx.strokeStyle = 'rgba(255,255,255,0.14)';
    ctx.setLineDash([5,5]);
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(gratingX, yMid);
    ctx.lineTo(screenX, yMid);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(184,194,255,0.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText('Œ∏ = 0', gratingX + 8, yMid - 6);

    // Ray at angle theta (pick a visible angle based on slider span)
    const thetaDemo = Math.min(35, Math.max(10, state.thetaSpanDeg*0.35)) * Math.PI/180;
    const rayLen = (screenX - gratingX) * 0.9;
    const x2 = gratingX + rayLen*Math.cos(thetaDemo);
    const y2 = yMid - rayLen*Math.sin(thetaDemo);

    ctx.strokeStyle = 'rgba(177,140,255,0.8)';
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    ctx.moveTo(gratingX, yMid);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    // arrowhead
    const ah = 10;
    const ang = -thetaDemo;
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - ah*Math.cos(thetaDemo) - 4*Math.sin(thetaDemo), y2 + ah*Math.sin(thetaDemo) - 4*Math.cos(thetaDemo));
    ctx.lineTo(x2 - ah*Math.cos(thetaDemo) + 4*Math.sin(thetaDemo), y2 + ah*Math.sin(thetaDemo) + 4*Math.cos(thetaDemo));
    ctx.closePath();
    ctx.fillStyle = 'rgba(177,140,255,0.8)';
    ctx.fill();

    // Angle arc
    const r = 28;
    ctx.strokeStyle = 'rgba(177,140,255,0.7)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(gratingX, yMid, r, 0, -thetaDemo, true);
    ctx.stroke();
    ctx.fillStyle = 'rgba(232,236,255,0.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText('Œ∏', gratingX + r + 6, yMid - 10);

    // x coordinate on screen
    ctx.strokeStyle = 'rgba(124,240,255,0.22)';
    ctx.lineWidth = 1.6;
    ctx.beginPath();
    ctx.moveTo(screenX, yMid);
    ctx.lineTo(screenX, y2);
    ctx.stroke();
    ctx.fillStyle = 'rgba(184,194,255,0.95)';
    ctx.fillText('x', screenX + 6, (yMid+y2)/2);

    // Note about small angle
    ctx.fillStyle = 'rgba(184,194,255,0.9)';
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText('Small-angle: Œ∏ ‚âà x/d', gx+6, gy + gh - 2);
  }

  // ---------- Draw: Main plot I(Œ∏) ----------
  function drawMainPlot(){
    const {ctx, resize} = mainPlot;
    const {w,h} = resize();
    clear(ctx, w, h);

    const box = {x:10,y:10,w:w-20,h:h-20,padL:58,padR:18,padT:34,padB:34};
    const span = state.thetaSpanDeg;
    const thetaMin = -span, thetaMax = span;
    const M = 2*state.L + 1;

    const xTicks = [];
    for(let t=-span; t<=span; t+= (span<=30?10:30)){
      xTicks.push({pos:(t-thetaMin)/(thetaMax-thetaMin), label:String(t)});
    }
    const yTicks = [
      {pos:0, label:'0'},
      {pos:0.25, label:'0.25'},
      {pos:0.5, label:'0.5'},
      {pos:0.75, label:'0.75'},
      {pos:1.0, label:'1'}
    ];

    const area = drawAxes(ctx, box,
      'Œ∏ (deg)',
      'I(Œ∏)/I_max (unitless)',
      'Normalized Fraunhofer intensity vs angle',
      xTicks, yTicks
    );

    const {px,py,pw,ph} = area;
    const xToPx = x => px + (x-thetaMin)/(thetaMax-thetaMin)*pw;
    const yToPx = y => py + (1 - clamp(y,0,1))*ph;

    // curve
    const pts = computeCurve(thetaMin, thetaMax, 2200, M, state.aOverLambda);

    // fill + stroke
    fillUnder(ctx, area, xToPx, yToPx, pts, 'rgba(124,240,255,0.08)');
    linePlot(ctx, area, xToPx, yToPx, pts, 'rgba(124,240,255,0.9)');

    // mark principal maxima positions (within span)
    const orders = principalOrders(state.aOverLambda);
    ctx.strokeStyle = 'rgba(177,140,255,0.45)';
    ctx.lineWidth = 1.2;
    ctx.setLineDash([3,4]);
    orders.forEach(o=>{
      const theta = Math.asin(clamp(o.sinTheta,-1,1)) * 180/Math.PI;
      if(theta >= thetaMin && theta <= thetaMax){
        const X = xToPx(theta);
        ctx.beginPath();
        ctx.moveTo(X, py);
        ctx.lineTo(X, py+ph);
        ctx.stroke();
      }
    });
    ctx.setLineDash([]);

    drawLegend(ctx, px+pw-232, py+10, [
      {color:'rgba(124,240,255,0.9)', text:'I(Œ∏) normalized'},
      {color:'rgba(177,140,255,0.6)', text:'principal orders'}
    ]);
  }

  // ---------- Draw: Secondary plot (orders vs sinŒ∏) ----------
  function drawSecondaryPlot(){
    const {ctx, resize} = secondaryPlot;
    const {w,h} = resize();
    clear(ctx, w, h);

    const box = {x:10,y:10,w:w-20,h:h-20,padL:64,padR:18,padT:34,padB:34};

    // x axis: order n
    const nMax = Math.floor(state.aOverLambda + 1e-9);
    const nMin = -nMax, nMaxA = nMax;

    // y axis: sinŒ∏ in [-1,1]
    const xTicks = [];
    const step = nMax<=10 ? 2 : (nMax<=20 ? 4 : 6);
    for(let n=nMin; n<=nMaxA; n+=step){
      xTicks.push({pos:(n-nMin)/(nMaxA-nMin || 1), label:String(n)});
    }
    const yTicks = [
      {pos:0, label:'-1'},
      {pos:0.5, label:'0'},
      {pos:1.0, label:'1'}
    ];

    const area = drawAxes(ctx, box,
      'order n (integer)',
      'sinŒ∏_n (unitless)',
      'Principal maxima locations: sinŒ∏_n = n Œª / a',
      xTicks, yTicks
    );

    const {px,py,pw,ph} = area;
    const xToPx = n => px + (n-nMin)/(nMaxA-nMin || 1)*pw;
    const yToPx = s => py + (1 - (s+1)/2)*ph;

    // horizontal bounds lines at sinŒ∏ = ¬±1
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1.2;
    ctx.setLineDash([5,5]);
    [1,-1].forEach(s=>{
      const Y = yToPx(s);
      ctx.beginPath();
      ctx.moveTo(px, Y);
      ctx.lineTo(px+pw, Y);
      ctx.stroke();
    });
    ctx.setLineDash([]);

    // stems for each n
    const orders = principalOrders(state.aOverLambda);
    orders.forEach(o=>{
      const X = xToPx(o.n);
      const Y = yToPx(o.sinTheta);
      const Y0 = yToPx(0);
      ctx.strokeStyle = 'rgba(177,140,255,0.85)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(X, Y0);
      ctx.lineTo(X, Y);
      ctx.stroke();
      ctx.fillStyle = 'rgba(177,140,255,0.9)';
      ctx.beginPath();
      ctx.arc(X, Y, 3.2, 0, Math.PI*2);
      ctx.fill();
    });

    // text annotation
    ctx.fillStyle = 'rgba(184,194,255,0.95)';
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText('Only orders with |n| ‚â§ a/Œª appear (since |sinŒ∏|‚â§1).', px+6, py+ph-10);

    drawLegend(ctx, px+pw-232, py+10, [
      {color:'rgba(177,140,255,0.85)', text:'principal maxima'}
    ]);
  }

  // ---------- Draw: Zoom plot around Œ∏=0 ----------
  function drawZoomPlot(){
    const {ctx, resize} = zoomPlot;
    const {w,h} = resize();
    clear(ctx, w, h);

    const box = {x:10,y:10,w:w-20,h:h-20,padL:58,padR:18,padT:34,padB:34};

    // Zoom range: choose based on M (narrower peaks at larger M)
    const M = 2*state.L + 1;
    // heuristic: smaller window when M large, but keep within [2¬∞, 20¬∞]
    const halfWin = clamp(18/Math.sqrt(M), 2.5, 20);
    const thetaMin = -halfWin, thetaMax = halfWin;

    const xTicks = [];
    const tickStep = halfWin <= 5 ? 2 : (halfWin <= 10 ? 5 : 10);
    for(let t=Math.ceil(thetaMin/tickStep)*tickStep; t<=thetaMax+1e-9; t+=tickStep){
      xTicks.push({pos:(t-thetaMin)/(thetaMax-thetaMin), label:String(t)});
    }
    const yTicks = [
      {pos:0, label:'0'},
      {pos:0.5, label:'0.5'},
      {pos:1.0, label:'1'}
    ];

    const area = drawAxes(ctx, box,
      'Œ∏ (deg)',
      'I(Œ∏)/I_max',
      'Zoom near Œ∏ = 0 (peak narrowing with M)',
      xTicks, yTicks
    );

    const {px,py,pw,ph} = area;
    const xToPx = x => px + (x-thetaMin)/(thetaMax-thetaMin)*pw;
    const yToPx = y => py + (1 - clamp(y,0,1))*ph;

    // plot for current M
    const pts = computeCurve(thetaMin, thetaMax, 1600, M, state.aOverLambda);
    fillUnder(ctx, area, xToPx, yToPx, pts, 'rgba(121,255,168,0.08)');
    linePlot(ctx, area, xToPx, yToPx, pts, 'rgba(121,255,168,0.9)');

    // also plot a comparison curve for smaller M' (fixed reference) so the effect is obvious
    const Mref = Math.max(3, Math.floor((M+1)/3)); // roughly 1/3 as many slits
    const pts2 = computeCurve(thetaMin, thetaMax, 1600, Mref, state.aOverLambda);
    linePlot(ctx, area, xToPx, yToPx, pts2, 'rgba(255,212,121,0.85)');

    drawLegend(ctx, px+pw-232, py+10, [
      {color:'rgba(121,255,168,0.9)', text:'current M = ' + M},
      {color:'rgba(255,212,121,0.85)', text:'reference M = ' + Mref}
    ]);
  }

  // ---------- Update all ----------
  function updateAll(){
    updateLabels();
    drawDiagram();
    drawMainPlot();
    drawSecondaryPlot();
    drawZoomPlot();
  }

  // ---------- Responsive redraw ----------
  let resizeTimer = null;
  window.addEventListener('resize', ()=>{
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(updateAll, 60);
  });

  // Init
  updateLabels();
  updateAll();
})();
</script>
</body>
</html>
