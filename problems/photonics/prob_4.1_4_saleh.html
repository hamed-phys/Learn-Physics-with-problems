<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Conical Confinement Angle from Maximum Spatial Frequency</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101a33;
      --panel2:#0f1730;
      --text:#eaf0ff;
      --muted:#b9c6ff;
      --faint:rgba(234,240,255,.12);
      --faint2:rgba(234,240,255,.08);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
      --shadow: 0 20px 60px rgba(0,0,0,.35);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 600px at 10% 0%, rgba(125,211,252,.18), transparent 60%),
        radial-gradient(900px 700px at 90% 10%, rgba(167,139,250,.18), transparent 55%),
        radial-gradient(800px 800px at 30% 90%, rgba(52,211,153,.12), transparent 55%),
        linear-gradient(180deg, var(--bg), #070a14 70%);
      color:var(--text);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:28px 20px 18px;
      max-width:1200px;
      margin:0 auto;
    }
    .title{
      display:grid;
      gap:10px;
      align-items:start;
    }
    .title h1{
      margin:0;
      font-size:clamp(1.35rem, 2.4vw, 2.05rem);
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      max-width:80ch;
      font-size:1rem;
    }

    .layout{
      max-width:1200px;
      margin:0 auto;
      padding:0 20px 60px;
      display:grid;
      grid-template-columns: 1fr;
      gap:16px;
    }

    /* Sticky mini-TOC */
    .toc{
      position:sticky;
      top:12px;
      z-index:5;
      background:linear-gradient(180deg, rgba(16,26,51,.92), rgba(16,26,51,.70));
      border:1px solid var(--faint);
      backdrop-filter: blur(10px);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      padding:12px 12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .toc .left{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:7px 10px;
      border-radius:999px;
      background:rgba(234,240,255,.06);
      border:1px solid var(--faint2);
      color:var(--text);
      font-size:.92rem;
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .pill:hover{transform:translateY(-1px); background:rgba(234,240,255,.09); border-color:rgba(125,211,252,.35)}
    .pill:active{transform:translateY(0px) scale(.99)}
    .toc .right{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .badge{
      font-family:var(--mono);
      font-size:.86rem;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(125,211,252,.35);
      background:rgba(125,211,252,.10);
      color:var(--text);
      white-space:nowrap;
    }

    main{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
      .toc{top:8px}
    }

    section, article{
      background:linear-gradient(180deg, rgba(16,26,51,.9), rgba(15,23,48,.84));
      border:1px solid var(--faint);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      padding:18px 18px;
    }
    section h2{
      margin:0 0 10px;
      font-size:1.15rem;
      letter-spacing:.2px;
    }
    section h3{
      margin:14px 0 8px;
      font-size:1.02rem;
      color:var(--text);
    }
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 640px){
      .grid2{grid-template-columns:1fr}
    }
    .card{
      background:rgba(234,240,255,.05);
      border:1px solid var(--faint2);
      border-radius:16px;
      padding:12px 12px;
    }

    ul{margin:8px 0 0 18px}
    li{margin:6px 0}
    .qs li{margin:7px 0}

    .eq{
      font-family:var(--mono);
      background:rgba(0,0,0,.22);
      border:1px solid rgba(234,240,255,.14);
      border-radius:14px;
      padding:12px 12px;
      overflow:auto;
      position:relative;
    }
    .eq .label{
      font-family:var(--sans);
      color:var(--muted);
      font-size:.9rem;
      margin-bottom:6px;
    }
    .copybar{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-top:10px;
    }
    button.copy{
      appearance:none;
      border:1px solid rgba(234,240,255,.18);
      background:rgba(234,240,255,.06);
      color:var(--text);
      border-radius:12px;
      padding:9px 10px;
      cursor:pointer;
      font-size:.92rem;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    button.copy:hover{transform:translateY(-1px); border-color:rgba(167,139,250,.45); background:rgba(167,139,250,.12)}
    button.copy:active{transform:translateY(0px) scale(.99)}
    .toast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform:translateX(-50%);
      background:rgba(16,26,51,.92);
      border:1px solid rgba(125,211,252,.35);
      padding:10px 12px;
      border-radius:12px;
      box-shadow:var(--shadow);
      color:var(--text);
      font-size:.92rem;
      opacity:0;
      pointer-events:none;
      transition:opacity .18s ease, transform .18s ease;
      z-index:100;
    }
    .toast.show{opacity:1; transform:translateX(-50%) translateY(-2px)}

    .controls{
      display:grid;
      gap:10px;
    }
    .control{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
      padding:10px 10px;
      border-radius:16px;
      background:rgba(234,240,255,.05);
      border:1px solid var(--faint2);
    }
    .control label{
      display:grid;
      gap:6px;
      font-size:.95rem;
    }
    .control .value{
      font-family:var(--mono);
      font-size:.95rem;
      padding:7px 10px;
      border-radius:999px;
      background:rgba(0,0,0,.20);
      border:1px solid rgba(234,240,255,.12);
      min-width: 120px;
      text-align:right;
      white-space:nowrap;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }

    figure{
      margin:0;
      display:grid;
      gap:10px;
    }
    canvas{
      width:100%;
      height:280px;
      border-radius:16px;
      border:1px solid rgba(234,240,255,.14);
      background: radial-gradient(800px 300px at 20% 20%, rgba(125,211,252,.08), transparent 55%),
                  linear-gradient(180deg, rgba(0,0,0,.22), rgba(0,0,0,.14));
    }
    .figcap{
      color:var(--muted);
      font-size:.92rem;
    }

    .callout{
      border-left:4px solid rgba(125,211,252,.65);
      padding:10px 12px;
      background:rgba(125,211,252,.08);
      border-radius:14px;
      margin:10px 0 0;
    }
    .final{
      border-left:4px solid rgba(52,211,153,.8);
      background:rgba(52,211,153,.10);
    }
    .warn{
      border-left:4px solid rgba(251,191,36,.85);
      background:rgba(251,191,36,.10);
    }

    .small{font-size:.95rem}
    .kpi{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 520px){
      .kpi{grid-template-columns:1fr}
    }
    .kpi .box{
      border-radius:16px;
      padding:12px 12px;
      border:1px solid rgba(234,240,255,.14);
      background:rgba(0,0,0,.18);
    }
    .kpi .box .t{color:var(--muted); font-size:.9rem; margin-bottom:6px}
    .kpi .box .v{font-family:var(--mono); font-size:1.05rem}

    footer{
      max-width:1200px;
      margin:16px auto 0;
      padding:0 20px 30px;
      color:var(--muted);
      font-size:.92rem;
    }

    /* subtle motion, respects reduced motion */
    @media (prefers-reduced-motion: no-preference){
      section, article{animation: pop .35s ease both}
      @keyframes pop{from{transform:translateY(4px); opacity:.0} to{transform:translateY(0); opacity:1}}
    }

    /* Print friendly */
    @media print{
      body{background:#fff; color:#000}
      section, article, .toc{box-shadow:none; background:#fff; border:1px solid #ccc}
      canvas{border:1px solid #bbb; background:#fff}
      .pill, button.copy{display:none !important}
      .badge{border:1px solid #444; background:#fff; color:#000}
      a{color:#000; text-decoration:underline}
    }
  </style>
</head>
<body>
  <header>
    <div class="title">
      <h1>Conical Confinement Angle from a Maximum Spatial Frequency</h1>
      <div class="subtitle">
        We connect a <em>maximum spatial frequency</em> of a circularly symmetric field to the <em>maximum propagation angle</em>
        (i.e., the half-angle of a cone of allowed plane-wave directions) using Fourier optics / angular spectrum ideas.
      </div>
    </div>
  </header>

  <div class="layout">
    <nav class="toc" aria-label="Mini table of contents">
      <div class="left">
        <div class="pill" data-jump="#quick">⚡ Quick Summary</div>
        <div class="pill" data-jump="#part1">Part 1 — Problem Analysis</div>
        <div class="pill" data-jump="#part2">Part 2 — Strategy & Tips</div>
        <div class="pill" data-jump="#part3">Part 3 — Full Solution</div>
        <div class="pill" data-jump="#viz">Interactive Visualizations</div>
      </div>
      <div class="right">
        <div class="badge" id="badgeAnswer">θmax = —</div>
      </div>
    </nav>

    <main>
      <article>
        <section id="quick">
          <h2>Quick Summary</h2>
          <ul class="qs">
            <li>A 2D field’s spatial frequencies (cycles/length) correspond to propagation directions in the angular spectrum.</li>
            <li>For a plane wave at polar angle <span class="eq-inline">θ</span> from the optical axis: <span class="eq-inline">f<sub>t</sub> = (sin θ)/λ</span>.</li>
            <li>If the spectrum is confined to a circular disk of radius <span class="eq-inline">f<sub>max</sub></span>, then <span class="eq-inline">sin θ<sub>max</sub> = λ f<sub>max</sub></span>.</li>
            <li>Given <span class="eq-inline">f<sub>max</sub> = 200 lines/mm</span> and <span class="eq-inline">λ = 633 nm</span>, we get <span class="eq-inline">θ<sub>max</sub> ≈ 7.27°</span>.</li>
            <li>The full cone apex angle is <span class="eq-inline">2θ<sub>max</sub> ≈ 14.5°</span> (often what “cone angle” means in words).</li>
          </ul>
        </section>

        <section id="part1">
          <h2>PART 1 — Problem Analysis (no solving yet)</h2>

          <h3>Problem restatement (in my words)</h3>
          <p class="muted">
            A circularly symmetric function <span class="eq-inline">f(x,y)</span> has a maximum spatial frequency of
            <span class="eq-inline">200 lines/mm</span>. Using the wavelength <span class="eq-inline">λ = 633 nm</span>,
            determine the angle of the cone about the optical axis within which the corresponding plane-wave directions are confined.
          </p>

          <div class="grid2">
            <div class="card">
              <h3>Given quantities</h3>
              <ul>
                <li>Maximum spatial frequency: <span class="eq-inline">f<sub>max</sub> = 200 lines/mm</span></li>
                <li>Wavelength: <span class="eq-inline">λ = 633 nm</span></li>
                <li>Circular (radial) symmetry in the spatial-frequency content</li>
              </ul>
            </div>
            <div class="card">
              <h3>Unknowns</h3>
              <ul>
                <li>Maximum propagation (half-)angle: <span class="eq-inline">θ<sub>max</sub></span></li>
                <li>(Optionally) full cone apex angle: <span class="eq-inline">2θ<sub>max</sub></span></li>
              </ul>
            </div>
          </div>

          <h3>What must be found</h3>
          <p>
            Find the cone angle that bounds all wave directions implied by the spatial-frequency cutoff. In angular-spectrum language:
            “What is the largest tilt angle of any plane-wave component?”
          </p>

          <h3>Relevant physical principles (and why they apply)</h3>
          <ul>
            <li>
              <strong>Angular spectrum / Fourier optics mapping:</strong>
              Any monochromatic field can be decomposed into plane waves. The transverse spatial frequency components
              <span class="eq-inline">(f<sub>x</sub>, f<sub>y</sub>)</span> map directly to transverse wavevector components
              <span class="eq-inline">(k<sub>x</sub>, k<sub>y</sub>)</span> and thus to propagation angles.
            </li>
            <li>
              <strong>Geometry of a plane wave:</strong>
              For a plane wave making an angle <span class="eq-inline">θ</span> with the optical axis,
              <span class="eq-inline">k<sub>t</sub> = k sin θ</span>, where <span class="eq-inline">k = 2π/λ</span>.
              Since <span class="eq-inline">k<sub>t</sub> = 2π f<sub>t</sub></span>, we get
              <span class="eq-inline">f<sub>t</sub> = (sin θ)/λ</span>.
            </li>
            <li>
              <strong>Circular symmetry:</strong>
              If the spectrum is radially bounded by <span class="eq-inline">f<sub>max</sub></span>, then all directions are confined inside a cone
              (same <span class="eq-inline">θ<sub>max</sub></span> for all azimuths).
            </li>
          </ul>

          <h3>Possible approaches (compare briefly)</h3>
          <ul>
            <li>
              <strong>Approach A (best):</strong> Use the direct angular-spectrum relation
              <span class="eq-inline">sin θ<sub>max</sub> = λ f<sub>max</sub></span>. Fast, clean, minimal assumptions.
            </li>
            <li>
              <strong>Approach B:</strong> Convert to wavevector space:
              <span class="eq-inline">k<sub>t,max</sub> = 2π f<sub>max</sub></span>, then
              <span class="eq-inline">sin θ<sub>max</sub> = k<sub>t,max</sub>/k</span>. Equivalent but one extra step.
            </li>
            <li>
              <strong>Approach C:</strong> Think in terms of numerical aperture:
              <span class="eq-inline">NA = sin θ<sub>max</sub></span> (in air), relate <span class="eq-inline">NA = λ f<sub>max</sub></span>. Same physics, different language.
            </li>
          </ul>

          <div class="callout">
            <strong>Chosen approach:</strong> Approach A — it is the most direct mapping between spatial frequency cutoff and maximum propagation angle.
          </div>
        </section>

        <section id="part2">
          <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

          <h3>Step-by-step plan (no algebra yet)</h3>
          <ol>
            <li>
              <strong>Interpret “lines/mm”:</strong> Convert the maximum spatial frequency to cycles per meter.
              <div class="muted small">Tool: unit conversion.</div>
            </li>
            <li>
              <strong>Use the angular-spectrum mapping:</strong> Recognize that transverse spatial frequency and angle are related.
              <div class="muted small">Principle: plane-wave decomposition / Fourier optics.</div>
            </li>
            <li>
              <strong>Relate radial cutoff to maximum angle:</strong> For circular symmetry use the radial magnitude <span class="eq-inline">f<sub>t</sub></span>.
              <div class="muted small">Equation: <span class="eq-inline">f<sub>t</sub> = (sin θ)/λ</span>.</div>
            </li>
            <li>
              <strong>Solve for <span class="eq-inline">θ<sub>max</sub></span>:</strong> Apply inverse sine.
              <div class="muted small">Math tool: <span class="eq-inline">θ = arcsin(…)</span>.</div>
            </li>
            <li>
              <strong>Interpret “cone angle”:</strong> Report half-angle <span class="eq-inline">θ<sub>max</sub></span> and (if desired) full apex angle <span class="eq-inline">2θ<sub>max</sub></span>.
            </li>
            <li>
              <strong>Sanity checks:</strong> Ensure <span class="eq-inline">λ f<sub>max</sub> ≤ 1</span>, verify units, and interpret physically (small-angle regime).
            </li>
          </ol>

          <h3>Common mistakes & quick tips</h3>
          <div class="grid2">
            <div class="card warn">
              <strong>Mistakes</strong>
              <ul>
                <li>Forgetting that “lines/mm” means <em>cycles per mm</em> (not radians, not per cm).</li>
                <li>Mixing <span class="eq-inline">k</span>-space (rad/m) with frequency space (cycles/m) without <span class="eq-inline">2π</span> consistency.</li>
                <li>Reporting <span class="eq-inline">2θ</span> when the question expects <span class="eq-inline">θ</span> (or vice versa).</li>
              </ul>
            </div>
            <div class="card">
              <strong>Tips</strong>
              <ul>
                <li>Use the simplest identity: <span class="eq-inline">sin θ = λ f</span> (in air, paraxial not required).</li>
                <li>If <span class="eq-inline">λ f</span> is small, you can check with <span class="eq-inline">θ ≈ λ f</span> (radians).</li>
                <li>Always state clearly: <em>half-angle from the axis</em> vs <em>full cone apex angle</em>.</li>
              </ul>
            </div>
          </div>
        </section>

        <section id="part3">
          <h2>PART 3 — Full Solution</h2>

          <h3>Physical intuition first</h3>
          <p>
            A monochromatic field can be built from plane waves pointing in different directions. Large spatial frequencies mean the field varies
            rapidly across <span class="eq-inline">x</span> and <span class="eq-inline">y</span>, which requires plane-wave components with larger transverse wavevector,
            i.e., rays tilted further away from the axis. If there is a maximum spatial frequency, then there is a maximum tilt angle — producing a cone of directions.
          </p>

          <h3>Step-by-step derivation</h3>

          <div class="eq" id="eq1">
            <div class="label">Key mapping between transverse spatial frequency and propagation angle</div>
            <div>
              Consider a plane wave of wavelength <span class="eq-inline">λ</span> propagating at polar angle <span class="eq-inline">θ</span> from the <span class="eq-inline">z</span>-axis.
              Its wavevector magnitude is <span class="eq-inline">k = 2π/λ</span>, and its transverse component is:
              <br><br>
              <span class="eq-inline">k<sub>t</sub> = k sin θ</span>.
              <br><br>
              Spatial frequency (cycles per length) relates to wavevector (radians per length) by:
              <br><br>
              <span class="eq-inline">k<sub>t</sub> = 2π f<sub>t</sub></span>.
              <br><br>
              Combine them:
              <br><br>
              <span class="eq-inline">2π f<sub>t</sub> = (2π/λ) sin θ</span>
              <br>
              ⇒ <span class="eq-inline">f<sub>t</sub> = (sin θ)/λ</span>
              <br>
              ⇒ <span class="eq-inline">sin θ = λ f<sub>t</sub></span>.
            </div>
          </div>
          <div class="copybar">
            <button class="copy" data-copy="sin(θ) = λ f_t">Copy: sin(θ) = λ f_t</button>
          </div>

          <h3>Apply the maximum spatial frequency (circularly symmetric)</h3>
          <p>
            “Circularly symmetric with a maximum spatial frequency” means the spectrum occupies a disk in the
            <span class="eq-inline">(f<sub>x</sub>, f<sub>y</sub>)</span> plane with maximum radial magnitude
            <span class="eq-inline">f<sub>t,max</sub> = f<sub>max</sub></span>. Therefore the largest propagation angle is obtained by setting
            <span class="eq-inline">f<sub>t</sub> = f<sub>max</sub></span>:
          </p>

          <div class="eq" id="eq2">
            <div class="label">Angle confinement condition</div>
            <div>
              <span class="eq-inline">sin θ<sub>max</sub> = λ f<sub>max</sub></span>
              <br>
              <span class="eq-inline">θ<sub>max</sub> = arcsin(λ f<sub>max</sub>)</span>.
            </div>
          </div>
          <div class="copybar">
            <button class="copy" data-copy="θ_max = arcsin(λ f_max)">Copy: θ_max = arcsin(λ f_max)</button>
          </div>

          <h3>Insert the numbers (careful with units)</h3>
          <p>
            Convert <span class="eq-inline">200 lines/mm</span> to cycles per meter:
          </p>
          <div class="eq" id="eq3">
            <div class="label">Unit conversion</div>
            <div>
              <span class="eq-inline">f<sub>max</sub> = 200 cycles/mm = 200 × 10<sup>3</sup> cycles/m = 2.00 × 10<sup>5</sup> m<sup>−1</sup></span>.
              <br>
              <span class="eq-inline">λ = 633 nm = 633 × 10<sup>−9</sup> m</span>.
            </div>
          </div>

          <p>
            Compute the dimensionless product:
            <span class="eq-inline">λ f<sub>max</sub> = (633 × 10<sup>−9</sup>)(2.00 × 10<sup>5</sup>) = 0.1266</span>.
          </p>
          <p>
            Then:
            <span class="eq-inline">θ<sub>max</sub> = arcsin(0.1266) ≈ 7.27°</span>.
          </p>

          <div class="callout final" id="finalBox">
            <strong>Final result (cone confinement):</strong><br>
            Half-angle from the axis:
            <span class="eq-inline"><strong>θ<sub>max</sub> ≈ 7.27°</strong></span>.<br>
            Full cone apex angle (often called “the cone angle”):
            <span class="eq-inline"><strong>2θ<sub>max</sub> ≈ 14.5°</strong></span>.
          </div>
          <div class="copybar">
            <button class="copy" id="copyFinal" data-copy="θ_max ≈ 7.27° (half-angle from axis); full cone apex angle 2θ_max ≈ 14.5°">Copy: final answer</button>
          </div>

          <h3>Sanity checks</h3>
          <ul>
            <li>
              <strong>Units:</strong> <span class="eq-inline">λ</span> is meters, <span class="eq-inline">f</span> is cycles/m, so <span class="eq-inline">λ f</span> is dimensionless — valid input to <span class="eq-inline">arcsin</span>.
            </li>
            <li>
              <strong>Limiting case:</strong> If <span class="eq-inline">f<sub>max</sub> → 0</span>, then <span class="eq-inline">θ<sub>max</sub> → 0</span>: only near-axis waves — makes sense.
            </li>
            <li>
              <strong>Physical feasibility:</strong> Must have <span class="eq-inline">λ f<sub>max</sub> ≤ 1</span>. Here <span class="eq-inline">0.1266</span> so it’s comfortably allowed (propagating components, not evanescent).
            </li>
            <li>
              <strong>Interpretation:</strong> The field’s angular spectrum is confined to a cone of directions of half-angle ~7.3° about the optical axis.
            </li>
          </ul>
        </section>
      </article>

      <aside>
        <section id="viz">
          <h2>Interactive Visualizations</h2>
          <p class="muted small">
            Use the sliders to change <span class="eq-inline">f<sub>max</sub></span> and <span class="eq-inline">λ</span>. All plots update live:
            the cone diagram, the angle-vs-frequency plot, and a k-space (angular spectrum) visualization.
          </p>

          <div class="controls" aria-label="Interactive controls">
            <div class="control">
              <label>
                <span><strong>Max spatial frequency</strong> <span class="muted">(lines/mm)</span></span>
                <input id="fSlider" type="range" min="0" max="500" value="200" step="1" />
              </label>
              <div class="value" id="fVal">200 lines/mm</div>
            </div>

            <div class="control">
              <label>
                <span><strong>Wavelength</strong> <span class="muted">(nm)</span></span>
                <input id="lamSlider" type="range" min="400" max="900" value="633" step="1" />
              </label>
              <div class="value" id="lamVal">633 nm</div>
            </div>
          </div>

          <div class="kpi" role="group" aria-label="Computed outputs">
            <div class="box">
              <div class="t">Half-angle (from axis)</div>
              <div class="v" id="thetaHalf">—</div>
            </div>
            <div class="box">
              <div class="t">Full cone apex angle</div>
              <div class="v" id="thetaFull">—</div>
            </div>
          </div>

          <figure style="margin-top:12px">
            <canvas id="cDiagram" aria-label="Cone diagram"></canvas>
            <div class="figcap">Diagram: cone of allowed plane-wave directions (half-angle θ<sub>max</sub> from the axis).</div>
          </figure>

          <figure style="margin-top:12px">
            <canvas id="cMain" aria-label="Main plot: theta vs fmax"></canvas>
            <div class="figcap">Main plot: θ<sub>max</sub> versus f<sub>max</sub> for the chosen wavelength.</div>
          </figure>

          <figure style="margin-top:12px">
            <canvas id="cSecondary" aria-label="Secondary plot: k-space disk"></canvas>
            <div class="figcap">Secondary plot: angular-spectrum disk in k-space (propagating region) and the cutoff radius set by f<sub>max</sub>.</div>
          </figure>

          <div class="callout warn small" style="margin-top:12px">
            <strong>Note:</strong> If <span class="eq-inline">λ f<sub>max</sub> &gt; 1</span>, the computed “angle” would not correspond to propagating waves in free space (it would imply evanescent components). The plots will warn you.
          </div>
        </section>
      </aside>
    </main>

    <footer>
      Built with vanilla HTML/CSS/JS. Equations are shown in plain text (no MathJax). Canvas plots are rendered with high-DPI support.
    </footer>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite">Copied!</div>

  <script>
    // ---------- Utilities ----------
    function $(id){ return document.getElementById(id); }
    function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
    function rad2deg(r){ return r * 180 / Math.PI; }
    function deg2rad(d){ return d * Math.PI / 180; }

    function showToast(msg){
      const t = $("toast");
      t.textContent = msg || "Copied!";
      t.classList.add("show");
      clearTimeout(showToast._timer);
      showToast._timer = setTimeout(()=>t.classList.remove("show"), 900);
    }

    async function copyText(text){
      try{
        await navigator.clipboard.writeText(text);
        showToast("Copied to clipboard");
      }catch(e){
        // fallback
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
        showToast("Copied");
      }
    }

    document.querySelectorAll("button.copy").forEach(btn=>{
      btn.addEventListener("click", ()=> copyText(btn.getAttribute("data-copy") || ""));
    });

    // mini-TOC jumps
    document.querySelectorAll(".pill[data-jump]").forEach(p=>{
      p.addEventListener("click", ()=>{
        const target = document.querySelector(p.getAttribute("data-jump"));
        if(target) target.scrollIntoView({behavior:"smooth", block:"start"});
      });
    });

    // ---------- Canvas Helpers ----------
    function setupCanvas(canvas){
      const ctx = canvas.getContext("2d");
      const state = { canvas, ctx, w: 0, h: 0, dpr: 1 };

      function resize(){
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        state.dpr = dpr;
        state.w = Math.max(2, Math.floor(rect.width * dpr));
        state.h = Math.max(2, Math.floor(rect.height * dpr));
        canvas.width = state.w;
        canvas.height = state.h;
        ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      }

      const ro = new ResizeObserver(resize);
      ro.observe(canvas);
      resize();
      return state;
    }

    function clear(ctx, w, h){
      ctx.clearRect(0,0,w,h);
    }

    function drawPanelTitle(ctx, x, y, title){
      ctx.save();
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.font = "600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(title, x, y);
      ctx.restore();
    }

    // Plot frame with axes, ticks, gridlines
    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel){
      const {x,y,w,h, padL, padR, padT, padB} = box;
      const ix = x + padL, iy = y + padT;
      const iw = w - padL - padR, ih = h - padT - padB;

      // background soft
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.10)";
      ctx.fillRect(x,y,w,h);
      ctx.restore();

      // grid + ticks
      const nGrid = 6;
      ctx.save();
      ctx.strokeStyle = "rgba(234,240,255,.10)";
      ctx.lineWidth = 1;

      for(let i=0;i<=nGrid;i++){
        const gx = ix + iw*i/nGrid;
        const gy = iy + ih*i/nGrid;
        ctx.beginPath(); ctx.moveTo(gx, iy); ctx.lineTo(gx, iy+ih); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ix, gy); ctx.lineTo(ix+iw, gy); ctx.stroke();
      }
      ctx.restore();

      // axes
      ctx.save();
      ctx.strokeStyle = "rgba(234,240,255,.35)";
      ctx.lineWidth = 1.2;
      ctx.beginPath(); ctx.rect(ix, iy, iw, ih); ctx.stroke();
      ctx.restore();

      // tick labels
      ctx.save();
      ctx.fillStyle = "rgba(234,240,255,.78)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

      function fmt(v){
        // compact formatting
        const av = Math.abs(v);
        if(av >= 1000) return v.toFixed(0);
        if(av >= 100) return v.toFixed(0);
        if(av >= 10) return v.toFixed(1);
        if(av >= 1) return v.toFixed(2);
        return v.toFixed(3);
      }

      for(let i=0;i<=nGrid;i++){
        const xv = xMin + (xMax-xMin)*i/nGrid;
        const yv = yMax - (yMax-yMin)*i/nGrid;

        const gx = ix + iw*i/nGrid;
        const gy = iy + ih*i/nGrid;

        ctx.fillText(fmt(xv), gx-10, iy+ih+16);
        ctx.fillText(fmt(yv), ix-56, gy+4);
      }

      // axis labels
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(xLabel, ix + iw - ctx.measureText(xLabel).width, iy+ih+34);

      ctx.save();
      ctx.translate(ix-38, iy+12);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();

      ctx.restore();

      return {
        ix, iy, iw, ih,
        xToPx: (xv)=> ix + (xv-xMin)*iw/(xMax-xMin),
        yToPx: (yv)=> iy + (yMax-yv)*ih/(yMax-yMin)
      };
    }

    function drawLegend(ctx, items, x, y){
      ctx.save();
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      let yy = y;
      items.forEach(it=>{
        ctx.fillStyle = it.color;
        ctx.fillRect(x, yy-9, 14, 8);
        ctx.fillStyle = "rgba(234,240,255,.92)";
        ctx.fillText(it.label, x+20, yy);
        yy += 16;
      });
      ctx.restore();
    }

    // ---------- Physics ----------
    // f_max in lines/mm -> cycles/m
    function fLinesPerMm_to_cyclesPerM(fmm){
      return fmm * 1e3;
    }
    // lambda in nm -> meters
    function lamNm_to_m(lamNm){
      return lamNm * 1e-9;
    }
    function thetaMax_rad(lam_m, f_cycles_m){
      const s = lam_m * f_cycles_m;
      if(s <= -1) return -Math.PI/2;
      if(s >=  1) return  Math.PI/2;
      return Math.asin(s);
    }

    // ---------- Draw: Diagram ----------
    function drawConeDiagram(st, thetaRad){
      const ctx = st.ctx;
      const w = st.canvas.getBoundingClientRect().width;
      const h = st.canvas.getBoundingClientRect().height;

      clear(ctx, w, h);

      drawPanelTitle(ctx, 14, 18, "Diagram — Cone of allowed propagation directions");

      const cx = w*0.52;
      const cy = h*0.82;
      const axisLen = h*0.66;

      // axis (z)
      ctx.save();
      ctx.strokeStyle = "rgba(234,240,255,.55)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx, cy-axisLen);
      ctx.stroke();

      // arrow head
      ctx.beginPath();
      ctx.moveTo(cx, cy-axisLen);
      ctx.lineTo(cx-6, cy-axisLen+10);
      ctx.lineTo(cx+6, cy-axisLen+10);
      ctx.closePath();
      ctx.fillStyle = "rgba(234,240,255,.55)";
      ctx.fill();

      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.font = "600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("z-axis (optical axis)", cx+10, cy-axisLen+18);

      // cone lines
      const theta = clamp(thetaRad, 0, Math.PI/2);
      const rayLen = axisLen*0.92;
      const leftX = cx - Math.tan(theta)*rayLen;
      const rightX = cx + Math.tan(theta)*rayLen;
      const topY = cy - rayLen;

      ctx.strokeStyle = "rgba(125,211,252,.85)";
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(leftX, topY);
      ctx.moveTo(cx, cy);
      ctx.lineTo(rightX, topY);
      ctx.stroke();

      // cone fill (suggestion)
      ctx.fillStyle = "rgba(125,211,252,.10)";
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(leftX, topY);
      ctx.lineTo(rightX, topY);
      ctx.closePath();
      ctx.fill();

      // angle arc
      const arcR = 46;
      const arcCenterX = cx;
      const arcCenterY = cy - 6;
      ctx.strokeStyle = "rgba(52,211,153,.85)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(arcCenterX, arcCenterY, arcR, -Math.PI/2, -Math.PI/2 + theta, false);
      ctx.stroke();

      // angle label
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.font = "600 13px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      const deg = rad2deg(theta);
      ctx.fillText("θmax ≈ " + deg.toFixed(2) + "°", arcCenterX + 18, arcCenterY - arcR + 16);

      // base circle (projected)
      const baseR = Math.tan(theta)*rayLen;
      ctx.strokeStyle = "rgba(234,240,255,.22)";
      ctx.setLineDash([6,6]);
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.ellipse(cx, topY, baseR, baseR*0.22, 0, 0, Math.PI*2);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = "rgba(234,240,255,.72)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("allowed directions", cx - 54, topY - 10);

      ctx.restore();
    }

    // ---------- Draw: Main plot θmax vs fmax ----------
    function drawMainPlot(st, lamNm, fmmCurrent){
      const ctx = st.ctx;
      const w = st.canvas.getBoundingClientRect().width;
      const h = st.canvas.getBoundingClientRect().height;
      clear(ctx, w, h);

      drawPanelTitle(ctx, 14, 18, "Main Plot — θmax vs fmax (for chosen λ)");

      const pad = {padL:64, padR:16, padT:34, padB:48};
      const box = {x:14, y:30, w:w-28, h:h-44, ...pad};

      // ranges
      const fMaxPlot = 500; // lines/mm
      const lam_m = lamNm_to_m(lamNm);

      // y max from lambda and f range (cap at 90°)
      const sMax = lam_m * fLinesPerMm_to_cyclesPerM(fMaxPlot);
      const thetaMaxPossible = rad2deg(Math.asin(clamp(sMax, 0, 1)));
      const yMax = Math.max(10, Math.min(90, thetaMaxPossible));
      const yMin = 0;

      const ax = drawAxes(ctx, box, 0, fMaxPlot, yMin, yMax, "fmax (lines/mm)", "θmax (deg)");

      // curve
      ctx.save();
      ctx.strokeStyle = "rgba(125,211,252,.9)";
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      for(let i=0;i<=250;i++){
        const fmm = fMaxPlot * i/250;
        const f_m = fLinesPerMm_to_cyclesPerM(fmm);
        const s = lam_m * f_m;
        const th = rad2deg(Math.asin(clamp(s, 0, 1)));
        const px = ax.xToPx(fmm);
        const py = ax.yToPx(th);
        if(i===0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();

      // current point
      const f_m_cur = fLinesPerMm_to_cyclesPerM(fmmCurrent);
      const sCur = lam_m * f_m_cur;
      const thCur = rad2deg(Math.asin(clamp(sCur, 0, 1)));
      const pxC = ax.xToPx(fmmCurrent);
      const pyC = ax.yToPx(thCur);

      ctx.fillStyle = "rgba(52,211,153,.95)";
      ctx.beginPath();
      ctx.arc(pxC, pyC, 5.5, 0, Math.PI*2);
      ctx.fill();

      // warning region if sCur > 1
      if(sCur > 1){
        ctx.fillStyle = "rgba(251,191,36,.12)";
        ctx.fillRect(ax.ix, ax.iy, ax.iw, ax.ih);
        ctx.fillStyle = "rgba(251,191,36,.95)";
        ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText("Warning: λ fmax > 1 (implies evanescent components)", ax.ix+10, ax.iy+18);
      }

      // legend
      drawLegend(ctx, [
        {color:"rgba(125,211,252,.9)", label:"θmax = arcsin(λ fmax)"},
        {color:"rgba(52,211,153,.95)", label:"current (λ, fmax)"}
      ], ax.ix+10, ax.iy+18 + 18);

      // annotate current values
      ctx.fillStyle = "rgba(234,240,255,.90)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      const txt = `λ=${lamNm.toFixed(0)} nm, fmax=${fmmCurrent.toFixed(0)} lines/mm, θmax=${thCur.toFixed(2)}°`;
      const tw = ctx.measureText(txt).width;
      ctx.fillStyle = "rgba(0,0,0,.25)";
      ctx.fillRect(ax.ix + ax.iw - tw - 12, ax.iy + 8, tw + 10, 18);
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.fillText(txt, ax.ix + ax.iw - tw - 7, ax.iy + 22);

      ctx.restore();
    }

    // ---------- Draw: Secondary plot (k-space disk) ----------
    function drawSecondaryPlot(st, lamNm, fmmCurrent){
      const ctx = st.ctx;
      const w = st.canvas.getBoundingClientRect().width;
      const h = st.canvas.getBoundingClientRect().height;
      clear(ctx, w, h);

      drawPanelTitle(ctx, 14, 18, "Secondary Plot — Angular spectrum in k-space");

      // Interpretations:
      // k = 2π/λ. Propagating plane waves satisfy k_t ≤ k.
      // k_t = 2π f_t. A cutoff fmax implies k_t,max = 2π fmax.
      const lam_m = lamNm_to_m(lamNm);
      const k = 2*Math.PI/lam_m; // rad/m
      const f_m_cur = fLinesPerMm_to_cyclesPerM(fmmCurrent);
      const ktMax = 2*Math.PI*f_m_cur; // rad/m
      const ratio = ktMax / k; // = λ fmax

      // plotting box
      const pad = {padL:64, padR:16, padT:34, padB:48};
      const box = {x:14, y:30, w:w-28, h:h-44, ...pad};

      // k_t axes range: show up to 1.1*k for visibility
      const xMin = -1.1*k, xMax = 1.1*k;
      const yMin = -1.1*k, yMax = 1.1*k;

      const ax = drawAxes(ctx, box, xMin, xMax, yMin, yMax, "k_x (rad/m)", "k_y (rad/m)");

      // draw propagating circle k_t = k
      ctx.save();
      ctx.strokeStyle = "rgba(234,240,255,.55)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      const cX = ax.xToPx(0);
      const cY = ax.yToPx(0);
      const rPx = Math.abs(ax.xToPx(k) - ax.xToPx(0));
      ctx.arc(cX, cY, rPx, 0, Math.PI*2);
      ctx.stroke();

      ctx.fillStyle = "rgba(234,240,255,.12)";
      ctx.beginPath();
      ctx.arc(cX, cY, rPx, 0, Math.PI*2);
      ctx.fill();

      // draw cutoff circle ktMax
      const rCut = Math.abs(ax.xToPx(ktMax) - ax.xToPx(0));
      ctx.strokeStyle = "rgba(125,211,252,.9)";
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      ctx.arc(cX, cY, rCut, 0, Math.PI*2);
      ctx.stroke();

      // fill cutoff region
      ctx.fillStyle = "rgba(125,211,252,.10)";
      ctx.beginPath();
      ctx.arc(cX, cY, rCut, 0, Math.PI*2);
      ctx.fill();

      // annotate
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      const line1 = `k = 2π/λ = ${k.toExponential(3)} rad/m`;
      const line2 = `k_t,max = 2π fmax = ${ktMax.toExponential(3)} rad/m`;
      const line3 = `k_t,max / k = λ fmax = ${ratio.toFixed(4)}`;
      ctx.fillStyle = "rgba(0,0,0,.26)";
      ctx.fillRect(ax.ix+10, ax.iy+8, 360, 54);
      ctx.fillStyle = "rgba(234,240,255,.92)";
      ctx.fillText(line1, ax.ix+16, ax.iy+24);
      ctx.fillText(line2, ax.ix+16, ax.iy+40);
      ctx.fillText(line3, ax.ix+16, ax.iy+56);

      // warning if outside propagating disk
      if(ktMax > k){
        ctx.fillStyle = "rgba(251,191,36,.16)";
        ctx.fillRect(ax.ix, ax.iy, ax.iw, ax.ih);
        ctx.fillStyle = "rgba(251,191,36,.95)";
        ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText("Cutoff circle exceeds propagating region (evanescent implied)", ax.ix+10, ax.iy+18);
      }

      drawLegend(ctx, [
        {color:"rgba(234,240,255,.55)", label:"propagating limit: k_t = k"},
        {color:"rgba(125,211,252,.9)", label:"spectral cutoff: k_t,max = 2π fmax"}
      ], ax.ix+10, ax.iy+ax.ih-22);

      ctx.restore();
    }

    // ---------- App State & Update ----------
    const S = {
      fmm: 200,
      lamNm: 633,
      canv: {}
    };

    function computeOutputs(){
      const lam_m = lamNm_to_m(S.lamNm);
      const f_m = fLinesPerMm_to_cyclesPerM(S.fmm);
      const s = lam_m * f_m; // dimensionless
      const th = thetaMax_rad(lam_m, f_m);
      return { s, thetaRad: th, thetaDeg: rad2deg(th), thetaFullDeg: 2*rad2deg(th) };
    }

    function updateUI(){
      $("fVal").textContent = `${S.fmm.toFixed(0)} lines/mm`;
      $("lamVal").textContent = `${S.lamNm.toFixed(0)} nm`;

      const out = computeOutputs();

      // display
      const half = out.thetaDeg;
      const full = out.thetaFullDeg;

      $("thetaHalf").textContent = `${half.toFixed(2)}°`;
      $("thetaFull").textContent = `${full.toFixed(2)}°`;

      $("badgeAnswer").textContent = `θmax = ${half.toFixed(2)}°  |  2θmax = ${full.toFixed(2)}°`;

      // redraw canvases
      drawConeDiagram(S.canv.diagram, out.thetaRad);
      drawMainPlot(S.canv.main, S.lamNm, S.fmm);
      drawSecondaryPlot(S.canv.secondary, S.lamNm, S.fmm);

      // update final answer copy text to match current (even if changed)
      $("copyFinal").setAttribute(
        "data-copy",
        `θ_max ≈ ${half.toFixed(2)}° (half-angle from axis); full cone apex angle 2θ_max ≈ ${full.toFixed(2)}°`
      );
    }

    function init(){
      // Canvas setup
      S.canv.diagram = setupCanvas($("cDiagram"));
      S.canv.main = setupCanvas($("cMain"));
      S.canv.secondary = setupCanvas($("cSecondary"));

      // Sliders
      $("fSlider").addEventListener("input", (e)=>{
        S.fmm = parseFloat(e.target.value);
        updateUI();
      });
      $("lamSlider").addEventListener("input", (e)=>{
        S.lamNm = parseFloat(e.target.value);
        updateUI();
      });

      // initial
      updateUI();

      // ensure redraw on DPI changes
      window.addEventListener("resize", ()=> updateUI(), {passive:true});
    }

    init();
  </script>

  <style>
    /* Inline equation styling (small) */
    .eq-inline{
      font-family: var(--mono);
      padding: 1px 6px;
      border-radius: 10px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(234,240,255,.12);
      white-space: nowrap;
    }
  </style>
</body>
</html>
