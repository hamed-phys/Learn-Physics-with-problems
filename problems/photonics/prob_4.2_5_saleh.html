<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Design of an Optical Fourier-Transform System (Lens Focal Length)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1733;
      --card:#101a3a;
      --text:#e9ecff;
      --muted:#b9c0ff;
      --faint:#7f8cff;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --ok:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 18px 40px rgba(0,0,0,.35);
      --radius:18px;
      --radius2:22px;
    }
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 600px at 20% 0%, rgba(125,211,252,.18), transparent 55%),
                  radial-gradient(900px 500px at 90% 20%, rgba(167,139,250,.18), transparent 55%),
                  radial-gradient(900px 700px at 50% 110%, rgba(52,211,153,.10), transparent 60%),
                  var(--bg);
      color:var(--text);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:28px 18px 8px;
      max-width:1180px;
      margin:0 auto;
    }
    .topbar{
      display:flex;
      gap:14px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .titleblock{
      max-width:820px;
    }
    h1{
      font-size:clamp(1.35rem, 2.4vw, 2.1rem);
      margin:0 0 8px;
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      margin:0;
      font-size:clamp(.95rem, 1.2vw, 1.02rem);
    }
    .badgeRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .badge{
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      padding:6px 10px;
      border-radius:999px;
      color:var(--muted);
      font-size:.86rem;
      display:inline-flex;
      gap:8px;
      align-items:center;
      box-shadow: 0 10px 20px rgba(0,0,0,.15);
    }
    .badge b{color:var(--text); font-weight:700}
    main{
      max-width:1180px;
      margin:0 auto;
      padding:14px 18px 80px;
      display:grid;
      grid-template-columns: 300px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
      .toc{position:relative; top:0}
    }
    .toc{
      position:sticky;
      top:14px;
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border-radius:var(--radius2);
      padding:14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .toc h2{
      font-size:1rem;
      margin:0 0 10px;
      color:var(--text);
      letter-spacing:.3px;
    }
    .toc a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      color:var(--muted);
      border:1px solid transparent;
    }
    .toc a:hover{
      background:rgba(125,211,252,.08);
      border-color:rgba(125,211,252,.25);
      text-decoration:none;
      color:var(--text);
    }
    .content{
      display:flex;
      flex-direction:column;
      gap:16px;
      min-width:0;
    }
    section, article{
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border-radius:var(--radius2);
      padding:16px 16px 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    h2{
      margin:0 0 8px;
      font-size:1.25rem;
      letter-spacing:.2px;
    }
    h3{
      margin:14px 0 6px;
      font-size:1.05rem;
      color:var(--text);
    }
    p{margin:8px 0; color:var(--text)}
    ul{margin:8px 0 8px 18px; color:var(--text)}
    li{margin:6px 0}
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 820px){
      .grid2{grid-template-columns:1fr}
    }
    .callouts{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:12px;
      margin-top:10px;
    }
    @media (max-width: 900px){
      .callouts{grid-template-columns:1fr}
    }
    .card{
      border:1px solid var(--line);
      background:rgba(16,26,58,.55);
      border-radius:var(--radius);
      padding:12px;
    }
    .card h3{margin-top:0}
    .kpi{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .kpi .k{
      padding:10px;
      border-radius:16px;
      background:rgba(0,0,0,.18);
      border:1px solid var(--line);
    }
    .k .label{color:var(--muted); font-size:.86rem}
    .k .value{font-size:1.06rem; font-weight:800; margin-top:4px}
    .eq{
      position:relative;
      border:1px solid rgba(125,211,252,.25);
      background:rgba(125,211,252,.06);
      border-radius:16px;
      padding:10px 12px;
      overflow:hidden;
      margin:10px 0;
    }
    .eq pre{
      margin:0;
      white-space:pre-wrap;
      word-break:break-word;
      color:var(--text);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:.95rem;
      line-height:1.4;
    }
    .copyBtn{
      position:absolute;
      right:10px;
      top:10px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      color:var(--text);
      padding:6px 10px;
      border-radius:12px;
      cursor:pointer;
      font-size:.85rem;
      transition: transform .12s ease, background .12s ease;
    }
    .copyBtn:hover{transform: translateY(-1px); background:rgba(0,0,0,.28)}
    .copyState{
      display:inline-flex;
      align-items:center;
      gap:8px;
      color:var(--muted);
      font-size:.9rem;
      margin-left:10px;
    }
    .box{
      border:1px solid rgba(52,211,153,.30);
      background:rgba(52,211,153,.08);
      border-radius:18px;
      padding:12px;
      margin-top:10px;
    }
    .box strong{color:var(--text)}
    .final{
      border:1px solid rgba(52,211,153,.45);
      background:linear-gradient(180deg, rgba(52,211,153,.14), rgba(52,211,153,.06));
      border-radius:20px;
      padding:14px 14px 12px;
      margin-top:12px;
    }
    .final .big{
      font-size:1.15rem;
      font-weight:900;
      margin:6px 0 2px;
    }
    .controls{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:12px;
      align-items:start;
    }
    @media (max-width: 980px){
      .controls{grid-template-columns:1fr}
    }
    .ctrlRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width: 640px){
      .ctrlRow{grid-template-columns:1fr}
    }
    label{
      display:block;
      font-size:.88rem;
      color:var(--muted);
      margin-bottom:6px;
    }
    input[type="range"], input[type="number"]{
      width:100%;
    }
    input[type="number"]{
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      color:var(--text);
      outline:none;
    }
    input[type="number"]:focus{
      border-color:rgba(125,211,252,.45);
      box-shadow:0 0 0 3px rgba(125,211,252,.15);
    }
    .btnRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    button.action{
      border:1px solid rgba(125,211,252,.35);
      background:rgba(125,211,252,.10);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:700;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    button.action:hover{transform: translateY(-1px); background:rgba(125,211,252,.16); border-color:rgba(125,211,252,.55)}
    button.action.secondary{
      border-color:rgba(167,139,250,.35);
      background:rgba(167,139,250,.10);
    }
    button.action.secondary:hover{background:rgba(167,139,250,.16); border-color:rgba(167,139,250,.55)}
    .canvasGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
      margin-top:10px;
    }
    figure{
      margin:0;
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      border-radius:18px;
      overflow:hidden;
    }
    figcaption{
      padding:10px 12px;
      border-top:1px solid var(--line);
      color:var(--muted);
      font-size:.9rem;
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
    }
    .small canvas{height:280px}
    .hr{
      height:1px;
      background:var(--line);
      margin:12px 0;
    }
    footer{
      max-width:1180px;
      margin:0 auto;
      padding:0 18px 40px;
      color:var(--muted);
      font-size:.92rem;
    }
    /* Print-friendly */
    @media print{
      body{background:#fff; color:#000}
      main{grid-template-columns:1fr}
      .toc{display:none}
      section, article, figure{box-shadow:none; background:#fff; border-color:#bbb}
      .copyBtn, .btnRow{display:none !important}
      canvas{display:none !important}
      figcaption{border-top:none}
    }
  </style>
</head>
<body>
  <header>
    <div class="topbar">
      <div class="titleblock">
        <h1>Design of an Optical Fourier-Transform System: Choosing the Lens Focal Length</h1>
        <p class="subtitle">
          How a thin lens maps object spatial frequencies to positions in the Fourier (back focal) plane, and how to pick <b>f</b> so two spatial frequencies land a desired distance apart.
        </p>
        <div class="badgeRow">
          <span class="badge">Topic: <b>Fourier optics</b></span>
          <span class="badge">Key map: <b>x = f λ f<sub>x</sub></b></span>
          <span class="badge">Given: <b>λ = 488 nm</b></span>
          <span class="badge">Range: <b>20–200 lines/mm</b></span>
          <span class="badge">Target spacing: <b>9 cm</b></span>
        </div>
      </div>
      <div class="card" style="min-width:260px; max-width:340px;">
        <h3 style="margin:0 0 6px;">Quick Summary</h3>
        <ul style="margin:8px 0 0 18px;">
          <li>A thin lens forms a Fourier transform at its back focal plane.</li>
          <li>Spatial frequency <span class="muted">f<sub>x</sub></span> maps to position <span class="muted">x = f λ f<sub>x</sub></span>.</li>
          <li>Separation in the Fourier plane is <span class="muted">Δx = f λ Δf</span>.</li>
          <li>Here <span class="muted">Δf = (200−20) lines/mm</span> = <span class="muted">180,000 m⁻¹</span>.</li>
          <li>Required focal length: <b>f ≈ 1.02 m</b> to get <b>Δx = 9 cm</b>.</li>
        </ul>
      </div>
    </div>
  </header>

  <main>
    <nav class="toc" aria-label="Table of contents">
      <h2>Table of Contents</h2>
      <a href="#interactive">Interactive Visuals & Controls</a>
      <a href="#part1">PART 1 — Problem Analysis</a>
      <a href="#part2">PART 2 — Strategy & Tips</a>
      <a href="#part3">PART 3 — Full Solution</a>
      <a href="#checks">Sanity Checks</a>
      <a href="#wrapup">Wrap-up</a>
    </nav>

    <div class="content">
      <section id="interactive">
        <h2>Interactive Visuals & Controls</h2>
        <p class="muted">
          Use the controls to change wavelength, spatial-frequency range, and target separation. All plots update live.
          The “Set f to required” button sets the focal length to the computed value for your current inputs.
        </p>

        <div class="controls">
          <div class="card">
            <h3 style="margin-top:0;">Inputs (edit & explore)</h3>

            <div class="ctrlRow">
              <div>
                <label for="lamNm">Wavelength λ (nm)</label>
                <input id="lamNm" type="range" min="400" max="700" step="1" value="488" />
                <div class="muted"><span id="lamNmVal">488</span> nm</div>
              </div>
              <div>
                <label for="sepCm">Desired separation Δx (cm)</label>
                <input id="sepCm" type="range" min="1" max="20" step="0.1" value="9" />
                <div class="muted"><span id="sepCmVal">9.0</span> cm</div>
              </div>
            </div>

            <div class="ctrlRow" style="margin-top:10px;">
              <div>
                <label for="fminLmm">Lowest spatial frequency f<sub>min</sub> (lines/mm)</label>
                <input id="fminLmm" type="number" step="1" value="20" />
              </div>
              <div>
                <label for="fmaxLmm">Highest spatial frequency f<sub>max</sub> (lines/mm)</label>
                <input id="fmaxLmm" type="number" step="1" value="200" />
              </div>
            </div>

            <div class="ctrlRow" style="margin-top:10px;">
              <div style="grid-column:1/-1;">
                <label for="fLens">Lens focal length f (m) — for plotting/diagram</label>
                <input id="fLens" type="range" min="0.1" max="2.5" step="0.001" value="1.0246" />
                <div class="muted"><span id="fLensVal">1.0246</span> m</div>
              </div>
            </div>

            <div class="btnRow">
              <button class="action" id="setRequired">Set f to required</button>
              <button class="action secondary" id="resetDefaults">Reset to problem values</button>
            </div>

            <div class="kpi">
              <div class="k">
                <div class="label">Computed required focal length</div>
                <div class="value"><span id="fReqVal">—</span> m</div>
              </div>
              <div class="k">
                <div class="label">Current separation with chosen f</div>
                <div class="value"><span id="sepNowVal">—</span> cm</div>
              </div>
            </div>

            <div class="box">
              <strong>Mapping used in all visuals:</strong>
              <div class="eq" style="margin:10px 0 0;">
                <button class="copyBtn" data-copy="eq-map">Copy</button>
                <pre id="eq-map">x = f · λ · f_x
Δx = f · λ · (f_max − f_min)</pre>
              </div>
              <span class="copyState" id="copyState" aria-live="polite"></span>
            </div>
          </div>

          <div class="card">
            <h3 style="margin-top:0;">What you’re seeing</h3>
            <ul>
              <li><b>Diagram:</b> lens + Fourier plane with two “spots” at positions for <span class="muted">f<sub>min</sub></span> and <span class="muted">f<sub>max</sub></span>.</li>
              <li><b>Main plot:</b> linear relationship <span class="muted">x(f<sub>x</sub>)</span> and the two marked frequencies.</li>
              <li><b>Secondary plot:</b> how separation <span class="muted">Δx</span> changes with focal length (a parameter sweep).</li>
            </ul>
            <div class="hr"></div>
            <p class="muted">
              Note: The problem gives fixed numbers; the controls are for intuition and checking.
            </p>
          </div>
        </div>

        <div class="canvasGrid">
          <figure>
            <canvas id="diagCanvas" aria-label="Labeled diagram of lens Fourier-transform geometry"></canvas>
            <figcaption><b>Diagram:</b> Thin lens producing a Fourier transform at the back focal plane; two spatial frequencies map to two positions separated by Δx.</figcaption>
          </figure>

          <figure>
            <canvas id="mainPlot" aria-label="Main plot of Fourier-plane position versus spatial frequency"></canvas>
            <figcaption><b>Main plot:</b> Fourier-plane position <span class="muted">x = f λ f<sub>x</sub></span> vs spatial frequency <span class="muted">f<sub>x</sub></span> (lines/mm).</figcaption>
          </figure>

          <figure class="small">
            <canvas id="sweepPlot" aria-label="Secondary plot sweeping focal length versus separation"></canvas>
            <figcaption><b>Secondary plot:</b> Separation <span class="muted">Δx</span> vs focal length <span class="muted">f</span>, with markers for chosen <span class="muted">f</span> and required <span class="muted">f</span>.</figcaption>
          </figure>
        </div>
      </section>

      <article id="part1">
        <h2>PART 1 — Problem Analysis (no solving yet)</h2>

        <h3>Restate the problem</h3>
        <p>
          A lens is used as a Fourier-transform lens: it produces the Fourier spectrum of a 2D object in its back focal plane.
          The object contains spatial frequencies between <b>20</b> and <b>200</b> lines/mm. Using light of wavelength
          <b>λ = 488 nm</b>, choose the lens focal length <b>f</b> so that the Fourier-plane locations corresponding to the
          lowest and highest spatial frequencies are separated by <b>9 cm</b>.
        </p>

        <h3>Given quantities</h3>
        <ul>
          <li>Wavelength: <b>λ = 488 nm</b></li>
          <li>Spatial frequency range: <b>f<sub>min</sub> = 20 lines/mm</b>, <b>f<sub>max</sub> = 200 lines/mm</b></li>
          <li>Desired separation in Fourier plane: <b>Δx = 9 cm</b></li>
        </ul>

        <h3>Unknowns</h3>
        <ul>
          <li>Lens focal length <b>f</b> (meters)</li>
        </ul>

        <h3>What must be found</h3>
        <p>
          Find <b>f</b> such that the distance between the Fourier-plane points for <span class="muted">f<sub>min</sub></span> and
          <span class="muted">f<sub>max</sub></span> equals <span class="muted">Δx = 9 cm</span>.
        </p>

        <h3>Relevant physical principles (and why they apply)</h3>
        <ul>
          <li>
            <b>Fourier transform property of a thin lens:</b> under paraxial conditions, the complex field in the back focal plane of a lens
            is proportional to the Fourier transform of the field at the front focal plane. This is the standard “optical Fourier transform.”
          </li>
          <li>
            <b>Spatial-frequency-to-position mapping:</b> a plane-wave component at angle θ focuses to a point at transverse position
            <span class="muted">x ≈ f θ</span>. Spatial frequency relates to angle by <span class="muted">sinθ ≈ θ ≈ λ f<sub>x</sub></span>,
            giving <span class="muted">x = f λ f<sub>x</sub></span>.
          </li>
        </ul>

        <h3>Possible approaches (compare briefly)</h3>
        <ul>
          <li>
            <b>Direct mapping approach (best):</b> use <span class="muted">x = f λ f<sub>x</sub></span>, compute positions for
            <span class="muted">f<sub>min</sub></span> and <span class="muted">f<sub>max</sub></span>, set their difference to 9 cm.
            Fast, minimal assumptions, and exactly fits the question.
          </li>
          <li>
            <b>Angle-based approach:</b> convert spatial frequency to diffraction angle via <span class="muted">θ ≈ λ f<sub>x</sub></span>,
            then use <span class="muted">x = f θ</span> and difference angles. Equivalent to the direct mapping, just one extra step.
          </li>
          <li>
            <b>k-space approach:</b> use transverse wavevector <span class="muted">k<sub>x</sub> = 2π f<sub>x</sub></span> and
            relate to focal-plane coordinates. More advanced than needed here.
          </li>
        </ul>

        <h3>Chosen approach</h3>
        <p>
          We use the <b>direct mapping</b> <span class="muted">x = f λ f<sub>x</sub></span> because it directly connects the given spatial
          frequencies to the measured separation in the Fourier plane with the fewest steps and the clearest unit handling.
        </p>
      </article>

      <article id="part2">
        <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

        <h3>Plan (5–10 steps)</h3>
        <ol>
          <li>
            <b>Goal:</b> connect spatial frequency to Fourier-plane position.<br />
            <span class="muted">Tool:</span> lens Fourier mapping <span class="muted">x = f λ f<sub>x</sub></span>.
          </li>
          <li>
            <b>Goal:</b> write expressions for <span class="muted">x<sub>min</sub></span> and <span class="muted">x<sub>max</sub></span>.<br />
            <span class="muted">Tool:</span> substitute <span class="muted">f<sub>min</sub></span>, <span class="muted">f<sub>max</sub></span>.
          </li>
          <li>
            <b>Goal:</b> express the separation <span class="muted">Δx</span> in terms of <span class="muted">f</span>.<br />
            <span class="muted">Tool:</span> <span class="muted">Δx = x<sub>max</sub> − x<sub>min</sub> = f λ (f<sub>max</sub> − f<sub>min</sub>)</span>.
          </li>
          <li>
            <b>Goal:</b> solve for the focal length <span class="muted">f</span> symbolically.<br />
            <span class="muted">Tool:</span> algebraic rearrangement.
          </li>
          <li>
            <b>Goal:</b> convert units carefully (lines/mm → m⁻¹; nm → m; cm → m).<br />
            <span class="muted">Tool:</span> dimensional analysis.
          </li>
          <li>
            <b>Goal:</b> compute the numerical focal length and present the result clearly.<br />
            <span class="muted">Tool:</span> arithmetic + rounding.
          </li>
          <li>
            <b>Goal:</b> sanity-check units and physical reasonableness (larger f gives larger separation).<br />
            <span class="muted">Tool:</span> scaling/limiting behavior.
          </li>
        </ol>

        <h3>Common mistakes & quick tips</h3>
        <ul>
          <li><b>Unit trap:</b> “lines/mm” is a spatial frequency. Convert to <b>m⁻¹</b> before using SI formulas.</li>
          <li><b>Mixing cm and m:</b> convert <b>9 cm → 0.09 m</b> early to avoid slips.</li>
          <li><b>Using 2π incorrectly:</b> the mapping here uses spatial frequency in <b>cycles per meter</b>, not radians per meter—so no 2π is needed.</li>
          <li><b>Interpretation:</b> in 2D, the mapping applies component-wise; the “separation” asked is along the axis corresponding to the frequency difference.</li>
        </ul>
      </article>

      <article id="part3">
        <h2>PART 3 — Full Solution</h2>

        <h3>Physical intuition first</h3>
        <p>
          A larger focal length “spreads out” angles more: points in the Fourier plane lie at <span class="muted">x ≈ f θ</span>.
          Since spatial frequency corresponds to propagation angle (higher spatial frequency → larger angle),
          increasing <span class="muted">f</span> increases the spacing between low- and high-frequency components.
          So we expect <span class="muted">f</span> to scale like <span class="muted">Δx</span> divided by <span class="muted">λ Δf</span>.
        </p>

        <h3>Step-by-step derivation</h3>

        <p><b>1) Lens Fourier-plane position mapping</b></p>
        <p>
          In Fourier optics (paraxial regime), a spatial frequency component <span class="muted">f<sub>x</sub></span>
          (in cycles per meter) maps to a position <span class="muted">x</span> in the back focal plane:
        </p>

        <div class="eq">
          <button class="copyBtn" data-copy="eq1">Copy</button>
          <pre id="eq1">x = f · λ · f_x</pre>
        </div>

        <p>
          Here:
          <span class="muted">x</span> is in meters, <span class="muted">f</span> is in meters,
          <span class="muted">λ</span> is in meters, and <span class="muted">f<sub>x</sub></span> is in m⁻¹.
        </p>

        <p><b>2) Write the two positions</b></p>
        <div class="eq">
          <button class="copyBtn" data-copy="eq2">Copy</button>
          <pre id="eq2">x_min = f · λ · f_min
x_max = f · λ · f_max</pre>
        </div>

        <p><b>3) Separation in the Fourier plane</b></p>
        <p>
          The required separation is:
        </p>
        <div class="eq">
          <button class="copyBtn" data-copy="eq3">Copy</button>
          <pre id="eq3">Δx = x_max − x_min
    = f · λ · (f_max − f_min)</pre>
        </div>

        <p><b>4) Solve for the focal length</b></p>
        <p>
          Rearranging,
        </p>
        <div class="eq">
          <button class="copyBtn" data-copy="eq4">Copy</button>
          <pre id="eq4">f = Δx / ( λ · (f_max − f_min) )</pre>
        </div>

        <h3>Plug in numbers (with careful unit conversion)</h3>

        <p><b>Convert each given value to SI units</b></p>
        <ul>
          <li>
            Wavelength:
            <span class="muted">λ = 488 nm = 488 × 10⁻⁹ m = 4.88 × 10⁻⁷ m</span>
          </li>
          <li>
            Spatial frequencies:
            <span class="muted">1 line/mm = 1000 lines/m</span>, so
            <span class="muted">20 lines/mm = 20,000 m⁻¹</span>,
            <span class="muted">200 lines/mm = 200,000 m⁻¹</span>
          </li>
          <li>
            Frequency difference:
            <span class="muted">Δf = 200,000 − 20,000 = 180,000 m⁻¹</span>
          </li>
          <li>
            Separation:
            <span class="muted">Δx = 9 cm = 0.09 m</span>
          </li>
        </ul>

        <p><b>Compute f</b></p>
        <div class="eq">
          <button class="copyBtn" data-copy="eq5">Copy</button>
          <pre id="eq5">f = 0.09 / ( (488×10^-9) · (180000) )
  ≈ 1.0246 m</pre>
        </div>

        <div class="final">
          <div class="muted">Final (rounded):</div>
          <div class="big">f ≈ 1.02 m</div>
          <div class="eq" style="margin:10px 0 0;">
            <button class="copyBtn" data-copy="finalAnswer">Copy</button>
            <pre id="finalAnswer">Required focal length: f ≈ 1.02 m</pre>
          </div>
        </div>
      </article>

      <article id="checks">
        <h2>Sanity Checks</h2>

        <h3>1) Units</h3>
        <p>
          From <span class="muted">f = Δx / (λ Δf)</span>:
          <span class="muted">Δx</span> is m, <span class="muted">λ</span> is m, <span class="muted">Δf</span> is m⁻¹, so
          <span class="muted">λ Δf</span> is dimensionless and <span class="muted">f</span> comes out in meters. ✔️
        </p>

        <h3>2) Limiting behavior</h3>
        <ul>
          <li>If <span class="muted">λ</span> increases (redder light), the same spatial frequencies spread more, so required <span class="muted">f</span> should decrease. The formula gives <span class="muted">f ∝ 1/λ</span>. ✔️</li>
          <li>If the frequency range widens (larger <span class="muted">Δf</span>), the spots naturally separate more, so required <span class="muted">f</span> should decrease. The formula gives <span class="muted">f ∝ 1/Δf</span>. ✔️</li>
          <li>If you demand a larger separation <span class="muted">Δx</span>, required <span class="muted">f</span> should increase. The formula gives <span class="muted">f ∝ Δx</span>. ✔️</li>
        </ul>

        <h3>3) Physical interpretation</h3>
        <p>
          A focal length around 1 meter is plausible for a bench-top Fourier optics setup when you want centimeter-scale spacing
          between frequency components at visible wavelengths, especially for relatively high spatial frequencies like
          <span class="muted">200 lines/mm</span>.
        </p>
      </article>

      <article id="wrapup">
        <h2>Wrap-up</h2>
        <p>
          The key idea is that a Fourier-transform lens maps spatial frequencies to physical positions in the back focal plane,
          with a simple linear rule: <span class="muted">x = f λ f<sub>x</sub></span>. Setting the desired separation between
          <span class="muted">f<sub>min</sub></span> and <span class="muted">f<sub>max</sub></span> immediately yields
          <span class="muted">f = Δx / (λ (f<sub>max</sub>−f<sub>min</sub>))</span>, giving <b>f ≈ 1.02 m</b> for this problem.
        </p>
      </article>
    </div>
  </main>

  <footer>
    <div class="hr"></div>
    <p>
      Built with vanilla HTML/CSS/JS. Interactive figures are educational aids; the numerical solution uses the exact values from the prompt.
    </p>
  </footer>

  <script>
    (function(){
      // ---------- Helpers ----------
      const $ = (id)=>document.getElementById(id);

      function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

      function fmt(x, digits=3){
        if(!isFinite(x)) return "—";
        const ax = Math.abs(x);
        if(ax !== 0 && (ax < 1e-3 || ax >= 1e4)) return x.toExponential(digits);
        return x.toFixed(digits);
      }

      function niceTicks(min, max, targetTicks){
        // Simple tick generator (linear), returns {ticks, step, start}
        const span = max - min;
        if(span <= 0 || !isFinite(span)) return {ticks:[min], step:1, start:min};
        const raw = span / Math.max(2, targetTicks);
        const pow = Math.pow(10, Math.floor(Math.log10(raw)));
        const mults = [1,2,5,10];
        let step = mults[mults.length-1] * pow;
        for(const m of mults){
          const s = m * pow;
          if(raw <= s){ step = s; break; }
        }
        const start = Math.ceil(min/step)*step;
        const ticks = [];
        for(let t=start; t<=max+1e-12; t+=step) ticks.push(t);
        return {ticks, step, start};
      }

      function setCanvasSize(canvas){
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        const w = Math.max(2, Math.floor(rect.width * dpr));
        const h = Math.max(2, Math.floor(rect.height * dpr));
        if(canvas.width !== w || canvas.height !== h){
          canvas.width = w;
          canvas.height = h;
        }
        const ctx = canvas.getContext('2d');
        ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
        return {ctx, wCSS: rect.width, hCSS: rect.height, dpr};
      }

      function drawAxes(ctx, x0, y0, w, h, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
        // Background
        ctx.save();
        ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);

        // Title
        ctx.fillStyle = "rgba(233,236,255,0.95)";
        ctx.font = "700 14px ui-sans-serif, system-ui";
        ctx.fillText(title, x0, y0 - 12);

        // Plot area
        ctx.strokeStyle = "rgba(255,255,255,0.14)";
        ctx.lineWidth = 1;
        ctx.strokeRect(x0, y0, w, h);

        // Grid + ticks
        const xTicks = niceTicks(xMin, xMax, 6).ticks;
        const yTicks = niceTicks(yMin, yMax, 5).ticks;

        ctx.font = "12px ui-sans-serif, system-ui";
        ctx.fillStyle = "rgba(185,192,255,0.95)";
        ctx.strokeStyle = "rgba(255,255,255,0.08)";

        // X grid/ticks
        for(const xt of xTicks){
          const x = x0 + (xt - xMin)/(xMax - xMin) * w;
          ctx.beginPath();
          ctx.moveTo(x, y0);
          ctx.lineTo(x, y0 + h);
          ctx.stroke();

          ctx.strokeStyle = "rgba(255,255,255,0.14)";
          ctx.beginPath();
          ctx.moveTo(x, y0 + h);
          ctx.lineTo(x, y0 + h + 6);
          ctx.stroke();
          ctx.strokeStyle = "rgba(255,255,255,0.08)";

          const s = (Math.abs(xt) >= 1000) ? xt.toFixed(0) : (Math.abs(xt) >= 10 ? xt.toFixed(1) : xt.toFixed(2));
          ctx.fillText(s, x - 10, y0 + h + 18);
        }

        // Y grid/ticks
        for(const yt of yTicks){
          const y = y0 + h - (yt - yMin)/(yMax - yMin) * h;
          ctx.beginPath();
          ctx.moveTo(x0, y);
          ctx.lineTo(x0 + w, y);
          ctx.stroke();

          ctx.strokeStyle = "rgba(255,255,255,0.14)";
          ctx.beginPath();
          ctx.moveTo(x0 - 6, y);
          ctx.lineTo(x0, y);
          ctx.stroke();
          ctx.strokeStyle = "rgba(255,255,255,0.08)";

          const s = (Math.abs(yt) >= 1000) ? yt.toFixed(0) : (Math.abs(yt) >= 10 ? yt.toFixed(1) : yt.toFixed(2));
          ctx.fillText(s, x0 - 44, y + 4);
        }

        // Labels
        ctx.fillStyle = "rgba(233,236,255,0.90)";
        ctx.font = "600 12px ui-sans-serif, system-ui";
        ctx.fillText(xLabel, x0 + w - ctx.measureText(xLabel).width, y0 + h + 36);

        ctx.save();
        ctx.translate(x0 - 58, y0 + 10);
        ctx.rotate(-Math.PI/2);
        ctx.fillText(yLabel, 0, 0);
        ctx.restore();

        ctx.restore();

        // return mapping functions
        const xToPx = (x)=> x0 + (x - xMin)/(xMax - xMin) * w;
        const yToPx = (y)=> y0 + h - (y - yMin)/(yMax - yMin) * h;
        return {xToPx, yToPx};
      }

      function drawLegend(ctx, x, y, items){
        ctx.save();
        ctx.font = "12px ui-sans-serif, system-ui";
        let yy = y;
        for(const it of items){
          ctx.fillStyle = it.color;
          ctx.fillRect(x, yy-9, 14, 8);
          ctx.fillStyle = "rgba(233,236,255,0.92)";
          ctx.fillText(it.label, x + 20, yy-2);
          yy += 16;
        }
        ctx.restore();
      }

      // ---------- State ----------
      const state = {
        lamNm: 488,
        sepCm: 9.0,
        fminLmm: 20,
        fmaxLmm: 200,
        fLens: 1.0246
      };

      function compute(){
        const lam = state.lamNm * 1e-9;      // m
        const dx = state.sepCm * 1e-2;       // m
        const fmin = state.fminLmm * 1000;   // m^-1
        const fmax = state.fmaxLmm * 1000;   // m^-1
        const df = (fmax - fmin);
        const fReq = dx / (lam * df);
        const dxNow = state.fLens * lam * df; // m
        const xMin = state.fLens * lam * fmin;
        const xMax = state.fLens * lam * fmax;
        return {lam, dx, fmin, fmax, df, fReq, dxNow, xMin, xMax};
      }

      // ---------- Drawing: Diagram ----------
      function drawDiagram(){
        const canvas = $("diagCanvas");
        const {ctx, wCSS, hCSS} = setCanvasSize(canvas);
        const W = wCSS, H = hCSS;
        ctx.clearRect(0,0,W,H);

        const m = compute();

        // Layout in CSS pixels
        const pad = 18;
        const midY = H*0.56;
        const lensX = W*0.36;
        const planeX = W*0.78;

        // Title
        ctx.fillStyle = "rgba(233,236,255,0.95)";
        ctx.font = "700 14px ui-sans-serif, system-ui";
        ctx.fillText("Diagram: Lens Fourier mapping to the back focal plane", pad, pad+6);

        // Optical axis
        ctx.strokeStyle = "rgba(255,255,255,0.20)";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(pad, midY);
        ctx.lineTo(W-pad, midY);
        ctx.stroke();

        // Lens (vertical curved line)
        ctx.strokeStyle = "rgba(125,211,252,0.85)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(lensX, midY - 92);
        ctx.quadraticCurveTo(lensX - 14, midY, lensX, midY + 92);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(lensX, midY - 92);
        ctx.quadraticCurveTo(lensX + 14, midY, lensX, midY + 92);
        ctx.stroke();

        ctx.fillStyle = "rgba(185,192,255,0.92)";
        ctx.font = "600 12px ui-sans-serif, system-ui";
        ctx.fillText("Lens", lensX - 16, midY - 104);

        // Fourier plane line
        ctx.strokeStyle = "rgba(167,139,250,0.85)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(planeX, midY - 112);
        ctx.lineTo(planeX, midY + 112);
        ctx.stroke();

        ctx.fillStyle = "rgba(185,192,255,0.92)";
        ctx.fillText("Fourier (back focal) plane", planeX - 94, midY - 126);

        // f arrow between lens and plane (approx)
        ctx.strokeStyle = "rgba(255,255,255,0.22)";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(lensX+10, midY-70);
        ctx.lineTo(planeX-10, midY-70);
        ctx.stroke();
        // arrowheads
        ctx.beginPath();
        ctx.moveTo(lensX+10, midY-70);
        ctx.lineTo(lensX+20, midY-75);
        ctx.lineTo(lensX+20, midY-65);
        ctx.closePath();
        ctx.fillStyle = "rgba(255,255,255,0.22)";
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(planeX-10, midY-70);
        ctx.lineTo(planeX-20, midY-75);
        ctx.lineTo(planeX-20, midY-65);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "rgba(185,192,255,0.92)";
        ctx.fillText("f", (lensX+planeX)/2 - 4, midY - 78);

        // Map x positions to diagram scale
        // We'll display two spots at planeX with vertical offsets proportional to xMin/xMax relative to max range.
        const xMin = m.xMin; // meters
        const xMax = m.xMax; // meters
        const range = Math.max(Math.abs(xMin), Math.abs(xMax), 1e-6);
        const scale = 92 / range; // px per meter (just for diagram)
        const yMin = midY - xMin * scale;
        const yMax = midY - xMax * scale;

        // Rays from lens to those points (suggestive)
        ctx.strokeStyle = "rgba(125,211,252,0.35)";
        ctx.lineWidth = 1.4;
        ctx.beginPath();
        ctx.moveTo(lensX, midY);
        ctx.lineTo(planeX, yMin);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(lensX, midY);
        ctx.lineTo(planeX, yMax);
        ctx.stroke();

        // Spots
        function spot(y, color, label){
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(planeX, y, 6, 0, Math.PI*2);
          ctx.fill();
          ctx.strokeStyle = "rgba(255,255,255,0.25)";
          ctx.lineWidth = 1;
          ctx.stroke();

          ctx.fillStyle = "rgba(233,236,255,0.92)";
          ctx.font = "600 12px ui-sans-serif, system-ui";
          ctx.fillText(label, planeX + 10, y + 4);
        }
        spot(yMin, "rgba(52,211,153,0.95)", `fmin → x = ${fmt(xMin,4)} m`);
        spot(yMax, "rgba(251,191,36,0.95)", `fmax → x = ${fmt(xMax,4)} m`);

        // Separation bracket
        const yTop = Math.min(yMin, yMax);
        const yBot = Math.max(yMin, yMax);
        ctx.strokeStyle = "rgba(255,255,255,0.30)";
        ctx.lineWidth = 1.4;
        ctx.beginPath();
        ctx.moveTo(planeX + 56, yTop);
        ctx.lineTo(planeX + 56, yBot);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(planeX + 50, yTop);
        ctx.lineTo(planeX + 62, yTop);
        ctx.moveTo(planeX + 50, yBot);
        ctx.lineTo(planeX + 62, yBot);
        ctx.stroke();
        ctx.fillStyle = "rgba(233,236,255,0.92)";
        ctx.fillText(`Δx ≈ ${fmt(m.dxNow*100,2)} cm (with chosen f)`, planeX + 12, yBot + 22);

        // small note
        ctx.fillStyle = "rgba(185,192,255,0.85)";
        ctx.font = "12px ui-sans-serif, system-ui";
        ctx.fillText("Mapping: x = f λ f_x", pad, H - 16);
      }

      // ---------- Drawing: Main Plot x vs fx ----------
      function drawMainPlot(){
        const canvas = $("mainPlot");
        const {ctx, wCSS, hCSS} = setCanvasSize(canvas);
        const W = wCSS, H = hCSS;

        const m = compute();

        const padL = 64, padR = 18, padT = 44, padB = 54;
        const x0 = padL, y0 = padT, pw = W - padL - padR, ph = H - padT - padB;

        const fminL = Math.min(state.fminLmm, state.fmaxLmm);
        const fmaxL = Math.max(state.fminLmm, state.fmaxLmm);

        const xMinPlot = 0.0; // mm? We'll plot x in mm
        const xMaxPlot = fmaxL * m.lam * state.fLens * 1000; // mm (since x[m]*1000)
        // Create some vertical margin
        const yMin = 0;
        const yMax = Math.max(1, xMaxPlot * 1.05);

        // Axes: horizontal = spatial frequency (lines/mm), vertical = x (mm)
        const map = drawAxes(
          ctx, x0, y0, pw, ph,
          fminL*0.9, fmaxL*1.1,
          yMin, yMax,
          "Spatial frequency f_x (lines/mm)",
          "Fourier-plane position x (mm)",
          "Main plot: x = f λ f_x (linear mapping)"
        );

        // Line: x(fx)
        ctx.save();
        ctx.strokeStyle = "rgba(125,211,252,0.90)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        const n = 160;
        for(let i=0;i<=n;i++){
          const fxL = (fminL*0.9) + (fmaxL*1.1 - fminL*0.9) * (i/n);
          const fx = fxL * 1000; // m^-1
          const xmm = (state.fLens * m.lam * fx) * 1000; // mm
          const px = map.xToPx(fxL);
          const py = map.yToPx(xmm);
          if(i===0) ctx.moveTo(px,py);
          else ctx.lineTo(px,py);
        }
        ctx.stroke();

        // Markers for fmin, fmax
        function marker(fxL, color, label){
          const fx = fxL * 1000;
          const xmm = (state.fLens * m.lam * fx) * 1000;
          const px = map.xToPx(fxL);
          const py = map.yToPx(xmm);

          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(px, py, 5.5, 0, Math.PI*2);
          ctx.fill();
          ctx.strokeStyle = "rgba(255,255,255,0.25)";
          ctx.lineWidth = 1;
          ctx.stroke();

          ctx.fillStyle = "rgba(233,236,255,0.92)";
          ctx.font = "600 12px ui-sans-serif, system-ui";
          ctx.fillText(label, px + 10, py - 8);
        }

        marker(state.fminLmm, "rgba(52,211,153,0.95)", `fmin (${state.fminLmm} l/mm)`);
        marker(state.fmaxLmm, "rgba(251,191,36,0.95)", `fmax (${state.fmaxLmm} l/mm)`);

        // Required focal length line (dashed): show what x would be for required f
        const fReq = m.fReq;
        if(isFinite(fReq) && fReq > 0){
          ctx.setLineDash([6,5]);
          ctx.strokeStyle = "rgba(167,139,250,0.95)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          for(let i=0;i<=n;i++){
            const fxL = (fminL*0.9) + (fmaxL*1.1 - fminL*0.9) * (i/n);
            const fx = fxL * 1000;
            const xmm = (fReq * m.lam * fx) * 1000;
            const px = map.xToPx(fxL);
            const py = map.yToPx(xmm);
            if(i===0) ctx.moveTo(px,py);
            else ctx.lineTo(px,py);
          }
          ctx.stroke();
          ctx.setLineDash([]);
        }

        drawLegend(ctx, x0 + 10, y0 + 22, [
          {color:"rgba(125,211,252,0.90)", label:"Using chosen f (solid)"},
          {color:"rgba(167,139,250,0.90)", label:"Using required f (dashed)"}
        ]);
        ctx.restore();
      }

      // ---------- Drawing: Sweep Plot Δx vs f ----------
      function drawSweepPlot(){
        const canvas = $("sweepPlot");
        const {ctx, wCSS, hCSS} = setCanvasSize(canvas);
        const W = wCSS, H = hCSS;

        const m = compute();

        const padL = 64, padR = 18, padT = 44, padB = 54;
        const x0 = padL, y0 = padT, pw = W - padL - padR, ph = H - padT - padB;

        const fMin = 0.1;
        const fMax = 2.5;

        // Δx = f λ Δf (meters). We'll plot in cm for readability.
        const dxMin = 0;
        const dxMax = Math.max(1, (fMax * m.lam * m.df) * 100 * 1.05);

        const map = drawAxes(
          ctx, x0, y0, pw, ph,
          fMin, fMax,
          dxMin, dxMax,
          "Focal length f (m)",
          "Separation Δx (cm)",
          "Secondary plot: separation vs focal length (parameter sweep)"
        );

        // Sweep curve
        ctx.save();
        ctx.strokeStyle = "rgba(125,211,252,0.90)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        const n = 220;
        for(let i=0;i<=n;i++){
          const f = fMin + (fMax - fMin) * (i/n);
          const dxCm = (f * m.lam * m.df) * 100;
          const px = map.xToPx(f);
          const py = map.yToPx(dxCm);
          if(i===0) ctx.moveTo(px,py);
          else ctx.lineTo(px,py);
        }
        ctx.stroke();

        // Target separation horizontal line
        ctx.setLineDash([6,5]);
        ctx.strokeStyle = "rgba(251,191,36,0.80)";
        ctx.lineWidth = 1.8;
        ctx.beginPath();
        ctx.moveTo(map.xToPx(fMin), map.yToPx(state.sepCm));
        ctx.lineTo(map.xToPx(fMax), map.yToPx(state.sepCm));
        ctx.stroke();
        ctx.setLineDash([]);

        // Marker: chosen f
        function vMarker(f, color, label){
          const dxCm = (f * m.lam * m.df) * 100;
          const px = map.xToPx(f);
          const py = map.yToPx(dxCm);

          ctx.strokeStyle = color;
          ctx.lineWidth = 1.6;
          ctx.beginPath();
          ctx.moveTo(px, y0);
          ctx.lineTo(px, y0 + ph);
          ctx.stroke();

          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(px, py, 5.5, 0, Math.PI*2);
          ctx.fill();
          ctx.strokeStyle = "rgba(255,255,255,0.25)";
          ctx.lineWidth = 1;
          ctx.stroke();

          ctx.fillStyle = "rgba(233,236,255,0.92)";
          ctx.font = "600 12px ui-sans-serif, system-ui";
          ctx.fillText(label, clamp(px + 10, x0 + 8, x0 + pw - 120), clamp(py - 10, y0 + 14, y0 + ph - 10));
        }

        vMarker(state.fLens, "rgba(52,211,153,0.95)", "chosen f");
        if(isFinite(m.fReq) && m.fReq>0 && m.fReq<=fMax*2){
          vMarker(m.fReq, "rgba(167,139,250,0.95)", "required f");
        }

        drawLegend(ctx, x0 + 10, y0 + 22, [
          {color:"rgba(125,211,252,0.90)", label:"Δx(f) = f λ Δf"},
          {color:"rgba(251,191,36,0.85)", label:"Target Δx (horizontal)"},
          {color:"rgba(52,211,153,0.95)", label:"Chosen f marker"},
          {color:"rgba(167,139,250,0.95)", label:"Required f marker"}
        ]);
        ctx.restore();
      }

      // ---------- UI updates ----------
      function syncUI(){
        $("lamNmVal").textContent = String(state.lamNm);
        $("sepCmVal").textContent = state.sepCm.toFixed(1);
        $("fLensVal").textContent = fmt(state.fLens, 4);

        const m = compute();
        $("fReqVal").textContent = fmt(m.fReq, 4);
        $("sepNowVal").textContent = fmt(m.dxNow*100, 2);

        // ensure range order isn't inverted for computations:
        // (We'll allow user to input any order; df uses m.df, which can be negative if inverted.
        // We'll enforce fmax >= fmin in compute via UI guard here.)
        if(state.fmaxLmm < state.fminLmm){
          // Swap to keep consistent and avoid confusing negative df.
          const tmp = state.fminLmm;
          state.fminLmm = state.fmaxLmm;
          state.fmaxLmm = tmp;
          $("fminLmm").value = state.fminLmm;
          $("fmaxLmm").value = state.fmaxLmm;
        }
      }

      function redrawAll(){
        syncUI();
        drawDiagram();
        drawMainPlot();
        drawSweepPlot();
      }

      // ---------- Copy buttons ----------
      function wireCopy(){
        const copyState = $("copyState");
        document.querySelectorAll(".copyBtn").forEach(btn=>{
          btn.addEventListener("click", async ()=>{
            const id = btn.getAttribute("data-copy");
            const el = document.getElementById(id);
            const txt = el ? el.textContent.trim() : "";
            try{
              await navigator.clipboard.writeText(txt);
              copyState.textContent = "Copied to clipboard ✓";
              setTimeout(()=>{ copyState.textContent = ""; }, 1400);
            }catch(e){
              copyState.textContent = "Copy failed (browser blocked clipboard).";
              setTimeout(()=>{ copyState.textContent = ""; }, 1800);
            }
          });
        });
      }

      // ---------- Event wiring ----------
      function wireInputs(){
        $("lamNm").addEventListener("input", (e)=>{ state.lamNm = Number(e.target.value); redrawAll(); });
        $("sepCm").addEventListener("input", (e)=>{ state.sepCm = Number(e.target.value); redrawAll(); });

        $("fminLmm").addEventListener("input", (e)=>{
          const v = Number(e.target.value);
          state.fminLmm = isFinite(v) ? v : state.fminLmm;
          redrawAll();
        });
        $("fmaxLmm").addEventListener("input", (e)=>{
          const v = Number(e.target.value);
          state.fmaxLmm = isFinite(v) ? v : state.fmaxLmm;
          redrawAll();
        });

        $("fLens").addEventListener("input", (e)=>{ state.fLens = Number(e.target.value); redrawAll(); });

        $("setRequired").addEventListener("click", ()=>{
          const m = compute();
          if(isFinite(m.fReq) && m.fReq > 0){
            state.fLens = clamp(m.fReq, Number($("fLens").min), Number($("fLens").max));
            $("fLens").value = String(state.fLens);
            redrawAll();
          }
        });

        $("resetDefaults").addEventListener("click", ()=>{
          state.lamNm = 488;
          state.sepCm = 9.0;
          state.fminLmm = 20;
          state.fmaxLmm = 200;
          // set f to the problem's required focal length:
          const lam = state.lamNm*1e-9;
          const df = (state.fmaxLmm - state.fminLmm) * 1000;
          const dx = state.sepCm*1e-2;
          state.fLens = dx/(lam*df);

          $("lamNm").value = String(state.lamNm);
          $("sepCm").value = String(state.sepCm);
          $("fminLmm").value = String(state.fminLmm);
          $("fmaxLmm").value = String(state.fmaxLmm);
          $("fLens").value = String(state.fLens);
          redrawAll();
        });

        // Resize redraw (debounced)
        let t = null;
        window.addEventListener("resize", ()=>{
          if(t) cancelAnimationFrame(t);
          t = requestAnimationFrame(()=>redrawAll());
        });
      }

      // ---------- Init ----------
      wireCopy();
      wireInputs();
      redrawAll();
    })();
  </script>
</body>
</html>
