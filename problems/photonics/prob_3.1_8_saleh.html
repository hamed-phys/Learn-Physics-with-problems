<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Elliptic Gaussian Beam (Paraxial Helmholtz): Depth of Focus, Divergence, Curvature, Near/Far Field Spot</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#111827;
      --panel2:#0f172a;
      --text:#e5e7eb;
      --muted:#a7b0c0;
      --accent:#60a5fa;
      --accent2:#34d399;
      --warn:#fbbf24;
      --danger:#fb7185;
      --border:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 20% 10%, rgba(96,165,250,.15), transparent 60%),
        radial-gradient(900px 500px at 90% 20%, rgba(52,211,153,.12), transparent 55%),
        radial-gradient(700px 400px at 50% 110%, rgba(251,191,36,.08), transparent 60%),
        var(--bg);
      line-height:1.55;
    }

    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    code, .mono{font-family:var(--mono)}
    .container{
      max-width:1200px;
      margin:0 auto;
      padding:24px 18px 60px;
    }

    header.hero{
      background: linear-gradient(180deg, rgba(17,24,39,.9), rgba(15,23,42,.85));
      border:1px solid var(--border);
      border-radius:18px;
      box-shadow:var(--shadow);
      padding:22px 18px;
      position:relative;
      overflow:hidden;
    }
    header.hero:before{
      content:"";
      position:absolute; inset:-40px;
      background: radial-gradient(600px 220px at 20% 20%, rgba(96,165,250,.18), transparent 60%),
                  radial-gradient(520px 200px at 80% 30%, rgba(52,211,153,.14), transparent 60%);
      filter: blur(2px);
      pointer-events:none;
    }
    header.hero > *{position:relative}
    .title{
      display:flex; gap:14px; align-items:flex-start; flex-wrap:wrap;
    }
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      padding:7px 10px;
      background: rgba(96,165,250,.12);
      border:1px solid rgba(96,165,250,.35);
      color:#cfe6ff;
      border-radius:999px;
      font-size:13px;
      letter-spacing:.2px;
      margin-top:2px;
      white-space:nowrap;
    }
    h1{
      margin:0;
      font-size: clamp(22px, 3.2vw, 34px);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:8px 0 0;
      color:var(--muted);
      max-width:80ch;
    }

    .layout{
      display:grid;
      grid-template-columns: 280px 1fr;
      gap:18px;
      margin-top:18px;
      align-items:start;
    }

    nav.toc{
      position:sticky;
      top:14px;
      background: rgba(17,24,39,.78);
      backdrop-filter: blur(10px);
      border:1px solid var(--border);
      border-radius:16px;
      padding:14px 12px;
      box-shadow: var(--shadow);
    }
    nav.toc h2{
      font-size:13px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color:#cbd5e1;
      margin:0 0 10px;
    }
    .toc a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      color:var(--text);
      opacity:.92;
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:14px;
    }
    .toc a:hover{
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.10);
      transform: translateY(-1px);
      text-decoration:none;
    }
    .toc .small{color:var(--muted); font-size:12px; padding-left:10px; margin-top:8px}

    main{
      min-width:0;
    }

    section.card{
      background: rgba(17,24,39,.78);
      backdrop-filter: blur(10px);
      border:1px solid var(--border);
      border-radius:18px;
      box-shadow: var(--shadow);
      padding:18px 16px;
      margin-bottom:18px;
    }
    section.card h2{
      margin:0 0 12px;
      font-size:20px;
      letter-spacing:.2px;
    }
    section.card h3{
      margin:16px 0 8px;
      font-size:16px;
      color:#dbeafe;
    }
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns: 1fr}
      nav.toc{position:relative; top:auto}
      .grid2,.grid3{grid-template-columns:1fr}
    }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    @media (max-width: 980px){
      .callouts{grid-template-columns:1fr}
    }
    .callout{
      border:1px solid var(--border);
      border-radius:16px;
      padding:12px 12px;
      background: linear-gradient(180deg, rgba(15,23,42,.7), rgba(17,24,39,.55));
    }
    .callout strong{color:#eaf2ff}
    .callout ul{margin:8px 0 0 18px}
    .kpi{
      display:flex; flex-wrap:wrap; gap:10px;
      margin-top:10px;
    }
    .pill{
      border:1px solid rgba(255,255,255,.12);
      border-radius:999px;
      padding:8px 10px;
      background: rgba(255,255,255,.05);
      color:var(--text);
      font-size:13px;
      display:flex; gap:10px; align-items:center;
    }
    .pill span{color:var(--muted)}
    .eqbox{
      background: rgba(2,6,23,.55);
      border:1px solid rgba(96,165,250,.25);
      border-radius:16px;
      padding:12px 12px;
      overflow:auto;
      position:relative;
    }
    .eq{
      font-family:var(--mono);
      font-size: 14px;
      white-space: pre;
      margin:0;
      line-height:1.45;
    }
    .copybar{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    button.btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:9px 10px;
      border-radius:12px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:13px;
    }
    button.btn:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.09);
      border-color: rgba(255,255,255,.20);
    }
    button.btn:active{transform: translateY(0px) scale(.99)}
    button.btn.primary{
      background: rgba(96,165,250,.14);
      border-color: rgba(96,165,250,.35);
      color:#dbeafe;
    }
    .toast{
      position:fixed;
      right:18px; bottom:18px;
      background: rgba(17,24,39,.92);
      border:1px solid rgba(255,255,255,.14);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      box-shadow: var(--shadow);
      opacity:0;
      transform: translateY(8px);
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      font-size:13px;
    }
    .toast.show{opacity:1; transform: translateY(0px)}
    .controls{
      display:grid;
      grid-template-columns: 1.1fr 1fr 1fr;
      gap:10px;
      margin-top:10px;
      align-items:end;
    }
    @media (max-width: 980px){
      .controls{grid-template-columns:1fr}
    }
    .control{
      border:1px solid var(--border);
      border-radius:16px;
      padding:10px 10px;
      background: rgba(255,255,255,.04);
    }
    .control label{
      display:block;
      color:#cbd5e1;
      font-size:13px;
      margin-bottom:8px;
    }
    .row{
      display:flex; justify-content:space-between; gap:10px; align-items:center;
      flex-wrap:wrap;
    }
    input[type="range"]{width:100%}
    input[type="number"]{
      width:120px;
      background: rgba(2,6,23,.6);
      border:1px solid rgba(255,255,255,.14);
      border-radius:10px;
      padding:7px 8px;
      color:var(--text);
      font-family: var(--mono);
      font-size:13px;
    }
    select{
      width:100%;
      background: rgba(2,6,23,.6);
      border:1px solid rgba(255,255,255,.14);
      border-radius:10px;
      padding:8px 10px;
      color:var(--text);
      font-size:13px;
    }

    figure{
      margin:12px 0 0;
      border:1px solid var(--border);
      border-radius:18px;
      background: rgba(2,6,23,.45);
      overflow:hidden;
    }
    figcaption{
      padding:10px 12px;
      color:var(--muted);
      font-size:13px;
      border-top:1px solid rgba(255,255,255,.08);
    }
    canvas{
      width:100%;
      height:360px;
      display:block;
      background: rgba(2,6,23,.35);
    }
    .canvasTall canvas{height:420px}
    .canvasWide canvas{height:420px}
    .twoCanv{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      padding:12px;
    }
    .twoCanv > div{
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      overflow:hidden;
      background: rgba(2,6,23,.32);
    }
    .twoCanv canvas{height:320px}
    @media (max-width: 980px){
      .twoCanv{grid-template-columns:1fr}
      .twoCanv canvas{height:340px}
    }

    .boxFinal{
      border:1px solid rgba(52,211,153,.35);
      background: rgba(52,211,153,.08);
      border-radius:18px;
      padding:14px 14px;
      margin-top:12px;
    }
    .boxFinal h3{margin:0 0 8px; color:#bbf7d0}
    .boxFinal .eqbox{border-color: rgba(52,211,153,.35)}
    .printHint{
      color:var(--muted);
      font-size:12px;
      margin-top:10px;
    }

    footer{
      margin-top:18px;
      color:var(--muted);
      font-size:12px;
      text-align:center;
    }

    /* subtle entry */
    .fadeIn{
      animation: fadeIn .35s ease both;
    }
    @keyframes fadeIn{
      from{opacity:0; transform: translateY(8px)}
      to{opacity:1; transform: translateY(0)}
    }

    @media print{
      body{background:#fff; color:#000}
      nav.toc{display:none}
      header.hero, section.card{box-shadow:none; background:#fff; border:1px solid #ccc}
      canvas{background:#fff}
      .eqbox{background:#fff}
      button.btn{display:none}
      .toast{display:none}
    }
  </style>
</head>
<body>
  <div class="container">
    <header class="hero fadeIn">
      <div class="title">
        <div class="badge">üì° Paraxial Optics ‚Ä¢ Gaussian Beams</div>
        <div style="min-width:240px; flex:1">
          <h1>The Elliptic Gaussian Beam: Depth of Focus, Divergence, and Curvature</h1>
          <p class="subtitle">
            We start from an elliptical (astigmatic) Gaussian intensity profile at the waist plane <span class="mono">z = 0</span>.
            You‚Äôll derive the two Rayleigh ranges, two divergence angles, and two radii of curvature‚Äîone for each transverse axis‚Äîand
            visualize how a spot that is wide in <span class="mono">x</span> becomes narrow in far-field divergence, and vice-versa.
          </p>
        </div>
      </div>

      <section class="card" style="margin:14px 0 0; background:rgba(2,6,23,.22)">
        <h2 id="quick-summary">Quick Summary</h2>
        <ul>
          <li>At <span class="mono">z=0</span>: <span class="mono">I(x,y,0)=I0 exp[-2(x¬≤/W0x¬≤ + y¬≤/W0y¬≤)]</span> ‚Üí elliptical contours.</li>
          <li>Two independent Rayleigh ranges (depths of focus): <span class="mono">zRx = œÄ W0x¬≤/Œª</span>, <span class="mono">zRy = œÄ W0y¬≤/Œª</span>.</li>
          <li>Beam radii: <span class="mono">Wx(z)=W0x ‚àö(1+(z/zRx)¬≤)</span>, <span class="mono">Wy(z)=W0y ‚àö(1+(z/zRy)¬≤)</span>.</li>
          <li>Far-field half-angles (1/e¬≤): <span class="mono">Œ∏x = Œª/(œÄ W0x)</span>, <span class="mono">Œ∏y = Œª/(œÄ W0y)</span>.</li>
          <li>Wavefront curvature: <span class="mono">Rx(z)=z[1+(zRx/z)¬≤]</span>, <span class="mono">Ry(z)=z[1+(zRy/z)¬≤]</span>.</li>
          <li>If <span class="mono">W0x=2W0y</span>: waist spot is stretched in <span class="mono">x</span>, but far-field spot is stretched in <span class="mono">y</span>.</li>
        </ul>
      </section>
    </header>

    <div class="layout">
      <nav class="toc fadeIn" aria-label="Table of contents">
        <h2>Contents</h2>
        <a href="#quick-summary">Quick Summary</a>
        <a href="#part1">Part 1 ‚Äî Problem Analysis</a>
        <a href="#part2">Part 2 ‚Äî Strategy & Tips</a>
        <a href="#part3">Part 3 ‚Äî Full Solution</a>
        <a href="#viz">Interactive Visualizations</a>
        <div class="small">Tip: use the sliders to update all plots.</div>
      </nav>

      <main class="fadeIn">
        <!-- PART 1 -->
        <section class="card" id="part1">
          <h2>PART 1 ‚Äî Problem Analysis (no solving yet)</h2>

          <h3>1) Restate the problem (in my own words)</h3>
          <p>
            A paraxial (Helmholtz) Gaussian beam has an <em>elliptical</em> intensity distribution at the waist plane <span class="mono">z=0</span>:
            <span class="mono">I(x,y,0)=|A0|¬≤ exp[-2(x¬≤/W0x¬≤ + y¬≤/W0y¬≤)]</span>.
            The waist radii in the transverse directions are <span class="mono">W0x</span> and <span class="mono">W0y</span>, so constant-intensity contours are ellipses.
            We must write expressions for:
            <strong>(i)</strong> beam depth of focus (Rayleigh range) in <span class="mono">x</span> and <span class="mono">y</span>,
            <strong>(ii)</strong> angular divergence in <span class="mono">x</span> and <span class="mono">y</span>,
            <strong>(iii)</strong> radius of curvature of the wavefront in <span class="mono">x</span> and <span class="mono">y</span>,
            all as functions of <span class="mono">W0x, W0y</span> and wavelength <span class="mono">Œª</span>.
            Finally, for <span class="mono">W0x = 2 W0y</span>, we should sketch the beam spot at <span class="mono">z=0</span> and in the far field.
          </p>

          <div class="callouts">
            <div class="callout">
              <strong>Given quantities</strong>
              <ul>
                <li>Wavelength: <span class="mono">Œª</span></li>
                <li>Waist radii: <span class="mono">W0x</span>, <span class="mono">W0y</span></li>
                <li>Waist plane intensity: <span class="mono">I(x,y,0)=|A0|¬≤ exp[-2(x¬≤/W0x¬≤ + y¬≤/W0y¬≤)]</span></li>
              </ul>
            </div>
            <div class="callout">
              <strong>Unknowns to find</strong>
              <ul>
                <li>Depth of focus (Rayleigh range): <span class="mono">zRx</span>, <span class="mono">zRy</span></li>
                <li>Divergence half-angles (1/e¬≤): <span class="mono">Œ∏x</span>, <span class="mono">Œ∏y</span></li>
                <li>Radii of curvature: <span class="mono">Rx(z)</span>, <span class="mono">Ry(z)</span></li>
                <li>Near- and far-field spot shapes for <span class="mono">W0x=2W0y</span></li>
              </ul>
            </div>
          </div>

          <h3>2) Relevant principles and why they apply</h3>
          <ul>
            <li>
              <strong>Paraxial Helmholtz (paraxial wave equation):</strong>
              Gaussian beams are exact solutions under the paraxial approximation, and propagation preserves Gaussian form.
              Here, anisotropy means the beam factorizes into independent Gaussian evolutions along <span class="mono">x</span> and <span class="mono">y</span>.
            </li>
            <li>
              <strong>Rayleigh range and diffraction:</strong>
              The longitudinal scale over which diffraction doubles the beam area differs in each axis because it depends on <span class="mono">W0¬≤</span>.
            </li>
            <li>
              <strong>Fourier optics / far-field relation:</strong>
              The far-field angular distribution is essentially the Fourier transform of the waist field.
              A larger waist in one direction means a narrower angular spread in that direction.
            </li>
          </ul>

          <h3>3) Possible approaches (compare briefly)</h3>
          <ol>
            <li>
              <strong>Direct separation of variables:</strong> treat the field as a product of two 1D Gaussian beam solutions
              with different waists ‚Üí yields <span class="mono">zR</span>, <span class="mono">W(z)</span>, and <span class="mono">R(z)</span> immediately.
            </li>
            <li>
              <strong>ABCD matrix (q-parameter) in each axis:</strong> define <span class="mono">qx</span>, <span class="mono">qy</span> and use Gaussian beam optics
              to propagate ‚Üí elegant and general.
            </li>
            <li>
              <strong>Fraunhofer (Fourier) far-field derivation:</strong> compute the angular spectrum of the waist Gaussian ‚Üí directly gives divergences.
            </li>
          </ol>

          <p>
            <strong>Best choice:</strong> use the <em>Gaussian beam q-parameter / separated-axis</em> approach.
            It produces all requested quantities (Rayleigh ranges, divergences, curvature) in a unified way, and the far-field
            behavior falls out as a limiting case.
          </p>
        </section>

        <!-- PART 2 -->
        <section class="card" id="part2">
          <h2>PART 2 ‚Äî Strategy & Tips (roadmap only)</h2>

          <h3>Roadmap (5‚Äì10 steps)</h3>
          <ol>
            <li>
              <strong>Interpret the waist profile</strong> ‚Üí identify <span class="mono">W0x</span>, <span class="mono">W0y</span> as 1/e¬≤ intensity radii.
              <span class="muted">(Tool: Gaussian definition)</span>
            </li>
            <li>
              <strong>Write the separated Gaussian beam form</strong>:
              field envelope as product of an <span class="mono">x</span>-Gaussian and a <span class="mono">y</span>-Gaussian.
              <span class="muted">(Tool: paraxial solution structure)</span>
            </li>
            <li>
              <strong>Define Rayleigh ranges</strong> for each axis:
              <span class="mono">zRx</span>, <span class="mono">zRy</span>.
              <span class="muted">(Tool: standard Gaussian beam parameter)</span>
            </li>
            <li>
              <strong>Obtain beam radii vs z</strong>:
              <span class="mono">Wx(z)</span>, <span class="mono">Wy(z)</span>.
              <span class="muted">(Tool: Gaussian beam evolution)</span>
            </li>
            <li>
              <strong>Read off divergences</strong> from far-field limit <span class="mono">|z|‚â´zR</span>:
              <span class="mono">Wx(z)‚âàŒ∏x|z|</span>, <span class="mono">Wy(z)‚âàŒ∏y|z|</span>.
              <span class="muted">(Tool: asymptotics)</span>
            </li>
            <li>
              <strong>Write radii of curvature</strong> <span class="mono">Rx(z)</span>, <span class="mono">Ry(z)</span>.
              <span class="muted">(Tool: wavefront phase of Gaussian beam)</span>
            </li>
            <li>
              <strong>Specialize to</strong> <span class="mono">W0x=2W0y</span>:
              compare near-field ellipse vs far-field ellipse.
              <span class="muted">(Tool: scaling arguments)</span>
            </li>
          </ol>

          <div class="callouts">
            <div class="callout">
              <strong>Common mistakes</strong>
              <ul>
                <li>Mixing 1/e amplitude radius with 1/e¬≤ intensity radius. (Here <span class="mono">W0</span> is 1/e¬≤ <em>intensity</em> radius.)</li>
                <li>Forgetting that <span class="mono">zR ‚àù W0¬≤</span> (quadratic sensitivity).</li>
                <li>Thinking the far-field spot keeps the same ellipse orientation as the waist; it flips if waists differ.</li>
              </ul>
            </div>
            <div class="callout">
              <strong>Quick tips</strong>
              <ul>
                <li>Use two independent ‚Äú1D Gaussian beams‚Äù: one in <span class="mono">x</span>, one in <span class="mono">y</span>.</li>
                <li>In far field: <span class="mono">Œ∏ ‚âà Œª/(œÄ W0)</span>, and spot size <span class="mono">W(z) ‚âà Œ∏ z</span>.</li>
                <li>Curvature: <span class="mono">R(z)=z + zR¬≤/z</span> (helps check limits).</li>
              </ul>
            </div>
          </div>
        </section>

        <!-- PART 3 -->
        <section class="card" id="part3">
          <h2>PART 3 ‚Äî Full Solution</h2>

          <h3>Physical intuition</h3>
          <p>
            A Gaussian beam ‚Äúdiffracts‚Äù because different transverse spatial frequencies propagate at slightly different angles.
            If the waist is wider in <span class="mono">x</span>, the field varies more slowly in <span class="mono">x</span>,
            so it contains smaller transverse spatial frequencies ‚Üí it spreads less in angle along <span class="mono">x</span>.
            Conversely, a tighter waist in <span class="mono">y</span> means larger transverse frequencies ‚Üí larger angular spread in <span class="mono">y</span>.
            With unequal waists, the beam has two distinct diffraction lengths and two distinct wavefront curvatures.
          </p>

          <h3>Step-by-step derivation</h3>

          <p class="muted">
            Definitions used throughout:
            <span class="mono">Œª</span> is vacuum wavelength (or wavelength in the medium if you interpret <span class="mono">k=2œÄ/Œª</span> accordingly),
            and <span class="mono">W0x, W0y</span> are the 1/e¬≤ intensity waist radii in <span class="mono">x</span>, <span class="mono">y</span>.
          </p>

          <h3>1) Start from the standard Gaussian beam in each transverse axis</h3>
          <p>
            For a circular Gaussian beam, the (1/e¬≤) intensity radius evolves as
            <span class="mono">W(z)=W0 ‚àö(1+(z/zR)¬≤)</span>, where <span class="mono">zR = œÄ W0¬≤ / Œª</span>.
            An <em>elliptic</em> Gaussian waist can be treated as a separable solution:
            each axis behaves like its own Gaussian beam with its own waist size.
          </p>

          <div class="eqbox" role="group" aria-label="Key separated-axis model equation">
<pre class="eq" id="eq-separated">
I(x,y,z) = I0 * exp[-2 x^2 / Wx(z)^2] * exp[-2 y^2 / Wy(z)^2]
with Wx(z) = W0x * sqrt(1 + (z/zRx)^2),  Wy(z) = W0y * sqrt(1 + (z/zRy)^2)
</pre>
          </div>
          <div class="copybar">
            <button class="btn" data-copy="#eq-separated">Copy separated form</button>
          </div>

          <h3>2) Depth of focus (Rayleigh range) in x and y</h3>
          <p>
            The Rayleigh range (often also called ‚Äúdepth of focus‚Äù up to a factor of 2 depending on convention)
            is the distance where <span class="mono">W(z)</span> increases by <span class="mono">‚àö2</span> from its waist value (beam area doubles).
            Therefore, independently:
          </p>

          <div class="eqbox">
<pre class="eq" id="eq-rayleigh">
zRx = œÄ W0x^2 / Œª
zRy = œÄ W0y^2 / Œª
</pre>
          </div>
          <div class="copybar">
            <button class="btn" data-copy="#eq-rayleigh">Copy Rayleigh ranges</button>
          </div>

          <p class="muted">
            Note: Some books define ‚Äúdepth of focus‚Äù as <span class="mono">2 zR</span>. If your course uses that convention, multiply the above by 2.
          </p>

          <h3>3) Angular divergence in x and y</h3>
          <p>
            In the far field <span class="mono">|z| ‚â´ zR</span> we have
            <span class="mono">W(z) ‚âà W0 |z|/zR</span>.
            Using the axis-specific Rayleigh ranges,
          </p>

          <div class="eqbox">
<pre class="eq" id="eq-divergence-derivation">
For |z| >> zRx:  Wx(z) = W0x * sqrt(1 + (z/zRx)^2) ‚âà W0x * |z|/zRx
Define divergence half-angle Œ∏x by Wx(z) ‚âà Œ∏x |z|  ‚áí  Œ∏x = W0x / zRx = Œª/(œÄ W0x)

Similarly: Œ∏y = Œª/(œÄ W0y)
</pre>
          </div>
          <div class="copybar">
            <button class="btn" data-copy="#eq-divergence-derivation">Copy divergence derivation</button>
          </div>

          <h3>4) Radius of curvature in x and y</h3>
          <p>
            The Gaussian beam phase contains a quadratic term <span class="mono">~ (k x¬≤)/(2 R(z))</span>
            associated with spherical wavefront curvature.
            For a standard Gaussian beam,
            <span class="mono">R(z) = z [1 + (zR/z)¬≤] = z + zR¬≤/z</span>.
            In the elliptic case, each axis inherits its own curvature function:
          </p>

          <div class="eqbox">
<pre class="eq" id="eq-curvature">
Rx(z) = z * (1 + (zRx/z)^2) = z + zRx^2 / z
Ry(z) = z * (1 + (zRy/z)^2) = z + zRy^2 / z
</pre>
          </div>
          <div class="copybar">
            <button class="btn" data-copy="#eq-curvature">Copy curvature radii</button>
          </div>

          <h3>5) Special case: W0x = 2 W0y (near field vs far field spot)</h3>
          <p>
            Let <span class="mono">W0x = 2 W0y</span>. Then:
          </p>

          <div class="eqbox">
<pre class="eq" id="eq-special">
zRx / zRy = (W0x^2) / (W0y^2) = (2^2) = 4    ‚áí   zRx = 4 zRy
Œ∏x / Œ∏y = (Œª/(œÄ W0x)) / (Œª/(œÄ W0y)) = W0y/W0x = 1/2   ‚áí   Œ∏x = Œ∏y / 2
</pre>
          </div>
          <div class="copybar">
            <button class="btn" data-copy="#eq-special">Copy special-case scaling</button>
          </div>

          <p>
            <strong>Interpretation:</strong>
            At the waist (<span class="mono">z=0</span>), the spot is an ellipse with semi-axes proportional to <span class="mono">W0x</span> and <span class="mono">W0y</span>,
            so it is stretched along <span class="mono">x</span>.
            In the far field, the spot radii grow like <span class="mono">W(z) ‚âà Œ∏ z</span>.
            Since <span class="mono">Œ∏y</span> is twice <span class="mono">Œ∏x</span>, the far-field ellipse is stretched along <span class="mono">y</span>.
          </p>

          <div class="boxFinal" id="final-results">
            <h3>Final Results (boxed)</h3>

            <div class="eqbox">
<pre class="eq" id="eq-final">
Given waist (z=0):  I(x,y,0) = I0 exp[-2(x^2/W0x^2 + y^2/W0y^2)].

Depth of focus (Rayleigh ranges):
  zRx = œÄ W0x^2 / Œª
  zRy = œÄ W0y^2 / Œª

Beam radii vs z (1/e^2 intensity radii):
  Wx(z) = W0x ‚àö(1 + (z/zRx)^2)
  Wy(z) = W0y ‚àö(1 + (z/zRy)^2)

Far-field divergence half-angles (1/e^2):
  Œ∏x = Œª / (œÄ W0x)
  Œ∏y = Œª / (œÄ W0y)

Radii of curvature:
  Rx(z) = z [1 + (zRx/z)^2] = z + zRx^2 / z
  Ry(z) = z [1 + (zRy/z)^2] = z + zRy^2 / z

If W0x = 2 W0y:
  zRx = 4 zRy,   Œ∏x = Œ∏y/2,
  near-field spot elongated in x, far-field spot elongated in y.
</pre>
            </div>

            <div class="copybar">
              <button class="btn primary" data-copy="#eq-final">Copy final answer</button>
            </div>

            <p class="printHint">These expressions are symbolic; the plots below use clearly labeled example values for visualization.</p>
          </div>

          <h3>Sanity checks</h3>
          <div class="callouts">
            <div class="callout">
              <strong>Units</strong>
              <ul>
                <li><span class="mono">zR</span> has units of length: <span class="mono">W0¬≤/Œª ‚Üí m¬≤/m = m</span>.</li>
                <li><span class="mono">Œ∏</span> is dimensionless (radians): <span class="mono">Œª/W0</span>.</li>
                <li><span class="mono">R(z)</span> has units of length.</li>
              </ul>
            </div>
            <div class="callout">
              <strong>Limiting cases</strong>
              <ul>
                <li>If <span class="mono">W0x=W0y</span>, then <span class="mono">zRx=zRy</span>, <span class="mono">Œ∏x=Œ∏y</span>, <span class="mono">Rx=Ry</span> ‚Üí circular Gaussian beam.</li>
                <li>Near waist (<span class="mono">z‚Üí0</span>): <span class="mono">R(z)‚âàzR¬≤/z ‚Üí ‚àû</span> (plane wavefront at the waist).</li>
                <li>Far field (<span class="mono">|z|‚â´zR</span>): <span class="mono">R(z)‚âàz</span> (wavefront becomes spherical, centered near the waist).</li>
              </ul>
            </div>
          </div>
        </section>

        <!-- Visualizations -->
        <section class="card" id="viz">
          <h2>Interactive Visualizations</h2>
          <p class="muted">
            The sliders below adjust <strong>waist anisotropy</strong> and <strong>wavelength</strong>.
            All plots update live using the same parameters as in the derivation. Units: waists in mm, wavelength in nm.
          </p>

          <div class="controls" aria-label="Interactive controls">
            <div class="control">
              <label for="ratio">Waist ratio r = W0x / W0y</label>
              <div class="row">
                <input id="ratio" type="range" min="0.5" max="3.0" step="0.01" value="2.00" />
                <input id="ratioNum" type="number" min="0.5" max="3.0" step="0.01" value="2.00" />
              </div>
              <div class="muted" style="font-size:12px; margin-top:6px">
                Problem‚Äôs special case is <span class="mono">r = 2</span>.
              </div>
            </div>

            <div class="control">
              <label for="w0y">Example value: W0y (mm)</label>
              <div class="row">
                <input id="w0y" type="range" min="0.10" max="2.00" step="0.01" value="0.50" />
                <input id="w0yNum" type="number" min="0.10" max="2.00" step="0.01" value="0.50" />
              </div>
              <div class="muted" style="font-size:12px; margin-top:6px">
                Sets scale of the plots; final symbolic results don‚Äôt depend on this choice.
              </div>
            </div>

            <div class="control">
              <label for="lambda">Wavelength Œª (nm)</label>
              <div class="row">
                <input id="lambda" type="range" min="400" max="1600" step="1" value="1064" />
                <input id="lambdaNum" type="number" min="400" max="1600" step="1" value="1064" />
              </div>
              <div class="muted" style="font-size:12px; margin-top:6px">
                Changing Œª changes both Rayleigh ranges and divergences.
              </div>
            </div>
          </div>

          <div class="kpi" id="kpi"></div>

          <figure class="canvasTall">
            <canvas id="cDiagram" aria-label="Diagram of elliptic Gaussian beam geometry"></canvas>
            <figcaption>
              Diagram: an elliptical waist at <span class="mono">z=0</span> with independent spreading in <span class="mono">x</span> and <span class="mono">y</span>.
              The ‚Äúhourglass‚Äù widths correspond to <span class="mono">Wx(z)</span> and <span class="mono">Wy(z)</span>.
            </figcaption>
          </figure>

          <figure class="canvasWide">
            <canvas id="cMain" aria-label="Main plot of beam radii vs propagation distance"></canvas>
            <figcaption>
              Main quantitative plot: <span class="mono">Wx(z)</span> and <span class="mono">Wy(z)</span> vs <span class="mono">z</span>, including Rayleigh ranges.
              Far field shows linear growth with slopes equal to divergences <span class="mono">Œ∏x</span>, <span class="mono">Œ∏y</span>.
            </figcaption>
          </figure>

          <figure>
            <div class="twoCanv">
              <div>
                <canvas id="cNear" aria-label="Near-field intensity map at z=0"></canvas>
                <div style="padding:10px 12px; color:var(--muted); font-size:13px; border-top:1px solid rgba(255,255,255,.08)">
                  Secondary plot (left): intensity map at <span class="mono">z=0</span> with elliptical contours.
                </div>
              </div>
              <div>
                <canvas id="cFar" aria-label="Far-field (large z) intensity map"></canvas>
                <div style="padding:10px 12px; color:var(--muted); font-size:13px; border-top:1px solid rgba(255,255,255,.08)">
                  Secondary plot (right): ‚Äúfar field‚Äù intensity map at <span class="mono">z = 5¬∑max(zRx,zRy)</span>.
                  Notice how the ellipse orientation reflects different divergences.
                </div>
              </div>
            </div>
          </figure>

          <div class="copybar">
            <button class="btn" id="btnReset">Reset to r = 2 (problem case)</button>
            <button class="btn" data-copy="#eq-final">Copy final answer again</button>
          </div>
        </section>

        <footer>
          Built with vanilla HTML/CSS/JS. Canvas plots are computed from the symbolic formulas derived above.
        </footer>
      </main>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <script>
    // ---------- Utilities ----------
    function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
    function fmt(x, digits=3){
      if (!isFinite(x)) return "‚Äî";
      const ax = Math.abs(x);
      if (ax !== 0 && (ax < 1e-3 || ax >= 1e4)) return x.toExponential(2);
      return x.toFixed(digits);
    }
    function showToast(msg){
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.classList.add('show');
      clearTimeout(showToast._to);
      showToast._to = setTimeout(()=>t.classList.remove('show'), 1300);
    }
    async function copyText(txt){
      try{
        await navigator.clipboard.writeText(txt);
        showToast("Copied to clipboard");
      }catch(e){
        // fallback
        const ta = document.createElement('textarea');
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        ta.remove();
        showToast("Copied to clipboard");
      }
    }

    function setupHiDPICanvas(canvas){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect.width * dpr));
      const h = Math.max(2, Math.floor(rect.height * dpr));
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {ctx, wCSS: rect.width, hCSS: rect.height, dpr};
    }

    // ---------- Plot helpers ----------
    function drawPanel(ctx, x, y, w, h, title){
      // background
      ctx.save();
      ctx.translate(x,y);
      ctx.fillStyle = "rgba(2,6,23,0.25)";
      ctx.fillRect(0,0,w,h);
      // border
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;
      ctx.strokeRect(0.5,0.5,w-1,h-1);
      // title
      ctx.fillStyle = "rgba(229,231,235,0.92)";
      ctx.font = "600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(title, 10, 18);
      ctx.restore();
    }

    function axisBox(x0,y0,w,h, pad){
      return {
        x0, y0, w, h,
        l: x0+pad, r: x0+w-pad,
        t: y0+pad, b: y0+h-pad
      };
    }

    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, opts={}){
      const {l,r,t,b} = box;
      const grid = opts.grid ?? true;
      const ticks = opts.ticks ?? 6;

      // gridlines + ticks
      ctx.save();
      ctx.lineWidth = 1;

      // grid
      if (grid){
        ctx.strokeStyle = "rgba(255,255,255,0.07)";
        for(let i=0;i<=ticks;i++){
          const u = i/ticks;
          const x = l + u*(r-l);
          const y = t + u*(b-t);
          ctx.beginPath(); ctx.moveTo(x,t); ctx.lineTo(x,b); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(l,y); ctx.lineTo(r,y); ctx.stroke();
        }
      }

      // axes
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.beginPath();
      ctx.moveTo(l,b); ctx.lineTo(r,b);
      ctx.moveTo(l,t); ctx.lineTo(l,b);
      ctx.stroke();

      // tick labels
      ctx.fillStyle = "rgba(229,231,235,0.82)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      for(let i=0;i<=ticks;i++){
        const u = i/ticks;
        const x = l + u*(r-l);
        const y = b - u*(b-t);
        const xv = xMin + u*(xMax-xMin);
        const yv = yMin + u*(yMax-yMin);

        // x ticks
        ctx.strokeStyle = "rgba(255,255,255,0.22)";
        ctx.beginPath(); ctx.moveTo(x,b); ctx.lineTo(x,b+5); ctx.stroke();
        ctx.fillText(fmt(xv, (Math.abs(xMax-xMin)<5)?2:1), x-12, b+18);

        // y ticks
        ctx.beginPath(); ctx.moveTo(l-5,y); ctx.lineTo(l,y); ctx.stroke();
        ctx.fillText(fmt(yv, (Math.abs(yMax-yMin)<5)?2:1), l-52, y+4);
      }

      // axis labels
      ctx.fillStyle = "rgba(229,231,235,0.92)";
      ctx.font = "600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(xLabel, (l+r)/2 - ctx.measureText(xLabel).width/2, b+42);

      ctx.save();
      ctx.translate(l-58, (t+b)/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
      ctx.restore();

      ctx.restore();

      // mapping functions
      const X = (x)=> l + (x-xMin)/(xMax-xMin)*(r-l);
      const Y = (y)=> b - (y-yMin)/(yMax-yMin)*(b-t);
      return {X,Y};
    }

    function drawLegend(ctx, x, y, items){
      ctx.save();
      ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      let yy = y;
      items.forEach(it=>{
        ctx.fillStyle = it.color;
        ctx.fillRect(x, yy-9, 14, 4);
        ctx.fillStyle = "rgba(229,231,235,0.90)";
        ctx.fillText(it.label, x+20, yy-2);
        yy += 16;
      });
      ctx.restore();
    }

    function niceMax(val){
      if (val<=0) return 1;
      const p = Math.pow(10, Math.floor(Math.log10(val)));
      const m = val/p;
      let n;
      if (m<1.5) n=1.5;
      else if (m<2.5) n=2.5;
      else if (m<5) n=5;
      else n=10;
      return n*p;
    }

    // ---------- Physics model ----------
    function computeParams(ratio, w0y_mm, lambda_nm){
      const w0y = w0y_mm * 1e-3;             // m
      const w0x = ratio * w0y;               // m
      const lambda = lambda_nm * 1e-9;       // m
      const pi = Math.PI;

      const zRx = pi * w0x*w0x / lambda;     // m
      const zRy = pi * w0y*w0y / lambda;     // m
      const thx = lambda / (pi * w0x);       // rad
      const thy = lambda / (pi * w0y);       // rad

      function Wx(z){ return w0x * Math.sqrt(1 + (z/zRx)*(z/zRx)); } // m
      function Wy(z){ return w0y * Math.sqrt(1 + (z/zRy)*(z/zRy)); } // m
      function Rx(z){ return (z===0)? Infinity : z*(1 + (zRx/z)*(zRx/z)); }
      function Ry(z){ return (z===0)? Infinity : z*(1 + (zRy/z)*(zRy/z)); }

      return {ratio, w0x, w0y, lambda, zRx, zRy, thx, thy, Wx, Wy, Rx, Ry};
    }

    // ---------- Rendering: Diagram ----------
    function renderDiagram(canvas, P){
      const {ctx, wCSS:W, hCSS:H} = setupHiDPICanvas(canvas);
      ctx.clearRect(0,0,W,H);

      drawPanel(ctx, 0,0,W,H, "Diagram ‚Äî Elliptic waist and two-axis spreading");

      // Coordinate frame
      const margin = 22;
      const x0 = margin, y0 = 34, w = W-2*margin, h = H-54;
      const midY = y0 + h/2;

      // z axis line
      ctx.save();
      ctx.strokeStyle = "rgba(229,231,235,0.35)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x0+20, midY);
      ctx.lineTo(x0+w-20, midY);
      ctx.stroke();

      // z arrow
      ctx.beginPath();
      ctx.moveTo(x0+w-20, midY);
      ctx.lineTo(x0+w-35, midY-6);
      ctx.lineTo(x0+w-35, midY+6);
      ctx.closePath();
      ctx.fillStyle = "rgba(229,231,235,0.35)";
      ctx.fill();
      ctx.fillStyle = "rgba(229,231,235,0.9)";
      ctx.font = "600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("z", x0+w-14, midY+5);

      // waist position at center
      const zc = x0 + w/2;

      // draw ellipses along z as a stylized "beam envelope"
      const zSpan = w*0.42;
      const n = 13;
      const zMax = 1.6*Math.max(P.zRx, P.zRy); // for shape
      for(let i=0;i<n;i++){
        const u = (i/(n-1))*2 - 1; // -1..1
        const z = u*zMax;
        const x = zc + (u*zSpan);
        const wx = P.Wx(z) / P.w0x; // normalized
        const wy = P.Wy(z) / P.w0y; // normalized
        const a = 14 + 26*wx; // px (x semi-axis)
        const b = 10 + 22*wy; // px (y semi-axis)
        ctx.beginPath();
        ctx.ellipse(x, midY, a, b, 0, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(96,165,250,0.18)";
        ctx.lineWidth = 1.2;
        ctx.stroke();
      }

      // draw waist ellipse bold
      const a0 = 14 + 26*(1);
      const b0 = 10 + 22*(1);
      ctx.beginPath();
      ctx.ellipse(zc, midY, a0*(P.w0x/P.w0y)/(P.ratio) * P.ratio, b0, 0, 0, Math.PI*2);
      // the above line is purely aesthetic; better: scale ellipse to ratio
      ctx.restore();

      // replace with explicit waist ellipse with ratio
      ctx.save();
      const aW = 48 * (P.ratio / 2); // px
      const bW = 24; // px
      ctx.beginPath();
      ctx.ellipse(zc, midY, aW, bW, 0, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(52,211,153,0.55)";
      ctx.lineWidth = 2;
      ctx.stroke();

      // waist line (z=0 plane)
      ctx.strokeStyle = "rgba(229,231,235,0.18)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(zc, y0+16);
      ctx.lineTo(zc, y0+h-16);
      ctx.stroke();

      // labels
      ctx.fillStyle = "rgba(229,231,235,0.92)";
      ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("waist plane z = 0", zc-56, y0+18);

      // Wx and Wy labels at waist
      ctx.strokeStyle = "rgba(52,211,153,0.55)";
      ctx.lineWidth = 2;
      // Wx arrow
      ctx.beginPath();
      ctx.moveTo(zc-aW, midY+ bW+18);
      ctx.lineTo(zc+aW, midY+ bW+18);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(zc-aW, midY+ bW+18);
      ctx.lineTo(zc-aW+10, midY+ bW+12);
      ctx.lineTo(zc-aW+10, midY+ bW+24);
      ctx.closePath();
      ctx.fillStyle = "rgba(52,211,153,0.55)";
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(zc+aW, midY+ bW+18);
      ctx.lineTo(zc+aW-10, midY+ bW+12);
      ctx.lineTo(zc+aW-10, midY+ bW+24);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "rgba(229,231,235,0.88)";
      ctx.font = "600 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      ctx.fillText("W0x", zc-14, midY+bW+36);

      // Wy arrow
      ctx.strokeStyle = "rgba(96,165,250,0.6)";
      ctx.fillStyle = "rgba(96,165,250,0.6)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(zc+aW+28, midY-bW);
      ctx.lineTo(zc+aW+28, midY+bW);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(zc+aW+28, midY-bW);
      ctx.lineTo(zc+aW+22, midY-bW+10);
      ctx.lineTo(zc+aW+34, midY-bW+10);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(zc+aW+28, midY+bW);
      ctx.lineTo(zc+aW+22, midY+bW-10);
      ctx.lineTo(zc+aW+34, midY+bW-10);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "rgba(229,231,235,0.88)";
      ctx.font = "600 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      ctx.fillText("W0y", zc+aW+14, midY+4);

      // far-field note
      ctx.fillStyle = "rgba(229,231,235,0.78)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("far field: |z| \u226B zRx, zRy  \u2192  Wx \u2248 \u03B8x|z|,  Wy \u2248 \u03B8y|z|", x0+22, y0+h-10);

      ctx.restore();
    }

    // ---------- Rendering: Main plot Wx(z), Wy(z) ----------
    function renderMain(canvas, P){
      const {ctx, wCSS:W, hCSS:H} = setupHiDPICanvas(canvas);
      ctx.clearRect(0,0,W,H);

      drawPanel(ctx, 0,0,W,H, "Main Plot ‚Äî Beam radii vs propagation distance");

      const pad = 62;
      const box = axisBox(12, 26, W-24, H-40, pad);

      // choose z range: +/- 3*max(zR)
      const zRmax = Math.max(P.zRx, P.zRy);
      const zMax = 3.2 * zRmax;

      // y range based on max radius at zMax
      const wMax = Math.max(P.Wx(zMax), P.Wy(zMax)); // m
      const yMax = niceMax((wMax*1e3)); // mm
      const yMin = 0;

      const xMin = -zMax*1e3; // mm
      const xMax =  zMax*1e3; // mm

      const map = drawAxes(
        ctx, box,
        xMin, xMax,
        yMin, yMax,
        "z (mm)",
        "W(z) (mm)",
        {ticks:6, grid:true}
      );

      // plot curves
      function plotCurve(color, fnW){
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        const N = 400;
        for(let i=0;i<=N;i++){
          const u = i/N;
          const zmm = xMin + u*(xMax-xMin);
          const z = zmm*1e-3; // m
          const wmm = fnW(z)*1e3;
          const X = map.X(zmm), Y = map.Y(wmm);
          if (i===0) ctx.moveTo(X,Y);
          else ctx.lineTo(X,Y);
        }
        ctx.stroke();
        ctx.restore();
      }

      const colX = "rgba(52,211,153,0.90)";
      const colY = "rgba(96,165,250,0.92)";
      plotCurve(colX, P.Wx);
      plotCurve(colY, P.Wy);

      // mark Rayleigh ranges
      function vline(zm, color, label){
        const zmm = zm*1e3;
        ctx.save();
        ctx.strokeStyle = color;
        ctx.setLineDash([6,5]);
        ctx.lineWidth = 1.6;
        ctx.beginPath();
        ctx.moveTo(map.X(zmm), box.t);
        ctx.lineTo(map.X(zmm), box.b);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = "rgba(229,231,235,0.92)";
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
        ctx.fillText(label, map.X(zmm)+6, box.t+14);
        ctx.restore();
      }
      vline(P.zRx, "rgba(52,211,153,0.65)", "+zRx");
      vline(-P.zRx, "rgba(52,211,153,0.45)", "-zRx");
      vline(P.zRy, "rgba(96,165,250,0.65)", "+zRy");
      vline(-P.zRy, "rgba(96,165,250,0.45)", "-zRy");

      drawLegend(ctx, box.r-130, box.t+18, [
        {color: colX, label: "Wx(z)"},
        {color: colY, label: "Wy(z)"}
      ]);

      // annotation: far-field slopes
      ctx.save();
      ctx.fillStyle = "rgba(229,231,235,0.80)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      const txt1 = `Far field: Wx ‚âà Œ∏x|z|,  Œ∏x=${fmt(P.thx*1e3,3)} mrad`;
      const txt2 = `          Wy ‚âà Œ∏y|z|,  Œ∏y=${fmt(P.thy*1e3,3)} mrad`;
      ctx.fillText(txt1, box.l+10, box.t+18);
      ctx.fillText(txt2, box.l+10, box.t+34);
      ctx.restore();
    }

    // ---------- Rendering: Intensity maps ----------
    function renderIntensityMap(canvas, title, Wmm, Hmm, wx_m, wy_m){
      const {ctx, wCSS:W, hCSS:H} = setupHiDPICanvas(canvas);
      ctx.clearRect(0,0,W,H);

      drawPanel(ctx, 0,0,W,H, title);

      const pad = 56;
      const box = axisBox(10, 26, W-20, H-36, pad);

      const xMin = -Wmm, xMax = Wmm; // mm
      const yMin = -Hmm, yMax = Hmm; // mm

      const map = drawAxes(
        ctx, box,
        xMin, xMax,
        yMin, yMax,
        "x (mm)",
        "y (mm)",
        {ticks:6, grid:true}
      );

      // Draw intensity as image pixels
      const imgW = Math.floor((box.r-box.l));
      const imgH = Math.floor((box.b-box.t));
      const img = ctx.createImageData(imgW, imgH);

      const wx = wx_m * 1e3; // mm
      const wy = wy_m * 1e3; // mm

      // We'll map intensity I = exp(-2(x^2/wx^2 + y^2/wy^2))
      // Use a gentle colormap: grayscale with alpha-ish tint for readability
      for(let j=0;j<imgH;j++){
        const y = yMax - (j/(imgH-1))*(yMax-yMin); // mm
        for(let i=0;i<imgW;i++){
          const x = xMin + (i/(imgW-1))*(xMax-xMin); // mm
          const I = Math.exp(-2*( (x*x)/(wx*wx) + (y*y)/(wy*wy) ));
          // map to brightness
          const v = clamp(Math.pow(I, 0.35), 0, 1); // gamma
          // color blend: bluish background + greenish core for contrast
          const r = Math.round(20 + 80*v);
          const g = Math.round(28 + 160*v);
          const b = Math.round(40 + 180*v);
          const a = 255;
          const idx = 4*(j*imgW+i);
          img.data[idx+0] = r;
          img.data[idx+1] = g;
          img.data[idx+2] = b;
          img.data[idx+3] = a;
        }
      }

      // put image
      ctx.putImageData(img, box.l, box.t);

      // draw a few contour ellipses (I = exp(-2 œÅ^2) -> œÅ^2 = const)
      // Choose I levels: 1/e^2 => rho=1; 1/e^4 => rho=sqrt(2); 0.1 etc
      const levels = [
        {rho:1,  col:"rgba(255,255,255,0.55)", label:"1/e¬≤"},
        {rho:Math.sqrt(2), col:"rgba(255,255,255,0.30)", label:"1/e‚Å¥"},
        {rho:1.8, col:"rgba(255,255,255,0.18)", label:"~0.02"}
      ];

      ctx.save();
      levels.forEach((L, idx)=>{
        const ax = L.rho*wx;
        const ay = L.rho*wy;
        ctx.strokeStyle = L.col;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        // ellipse in data coords
        const cx = map.X(0);
        const cy = map.Y(0);
        const rx = map.X(ax) - map.X(0);
        const ry = map.Y(0) - map.Y(ay);
        ctx.ellipse(cx, cy, Math.abs(rx), Math.abs(ry), 0, 0, Math.PI*2);
        ctx.stroke();
        if (idx===0){
          ctx.fillStyle = "rgba(229,231,235,0.90)";
          ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
          ctx.fillText(`Contour: ${L.label}`, box.l+10, box.t+46);
        }
      });
      ctx.restore();

      // legend for wx, wy
      ctx.save();
      ctx.fillStyle = "rgba(229,231,235,0.90)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";
      ctx.fillText(`Wx = ${fmt(wx,3)} mm`, box.l+10, box.t+18);
      ctx.fillText(`Wy = ${fmt(wy,3)} mm`, box.l+10, box.t+32);
      ctx.restore();
    }

    // ---------- UI wiring ----------
    const el = (id)=>document.getElementById(id);
    const ratio = el('ratio'), ratioNum = el('ratioNum');
    const w0y = el('w0y'), w0yNum = el('w0yNum');
    const lambda = el('lambda'), lambdaNum = el('lambdaNum');
    const kpi = el('kpi');

    function syncRangeNumber(rangeEl, numEl){
      rangeEl.addEventListener('input', ()=>{ numEl.value = rangeEl.value; updateAll(); });
      numEl.addEventListener('input', ()=>{
        const v = clamp(parseFloat(numEl.value || rangeEl.value), parseFloat(rangeEl.min), parseFloat(rangeEl.max));
        rangeEl.value = v;
        numEl.value = v;
        updateAll();
      });
    }
    syncRangeNumber(ratio, ratioNum);
    syncRangeNumber(w0y, w0yNum);
    syncRangeNumber(lambda, lambdaNum);

    // Copy buttons
    document.querySelectorAll('[data-copy]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const sel = btn.getAttribute('data-copy');
        const node = document.querySelector(sel);
        const txt = node ? node.textContent.trim() : "";
        if (txt) copyText(txt);
      });
    });

    el('btnReset').addEventListener('click', ()=>{
      ratio.value = 2.00; ratioNum.value = 2.00;
      updateAll();
      showToast("Reset to r = 2");
    });

    // Smooth scroll for TOC
    document.querySelectorAll('nav.toc a').forEach(a=>{
      a.addEventListener('click', (e)=>{
        const href = a.getAttribute('href');
        if (href && href.startsWith('#')){
          e.preventDefault();
          const t = document.querySelector(href);
          if (t) t.scrollIntoView({behavior:'smooth', block:'start'});
        }
      });
    });

    function renderKPIs(P){
      const zRx_mm = P.zRx*1e3;
      const zRy_mm = P.zRy*1e3;
      const thx_mrad = P.thx*1e3;
      const thy_mrad = P.thy*1e3;

      // example curvature at z = max(zR)
      const z = Math.max(P.zRx, P.zRy);
      const Rx = P.Rx(z)*1e3;
      const Ry = P.Ry(z)*1e3;

      kpi.innerHTML = `
        <div class="pill"><strong class="mono">W0x</strong><span class="mono">${fmt(P.w0x*1e3,3)} mm</span></div>
        <div class="pill"><strong class="mono">W0y</strong><span class="mono">${fmt(P.w0y*1e3,3)} mm</span></div>
        <div class="pill"><strong class="mono">zRx</strong><span class="mono">${fmt(zRx_mm,2)} mm</span></div>
        <div class="pill"><strong class="mono">zRy</strong><span class="mono">${fmt(zRy_mm,2)} mm</span></div>
        <div class="pill"><strong class="mono">Œ∏x</strong><span class="mono">${fmt(thx_mrad,3)} mrad</span></div>
        <div class="pill"><strong class="mono">Œ∏y</strong><span class="mono">${fmt(thy_mrad,3)} mrad</span></div>
        <div class="pill"><strong class="mono">Rx(zRmax)</strong><span class="mono">${fmt(Rx,2)} mm</span></div>
        <div class="pill"><strong class="mono">Ry(zRmax)</strong><span class="mono">${fmt(Ry,2)} mm</span></div>
      `;
    }

    function updateAll(){
      const r = parseFloat(ratio.value);
      const w0y_mm = parseFloat(w0y.value);
      const lam_nm = parseFloat(lambda.value);

      const P = computeParams(r, w0y_mm, lam_nm);

      // Render KPI
      renderKPIs(P);

      // Diagram
      renderDiagram(el('cDiagram'), P);

      // Main plot
      renderMain(el('cMain'), P);

      // Secondary maps: near field at z=0, far field at z=5*max(zR)
      const zFar = 5*Math.max(P.zRx, P.zRy);
      const wx0 = P.Wx(0);
      const wy0 = P.Wy(0);
      const wxF = P.Wx(zFar);
      const wyF = P.Wy(zFar);

      // Choose view windows (mm) based on radii so plots are readable
      const winNearX = niceMax(2.4*wx0*1e3);
      const winNearY = niceMax(2.4*wy0*1e3);
      const winFarX  = niceMax(2.4*wxF*1e3);
      const winFarY  = niceMax(2.4*wyF*1e3);

      renderIntensityMap(el('cNear'), "Secondary Plot ‚Äî Near field (z = 0)", winNearX, winNearY, wx0, wy0);
      renderIntensityMap(el('cFar'),  "Secondary Plot ‚Äî Far field (z = 5¬∑max(zR))", winFarX, winFarY, wxF, wyF);
    }

    // Re-render on resize (responsive)
    window.addEventListener('resize', ()=>{ updateAll(); });

    // initial
    updateAll();
  </script>
</body>
</html>
