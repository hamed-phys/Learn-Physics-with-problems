<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Half-Wave Retarder: Why the Output Rotates by 2θ (and Why It’s Not a Simple Rotator)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:rgba(255,255,255,0.06);
      --panel2:rgba(255,255,255,0.085);
      --text:rgba(255,255,255,0.92);
      --muted:rgba(255,255,255,0.72);
      --faint:rgba(255,255,255,0.55);
      --line:rgba(255,255,255,0.12);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 18px 55px rgba(0,0,0,0.35);
      --radius:18px;
      --radius2:24px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    html,body{
      margin:0;
      background: radial-gradient(1200px 700px at 10% 10%, rgba(125,211,252,0.12), transparent 50%),
                  radial-gradient(1100px 650px at 90% 20%, rgba(167,139,250,0.10), transparent 55%),
                  radial-gradient(900px 700px at 40% 100%, rgba(52,211,153,0.08), transparent 55%),
                  var(--bg);
      color: var(--text);
      font-family: var(--sans);
      line-height:1.55;
      scroll-behavior:smooth;
    }

    a{ color: var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }

    header{
      padding: 34px 18px 18px;
      max-width: 1100px;
      margin: 0 auto;
    }
    .title{
      display:grid;
      gap:10px;
      align-items:start;
    }
    .title h1{
      margin:0;
      font-size: clamp(1.55rem, 2.2vw + 1rem, 2.6rem);
      letter-spacing: -0.02em;
      line-height:1.15;
    }
    .subtitle{
      margin:0;
      color: var(--muted);
      max-width: 70ch;
    }
    .metaRow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:10px;
      color:var(--faint);
      font-size:0.95rem;
    }
    .pill{
      padding:6px 10px;
      border:1px solid var(--line);
      background: rgba(255,255,255,0.03);
      border-radius:999px;
      backdrop-filter: blur(10px);
    }

    main{
      max-width: 1100px;
      margin: 0 auto;
      padding: 0 18px 60px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    /* Sticky mini-TOC */
    .layout{
      display:grid;
      grid-template-columns: 290px 1fr;
      gap: 16px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
    }
    nav#toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      border:1px solid var(--line);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
      backdrop-filter: blur(10px);
    }
    nav#toc h2{
      margin:0 0 10px 0;
      font-size: 1rem;
      color: var(--text);
      letter-spacing:0.02em;
    }
    .tocList{
      list-style:none;
      padding:0;
      margin:0;
      display:grid;
      gap:8px;
    }
    .tocList a{
      display:block;
      padding:8px 10px;
      border-radius: 12px;
      border:1px solid transparent;
      color: var(--muted);
      background: rgba(0,0,0,0.08);
    }
    .tocList a:hover{
      color: var(--text);
      border-color: rgba(125,211,252,0.35);
      background: rgba(125,211,252,0.10);
      text-decoration:none;
    }
    .tocList a.active{
      color: var(--text);
      border-color: rgba(167,139,250,0.45);
      background: rgba(167,139,250,0.12);
    }

    section{
      background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.03));
      border:1px solid var(--line);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      padding: 18px;
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    section h2{
      margin:0 0 10px;
      font-size: clamp(1.15rem, 1vw + 1rem, 1.55rem);
      letter-spacing:-0.01em;
    }
    section h3{
      margin: 16px 0 8px;
      font-size: 1.05rem;
      color: var(--text);
    }
    p{ margin: 10px 0; color: var(--muted); }
    ul{ margin: 8px 0 8px 20px; color: var(--muted); }
    li{ margin: 6px 0; }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
      align-items:stretch;
    }
    @media (max-width: 860px){
      .grid2{ grid-template-columns: 1fr; }
    }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
    }
    @media (max-width: 860px){
      .callouts{ grid-template-columns: 1fr; }
    }
    .card{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(0,0,0,0.12);
      padding: 12px 12px 10px;
    }
    .card strong{ color: var(--text); }
    .tag{
      display:inline-block;
      font-size:0.83rem;
      padding: 3px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,0.03);
      color: var(--faint);
      margin-bottom:8px;
    }
    .tag.good{ border-color: rgba(52,211,153,0.35); color: rgba(52,211,153,0.95); }
    .tag.warn{ border-color: rgba(251,191,36,0.35); color: rgba(251,191,36,0.95); }
    .tag.bad{ border-color: rgba(251,113,133,0.35); color: rgba(251,113,133,0.95); }

    .eqBlock{
      position:relative;
      border:1px solid var(--line);
      background: rgba(0,0,0,0.18);
      border-radius: var(--radius);
      padding: 12px 12px 12px;
      margin: 10px 0;
      overflow:auto;
    }
    pre.eq{
      margin:0;
      font-family: var(--mono);
      color: rgba(255,255,255,0.90);
      font-size: 0.95rem;
      white-space: pre-wrap;
    }
    .copyBtn{
      position:absolute;
      top:10px;
      right:10px;
      border:1px solid var(--line);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 7px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-size: 0.86rem;
      transition: transform 0.12s ease, background 0.12s ease, border-color 0.12s ease;
      user-select:none;
    }
    .copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(125,211,252,0.10);
      border-color: rgba(125,211,252,0.35);
    }
    .copyBtn:active{ transform: translateY(0px) scale(0.99); }
    .copyToast{
      position: fixed;
      left: 50%;
      bottom: 22px;
      transform: translateX(-50%);
      padding: 10px 14px;
      border-radius: 14px;
      border:1px solid var(--line);
      background: rgba(0,0,0,0.55);
      color: var(--text);
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: opacity 0.18s ease, transform 0.18s ease;
      backdrop-filter: blur(10px);
      font-size: 0.92rem;
      z-index: 9999;
    }
    .copyToast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-4px);
    }

    /* Visualization */
    .vizWrap{
      display:grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 14px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .vizWrap{ grid-template-columns: 1fr; }
    }

    .vizPanel{
      border:1px solid var(--line);
      border-radius: var(--radius2);
      background: rgba(0,0,0,0.15);
      overflow:hidden;
    }
    .vizHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding: 12px 12px 10px;
      border-bottom:1px solid var(--line);
      background: rgba(255,255,255,0.03);
    }
    .vizHeader h3{
      margin:0;
      font-size: 1rem;
      color: var(--text);
    }
    .vizBody{ padding: 10px 12px 12px; }
    canvas{
      width: 100%;
      height: 320px;
      display:block;
      border-radius: 16px;
      background: rgba(8,12,24,0.55);
      border: 1px solid rgba(255,255,255,0.08);
    }
    .smallCanvas canvas{ height: 260px; }
    .controls{
      display:grid;
      gap: 10px;
    }
    .control{
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding: 10px 10px 8px;
      background: rgba(255,255,255,0.03);
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      color: var(--muted);
      font-size: 0.92rem;
      margin-bottom: 6px;
    }
    .control input[type="range"]{ width: 100%; }
    .control .val{
      font-family: var(--mono);
      color: rgba(255,255,255,0.85);
      font-size: 0.92rem;
      white-space:nowrap;
    }
    .control .hint{
      margin-top: 6px;
      color: var(--faint);
      font-size: 0.85rem;
    }
    .btnRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 8px;
    }
    .btn{
      border:1px solid var(--line);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 9px 12px;
      border-radius: 14px;
      cursor:pointer;
      transition: transform 0.12s ease, background 0.12s ease, border-color 0.12s ease;
      user-select:none;
      font-size: 0.92rem;
    }
    .btn:hover{
      transform: translateY(-1px);
      background: rgba(167,139,250,0.10);
      border-color: rgba(167,139,250,0.35);
    }
    .btn:active{ transform: translateY(0px) scale(0.99); }

    .note{
      color: var(--faint);
      font-size: 0.93rem;
    }

    footer{
      max-width:1100px;
      margin: 0 auto;
      padding: 0 18px 30px;
      color: var(--faint);
      font-size: 0.95rem;
    }

    /* Subtle animation */
    @keyframes floatIn{
      from{ transform: translateY(6px); opacity:0; }
      to{ transform: translateY(0px); opacity:1; }
    }
    section{ animation: floatIn 0.35s ease both; }

    /* Print-friendly */
    @media print{
      :root{ --bg:#ffffff; --text:#111; --muted:#222; --faint:#444; --panel:#fff; --panel2:#fff; --line:#ccc; }
      body{ background:#fff; color:#111; }
      nav#toc{ display:none; }
      section{ box-shadow:none; background:#fff; border-color:#ccc; }
      canvas{ border-color:#bbb; background:#fff; }
      .copyBtn{ display:none; }
      .pill{ border-color:#bbb; }
      a{ color:#000; text-decoration:underline; }
    }
  </style>
</head>

<body>
  <header>
    <div class="title">
      <h1>6.1-8 Half-Wave Retarder: Why the Transmitted Linear Polarization Rotates by <span style="color:var(--accent)">2θ</span> (and Why a Waveplate ≠ a Rotator)</h1>
      <p class="subtitle">
        We use <strong>Jones calculus</strong> to show that a half-wave plate reflects the polarization direction about its fast axis.
        That produces the famous output angle <strong>α′ = 2θ − α</strong> and explains why the device is <em>not</em> equivalent to a true polarization rotator.
      </p>
      <div class="metaRow">
        <span class="pill">Topic: Polarization optics</span>
        <span class="pill">Tools: Jones vectors & matrices</span>
        <span class="pill">Key device: Half-wave retarder (δ = π)</span>
      </div>
    </div>
  </header>

  <main>
    <div class="layout">
      <nav id="toc" aria-label="Table of Contents">
        <h2>On this page</h2>
        <ul class="tocList">
          <li><a href="#quick" class="tocLink">Quick Summary</a></li>
          <li><a href="#part0" class="tocLink">PART 0 — Concept Primer</a></li>
          <li><a href="#part1" class="tocLink">PART 1 — Problem Analysis</a></li>
          <li><a href="#part2" class="tocLink">PART 2 — Strategy & Tips</a></li>
          <li><a href="#part3" class="tocLink">PART 3 — Full Solution</a></li>
          <li><a href="#part4" class="tocLink">PART 4 — Deeper Understanding</a></li>
          <li><a href="#part5" class="tocLink">PART 5 — Visualization Guide</a></li>
        </ul>
        <p class="note" style="margin:10px 0 0;">
          Tip: Use the sliders in the visualization section to see how the output changes with <span style="color:var(--accent)">θ</span> and retardance <span style="color:var(--accent2)">δ</span>.
        </p>
      </nav>

      <article>
        <!-- Quick Summary -->
        <section id="quick">
          <h2>Quick Summary</h2>
          <ul>
            <li><strong>What this is about:</strong> A <em>half-wave retarder</em> (half-wave plate) changes the relative phase between two orthogonal polarization components.</li>
            <li><strong>Key physics idea:</strong> A half-wave plate (retardance <span style="font-family:var(--mono)">δ = π</span>) flips the sign of the component along its <em>slow</em> axis relative to the <em>fast</em> axis, which geometrically reflects the polarization direction about the fast axis.</li>
            <li><strong>Governing model:</strong> <strong>Jones calculus</strong> for fully polarized, monochromatic light in a fixed transverse plane.</li>
            <li><strong>Core matrix (fast/slow basis):</strong> <span style="font-family:var(--mono)">J(δ)=diag(1, e^{iδ})</span> (one axis gets an extra phase).</li>
            <li><strong>Rotation to lab axes:</strong> <span style="font-family:var(--mono)">J_lab = R(θ) diag(1, e^{iδ}) R(-θ)</span>, where <span style="font-family:var(--mono)">R</span> rotates between lab axes and the plate axes.</li>
            <li><strong>Main result (half-wave):</strong> For incident linear polarization at angle <span style="font-family:var(--mono)">α</span> (lab), the output is linear at <span style="font-family:var(--mono)">α′ = 2θ − α</span>. If the input makes angle <span style="font-family:var(--mono)">θ</span> with the <em>fast axis</em>, then the output makes angle <span style="font-family:var(--mono)">−θ</span> with the fast axis → rotation by <span style="font-family:var(--mono)">2θ</span>.</li>
            <li><strong>Why it’s not a rotator:</strong> It does <em>not</em> apply the same angular rotation to <em>all</em> polarization states; it’s a phase device (birefringent, reciprocal). Only special inputs (like linear) look like a “rotation,” and it is not non-reciprocal like a Faraday rotator.</li>
          </ul>
        </section>

        <!-- PART 0 -->
        <section id="part0">
          <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

          <div class="grid2">
            <div>
              <h3>Core definitions (symbols & meaning)</h3>
              <ul>
                <li><strong>Jones vector</strong> <span style="font-family:var(--mono)">E = [E_x, E_y]^T</span>: complex field amplitudes along transverse axes (units: electric field, V/m, but often normalized).</li>
                <li><strong>Linear polarization angle</strong> <span style="font-family:var(--mono)">α</span>: angle of the electric field direction relative to a fixed lab x-axis.</li>
                <li><strong>Retarder (waveplate)</strong>: a birefringent element giving different phase velocities along two orthogonal principal axes:
                  <ul>
                    <li><strong>fast axis</strong> (lower refractive index → faster phase velocity)</li>
                    <li><strong>slow axis</strong> (higher refractive index → slower phase velocity)</li>
                  </ul>
                </li>
                <li><strong>Retardance</strong> <span style="font-family:var(--mono)">δ</span> (radians): relative phase delay added between the two axes.
                  For a plate of thickness <span style="font-family:var(--mono)">L</span>:
                  <span style="font-family:var(--mono)">δ = (2π/λ) Δn L</span>, where <span style="font-family:var(--mono)">Δn = n_slow − n_fast</span>.</li>
                <li><strong>Half-wave plate</strong>: <span style="font-family:var(--mono)">δ = π</span> (a half wavelength of phase difference).</li>
              </ul>
            </div>

            <div>
              <h3>Physical meaning (what the quantities “do”)</h3>
              <ul>
                <li><span style="font-family:var(--mono)">E_x, E_y</span> are not just numbers: they encode both amplitude and phase, which determines the polarization ellipse.</li>
                <li><span style="font-family:var(--mono)">δ</span> controls how much the plate “twists” the relative phase between orthogonal components → changing <em>ellipse shape</em> (linear ↔ elliptical ↔ circular).</li>
                <li><span style="font-family:var(--mono)">θ</span> is the orientation of the plate’s fast axis relative to the lab x-axis. Rotating the plate changes which combination of lab components get phase shifted.</li>
              </ul>

              <div class="callouts">
                <div class="card">
                  <div class="tag good">Valid when</div>
                  <p>
                    Jones calculus assumes <strong>fully polarized</strong>, <strong>monochromatic</strong> light and that the optical element is linear, deterministic, and does not depolarize.
                  </p>
                </div>
                <div class="card">
                  <div class="tag warn">Common approximation</div>
                  <p>
                    We treat the plate as an <strong>ideal retarder</strong>: no absorption, no multiple reflections, and perfectly orthogonal principal axes.
                  </p>
                </div>
              </div>
            </div>
          </div>

          <h3>Key laws/principles (and assumptions)</h3>
          <p>
            A linear retarder is modeled as a device that preserves amplitudes along its principal axes but adds a relative phase.
            In its own principal-axis basis (fast/slow), the Jones matrix is diagonal:
          </p>

          <div class="eqBlock">
            <button class="copyBtn" data-copy="J(δ)=diag(1, e^{iδ})">Copy</button>
            <pre class="eq">J(δ) = [ 1      0
         0   e^{iδ} ]   (principal-axis basis)</pre>
          </div>

          <p>
            If the fast axis is rotated by <span style="font-family:var(--mono)">θ</span> from the lab x-axis, we rotate into the plate basis, apply <span style="font-family:var(--mono)">J(δ)</span>, then rotate back:
          </p>

          <div class="eqBlock">
            <button class="copyBtn" data-copy="J_lab(θ,δ)=R(θ)·diag(1,e^{iδ})·R(-θ),  R(θ)=[[cosθ,-sinθ],[sinθ,cosθ]]">Copy</button>
            <pre class="eq">J_lab(θ,δ) = R(θ) · diag(1, e^{iδ}) · R(-θ)

R(θ) = [ cosθ  -sinθ
         sinθ   cosθ ]</pre>
          </div>

          <h3>Mini intuition examples (no long algebra)</h3>
          <ul>
            <li><strong>If θ = 0:</strong> the plate axes align with lab axes. Then one lab component gets phase-shifted relative to the other. For δ = π, that’s just a sign flip of one component.</li>
            <li><strong>If input is at 45° to the axes:</strong> the two components are equal magnitude. A δ = π/2 quarter-wave plate turns linear into circular; a δ = π half-wave plate keeps it linear but rotates its direction.</li>
          </ul>

          <h3>What to watch for (pitfalls)</h3>
          <ul>
            <li>Confusing <strong>angle from lab axis</strong> (α) with <strong>angle from the fast axis</strong> (relative angle).</li>
            <li>Forgetting that a waveplate is a <strong>phase device</strong>: it does not literally “rotate the field vector” in real space; it changes the relative phase of components.</li>
            <li>Assuming “it rotates by a fixed angle” for any polarization state (false). For many inputs, a waveplate outputs <strong>elliptical</strong> polarization.</li>
          </ul>
        </section>

        <!-- PART 1 -->
        <section id="part1">
          <h2>PART 1 — Problem Analysis (no solving yet)</h2>

          <h3>Restate the problem (in plain words)</h3>
          <p>
            Linearly polarized light passes through a <strong>half-wave retarder</strong>. The input polarization direction makes an angle
            <span style="font-family:var(--mono)">θ</span> with the plate’s <strong>fast axis</strong>. Show that the output is still linearly polarized,
            but at angle <span style="font-family:var(--mono)">−θ</span> relative to the fast axis—i.e., the polarization direction is rotated by <span style="font-family:var(--mono)">2θ</span>.
            Then explain why a half-wave retarder is <em>not</em> equivalent to a polarization rotator.
          </p>

          <div class="callouts">
            <div class="card">
              <div class="tag good">Given</div>
              <ul>
                <li>Input: linear polarization.</li>
                <li>Optical element: half-wave plate (ideal), retardance <span style="font-family:var(--mono)">δ = π</span>.</li>
                <li>Geometry: input polarization makes angle <span style="font-family:var(--mono)">θ</span> with the fast axis.</li>
              </ul>
            </div>
            <div class="card">
              <div class="tag warn">Find / Prove</div>
              <ul>
                <li>Output polarization is linear.</li>
                <li>Output angle relative fast axis is <span style="font-family:var(--mono)">−θ</span> (a “flip”).</li>
                <li>Explain: why not equivalent to a polarization rotator.</li>
              </ul>
            </div>
          </div>

          <h3>Relevant principles (and why they apply)</h3>
          <ul>
            <li><strong>Jones calculus</strong> applies because we assume fully polarized, monochromatic light and a deterministic linear optical element.</li>
            <li><strong>Birefringent retarder model</strong> applies because a half-wave plate introduces a relative phase shift between orthogonal eigenpolarizations.</li>
            <li>We do <em>not</em> need Fresnel coefficients, intensity loss, or scattering models because the problem is about <strong>polarization state</strong>, not power loss.</li>
          </ul>

          <h3>Assumptions</h3>
          <div class="card">
            <div class="tag warn">Assumptions</div>
            <ul>
              <li>Ideal retarder: no absorption, no depolarization.</li>
              <li>Perfectly orthogonal fast/slow axes; constant retardance across the beam.</li>
              <li>Single-frequency (monochromatic) light; spatial effects ignored.</li>
            </ul>
          </div>

          <h3>Possible approaches (choose one)</h3>
          <ul>
            <li><strong>Approach A: Jones matrices (recommended)</strong> — Fast, systematic, and gives a clear formula for the output angle.</li>
            <li><strong>Approach B: Component phase reasoning in fast/slow axes</strong> — Very intuitive for a half-wave plate: one component flips sign; you then interpret that as a geometric reflection.</li>
            <li><strong>Approach C: Stokes/Poincaré sphere</strong> — Powerful, conceptual: a half-wave plate corresponds to a 180° rotation of the Stokes vector about a suitable axis. More abstract, great for deeper insight.</li>
          </ul>
          <p>
            We’ll use <strong>A + B</strong>: Jones calculus for rigor, plus the “sign flip” picture for intuition.
          </p>
        </section>

        <!-- PART 2 -->
        <section id="part2">
          <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

          <ol style="color:var(--muted); margin-left:20px;">
            <li><strong>Set axes:</strong> Define the plate basis <span style="font-family:var(--mono)">(f,s)</span> (fast/slow) and express the input Jones vector there.
              <div class="note">Meaning: we decompose the field into eigenpolarizations of the plate.</div>
            </li>
            <li><strong>Write the half-wave matrix:</strong> Use <span style="font-family:var(--mono)">diag(1, e^{iπ}) = diag(1,-1)</span>.
              <div class="note">Meaning: the slow-axis component changes sign relative to the fast-axis component.</div>
            </li>
            <li><strong>Apply the matrix:</strong> Multiply to get the output vector in the plate basis.
              <div class="note">Meaning: you now have the output amplitudes/phases after the plate.</div>
            </li>
            <li><strong>Interpret the result:</strong> Show the output corresponds to linear polarization at angle <span style="font-family:var(--mono)">−θ</span> relative to the fast axis.
              <div class="note">Meaning: a reflection about the fast axis → net “rotation” by <span style="font-family:var(--mono)">2θ</span>.</div>
            </li>
            <li><strong>Generalize briefly:</strong> For an arbitrary input angle α (lab), show <span style="font-family:var(--mono)">α′ = 2θ − α</span>.
              <div class="note">Meaning: the plate acts like a mirror in polarization-angle space, not a constant rotator.</div>
            </li>
            <li><strong>Conceptual question:</strong> Explain why a waveplate ≠ rotator (state-dependence + reciprocity).
              <div class="note">Meaning: a true rotator applies the same rotation to any input state (and Faraday rotation is non-reciprocal).</div>
            </li>
          </ol>

          <div class="callouts">
            <div class="card">
              <div class="tag bad">Common mistakes</div>
              <ul>
                <li>Using <span style="font-family:var(--mono)">R(θ)</span> with the wrong sign (mixing “rotate axes” vs “rotate vectors”).</li>
                <li>Claiming “output always rotated by 2θ” even if input is not linear (for many inputs, output becomes elliptical).</li>
              </ul>
            </div>
            <div class="card">
              <div class="tag good">Quick tips</div>
              <ul>
                <li>Work in the plate basis first: half-wave is literally <span style="font-family:var(--mono)">[1, -1]</span> on components.</li>
                <li>Geometric interpretation: sign flip about one axis = reflection = angle negation relative that axis.</li>
              </ul>
            </div>
          </div>
        </section>

        <!-- VISUALIZATION SECTION (placed before full solution for learning flow) -->
        <section id="viz">
          <h2>Interactive Visualizations</h2>
          <p>
            The plots below use <strong>example values</strong> for exploration. The final analytic result remains symbolic.
            You can vary the fast-axis angle <span style="font-family:var(--mono)">θ</span>, the input linear angle <span style="font-family:var(--mono)">α</span>, and the retardance <span style="font-family:var(--mono)">δ</span>.
            Set <span style="font-family:var(--mono)">δ = 180°</span> to see the half-wave behavior.
          </p>

          <div class="vizWrap">
            <div class="vizPanel">
              <div class="vizHeader">
                <h3>Diagram: Input vs Fast/Slow Axes & Output Polarization Ellipse</h3>
                <span class="pill" style="font-size:0.86rem;">Canvas 1 (diagram)</span>
              </div>
              <div class="vizBody">
                <canvas id="cDiagram" aria-label="Polarization diagram"></canvas>
                <p class="note" style="margin:10px 2px 0;">
                  The output ellipse is computed from the Jones vector after the retarder. When <span style="font-family:var(--mono)">δ=180°</span>, the ellipse collapses to a line (linear).
                </p>
              </div>
            </div>

            <div class="controls">
              <div class="control">
                <label>
                  <span>Fast-axis angle <span style="font-family:var(--mono)">θ</span> (deg, lab reference)</span>
                  <span class="val" id="valTheta">+25.0°</span>
                </label>
                <input id="sTheta" type="range" min="-90" max="90" value="25" step="0.5">
                <div class="hint">Rotating the plate changes which lab components are “fast” and “slow.”</div>
              </div>

              <div class="control">
                <label>
                  <span>Input linear angle <span style="font-family:var(--mono)">α</span> (deg, lab reference)</span>
                  <span class="val" id="valAlpha">+10.0°</span>
                </label>
                <input id="sAlpha" type="range" min="-90" max="90" value="10" step="0.5">
                <div class="hint">This is the incident polarization direction in the lab frame.</div>
              </div>

              <div class="control">
                <label>
                  <span>Retardance <span style="font-family:var(--mono)">δ</span> (deg)</span>
                  <span class="val" id="valDelta">180.0°</span>
                </label>
                <input id="sDelta" type="range" min="0" max="360" value="180" step="1">
                <div class="hint">Set δ = 180° for a half-wave plate. Other values produce elliptical polarization.</div>
              </div>

              <div class="btnRow">
                <button class="btn" id="btnHalf">Set Half-Wave (δ = 180°)</button>
                <button class="btn" id="btnQuarter">Set Quarter-Wave (δ = 90°)</button>
                <button class="btn" id="btnReset">Reset Defaults</button>
              </div>

              <div class="card">
                <div class="tag good">Live readout</div>
                <p class="note" style="margin:6px 0 0;">
                  Output ellipse azimuth (major-axis angle) <span style="font-family:var(--mono)">ψ</span>:
                  <strong id="readPsi" style="color:var(--text)"></strong><br/>
                  Output ellipticity angle <span style="font-family:var(--mono)">χ</span>:
                  <strong id="readChi" style="color:var(--text)"></strong><br/>
                  For δ = 180°: output is linear and <span style="font-family:var(--mono)">ψ = α′ = 2θ − α</span>.
                </p>
              </div>
            </div>
          </div>

          <div class="grid2" style="margin-top:14px;">
            <div class="vizPanel">
              <div class="vizHeader">
                <h3>Main quantitative plot: Output azimuth ψ vs plate angle θ</h3>
                <span class="pill" style="font-size:0.86rem;">Canvas 2</span>
              </div>
              <div class="vizBody">
                <canvas id="cPlot1" aria-label="Azimuth vs theta"></canvas>
                <p class="note" style="margin:10px 2px 0;">
                  For a half-wave plate (δ = 180°), this curve becomes a straight line: <span style="font-family:var(--mono)">ψ(θ)=2θ−α</span>.
                </p>
              </div>
            </div>

            <div class="vizPanel smallCanvas">
              <div class="vizHeader">
                <h3>Secondary plot: Ellipticity angle χ vs plate angle θ</h3>
                <span class="pill" style="font-size:0.86rem;">Canvas 3</span>
              </div>
              <div class="vizBody">
                <canvas id="cPlot2" aria-label="Ellipticity vs theta"></canvas>
                <p class="note" style="margin:10px 2px 0;">
                  When δ = 180°, χ → 0 for all θ, meaning the output is always linear (just reoriented).
                </p>
              </div>
            </div>
          </div>
        </section>

        <!-- PART 3 -->
        <section id="part3">
          <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

          <h3>Physical intuition (before math)</h3>
          <p>
            Decompose the input linear polarization into components along the plate’s <strong>fast axis</strong> and <strong>slow axis</strong>.
            A half-wave plate introduces a relative phase shift of <span style="font-family:var(--mono)">π</span> between these components.
            A phase shift of <span style="font-family:var(--mono)">π</span> is just a <strong>sign flip</strong> of one component.
            Geometrically, flipping the sign of the component perpendicular to the fast axis reflects the polarization direction across the fast axis.
            A reflection across a line changes an angle <span style="font-family:var(--mono)">+θ</span> to <span style="font-family:var(--mono)">−θ</span>.
          </p>

          <h3>Step 1: Define the input Jones vector in the plate (fast/slow) basis</h3>
          <p>
            Let the plate’s axes be <span style="font-family:var(--mono)">\u005Chat{f}</span> (fast) and <span style="font-family:var(--mono)">\u005Chat{s}</span> (slow).
            The input is linearly polarized making angle <span style="font-family:var(--mono)">θ</span> with the fast axis.
            In the <span style="font-family:var(--mono)">(f,s)</span> basis, a unit-amplitude linear polarization at angle <span style="font-family:var(--mono)">θ</span> is:
          </p>

          <div class="eqBlock">
            <button class="copyBtn" data-copy="E_in(fs) = [cosθ, sinθ]^T">Copy</button>
            <pre class="eq">E_in (fast/slow basis) = [ cosθ
                            sinθ ]</pre>
          </div>

          <p>
            <strong>Meaning:</strong> the field has amplitude <span style="font-family:var(--mono)">cosθ</span> along the fast axis and <span style="font-family:var(--mono)">sinθ</span> along the slow axis, with the same phase (so it’s linear).
          </p>

          <h3>Step 2: Write the half-wave plate matrix in its own basis</h3>
          <p>
            Choose the fast axis as the reference phase (no extra delay) and the slow axis as delayed by <span style="font-family:var(--mono)">δ</span>.
            Then:
          </p>

          <div class="eqBlock">
            <button class="copyBtn" data-copy="J_HWP = diag(1, e^{iπ}) = diag(1, -1)">Copy</button>
            <pre class="eq">J_HWP = diag(1, e^{iπ}) = diag(1, -1)</pre>
          </div>

          <p>
            <strong>Meaning:</strong> the slow component picks up a phase of π, i.e. it changes sign.
          </p>

          <h3>Step 3: Apply the matrix</h3>
          <p>Compute the output Jones vector in the same (fast/slow) basis:</p>

          <div class="eqBlock">
            <button class="copyBtn" data-copy="E_out(fs) = J_HWP E_in = [cosθ, -sinθ]^T">Copy</button>
            <pre class="eq">E_out = J_HWP · E_in
      = [ 1   0 ] [ cosθ ]   = [  cosθ ]
        [ 0  -1 ] [ sinθ ]     [ -sinθ ]</pre>
          </div>

          <p>
            <strong>What we did:</strong> multiplied the diagonal phase matrix into the component vector.
            <strong>Why:</strong> in the principal-axis basis, the waveplate action is simplest.
          </p>

          <h3>Step 4: Recognize the polarization angle of the output</h3>
          <p>
            The output vector <span style="font-family:var(--mono)">[cosθ, -sinθ]^T</span> has <em>real</em> components with a common phase (no relative complex phase),
            so the polarization is still <strong>linear</strong>.
            Its direction angle relative to the fast axis is the angle whose cosine and sine are the components:
          </p>

          <div class="eqBlock">
            <button class="copyBtn" data-copy="E_out(fs) ∝ [cos(−θ), sin(−θ)]^T  ⇒ output angle = −θ (relative fast axis)">Copy</button>
            <pre class="eq">[ cosθ, -sinθ ]^T = [ cos(-θ), sin(-θ) ]^T

⇒ output linear polarization makes angle  -θ  with the fast axis.</pre>
          </div>

          <div class="card" style="margin-top:12px;">
            <div class="tag good">Final result (as asked)</div>
            <p style="margin:8px 0 0; color:var(--muted);">
              If the incident polarization is at <strong>+θ</strong> relative to the fast axis, the transmitted polarization is at <strong>−θ</strong> relative to the fast axis.
              Therefore, the polarization direction has changed by <strong>2θ</strong> (a “rotation” by twice the initial offset from the fast axis).
            </p>
          </div>

          <h3>Step 5 (useful general form): Output angle in the lab frame</h3>
          <p>
            Often we define angles in the lab frame. Let:
          </p>
          <ul>
            <li><span style="font-family:var(--mono)">θ</span> = fast-axis angle relative to lab x</li>
            <li><span style="font-family:var(--mono)">α</span> = input linear polarization angle relative to lab x</li>
          </ul>
          <p>
            Then the input angle relative to the fast axis is <span style="font-family:var(--mono)">α - θ</span>.
            The half-wave plate flips that relative angle:
            <span style="font-family:var(--mono)">α′ - θ = -(α - θ)</span>.
            Solve for <span style="font-family:var(--mono)">α′</span>:
          </p>

          <div class="eqBlock">
            <button class="copyBtn" data-copy="α′ - θ = -(α - θ)  ⇒  α′ = 2θ - α">Copy</button>
            <pre class="eq">α′ - θ = -(α - θ)
⇒ α′ = 2θ - α</pre>
          </div>

          <div class="eqBlock">
            <button class="copyBtn" data-copy="Half-wave plate mapping for linear input: α → α′ = 2θ − α (a reflection about θ)">Copy</button>
            <pre class="eq">Half-wave plate (δ=π) acting on a linear input:
α  →  α′ = 2θ − α

Geometric meaning: reflection of the polarization direction about the fast axis (angle θ).</pre>
          </div>

          <h3>Why the half-wave retarder is NOT equivalent to a polarization rotator</h3>
          <p>
            A true “polarization rotator” (in the usual sense) applies a <strong>fixed rotation</strong> of the polarization state, independent of the input state:
            it would map <span style="font-family:var(--mono)">α → α + φ</span> for all linear inputs, and it has a consistent action on <em>all</em> polarization states.
          </p>
          <p>
            The half-wave plate instead performs:
            <span style="font-family:var(--mono)">α → 2θ − α</span>, which depends on <span style="font-family:var(--mono)">α</span>.
            That is a <strong>reflection</strong> in polarization-angle space, not a uniform rotation.
            Moreover, for non-linear input states, the half-wave plate generally produces a different elliptical state—not a simple “rotated” version.
          </p>

          <div class="card" style="margin-top:12px;">
            <div class="tag warn">Key conceptual distinction</div>
            <ul style="margin:8px 0 0 20px;">
              <li><strong>Waveplate:</strong> birefringent, phase-based, <strong>reciprocal</strong>; action depends on the state relative to its axes.</li>
              <li><strong>Faraday rotator (classic rotator):</strong> magneto-optic, <strong>non-reciprocal</strong>; rotates by the same angle even if you reverse propagation direction (within the same magnetic field orientation).</li>
            </ul>
          </div>

          <h3>Sanity checks</h3>
          <ul>
            <li><strong>Units:</strong> angles are dimensionless; Jones vectors are field amplitudes (often normalized).</li>
            <li><strong>Limiting case θ = 0:</strong> input aligned with fast axis → output unchanged (no “rotation”), and formula gives <span style="font-family:var(--mono)">α′ = -α</span> about the same axis; if α=0 it stays 0.</li>
            <li><strong>Limiting case α = θ:</strong> input is exactly along fast axis → output remains along fast axis; relative angle 0 flips to 0.</li>
            <li><strong>Direction/sign:</strong> the mapping <span style="font-family:var(--mono)">α′ = 2θ − α</span> is symmetric about θ, matching the reflection picture in the diagram/plot.</li>
          </ul>

          <p>
            Connect to the diagram: in the plate basis, the slow component changes sign. That is the same as reflecting the vector across the fast axis.
            The plots show this as a straight-line relation between output azimuth and plate angle when <span style="font-family:var(--mono)">δ=180°</span>.
          </p>

          <div class="eqBlock" style="margin-top:14px;">
            <button class="copyBtn" data-copy="FINAL: For half-wave plate (δ=π), linear input at angle α yields linear output at α′=2θ−α. Relative to fast axis: +θ → −θ, so the polarization direction changes by 2θ. Not a rotator because the mapping depends on α and does not act as a fixed rotation for arbitrary polarization states (and it is reciprocal).">Copy</button>
            <pre class="eq">FINAL ANSWER (plain text):
For a half-wave plate (δ=π), a linear input at angle α (lab) emerges linear at angle α′ = 2θ − α,
where θ is the fast-axis angle (lab). In the plate frame, an input at +θ to the fast axis emerges at −θ,
so the polarization direction changes by 2θ.

The half-wave retarder is not equivalent to a polarization rotator because it does not apply a fixed
rotation independent of the input state: it performs a reflection about its axis (α → 2θ − α) and, for
general (nonlinear) polarization states, it changes ellipticity. It is also a reciprocal birefringent
phase element, unlike non-reciprocal rotators (e.g., Faraday rotators).</pre>
          </div>
        </section>

        <!-- PART 4 -->
        <section id="part4">
          <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

          <h3>Re-interpret the final formula</h3>
          <p>
            The mapping <span style="font-family:var(--mono)">α′ = 2θ − α</span> says:
          </p>
          <ul>
            <li><span style="font-family:var(--mono)">θ</span> sets the <strong>mirror line</strong> (the fast axis). The output is symmetric around this line.</li>
            <li>The change <span style="font-family:var(--mono)">α′ − α = 2(θ − α)</span> is <strong>not constant</strong>; it depends on how far the input is from the fast axis.</li>
            <li>So a half-wave plate behaves like a “polarization mirror” rather than a fixed-angle rotator.</li>
          </ul>

          <h3>How changing parameters affects the outcome (connect to plots)</h3>
          <ul>
            <li>When you set <span style="font-family:var(--mono)">δ = 180°</span>, the ellipticity plot shows <span style="font-family:var(--mono)">χ ≈ 0</span> for all θ → output remains linear.</li>
            <li>If you change <span style="font-family:var(--mono)">δ</span> away from 180°, the output becomes elliptical for most θ; the azimuth <span style="font-family:var(--mono)">ψ</span> still varies smoothly but no longer represents a simple “rotated line.”</li>
            <li>At <span style="font-family:var(--mono)">δ = 90°</span> (quarter-wave), inputs at 45° to the axes become nearly circular (|χ| approaches 45°), visible in the ellipticity plot.</li>
          </ul>

          <h3>Alternative derivation idea (brief)</h3>
          <p>
            On the <strong>Poincaré sphere</strong>, a retarder corresponds to a rotation of the Stokes vector by angle δ about an axis determined by the plate orientation.
            For a half-wave plate (δ = π), the Stokes vector rotates by 180°, which acts like a “mirror” operation on the equator (linear states),
            giving the same reflection rule <span style="font-family:var(--mono)">α′ = 2θ − α</span>.
          </p>

          <h3>Concept checks (with answers)</h3>
          <ul>
            <li><strong>Q:</strong> If the input polarization is along the fast axis, does a half-wave plate change it?<br/>
                <strong>A:</strong> No. Only the slow component would flip sign, but it is zero in that case.</li>
            <li><strong>Q:</strong> Does a half-wave plate always “rotate polarization” by a fixed angle?<br/>
                <strong>A:</strong> No. For linear inputs it reflects about the fast axis; for general inputs it changes ellipticity.</li>
            <li><strong>Q:</strong> Why does δ = π keep linear polarization linear (for linear input)?<br/>
                <strong>A:</strong> Because the relative phase between components is 0 or π (both components remain in phase or anti-phase), which corresponds to a line, not an ellipse.</li>
            <li><strong>Q:</strong> What makes a Faraday rotator special compared to a waveplate?<br/>
                <strong>A:</strong> Faraday rotation is non-reciprocal: reversing direction does not undo the rotation (in the same magnetic field orientation).</li>
          </ul>
        </section>

        <!-- PART 5 -->
        <section id="part5">
          <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

          <h3>Canvas 1 — Diagram</h3>
          <ul>
            <li>Shows lab axes (x,y), the plate’s <strong>fast axis</strong> at angle θ, and the incident polarization direction at angle α.</li>
            <li>Also shows the output polarization ellipse computed after applying retardance δ. When δ = 180°, the ellipse collapses to a line.</li>
            <li>The diagram is the geometry behind the statement “angle +θ relative fast axis becomes −θ.”</li>
          </ul>

          <h3>Canvas 2 — Main plot (Output azimuth ψ vs θ)</h3>
          <ul>
            <li>Horizontal axis: plate angle θ (degrees).</li>
            <li>Vertical axis: output azimuth ψ (degrees), i.e., the major-axis orientation of the polarization ellipse.</li>
            <li>When δ = 180° (half-wave), ψ becomes the output linear angle and follows <span style="font-family:var(--mono)">ψ = 2θ − α</span> (a straight line).</li>
          </ul>

          <h3>Canvas 3 — Secondary plot (Ellipticity angle χ vs θ)</h3>
          <ul>
            <li>Ellipticity angle χ (degrees) measures how elliptical the polarization is:
              <span style="font-family:var(--mono)">χ = 0°</span> linear, <span style="font-family:var(--mono)">±45°</span> circular.</li>
            <li>For δ = 180°, χ stays near 0° for all θ → always linear output (just reoriented).</li>
          </ul>

          <h3>Interactive controls</h3>
          <ul>
            <li><strong>θ slider:</strong> rotates the fast/slow axes. All canvases update, showing the reflection behavior (especially at δ = 180°).</li>
            <li><strong>α slider:</strong> changes the input linear polarization direction. You’ll see the ψ(θ) curve shift accordingly.</li>
            <li><strong>δ slider:</strong> changes retardance. Watch χ become nonzero when δ ≠ 180° (output becomes elliptical).</li>
          </ul>
        </section>
      </article>
    </div>
  </main>

  <footer>
    <p>
      Built with vanilla HTML/CSS/JS. Visualizations compute Jones vectors and extract ellipse parameters (azimuth ψ and ellipticity χ) consistently with the symbols used in the text.
    </p>
  </footer>

  <div class="copyToast" id="toast">Copied!</div>

  <script>
    // ---------- Utilities ----------
    const DEG = Math.PI / 180;
    function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
    function wrapDeg180(x){
      // wrap to (-180, 180]
      let y = x % 360;
      if (y <= -180) y += 360;
      if (y > 180) y -= 360;
      return y;
    }
    function fmt(x, d=1){
      const s = (Math.round(x*10**d)/10**d).toFixed(d);
      return (x>=0? "+" : "") + s;
    }

    // Smooth scroll highlight for TOC
    const tocLinks = [...document.querySelectorAll('.tocLink')];
    const sections = tocLinks.map(a => document.querySelector(a.getAttribute('href'))).filter(Boolean);
    function updateTOCActive(){
      const y = window.scrollY + 110;
      let idx = 0;
      for (let i=0;i<sections.length;i++){
        const r = sections[i].getBoundingClientRect();
        const top = r.top + window.scrollY;
        if (top <= y) idx = i;
      }
      tocLinks.forEach((a,i)=>a.classList.toggle('active', i===idx));
    }
    window.addEventListener('scroll', updateTOCActive, {passive:true});
    window.addEventListener('load', updateTOCActive);

    // Copy buttons
    const toast = document.getElementById('toast');
    let toastTimer = null;
    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add('show');
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=>toast.classList.remove('show'), 1100);
    }
    document.addEventListener('click', async (e)=>{
      const btn = e.target.closest('.copyBtn');
      if(!btn) return;
      const txt = btn.getAttribute('data-copy') || '';
      try{
        await navigator.clipboard.writeText(txt);
        showToast('Copied to clipboard');
      }catch(err){
        // fallback
        const ta = document.createElement('textarea');
        ta.value = txt;
        ta.style.position = 'fixed';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.select();
        try{
          document.execCommand('copy');
          showToast('Copied');
        }catch(e2){
          showToast('Copy failed');
        }
        document.body.removeChild(ta);
      }
    });

    // ---------- Jones calculus + ellipse extraction ----------
    // Input: linear at angle alpha in LAB: E = [cos alpha, sin alpha]^T (real)
    // Plate: fast axis at angle theta in LAB, retardance delta between slow relative to fast
    // Compute E_out = R(theta) diag(1, e^{i delta}) R(-theta) E_in
    function R(theta){
      const c = Math.cos(theta), s = Math.sin(theta);
      return [[c, -s],[s, c]];
    }
    function matMul2(A,B){
      return [
        [A[0][0]*B[0][0]+A[0][1]*B[1][0], A[0][0]*B[0][1]+A[0][1]*B[1][1]],
        [A[1][0]*B[0][0]+A[1][1]*B[1][0], A[1][0]*B[0][1]+A[1][1]*B[1][1]],
      ];
    }
    function matVec2(A,v){
      return [
        A[0][0]*v[0] + A[0][1]*v[1],
        A[1][0]*v[0] + A[1][1]*v[1],
      ];
    }

    // Complex numbers as {re, im}
    function c(re, im){ return {re, im}; }
    function cMul(a,b){ return {re: a.re*b.re - a.im*b.im, im: a.re*b.im + a.im*b.re}; }
    function cAdd(a,b){ return {re: a.re+b.re, im: a.im+b.im}; }
    function cScale(a,s){ return {re: a.re*s, im: a.im*s}; }
    function cAbs2(a){ return a.re*a.re + a.im*a.im; }
    function cConj(a){ return {re:a.re, im:-a.im}; }
    function cArg(a){ return Math.atan2(a.im, a.re); }

    function expi(phi){ return {re: Math.cos(phi), im: Math.sin(phi)}; }

    function applyRetarder(alpha, theta, delta){
      // E_in real
      const Ein = [Math.cos(alpha), Math.sin(alpha)];
      const Rp = R(theta);
      const Rm = R(-theta);
      // in plate basis: v = R(-theta)*Ein (still real)
      const v = matVec2(Rm, Ein); // [E_fast, E_slow] in reals
      const Ef = c(v[0], 0);
      const Es = c(v[1], 0);
      const phase = expi(delta);
      const Es2 = cMul(Es, phase);
      // back to lab: Eout = R(theta) * [Ef, Es2]
      const Ex = cAdd(cScale(Ef, Rp[0][0]), cScale(Es2, Rp[0][1]));
      const Ey = cAdd(cScale(Ef, Rp[1][0]), cScale(Es2, Rp[1][1]));
      return {Ex, Ey};
    }

    // Extract polarization ellipse parameters from Jones vector:
    // Stokes:
    // S0 = |Ex|^2 + |Ey|^2
    // S1 = |Ex|^2 - |Ey|^2
    // S2 = 2 Re(Ex Ey*)
    // S3 = 2 Im(Ex Ey*)
    // Then:
    // ψ = 0.5 atan2(S2, S1)   (azimuth, radians)
    // χ = 0.5 asin(S3/S0)     (ellipticity angle, radians)
    function stokesFromJones(Ex, Ey){
      const S0 = cAbs2(Ex) + cAbs2(Ey);
      const S1 = cAbs2(Ex) - cAbs2(Ey);
      const EyConj = cConj(Ey);
      const prod = cMul(Ex, EyConj);
      const S2 = 2*prod.re;
      const S3 = 2*prod.im;
      return {S0,S1,S2,S3};
    }
    function ellipseParams(Ex, Ey){
      const {S0,S1,S2,S3} = stokesFromJones(Ex,Ey);
      const psi = 0.5*Math.atan2(S2, S1);
      const ratio = (S0===0)? 0 : clamp(S3/S0, -1, 1);
      const chi = 0.5*Math.asin(ratio);
      return {psi, chi, S0, S1, S2, S3};
    }

    // ---------- Canvas helpers ----------
    function makeCanvasHiDPI(canvas){
      const ctx = canvas.getContext('2d');
      function resize(){
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.max(2, Math.floor(rect.width * dpr));
        canvas.height = Math.max(2, Math.floor(rect.height * dpr));
        ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      }
      return {ctx, resize};
    }

    function drawGridAxes(ctx, W, H, plot){
      // plot: {x0,y0,w,h, xMin,xMax,yMin,yMax, xLabel,yLabel,title}
      const {x0,y0,w,h} = plot;
      // background
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.fillRect(x0,y0,w,h);
      // grid
      const gridN = 8;
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      for(let i=0;i<=gridN;i++){
        const x = x0 + w*i/gridN;
        ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+h); ctx.stroke();
        const y = y0 + h*i/gridN;
        ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+w,y); ctx.stroke();
      }
      // axes box
      ctx.strokeStyle = 'rgba(255,255,255,0.16)';
      ctx.strokeRect(x0,y0,w,h);

      // ticks + labels
      ctx.fillStyle = 'rgba(255,255,255,0.72)';
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      // x ticks
      const xticks = 6;
      for(let i=0;i<=xticks;i++){
        const t = i/xticks;
        const xv = plot.xMin + (plot.xMax-plot.xMin)*t;
        const x = x0 + w*t;
        ctx.strokeStyle = 'rgba(255,255,255,0.18)';
        ctx.beginPath(); ctx.moveTo(x,y0+h); ctx.lineTo(x,y0+h+6); ctx.stroke();
        ctx.fillText(xv.toFixed(0), x, y0+h+8);
      }
      // y ticks
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      const yticks = 6;
      for(let i=0;i<=yticks;i++){
        const t = i/yticks;
        const yv = plot.yMax - (plot.yMax-plot.yMin)*t;
        const y = y0 + h*t;
        ctx.strokeStyle = 'rgba(255,255,255,0.18)';
        ctx.beginPath(); ctx.moveTo(x0-6,y); ctx.lineTo(x0,y); ctx.stroke();
        ctx.fillText(yv.toFixed(0), x0-8, y);
      }

      // labels
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText(plot.xLabel, x0+w/2, y0+h+34);

      ctx.save();
      ctx.translate(x0-46, y0+h/2);
      ctx.rotate(-Math.PI/2);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText(plot.yLabel, 0, 0);
      ctx.restore();

      // title
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.font = '13px ui-sans-serif, system-ui';
      ctx.fillText(plot.title, x0, y0-22);
      ctx.restore();
    }

    function mapX(x, plot){
      return plot.x0 + (x-plot.xMin)/(plot.xMax-plot.xMin)*plot.w;
    }
    function mapY(y, plot){
      return plot.y0 + (plot.yMax-y)/(plot.yMax-plot.yMin)*plot.h;
    }

    // ---------- State + UI ----------
    const sTheta = document.getElementById('sTheta');
    const sAlpha = document.getElementById('sAlpha');
    const sDelta = document.getElementById('sDelta');
    const valTheta = document.getElementById('valTheta');
    const valAlpha = document.getElementById('valAlpha');
    const valDelta = document.getElementById('valDelta');

    const readPsi = document.getElementById('readPsi');
    const readChi = document.getElementById('readChi');

    const btnHalf = document.getElementById('btnHalf');
    const btnQuarter = document.getElementById('btnQuarter');
    const btnReset = document.getElementById('btnReset');

    const cDiagram = document.getElementById('cDiagram');
    const cPlot1 = document.getElementById('cPlot1');
    const cPlot2 = document.getElementById('cPlot2');

    const diag = makeCanvasHiDPI(cDiagram);
    const p1 = makeCanvasHiDPI(cPlot1);
    const p2 = makeCanvasHiDPI(cPlot2);

    function getState(){
      return {
        thetaDeg: parseFloat(sTheta.value),
        alphaDeg: parseFloat(sAlpha.value),
        deltaDeg: parseFloat(sDelta.value),
      };
    }

    function setState({thetaDeg, alphaDeg, deltaDeg}){
      if(thetaDeg!=null) sTheta.value = thetaDeg;
      if(alphaDeg!=null) sAlpha.value = alphaDeg;
      if(deltaDeg!=null) sDelta.value = deltaDeg;
      renderAll();
    }

    btnHalf.addEventListener('click', ()=> setState({deltaDeg:180}));
    btnQuarter.addEventListener('click', ()=> setState({deltaDeg:90}));
    btnReset.addEventListener('click', ()=> setState({thetaDeg:25, alphaDeg:10, deltaDeg:180}));

    [sTheta,sAlpha,sDelta].forEach(el => el.addEventListener('input', renderAll));
    window.addEventListener('resize', ()=>{
      diag.resize(); p1.resize(); p2.resize();
      renderAll();
    });

    // ---------- Rendering ----------
    function renderAll(){
      valTheta.textContent = `${fmt(getState().thetaDeg,1)}°`;
      valAlpha.textContent = `${fmt(getState().alphaDeg,1)}°`;
      valDelta.textContent = `${fmt(getState().deltaDeg,1)}°`;

      // resize canvases to stay crisp
      diag.resize(); p1.resize(); p2.resize();

      const st = getState();
      const theta = st.thetaDeg*DEG;
      const alpha = st.alphaDeg*DEG;
      const delta = st.deltaDeg*DEG;

      const Eout = applyRetarder(alpha, theta, delta);
      const ep = ellipseParams(Eout.Ex, Eout.Ey);

      // Readouts
      let psiDeg = wrapDeg180(ep.psi/DEG);
      let chiDeg = ep.chi/DEG;
      readPsi.textContent = `${fmt(psiDeg,1)}°`;
      readChi.textContent = `${fmt(chiDeg,1)}°`;

      drawDiagram(diag.ctx, cDiagram.getBoundingClientRect().width, cDiagram.getBoundingClientRect().height, st, Eout, ep);
      drawPlotPsi(p1.ctx, cPlot1.getBoundingClientRect().width, cPlot1.getBoundingClientRect().height, st);
      drawPlotChi(p2.ctx, cPlot2.getBoundingClientRect().width, cPlot2.getBoundingClientRect().height, st);
    }

    function drawDiagram(ctx, W, H, st, Eout, ep){
      ctx.clearRect(0,0,W,H);

      // Coordinate system center
      const cx = W*0.50;
      const cy = H*0.56;

      // Scale
      const R = Math.min(W,H)*0.34;

      // Background subtle vignette
      const grad = ctx.createRadialGradient(cx, cy, R*0.2, cx, cy, R*1.25);
      grad.addColorStop(0,'rgba(255,255,255,0.06)');
      grad.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,W,H);

      // Title
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.font = '13px ui-sans-serif, system-ui';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText('Polarization geometry in the transverse plane (example visualization)', 12, 10);

      // Axes (lab)
      ctx.save();
      ctx.translate(cx, cy);
      ctx.lineWidth = 2;

      // grid circle
      ctx.strokeStyle = 'rgba(255,255,255,0.10)';
      ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0,R*0.5,0,Math.PI*2); ctx.stroke();

      // lab axes
      ctx.strokeStyle = 'rgba(125,211,252,0.55)';
      ctx.beginPath(); ctx.moveTo(-R,0); ctx.lineTo(R,0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,-R); ctx.lineTo(0,R); ctx.stroke();

      // labels
      ctx.fillStyle = 'rgba(125,211,252,0.95)';
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText('x (lab)', R-6, -6);
      ctx.textBaseline = 'top';
      ctx.fillText('y (lab)', 10, -R+6);

      // Fast axis (theta)
      const th = st.thetaDeg*DEG;
      const fx = Math.cos(th), fy = Math.sin(th);
      const sx = -Math.sin(th), sy = Math.cos(th);

      // fast axis line
      ctx.strokeStyle = 'rgba(167,139,250,0.65)';
      ctx.beginPath(); ctx.moveTo(-fx*R, -fy*R); ctx.lineTo(fx*R, fy*R); ctx.stroke();

      // slow axis line
      ctx.strokeStyle = 'rgba(52,211,153,0.55)';
      ctx.beginPath(); ctx.moveTo(-sx*R, -sy*R); ctx.lineTo(sx*R, sy*R); ctx.stroke();

      // axis labels
      ctx.fillStyle = 'rgba(167,139,250,0.95)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText('fast', fx*R*0.72 + 6, fy*R*0.72);

      ctx.fillStyle = 'rgba(52,211,153,0.92)';
      ctx.fillText('slow', sx*R*0.72 + 6, sy*R*0.72);

      // Input polarization arrow (alpha)
      const a = st.alphaDeg*DEG;
      const ix = Math.cos(a), iy = Math.sin(a);
      drawArrow(ctx, 0,0, ix*R*0.92, iy*R*0.92, 'rgba(125,211,252,0.95)', 2.6);
      ctx.fillStyle = 'rgba(125,211,252,0.95)';
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.textAlign = 'left';
      ctx.fillText('E_in', ix*R*0.92 + 6, iy*R*0.92);

      // Output: draw ellipse from Jones vector
      const ex = Eout.Ex, ey = Eout.Ey;
      const S = ep; // has psi, chi

      // Build ellipse parametric curve from Jones: E(t) = Re{ Ex e^{-iωt} } xhat + Re{ Ey e^{-iωt} } yhat
      // Take ωt as parameter phi in [0,2π].
      ctx.strokeStyle = 'rgba(255,255,255,0.82)';
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      const N = 240;
      for(let k=0;k<=N;k++){
        const phi = (k/N)*Math.PI*2;
        const cosp = Math.cos(phi), sinp = Math.sin(phi);
        // Re{ (re + i im) (cos - i sin) } = re*cos + im*sin
        const x = (ex.re*cosp + ex.im*sinp);
        const y = (ey.re*cosp + ey.im*sinp);
        // normalize for drawing
        const scale = R*0.92;
        const nx = x*scale;
        const ny = y*scale;
        if(k===0) ctx.moveTo(nx, ny);
        else ctx.lineTo(nx, ny);
      }
      ctx.stroke();

      // major axis direction (psi)
      const psi = S.psi;
      const mx = Math.cos(psi), my = Math.sin(psi);
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(-mx*R*0.95, -my*R*0.95); ctx.lineTo(mx*R*0.95, my*R*0.95); ctx.stroke();

      // Output label
      drawArrow(ctx, 0,0, mx*R*0.80, my*R*0.80, 'rgba(255,255,255,0.70)', 2.3);
      ctx.fillStyle = 'rgba(255,255,255,0.90)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText('major axis (ψ)', mx*R*0.80 + 6, my*R*0.80);

      // Angle markers for alpha and theta
      drawAngleArc(ctx, 0,0, R*0.28, 0, th, 'rgba(167,139,250,0.65)');
      drawAngleArc(ctx, 0,0, R*0.22, 0, a, 'rgba(125,211,252,0.60)');

      // Legend-like annotation
      ctx.resetTransform();
      ctx.fillStyle = 'rgba(255,255,255,0.78)';
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      const info1 = `θ = ${st.thetaDeg.toFixed(1)}° (fast-axis),  α = ${st.alphaDeg.toFixed(1)}° (input),  δ = ${st.deltaDeg.toFixed(0)}°`;
      const info2 = `Output: ψ = ${wrapDeg180(S.psi/DEG).toFixed(1)}°,  χ = ${(S.chi/DEG).toFixed(1)}° (0° linear, ±45° circular)`;
      ctx.fillText(info1, 12, H-32);
      ctx.fillText(info2, 12, H-14);

      ctx.restore();
    }

    function drawArrow(ctx, x0,y0,x1,y1, color, lw){
      ctx.save();
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = lw;
      ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
      const ang = Math.atan2(y1-y0, x1-x0);
      const head = 10;
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x1 - head*Math.cos(ang-0.35), y1 - head*Math.sin(ang-0.35));
      ctx.lineTo(x1 - head*Math.cos(ang+0.35), y1 - head*Math.sin(ang+0.35));
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawAngleArc(ctx, cx,cy,r, a0, a1, color){
      // draw from a0 to a1 (could be negative); choose direction with small arc
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      // choose arc direction as given
      ctx.beginPath();
      ctx.arc(cx,cy,r, a0, a1, a1<a0);
      ctx.stroke();
      ctx.restore();
    }

    function drawPlotPsi(ctx, W, H, st){
      ctx.clearRect(0,0,W,H);

      const padL=58, padR=18, padT=36, padB=50;
      const plot = {
        x0: padL, y0: padT, w: W-padL-padR, h: H-padT-padB,
        xMin: -90, xMax: 90,
        yMin: -90, yMax: 90,
        xLabel: 'plate angle θ (deg)',
        yLabel: 'output azimuth ψ (deg)',
        title: 'Output azimuth ψ versus θ (for current α and δ)'
      };
      drawGridAxes(ctx,W,H,plot);

      const alpha = st.alphaDeg*DEG;
      const delta = st.deltaDeg*DEG;

      // curve ψ(θ)
      ctx.save();
      ctx.strokeStyle = 'rgba(125,211,252,0.85)';
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      const N = 260;
      for(let i=0;i<=N;i++){
        const thDeg = plot.xMin + (plot.xMax-plot.xMin)*i/N;
        const th = thDeg*DEG;
        const Eout = applyRetarder(alpha, th, delta);
        const ep = ellipseParams(Eout.Ex, Eout.Ey);
        let psiDeg = wrapDeg180(ep.psi/DEG);
        // map
        const x = mapX(thDeg, plot);
        const y = mapY(psiDeg, plot);
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.stroke();

      // reference line for half-wave prediction ψ=2θ-α when δ=π
      ctx.setLineDash([6,6]);
      ctx.strokeStyle = 'rgba(167,139,250,0.65)';
      ctx.lineWidth = 1.8;
      ctx.beginPath();
      for(let i=0;i<=N;i++){
        const thDeg = plot.xMin + (plot.xMax-plot.xMin)*i/N;
        const psiPred = wrapDeg180(2*thDeg - st.alphaDeg);
        const x = mapX(thDeg, plot);
        const y = mapY(psiPred, plot);
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.setLineDash([]);

      // current point
      const thNow = st.thetaDeg;
      const EoutNow = applyRetarder(alpha, st.thetaDeg*DEG, delta);
      const epNow = ellipseParams(EoutNow.Ex, EoutNow.Ey);
      const psiNow = wrapDeg180(epNow.psi/DEG);
      const xNow = mapX(thNow, plot);
      const yNow = mapY(psiNow, plot);

      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(xNow,yNow,5,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(xNow,yNow,9,0,Math.PI*2); ctx.stroke();

      // legend
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      const lx = plot.x0 + 8, ly = plot.y0 + 8;
      // solid line
      ctx.strokeStyle = 'rgba(125,211,252,0.85)'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(lx,ly+6); ctx.lineTo(lx+22,ly+6); ctx.stroke();
      ctx.fillText('Computed ψ(θ) from Jones vector', lx+30, ly);
      // dashed line
      ctx.strokeStyle = 'rgba(167,139,250,0.65)'; ctx.lineWidth = 2; ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(lx,ly+26); ctx.lineTo(lx+22,ly+26); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillText('Half-wave prediction ψ = 2θ − α (for comparison)', lx+30, ly+20);

      ctx.restore();
    }

    function drawPlotChi(ctx, W, H, st){
      ctx.clearRect(0,0,W,H);

      const padL=58, padR=18, padT=36, padB=50;
      const plot = {
        x0: padL, y0: padT, w: W-padL-padR, h: H-padT-padB,
        xMin: -90, xMax: 90,
        yMin: -45, yMax: 45,
        xLabel: 'plate angle θ (deg)',
        yLabel: 'ellipticity χ (deg)',
        title: 'Ellipticity χ versus θ (0° linear, ±45° circular)'
      };
      drawGridAxes(ctx,W,H,plot);

      const alpha = st.alphaDeg*DEG;
      const delta = st.deltaDeg*DEG;

      ctx.save();
      ctx.strokeStyle = 'rgba(52,211,153,0.85)';
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      const N = 260;
      for(let i=0;i<=N;i++){
        const thDeg = plot.xMin + (plot.xMax-plot.xMin)*i/N;
        const th = thDeg*DEG;
        const Eout = applyRetarder(alpha, th, delta);
        const ep = ellipseParams(Eout.Ex, Eout.Ey);
        const chiDeg = ep.chi/DEG;
        const x = mapX(thDeg, plot);
        const y = mapY(chiDeg, plot);
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.stroke();

      // zero line
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(mapX(plot.xMin,plot), mapY(0,plot));
      ctx.lineTo(mapX(plot.xMax,plot), mapY(0,plot));
      ctx.stroke();

      // current point
      const EoutNow = applyRetarder(alpha, st.thetaDeg*DEG, delta);
      const epNow = ellipseParams(EoutNow.Ex, EoutNow.Ey);
      const chiNow = epNow.chi/DEG;
      const xNow = mapX(st.thetaDeg, plot);
      const yNow = mapY(chiNow, plot);

      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(xNow,yNow,5,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(xNow,yNow,9,0,Math.PI*2); ctx.stroke();

      // legend
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      const lx = plot.x0 + 8, ly = plot.y0 + 8;
      ctx.strokeStyle = 'rgba(52,211,153,0.85)'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(lx,ly+6); ctx.lineTo(lx+22,ly+6); ctx.stroke();
      ctx.fillText('Computed χ(θ) from Jones vector', lx+30, ly);
      ctx.strokeStyle = 'rgba(255,255,255,0.25)'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(lx,ly+26); ctx.lineTo(lx+22,ly+26); ctx.stroke();
      ctx.fillText('χ = 0 line (linear polarization)', lx+30, ly+20);

      ctx.restore();
    }

    // Initial render
    renderAll();
  </script>
</body>
</html>
