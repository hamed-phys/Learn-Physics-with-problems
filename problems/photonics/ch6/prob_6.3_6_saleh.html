<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Conical Refraction in a Biaxial Crystal — Theory, Derivation, and Visualizations</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --card2:#0f1730;
      --text:#eaf0ff;
      --muted:#b9c4e6;
      --faint:#7f8bb8;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --ok:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 18px 45px rgba(0,0,0,.35);
      --shadow2: 0 12px 28px rgba(0,0,0,.28);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Helvetica Neue", sans-serif;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:
        radial-gradient(1200px 600px at 15% 10%, rgba(125,211,252,.14), transparent 60%),
        radial-gradient(900px 520px at 85% 15%, rgba(167,139,250,.12), transparent 62%),
        radial-gradient(700px 420px at 50% 85%, rgba(52,211,153,.08), transparent 60%),
        linear-gradient(180deg, #070a14 0%, #0b1020 70%, #070a14 100%);
      color:var(--text);
      font-family:var(--sans);
      line-height:1.6;
    }

    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}

    header{
      position:relative;
      padding: 44px 18px 18px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .hero{
      display:grid;
      gap:18px;
      grid-template-columns: 1.35fr .65fr;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns: 1fr}
    }

    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding: 22px 22px 18px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .titleCard:before{
      content:"";
      position:absolute;
      inset:-2px -2px auto -2px;
      height:4px;
      background: linear-gradient(90deg, rgba(125,211,252,.7), rgba(167,139,250,.7), rgba(52,211,153,.6));
      opacity:.85;
    }

    h1{
      margin: 0 0 6px;
      font-size: clamp(1.5rem, 1.2rem + 1.6vw, 2.25rem);
      letter-spacing:.2px;
      line-height:1.15;
    }
    .subtitle{
      color:var(--muted);
      margin:0 0 12px;
      font-size: 1.02rem;
    }
    .metaRow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      margin-top: 10px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 7px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(15,23,48,.55);
      color: var(--muted);
      font-size:.88rem;
      backdrop-filter: blur(8px);
    }
    .dot{
      width:9px;height:9px;border-radius:99px;background:var(--accent);
      box-shadow: 0 0 0 3px rgba(125,211,252,.15);
    }

    .toc{
      position: sticky;
      top: 14px;
      align-self:start;
      background: rgba(17,26,51,.68);
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding: 14px 14px 10px;
      box-shadow: var(--shadow2);
      backdrop-filter: blur(10px);
    }
    .toc h2{
      font-size:.95rem;
      margin:0 0 8px;
      color:var(--muted);
      letter-spacing:.3px;
      text-transform:uppercase;
    }
    .toc a{
      display:block;
      padding: 7px 10px;
      border-radius: 12px;
      color: var(--text);
      font-size:.92rem;
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .toc a:hover{
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.22);
      transform: translateX(2px);
      text-decoration:none;
    }

    main{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 18px 54px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 18px;
    }

    section{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.025));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding: 18px 18px 16px;
      box-shadow: var(--shadow2);
      overflow:hidden;
      position:relative;
    }

    section h2{
      margin: 0 0 10px;
      font-size: 1.25rem;
      letter-spacing:.2px;
    }
    section h3{
      margin: 18px 0 10px;
      font-size: 1.06rem;
      color: var(--text);
    }
    p{margin: 10px 0; color: var(--muted)}
    ul{margin: 10px 0 10px 20px; color: var(--muted)}
    li{margin:6px 0}

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      .grid2{grid-template-columns:1fr}
    }

    .callout{
      border-radius: 16px;
      border:1px solid var(--line);
      background: rgba(15,23,48,.58);
      padding: 12px 12px 10px;
      position:relative;
      overflow:hidden;
    }
    .callout strong{color: var(--text)}
    .callout .tag{
      display:inline-block;
      font-size:.78rem;
      color: var(--text);
      padding: 4px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      margin-bottom:8px;
    }
    .callout.assumptions .tag{border-color: rgba(52,211,153,.28); background: rgba(52,211,153,.10)}
    .callout.keyeq .tag{border-color: rgba(125,211,252,.28); background: rgba(125,211,252,.10)}
    .callout.mistakes .tag{border-color: rgba(251,191,36,.30); background: rgba(251,191,36,.12)}
    .callout.final .tag{border-color: rgba(167,139,250,.30); background: rgba(167,139,250,.12)}

    .eqBlock{
      margin: 10px 0;
      border-radius: 16px;
      border:1px solid rgba(125,211,252,.25);
      background: rgba(7,10,20,.55);
      padding: 10px 10px 10px;
      overflow:auto;
      position:relative;
    }
    pre, code{
      font-family: var(--mono);
      color:#eaf0ff;
      font-size: .95rem;
    }
    pre{margin:0; white-space:pre-wrap}
    .copyRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .btn{
      appearance:none;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 9px 12px;
      border-radius: 14px;
      cursor:pointer;
      font-weight: 600;
      font-size:.92rem;
      transition: transform .12s ease, border-color .12s ease, background .12s ease, box-shadow .12s ease;
      box-shadow: 0 10px 22px rgba(0,0,0,.18);
    }
    .btn:hover{
      transform: translateY(-1px);
      border-color: rgba(125,211,252,.28);
      background: rgba(125,211,252,.10);
    }
    .btn:active{transform: translateY(0px) scale(.99)}
    .btn.small{padding:7px 10px; font-size:.86rem; border-radius: 12px}

    .vizWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
      margin-top: 10px;
    }

    figure{
      margin:0;
      border-radius: 18px;
      border:1px solid var(--line);
      background: rgba(7,10,20,.45);
      overflow:hidden;
    }
    .figHead{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      border-bottom:1px solid var(--line);
      background: rgba(17,26,51,.38);
    }
    .figHead .title{
      color: var(--text);
      font-weight:700;
      font-size:.98rem;
    }
    .figHead .note{
      color: var(--faint);
      font-size:.86rem;
    }
    canvas{
      width:100%;
      height: 360px;
      display:block;
      background: transparent;
    }
    @media (max-width: 980px){
      canvas{height: 320px}
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    @media (max-width: 980px){
      .controls{grid-template-columns: 1fr 1fr}
    }
    .control{
      border:1px solid var(--line);
      background: rgba(15,23,48,.55);
      border-radius: 16px;
      padding: 10px 10px 8px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      color: var(--muted);
      font-size:.9rem;
      margin-bottom: 6px;
    }
    .control output{
      color: var(--text);
      font-weight: 700;
      font-family: var(--mono);
      font-size: .9rem;
    }
    input[type="range"]{width:100%}
    select{
      width:100%;
      border-radius: 12px;
      border:1px solid var(--line);
      background: rgba(7,10,20,.4);
      color: var(--text);
      padding: 9px 10px;
      font-weight: 600;
    }

    .fadeIn{
      animation: pop .42s ease both;
    }
    @keyframes pop{
      from{opacity:0; transform: translateY(6px)}
      to{opacity:1; transform: translateY(0)}
    }

    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 14px 18px 40px;
      color: var(--faint);
      font-size: .9rem;
    }

    /* Print-friendly */
    @media print{
      body{background:white; color:black}
      header, main, section, .titleCard, .toc, figure, .callout, .eqBlock{box-shadow:none}
      .toc{position:static}
      canvas{display:none}
      .notePrint{display:block !important}
      a{color:black; text-decoration:underline}
      .btn{display:none}
      .control{display:none}
    }
    .notePrint{display:none; color:var(--muted); margin-top:10px}
  </style>
</head>
<body>

<header class="fadeIn">
  <div class="hero">
    <div class="titleCard">
      <h1>Conical Refraction (Biaxial Crystals): Why a Single Beam Becomes a Cone — and a Ring in Air</h1>
      <p class="subtitle">
        A mini-lecture + full worked solution (symbolic, with interactive plots) for the classic biaxial-crystal phenomenon:
        when the wavevector <span style="font-family:var(--mono)">k</span> aligns with an optic axis, the dispersion surface becomes locally conical,
        producing a continuum of refracted rays.
      </p>
      <div class="metaRow">
        <span class="pill"><span class="dot"></span> optics • anisotropy • wave normals vs rays</span>
        <span class="pill"><span class="dot" style="background:var(--accent2); box-shadow:0 0 0 3px rgba(167,139,250,.15)"></span> k-surface geometry</span>
        <span class="pill"><span class="dot" style="background:var(--ok); box-shadow:0 0 0 3px rgba(52,211,153,.15)"></span> conical refraction → ring</span>
      </div>
      <p class="notePrint">
        Print note: interactive canvases are hidden in print. The formulas and explanations remain.
      </p>
    </div>

    <nav class="toc" aria-label="Table of Contents">
      <h2>Contents</h2>
      <a href="#quick" data-scroll>Quick Summary</a>
      <a href="#p0" data-scroll>PART 0 — Concept Primer</a>
      <a href="#p1" data-scroll>PART 1 — Problem Analysis</a>
      <a href="#p2" data-scroll>PART 2 — Strategy & Tips</a>
      <a href="#p3" data-scroll>PART 3 — Full Solution</a>
      <a href="#p4" data-scroll>PART 4 — Deeper Understanding</a>
      <a href="#p5" data-scroll>PART 5 — Visualization Guide</a>
    </nav>
  </div>
</header>

<main>

  <section id="quick" class="fadeIn">
    <h2>Quick Summary</h2>
    <ul>
      <li><strong>What this is about:</strong> Conical refraction in a <strong>biaxial</strong> crystal when the incident beam is aligned with an <strong>optic axis</strong>.</li>
      <li><strong>Key physics idea:</strong> Near an optic axis, the two sheets of the crystal’s dispersion (the <em>k-surface</em>) <strong>touch</strong> and can be approximated locally by a <strong>cone</strong>.</li>
      <li><strong>Why multiple rays appear:</strong> The <strong>ray (energy) direction</strong> follows the <strong>group velocity</strong>, which is normal to the k-surface; normals to a cone form a <strong>cone of directions</strong>.</li>
      <li><strong>Governing relationship:</strong> For fixed frequency <span style="font-family:var(--mono)">ω</span>, dispersion gives <span style="font-family:var(--mono)">ω = ω(k)</span>, and rays follow <span style="font-family:var(--mono)">v_g = ∇_k ω</span> (normal to the k-surface).</li>
      <li><strong>Internal result type:</strong> A <strong>hollow cone of rays</strong> inside the crystal with semi-angle <span style="font-family:var(--mono)">ρ</span> (a material-dependent “conical-refraction angle”).</li>
      <li><strong>What happens at the exit into air:</strong> The cone refracts again; for a plane exit face, the emergent field produces a <strong>ring</strong> in a screen plane (intersection of a cone with a plane), with radius <span style="font-family:var(--mono)">R ≈ L tan(θ_air)</span>.</li>
      <li><strong>External cone angle (simple model):</strong> Treat each conical ray as incident at angle <span style="font-family:var(--mono)">ρ</span> to the normal inside an effective index <span style="font-family:var(--mono)">n_eff</span>, then <span style="font-family:var(--mono)">sin(θ_air) ≈ n_eff sin(ρ)</span> (Snell-like mapping for ray directions).</li>
    </ul>

    <div class="callout final">
      <div class="tag">Final result (what you should conclude)</div>
      <p>
        <strong>Inside the biaxial crystal:</strong> a normally incident beam along an optic axis does <em>not</em> yield just “ordinary/extraordinary” refraction.
        Because the k-surface is locally <strong>conical</strong>, the energy-flow directions span a <strong>continuous cone</strong> (conical refraction).
        <br/>
        <strong>After exiting a parallel face into air:</strong> that conical bundle maps to an <strong>external cone</strong>, and in any plane perpendicular to the axis
        it forms a <strong>ring</strong> (often observed as a bright ring, sometimes with a split/double-ring structure in more refined treatments).
      </p>
      <div class="copyRow">
        <button class="btn small" data-copy="final">Copy final answer (plain text)</button>
      </div>
      <div class="eqBlock" style="margin-top:10px">
<pre id="finalText">Inside crystal: ray directions form a cone because v_g = ∇_k ω is normal to the (locally conical) k-surface near an optic axis.
Exit to air (parallel face): conical rays refract to an external cone; on a screen at distance L the pattern is a ring with R ≈ L tan(θ_air),
with θ_air related to the internal cone angle ρ by sin(θ_air) ≈ n_eff sin(ρ) (simple Snell-like mapping).</pre>
      </div>
    </div>
  </section>

  <section id="p0" class="fadeIn">
    <h2>PART 0 — Concept Primer (THEORY BEFORE SOLVING)</h2>

    <div class="grid2">
      <div>
        <h3>0.1 Core definitions (symbols & units)</h3>
        <ul>
          <li><strong>Wavevector</strong> <span style="font-family:var(--mono)">k</span> [rad/m]: points along the <em>phase normal</em> (direction of constant phase planes).</li>
          <li><strong>Angular frequency</strong> <span style="font-family:var(--mono)">ω</span> [rad/s], <strong>wavelength</strong> in vacuum <span style="font-family:var(--mono)">λ0</span> [m].</li>
          <li><strong>Refractive indices</strong> <span style="font-family:var(--mono)">n1, n2, n3</span> [dimensionless]: principal indices of a biaxial crystal (typically along principal axes).</li>
          <li><strong>Dispersion surface / k-surface</strong>: for fixed <span style="font-family:var(--mono)">ω</span>, the allowed <span style="font-family:var(--mono)">k</span> vectors lie on surfaces <span style="font-family:var(--mono)">F(k, ω)=0</span>. In anisotropic media there are generally <strong>two sheets</strong> (two polarizations).</li>
          <li><strong>Group velocity</strong> <span style="font-family:var(--mono)">v_g</span> [m/s]: <span style="font-family:var(--mono)">v_g = ∇_k ω</span>. This points along energy flow (ray direction) in lossless media.</li>
          <li><strong>Conical refraction semi-angle</strong> <span style="font-family:var(--mono)">ρ</span> [rad]: the half-angle of the cone of ray directions inside the crystal (material/geometry dependent).</li>
        </ul>
      </div>

      <div>
        <h3>0.2 Physical meaning (what the quantities “mean”)</h3>
        <ul>
          <li><span style="font-family:var(--mono)">k</span> determines how the phase advances; in anisotropic crystals, <span style="font-family:var(--mono)">k</span> is generally <strong>not parallel</strong> to the ray direction.</li>
          <li>The k-surface geometry encodes the allowed plane waves: its <strong>shape</strong> tells you how phase velocity depends on direction.</li>
          <li><span style="font-family:var(--mono)">v_g</span> is perpendicular (normal) to constant-ω surfaces in k-space. So the <strong>local geometry</strong> of the k-surface directly dictates ray directions.</li>
          <li>In a biaxial crystal, there are <strong>two optic axes</strong>: special directions where the two sheets become degenerate (touch). Near those directions, unusual refraction occurs.</li>
        </ul>
      </div>
    </div>

    <h3>0.3 Key laws/principles + validity conditions</h3>
    <div class="callout keyeq">
      <div class="tag">Key principle</div>
      <p>
        For a monochromatic wave in a transparent (lossless) medium, <strong>energy/ray direction</strong> is given by the group velocity:
        <strong><span style="font-family:var(--mono)">v_g = ∇_k ω</span></strong>, which is <strong>normal to the k-surface</strong> <span style="font-family:var(--mono)">ω(k)=const</span>.
      </p>
      <div class="eqBlock">
<pre id="eq_vg">v_g = ∇_k ω
=> v_g ⟂ (ω(k)=const)  (i.e., normal to the k-surface)</pre>
      </div>
      <div class="copyRow">
        <button class="btn small" data-copy="eq_vg">Copy equation</button>
      </div>
      <p style="color:var(--faint); margin-top:8px">
        Valid when: linear optics, weak absorption (or none), steady-state harmonic fields, and when a ray (geometric optics) description is appropriate.
      </p>
    </div>

    <h3>0.4 Common models/approximations (and why we use them)</h3>
    <ul>
      <li><strong>Local conical approximation:</strong> near an optic axis, the two sheets of the k-surface touch and can be approximated locally by a cone. This captures the “many ray directions” geometry cleanly.</li>
      <li><strong>Small-angle / paraxial cone:</strong> conical refraction angles are often small (mrad–deg). Then <span style="font-family:var(--mono)">sin ρ ≈ ρ</span>, <span style="font-family:var(--mono)">tan ρ ≈ ρ</span>.</li>
      <li><strong>Snell-like mapping for rays at the exit face:</strong> treat each ray in the cone as an individual direction refracting from an effective index <span style="font-family:var(--mono)">n_eff</span> to air.</li>
    </ul>

    <h3>0.5 Mini intuition examples (no long algebra)</h3>
    <ul>
      <li><strong>Sphere vs cone in k-space:</strong> In an isotropic medium, the k-surface is a sphere. Normals all point radially → a single ray direction for each <span style="font-family:var(--mono)">k</span>. If the surface becomes conical, normals span a cone → a continuum of ray directions.</li>
      <li><strong>Intersection with a screen:</strong> A cone of rays intersecting a flat screen makes a ring. That’s why conical refraction is often observed as a bright ring pattern.</li>
    </ul>

    <div class="callout mistakes">
      <div class="tag">What to watch for (pitfalls)</div>
      <ul>
        <li><strong>Mixing up directions:</strong> <span style="font-family:var(--mono)">k</span> (phase normal) is not generally the ray direction in anisotropic media.</li>
        <li><strong>Thinking “only two refracted rays”:</strong> that’s typical away from optic axes; at an optic axis the degeneracy creates a continuum.</li>
        <li><strong>Assuming the cone stays unchanged in air:</strong> refraction at the second face changes the cone angle (and can distort polarization details).</li>
      </ul>
    </div>
  </section>

  <section id="p1" class="fadeIn">
    <h2>PART 1 — Problem Analysis (no solving yet)</h2>

    <h3>1.1 Restate the problem in clear words</h3>
    <p>
      A collimated ray (beam) is <strong>normally incident</strong> on the entrance face of a <strong>biaxial crystal</strong>.
      The crystal is oriented so that <strong>one optic axis is also normal to the surface</strong>. When the wavevector <span style="font-family:var(--mono)">k</span>
      points along an optic axis, the two k-surface sheets meet and are locally conical.
      <br/><br/>
      <strong>Task A:</strong> Show that refraction becomes <strong>multiple</strong>: the refracted rays inside the crystal form a <strong>cone</strong> (conical refraction).
      <br/>
      <strong>Task B:</strong> Explain what happens when those conical rays hit the <strong>parallel exit face</strong> and refract into <strong>air</strong>.
    </p>

    <div class="grid2">
      <div class="callout assumptions">
        <div class="tag">Given</div>
        <ul>
          <li>Biaxial crystal; one optic axis aligned with the surface normal (call it <span style="font-family:var(--mono)">z</span>).</li>
          <li>Incident ray is normal to the entrance face (incident direction along <span style="font-family:var(--mono)">+z</span>).</li>
          <li>Near optic axis, k-surface sheets meet and are approximated by a cone (local model).</li>
        </ul>
      </div>
      <div class="callout assumptions">
        <div class="tag">Unknowns / what must be shown</div>
        <ul>
          <li>Why the refracted rays are not just one or two discrete directions but instead form a <strong>cone</strong>.</li>
          <li>Qualitative + geometric description of the emergent pattern in air from the second face.</li>
          <li>Provide a usable relationship (symbolic) between internal cone angle and external observation (ring radius).</li>
        </ul>
      </div>
    </div>

    <h3>1.2 Relevant physical principles (and why they apply)</h3>
    <ul>
      <li><strong>Dispersion geometry:</strong> allowed plane waves at fixed <span style="font-family:var(--mono)">ω</span> lie on the k-surface. Near an optic axis, the surface is locally conical → essential cause of the effect.</li>
      <li><strong>Rays follow group velocity:</strong> in transparent crystals, ray direction aligns with <span style="font-family:var(--mono)">v_g = ∇_k ω</span>, normal to the k-surface. This directly converts surface shape → ray-direction shape.</li>
      <li><strong>Boundary conditions at an interface:</strong> tangential components of <span style="font-family:var(--mono)">k</span> match across a planar boundary (phase matching). For normal incidence along the optic axis, the degeneracy means many internal ray directions are consistent with the same axial wavevector direction in the local model.</li>
      <li><strong>Refraction at the second face:</strong> treat each internal ray direction as an incident direction at the exit interface and map it into air (Snell-like for directions).</li>
    </ul>
    <p>
      <strong>Why other ideas are less central here:</strong> We are not solving a full Maxwell boundary-value polarization problem; the prompt specifically points to the k-surface being conical. So the cleanest explanation is geometric: k-surface → normals → cone of rays.
    </p>

    <div class="callout assumptions">
      <div class="tag">Assumptions (explicit)</div>
      <ul>
        <li>Monochromatic field; linear, homogeneous crystal; negligible absorption.</li>
        <li>Geometric optics / ray picture is meaningful (beam dimensions large vs wavelength).</li>
        <li>Local conical approximation near the optic axis captures the ray-direction distribution.</li>
        <li>For exit into air, use an effective index <span style="font-family:var(--mono)">n_eff</span> to map angles (a teaching model). Real crystals can show additional fine structure (e.g., ring splitting) beyond this basic mapping.</li>
      </ul>
    </div>

    <h3>1.3 Possible approaches (compare)</h3>
    <ul>
      <li><strong>(A) k-surface differential geometry (best for this prompt):</strong> use <span style="font-family:var(--mono)">v_g ⟂</span> k-surface; show normals to a cone form a cone. <em>Pros:</em> direct, conceptual, matches statement “surface approximated by a cone.” <em>Cons:</em> material-dependent angle <span style="font-family:var(--mono)">ρ</span> remains as a parameter unless you derive it from full biaxial dispersion.</li>
      <li><strong>(B) Index ellipsoid + wave normal/ray equations:</strong> derive conical refraction using the Fresnel equation near optic axis. <em>Pros:</em> can yield <span style="font-family:var(--mono)">ρ</span> in terms of principal indices. <em>Cons:</em> algebra-heavy; beyond what the prompt demands.</li>
      <li><strong>(C) Full Maxwell eigenmode matching:</strong> compute transmitted field distribution. <em>Pros:</em> most complete. <em>Cons:</em> overkill for a “show that” geometry question.</li>
    </ul>

    <p><strong>Chosen approach:</strong> (A) k-surface geometry + group velocity normals, then Snell-like mapping at the exit face. This gives the cleanest “why a cone” and “why a ring in air.”</p>
  </section>

  <section id="p2" class="fadeIn">
    <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

    <ol style="color:var(--muted); margin-left: 20px">
      <li><strong>Goal:</strong> connect k-surface shape to ray directions.
        <br/><em>Tool:</em> <span style="font-family:var(--mono)">v_g = ∇_k ω</span>.
        <br/><em>Meaning:</em> rays are normals to the k-surface.</li>

      <li><strong>Goal:</strong> model the local k-surface near an optic axis as a cone.
        <br/><em>Tool:</em> “two sheets meet → conical approximation.”
        <br/><em>Meaning:</em> degeneracy yields a special local geometry.</li>

      <li><strong>Goal:</strong> show that normals to a cone form a cone of directions.
        <br/><em>Tool:</em> compute/argue geometric normal directions.
        <br/><em>Meaning:</em> continuous family of refracted rays → conical refraction.</li>

      <li><strong>Goal:</strong> interpret what happens inside a finite-thickness slab.
        <br/><em>Tool:</em> straight-line rays in homogeneous medium.
        <br/><em>Meaning:</em> at the exit face, rays arrive on a ring (intersection of cone with plane).</li>

      <li><strong>Goal:</strong> map internal cone to external cone in air.
        <br/><em>Tool:</em> Snell-like mapping for ray directions: <span style="font-family:var(--mono)">sin θ_air ≈ n_eff sin ρ</span>.
        <br/><em>Meaning:</em> the ring observed in air has radius <span style="font-family:var(--mono)">R ≈ L tan θ_air</span>.</li>

      <li><strong>Goal:</strong> sanity checks.
        <br/><em>Tool:</em> small-angle limits, units of <span style="font-family:var(--mono)">R</span>, and limiting behavior as <span style="font-family:var(--mono)">ρ→0</span>.</li>
    </ol>

    <div class="callout mistakes">
      <div class="tag">Common mistakes & quick tips</div>
      <ul>
        <li><strong>Mistake:</strong> treating <span style="font-family:var(--mono)">k</span> as the ray direction. <strong>Tip:</strong> in anisotropic media, use <span style="font-family:var(--mono)">v_g</span> (normal to k-surface) for rays.</li>
        <li><strong>Mistake:</strong> expecting just two transmitted rays. <strong>Tip:</strong> optic-axis degeneracy produces a continuum; think “cone,” not “pair.”</li>
        <li><strong>Mistake:</strong> forgetting the second refraction. <strong>Tip:</strong> the exit face maps internal angles to external ones; the observable is typically a ring in air.</li>
      </ul>
    </div>
  </section>

  <section id="p3" class="fadeIn">
    <h2>PART 3 — Full Solution (DETAILED + TEACHING)</h2>

    <h3>3.1 Physical intuition (before the math)</h3>
    <p>
      Away from special directions, a biaxial crystal supports two distinct polarization eigenwaves, so one often expects “two refractions.”
      But along an optic axis, the two dispersion sheets touch (degenerate). If that touching region looks like a <strong>cone</strong>,
      then the set of surface normals is not a single direction: it’s a <strong>cone of directions</strong>. Since rays follow those normals,
      a single incident beam can feed a <strong>continuous</strong> set of ray directions. That is the essence of conical refraction.
    </p>

    <h3>3.2 Step 1 — Rays are normals to the k-surface</h3>
    <p>
      In a transparent medium, for a given frequency <span style="font-family:var(--mono)">ω</span>, allowed plane waves satisfy a dispersion relation
      <span style="font-family:var(--mono)">ω = ω(k)</span>. The group velocity is
      <span style="font-family:var(--mono)">v_g = ∇_k ω</span>. Holding <span style="font-family:var(--mono)">ω</span> constant defines the k-surface
      <span style="font-family:var(--mono)">ω(k)=const</span>. The gradient <span style="font-family:var(--mono)">∇_k ω</span> is perpendicular to
      constant-ω surfaces, therefore:
    </p>

    <div class="callout keyeq">
      <div class="tag">Key equation</div>
      <div class="eqBlock">
<pre id="eq_normals">v_g = ∇_k ω
⇒ v_g is normal to the k-surface (ω(k)=const)</pre>
      </div>
      <div class="copyRow">
        <button class="btn small" data-copy="eq_normals">Copy equation</button>
      </div>
      <p style="color:var(--faint); margin-top:8px">
        Interpretation: once you know the local shape of the k-surface, you know the possible ray directions.
      </p>
    </div>

    <h3>3.3 Step 2 — Local conical approximation of the k-surface near an optic axis</h3>
    <p>
      The prompt tells us: when <span style="font-family:var(--mono)">k</span> points along an optic axis in a biaxial crystal,
      the two sheets of the k-surface meet and can be approximated by a conical surface.
      Let the optic axis be the <span style="font-family:var(--mono)">z</span>-axis (normal to the entrance face).
      A simple local model of a cone in k-space is:
    </p>

    <div class="eqBlock">
<pre id="eq_cone_k">k_z = k0   (sets the axial location at the degeneracy)
and the surface is locally conical in transverse components:
|k_⊥| = α |k_z - k0|   (schematic “cone” relation near the touching region)</pre>
    </div>
    <div class="copyRow">
      <button class="btn small" data-copy="eq_cone_k">Copy equation</button>
    </div>

    <p style="color:var(--muted)">
      Here <span style="font-family:var(--mono)">k_⊥</span> is the magnitude of the transverse component of <span style="font-family:var(--mono)">k</span>
      (perpendicular to the optic axis), <span style="font-family:var(--mono)">k0</span> is the characteristic magnitude at the optic-axis degeneracy
      (roughly <span style="font-family:var(--mono)">k0 ~ n_eff ω / c</span>), and <span style="font-family:var(--mono)">α</span> encodes the local slope of the conical surface.
      <br/><br/>
      <strong>Important:</strong> we do not need the exact <span style="font-family:var(--mono)">α(n1,n2,n3)</span> to prove the cone of rays; we only need that the surface is conical.
    </p>

    <h3>3.4 Step 3 — Normals to a cone form a cone of directions (the heart of the proof)</h3>
    <p>
      Consider a real-space ray direction unit vector <span style="font-family:var(--mono)">ŝ</span> proportional to the group velocity direction.
      Since <span style="font-family:var(--mono)">v_g</span> is normal to the k-surface, the set of possible <span style="font-family:var(--mono)">ŝ</span> directions equals the set of normals to that surface.
      A right circular cone has rotational symmetry: every point around the cone at a given azimuth has a normal tilted by the same polar angle away from the axis, but rotated in azimuth.
      Therefore the set of normals sweeps a <strong>cone</strong>.
    </p>

    <p>
      To make that explicit, write a (real-space) cone of ray directions as:
    </p>

    <div class="eqBlock">
<pre id="eq_ray_cone">Inside the crystal, ray directions satisfy:
ŝ(φ) = (sin ρ cos φ,  sin ρ sin φ,  cos ρ),   0 ≤ φ &lt; 2π

where ρ is the internal conical-refraction semi-angle.</pre>
    </div>
    <div class="copyRow">
      <button class="btn small" data-copy="eq_ray_cone">Copy equation</button>
    </div>

    <p style="color:var(--muted)">
      That is exactly “multiple refraction”: rather than a single transmitted ray (or two), you get a continuous family indexed by azimuth <span style="font-family:var(--mono)">φ</span>.
      Physically, the optic-axis degeneracy allows the incident excitation to couple into a continuum of directions around the axis (with polarization varying around the ring in a full treatment).
    </p>

    <h3>3.5 Step 4 — What reaches the exit face of a parallel-sided crystal?</h3>
    <p>
      Consider a crystal slab of thickness <span style="font-family:var(--mono)">t</span>, with entrance and exit faces perpendicular to the optic axis (<span style="font-family:var(--mono)">z</span>).
      Rays travel in straight lines inside a homogeneous medium, so a ray launched at angle <span style="font-family:var(--mono)">ρ</span> to the axis reaches the exit plane at radius
      (measured from the axis):
    </p>

    <div class="callout keyeq">
      <div class="tag">Geometry inside the slab</div>
      <div class="eqBlock">
<pre id="eq_ring_exit">Ring radius at the exit face:
r_exit = t tan(ρ)   (≈ t ρ for small ρ)</pre>
      </div>
      <div class="copyRow">
        <button class="btn small" data-copy="eq_ring_exit">Copy equation</button>
      </div>
      <p style="color:var(--faint); margin-top:8px">
        This is just “cone intersects a plane” geometry. It already tells you why a ring appears at the exit face.
      </p>
    </div>

    <h3>3.6 Step 5 — Refraction of the conical rays into air (what the problem asks next)</h3>
    <p>
      Now each internal ray hits the exit interface (crystal → air) at the same internal incidence angle <span style="font-family:var(--mono)">ρ</span> relative to the surface normal,
      but with different azimuth <span style="font-family:var(--mono)">φ</span>.
      A simple teaching model is to map directions using a Snell-like relation with an effective refractive index <span style="font-family:var(--mono)">n_eff</span>
      appropriate for the optic-axis neighborhood:
    </p>

    <div class="eqBlock">
<pre id="eq_snell_like">Directional mapping (simple model):
n_eff sin(ρ) ≈ n_air sin(θ_air) , with n_air ≈ 1
⇒ sin(θ_air) ≈ n_eff sin(ρ)</pre>
    </div>
    <div class="copyRow">
      <button class="btn small" data-copy="eq_snell_like">Copy equation</button>
    </div>

    <p style="color:var(--muted)">
      This tells you the conical bundle generally remains conical in air, but with a different semi-angle <span style="font-family:var(--mono)">θ_air</span>.
      The emergent rays again form a cone (same azimuthal symmetry).
      If you place a screen a distance <span style="font-family:var(--mono)">L</span> after the exit face, the cone intersects the screen in a ring of radius:
    </p>

    <div class="callout final">
      <div class="tag">External observable (ring in air)</div>
      <div class="eqBlock">
<pre id="eq_R_screen">Ring radius on a screen in air (distance L from exit face):
R = L tan(θ_air)

with θ_air determined by sin(θ_air) ≈ n_eff sin(ρ)  (n_air ≈ 1).</pre>
      </div>
      <div class="copyRow">
        <button class="btn small" data-copy="eq_R_screen">Copy equation</button>
      </div>
      <p style="color:var(--faint); margin-top:8px">
        So the answer to “what happens in air?” is: you observe a ring (and, in more detailed physical optics, often ring structure/intensity variations).
      </p>
    </div>

    <h3>3.7 Sanity checks</h3>
    <div class="grid2">
      <div class="callout">
        <div class="tag">Units / dimensions</div>
        <ul>
          <li><span style="font-family:var(--mono)">ρ</span>, <span style="font-family:var(--mono)">θ_air</span> are angles (dimensionless in radians).</li>
          <li><span style="font-family:var(--mono)">r_exit = t tan ρ</span> has units of length (since <span style="font-family:var(--mono)">t</span> is length).</li>
          <li><span style="font-family:var(--mono)">R = L tan θ_air</span> has units of length (since <span style="font-family:var(--mono)">L</span> is length).</li>
        </ul>
      </div>
      <div class="callout">
        <div class="tag">Limiting cases</div>
        <ul>
          <li><span style="font-family:var(--mono)">ρ → 0</span>: cone collapses to a line; <span style="font-family:var(--mono)">r_exit → 0</span>, ring disappears (back to a single axial beam).</li>
          <li>Small angles: <span style="font-family:var(--mono)">r_exit ≈ t ρ</span> and <span style="font-family:var(--mono)">R ≈ L θ_air</span>.</li>
          <li>If <span style="font-family:var(--mono)">n_eff sin ρ</span> is small, then <span style="font-family:var(--mono)">θ_air ≈ n_eff ρ</span> (in radians).</li>
        </ul>
      </div>
    </div>

    <p>
      <strong>Connection back to the geometry:</strong> the entrance face is aligned with an optic axis so the k-surface is locally conical.
      The normals to that cone provide the internal ray cone. The parallel exit face converts that cone into an external cone in air.
      Any plane perpendicular to the axis cuts the cone into a ring — exactly what you observe.
    </p>
  </section>

  <section id="p4" class="fadeIn">
    <h2>PART 4 — Deeper Understanding (THEORY AROUND THE RESULT)</h2>

    <h3>4.1 Re-interpreting the formulas (what controls what)</h3>
    <ul>
      <li><strong><span style="font-family:var(--mono)">ρ</span> (internal cone angle):</strong> set by the local slope/geometry of the k-surface near the optic axis — a property of the biaxial indices and orientation.</li>
      <li><strong><span style="font-family:var(--mono)">t</span> (crystal thickness):</strong> sets how large the cone becomes at the exit face via <span style="font-family:var(--mono)">r_exit = t tan ρ</span>.</li>
      <li><strong><span style="font-family:var(--mono)">n_eff</span> (effective index for exit mapping):</strong> controls how strongly angles expand/contract into air through <span style="font-family:var(--mono)">sin θ_air ≈ n_eff sin ρ</span>.</li>
      <li><strong><span style="font-family:var(--mono)">L</span> (screen distance in air):</strong> turns angle into a measurable ring radius via <span style="font-family:var(--mono)">R = L tan θ_air</span>.</li>
    </ul>

    <h3>4.2 Parameter effects (connect to the interactive plots)</h3>
    <ul>
      <li>Increase <span style="font-family:var(--mono)">ρ</span> → both <span style="font-family:var(--mono)">r_exit</span> and <span style="font-family:var(--mono)">R</span> increase (ring gets larger).</li>
      <li>Increase <span style="font-family:var(--mono)">t</span> → exit-face ring radius increases linearly for small angles (<span style="font-family:var(--mono)">r_exit ≈ t ρ</span>).</li>
      <li>Increase <span style="font-family:var(--mono)">n_eff</span> → <span style="font-family:var(--mono)">θ_air</span> increases (until the simple model approaches its limit), making the observed ring larger.</li>
      <li>Increase <span style="font-family:var(--mono)">L</span> → <span style="font-family:var(--mono)">R</span> grows linearly (for fixed <span style="font-family:var(--mono)">θ_air</span>), because the cone keeps expanding.</li>
    </ul>

    <h3>4.3 Alternative derivation idea (brief)</h3>
    <p>
      If you want the material-dependent angle <span style="font-family:var(--mono)">ρ</span> explicitly, you can start from the biaxial Fresnel equation
      (derived from Maxwell’s equations with the dielectric tensor) and expand the dispersion relation near an optic axis.
      That expansion shows two sheets touching and yields the cone slope (hence <span style="font-family:var(--mono)">ρ</span>) in terms of principal indices.
      This is algebra-heavy but conceptually consistent with our geometric method.
    </p>

    <h3>4.4 Concept checks (self-test)</h3>
    <ul>
      <li><strong>Q:</strong> In anisotropic media, which direction corresponds to energy flow: <span style="font-family:var(--mono)">k</span> or <span style="font-family:var(--mono)">v_g</span>? <strong>A:</strong> <span style="font-family:var(--mono)">v_g</span> (group velocity), which is normal to the k-surface.</li>
      <li><strong>Q:</strong> Why can a single incident direction create a continuum of refracted rays at an optic axis? <strong>A:</strong> Because the two k-surface sheets become degenerate and locally conical; its normals span a cone.</li>
      <li><strong>Q:</strong> What geometric shape appears on a screen from a cone of rays? <strong>A:</strong> A ring (intersection of a cone with a plane).</li>
      <li><strong>Q:</strong> If the internal cone angle is tiny, what happens to the ring? <strong>A:</strong> It collapses toward the axis: <span style="font-family:var(--mono)">R ≈ L n_eff ρ</span> becomes small.</li>
    </ul>
  </section>

  <section id="p5" class="fadeIn">
    <h2>PART 5 — Visualization Guide (HOW TO READ THE PLOTS)</h2>

    <p>
      Below are three interactive canvases:
    </p>

    <div class="controls" aria-label="Interactive controls">
      <div class="control">
        <label for="rho"><span>Internal cone angle ρ (deg)</span><output id="rhoOut">0.60</output></label>
        <input id="rho" type="range" min="0.05" max="2.0" step="0.01" value="0.60"/>
      </div>
      <div class="control">
        <label for="t"><span>Crystal thickness t (mm)</span><output id="tOut">10.0</output></label>
        <input id="t" type="range" min="1" max="30" step="0.5" value="10.0"/>
      </div>
      <div class="control">
        <label for="L"><span>Screen distance L (cm)</span><output id="LOut">30.0</output></label>
        <input id="L" type="range" min="5" max="120" step="1" value="30.0"/>
      </div>
      <div class="control">
        <label for="nEff"><span>Effective index n_eff</span><output id="nEffOut">1.60</output></label>
        <input id="nEff" type="range" min="1.20" max="2.00" step="0.01" value="1.60"/>
      </div>
    </div>

    <div class="callout" style="margin-top:12px">
      <div class="tag">What the controls do</div>
      <ul>
        <li><strong>ρ</strong> changes the internal cone opening. All figures update (bigger ρ → bigger rings).</li>
        <li><strong>t</strong> changes the exit-face ring radius inside the crystal: <span style="font-family:var(--mono)">r_exit = t tan ρ</span>.</li>
        <li><strong>L</strong> changes the observed ring radius in air: <span style="font-family:var(--mono)">R = L tan θ_air</span>.</li>
        <li><strong>n_eff</strong> changes the mapping into air: <span style="font-family:var(--mono)">sin θ_air ≈ n_eff sin ρ</span>.</li>
      </ul>
    </div>

    <div class="vizWrap">
      <figure>
        <div class="figHead">
          <div class="title">Diagram — Conical refraction in a parallel-sided biaxial crystal</div>
          <div class="note">Not to scale • directions + ring geometry</div>
        </div>
        <canvas id="cDiagram" aria-label="Diagram of conical refraction"></canvas>
      </figure>

      <figure>
        <div class="figHead">
          <div class="title">Main Plot — Ring radius in air vs screen distance</div>
          <div class="note">R(L) = L tan(θ_air)</div>
        </div>
        <canvas id="cMain" aria-label="Main quantitative plot"></canvas>
      </figure>

      <figure>
        <div class="figHead">
          <div class="title">Secondary Plot — Angle mapping: θ_air(ρ) for different n_eff</div>
          <div class="note">sin(θ_air) ≈ n_eff sin(ρ)</div>
        </div>
        <canvas id="cSecondary" aria-label="Secondary plot of angle mapping"></canvas>
      </figure>
    </div>

    <p>
      <strong>Reading the plots:</strong>
      <br/>
      (1) The diagram shows the incident beam, the internal cone, the ring at the exit face, and the external cone.
      <br/>
      (2) The main plot shows how the ring expands with propagation distance in air; for fixed angle it is essentially linear for small angles.
      <br/>
      (3) The secondary plot shows how the external cone angle depends on the internal cone angle and the effective refractive index.
    </p>
  </section>

</main>

<footer class="fadeIn">
  <div style="border-top:1px solid var(--line); padding-top:14px">
    Built as a self-contained learning article (vanilla HTML/CSS/JS). Interactive plots use example values where the problem is symbolic.
  </div>
</footer>

<script>
(() => {
  // -----------------------
  // Smooth scroll for TOC
  // -----------------------
  document.querySelectorAll('[data-scroll]').forEach(a=>{
    a.addEventListener('click', (e)=>{
      e.preventDefault();
      const id = a.getAttribute('href');
      const el = document.querySelector(id);
      if(!el) return;
      el.scrollIntoView({behavior:'smooth', block:'start'});
      history.replaceState(null, '', id);
    });
  });

  // -----------------------
  // Copy buttons
  // -----------------------
  async function copyTextFrom(id){
    const el = document.getElementById(id);
    if(!el) return;
    const txt = el.textContent;
    try{
      await navigator.clipboard.writeText(txt);
      toast('Copied ✓');
    }catch(err){
      // Fallback
      const ta = document.createElement('textarea');
      ta.value = txt;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      toast('Copied ✓ (fallback)');
    }
  }

  function toast(msg){
    let t = document.getElementById('toast');
    if(!t){
      t = document.createElement('div');
      t.id = 'toast';
      t.style.position = 'fixed';
      t.style.left = '50%';
      t.style.bottom = '18px';
      t.style.transform = 'translateX(-50%)';
      t.style.padding = '10px 12px';
      t.style.borderRadius = '14px';
      t.style.border = '1px solid rgba(255,255,255,.16)';
      t.style.background = 'rgba(17,26,51,.85)';
      t.style.color = 'white';
      t.style.fontWeight = '700';
      t.style.boxShadow = '0 18px 40px rgba(0,0,0,.35)';
      t.style.backdropFilter = 'blur(10px)';
      t.style.zIndex = '9999';
      t.style.opacity = '0';
      t.style.transition = 'opacity .18s ease, transform .18s ease';
      document.body.appendChild(t);
    }
    t.textContent = msg;
    t.style.opacity = '1';
    t.style.transform = 'translateX(-50%) translateY(-2px)';
    clearTimeout(window.__toastTimer);
    window.__toastTimer = setTimeout(()=>{
      t.style.opacity = '0';
      t.style.transform = 'translateX(-50%) translateY(0px)';
    }, 1100);
  }

  document.querySelectorAll('[data-copy]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const id = btn.getAttribute('data-copy');
      copyTextFrom(id);
    });
  });

  // -----------------------
  // Controls + state
  // -----------------------
  const elRho = document.getElementById('rho');
  const elT = document.getElementById('t');
  const elL = document.getElementById('L');
  const elNEff = document.getElementById('nEff');

  const outRho = document.getElementById('rhoOut');
  const outT = document.getElementById('tOut');
  const outL = document.getElementById('LOut');
  const outNEff = document.getElementById('nEffOut');

  const state = {
    rhoDeg: parseFloat(elRho.value),
    tMm: parseFloat(elT.value),
    LCm: parseFloat(elL.value),
    nEff: parseFloat(elNEff.value),
    nAir: 1.0
  };

  function deg2rad(d){ return d*Math.PI/180; }
  function rad2deg(r){ return r*180/Math.PI; }
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

  function updateOutputs(){
    outRho.textContent = state.rhoDeg.toFixed(2);
    outT.textContent = state.tMm.toFixed(1);
    outL.textContent = state.LCm.toFixed(1);
    outNEff.textContent = state.nEff.toFixed(2);
  }

  function thetaAirFromRho(rhoRad, nEff){
    // Simple Snell-like mapping: sin(theta_air)=nEff*sin(rho) (n_air≈1)
    const s = nEff * Math.sin(rhoRad) / state.nAir;
    const sc = clamp(s, 0, 0.999999); // avoid asin issues
    return Math.asin(sc);
  }

  function computeDerived(){
    const rho = deg2rad(state.rhoDeg);
    const t = state.tMm * 1e-3; // m
    const L = state.LCm * 1e-2; // m

    const thetaAir = thetaAirFromRho(rho, state.nEff);
    const rExit = t * Math.tan(rho);
    const R = L * Math.tan(thetaAir);

    return { rho, t, L, thetaAir, rExit, R };
  }

  // -----------------------
  // Canvas utilities
  // -----------------------
  function setupCanvas(canvas){
    const ctx = canvas.getContext('2d');
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect.width * dpr));
      const h = Math.max(2, Math.floor(rect.height * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {w: rect.width, h: rect.height, dpr};
    }
    return {ctx, resize};
  }

  function clear(ctx, w, h){
    ctx.clearRect(0,0,w,h);
  }

  function drawGrid(ctx, x0,y0,w,h, xTicks, yTicks){
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,.08)';
    ctx.lineWidth = 1;
    for(let i=0;i<=xTicks;i++){
      const x = x0 + (w*i/xTicks);
      ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+h); ctx.stroke();
    }
    for(let j=0;j<=yTicks;j++){
      const y = y0 + (h*j/yTicks);
      ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+w,y); ctx.stroke();
    }
    ctx.restore();
  }

  function axis(ctx, x0,y0,w,h, opts){
    const {xLabel,yLabel, xMin,xMax,yMin,yMax, xTicks=5,yTicks=5, title='' } = opts;
    ctx.save();

    // Title
    ctx.fillStyle = 'rgba(234,240,255,.95)';
    ctx.font = '700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(title, x0, y0-10);

    // Frame
    ctx.strokeStyle = 'rgba(255,255,255,.16)';
    ctx.lineWidth = 1;
    ctx.strokeRect(x0,y0,w,h);

    drawGrid(ctx, x0,y0,w,h, xTicks, yTicks);

    // Ticks + labels
    ctx.fillStyle = 'rgba(185,196,230,.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

    // x ticks
    for(let i=0;i<=xTicks;i++){
      const x = x0 + (w*i/xTicks);
      const val = xMin + (xMax-xMin)*i/xTicks;
      ctx.strokeStyle = 'rgba(255,255,255,.16)';
      ctx.beginPath(); ctx.moveTo(x, y0+h); ctx.lineTo(x, y0+h+6); ctx.stroke();
      const txt = formatTick(val);
      ctx.fillText(txt, x-ctx.measureText(txt).width/2, y0+h+18);
    }
    // y ticks
    for(let j=0;j<=yTicks;j++){
      const y = y0 + (h*j/yTicks);
      const val = yMax - (yMax-yMin)*j/yTicks;
      ctx.strokeStyle = 'rgba(255,255,255,.16)';
      ctx.beginPath(); ctx.moveTo(x0-6, y); ctx.lineTo(x0, y); ctx.stroke();
      const txt = formatTick(val);
      ctx.fillText(txt, x0-10-ctx.measureText(txt).width, y+4);
    }

    // Axis labels
    ctx.fillStyle = 'rgba(234,240,255,.92)';
    ctx.font = '700 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(xLabel, x0 + w/2 - ctx.measureText(xLabel).width/2, y0 + h + 36);

    ctx.save();
    ctx.translate(x0 - 44, y0 + h/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
    ctx.restore();

    ctx.restore();
  }

  function formatTick(v){
    const av = Math.abs(v);
    if(av>=1000) return v.toFixed(0);
    if(av>=100) return v.toFixed(0);
    if(av>=10) return v.toFixed(1);
    if(av>=1) return v.toFixed(2);
    if(av>=0.1) return v.toFixed(3);
    return v.toExponential(1);
  }

  function mapX(x, xMin,xMax, x0,w){
    return x0 + (x - xMin) * w / (xMax - xMin);
  }
  function mapY(y, yMin,yMax, y0,h){
    return y0 + (yMax - y) * h / (yMax - yMin);
  }

  function drawLine(ctx, pts, stroke='rgba(125,211,252,.95)', width=2){
    ctx.save();
    ctx.strokeStyle = stroke;
    ctx.lineWidth = width;
    ctx.beginPath();
    pts.forEach((p, i)=>{
      if(i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    });
    ctx.stroke();
    ctx.restore();
  }

  function drawLegend(ctx, items, x, y){
    ctx.save();
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillStyle = 'rgba(234,240,255,.9)';
    const boxW = 210;
    const lineH = 18;
    const boxH = 10 + items.length*lineH;
    ctx.strokeStyle = 'rgba(255,255,255,.14)';
    ctx.fillStyle = 'rgba(17,26,51,.55)';
    roundRect(ctx, x, y, boxW, boxH, 12, true, true);
    items.forEach((it, i)=>{
      const yy = y + 8 + (i+1)*lineH - 6;
      ctx.strokeStyle = it.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x+12, yy);
      ctx.lineTo(x+30, yy);
      ctx.stroke();
      ctx.fillStyle = 'rgba(234,240,255,.92)';
      ctx.fillText(it.label, x+38, yy+4);
    });
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }

  // -----------------------
  // Diagram canvas
  // -----------------------
  const cDiagram = setupCanvas(document.getElementById('cDiagram'));
  const cMain = setupCanvas(document.getElementById('cMain'));
  const cSecondary = setupCanvas(document.getElementById('cSecondary'));

  function drawDiagram(){
    const {ctx, resize} = cDiagram;
    const {w,h} = resize();
    clear(ctx, w,h);

    const d = computeDerived();
    const rho = d.rho;
    const thetaAir = d.thetaAir;

    // Layout in CSS pixels
    const pad = 18;
    const x0 = pad, y0 = pad;
    const W = w - 2*pad, H = h - 2*pad;

    // Draw slab
    const slabX = x0 + W*0.18;
    const slabW = W*0.22;
    const slabY = y0 + H*0.12;
    const slabH = H*0.76;

    ctx.save();
    ctx.fillStyle = 'rgba(17,26,51,.55)';
    ctx.strokeStyle = 'rgba(255,255,255,.18)';
    ctx.lineWidth = 1.2;
    roundRect(ctx, slabX, slabY, slabW, slabH, 16, true, true);

    // Label slab
    ctx.fillStyle = 'rgba(234,240,255,.92)';
    ctx.font = '700 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Biaxial crystal slab', slabX+10, slabY+18);
    ctx.fillStyle = 'rgba(185,196,230,.95)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText(`t = ${state.tMm.toFixed(1)} mm`, slabX+10, slabY+36);
    ctx.fillText(`optic axis ⟂ face`, slabX+10, slabY+54);

    // Coordinate axis arrow (z)
    const zX = slabX + slabW/2;
    const zTop = slabY - 8;
    const zBot = slabY + slabH + 12;
    ctx.strokeStyle = 'rgba(125,211,252,.8)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(zX, zBot); ctx.lineTo(zX, zTop); ctx.stroke();
    // arrow head
    ctx.beginPath();
    ctx.moveTo(zX, zTop);
    ctx.lineTo(zX-6, zTop+10);
    ctx.lineTo(zX+6, zTop+10);
    ctx.closePath();
    ctx.fillStyle = 'rgba(125,211,252,.85)';
    ctx.fill();
    ctx.fillStyle = 'rgba(234,240,255,.9)';
    ctx.font = '700 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('z (optic axis)', zX+10, zTop+12);

    // Incident beam
    const inX = x0 + W*0.06;
    const inY = slabY + slabH/2;
    ctx.strokeStyle = 'rgba(234,240,255,.85)';
    ctx.lineWidth = 2.4;
    ctx.beginPath(); ctx.moveTo(inX, inY); ctx.lineTo(slabX, inY); ctx.stroke();
    // arrow head
    ctx.beginPath();
    ctx.moveTo(slabX, inY);
    ctx.lineTo(slabX-12, inY-6);
    ctx.lineTo(slabX-12, inY+6);
    ctx.closePath();
    ctx.fillStyle = 'rgba(234,240,255,.85)';
    ctx.fill();
    ctx.fillStyle = 'rgba(185,196,230,.95)';
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('normally incident beam', inX, inY-12);

    // Internal cone rays
    const apexX = slabX + slabW*0.35;
    const apexY = inY;
    const coneLen = slabW*0.8;
    const maxSpread = Math.tan(rho) * coneLen * 2.0; // exaggerated for visibility
    const N = 8;
    for(let i=0;i<N;i++){
      const phi = (i/N)*2*Math.PI;
      // project into 2D: show a fan in top/bottom only (use sin component)
      const dy = (Math.sin(phi)) * maxSpread*0.35;
      ctx.strokeStyle = 'rgba(167,139,250,.55)';
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      ctx.moveTo(apexX, apexY);
      ctx.lineTo(apexX + coneLen, apexY + dy);
      ctx.stroke();
    }

    // Exit ring on crystal face
    const exitX = slabX + slabW;
    const ringR = Math.min(slabH*0.22, 12 + 2300 * d.rExit); // visual scaling
    ctx.strokeStyle = 'rgba(52,211,153,.85)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(exitX, inY, ringR*0.55, ringR, 0, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fillStyle = 'rgba(52,211,153,.12)';
    ctx.beginPath();
    ctx.ellipse(exitX, inY, ringR*0.55, ringR, 0, 0, 2*Math.PI);
    ctx.fill();

    ctx.fillStyle = 'rgba(185,196,230,.95)';
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('ring at exit face', exitX-50, inY + ringR + 18);

    // External cone in air
    const airLen = W*0.38;
    const outApexX = exitX + 8;
    const outApexY = inY;
    const outSpread = Math.tan(thetaAir) * airLen * 2.0;
    for(let i=0;i<N;i++){
      const phi = (i/N)*2*Math.PI;
      const dy = (Math.sin(phi)) * outSpread*0.35;
      ctx.strokeStyle = 'rgba(125,211,252,.6)';
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      ctx.moveTo(outApexX, outApexY);
      ctx.lineTo(outApexX + airLen, outApexY + dy);
      ctx.stroke();
    }

    // Screen plane and observed ring
    const screenX = outApexX + airLen;
    ctx.strokeStyle = 'rgba(255,255,255,.16)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(screenX, slabY);
    ctx.lineTo(screenX, slabY + slabH);
    ctx.stroke();
    ctx.fillStyle = 'rgba(185,196,230,.9)';
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('screen', screenX-18, slabY-8);

    const Rvis = Math.min(slabH*0.25, 12 + 2000 * d.R);
    ctx.strokeStyle = 'rgba(251,191,36,.9)';
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    ctx.ellipse(screenX, inY, Rvis*0.55, Rvis, 0, 0, 2*Math.PI);
    ctx.stroke();

    // Angle labels
    ctx.fillStyle = 'rgba(234,240,255,.9)';
    ctx.font = '700 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText(`ρ = ${state.rhoDeg.toFixed(2)}°`, slabX + 10, slabY + slabH - 14);
    ctx.fillText(`θ_air = ${rad2deg(thetaAir).toFixed(2)}°`, outApexX + 10, slabY + slabH - 14);

    ctx.restore();
  }

  // -----------------------
  // Main plot: R vs L
  // -----------------------
  function drawMainPlot(){
    const {ctx, resize} = cMain;
    const {w,h} = resize();
    clear(ctx, w,h);

    const padL = 74, padR = 18, padT = 46, padB = 54;
    const x0 = padL, y0 = padT;
    const W = w - padL - padR;
    const H = h - padT - padB;

    const d = computeDerived();
    const thetaAir = d.thetaAir;

    // x in cm, y in mm for readability
    const xMin = 0;
    const xMax = 130;
    // y max based on current angle
    const RAtMax = (xMax*1e-2) * Math.tan(thetaAir); // m
    const yMaxMm = Math.max(1, (RAtMax*1e3) * 1.15);
    const yMinMm = 0;

    axis(ctx, x0,y0,W,H, {
      title: 'Ring radius in air vs screen distance',
      xLabel: 'Screen distance L (cm)',
      yLabel: 'Ring radius R (mm)',
      xMin, xMax,
      yMin: yMinMm, yMax: yMaxMm,
      xTicks: 6, yTicks: 5
    });

    // Plot curve
    const pts = [];
    for(let i=0;i<=220;i++){
      const Lcm = xMin + (xMax-xMin)*i/220;
      const Lm = Lcm*1e-2;
      const Rm = Lm*Math.tan(thetaAir);
      const Rmm = Rm*1e3;
      pts.push({x: mapX(Lcm, xMin,xMax, x0,W), y: mapY(Rmm, yMinMm,yMaxMm, y0,H)});
    }
    drawLine(ctx, pts, 'rgba(125,211,252,.95)', 2.4);

    // Mark current point
    const LcmNow = state.LCm;
    const RmmNow = d.R*1e3;
    const px = mapX(LcmNow, xMin,xMax, x0,W);
    const py = mapY(RmmNow, yMinMm,yMaxMm, y0,H);
    ctx.save();
    ctx.fillStyle = 'rgba(251,191,36,.95)';
    ctx.beginPath(); ctx.arc(px, py, 4.5, 0, 2*Math.PI); ctx.fill();
    ctx.strokeStyle = 'rgba(251,191,36,.55)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(px, py, 9, 0, 2*Math.PI); ctx.stroke();
    ctx.fillStyle = 'rgba(234,240,255,.92)';
    ctx.font = '700 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    const label = `R = ${RmmNow.toFixed(2)} mm @ L = ${LcmNow.toFixed(1)} cm`;
    ctx.fillText(label, x0 + 10, y0 + 16);
    ctx.restore();

    drawLegend(ctx, [
      {label:'R(L) = L tan(θ_air)', color:'rgba(125,211,252,.95)'},
      {label:'current setting', color:'rgba(251,191,36,.95)'}
    ], x0 + W - 228, y0 + 10);
  }

  // -----------------------
  // Secondary: theta_air vs rho for several n_eff values
  // -----------------------
  function drawSecondaryPlot(){
    const {ctx, resize} = cSecondary;
    const {w,h} = resize();
    clear(ctx, w,h);

    const padL = 74, padR = 18, padT = 46, padB = 54;
    const x0 = padL, y0 = padT;
    const W = w - padL - padR;
    const H = h - padT - padB;

    const xMin = 0;
    const xMax = 2.1; // deg
    const yMin = 0;
    const yMax = 4.0; // deg (covers mapping)

    axis(ctx, x0,y0,W,H, {
      title: 'Angle mapping into air',
      xLabel: 'Internal cone angle ρ (deg)',
      yLabel: 'External cone angle θ_air (deg)',
      xMin, xMax,
      yMin, yMax,
      xTicks: 7, yTicks: 5
    });

    const nList = [
      Math.max(1.2, state.nEff - 0.20),
      state.nEff,
      Math.min(2.0, state.nEff + 0.20)
    ];

    const colors = [
      'rgba(167,139,250,.95)',
      'rgba(125,211,252,.95)',
      'rgba(52,211,153,.95)'
    ];

    // plot three curves
    nList.forEach((n, idx)=>{
      const pts = [];
      for(let i=0;i<=240;i++){
        const rhoDeg = xMin + (xMax-xMin)*i/240;
        const rhoRad = deg2rad(rhoDeg);
        const th = thetaAirFromRho(rhoRad, n);
        const thDeg = rad2deg(th);
        pts.push({x: mapX(rhoDeg, xMin,xMax, x0,W), y: mapY(thDeg, yMin,yMax, y0,H)});
      }
      drawLine(ctx, pts, colors[idx], 2.2);
    });

    // current point on middle curve
    const rhoRadNow = deg2rad(state.rhoDeg);
    const thNow = thetaAirFromRho(rhoRadNow, state.nEff);
    const thDegNow = rad2deg(thNow);

    const px = mapX(state.rhoDeg, xMin,xMax, x0,W);
    const py = mapY(thDegNow, yMin,yMax, y0,H);

    ctx.save();
    ctx.fillStyle = 'rgba(251,191,36,.95)';
    ctx.beginPath(); ctx.arc(px, py, 4.5, 0, 2*Math.PI); ctx.fill();
    ctx.fillStyle = 'rgba(234,240,255,.92)';
    ctx.font = '700 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.fillText(`θ_air ≈ ${thDegNow.toFixed(2)}°`, x0 + 10, y0 + 16);
    ctx.restore();

    drawLegend(ctx, [
      {label:`n_eff = ${(nList[0]).toFixed(2)}`, color: colors[0]},
      {label:`n_eff = ${(nList[1]).toFixed(2)}`, color: colors[1]},
      {label:`n_eff = ${(nList[2]).toFixed(2)}`, color: colors[2]}
    ], x0 + W - 228, y0 + 10);
  }

  function renderAll(){
    updateOutputs();
    drawDiagram();
    drawMainPlot();
    drawSecondaryPlot();
  }

  function bind(){
    const handler = ()=>{
      state.rhoDeg = parseFloat(elRho.value);
      state.tMm = parseFloat(elT.value);
      state.LCm = parseFloat(elL.value);
      state.nEff = parseFloat(elNEff.value);
      renderAll();
    };
    elRho.addEventListener('input', handler);
    elT.addEventListener('input', handler);
    elL.addEventListener('input', handler);
    elNEff.addEventListener('input', handler);
    window.addEventListener('resize', ()=>renderAll(), {passive:true});
  }

  // Initial
  bind();
  renderAll();
})();
</script>

</body>
</html>
