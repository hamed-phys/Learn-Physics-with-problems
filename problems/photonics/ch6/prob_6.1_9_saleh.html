<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wave Retarders in Tandem (Jones Matrices): Quarter-Wave + Half-Wave + Quarter-Wave = 90Â° Rotator</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --card:#111c3a;
      --text:#e9eefc;
      --muted:#b8c3e6;
      --faint:#7f8bb6;
      --accent:#7cf0c1;
      --accent2:#78a6ff;
      --warn:#ffd36b;
      --bad:#ff6b8b;
      --ok:#9cff8b;
      --border:rgba(255,255,255,.10);
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    html,body{height:100%;}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 900px at 70% -10%, rgba(120,166,255,.22), transparent 60%),
        radial-gradient(900px 800px at 0% 20%, rgba(124,240,193,.18), transparent 55%),
        linear-gradient(180deg, var(--bg), #070a14 60%, #060913);
      line-height:1.55;
    }

    a{color:var(--accent2); text-decoration:none;}
    a:hover{text-decoration:underline;}

    header{
      padding:28px 18px 10px;
      max-width:1100px;
      margin:0 auto;
    }
    header .kicker{
      display:inline-flex; gap:10px; align-items:center;
      color:var(--muted);
      font-size:14px;
      opacity:.95;
    }
    header h1{
      margin:10px 0 8px;
      font-size: clamp(26px, 3vw, 40px);
      letter-spacing:-0.02em;
      line-height:1.15;
    }
    header p{
      margin:0;
      color:var(--muted);
      max-width: 70ch;
    }

    .layout{
      max-width:1100px;
      margin:0 auto;
      padding: 10px 18px 60px;
      display:grid;
      grid-template-columns: 1fr 280px;
      gap:18px;
      align-items:start;
    }

    nav.toc{
      position:sticky;
      top:12px;
      align-self:start;
      background: rgba(17,28,58,.72);
      backdrop-filter: blur(10px);
      border:1px solid var(--border);
      border-radius:16px;
      box-shadow: var(--shadow);
      padding:14px 12px;
    }
    nav.toc h2{
      font-size:13px;
      margin:0 0 10px;
      color:var(--muted);
      letter-spacing:.02em;
      text-transform:uppercase;
    }
    nav.toc a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      color:var(--text);
      font-size:14px;
      border:1px solid transparent;
    }
    nav.toc a:hover{
      background: rgba(124,240,193,.08);
      border-color: rgba(124,240,193,.18);
      text-decoration:none;
    }
    nav.toc .hint{
      margin-top:10px;
      font-size:12px;
      color:var(--faint);
      padding:10px;
      border-radius:12px;
      border:1px dashed rgba(255,255,255,.14);
    }

    main{
      display:flex;
      flex-direction:column;
      gap:14px;
      min-width:0;
    }

    section, article{
      background: rgba(17,28,58,.72);
      border:1px solid var(--border);
      border-radius:18px;
      padding:18px 18px 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }

    section h2{
      margin:0 0 8px;
      font-size: clamp(18px, 2vw, 24px);
      letter-spacing:-0.01em;
    }
    section h3{
      margin:14px 0 6px;
      font-size: 16px;
      color: var(--muted);
      letter-spacing:.01em;
    }
    p{margin:8px 0; color:var(--text);}
    ul{margin:8px 0 10px 20px;}
    li{margin:6px 0; color:var(--text);}

    .grid2{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:12px;
      align-items:start;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
    }

    .callouts{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:12px;
      margin-top:10px;
    }
    .box{
      grid-column: span 12;
      border-radius:16px;
      border:1px solid var(--border);
      padding:12px 12px;
      background: rgba(15,23,48,.65);
    }
    .box h4{
      margin:0 0 6px;
      font-size:13px;
      letter-spacing:.02em;
      text-transform:uppercase;
      color:var(--muted);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .tag{
      display:inline-flex;
      align-items:center;
      padding:2px 8px;
      border-radius:999px;
      font-size:12px;
      border:1px solid rgba(255,255,255,.14);
      color:var(--muted);
      background: rgba(255,255,255,.05);
      white-space:nowrap;
    }
    .box.assumptions h4::before{content:"âš™ï¸";}
    .box.keyeq h4::before{content:"ğŸ§ ";}
    .box.mistakes h4::before{content:"âš ï¸";}
    .box.final h4::before{content:"âœ…";}
    .box.final{border-color: rgba(124,240,193,.25); background: rgba(124,240,193,.06);}
    .box.mistakes{border-color: rgba(255,211,107,.25); background: rgba(255,211,107,.06);}

    .eq{
      position:relative;
      margin:10px 0;
      padding:12px 12px 12px;
      border-radius:14px;
      background: rgba(7,10,20,.55);
      border:1px solid rgba(255,255,255,.14);
      overflow:auto;
      font-family: var(--mono);
      font-size: 13px;
      line-height:1.45;
      color:#f3f6ff;
    }
    .copybtn{
      position:absolute;
      top:10px;
      right:10px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:6px 10px;
      border-radius:999px;
      cursor:pointer;
      font-size:12px;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      user-select:none;
    }
    .copybtn:hover{
      background: rgba(124,240,193,.10);
      border-color: rgba(124,240,193,.25);
      transform: translateY(-1px);
    }
    .copybtn:active{transform: translateY(0px) scale(.98);}
    .copymsg{
      position:absolute;
      top:44px;
      right:10px;
      font-size:12px;
      color:var(--accent);
      opacity:0;
      transform: translateY(-4px);
      transition: opacity .25s ease, transform .25s ease;
      pointer-events:none;
    }
    .eq.copied .copymsg{opacity:1; transform: translateY(0);}

    figure{
      margin:0;
      border-radius:16px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(7,10,20,.40);
    }
    figcaption{
      padding:10px 12px;
      color:var(--muted);
      font-size:13px;
      border-top:1px solid rgba(255,255,255,.10);
    }
    canvas{
      display:block;
      width:100%;
      height:320px;
      background: radial-gradient(600px 320px at 50% 30%, rgba(120,166,255,.10), transparent 60%),
                  linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));
    }

    .controls{
      display:grid;
      grid-template-columns: 1.2fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .control{
      border:1px solid rgba(255,255,255,.14);
      border-radius:14px;
      padding:10px 12px;
      background: rgba(7,10,20,.35);
    }
    .control label{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      color:var(--muted);
      font-size:13px;
      margin-bottom:8px;
    }
    .control .value{
      font-family:var(--mono);
      color:var(--text);
      font-size:13px;
    }
    input[type="range"]{width:100%;}
    select, button.small{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color:var(--text);
      font-size:13px;
      cursor:pointer;
    }
    button.small:hover, select:hover{
      border-color: rgba(124,240,193,.22);
      background: rgba(124,240,193,.08);
    }

    .divider{
      height:1px;
      background: rgba(255,255,255,.10);
      margin:10px 0;
    }

    footer{
      max-width:1100px;
      margin:0 auto;
      padding: 0 18px 26px;
      color: var(--faint);
      font-size: 13px;
    }

    @media (max-width: 980px){
      .layout{grid-template-columns: 1fr; }
      nav.toc{position:relative; top:auto;}
      canvas{height:300px;}
      .grid2{grid-template-columns: 1fr;}
      .controls{grid-template-columns: 1fr;}
    }

    @media print{
      body{background:#fff; color:#111;}
      header, main, section, article, nav.toc{box-shadow:none; background:#fff; border:1px solid #ddd;}
      nav.toc{position:relative;}
      .copybtn, .copymsg{display:none !important;}
      a{color:#111; text-decoration:underline;}
      canvas{display:none;}
      figcaption{border-top:1px solid #ddd;}
    }

    /* subtle entrance */
    .fadein{
      animation: enter .45s ease both;
    }
    @keyframes enter{
      from{opacity:0; transform: translateY(6px);}
      to{opacity:1; transform: translateY(0);}
    }
  </style>
</head>

<body>
<!DOCTYPE html>
<header class="fadein">
  <div class="kicker">
    <span class="tag">Polarization Optics</span>
    <span class="tag">Jones Calculus</span>
    <span class="tag">Retarders in Tandem</span>
  </div>
  <h1>6.1-9 â€” Wave Retarders in Tandem: Jones Matrices and the 90Â° Polarization Rotator</h1>
  <p>
    Weâ€™ll build the Jones matrices for three ideal wave plates, cascade them, and show the combined device rotates polarization by 90Â°.
    Then weâ€™ll reverse the order and see what changes (hint: rotation direction flips).
  </p>
</header>

<div class="layout">
  <main>
    <section id="quick-summary" class="fadein">
      <h2>Quick Summary</h2>
      <ul>
        <li>This problem is about <b>Jones matrices</b> for wave retarders (quarter-wave and half-wave plates) and their <b>non-commuting</b> cascades.</li>
        <li>Key idea: a linear retarder introduces a <b>relative phase delay</b> between orthogonal polarization components along its principal axes.</li>
        <li>Governing tool: <b>Jones calculus</b> with rotation matrices:
          <span class="tag">J(Î¸,Î´)=R(-Î¸)Â·diag(1,e^{iÎ´})Â·R(Î¸)</span>.
        </li>
        <li>We write matrices for:
          (a) QWP fast along x, (b) HWP fast at 45Â°, (c) QWP fast along y.</li>
        <li>When cascaded as <b>(c) after (b) after (a)</b>, the net matrix equals (up to global phase)
          <b>R(90Â°)</b>, i.e. a <b>90Â° polarization rotation</b>.</li>
        <li>If the order is reversed, the net effect becomes <b>R(-90Â°)</b> (rotation by 270Â°), demonstrating <b>order matters</b>.</li>
        <li>Final result is <b>symbolic</b>, with numeric examples used only for plots.</li>
      </ul>
    </section>

    <section id="part0" class="fadein">
      <h2>PART 0 â€” Concept Primer (Theory Before Solving)</h2>

      <div class="grid2">
        <article>
          <h3>Core Definitions</h3>
          <p>
            <b>Jones vector</b> (monochromatic, fully polarized light) describes the complex field amplitudes in the
            transverse xâ€“y basis:
          </p>
          <div class="eq" data-copy="E = [E_x; E_y],  where E_x, E_y are complex (amplitude + phase).">
            <button class="copybtn" type="button">Copy</button>
            <div class="copymsg">Copied âœ“</div>
            E = [ E_x ; E_y ]    (Jones vector)
          </div>
          <p>
            A <b>linear retarder</b> (wave plate) has two orthogonal principal axes: <b>fast</b> and <b>slow</b>.
            The slow axis accumulates more phase. The <b>retardance</b> is
            <b>Î´ = Ï†_slow âˆ’ Ï†_fast</b> (radians).
          </p>
          <p>
            For an ideal plate aligned to the xâ€“y axes, if x is the fast axis, then y is slow and the Jones matrix (dropping global phase) is:
          </p>
          <div class="eq" data-copy="If fast axis = x:  J = [[1, 0],[0, e^{iÎ´}]].  If fast axis = y:  J = [[e^{iÎ´}, 0],[0, 1]].">
            <button class="copybtn" type="button">Copy</button>
            <div class="copymsg">Copied âœ“</div>
If fast axis = x:
  J = [ [ 1,   0 ],
        [ 0, e^{iÎ´} ] ]

If fast axis = y:
  J = [ [ e^{iÎ´}, 0 ],
        [   0,   1 ] ]
          </div>
        </article>

        <article>
          <h3>Rotation of Optical Axes</h3>
          <p>
            If a plateâ€™s fast axis is rotated by angle Î¸ from the x-axis (counterclockwise), we use a basis rotation:
          </p>
          <div class="eq" data-copy="R(Î¸)= [[cosÎ¸, -sinÎ¸],[sinÎ¸, cosÎ¸]].  Rotated retarder: J(Î¸,Î´)=R(-Î¸)Â·diag(1,e^{iÎ´})Â·R(Î¸).">
            <button class="copybtn" type="button">Copy</button>
            <div class="copymsg">Copied âœ“</div>
R(Î¸) = [ [ cosÎ¸, -sinÎ¸ ],
         [ sinÎ¸,  cosÎ¸ ] ]

J(Î¸, Î´) = R(-Î¸) Â· diag(1, e^{iÎ´}) Â· R(Î¸)
          </div>
          <p>
            Special cases (retardance Î´):
            <span class="tag">Quarter-wave plate (QWP): Î´=Ï€/2</span>
            <span class="tag">Half-wave plate (HWP): Î´=Ï€</span>
          </p>
          <p>
            <b>Physical meaning:</b> QWP converts linear â†” circular/elliptical depending on orientation; HWP reflects the polarization state on the PoincarÃ© sphere and rotates linear polarization by <b>2Ã—</b> the angle between input and its axis.
          </p>
        </article>
      </div>

      <div class="callouts">
        <div class="box keyeq">
          <h4>Key Principle</h4>
          <p>
            Jones matrices for ideal, lossless elements are unitary up to a global phase.
            <b>Global phase does not affect polarization</b>, so we are free to factor it out.
          </p>
        </div>
        <div class="box assumptions">
          <h4>Validity / Assumptions</h4>
          <ul>
            <li>Monochromatic (single frequency) light.</li>
            <li>Fully polarized beam (Jones calculus applies directly).</li>
            <li>Ideal retarders: no absorption, no depolarization, perfect retardance.</li>
            <li>We track polarization only (ignore global phase).</li>
          </ul>
        </div>
        <div class="box mistakes">
          <h4>What to Watch For</h4>
          <ul>
            <li><b>Fast vs slow axis</b>: the slow axis gets the extra phase <b>e^{iÎ´}</b>.</li>
            <li><b>Order matters</b>: matrix multiplication is not commutative.</li>
            <li>Be consistent about <b>rotation convention</b> (here: Î¸ CCW from x).</li>
            <li>Dropping global phase is fine, but donâ€™t accidentally drop <i>relative</i> phase.</li>
          </ul>
        </div>
      </div>

      <h3>Mini Intuition Examples (No Long Algebra)</h3>
      <ul>
        <li>
          A QWP with fast axis along x: if input is linear at 45Â° (equal x and y components), the y component lags by 90Â° â†’ output becomes circular (one component in quadrature).
        </li>
        <li>
          A HWP at 45Â° swaps x and y components (up to sign) â†’ linear polarization rotates by 90Â° if initially aligned with x or y.
        </li>
      </ul>
    </section>

    <section id="part1" class="fadein">
      <h2>PART 1 â€” Problem Analysis (No Solving Yet)</h2>

      <h3>Restatement (In Plain Words)</h3>
      <p>
        Write Jones matrices for three specific retarders:
        (a) a quarter-wave plate with fast axis along x,
        (b) a half-wave plate with fast axis at 45Â° to x,
        (c) a quarter-wave plate with fast axis along y.
        Then multiply them in the specified order (a â†’ b â†’ c) and show the cascade acts like a 90Â° rotator.
        Finally, reverse the order and determine what happens.
      </p>

      <div class="grid2">
        <article>
          <h3>Given</h3>
          <ul>
            <li>Retardances: Î´_Q = Ï€/2, Î´_H = Ï€.</li>
            <li>Orientations: (a) Î¸=0Â° (fast along x), (b) Î¸=45Â° (fast at 45Â°), (c) fast along y (equivalently Î¸=90Â° with x-fast form).</li>
          </ul>

          <h3>Unknowns / What to Find</h3>
          <ul>
            <li>Jones matrices J<sub>a</sub>, J<sub>b</sub>, J<sub>c</sub>.</li>
            <li>Product J<sub>tot</sub> = J<sub>c</sub> J<sub>b</sub> J<sub>a</sub> and its interpretation.</li>
            <li>Product in reversed order and its interpretation.</li>
          </ul>
        </article>

        <article>
          <h3>Relevant Principles (and Why)</h3>
          <ul>
            <li><b>Jones calculus</b> applies because elements are linear and the field is fully polarized.</li>
            <li><b>Axis rotation rule</b> applies because plate (b) is rotated relative to the xâ€“y basis.</li>
            <li><b>Matrix multiplication</b> models a cascade because the output of one element becomes the input to the next.</li>
          </ul>
          <p>
            We do <i>not</i> need Maxwellâ€™s equations or Fresnel coefficients: the problem is purely polarization transformation under ideal linear optical components.
          </p>
        </article>
      </div>

      <div class="box assumptions">
        <h4>Assumptions Used in the Solution</h4>
        <ul>
          <li>Ideal quarter-wave and half-wave retardances exactly Ï€/2 and Ï€.</li>
          <li>Axes are perfectly aligned at the stated angles.</li>
          <li>Lossless elements (unitary polarization transformation).</li>
        </ul>
      </div>

      <h3>Possible Approaches</h3>
      <ul>
        <li>
          <b>Approach A: Direct Jones matrices</b> â€” build each matrix then multiply. <span class="tag">Best for this problem</span>
        </li>
        <li>
          <b>Approach B: PoincarÃ© sphere reasoning</b> â€” QWP and HWP correspond to rotations on the sphere; cascade yields net rotation. Fast conceptual check, but can be more abstract.
        </li>
        <li>
          <b>Approach C: Eigen-axis decomposition</b> â€” treat each plate as phase shift in its eigenbasis. Equivalent to A but phrased differently.
        </li>
      </ul>
      <p>
        We choose <b>Approach A</b> because the question explicitly asks for Jones matrices and a product demonstration.
      </p>
    </section>

    <section id="part2" class="fadein">
      <h2>PART 2 â€” Strategy &amp; Tips (Roadmap Only)</h2>

      <ol>
        <li><b>Write the base retarder matrix</b> aligned with xâ€“y (fast axis known). Tool: diag(1, e^{iÎ´}). Meaning: introduces relative phase Î´.</li>
        <li><b>Specialize to QWP and HWP</b> by setting Î´=Ï€/2 or Ï€. Meaning: quarter-wave (90Â° phase lag), half-wave (180Â° phase lag).</li>
        <li><b>Rotate the HWP</b> to Î¸=45Â° using J(Î¸,Î´)=R(-Î¸)Â·diag(1,e^{iÎ´})Â·R(Î¸). Meaning: express plate action in the lab xâ€“y basis.</li>
        <li><b>Multiply in cascade order</b> J<sub>tot</sub>=J<sub>c</sub>J<sub>b</sub>J<sub>a</sub>. Meaning: sequential action on the field.</li>
        <li><b>Recognize the result</b> as a rotation matrix (up to global phase). Meaning: the device rotates polarization.</li>
        <li><b>Reverse the order</b> and repeat multiplication; compare. Meaning: non-commutativity â†’ different physical effect.</li>
        <li><b>Sanity checks</b>: compare with ideal rotation matrix, test on basis vectors x and y, and confirm global phase irrelevance.</li>
      </ol>

      <div class="box mistakes">
        <h4>Common Mistakes + Quick Tips</h4>
        <ul>
          <li>Multiplying in the wrong order: rightmost acts first on the input Jones vector.</li>
          <li>Using Î¸ instead of 2Î¸ for HWP â€œrotation effectâ€: HWP rotates linear polarization by 2Ã— the relative angle, but the matrix rotation uses Î¸ directly inside R(Î¸).</li>
          <li>Forgetting that a global factor like <span class="tag">e^{iÏ†}</span> can be ignored for polarization.</li>
        </ul>
      </div>
    </section>

    <section id="part3" class="fadein">
      <h2>PART 3 â€” Full Solution (Detailed + Teaching)</h2>

      <h3>Qualitative Expectation (Before Calculating)</h3>
      <p>
        A quarter-wave plate changes the <i>ellipticity</i> (phase relationship) while a half-wave plate strongly â€œflipsâ€ polarization states.
        Sandwiching an HWP between two QWPs is a classic trick: the QWPs convert certain phase relationships into axis rotations and back.
        So itâ€™s plausible the net device acts like a <b>pure rotator</b> on the polarization.
      </p>

      <div class="divider"></div>

      <h3>Step 1: Jones Matrix for (a) QWP, Fast Along x</h3>
      <p>
        If the fast axis is x, then y is slow, so y gains phase <b>e^{iÎ´}</b> relative to x. For a QWP, Î´=Ï€/2, so e^{iÏ€/2}=i:
      </p>
      <div class="eq" data-copy="(a) QWP fast along x:  J_a = [[1,0],[0,i]].">
        <button class="copybtn" type="button">Copy</button>
        <div class="copymsg">Copied âœ“</div>
J_a = [ [ 1, 0 ],
        [ 0, i ] ]     (QWP, fast axis x)
      </div>
      <p>
        <i>Meaning:</i> the y-component is shifted by +90Â° phase compared to x (since y is slow).
      </p>

      <h3>Step 2: Jones Matrix for (c) QWP, Fast Along y</h3>
      <p>
        If the fast axis is y, then x is slow and x gains the extra phase e^{iÎ´}. Again Î´=Ï€/2:
      </p>
      <div class="eq" data-copy="(c) QWP fast along y:  J_c = [[i,0],[0,1]].">
        <button class="copybtn" type="button">Copy</button>
        <div class="copymsg">Copied âœ“</div>
J_c = [ [ i, 0 ],
        [ 0, 1 ] ]     (QWP, fast axis y)
      </div>
      <p>
        <i>Meaning:</i> now x is the slow component and picks up +90Â° relative phase.
      </p>

      <h3>Step 3: Jones Matrix for (b) HWP, Fast Axis at 45Â°</h3>
      <p>
        Start with an x-aligned retarder with fast axis along x:
        diag(1, e^{iÎ´}). For a HWP, Î´=Ï€, so e^{iÏ€} = âˆ’1:
      </p>
      <div class="eq" data-copy="Base HWP (fast along x): diag(1, -1). Rotated by Î¸: J_b(Î¸)=R(-Î¸)Â·diag(1,-1)Â·R(Î¸). For Î¸=45Â°, J_b=[[0,1],[1,0]] (up to global phase).">
        <button class="copybtn" type="button">Copy</button>
        <div class="copymsg">Copied âœ“</div>
diag(1, e^{iÏ€}) = diag(1, -1)

J_b(Î¸) = R(-Î¸) Â· diag(1, -1) Â· R(Î¸)

At Î¸ = 45Â°:
J_b = [ [ 0, 1 ],
        [ 1, 0 ] ]   (HWP at 45Â°, global phase ignored)
      </div>

      <p>
        <i>What did we do and why?</i> We expressed the plateâ€™s principal-axis action in its own frame (diagonal form),
        then rotated back to the lab xâ€“y basis using R(Î¸).
      </p>

      <div class="box keyeq">
        <h4>Handy Closed Form for a Half-Wave Plate</h4>
        <p>
          For an HWP at angle Î¸, dropping global phase:
        </p>
        <div class="eq" data-copy="HWP(Î¸) â‰ˆ [[cos2Î¸, sin2Î¸],[sin2Î¸, -cos2Î¸]] (global phase ignored).">
          <button class="copybtn" type="button">Copy</button>
          <div class="copymsg">Copied âœ“</div>
HWP(Î¸) â‰ˆ [ [ cos(2Î¸),  sin(2Î¸) ],
           [ sin(2Î¸), -cos(2Î¸) ] ]
          </div>
        <p>
          Plugging Î¸=45Â° gives cos90Â°=0 and sin90Â°=1, hence the swap matrix.
        </p>
      </div>

      <div class="divider"></div>

      <h3>Step 4: Cascade (c) Following (b) Following (a)</h3>
      <p>
        The rightmost element acts first on the input Jones vector, so the total is:
      </p>
      <div class="eq" data-copy="J_total = J_c Â· J_b Â· J_a (because a acts first, then b, then c).">
        <button class="copybtn" type="button">Copy</button>
        <div class="copymsg">Copied âœ“</div>
J_total = J_c Â· J_b Â· J_a
      </div>

      <p>Compute step-by-step:</p>
      <div class="eq" data-copy="J_b J_a = [[0,1],[1,0]]Â·[[1,0],[0,i]] = [[0,i],[1,0]]. Then J_total = J_cÂ·(J_b J_a) = [[i,0],[0,1]]Â·[[0,i],[1,0]] = [[0,-1],[1,0]].">
        <button class="copybtn" type="button">Copy</button>
        <div class="copymsg">Copied âœ“</div>
J_b J_a =
  [ [ 0, 1 ],
    [ 1, 0 ] ] Â·
  [ [ 1, 0 ],
    [ 0, i ] ]
= [ [ 0, i ],
    [ 1, 0 ] ]

J_total = J_c Â· (J_b J_a) =
  [ [ i, 0 ],
    [ 0, 1 ] ] Â·
  [ [ 0, i ],
    [ 1, 0 ] ]
= [ [ 0, iÂ·i ],
    [ 1, 0 ] ]
= [ [ 0, -1 ],
    [ 1,  0 ] ]
      </div>

      <p>
        <b>Recognize the result:</b> The real rotation matrix by +90Â° is
        R(90Â°) = [[0, âˆ’1],[1, 0]]. That matches exactly. Therefore the device is a <b>90Â° polarization rotator</b>.
      </p>

      <div class="box final" id="final-answer-box">
        <h4>Final Answer (Cascade aâ†’bâ†’c)</h4>
        <div class="eq" data-copy="J_a=[[1,0],[0,i]].  J_b(45Â°)=[[0,1],[1,0]].  J_c=[[i,0],[0,1]].  J_total=J_c J_b J_a = [[0,-1],[1,0]] = R(90Â°).">
          <button class="copybtn" type="button">Copy</button>
          <div class="copymsg">Copied âœ“</div>
J_a = [ [1, 0],
        [0, i] ]

J_b (Î¸=45Â°) = [ [0, 1],
               [1, 0] ]

J_c = [ [i, 0],
        [0, 1] ]

J_total = J_c J_b J_a = [ [ 0, -1],
                          [ 1,  0] ] = R(90Â°)
        </div>
        <p>
          <b>Interpretation:</b> For any input polarization state, the output is the same state rotated by +90Â° in the xâ€“y plane
          (global phase ignored).
        </p>
      </div>

      <h3>Step 5: What If the Order Is Reversed?</h3>
      <p>
        Reversing means: <b>(a) after (b) after (c)</b>, i.e.
        Jâ€² = J<sub>a</sub> J<sub>b</sub> J<sub>c</sub>.
      </p>
      <div class="eq" data-copy="Reversed order: J_rev = J_aÂ·J_bÂ·J_c = [[0,1],[-1,0]] = R(-90Â°).">
        <button class="copybtn" type="button">Copy</button>
        <div class="copymsg">Copied âœ“</div>
First: J_b J_c =
  [ [ 0, 1 ],
    [ 1, 0 ] ] Â·
  [ [ i, 0 ],
    [ 0, 1 ] ]
= [ [ 0, 1 ],
    [ i, 0 ] ]

Then: J_rev = J_a (J_b J_c) =
  [ [ 1, 0 ],
    [ 0, i ] ] Â·
  [ [ 0, 1 ],
    [ i, 0 ] ]
= [ [ 0, 1 ],
    [ iÂ·i, 0 ] ]
= [ [ 0,  1 ],
    [ -1, 0 ] ]
= R(-90Â°)
      </div>

      <div class="box final">
        <h4>Final Answer (Reversed Order)</h4>
        <p>
          Reversing the order flips the rotation direction:
          <b>+90Â° becomes âˆ’90Â°</b> (equivalently 270Â°). This is a direct manifestation of <b>non-commutativity</b>:
          J<sub>c</sub>J<sub>b</sub>J<sub>a</sub> â‰  J<sub>a</sub>J<sub>b</sub>J<sub>c</sub>.
        </p>
      </div>

      <h3>Sanity Checks</h3>
      <ul>
        <li><b>Units/dimensions:</b> Jones matrices are dimensionless; phase factors are unit-magnitude complex numbers.</li>
        <li><b>Test on basis vectors:</b> Apply J_total to x-polarized [1,0]áµ€ â†’ [0,1]áµ€ (becomes y). Apply to y-polarized [0,1]áµ€ â†’ [âˆ’1,0]áµ€ (becomes âˆ’x). That is a +90Â° rotation.</li>
        <li><b>Global phase:</b> Any overall factor e^{iÏ†} would not change polarization; our identification as a rotator is polarization-correct.</li>
      </ul>

      <p>
        <b>Connection to the plots:</b> In the â€œMain Plotâ€ below, for Î¸=45Â° and order aâ†’bâ†’c, the output linear polarization azimuth
        Ïˆ<sub>out</sub> tracks Ïˆ<sub>in</sub> + 90Â° across all inputs, demonstrating a pure rotation.
      </p>
    </section>

    <section id="part4" class="fadein">
      <h2>PART 4 â€” Deeper Understanding (Theory Around the Result)</h2>

      <h3>What the Final Matrix Really Means</h3>
      <p>
        The net device behaves like a <b>polarization rotator</b>:
        it changes the basis directions of the field without changing the â€œshapeâ€ of the polarization state (aside from a rotation).
        In matrix form, a real rotation by angle Ï† is:
      </p>
      <div class="eq" data-copy="Rotation matrix: R(Ï†)=[[cosÏ†,-sinÏ†],[sinÏ†,cosÏ†]]. Here, J_total = R(90Â°).">
        <button class="copybtn" type="button">Copy</button>
        <div class="copymsg">Copied âœ“</div>
R(Ï†) = [ [ cosÏ†, -sinÏ† ],
         [ sinÏ†,  cosÏ† ] ]

Here: J_total = R(90Â°)
      </div>

      <h3>Parameter Sensitivity (Why the Slider Matters)</h3>
      <p>
        The middle HWP orientation is crucial. When its fast axis is exactly at <b>Î¸=45Â°</b>, the cascade becomes a perfect 90Â° rotator.
        If Î¸ deviates, the output is no longer a pure +90Â° shift for all input polarizations â€” the plots show increasing deviation.
      </p>

      <h3>Alternative Derivation Idea (Brief)</h3>
      <p>
        On the <b>PoincarÃ© sphere</b>, a linear retarder corresponds to a rotation about an axis in the S<sub>1</sub>â€“S<sub>2</sub> plane.
        A QWP is a 90Â° rotation about an equatorial axis; an HWP is a 180Â° rotation. The sequence QWPâ€“HWPâ€“QWP composes into a net rotation equivalent to a spatial rotation of the polarization ellipse. Reversing the sequence reverses the effective rotation direction.
      </p>

      <h3>Concept Check (Self-Test)</h3>
      <ul>
        <li><b>Q:</b> Why can we drop a global phase factor in Jones calculus? <b>A:</b> Because polarization observables depend on relative phases between components, not on an overall phase multiplying both.</li>
        <li><b>Q:</b> Why does reversing the order change the result? <b>A:</b> Because matrix multiplication is not commutative; physically, intermediate states differ, so the final state differs.</li>
        <li><b>Q:</b> Whatâ€™s special about Î¸=45Â° for the HWP here? <b>A:</b> It makes the HWP swap x and y components (in the lab basis), enabling the two QWPs to convert phase operations into an effective spatial rotation.</li>
        <li><b>Q:</b> If you set Î¸=0Â° for the HWP, would you still get a rotator? <b>A:</b> No; youâ€™d mainly get a diagonal phase/sign operation, not a universal 90Â° rotation.</li>
      </ul>
    </section>

    <section id="viz" class="fadein">
      <h2>Interactive Visualizations</h2>

      <div class="controls" aria-label="Interactive controls">
        <div class="control">
          <label for="theta">
            Middle HWP fast-axis angle Î¸ (deg)
            <span class="value" id="thetaVal">45.0</span>
          </label>
          <input id="theta" type="range" min="0" max="90" step="0.1" value="45.0" />
          <p style="margin:8px 0 0; color:var(--faint); font-size:12px;">
            This changes plate (b) orientation; perfect rotator occurs near Î¸=45Â°.
          </p>
        </div>

        <div class="control">
          <label for="order">
            Cascade order
            <span class="value" id="orderVal">a â†’ b â†’ c</span>
          </label>
          <select id="order">
            <option value="abc" selected>a â†’ b â†’ c (c after b after a)</option>
            <option value="cba">c â†’ b â†’ a (reversed)</option>
          </select>
          <p style="margin:8px 0 0; color:var(--faint); font-size:12px;">
            Same plates, different order â†’ generally different net transformation.
          </p>
        </div>
      </div>

      <div class="grid2" style="margin-top:12px;">
        <figure>
          <canvas id="diag"></canvas>
          <figcaption>
            <b>Diagram:</b> Three plates in tandem: (a) QWP (fast x), (b) HWP (fast at Î¸), (c) QWP (fast y).
            Arrows show fast axes in the lab xâ€“y basis.
          </figcaption>
        </figure>

        <figure>
          <canvas id="plotMain"></canvas>
          <figcaption>
            <b>Main plot:</b> For <i>linear inputs</i> with azimuth Ïˆ<sub>in</sub>, we compute Ïˆ<sub>out</sub> from the Jones output.
            Ideal rotator: Ïˆ<sub>out</sub> = Ïˆ<sub>in</sub> Â± 90Â°.
          </figcaption>
        </figure>
      </div>

      <figure style="margin-top:12px;">
        <canvas id="plotSweep"></canvas>
        <figcaption>
          <b>Secondary plot (parameter sweep):</b> Maximum deviation from an ideal Â±90Â° rotation over all linear input angles,
          plotted versus Î¸. The marker shows your current Î¸.
        </figcaption>
      </figure>
    </section>

    <section id="part5" class="fadein">
      <h2>PART 5 â€” Visualization Guide (How to Read the Plots)</h2>

      <h3>What Each Canvas Shows</h3>
      <ul>
        <li><b>Diagram canvas:</b> The optical train with three plates. The fast-axis direction on each plate is drawn as an arrow in the xâ€“y plane.</li>
        <li><b>Main plot:</b> x-axis is input linear polarization angle Ïˆ<sub>in</sub> (degrees). y-axis is output angle Ïˆ<sub>out</sub> (degrees).
          A perfect +90Â° rotator appears as a straight line Ïˆ<sub>out</sub>=Ïˆ<sub>in</sub>+90Â° (wrapped modulo 180Â° for linear polarization).</li>
        <li><b>Secondary sweep plot:</b> x-axis is the HWP angle Î¸. y-axis is the worst-case deviation (degrees) from the best-fit ideal Â±90Â° rotation over all Ïˆ<sub>in</sub>.
          Low values near Î¸=45Â° show robustness at the correct setting.</li>
      </ul>

      <h3>How the Controls Affect the Physics</h3>
      <ul>
        <li><b>Î¸ slider:</b> rotates the HWP principal axes. At Î¸=45Â°, the cascade aâ†’bâ†’c becomes a clean 90Â° rotator.
          Moving away introduces mixing of ellipticity and azimuth, so Ïˆ<sub>out</sub> no longer tracks Ïˆ<sub>in</sub>+90Â° for all inputs.</li>
        <li><b>Order selector:</b> switches between aâ†’bâ†’c and reversed. For the ideal angles, reversing flips the sign of the rotation (Â±90Â°).</li>
      </ul>

      <div class="box keyeq">
        <h4>Symbols Match the Code</h4>
        <ul>
          <li>Î¸ (deg): HWP fast-axis angle in the lab frame.</li>
          <li>Î´<sub>Q</sub>=Ï€/2, Î´<sub>H</sub>=Ï€: fixed retardances (ideal QWP and HWP).</li>
          <li>J<sub>a</sub>, J<sub>b</sub>(Î¸), J<sub>c</sub>: the three Jones matrices.</li>
          <li>Ïˆ: linear polarization azimuth extracted from Stokes parameters (computed from Jones output).</li>
        </ul>
      </div>
    </section>
  </main>

  <nav class="toc fadein" aria-label="Table of Contents">
    <h2>On this page</h2>
    <a href="#quick-summary">Quick Summary</a>
    <a href="#part0">PART 0 â€” Concept Primer</a>
    <a href="#part1">PART 1 â€” Problem Analysis</a>
    <a href="#part2">PART 2 â€” Strategy &amp; Tips</a>
    <a href="#part3">PART 3 â€” Full Solution</a>
    <a href="#part4">PART 4 â€” Deeper Understanding</a>
    <a href="#viz">Interactive Visualizations</a>
    <a href="#part5">PART 5 â€” Visualization Guide</a>
    <div class="hint">
      Tip: Use the slider to move Î¸ away from 45Â° and watch how the â€œperfect rotatorâ€ behavior breaks.
    </div>
  </nav>
</div>

<footer class="fadein">
  Built as a self-contained learning article: theory â†’ analysis â†’ strategy â†’ full derivation â†’ deeper understanding â†’ interactive visuals.
</footer>

<script>
/* ---------------------------
   Smooth TOC scrolling
---------------------------- */
(function(){
  document.querySelectorAll('nav.toc a[href^="#"]').forEach(a=>{
    a.addEventListener('click', (e)=>{
      e.preventDefault();
      const id = a.getAttribute('href');
      const el = document.querySelector(id);
      if(!el) return;
      el.scrollIntoView({behavior:"smooth", block:"start"});
      history.replaceState(null,"",id);
    });
  });
})();

/* ---------------------------
   Copy buttons
---------------------------- */
(function(){
  function copyText(txt){
    if(navigator.clipboard && navigator.clipboard.writeText){
      return navigator.clipboard.writeText(txt);
    }
    // fallback
    const ta = document.createElement('textarea');
    ta.value = txt;
    ta.setAttribute('readonly','');
    ta.style.position='fixed';
    ta.style.left='-9999px';
    document.body.appendChild(ta);
    ta.select();
    try{ document.execCommand('copy'); }catch(e){}
    document.body.removeChild(ta);
    return Promise.resolve();
  }

  document.querySelectorAll('.eq').forEach(eq=>{
    const btn = eq.querySelector('.copybtn');
    if(!btn) return;
    btn.addEventListener('click', async ()=>{
      const txt = eq.getAttribute('data-copy') || eq.textContent.trim();
      try{
        await copyText(txt);
        eq.classList.add('copied');
        setTimeout(()=>eq.classList.remove('copied'), 900);
      }catch(err){
        eq.classList.add('copied');
        setTimeout(()=>eq.classList.remove('copied'), 900);
      }
    });
  });
})();

/* ---------------------------
   Complex + matrix utilities
---------------------------- */
class C {
  constructor(re, im){ this.re=re; this.im=im; }
  static add(a,b){ return new C(a.re+b.re, a.im+b.im); }
  static sub(a,b){ return new C(a.re-b.re, a.im-b.im); }
  static mul(a,b){ return new C(a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re); }
  static conj(a){ return new C(a.re, -a.im); }
  static abs2(a){ return a.re*a.re + a.im*a.im; }
  static expi(phi){ return new C(Math.cos(phi), Math.sin(phi)); }
}
function M2(a00,a01,a10,a11){ return [[a00,a01],[a10,a11]]; }
function mMul(A,B){
  const a00 = C.add(C.mul(A[0][0],B[0][0]), C.mul(A[0][1],B[1][0]));
  const a01 = C.add(C.mul(A[0][0],B[0][1]), C.mul(A[0][1],B[1][1]));
  const a10 = C.add(C.mul(A[1][0],B[0][0]), C.mul(A[1][1],B[1][0]));
  const a11 = C.add(C.mul(A[1][0],B[0][1]), C.mul(A[1][1],B[1][1]));
  return [[a00,a01],[a10,a11]];
}
function mVec(A,v){
  return [
    C.add(C.mul(A[0][0], v[0]), C.mul(A[0][1], v[1])),
    C.add(C.mul(A[1][0], v[0]), C.mul(A[1][1], v[1]))
  ];
}
function Rreal(theta){
  const c = Math.cos(theta), s = Math.sin(theta);
  // real matrix -> complex with im=0
  return M2(new C(c,0), new C(-s,0), new C(s,0), new C(c,0));
}
function retarder(theta, delta){
  // J(Î¸,Î´) = R(-Î¸) diag(1, e^{iÎ´}) R(Î¸), fast axis corresponds to first component in the rotated frame.
  const Rp = Rreal(theta);
  const Rm = Rreal(-theta);
  const D = M2(new C(1,0), new C(0,0), new C(0,0), C.expi(delta));
  return mMul(mMul(Rm, D), Rp);
}
function wrap180(deg){
  // wrap to [0,180)
  let x = deg % 180;
  if(x < 0) x += 180;
  return x;
}
function angleDiffDeg(a,b){
  // minimal difference for linear polarization angles with 180Â° periodicity: output in [-90,90]
  let d = (a - b) % 180;
  if(d > 90) d -= 180;
  if(d < -90) d += 180;
  return d;
}
function stokesFromJones(E){
  // E = [Ex, Ey]
  const Ex = E[0], Ey = E[1];
  const Ex2 = C.abs2(Ex), Ey2 = C.abs2(Ey);
  const S0 = Ex2 + Ey2;
  const S1 = Ex2 - Ey2;
  const ExEyConj = C.mul(Ex, C.conj(Ey));
  const S2 = 2 * ExEyConj.re;
  const S3 = -2 * ExEyConj.im; // convention; sign not critical for azimuth
  return {S0,S1,S2,S3};
}
function azimuthFromStokes(S){
  // psi = 0.5 atan2(S2,S1) in radians; map to degrees in [0,180)
  const psi = 0.5 * Math.atan2(S.S2, S.S1);
  return wrap180(psi * 180/Math.PI);
}

/* ---------------------------
   Canvas helpers
---------------------------- */
function setupCanvas(canvas){
  const ctx = canvas.getContext('2d');
  function resize(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(2, Math.floor(rect.width * dpr));
    canvas.height = Math.max(2, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  }
  return {ctx, resize};
}
function clear(ctx,w,h){
  ctx.clearRect(0,0,w,h);
}
function drawPanelTitle(ctx, title, x, y){
  ctx.save();
  ctx.fillStyle = "rgba(233,238,252,.92)";
  ctx.font = "600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText(title, x, y);
  ctx.restore();
}
function drawAxes(ctx, box, xLabel, yLabel, xTicks, yTicks){
  const {x,y,w,h} = box;
  // background
  ctx.save();
  ctx.fillStyle = "rgba(7,10,20,.25)";
  ctx.fillRect(x,y,w,h);

  // grid
  ctx.strokeStyle = "rgba(255,255,255,.08)";
  ctx.lineWidth = 1;

  const nx = xTicks.count, ny = yTicks.count;
  for(let i=0;i<=nx;i++){
    const xx = x + (w*i/nx);
    ctx.beginPath(); ctx.moveTo(xx,y); ctx.lineTo(xx,y+h); ctx.stroke();
  }
  for(let j=0;j<=ny;j++){
    const yy = y + (h*j/ny);
    ctx.beginPath(); ctx.moveTo(x,yy); ctx.lineTo(x+w,yy); ctx.stroke();
  }

  // axes frame
  ctx.strokeStyle = "rgba(255,255,255,.18)";
  ctx.lineWidth = 1.2;
  ctx.strokeRect(x,y,w,h);

  // tick labels
  ctx.fillStyle = "rgba(184,195,230,.95)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";

  for(let i=0;i<=nx;i++){
    const xx = x + (w*i/nx);
    const val = xTicks.min + (xTicks.max-xTicks.min)*i/nx;
    const s = (Math.round(val*10)/10).toString();
    ctx.fillText(s, xx-10, y+h+16);
  }
  for(let j=0;j<=ny;j++){
    const yy = y + (h*j/ny);
    const val = yTicks.max - (yTicks.max-yTicks.min)*j/ny;
    const s = (Math.round(val*10)/10).toString();
    ctx.fillText(s, x-38, yy+4);
  }

  // axis labels
  ctx.fillStyle = "rgba(233,238,252,.92)";
  ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText(xLabel, x + w/2 - ctx.measureText(xLabel).width/2, y+h+34);

  ctx.save();
  ctx.translate(x-54, y + h/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
  ctx.restore();

  ctx.restore();
}
function mapToBox(box, xVal, yVal, xMin, xMax, yMin, yMax){
  const {x,y,w,h} = box;
  const xx = x + (xVal - xMin) / (xMax - xMin) * w;
  const yy = y + (yMax - yVal) / (yMax - yMin) * h;
  return {xx,yy};
}
function drawLine(ctx, pts, strokeStyle, lineWidth){
  ctx.save();
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = lineWidth;
  ctx.beginPath();
  for(let i=0;i<pts.length;i++){
    const p = pts[i];
    if(i===0) ctx.moveTo(p.xx,p.yy);
    else ctx.lineTo(p.xx,p.yy);
  }
  ctx.stroke();
  ctx.restore();
}
function drawLegend(ctx, items, x, y){
  ctx.save();
  ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  let yy = y;
  items.forEach(it=>{
    ctx.strokeStyle = it.color;
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(x, yy-4); ctx.lineTo(x+18, yy-4); ctx.stroke();
    ctx.fillStyle = "rgba(233,238,252,.92)";
    ctx.fillText(it.label, x+24, yy);
    yy += 18;
  });
  ctx.restore();
}

/* ---------------------------
   Physics: build the three plates
---------------------------- */
const deltaQ = Math.PI/2;
const deltaH = Math.PI;

function buildSystem(thetaDeg, order){
  const theta = thetaDeg * Math.PI/180;

  // (a) QWP fast x: diag(1, e^{iÎ´})
  const Ja = M2(new C(1,0), new C(0,0), new C(0,0), C.expi(deltaQ));

  // (c) QWP fast y: diag(e^{iÎ´}, 1)
  const Jc = M2(C.expi(deltaQ), new C(0,0), new C(0,0), new C(1,0));

  // (b) HWP fast at theta: rotated retarder
  const Jb = retarder(theta, deltaH);

  // Cascade:
  // aâ†’bâ†’c means Jtot = Jc * Jb * Ja
  // reversed means Jtot = Ja * Jb * Jc
  if(order === "abc"){
    return mMul(mMul(Jc, Jb), Ja);
  } else {
    return mMul(mMul(Ja, Jb), Jc);
  }
}

function predictRotationSign(order){
  // For the ideal case theta=45Â°, the order determines +90 vs -90
  return (order === "abc") ? +1 : -1;
}

/* ---------------------------
   Data generation for plots
---------------------------- */
function computeMainCurve(thetaDeg, order){
  const J = buildSystem(thetaDeg, order);
  const pts = [];
  for(let psiIn=0; psiIn<=180.0001; psiIn+=2){
    const a = psiIn * Math.PI/180;
    // linear input Jones vector: [cos a, sin a]
    const Ein = [new C(Math.cos(a),0), new C(Math.sin(a),0)];
    const Eout = mVec(J, Ein);
    const S = stokesFromJones(Eout);
    const psiOut = azimuthFromStokes(S);
    pts.push({psiIn, psiOut});
  }
  return pts;
}
function computeIdealLine(order){
  const sgn = predictRotationSign(order);
  const pts = [];
  for(let psiIn=0; psiIn<=180.0001; psiIn+=2){
    const psiOut = wrap180(psiIn + sgn*90);
    pts.push({psiIn, psiOut});
  }
  return pts;
}
function bestFitDeviation(thetaDeg, order){
  // For a given theta, compute the best Â±90 ideal (choose sign with smaller max deviation)
  const curve = computeMainCurve(thetaDeg, order);
  const devForSign = (sgn)=>{
    let maxDev = 0;
    for(const p of curve){
      const ideal = wrap180(p.psiIn + sgn*90);
      const d = Math.abs(angleDiffDeg(p.psiOut, ideal));
      if(d > maxDev) maxDev = d;
    }
    return maxDev;
  };
  const dPlus = devForSign(+1);
  const dMinus = devForSign(-1);
  return {maxDev: Math.min(dPlus, dMinus), bestSign: (dPlus<=dMinus)? +1 : -1};
}
function computeSweep(order){
  const pts = [];
  for(let th=0; th<=90.0001; th+=1){
    const r = bestFitDeviation(th, order);
    pts.push({theta: th, maxDev: r.maxDev});
  }
  return pts;
}

/* ---------------------------
   Drawing: Diagram
---------------------------- */
function drawDiagram(ctx, canvas, thetaDeg, order){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  clear(ctx, w, h);

  drawPanelTitle(ctx, "Setup Diagram: QWP (a) â†’ HWP (b) â†’ QWP (c)", 12, 18);

  const pad = 16;
  const cx0 = pad + 10;
  const cy = h*0.55;
  const plateW = (w - 2*pad) / 3.3;
  const gap = (w - 2*pad - 3*plateW) / 2;

  // axis triad
  ctx.save();
  ctx.translate(14, h-14);
  ctx.strokeStyle = "rgba(233,238,252,.65)";
  ctx.lineWidth = 2;
  // x arrow
  ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(40,0); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(40,0); ctx.lineTo(33,-5); ctx.lineTo(33,5); ctx.closePath(); ctx.fillStyle="rgba(233,238,252,.65)"; ctx.fill();
  // y arrow
  ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-40); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,-40); ctx.lineTo(-5,-33); ctx.lineTo(5,-33); ctx.closePath(); ctx.fill();
  ctx.fillStyle="rgba(233,238,252,.8)";
  ctx.font="12px var(--mono)";
  ctx.fillText("x", 44, 4);
  ctx.fillText("y", -10, -44);
  ctx.restore();

  function plate(x, label, subtitle){
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,.05)";
    ctx.strokeStyle = "rgba(255,255,255,.16)";
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    const r=14;
    ctx.moveTo(x+r, cy-90);
    ctx.arcTo(x+plateW, cy-90, x+plateW, cy+90, r);
    ctx.arcTo(x+plateW, cy+90, x, cy+90, r);
    ctx.arcTo(x, cy+90, x, cy-90, r);
    ctx.arcTo(x, cy-90, x+plateW, cy-90, r);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle="rgba(233,238,252,.92)";
    ctx.font="700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(label, x+12, cy-62);
    ctx.fillStyle="rgba(184,195,230,.92)";
    ctx.font="12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(subtitle, x+12, cy-42);
    ctx.restore();
  }

  // arrows between plates
  ctx.save();
  ctx.strokeStyle="rgba(124,240,193,.35)";
  ctx.lineWidth=2;
  ctx.setLineDash([6,6]);
  const yline = cy+110;
  ctx.beginPath(); ctx.moveTo(pad, yline); ctx.lineTo(w-pad, yline); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle="rgba(124,240,193,.85)";
  ctx.font="12px var(--mono)";
  ctx.fillText(order==="abc" ? "light propagation: a â†’ b â†’ c" : "light propagation: c â†’ b â†’ a", pad, yline-10);
  ctx.restore();

  const xa = cx0;
  const xb = xa + plateW + gap;
  const xc = xb + plateW + gap;

  plate(xa, "(a) QWP", "fast axis: x");
  plate(xb, "(b) HWP", "fast axis: Î¸");
  plate(xc, "(c) QWP", "fast axis: y");

  // draw fast-axis arrows inside each plate
  function drawAxisArrow(x, angDeg, color){
    const ang = angDeg * Math.PI/180;
    const cx = x + plateW*0.52;
    const len = 58;
    const dx = Math.cos(ang)*len;
    const dy = -Math.sin(ang)*len;
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.lineCap = "round";
    ctx.beginPath(); ctx.moveTo(cx-dx, cy-dy); ctx.lineTo(cx+dx, cy+dy); ctx.stroke();
    // arrow head
    const hx = cx+dx, hy = cy+dy;
    const a1 = ang + Math.PI*0.80;
    const a2 = ang - Math.PI*0.80;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(hx, hy);
    ctx.lineTo(hx + Math.cos(a1)*10, hy - Math.sin(a1)*10);
    ctx.lineTo(hx + Math.cos(a2)*10, hy - Math.sin(a2)*10);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
  drawAxisArrow(xa, 0, "rgba(120,166,255,.85)");
  drawAxisArrow(xb, thetaDeg, "rgba(124,240,193,.85)");
  drawAxisArrow(xc, 90, "rgba(255,211,107,.85)");

  // annotation about ideal result at 45Â°
  const nearIdeal = Math.abs(thetaDeg - 45) < 0.2;
  ctx.save();
  ctx.fillStyle = nearIdeal ? "rgba(156,255,139,.92)" : "rgba(255,211,107,.92)";
  ctx.font = "600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  const txt = nearIdeal ? "Î¸ â‰ˆ 45Â° â†’ near-perfect Â±90Â° rotator" : "Move Î¸ toward 45Â° for a clean rotator";
  ctx.fillText(txt, 12, 40);
  ctx.restore();
}

/* ---------------------------
   Drawing: Main plot and sweep
---------------------------- */
function drawMainPlot(ctx, canvas, thetaDeg, order){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  clear(ctx, w, h);

  const title = "Main Plot: Output azimuth Ïˆ_out vs input azimuth Ïˆ_in (linear inputs)";
  drawPanelTitle(ctx, title, 12, 18);

  const box = {x:56, y:36, w: w-76, h: h-82};
  drawAxes(ctx, box, "Ïˆ_in (deg)", "Ïˆ_out (deg)", {min:0,max:180,count:6}, {min:0,max:180,count:6});

  const curve = computeMainCurve(thetaDeg, order);
  const ideal = computeIdealLine(order);

  const xMin=0,xMax=180,yMin=0,yMax=180;
  const ptsCurve = curve.map(p => mapToBox(box, p.psiIn, p.psiOut, xMin, xMax, yMin, yMax));
  const ptsIdeal = ideal.map(p => mapToBox(box, p.psiIn, p.psiOut, xMin, xMax, yMin, yMax));

  drawLine(ctx, ptsIdeal, "rgba(255,255,255,.35)", 2);
  drawLine(ctx, ptsCurve, "rgba(124,240,193,.85)", 2.6);

  // legend
  const sign = predictRotationSign(order);
  drawLegend(ctx, [
    {label: `Ideal: Ïˆ_out = Ïˆ_in ${sign>0?"+":"âˆ’"} 90Â°`, color:"rgba(255,255,255,.35)"},
    {label: `Computed (Î¸=${thetaDeg.toFixed(1)}Â°)`, color:"rgba(124,240,193,.85)"}
  ], box.x + 10, box.y + 18);

  // small stats: max deviation from best Â±90 (not necessarily order sign)
  const r = bestFitDeviation(thetaDeg, order);
  ctx.save();
  ctx.fillStyle = "rgba(184,195,230,.95)";
  ctx.font = "12px var(--mono)";
  ctx.fillText(`best-fit rotator sign: ${r.bestSign>0?"+":"âˆ’"}90Â°, max deviation â‰ˆ ${r.maxDev.toFixed(2)}Â°`, box.x+10, box.y+box.h-10);
  ctx.restore();
}

function drawSweepPlot(ctx, canvas, thetaDeg, order){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  clear(ctx, w, h);

  const title = "Secondary Plot (Sweep): worst-case deviation from an ideal Â±90Â° rotator vs Î¸";
  drawPanelTitle(ctx, title, 12, 18);

  const box = {x:62, y:36, w: w-86, h: h-86};
  // y range: 0..90 degrees deviation (safe)
  drawAxes(ctx, box, "Î¸ (deg)", "max deviation (deg)", {min:0,max:90,count:6}, {min:0,max:90,count:6});

  const sweep = computeSweep(order);
  const xMin=0,xMax=90,yMin=0,yMax=90;
  const pts = sweep.map(p => mapToBox(box, p.theta, p.maxDev, xMin, xMax, yMin, yMax));
  drawLine(ctx, pts, "rgba(120,166,255,.85)", 2.6);

  // marker for current theta
  const r = bestFitDeviation(thetaDeg, order);
  const marker = mapToBox(box, thetaDeg, r.maxDev, xMin, xMax, yMin, yMax);

  ctx.save();
  ctx.fillStyle = "rgba(255,211,107,.95)";
  ctx.strokeStyle = "rgba(255,211,107,.95)";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(marker.xx, marker.yy, 5.5, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.moveTo(marker.xx, box.y); ctx.lineTo(marker.xx, box.y+box.h); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(box.x, marker.yy); ctx.lineTo(box.x+box.w, marker.yy); ctx.stroke();

  ctx.fillStyle = "rgba(233,238,252,.92)";
  ctx.font = "12px var(--mono)";
  const label = `Î¸=${thetaDeg.toFixed(1)}Â°, max devâ‰ˆ${r.maxDev.toFixed(2)}Â°`;
  ctx.fillText(label, Math.min(marker.xx+10, box.x+box.w-ctx.measureText(label).width-8), Math.max(marker.yy-10, box.y+14));
  ctx.restore();

  // legend
  drawLegend(ctx, [
    {label:"Sweep curve (computed)", color:"rgba(120,166,255,.85)"},
    {label:"Current Î¸ marker", color:"rgba(255,211,107,.95)"}
  ], box.x + 10, box.y + 18);
}

/* ---------------------------
   Orchestration + responsive redraw
---------------------------- */
const diag = document.getElementById('diag');
const plotMain = document.getElementById('plotMain');
const plotSweep = document.getElementById('plotSweep');

const diagC = setupCanvas(diag);
const mainC = setupCanvas(plotMain);
const sweepC = setupCanvas(plotSweep);

const thetaSlider = document.getElementById('theta');
const thetaVal = document.getElementById('thetaVal');
const orderSel = document.getElementById('order');
const orderVal = document.getElementById('orderVal');

function redraw(){
  const thetaDeg = parseFloat(thetaSlider.value);
  const order = orderSel.value;
  thetaVal.textContent = thetaDeg.toFixed(1);
  orderVal.textContent = (order==="abc") ? "a â†’ b â†’ c" : "c â†’ b â†’ a";

  // resize canvases (for crispness) then draw
  [diagC, mainC, sweepC].forEach(o => o.resize());

  drawDiagram(diagC.ctx, diag, thetaDeg, order);
  drawMainPlot(mainC.ctx, plotMain, thetaDeg, order);
  drawSweepPlot(sweepC.ctx, plotSweep, thetaDeg, order);
}

thetaSlider.addEventListener('input', redraw);
orderSel.addEventListener('change', redraw);
window.addEventListener('resize', ()=>{ redraw(); });

// initial draw
redraw();
</script>
</body>
</html>
