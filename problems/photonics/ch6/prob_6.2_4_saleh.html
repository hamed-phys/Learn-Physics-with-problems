<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Refraction at the Brewster Angle (TM Polarization) — Derivation + Interactive Plots</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1733;
      --panel2:#0c1430;
      --text:#eaf0ff;
      --muted:#b7c3ffcc;
      --faint:#b7c3ff66;
      --line:#2a3a7a;
      --good:#7CFFB2;
      --warn:#FFD37C;
      --bad:#FF7C7C;
      --accent:#8fb1ff;
      --accent2:#b28fff;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% 0%, rgba(143,177,255,.20), transparent 60%),
        radial-gradient(900px 700px at 90% 10%, rgba(178,143,255,.18), transparent 55%),
        radial-gradient(1100px 900px at 40% 100%, rgba(124,255,178,.10), transparent 60%),
        linear-gradient(180deg, var(--bg), #070a14 70%);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      position:relative;
      padding: clamp(18px, 3vw, 34px);
      max-width:1180px;
      margin:0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.35fr .65fr;
      gap:16px;
      align-items:stretch;
    }
    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(143,177,255,.18);
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      padding: 18px 18px 14px;
      overflow:hidden;
      position:relative;
    }
    .titleCard:before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(500px 250px at 20% 10%, rgba(143,177,255,.18), transparent 60%),
                  radial-gradient(450px 280px at 80% 0%, rgba(178,143,255,.14), transparent 60%);
      pointer-events:none;
      filter: blur(2px);
      opacity:.9;
    }
    .titleCard > *{position:relative}
    h1{
      margin:0 0 6px;
      font-size: clamp(22px, 2.3vw, 34px);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size: clamp(13px, 1.2vw, 15px);
    }
    .meta{
      margin-top:12px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      color:var(--faint);
      font-size: 13px;
    }
    .pill{
      border:1px solid rgba(143,177,255,.22);
      background: rgba(15,23,51,.55);
      padding:6px 10px;
      border-radius: 999px;
      display:inline-flex;
      gap:8px;
      align-items:center;
      backdrop-filter: blur(6px);
    }
    .pill b{color:var(--text); font-weight:600}
    .toc{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.025));
      border:1px solid rgba(143,177,255,.16);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
      position: sticky;
      top: 12px;
      align-self:start;
      max-height: calc(100vh - 24px);
      overflow:auto;
    }
    .toc h2{
      margin:0 0 10px;
      font-size: 14px;
      letter-spacing:.35px;
      text-transform:uppercase;
      color: var(--muted);
    }
    .toc a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      color: var(--text);
      border:1px solid transparent;
      font-size: 13px;
      line-height:1.25;
      margin-bottom:6px;
      background: rgba(7,10,20,.28);
    }
    .toc a:hover{
      border-color: rgba(143,177,255,.22);
      background: rgba(143,177,255,.08);
      text-decoration:none;
    }
    main{
      max-width:1180px;
      margin:0 auto;
      padding: 0 clamp(18px, 3vw, 34px) 40px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    section{
      background: linear-gradient(180deg, rgba(255,255,255,.045), rgba(255,255,255,.022));
      border:1px solid rgba(143,177,255,.14);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    section > header{
      padding: 14px 18px 0;
      margin:0;
      max-width:none;
    }
    section > header h2{
      margin: 0 0 8px;
      font-size: clamp(18px, 1.7vw, 22px);
    }
    .content{
      padding: 0 18px 18px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1.05fr 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns:1fr}
      .grid2,.grid3{grid-template-columns:1fr}
      .toc{position:relative; top:auto}
    }
    .callout{
      border-radius: 16px;
      padding: 12px 12px 10px;
      border: 1px solid rgba(143,177,255,.18);
      background: rgba(12,20,48,.55);
    }
    .callout h3{
      margin:0 0 8px;
      font-size: 14px;
      letter-spacing:.3px;
      text-transform: uppercase;
      color: var(--muted);
    }
    ul{margin:10px 0 0 20px}
    li{margin:6px 0}
    .eqRow{
      display:flex;
      gap:10px;
      align-items:stretch;
      flex-wrap:wrap;
      margin: 10px 0;
    }
    pre.eq{
      margin:0;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(178,143,255,.20);
      background: rgba(7,10,20,.40);
      font-family: var(--mono);
      font-size: 13px;
      color: #f3f6ff;
      overflow:auto;
      flex: 1 1 430px;
      min-width: 240px;
    }
    .btn{
      border:1px solid rgba(143,177,255,.22);
      background: rgba(143,177,255,.10);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      cursor:pointer;
      font-weight:600;
      font-size: 13px;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{transform: translateY(-1px); background: rgba(143,177,255,.14); border-color: rgba(143,177,255,.34);}
    .btn:active{transform: translateY(0px) scale(.99);}
    .btn.small{padding:8px 10px; border-radius: 10px; font-size: 12px;}
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size: 12px;
      color: var(--muted);
      margin-left:8px;
    }
    .kbd{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      color: var(--text);
    }
    figure{
      margin:0;
      padding: 12px;
      border-top:1px solid rgba(143,177,255,.12);
      background: rgba(7,10,20,.18);
    }
    .figGrid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap: 12px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .figGrid{grid-template-columns:1fr}
    }
    canvas{
      width:100%;
      height: 360px;
      display:block;
      border-radius: 16px;
      border:1px solid rgba(143,177,255,.18);
      background: rgba(0,0,0,.18);
    }
    .plotCard{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .controls{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 10px;
      align-items:center;
      padding: 10px 12px;
      border-radius: 16px;
      border:1px solid rgba(143,177,255,.16);
      background: rgba(12,20,48,.45);
    }
    @media (max-width: 720px){
      .controls{grid-template-columns:1fr}
      canvas{height: 320px}
    }
    label{font-size: 13px; color: var(--muted)}
    input[type="range"]{width:100%}
    select{
      width:100%;
      border-radius: 12px;
      border:1px solid rgba(143,177,255,.18);
      background: rgba(7,10,20,.40);
      color: var(--text);
      padding: 10px 10px;
      font-weight:600;
    }
    .readout{
      font-family: var(--mono);
      font-size: 12px;
      color: #f3f6ff;
      opacity:.92;
      margin-top:6px;
      display:flex;
      flex-wrap:wrap;
      gap: 10px;
    }
    .readout span{
      padding: 4px 8px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
    }
    .box{
      border-left: 3px solid rgba(124,255,178,.70);
      background: rgba(124,255,178,.07);
      border-radius: 14px;
      padding: 10px 12px;
      margin: 10px 0;
    }
    .box.warn{
      border-left-color: rgba(255,211,124,.85);
      background: rgba(255,211,124,.08);
    }
    .box.bad{
      border-left-color: rgba(255,124,124,.85);
      background: rgba(255,124,124,.08);
    }
    .box strong{color: var(--text)}
    .muted{color: var(--muted)}
    .hr{
      height:1px;
      background: rgba(143,177,255,.14);
      margin: 12px 0;
    }
    footer{
      max-width:1180px;
      margin: 0 auto 26px;
      padding: 0 clamp(18px, 3vw, 34px);
      color: var(--faint);
      font-size: 12px;
    }
    .fadeIn{
      animation: fadeIn .55s ease both;
    }
    @keyframes fadeIn{
      from{opacity:0; transform: translateY(6px)}
      to{opacity:1; transform: translateY(0)}
    }
    @media print{
      body{background:#fff; color:#000}
      section, .titleCard, .toc{box-shadow:none}
      .toc{display:none}
      canvas{border:1px solid #999}
      a{color:#000; text-decoration:underline}
      .btn{display:none}
      pre.eq{border:1px solid #999; background:#f6f6f6; color:#000}
      section{break-inside:avoid; page-break-inside:avoid}
    }
  </style>
</head>
<body>
  <header class="fadeIn">
    <div class="hero">
      <div class="titleCard">
        <h1>Refraction at the Brewster Angle (TM / p-polarization)</h1>
        <p class="subtitle">
          Derive the Brewster angle from two conditions, prove reflected &amp; refracted rays are perpendicular at Brewster,
          and connect the geometry to the “no TM reflection” physical picture — with live-updating diagrams and plots.
        </p>
        <div class="meta">
          <span class="pill"><b>Topic</b> Fresnel coefficients • polarization • refraction</span>
          <span class="pill"><b>Key result</b> θ<sub>B</sub> = arctan(n₂/n₁)</span>
          <span class="pill"><b>Mode</b> TM (p) → no reflection at θ<sub>B</sub></span>
        </div>
      </div>

      <nav class="toc" aria-label="Table of Contents">
        <h2>On this page</h2>
        <a href="#quick" data-scroll>Quick Summary</a>
        <a href="#part0" data-scroll>PART 0 — Concept Primer</a>
        <a href="#part1" data-scroll>PART 1 — Problem Analysis</a>
        <a href="#part2" data-scroll>PART 2 — Strategy & Tips</a>
        <a href="#part3" data-scroll>PART 3 — Full Solution</a>
        <a href="#part4" data-scroll>PART 4 — Deeper Understanding</a>
        <a href="#part5" data-scroll>PART 5 — Visualization Guide</a>
        <a href="#viz" data-scroll>Interactive Visualizations</a>
      </nav>
    </div>
  </header>

  <main>
    <!-- Quick Summary -->
    <section id="quick" class="fadeIn">
      <header><h2>Quick Summary</h2></header>
      <div class="content">
        <ul>
          <li>This problem is about the <b>Brewster angle</b>: the incidence angle where <b>TM (p-polarized)</b> reflection vanishes at an interface.</li>
          <li>Key physics idea: <b>boundary conditions</b> (Fresnel reflection) + <b>Snell’s law</b> imply a special geometry where the reflected and refracted rays become <b>orthogonal</b>.</li>
          <li>Given conditions:
            <span class="muted">n₁ secθ₁ = n₂ secθ₂</span> and Snell:
            <span class="muted">n₁ sinθ₁ = n₂ sinθ₂</span>.
          </li>
          <li>Core derivations:
            <b>(i)</b> show θ₁ + θ₂ = 90° at Brewster, then <b>(ii)</b> obtain θ<sub>B</sub> = arctan(n₂/n₁).</li>
          <li>Final result type: <b>symbolic</b> (closed-form angle). Numerical examples are used <b>only for plotting</b>.</li>
          <li>Physical interpretation: at θ<sub>B</sub>, the induced “source” (dipole-like) oscillation is aligned with the reflected ray direction, so it cannot radiate into that direction → <b>no TM reflected wave</b>.</li>
        </ul>

        <div class="eqRow">
          <pre class="eq" id="eqKey1">Given (Brewster condition form):
n1 sec(θ1) = n2 sec(θ2)
⇔ n2 cos(θ1) = n1 cos(θ2)</pre>
          <button class="btn" data-copy="#eqKey1">Copy</button>
        </div>

        <div class="eqRow">
          <pre class="eq" id="eqKey2">Snell's law:
n1 sin(θ1) = n2 sin(θ2)</pre>
          <button class="btn" data-copy="#eqKey2">Copy</button>
        </div>

        <div class="eqRow">
          <pre class="eq" id="eqFinalShort">Final result (TM Brewster angle):
θB = arctan(n2/n1)
and at θ1 = θB:  θ1 + θ2 = 90°  (reflected ⟂ refracted)</pre>
          <button class="btn" data-copy="#eqFinalShort">Copy final answer</button>
        </div>
      </div>
    </section>

    <!-- PART 0 -->
    <section id="part0" class="fadeIn">
      <header><h2>PART 0 — Concept Primer (Theory Before Solving)</h2></header>
      <div class="content">
        <div class="grid2">
          <div class="callout">
            <h3>Core definitions (symbols & units)</h3>
            <ul>
              <li><b>n₁, n₂</b> — refractive indices (dimensionless) of medium 1 (incident side) and medium 2 (transmitted side).</li>
              <li><b>θ₁</b> — incidence angle (degrees or radians), measured from the surface normal in medium 1.</li>
              <li><b>θ₂</b> — refraction (transmission) angle in medium 2, measured from the normal.</li>
              <li><b>TM (p-polarization)</b> — electric field in the <b>plane of incidence</b> (the plane containing incident ray and the normal).</li>
              <li><b>Fresnel reflection coefficient</b> <span class="muted">r</span> — complex amplitude ratio (reflected/incident). Reflectance is <span class="muted">R = |r|²</span> (dimensionless power fraction).</li>
            </ul>
          </div>

          <div class="callout">
            <h3>Physical meaning (what these quantities “mean”)</h3>
            <ul>
              <li><b>θ₁, θ₂</b> encode the ray directions. They are constrained because the interface enforces phase matching along the boundary.</li>
              <li><b>n</b> sets wave speed: <span class="muted">v = c/n</span> and wavelength in medium: <span class="muted">λ = λ₀/n</span>.</li>
              <li><b>TM vs TE</b> matters because boundary conditions treat tangential <span class="muted">E</span> and <span class="muted">H</span> differently; hence reflection depends on polarization.</li>
              <li><b>Brewster angle</b> is the unique θ₁ where <b>TM reflected amplitude is zero</b> (so R<sub>TM</sub>=0).</li>
            </ul>
          </div>
        </div>

        <div class="hr"></div>

        <div class="grid2">
          <div class="callout">
            <h3>Key laws & validity (assumptions behind them)</h3>
            <ul>
              <li><b>Snell’s law</b> (planar interface, homogeneous isotropic media):
                <span class="muted">n₁ sinθ₁ = n₂ sinθ₂</span>.
              </li>
              <li><b>Fresnel equations</b> (linear media, steady-state monochromatic plane waves, no surface currents/charges beyond polarization response).</li>
              <li><b>Non-magnetic media</b> (typical optics): μ₁≈μ₂≈μ₀, so indices capture the main contrast. (This is the usual context for the classic Brewster formula.)</li>
            </ul>
            <div class="box">
              <strong>Why Brewster exists (intuition):</strong>
              TM polarization forces the electric field to have a component along the boundary. At a special angle, the boundary-driven reradiation cancels the TM reflected wave completely.
            </div>
          </div>

          <div class="callout">
            <h3>Common models / approximations (and why)</h3>
            <ul>
              <li><b>Plane-wave model:</b> locally, many beams can be decomposed into plane waves; Fresnel coefficients apply to each angular component.</li>
              <li><b>Lossless real indices</b> for clean Brewster zero. With absorption (complex n), the “zero” becomes a minimum.</li>
              <li><b>Single interface</b> (no thin-film multiple reflections). Brewster in multilayers can shift due to interference.</li>
            </ul>
            <div class="box warn">
              <strong>What to watch for:</strong>
              Angles are measured from the <b>normal</b>, and θ₂ is set by Snell — it is not independent.
            </div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="grid2">
          <div class="callout">
            <h3>Mini intuition examples (no long algebra)</h3>
            <ul>
              <li><b>If n₂ &gt; n₁</b> (air → glass), the Brewster angle is fairly large (often ~50–60°), and reflected light becomes strongly <b>TE-polarized</b>.</li>
              <li><b>If n₂ = n₁</b>, there is no interface: reflection is zero for all angles; Brewster becomes trivial.</li>
            </ul>
          </div>

          <div class="callout">
            <h3>Typical pitfalls & misconceptions</h3>
            <ul>
              <li>Confusing <b>TE/ TM</b> definitions: TM means <b>E in plane of incidence</b>.</li>
              <li>Thinking “no reflection” holds for all polarizations: it is <b>only TM</b> at Brewster (in the usual non-magnetic case).</li>
              <li>Mixing angle conventions (from surface vs from normal).</li>
              <li>Forgetting that total internal reflection (TIR) can occur when n₁ &gt; n₂ at large θ₁; then θ₂ becomes complex.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <!-- PART 1 -->
    <section id="part1" class="fadeIn">
      <header><h2>PART 1 — Problem Analysis (No Solving Yet)</h2></header>
      <div class="content">
        <div class="callout">
          <h3>Problem restatement (in plain words)</h3>
          <p>
            You are given two relations for a plane wave refracting at an interface:
            <span class="muted">n₁ secθ₁ = n₂ secθ₂</span> and Snell’s law <span class="muted">n₁ sinθ₁ = n₂ sinθ₂</span>.
            Using these, (1) derive the Brewster-angle formula <span class="muted">θ<sub>B</sub> = arctan(n₂/n₁)</span>.
            Then (2) show that at Brewster, <span class="muted">θ₁ + θ₂ = 90°</span>, meaning the reflected and refracted rays are perpendicular,
            and explain the polarization geometry argument for why <b>no TM light is reflected</b>.
          </p>
        </div>

        <div class="grid2">
          <div class="callout">
            <h3>Given quantities</h3>
            <ul>
              <li>n₁, n₂ (refractive indices, real and positive in the standard lossless case)</li>
              <li>Snell’s law relation between θ₁ and θ₂</li>
              <li>Extra Brewster-condition relation: n₁ secθ₁ = n₂ secθ₂</li>
            </ul>
          </div>
          <div class="callout">
            <h3>Unknowns / what must be shown</h3>
            <ul>
              <li>Derive <b>Brewster incidence angle</b> θ<sub>B</sub> in terms of n₁, n₂</li>
              <li>Prove at Brewster: <b>θ₁ + θ₂ = 90°</b></li>
              <li>Explain the <b>orthogonality</b> and <b>field alignment</b> argument for TM → no reflection</li>
            </ul>
          </div>
        </div>

        <div class="hr"></div>

        <div class="grid2">
          <div class="callout">
            <h3>Relevant principles (and why they apply)</h3>
            <ul>
              <li><b>Snell’s law</b> applies because tangential phase matching must hold at a planar interface for plane waves.</li>
              <li><b>The condition n₁ secθ₁ = n₂ secθ₂</b> is equivalent to the Fresnel TM “zero-reflection” requirement:
                it encodes the angle where the TM reflection numerator vanishes.
              </li>
              <li><b>Geometric ray directions</b>: reflection angle equals incidence angle (specular reflection), so reflected ray makes angle θ₁ with the normal.</li>
            </ul>
          </div>

          <div class="callout">
            <h3>Assumptions (explicit)</h3>
            <ul>
              <li>Two homogeneous, isotropic, linear media with a flat interface.</li>
              <li>Monochromatic plane wave; steady-state (time-harmonic).</li>
              <li>Standard optics case: μ₁≈μ₂ (non-magnetic); indices are real for a perfect Brewster zero.</li>
              <li>Angles θ₁, θ₂ measured from the interface normal.</li>
            </ul>
          </div>
        </div>

        <div class="hr"></div>

        <div class="callout">
          <h3>Possible approaches (compare)</h3>
          <ul>
            <li><b>Approach A (given equations only):</b> Combine the two provided relations cleverly (e.g., divide them) to infer θ₁+θ₂=90°, then plug into Snell to get tanθ<sub>B</sub>=n₂/n₁. <span class="muted">Pros:</span> shortest, matches the problem statement. <span class="muted">Cons:</span> relies on a trig identity step that must be justified carefully.</li>
            <li><b>Approach B (Fresnel derivation):</b> Start from the TM Fresnel coefficient
              <span class="muted">r<sub>TM</sub> = (n₂ cosθ₁ − n₁ cosθ₂)/(n₂ cosθ₁ + n₁ cosθ₂)</span>, set numerator to zero, then use Snell. <span class="muted">Pros:</span> physically transparent. <span class="muted">Cons:</span> uses a formula not explicitly given (though standard).</li>
            <li><b>Approach C (vector wave impedance view):</b> Use wave impedances and boundary matching of tangential fields to derive the Brewster condition. <span class="muted">Pros:</span> deep EM insight. <span class="muted">Cons:</span> longer than needed here.</li>
          </ul>
          <div class="box">
            <strong>Chosen approach:</strong> Approach A (because the problem explicitly instructs using the two given relations), with a short cross-check via Fresnel coefficients for interpretation.
          </div>
        </div>
      </div>
    </section>

    <!-- PART 2 -->
    <section id="part2" class="fadeIn">
      <header><h2>PART 2 — Strategy & Tips (Roadmap Only)</h2></header>
      <div class="content">
        <ol>
          <li><b>Goal:</b> Rewrite the “sec” condition in a more usable cosine form.
            <br><span class="muted">Tool:</span> secθ = 1/cosθ.
            <br><span class="muted">Meaning:</span> It becomes a relation between direction cosines of incident and transmitted rays.
          </li>
          <li><b>Goal:</b> Divide Snell’s law by the cosine-form condition.
            <br><span class="muted">Tool:</span> Algebraic division to eliminate n’s.
            <br><span class="muted">Meaning:</span> You get a purely geometric condition involving products sinθ cosθ.
          </li>
          <li><b>Goal:</b> Convert sinθ cosθ into sin(2θ).
            <br><span class="muted">Tool:</span> sin(2θ)=2sinθcosθ.
            <br><span class="muted">Meaning:</span> Compare sin(2θ₁) and sin(2θ₂) to infer angle relations.
          </li>
          <li><b>Goal:</b> Select the physically relevant solution (θ₁+θ₂=90°).
            <br><span class="muted">Tool:</span> Analyze allowed angle ranges (0–90°) and nontrivial interface (n₁≠n₂).
            <br><span class="muted">Meaning:</span> This proves reflected and refracted rays are perpendicular at Brewster.
          </li>
          <li><b>Goal:</b> Insert θ₂ = 90° − θ₁ into Snell’s law.
            <br><span class="muted">Tool:</span> sin(90°−θ)=cosθ.
            <br><span class="muted">Meaning:</span> Derive tanθ₁ = n₂/n₁ → θ₁=θ<sub>B</sub>.
          </li>
          <li><b>Goal:</b> Connect to TM polarization geometry (why reflection vanishes).
            <br><span class="muted">Tool:</span> Plane-of-incidence polarization picture + perpendicular ray geometry.
            <br><span class="muted">Meaning:</span> The refracted TM electric field aligns parallel to reflected propagation direction, so it cannot radiate into that direction.
          </li>
        </ol>

        <div class="grid2">
          <div class="box warn">
            <strong>Common mistakes</strong>
            <ul>
              <li>Picking the wrong trig solution when sin(2θ₁)=sin(2θ₂).</li>
              <li>Forgetting θ₁ and θ₂ are measured from the <b>normal</b>.</li>
              <li>Claiming “no reflection” for TE too (it’s not true here).</li>
            </ul>
          </div>
          <div class="box">
            <strong>Quick tips</strong>
            <ul>
              <li>Keep θ’s in (0°,90°) for ordinary refraction; use that to choose the correct branch.</li>
              <li>After obtaining θ<sub>B</sub>, do a sanity check: if n₂ &gt; n₁ then θ<sub>B</sub> should be &gt; 45°.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <!-- PART 3 -->
    <section id="part3" class="fadeIn">
      <header><h2>PART 3 — Full Solution (Detailed + Teaching)</h2></header>
      <div class="content">
        <div class="callout">
          <h3>Physical intuition before math</h3>
          <p>
            For TM polarization, the electric field lies in the plane of incidence. The interface induces oscillating polarization currents in medium 2
            that reradiate (scatter) into reflected and transmitted directions. At one special incidence angle, the geometry makes the TM reradiation
            unable to send energy back along the reflected direction, so the TM reflected amplitude must vanish. That special angle is the <b>Brewster angle</b>.
          </p>
        </div>

        <div class="hr"></div>

        <article class="callout">
          <h3>Step 1 — Rewrite the given “sec” condition</h3>
          <p>
            We are given:
          </p>
          <div class="eqRow">
            <pre class="eq" id="eqS1a">n1 sec(θ1) = n2 sec(θ2)</pre>
            <button class="btn small" data-copy="#eqS1a">Copy</button>
          </div>
          <p>
            Using <span class="muted">secθ = 1/cosθ</span>, this becomes
          </p>
          <div class="eqRow">
            <pre class="eq" id="eqS1b">n1 / cos(θ1) = n2 / cos(θ2)
⇒ n2 cos(θ1) = n1 cos(θ2)</pre>
            <button class="btn small" data-copy="#eqS1b">Copy</button>
          </div>
          <p class="muted">
            Meaning: this is exactly the classic TM Brewster condition written as a cosine relation.
          </p>
        </article>

        <article class="callout">
          <h3>Step 2 — Divide Snell’s law by the cosine relation</h3>
          <p>
            Snell’s law is:
          </p>
          <div class="eqRow">
            <pre class="eq" id="eqS2a">n1 sin(θ1) = n2 sin(θ2)</pre>
            <button class="btn small" data-copy="#eqS2a">Copy</button>
          </div>

          <p>
            Divide Snell’s law by the cosine relation <span class="muted">n2 cos(θ1) = n1 cos(θ2)</span>.
            (This is safe for angles not exactly 90°, where cos ≠ 0.)
          </p>
          <div class="eqRow">
            <pre class="eq" id="eqS2b">(n1 sin(θ1)) / (n2 cos(θ1)) = (n2 sin(θ2)) / (n1 cos(θ2))
But using the two equalities, n1/n2 cancels n2/n1, giving:
sin(θ1) cos(θ1) = sin(θ2) cos(θ2)</pre>
            <button class="btn small" data-copy="#eqS2b">Copy</button>
          </div>
          <p>
            Now use the double-angle identity <span class="muted">sin(2θ)=2sinθcosθ</span>:
          </p>
          <div class="eqRow">
            <pre class="eq" id="eqS2c">sin(θ1)cos(θ1) = sin(θ2)cos(θ2)
⇒ sin(2θ1) = sin(2θ2)</pre>
            <button class="btn small" data-copy="#eqS2c">Copy</button>
          </div>
          <p class="muted">
            Meaning: the Brewster condition enforces a special symmetry between the incidence and refraction angles.
          </p>
        </article>

        <article class="callout">
          <h3>Step 3 — Solve sin(2θ₁) = sin(2θ₂) and pick the physical branch</h3>
          <p>
            The equation <span class="muted">sin A = sin B</span> implies two families of solutions:
          </p>
          <div class="eqRow">
            <pre class="eq" id="eqS3a">A = B + 2kπ  OR  A = (π − B) + 2kπ</pre>
            <button class="btn small" data-copy="#eqS3a">Copy</button>
          </div>
          <p>
            Here, <span class="muted">A = 2θ1</span> and <span class="muted">B = 2θ2</span>.
            For ordinary refraction, θ₁ and θ₂ lie between 0° and 90°, so 2θ₁ and 2θ₂ lie between 0° and 180°.
            Within that interval, the two relevant options are:
          </p>
          <div class="eqRow">
            <pre class="eq" id="eqS3b">Option 1: 2θ1 = 2θ2  ⇒ θ1 = θ2
Option 2: 2θ1 = 180° − 2θ2 ⇒ θ1 + θ2 = 90°</pre>
            <button class="btn small" data-copy="#eqS3b">Copy</button>
          </div>
          <p>
            Which one is Brewster? If θ₁ = θ₂, then Snell’s law gives <span class="muted">n₁ = n₂</span> (a trivial “no interface” case).
            For a genuine interface with <span class="muted">n₁ ≠ n₂</span>, we must choose:
          </p>
          <div class="box">
            <strong>At Brewster:</strong> <span class="muted">θ1 + θ2 = 90°</span>.
            <br/>So the reflected ray (at angle θ₁) is perpendicular to the refracted ray (at angle θ₂).
          </div>

          <p class="muted">
            This completes the first requested proof: <b>at Brewster, reflected and refracted directions are orthogonal</b>.
          </p>
        </article>

        <article class="callout">
          <h3>Step 4 — Use θ₂ = 90° − θ₁ in Snell’s law to get θ<sub>B</sub></h3>
          <p>
            Insert <span class="muted">θ2 = 90° − θ1</span> into Snell’s law:
          </p>
          <div class="eqRow">
            <pre class="eq" id="eqS4a">n1 sin(θ1) = n2 sin(θ2)
= n2 sin(90° − θ1) = n2 cos(θ1)</pre>
            <button class="btn small" data-copy="#eqS4a">Copy</button>
          </div>
          <p>
            Therefore:
          </p>
          <div class="eqRow">
            <pre class="eq" id="eqS4b">n1 sin(θ1) = n2 cos(θ1)
⇒ tan(θ1) = n2 / n1</pre>
            <button class="btn small" data-copy="#eqS4b">Copy</button>
          </div>
          <p>
            At Brewster, θ₁ = θ<sub>B</sub>. Hence:
          </p>
          <div class="eqRow">
            <pre class="eq" id="eqS4c">θB = arctan(n2/n1)</pre>
            <button class="btn small" data-copy="#eqS4c">Copy</button>
          </div>

          <div class="box">
            <strong>Final Answer (boxed):</strong>
            <div class="eqRow" style="margin-top:8px">
              <pre class="eq" id="eqFinalBox">Brewster angle for TM (p polarization):
θB = arctan(n2/n1)

At θ1 = θB:
θ1 + θ2 = 90°  (reflected ray ⟂ refracted ray)</pre>
              <button class="btn" data-copy="#eqFinalBox">Copy</button>
            </div>
          </div>
        </article>

        <article class="callout">
          <h3>Step 5 — Why “no TM reflection” follows (orthogonality + field geometry)</h3>
          <p>
            At Brewster we proved <span class="muted">θ1 + θ2 = 90°</span>, so the reflected and refracted propagation directions are perpendicular.
            Now recall what TM means: the electric field lies in the plane of incidence and is perpendicular to its own propagation direction.
          </p>
          <p>
            In medium 2 (refracted wave), the TM electric field <b>E<sub>TM,trans</sub></b> is perpendicular to the refracted ray direction.
            But if the refracted ray is perpendicular to the reflected ray direction, then the line perpendicular to the refracted ray is
            <b>parallel to the reflected ray</b>. Therefore:
          </p>
          <div class="eqRow">
            <pre class="eq" id="eqGeom">At Brewster (θ1 + θ2 = 90°):
E_TM (transmitted) ⟂ k_trans
and k_trans ⟂ k_reflected
⇒ E_TM (transmitted) ∥ k_reflected</pre>
            <button class="btn small" data-copy="#eqGeom">Copy</button>
          </div>
          <p>
            The problem’s “scattering-source” picture says: the refracted wave (through induced polarization in medium 2) acts as a source that radiates the reflected wave.
            At Brewster, that source oscillation is aligned with the reflected direction, so it cannot radiate into that direction (a dipole does not radiate along its axis).
            Consequently, the TM reflected wave amplitude must be zero.
          </p>
          <div class="box warn">
            <strong>Sanity checks</strong>
            <ul>
              <li><b>Units:</b> n₂/n₁ is dimensionless, so arctan(n₂/n₁) is an angle — consistent.</li>
              <li><b>Limiting case n₂=n₁:</b> θ<sub>B</sub>=arctan(1)=45°, but the interface disappears so reflection is zero anyway (not a special angle).</li>
              <li><b>If n₂ &gt; n₁:</b> ratio &gt; 1 → θ<sub>B</sub> &gt; 45° (matches typical air→glass Brewster angles).</li>
            </ul>
          </div>
          <p class="muted">
            Connection to plots below: you will see R<sub>TM</sub>(θ₁) cross zero exactly at θ<sub>B</sub>, and the diagram will show the right-angle geometry.
          </p>
        </article>

        <article class="callout">
          <h3>Cross-check (optional): Fresnel TM coefficient gives the same condition</h3>
          <p>
            For non-magnetic media, the TM (p) Fresnel reflection amplitude is
          </p>
          <div class="eqRow">
            <pre class="eq" id="eqFresnel">r_TM = (n2 cosθ1 − n1 cosθ2) / (n2 cosθ1 + n1 cosθ2)</pre>
            <button class="btn small" data-copy="#eqFresnel">Copy</button>
          </div>
          <p>
            Setting <span class="muted">r<sub>TM</sub>=0</span> requires the numerator to vanish:
            <span class="muted">n₂ cosθ₁ = n₁ cosθ₂</span>, which is exactly the cosine form of the given condition.
          </p>
        </article>
      </div>
    </section>

    <!-- PART 4 -->
    <section id="part4" class="fadeIn">
      <header><h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2></header>
      <div class="content">
        <div class="grid2">
          <div class="callout">
            <h3>Reinterpreting θB = arctan(n2/n1)</h3>
            <ul>
              <li>The Brewster angle depends only on the <b>index ratio</b> <span class="muted">n₂/n₁</span>, not on wavelength (in this idealized model).</li>
              <li>As <span class="muted">n₂/n₁</span> increases, θ<sub>B</sub> increases and approaches 90° slowly (arctan grows and saturates).</li>
              <li>At Brewster, the interface makes TM matching “perfect” in the sense that the boundary-driven reradiation cancels the backward TM wave.</li>
            </ul>
            <div class="box">
              <strong>What each term controls:</strong>
              <br>n₂/n₁ controls the <b>tilt</b> needed so that refraction angle becomes the complement of incidence angle.
            </div>
          </div>

          <div class="callout">
            <h3>Parameter effects (connect to interactive plots)</h3>
            <ul>
              <li>Increase <b>n₂</b> (keeping n₁ fixed): the zero in R<sub>TM</sub>(θ₁) shifts to <b>larger θ₁</b>.</li>
              <li>Choose a typical pair (example for plotting): n₁=1.00 (air), n₂≈1.50 (glass) → θ<sub>B</sub>≈56.3°.</li>
              <li>If n₁ &gt; n₂, the critical angle appears; beyond it, θ₂ is not real (TIR). Brewster still emerges from the formula, but interpret with care near TIR regimes.</li>
            </ul>
          </div>
        </div>

        <div class="hr"></div>

        <div class="callout">
          <h3>Alternative derivation idea (brief)</h3>
          <p>
            Instead of using the given “sec” condition, you can start from boundary conditions:
            continuity of tangential <span class="muted">E</span> and <span class="muted">H</span> at the interface.
            Solving the resulting linear system yields Fresnel coefficients; setting the TM reflection coefficient numerator to zero
            immediately gives <span class="muted">n₂ cosθ₁ = n₁ cosθ₂</span>. Snell’s law then produces <span class="muted">θB = arctan(n₂/n₁)</span>.
          </p>
        </div>

        <div class="grid2">
          <div class="callout">
            <h3>Concept checks (with answers)</h3>
            <ul>
              <li><b>Q:</b> Which polarization has zero reflection at Brewster for ordinary dielectrics?
                <br><b>A:</b> <b>TM (p)</b>, where E lies in the plane of incidence.</li>
              <li><b>Q:</b> What geometric relationship holds between reflected and refracted rays at Brewster?
                <br><b>A:</b> They are <b>perpendicular</b>: θ₁ + θ₂ = 90°.</li>
              <li><b>Q:</b> If n₂/n₁ increases, what happens to θ<sub>B</sub>?
                <br><b>A:</b> θ<sub>B</sub> increases (arctan grows).</li>
              <li><b>Q:</b> Does Brewster guarantee no reflection for TE?
                <br><b>A:</b> No. TE generally reflects nonzero power at that angle.</li>
            </ul>
          </div>

          <div class="callout">
            <h3>Common mistakes (again, because they matter)</h3>
            <ul>
              <li>Using θ measured from the surface instead of the normal.</li>
              <li>Forgetting to restrict to physical angles when solving sin(2θ₁)=sin(2θ₂).</li>
              <li>Mixing up “reflected ray ⟂ refracted ray” with “E ⟂ H” (different perpendicularities).</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <!-- PART 5 -->
    <section id="part5" class="fadeIn">
      <header><h2>PART 5 — Visualization Guide (How to Read the Plots)</h2></header>
      <div class="content">
        <div class="grid2">
          <div class="callout">
            <h3>Canvas 1: Geometry diagram</h3>
            <ul>
              <li>Shows a flat interface, normal, and rays: incident, reflected, refracted.</li>
              <li>Angles θ₁ and θ₂ are measured from the normal.</li>
              <li>At Brewster, a right-angle marker appears between reflected and refracted directions.</li>
              <li>Also shows a short arrow illustrating that for TM at Brewster, <span class="muted">E<sub>TM,trans</sub></span> is parallel to the reflected direction.</li>
            </ul>
          </div>
          <div class="callout">
            <h3>Canvas 2: Main quantitative plot</h3>
            <ul>
              <li>Plots <b>R<sub>TM</sub>(θ₁)</b> and (for comparison) <b>R<sub>TE</sub>(θ₁)</b> vs incidence angle.</li>
              <li>The <b>TM curve hits zero</b> at θ₁=θ<sub>B</sub>.</li>
              <li>Vertical marker shows θ<sub>B</sub> for the current indices.</li>
            </ul>
          </div>
        </div>

        <div class="grid2" style="margin-top:14px">
          <div class="callout">
            <h3>Canvas 3: Parameter-sweep plot</h3>
            <ul>
              <li>Plots <b>θ<sub>B</sub></b> versus <b>index ratio</b> n₂/n₁ over a range.</li>
              <li>Your current ratio is highlighted as a point on the curve.</li>
              <li>This directly visualizes how changing n₂ or n₁ shifts the Brewster angle.</li>
            </ul>
          </div>
          <div class="callout">
            <h3>Interactive controls</h3>
            <ul>
              <li><b>Material preset</b> sets example indices (for quick exploration).</li>
              <li><b>n₁ and n₂ sliders</b> update: diagram angles, R(θ₁) curves, and the θ<sub>B</sub> sweep point — all live.</li>
              <li>Readouts show θ<sub>B</sub>, θ₂ at Brewster, and whether TIR occurs for parts of the scan.</li>
            </ul>
            <div class="box warn">
              <strong>Note:</strong> Plot values are computed from standard Fresnel formulas for <b>lossless, non-magnetic</b> media (example model).
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Visualizations -->
    <section id="viz" class="fadeIn">
      <header><h2>Interactive Visualizations</h2></header>
      <figure>
        <div class="figGrid">
          <div class="plotCard">
            <div class="controls">
              <div>
                <label for="preset">Example preset (for plotting)</label>
                <select id="preset">
                  <option value="custom" selected>Custom (use sliders)</option>
                  <option value="air_glass">Air → Glass (n1=1.00, n2=1.50)</option>
                  <option value="air_water">Air → Water (n1=1.00, n2=1.33)</option>
                  <option value="glass_air">Glass → Air (n1=1.50, n2=1.00)</option>
                  <option value="air_diamond">Air → Diamond (n1=1.00, n2=2.42)</option>
                </select>
                <div class="readout" id="readout">
                  <!-- populated by JS -->
                </div>
              </div>
              <div>
                <button class="btn" id="btnReset">Reset view</button>
                <div class="badge"><span class="kbd">Tip</span> Drag sliders → updates all canvases</div>
              </div>
            </div>

            <div class="controls">
              <div>
                <label for="n1">n₁ (incident medium index)</label>
                <input id="n1" type="range" min="1.00" max="2.20" step="0.01" value="1.00" />
                <div class="muted" style="font-size:12px;margin-top:4px">Range: 1.00 → 2.20 (example)</div>
              </div>
              <div>
                <label for="n2">n₂ (transmitted medium index)</label>
                <input id="n2" type="range" min="1.00" max="2.60" step="0.01" value="1.50" />
                <div class="muted" style="font-size:12px;margin-top:4px">Range: 1.00 → 2.60 (example)</div>
              </div>
            </div>

            <canvas id="canvasDiagram" aria-label="Refraction geometry diagram"></canvas>
          </div>

          <div class="plotCard">
            <canvas id="canvasMainPlot" aria-label="Reflectance vs incidence angle plot"></canvas>
            <canvas id="canvasSweepPlot" aria-label="Brewster angle vs index ratio sweep plot"></canvas>
          </div>
        </div>
      </figure>
    </section>
  </main>

  <footer>
    <div class="muted">
      Built for learning: theory → analysis → strategy → full derivation → interpretation, with interactive geometry and Fresnel-based plots (lossless, non-magnetic example model).
    </div>
  </footer>

  <script>
    // ---------- helpers ----------
    const TAU = Math.PI * 2;
    const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
    const deg2rad = d => d*Math.PI/180;
    const rad2deg = r => r*180/Math.PI;

    function copyText(text){
      if(!navigator.clipboard){
        // fallback
        const t = document.createElement('textarea');
        t.value = text;
        document.body.appendChild(t);
        t.select();
        try{ document.execCommand('copy'); }catch(e){}
        document.body.removeChild(t);
        return;
      }
      navigator.clipboard.writeText(text).catch(()=>{});
    }

    // smooth scroll for toc links
    document.querySelectorAll('[data-scroll]').forEach(a=>{
      a.addEventListener('click', (e)=>{
        e.preventDefault();
        const id = a.getAttribute('href');
        const el = document.querySelector(id);
        if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
      });
    });

    // copy buttons
    document.querySelectorAll('[data-copy]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const sel = btn.getAttribute('data-copy');
        const el = document.querySelector(sel);
        if(!el) return;
        const txt = el.textContent.replace(/\u00a0/g,' ').trim();
        copyText(txt);
        const old = btn.textContent;
        btn.textContent = 'Copied ✓';
        setTimeout(()=>btn.textContent=old, 800);
      });
    });

    // ---------- physics ----------
    // Snell: n1 sinθ1 = n2 sinθ2, return θ2 in radians or NaN if TIR
    function theta2FromTheta1(theta1, n1, n2){
      const s2 = (n1/n2)*Math.sin(theta1);
      if(s2>1) return NaN;
      if(s2<-1) return NaN;
      return Math.asin(s2);
    }

    // Fresnel coefficients (non-magnetic, lossless, real indices)
    // TE (s): r_s = (n1 cosθ1 - n2 cosθ2)/(n1 cosθ1 + n2 cosθ2)
    // TM (p): r_p = (n2 cosθ1 - n1 cosθ2)/(n2 cosθ1 + n1 cosθ2)
    function fresnel(n1,n2,theta1){
      const t2 = theta2FromTheta1(theta1,n1,n2);
      if(!isFinite(t2)) return {tir:true, rs:NaN, rp:NaN, Rs:NaN, Rp:NaN, theta2:NaN};
      const c1 = Math.cos(theta1);
      const c2 = Math.cos(t2);
      const rs = (n1*c1 - n2*c2)/(n1*c1 + n2*c2);
      const rp = (n2*c1 - n1*c2)/(n2*c1 + n1*c2);
      return {tir:false, rs, rp, Rs: rs*rs, Rp: rp*rp, theta2:t2};
    }

    function brewsterAngle(n1,n2){
      // θB = arctan(n2/n1) (in radians)
      return Math.atan2(n2, n1);
    }

    // ---------- plotting primitives ----------
    function setupCanvas(canvas){
      const ctx = canvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(260, rect.width);
      const h = Math.max(260, rect.height);
      canvas.width = Math.round(w*dpr);
      canvas.height = Math.round(h*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {ctx, w, h, dpr};
    }

    function clear(ctx,w,h){
      ctx.clearRect(0,0,w,h);
      // subtle background gradient overlay
      const g = ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0,'rgba(255,255,255,0.03)');
      g.addColorStop(1,'rgba(255,255,255,0.00)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);
    }

    function drawTitle(ctx, title, x, y){
      ctx.save();
      ctx.fillStyle = 'rgba(234,240,255,0.95)';
      ctx.font = '700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(title, x, y);
      ctx.restore();
    }

    function drawAxes(ctx, box, xLabel, yLabel, xTicks, yTicks){
      // box: {x,y,w,h}
      const {x,y,w,h} = box;
      ctx.save();
      ctx.strokeStyle = 'rgba(143,177,255,0.25)';
      ctx.lineWidth = 1;

      // border
      ctx.strokeRect(x,y,w,h);

      // gridlines + ticks
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.fillStyle = 'rgba(234,240,255,0.85)';

      // vertical grid & x ticks
      xTicks.forEach(t=>{
        const px = x + t.p*w;
        ctx.strokeStyle = 'rgba(143,177,255,0.14)';
        ctx.beginPath();
        ctx.moveTo(px,y);
        ctx.lineTo(px,y+h);
        ctx.stroke();

        ctx.strokeStyle = 'rgba(143,177,255,0.35)';
        ctx.beginPath();
        ctx.moveTo(px,y+h);
        ctx.lineTo(px,y+h+6);
        ctx.stroke();

        const txt = t.label;
        const tw = ctx.measureText(txt).width;
        ctx.fillText(txt, px - tw/2, y+h+18);
      });

      // horizontal grid & y ticks
      yTicks.forEach(t=>{
        const py = y + (1-t.p)*h;
        ctx.strokeStyle = 'rgba(143,177,255,0.14)';
        ctx.beginPath();
        ctx.moveTo(x,py);
        ctx.lineTo(x+w,py);
        ctx.stroke();

        ctx.strokeStyle = 'rgba(143,177,255,0.35)';
        ctx.beginPath();
        ctx.moveTo(x-6,py);
        ctx.lineTo(x,py);
        ctx.stroke();

        const txt = t.label;
        const tw = ctx.measureText(txt).width;
        ctx.fillText(txt, x - tw - 10, py + 4);
      });

      // labels
      ctx.fillStyle = 'rgba(183,195,255,0.90)';
      ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(xLabel, x + w - ctx.measureText(xLabel).width, y + h + 36);

      ctx.save();
      ctx.translate(x-46, y+12);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();

      ctx.restore();
    }

    function mapToBox(box, xMin,xMax,yMin,yMax, xVal,yVal){
      const px = box.x + (xVal-xMin)/(xMax-xMin)*box.w;
      const py = box.y + (1-(yVal-yMin)/(yMax-yMin))*box.h;
      return {px,py};
    }

    function drawLine(ctx, pts, strokeStyle, lineWidth=2){
      ctx.save();
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = lineWidth;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.beginPath();
      for(let i=0;i<pts.length;i++){
        const p=pts[i];
        if(i===0) ctx.moveTo(p.x,p.y);
        else ctx.lineTo(p.x,p.y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawLegend(ctx, items, x, y){
      ctx.save();
      ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      let dy=0;
      items.forEach(it=>{
        ctx.fillStyle = it.color;
        ctx.fillRect(x, y+dy-9, 14, 3);
        ctx.fillStyle = 'rgba(234,240,255,0.90)';
        ctx.fillText(it.label, x+20, y+dy-4);
        dy += 18;
      });
      ctx.restore();
    }

    // ---------- diagram ----------
    function drawDiagram(canvas, state){
      const {ctx,w,h} = setupCanvas(canvas);
      clear(ctx,w,h);

      drawTitle(ctx, 'Geometry: incident / reflected / refracted rays (angles from normal)', 14, 22);

      const padL=54, padR=18, padT=34, padB=18;
      const cx = (padL + (w-padR))/2;
      const cy = (padT + (h-padB))/2 + 20;

      // interface line
      ctx.save();
      ctx.strokeStyle = 'rgba(143,177,255,0.40)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padL, cy);
      ctx.lineTo(w-padR, cy);
      ctx.stroke();

      // normal
      ctx.strokeStyle = 'rgba(183,195,255,0.55)';
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(cx, padT);
      ctx.lineTo(cx, h-padB);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();

      // labels for media
      ctx.save();
      ctx.fillStyle = 'rgba(183,195,255,0.85)';
      ctx.font = '700 12px ui-sans-serif, system-ui';
      ctx.fillText(`Medium 1 (n₁=${state.n1.toFixed(2)})`, padL+6, cy-10);
      ctx.fillText(`Medium 2 (n₂=${state.n2.toFixed(2)})`, padL+6, cy+18);
      ctx.restore();

      // pick an incidence angle to illustrate: use Brewster if valid, else 45°
      let th1 = state.thetaB;
      if(!(th1>0 && th1<Math.PI/2)) th1 = deg2rad(45);

      const th2 = theta2FromTheta1(th1, state.n1, state.n2);

      // ray lengths
      const L1 = Math.min(w,h)*0.35;
      const L2 = Math.min(w,h)*0.33;

      function arrow(x1,y1,x2,y2,color){
        const dx=x2-x1, dy=y2-y1;
        const len = Math.hypot(dx,dy) || 1;
        const ux=dx/len, uy=dy/len;
        const ah=10, aw=6;
        ctx.save();
        ctx.strokeStyle=color;
        ctx.lineWidth=2.5;
        ctx.lineCap='round';
        ctx.beginPath();
        ctx.moveTo(x1,y1);
        ctx.lineTo(x2,y2);
        ctx.stroke();
        // head
        ctx.fillStyle=color;
        ctx.beginPath();
        ctx.moveTo(x2,y2);
        ctx.lineTo(x2 - ah*ux + aw*(-uy), y2 - ah*uy + aw*(ux));
        ctx.lineTo(x2 - ah*ux - aw*(-uy), y2 - ah*uy - aw*(ux));
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      // incident ray: coming from above left to interface point (cx,cy)
      const incDir = {x: Math.sin(th1), y: Math.cos(th1)}; // direction away from interface into medium1 along ray. We need reverse for incoming
      const xi = cx - incDir.x*L1;
      const yi = cy - incDir.y*L1;
      arrow(xi, yi, cx, cy, 'rgba(143,177,255,0.95)');

      // reflected ray: leaves interface into medium1 above right with angle th1
      const xr = cx + incDir.x*L1;
      const yr = cy - incDir.y*L1;
      arrow(cx, cy, xr, yr, 'rgba(255,211,124,0.95)');

      // refracted ray: into medium2 downward right with angle th2 from normal
      let hasTIR = !isFinite(th2);
      if(!hasTIR){
        const trDir = {x: Math.sin(th2), y: Math.cos(th2)};
        const xt = cx + trDir.x*L2;
        const yt = cy + trDir.y*L2;
        arrow(cx, cy, xt, yt, 'rgba(124,255,178,0.95)');

        // right-angle marker between reflected and transmitted at Brewster
        // (only show if using Brewster illustrative angle)
        if(Math.abs(th1 - state.thetaB) < deg2rad(0.5) && state.thetaB>0 && state.thetaB<Math.PI/2){
          // draw small square at interface, rotated
          const s=18;
          // use unit vectors along reflected and transmitted
          const ur = {x: incDir.x, y: -incDir.y}; // reflected direction from interface
          const ut = {x: trDir.x, y: trDir.y};    // transmitted direction from interface
          // corner points
          const p0 = {x: cx + 10*0, y: cy + 10*0};
          const p1 = {x: cx + ur.x*s, y: cy + ur.y*s};
          const p2 = {x: p1.x + ut.x*s, y: p1.y + ut.y*s};
          const p3 = {x: cx + ut.x*s, y: cy + ut.y*s};

          ctx.save();
          ctx.strokeStyle = 'rgba(234,240,255,0.7)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p0.x,p0.y);
          ctx.lineTo(p1.x,p1.y);
          ctx.lineTo(p2.x,p2.y);
          ctx.lineTo(p3.x,p3.y);
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }

        // indicate TM transmitted E direction: perpendicular to transmitted k (within plane), so rotate ut by +90° in plane
        const eDir = {x: ut.y, y: -ut.x}; // rotate by -90° (still in canvas plane)
        // scale and draw from a point on transmitted ray
        const ex0 = cx + ut.x*L2*0.55;
        const ey0 = cy + ut.y*L2*0.55;
        const ex1 = ex0 + eDir.x*34;
        const ey1 = ey0 + eDir.y*34;

        arrow(ex0, ey0, ex1, ey1, 'rgba(178,143,255,0.95)');

        ctx.save();
        ctx.fillStyle = 'rgba(178,143,255,0.92)';
        ctx.font = '700 12px ui-sans-serif, system-ui';
        ctx.fillText('E_TM (trans)', ex1 + 6, ey1 + 4);
        ctx.restore();

        // show that at Brewster E_TM (trans) ∥ reflected direction
        if(Math.abs(th1 - state.thetaB) < deg2rad(0.5)){
          ctx.save();
          ctx.fillStyle = 'rgba(183,195,255,0.85)';
          ctx.font = '600 12px ui-sans-serif, system-ui';
          ctx.fillText('At Brewster: k_ref ⟂ k_trans and E_TM ⟂ k_trans ⇒ E_TM ∥ k_ref', padL, padT+18);
          ctx.restore();
        }

        // angle arcs
        drawAngleArc(ctx, cx, cy, th1, true, 'θ₁', 'rgba(143,177,255,0.9)');
        drawAngleArc(ctx, cx, cy, th2, false, 'θ₂', 'rgba(124,255,178,0.9)');

      } else {
        // TIR warning
        ctx.save();
        ctx.fillStyle = 'rgba(255,124,124,0.92)';
        ctx.font = '700 12px ui-sans-serif, system-ui';
        ctx.fillText('TIR: θ₂ not real for this θ₁ in the scan', padL, padT+18);
        ctx.restore();
        // still draw a "grazing" transmitted hint
      }

      // annotate ray labels
      ctx.save();
      ctx.font = '700 12px ui-sans-serif, system-ui';
      ctx.fillStyle = 'rgba(143,177,255,0.95)';
      ctx.fillText('Incident', xi-10, yi-8);
      ctx.fillStyle = 'rgba(255,211,124,0.95)';
      ctx.fillText('Reflected', xr-10, yr-8);
      if(!hasTIR){
        ctx.fillStyle = 'rgba(124,255,178,0.95)';
        const trDir = {x: Math.sin(th2), y: Math.cos(th2)};
        ctx.fillText('Refracted', cx + trDir.x*L2 - 8, cy + trDir.y*L2 + 16);
      }
      ctx.restore();
    }

    function drawAngleArc(ctx, cx, cy, theta, isUpper, label, color){
      // theta from normal; draw arc between normal and ray
      const r = 46;
      const start = -Math.PI/2; // normal upwards in canvas coords
      const end = start + (isUpper ? theta : -theta);
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, r, Math.min(start,end), Math.max(start,end), false);
      ctx.stroke();

      // label
      const mid = (start+end)/2;
      const lx = cx + Math.cos(mid)*(r+14);
      const ly = cy + Math.sin(mid)*(r+14);
      ctx.fillStyle = 'rgba(234,240,255,0.92)';
      ctx.font = '700 12px ui-sans-serif, system-ui';
      ctx.fillText(label, lx-8, ly+4);
      ctx.restore();
    }

    // ---------- main plot ----------
    function drawMainPlot(canvas, state){
      const {ctx,w,h} = setupCanvas(canvas);
      clear(ctx,w,h);
      drawTitle(ctx, 'Main plot: Reflectance vs incidence angle (example Fresnel model)', 14, 22);

      const box = {x:64, y:42, w: w-84, h: h-88};

      const xMin=0, xMax=90;
      const yMin=0, yMax=1;

      // ticks
      const xTicks=[];
      for(let d=0; d<=90; d+=15) xTicks.push({p:(d-xMin)/(xMax-xMin), label:`${d}°`});
      const yTicks=[];
      for(let v=0; v<=1.0001; v+=0.25) yTicks.push({p:(v-yMin)/(yMax-yMin), label: v.toFixed(2)});

      drawAxes(ctx, box, 'θ₁ (deg)', 'Reflectance R (unitless)', xTicks, yTicks);

      // curves
      const ptsTM=[], ptsTE=[];
      let hadTIR=false;

      for(let d=0; d<=90; d+=0.5){
        const th1 = deg2rad(d);
        const fr = fresnel(state.n1, state.n2, th1);
        if(fr.tir){
          hadTIR=true;
          continue;
        }
        const pTM = mapToBox(box, xMin,xMax,yMin,yMax, d, clamp(fr.Rp,0,1));
        const pTE = mapToBox(box, xMin,xMax,yMin,yMax, d, clamp(fr.Rs,0,1));
        ptsTM.push({x:pTM.px, y:pTM.py});
        ptsTE.push({x:pTE.px, y:pTE.py});
      }

      drawLine(ctx, ptsTM, 'rgba(124,255,178,0.95)', 2.6);
      drawLine(ctx, ptsTE, 'rgba(255,211,124,0.90)', 2.2);

      // Brewster marker
      const thBdeg = rad2deg(state.thetaB);
      if(isFinite(thBdeg)){
        const xB = clamp(thBdeg, 0, 90);
        const p0 = mapToBox(box, xMin,xMax,yMin,yMax, xB, 0);
        ctx.save();
        ctx.strokeStyle = 'rgba(178,143,255,0.95)';
        ctx.lineWidth = 2;
        ctx.setLineDash([6,6]);
        ctx.beginPath();
        ctx.moveTo(p0.px, box.y);
        ctx.lineTo(p0.px, box.y+box.h);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = 'rgba(178,143,255,0.92)';
        ctx.font = '700 12px ui-sans-serif, system-ui';
        ctx.fillText(`θB ≈ ${xB.toFixed(2)}°`, p0.px + 6, box.y + 18);
        ctx.restore();
      }

      // legend
      drawLegend(ctx, [
        {label:'TM (p): R_TM = |r_TM|²', color:'rgba(124,255,178,0.95)'},
        {label:'TE (s): R_TE = |r_TE|²', color:'rgba(255,211,124,0.90)'},
        {label:'Brewster marker', color:'rgba(178,143,255,0.95)'},
      ], box.x + 10, box.y + 22);

      // note about TIR
      if(hadTIR){
        ctx.save();
        ctx.fillStyle = 'rgba(255,124,124,0.90)';
        ctx.font = '700 12px ui-sans-serif, system-ui';
        ctx.fillText('Note: Some θ₁ lead to TIR (θ₂ not real); those points are omitted.', box.x+10, box.y+box.h-10);
        ctx.restore();
      }
    }

    // ---------- sweep plot ----------
    function drawSweepPlot(canvas, state){
      const {ctx,w,h} = setupCanvas(canvas);
      clear(ctx,w,h);
      drawTitle(ctx, 'Secondary plot: Brewster angle θB vs index ratio (n₂/n₁)', 14, 22);

      const box = {x:64, y:42, w: w-84, h: h-88};

      const rMin = 0.6, rMax = 2.8;
      const yMin = 0, yMax = 85; // degrees

      const xTicks=[];
      for(let r=0.6; r<=2.8001; r+=0.4){
        xTicks.push({p:(r-rMin)/(rMax-rMin), label:r.toFixed(1)});
      }
      const yTicks=[];
      for(let a=0; a<=85; a+=17){
        yTicks.push({p:(a-yMin)/(yMax-yMin), label:`${a}°`});
      }

      drawAxes(ctx, box, 'index ratio n₂/n₁ (unitless)', 'θB (deg)', xTicks, yTicks);

      // curve θB(r) = arctan(r)
      const pts=[];
      for(let r=rMin; r<=rMax+1e-9; r+=0.01){
        const th = rad2deg(Math.atan(r));
        const p = mapToBox(box, rMin,rMax,yMin,yMax, r, th);
        pts.push({x:p.px, y:p.py});
      }
      drawLine(ctx, pts, 'rgba(143,177,255,0.95)', 2.6);

      // current point
      const ratio = state.n2/state.n1;
      const thBdeg = rad2deg(state.thetaB);
      if(isFinite(ratio) && isFinite(thBdeg)){
        const rr = clamp(ratio, rMin, rMax);
        const aa = clamp(thBdeg, yMin, yMax);
        const p = mapToBox(box, rMin,rMax,yMin,yMax, rr, aa);
        ctx.save();
        ctx.fillStyle = 'rgba(124,255,178,0.95)';
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(p.px, p.py, 6, 0, TAU);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = 'rgba(234,240,255,0.92)';
        ctx.font = '700 12px ui-sans-serif, system-ui';
        ctx.fillText(`(n₂/n₁=${ratio.toFixed(2)}, θB≈${thBdeg.toFixed(2)}°)`, p.px+10, p.py-10);
        ctx.restore();
      }

      drawLegend(ctx, [
        {label:'θB = arctan(n₂/n₁)', color:'rgba(143,177,255,0.95)'},
        {label:'current parameters', color:'rgba(124,255,178,0.95)'}
      ], box.x + 10, box.y + 22);
    }

    // ---------- state + UI ----------
    const els = {
      preset: document.getElementById('preset'),
      n1: document.getElementById('n1'),
      n2: document.getElementById('n2'),
      readout: document.getElementById('readout'),
      btnReset: document.getElementById('btnReset'),
      cDiag: document.getElementById('canvasDiagram'),
      cMain: document.getElementById('canvasMainPlot'),
      cSweep: document.getElementById('canvasSweepPlot'),
    };

    const defaultState = { n1: 1.00, n2: 1.50 };
    let state = { ...defaultState, thetaB: brewsterAngle(defaultState.n1, defaultState.n2) };

    function setSlidersFromState(){
      els.n1.value = state.n1.toFixed(2);
      els.n2.value = state.n2.toFixed(2);
    }

    function updateReadout(){
      const thB = state.thetaB;
      const thBdeg = rad2deg(thB);
      const th2B = theta2FromTheta1(thB, state.n1, state.n2);
      const th2Bdeg = isFinite(th2B) ? rad2deg(th2B) : NaN;

      // check orthogonality if both finite
      let ortho = '';
      if(isFinite(th2Bdeg) && isFinite(thBdeg)){
        ortho = (thBdeg + th2Bdeg).toFixed(2) + '°';
      } else {
        ortho = '—';
      }

      // critical angle (if n1>n2)
      let crit = '—';
      if(state.n1 > state.n2){
        const sc = state.n2/state.n1;
        if(sc<=1){
          crit = rad2deg(Math.asin(sc)).toFixed(2) + '°';
        }
      }

      els.readout.innerHTML = `
        <span>n₁=${state.n1.toFixed(2)}</span>
        <span>n₂=${state.n2.toFixed(2)}</span>
        <span>n₂/n₁=${(state.n2/state.n1).toFixed(3)}</span>
        <span>θB≈${isFinite(thBdeg)?thBdeg.toFixed(2):'—'}°</span>
        <span>θ₂(at θB)≈${isFinite(th2Bdeg)?th2Bdeg.toFixed(2):'—'}°</span>
        <span>θB+θ₂≈${ortho}</span>
        <span>θc (if n₁&gt;n₂)=${crit}</span>
      `;
    }

    function renderAll(){
      state.thetaB = brewsterAngle(state.n1, state.n2);
      updateReadout();
      drawDiagram(els.cDiag, state);
      drawMainPlot(els.cMain, state);
      drawSweepPlot(els.cSweep, state);
    }

    function setPreset(name){
      if(name==='air_glass'){ state.n1=1.00; state.n2=1.50; }
      else if(name==='air_water'){ state.n1=1.00; state.n2=1.33; }
      else if(name==='glass_air'){ state.n1=1.50; state.n2=1.00; }
      else if(name==='air_diamond'){ state.n1=1.00; state.n2=2.42; }
      // custom -> do nothing
      setSlidersFromState();
      renderAll();
    }

    // events
    els.preset.addEventListener('change', ()=>{
      const v = els.preset.value;
      if(v==='custom'){ renderAll(); return; }
      setPreset(v);
      els.preset.value = 'custom'; // allow further manual edits without switching again
    });

    function onSlider(){
      state.n1 = parseFloat(els.n1.value);
      state.n2 = parseFloat(els.n2.value);
      renderAll();
    }
    els.n1.addEventListener('input', onSlider);
    els.n2.addEventListener('input', onSlider);

    els.btnReset.addEventListener('click', ()=>{
      state = { ...defaultState, thetaB: brewsterAngle(defaultState.n1, defaultState.n2) };
      els.preset.value = 'custom';
      setSlidersFromState();
      renderAll();
    });

    // resize handling
    let resizeTimer=null;
    window.addEventListener('resize', ()=>{
      clearTimeout(resizeTimer);
      resizeTimer=setTimeout(()=>renderAll(), 80);
    });

    // initial
    setSlidersFromState();
    renderAll();
  </script>
</body>
</html>
