<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Reflection of Circularly Polarized Light — Why a Mirror Flips Handedness</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:rgba(255,255,255,0.06);
      --panel2:rgba(255,255,255,0.09);
      --text:rgba(255,255,255,0.92);
      --muted:rgba(255,255,255,0.72);
      --faint:rgba(255,255,255,0.55);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,0.14);
      --shadow:0 12px 30px rgba(0,0,0,0.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(125,211,252,0.16), transparent 60%),
        radial-gradient(900px 700px at 85% 20%, rgba(167,139,250,0.16), transparent 55%),
        radial-gradient(1100px 900px at 55% 85%, rgba(52,211,153,0.10), transparent 60%),
        linear-gradient(180deg, #070a14 0%, #0b1020 35%, #070a14 100%);
      min-height:100vh;
    }

    header{
      padding:28px 18px 10px;
      border-bottom:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,0.06), transparent);
    }
    .wrap{max-width:1120px;margin:0 auto}
    .title{
      display:grid;
      gap:10px;
      align-items:start;
    }
    h1{
      margin:0;
      font-weight:800;
      letter-spacing:-0.02em;
      line-height:1.05;
      font-size:clamp(1.7rem, 2.6vw, 2.5rem);
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      line-height:1.45;
      max-width:78ch;
      font-size:clamp(0.98rem, 1.35vw, 1.08rem);
    }

    main{
      padding:18px 18px 48px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }

    aside.toc{
      position:sticky;
      top:14px;
      align-self:start;
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:14px;
      padding:14px 14px 10px;
      box-shadow:var(--shadow);
      backdrop-filter: blur(10px);
    }
    .toc h2{
      font-size:0.95rem;
      margin:0 0 10px;
      color:var(--text);
      letter-spacing:0.02em;
      text-transform:uppercase;
      opacity:0.9;
    }
    .toc a{
      display:block;
      padding:8px 10px;
      margin:2px 0;
      border-radius:10px;
      color:var(--muted);
      text-decoration:none;
      border:1px solid transparent;
      transition:transform 140ms ease, background 140ms ease, border-color 140ms ease;
      font-size:0.95rem;
      line-height:1.25;
    }
    .toc a:hover{
      background:rgba(255,255,255,0.06);
      border-color:rgba(255,255,255,0.14);
      color:var(--text);
      transform:translateY(-1px);
    }

    section{
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:16px;
      padding:18px 16px;
      box-shadow:var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    section + section{margin-top:18px}

    h2{
      margin:0 0 12px;
      font-size:1.25rem;
      letter-spacing:-0.01em;
    }
    h3{
      margin:16px 0 10px;
      font-size:1.05rem;
      color:var(--text);
    }
    p{margin:10px 0;color:var(--muted);line-height:1.65}
    ul{margin:10px 0 10px 20px;color:var(--muted);line-height:1.6}
    li{margin:6px 0}
    .kicker{
      display:inline-flex;
      gap:8px;
      align-items:center;
      color:var(--muted);
      font-size:0.93rem;
      margin-bottom:8px;
    }
    .chip{
      display:inline-block;
      padding:3px 9px;
      border-radius:999px;
      background:rgba(125,211,252,0.14);
      border:1px solid rgba(125,211,252,0.26);
      color:rgba(230,248,255,0.92);
      font-size:0.84rem;
      font-weight:600;
    }

    .cards{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:12px;
      margin-top:10px;
    }
    .card{
      grid-column: span 12;
      background:rgba(255,255,255,0.05);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:14px;
      padding:12px 12px;
    }
    @media (min-width: 840px){
      .card.half{grid-column: span 6}
      .card.third{grid-column: span 4}
    }

    .callout{
      border-left:4px solid rgba(125,211,252,0.7);
      background:rgba(125,211,252,0.08);
      padding:12px 12px;
      border-radius:12px;
      margin:12px 0;
    }
    .callout.warn{
      border-left-color:rgba(251,191,36,0.8);
      background:rgba(251,191,36,0.09);
    }
    .callout.good{
      border-left-color:rgba(52,211,153,0.8);
      background:rgba(52,211,153,0.09);
    }
    .callout.bad{
      border-left-color:rgba(251,113,133,0.8);
      background:rgba(251,113,133,0.09);
    }

    .eq{
      font-family:var(--mono);
      background:rgba(0,0,0,0.25);
      border:1px solid rgba(255,255,255,0.14);
      border-radius:12px;
      padding:12px 12px;
      overflow:auto;
      position:relative;
      margin:10px 0;
    }
    .eq .label{
      color:rgba(255,255,255,0.72);
      font-family:var(--sans);
      font-size:0.88rem;
      margin-bottom:8px;
      display:flex;
      gap:8px;
      align-items:center;
    }
    .copyBtn{
      position:absolute;
      top:10px;
      right:10px;
      border:1px solid rgba(255,255,255,0.16);
      background:rgba(255,255,255,0.06);
      color:var(--text);
      border-radius:10px;
      padding:6px 10px;
      cursor:pointer;
      font-size:0.85rem;
      transition:transform 120ms ease, background 120ms ease, border-color 120ms ease;
      user-select:none;
    }
    .copyBtn:hover{
      transform:translateY(-1px);
      background:rgba(255,255,255,0.10);
      border-color:rgba(255,255,255,0.22);
    }
    .copyToast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform:translateX(-50%);
      background:rgba(0,0,0,0.68);
      border:1px solid rgba(255,255,255,0.18);
      color:rgba(255,255,255,0.92);
      padding:10px 12px;
      border-radius:999px;
      box-shadow:var(--shadow);
      opacity:0;
      pointer-events:none;
      transition:opacity 180ms ease, transform 180ms ease;
      z-index:99;
      font-size:0.92rem;
      backdrop-filter: blur(10px);
    }
    .copyToast.show{
      opacity:1;
      transform:translateX(-50%) translateY(-2px);
    }

    figure{
      margin:10px 0;
      background:rgba(0,0,0,0.22);
      border:1px solid rgba(255,255,255,0.14);
      border-radius:14px;
      padding:10px;
    }
    figcaption{
      margin-top:8px;
      color:var(--faint);
      font-size:0.92rem;
      line-height:1.45;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius:12px;
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width:720px){
      .controls{grid-template-columns:1fr}
    }
    .control{
      background:rgba(255,255,255,0.05);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:14px;
      padding:10px 12px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:12px;
      color:var(--muted);
      font-size:0.92rem;
      margin-bottom:8px;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    select, button{
      width:100%;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.16);
      background:rgba(255,255,255,0.07);
      color:var(--text);
      padding:10px 10px;
      font-size:0.95rem;
    }
    button{
      cursor:pointer;
      transition:transform 120ms ease, background 120ms ease;
    }
    button:hover{transform:translateY(-1px); background:rgba(255,255,255,0.10)}
    .mini{
      font-size:0.92rem;
      color:var(--faint);
      margin-top:6px;
      line-height:1.45;
    }

    .hr{
      height:1px;
      background:linear-gradient(90deg, transparent, rgba(255,255,255,0.18), transparent);
      margin:14px 0;
    }

    footer{
      padding:18px 18px 34px;
      color:var(--faint);
      border-top:1px solid var(--line);
    }

    @media print{
      body{background:white;color:black}
      header, footer{border:none}
      section, aside.toc, figure{box-shadow:none; backdrop-filter:none}
      section, aside.toc{background:white;border:1px solid #ddd}
      .copyBtn, .controls, .copyToast{display:none !important}
      a{color:black}
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap title">
      <div class="kicker">
        <span class="chip">Polarization</span>
        <span class="chip">Reflection</span>
        <span class="chip">Jones & Stokes</span>
      </div>
      <h1>6.1–10 — Reflection of Circularly Polarized Light: Why a Mirror Flips Handedness</h1>
      <p class="subtitle">
        We prove (carefully and conceptually) that <em>circularly polarized light reverses handedness</em>
        upon reflection from an ideal mirror. The key idea is that reflection reverses the propagation direction
        <span style="font-family:var(--mono)">k</span>, so the “right/left” label—defined <em>relative to the direction of propagation</em>—must flip.
      </p>
    </div>
  </header>

  <main>
    <div class="wrap grid">
      <article>
        <!-- Quick Summary -->
        <section id="quick">
          <h2>Quick Summary</h2>
          <ul>
            <li><strong>What this is about:</strong> Show that a mirror reflection turns Right-Circular Polarization (RCP) into Left-Circular Polarization (LCP), and vice versa.</li>
            <li><strong>Key physics idea:</strong> “Handedness” is defined with respect to the wave’s propagation direction. A mirror reverses that direction.</li>
            <li><strong>Governing description:</strong> Represent polarization with a complex transverse field (Jones vector) and/or Stokes parameter <span style="font-family:var(--mono)">S3</span> (helicity / circularity).</li>
            <li><strong>Mirror model (ideal):</strong> At normal incidence from a perfect conductor, both transverse components reflect with the same factor <span style="font-family:var(--mono)">r = -1</span> (a global phase), so the <em>shape</em> of the polarization ellipse in lab <span style="font-family:var(--mono)">x–y</span> is unchanged.</li>
            <li><strong>Where the flip comes from:</strong> Even if the Jones vector is unchanged up to a global phase, the propagation direction changes <span style="font-family:var(--mono)">+z → −z</span>, so the same transverse rotation corresponds to opposite handedness.</li>
            <li><strong>Compact result:</strong> <span style="font-family:var(--mono)">helicity_out = − helicity_in</span> for reflection from a mirror.</li>
            <li><strong>Final result type:</strong> Symbolic proof (with quantitative plots using example parameter sweeps).</li>
          </ul>

          <div class="eq" data-copy="RCP/LCP basis (for propagation +z):
e_R = (x̂ + i ŷ)/√2,   e_L = (x̂ − i ŷ)/√2.
Reflection reverses k: +z → −z, so handedness swaps: RCP ↔ LCP.">
            <div class="label">Key statement to copy</div>
            <button class="copyBtn" aria-label="Copy key statement">Copy</button>
            <div>
              <span style="font-family:var(--mono)">e<sub>R</sub> = (x̂ + i ŷ)/√2</span>,
              <span style="font-family:var(--mono)">e<sub>L</sub> = (x̂ − i ŷ)/√2</span> (for propagation <span style="font-family:var(--mono)">+z</span>).<br/>
              Mirror reflection reverses <span style="font-family:var(--mono)">k</span>, therefore <strong>RCP ↔ LCP</strong>.
            </div>
          </div>
        </section>

        <!-- PART 0 -->
        <section id="primer">
          <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

          <div class="cards">
            <div class="card half">
              <h3>Core definitions (symbols + meaning)</h3>
              <ul>
                <li><strong>Monochromatic plane wave</strong> (complex form):<br/>
                  <span style="font-family:var(--mono)">E(r,t) = Re{ Ẽ exp[i(k·r − ωt)] }</span></li>
                <li><strong>Transverse field</strong> (for propagation along <span style="font-family:var(--mono)">±z</span>):<br/>
                  <span style="font-family:var(--mono)">Ẽ = Ẽx x̂ + Ẽy ŷ</span> (units: V/m)</li>
                <li><strong>Jones vector</strong> (polarization state):<br/>
                  <span style="font-family:var(--mono)">J = (Ẽx, Ẽy)^T</span> (complex, up to a global phase)</li>
                <li><strong>Stokes circularity</strong> (normalized):<br/>
                  <span style="font-family:var(--mono)">s3 = S3/S0 ∈ [−1, +1]</span> where <span style="font-family:var(--mono)">s3=+1</span> is one circular handedness, <span style="font-family:var(--mono)">s3=−1</span> the other.</li>
              </ul>
            </div>

            <div class="card half">
              <h3>Physical meaning: “handedness” is relative</h3>
              <p>
                Circular polarization means the tip of the electric field vector rotates at constant magnitude in the plane transverse to propagation.
                The label “right” vs “left” is defined by the rotation sense <em>as seen by an observer looking along the propagation direction</em>.
              </p>
              <div class="callout">
                <strong>Crucial point:</strong> if you reverse the propagation direction, “clockwise” and “counterclockwise” swap because your viewing direction flips.
              </div>
            </div>

            <div class="card half">
              <h3>Key laws / principles (validity conditions)</h3>
              <ul>
                <li><strong>Boundary condition at an ideal conductor:</strong> tangential electric field at the surface is zero:
                  <span style="font-family:var(--mono)">E_t(z=0) = 0</span>.</li>
                <li>For normal incidence on a perfect conductor, this gives <strong>reflection coefficient</strong>
                  <span style="font-family:var(--mono)">r = −1</span> for both transverse components (same magnitude, same phase).</li>
                <li><strong>Linearity:</strong> reflection acts linearly on field components (Jones calculus applies).</li>
                <li><strong>Monochromatic steady-state:</strong> using complex amplitudes assumes single-frequency or narrowband behavior.</li>
              </ul>
            </div>

            <div class="card half">
              <h3>Common models / approximations (and why)</h3>
              <ul>
                <li><strong>Ideal mirror:</strong> treat as perfect conductor → cleanest proof: reflection adds only a global phase.</li>
                <li><strong>Plane wave:</strong> makes polarization definitions unambiguous and separates propagation direction from transverse rotation.</li>
                <li><strong>Jones/Stokes formalism:</strong> compactly encodes amplitude ratios and phase differences that determine ellipse shape and handedness.</li>
              </ul>
            </div>

            <div class="card third">
              <h3>Mini intuition example 1</h3>
              <p>
                Imagine a rotating arrow on a transparent sheet.
                If you look at the sheet from the opposite side, the arrow appears to rotate in the opposite sense.
                A mirror reflection effectively changes the direction from which the wave is “viewed” along propagation.
              </p>
            </div>
            <div class="card third">
              <h3>Mini intuition example 2</h3>
              <p>
                Helicity is the “spin along the direction of motion”:
                <span style="font-family:var(--mono)">h ∝ S·k̂</span>. If the wave’s <span style="font-family:var(--mono)">k̂</span> reverses under reflection,
                <span style="font-family:var(--mono)">h</span> must change sign (handedness flips).
              </p>
            </div>
            <div class="card third">
              <h3>What to watch for (pitfalls)</h3>
              <ul>
                <li>Mixing conventions: optics vs IEEE definitions of RCP/LCP. Always state your viewpoint rule.</li>
                <li>Confusing “Jones vector unchanged” with “handedness unchanged” (handedness depends on propagation direction).</li>
                <li>At oblique incidence or non-ideal mirrors, <span style="font-family:var(--mono)">r_s</span> and <span style="font-family:var(--mono)">r_p</span> may differ in phase → ellipse can change. The mirror flip result is still about reversing <span style="font-family:var(--mono)">k</span>.</li>
              </ul>
            </div>
          </div>

          <div class="eq" data-copy="Normalized Stokes parameters from Jones components:
S0 = |Ex|^2 + |Ey|^2
S3 = 2 Im(Ex Ey*)
s3 = S3/S0

For reflection from an ideal mirror at normal incidence:
J_out = r J_in with r = −1 (global phase), but k flips ⇒ helicity flips sign.">
            <div class="label">Equations you will use (copyable)</div>
            <button class="copyBtn" aria-label="Copy equations">Copy</button>
            <div style="white-space:pre-wrap; font-family:var(--mono); line-height:1.35">
S0 = |Ex|^2 + |Ey|^2
S3 = 2 Im(Ex Ey*)
s3 = S3/S0

Ideal mirror (normal incidence): J_out = r J_in,  r = −1 (global phase)
Reflection reverses k ⇒ handedness / helicity flips sign.
            </div>
          </div>
        </section>

        <!-- PART 1 -->
        <section id="analysis">
          <h2>PART 1 — Problem Analysis (No solving yet)</h2>

          <h3>Restate the problem (in plain words)</h3>
          <p>
            A circularly polarized plane wave hits a mirror and reflects. Prove that the reflected wave has the <em>opposite</em>
            circular handedness: right-circular becomes left-circular, and left-circular becomes right-circular.
          </p>

          <div class="cards">
            <div class="card half">
              <h3>Given</h3>
              <ul>
                <li>A mirror (ideal reflector; we will model it as a perfect conductor).</li>
                <li>An incident circularly polarized wave (RCP or LCP).</li>
                <li>We will use a simple geometry: normal incidence onto a planar mirror.</li>
              </ul>
            </div>
            <div class="card half">
              <h3>Unknown / what must be shown</h3>
              <ul>
                <li>Show mathematically that the reflected field corresponds to opposite handedness.</li>
                <li>Equivalently: show the “circular Stokes parameter” (helicity) changes sign.</li>
              </ul>
            </div>
          </div>

          <h3>Relevant principles (and why they apply)</h3>
          <ul>
            <li><strong>Electromagnetic boundary conditions:</strong> For an ideal conductor, the tangential electric field must vanish at the surface → determines the reflected field amplitude and phase.</li>
            <li><strong>Polarization definition:</strong> RCP/LCP are defined by rotation sense of <span style="font-family:var(--mono)">E</span> as viewed along the propagation direction.</li>
            <li><strong>Why not use something else?</strong> We don’t need energy or intensity arguments (those don’t encode handedness). We also don’t need full vector Maxwell solving in space—plane-wave + boundary conditions suffice.</li>
          </ul>

          <div class="callout warn">
            <strong>Assumptions (explicit):</strong>
            <ul style="margin:8px 0 0 20px">
              <li>Planar mirror at <span style="font-family:var(--mono)">z=0</span>, perfect conductor (ideal mirror).</li>
              <li>Normal incidence (wavevector along <span style="font-family:var(--mono)">+z</span> for the incident wave).</li>
              <li>Monochromatic plane wave; linear medium in front of mirror (vacuum/air).</li>
              <li>We label handedness using the rule “rotation sense as seen looking along the direction of propagation”.</li>
            </ul>
          </div>

          <h3>Possible solution approaches (compare)</h3>
          <div class="cards">
            <div class="card third">
              <h3>Approach A: Direct time-domain rotation</h3>
              <p>
                Write <span style="font-family:var(--mono)">E_x(t), E_y(t)</span> explicitly, apply reflection, then decide rotation sense for the reflected propagation direction.
              </p>
              <p class="mini"><strong>Pros:</strong> Very intuitive. <strong>Cons:</strong> Easy to mess up the viewing direction convention.</p>
            </div>
            <div class="card third">
              <h3>Approach B: Jones + Stokes (s3)</h3>
              <p>
                Use <span style="font-family:var(--mono)">S3 ∝ Im(Ex Ey*)</span> and track how “handedness” depends on the sign relative to <span style="font-family:var(--mono)">k</span>.
              </p>
              <p class="mini"><strong>Pros:</strong> Compact and quantitative. <strong>Cons:</strong> Must explain why <span style="font-family:var(--mono)">k</span> reversal flips helicity.</p>
            </div>
            <div class="card third">
              <h3>Approach C: Helicity argument</h3>
              <p>
                Use angular momentum: helicity <span style="font-family:var(--mono)">h ∝ S·k̂</span> changes sign when <span style="font-family:var(--mono)">k̂</span> flips.
              </p>
              <p class="mini"><strong>Pros:</strong> Deep and elegant. <strong>Cons:</strong> Abstract if you haven’t seen helicity.</p>
            </div>
          </div>

          <p>
            <strong>We will choose Approach B (Jones + Stokes)</strong> because it is both rigorous and directly connects to
            the interactive plots (we will plot <span style="font-family:var(--mono)">s3</span> and helicity sign changes).
            We will also add intuition from Approach A so the result is not just algebra.
          </p>
        </section>

        <!-- PART 2 -->
        <section id="strategy">
          <h2>PART 2 — Strategy & Tips (Roadmap only)</h2>

          <ol style="margin:10px 0 10px 20px; color:var(--muted); line-height:1.65">
            <li><strong>Goal:</strong> Define circular polarization precisely for a wave traveling along <span style="font-family:var(--mono)">+z</span>.<br/>
              <span style="color:var(--faint)">Tool:</span> Jones basis vectors <span style="font-family:var(--mono)">e_R, e_L</span>.</li>
            <li><strong>Goal:</strong> Write the incident field in complex form.<br/>
              <span style="color:var(--faint)">Tool:</span> <span style="font-family:var(--mono)">Ẽ exp[i(kz − ωt)]</span>.</li>
            <li><strong>Goal:</strong> Apply mirror boundary conditions to get the reflected field amplitude and phase.<br/>
              <span style="color:var(--faint)">Tool:</span> ideal mirror gives <span style="font-family:var(--mono)">r = −1</span> for both components at normal incidence.</li>
            <li><strong>Goal:</strong> Recognize that reflection reverses propagation direction: <span style="font-family:var(--mono)">k → −k</span>.<br/>
              <span style="color:var(--faint)">Meaning:</span> the “viewing direction” used to label R/L flips.</li>
            <li><strong>Goal:</strong> Quantify handedness via helicity / Stokes parameter <span style="font-family:var(--mono)">s3</span>.<br/>
              <span style="color:var(--faint)">Tool:</span> <span style="font-family:var(--mono)">S3 = 2 Im(Ex Ey*)</span> and note helicity flips when <span style="font-family:var(--mono)">k</span> flips.</li>
            <li><strong>Goal:</strong> Conclude <span style="font-family:var(--mono)">RCP ↔ LCP</span> and sanity-check with limiting cases.</li>
          </ol>

          <div class="callout warn">
            <strong>Common mistakes + quick tips</strong>
            <ul style="margin:8px 0 0 20px">
              <li><strong>Tip:</strong> A global phase (multiplying the Jones vector by <span style="font-family:var(--mono)">e^{iφ}</span>) does <em>not</em> change polarization.</li>
              <li><strong>Mistake:</strong> Deciding handedness while still looking from the same side after reflection—remember: the wave is now traveling the other way.</li>
              <li><strong>Tip:</strong> When unsure, compute the rotation direction of <span style="font-family:var(--mono)">E(t)</span> as seen along the <em>new</em> propagation direction.</li>
            </ul>
          </div>
        </section>

        <!-- PART 3 -->
        <section id="solution">
          <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

          <h3>Physical intuition (before the math)</h3>
          <p>
            Circular polarization is a <em>rotation in the transverse plane</em>. The label “right” or “left” depends on which way that rotation appears
            when you look <em>along the direction the wave travels</em>.
            A mirror reflection sends the wave back the way it came, reversing its travel direction.
            So the same physical transverse rotation must be labeled with the opposite handedness.
          </p>

          <div class="hr"></div>

          <h3>Step 1 — Define the incident wave and circular basis (propagation along +z)</h3>
          <p>
            Take a monochromatic plane wave traveling in the <span style="font-family:var(--mono)">+z</span> direction.
            We use the complex representation (the physical field is the real part):
          </p>

          <div class="eq" data-copy="Incident wave (propagation +z):
E_i(r,t) = Re{ E0 e_pol exp[i(k z − ω t)] }.

Circular basis for +z:
e_R = (x̂ + i ŷ)/√2
e_L = (x̂ − i ŷ)/√2">
            <div class="label">Definition of the incident field and circular basis</div>
            <button class="copyBtn" aria-label="Copy incident definition">Copy</button>
            <div style="white-space:pre-wrap; font-family:var(--mono); line-height:1.35">
E_i(r,t) = Re{ E0 e_pol exp[i(k z − ω t)] }.

For propagation along +z:
e_R = (x̂ + i ŷ)/√2
e_L = (x̂ − i ŷ)/√2
            </div>
          </div>

          <p>
            Here:
            <span style="font-family:var(--mono)">E0</span> is a real amplitude (V/m),
            <span style="font-family:var(--mono)">k = 2π/λ</span> (rad/m),
            and <span style="font-family:var(--mono)">e_pol</span> is the polarization unit vector.
            For a right-circularly polarized incident wave (using the above convention), set
            <span style="font-family:var(--mono)">e_pol = e_R</span>.
          </p>

          <h3>Step 2 — Model the mirror reflection at normal incidence</h3>
          <p>
            Place an ideal mirror (perfect conductor) in the plane <span style="font-family:var(--mono)">z=0</span>.
            The tangential electric field must vanish at the surface:
            <span style="font-family:var(--mono)">E_t(z=0)=0</span>.
            For normal incidence, both transverse components are tangential, so the reflected wave must cancel the incident wave at the surface.
          </p>

          <div class="eq" data-copy="Boundary condition at z=0 (perfect conductor):
E_i(t) + E_r(t) = 0  ⇒  E_r = −E_i at the surface.
Thus the reflection coefficient is r = −1 (same for x and y at normal incidence).">
            <div class="label">Mirror boundary condition (normal incidence)</div>
            <button class="copyBtn" aria-label="Copy boundary condition">Copy</button>
            <div style="white-space:pre-wrap; font-family:var(--mono); line-height:1.35">
E_t(z=0)=0 ⇒ E_i + E_r = 0 at z=0
⇒ E_r = − E_i at the surface
⇒ r = −1 for both transverse components (normal incidence).
            </div>
          </div>

          <p>
            <strong>Interpretation:</strong> the mirror multiplies the transverse Jones vector by a single complex number
            <span style="font-family:var(--mono)">r = −1</span> (a phase shift of <span style="font-family:var(--mono)">π</span>).
            A global phase does not change the polarization ellipse.
          </p>

          <h3>Step 3 — Write the reflected wave and note the propagation reversal</h3>
          <p>
            The reflected wave travels in the <span style="font-family:var(--mono)">−z</span> direction, so its phase is
            <span style="font-family:var(--mono)">exp[i(−k z − ω t)]</span>.
            Using the same transverse basis vectors <span style="font-family:var(--mono)">x̂, ŷ</span> in the lab:
          </p>

          <div class="eq" data-copy="Reflected wave (propagation −z):
E_r(r,t) = Re{ r E0 e_pol exp[i(−k z − ω t)] }, with r = −1.

So the Jones vector in (x̂,ŷ) is unchanged up to a global phase:
J_r = r J_i.">
            <div class="label">Reflected field expression</div>
            <button class="copyBtn" aria-label="Copy reflected field">Copy</button>
            <div style="white-space:pre-wrap; font-family:var(--mono); line-height:1.35">
E_r(r,t) = Re{ r E0 e_pol exp[i(−k z − ω t)] },  r = −1.

In lab (x̂,ŷ):  J_r = r J_i  (global phase only).
            </div>
          </div>

          <p>
            Up to this point, it may look like nothing “changed” besides direction of travel.
            That is exactly why the next step matters: <strong>handedness is defined relative to the travel direction</strong>.
          </p>

          <h3>Step 4 — Handedness via Stokes parameter and helicity sign</h3>
          <p>
            Let the complex transverse components (Jones components) be
            <span style="font-family:var(--mono)">Ẽx</span> and <span style="font-family:var(--mono)">Ẽy</span>.
            The Stokes parameter that measures circularity is
          </p>

          <div class="eq" data-copy="Stokes circularity:
S0 = |Ex|^2 + |Ey|^2
S3 = 2 Im(Ex Ey*)
s3 = S3/S0 ∈ [−1,+1]

For a +z traveling wave, helicity ∝ s3.
For a −z traveling wave, the same transverse state corresponds to helicity ∝ −s3 (because k̂ flips).">
            <div class="label">Stokes circularity and the effect of reversing k</div>
            <button class="copyBtn" aria-label="Copy Stokes/helicity">Copy</button>
            <div style="white-space:pre-wrap; font-family:var(--mono); line-height:1.35">
S0 = |Ex|^2 + |Ey|^2
S3 = 2 Im(Ex Ey*)
s3 = S3/S0

(+z): helicity ∝ s3
(−z): helicity ∝ −s3   (since k̂ reverses).
            </div>
          </div>

          <p>
            Now apply reflection. Since <span style="font-family:var(--mono)">J_r = r J_i</span> with a global phase <span style="font-family:var(--mono)">r</span>,
            the products <span style="font-family:var(--mono)">|Ẽx|^2</span>, <span style="font-family:var(--mono)">|Ẽy|^2</span>, and
            <span style="font-family:var(--mono)">Ẽx Ẽy*</span> are unchanged:
            multiplying both components by the same <span style="font-family:var(--mono)">r</span> cancels in <span style="font-family:var(--mono)">Ẽx Ẽy*</span>.
            Therefore, the <em>lab-frame</em> Stokes <span style="font-family:var(--mono)">s3</span> computed from the Jones vector is the same.
          </p>

          <p>
            But the propagation direction is reversed, so the <strong>helicity (handedness)</strong> flips sign:
          </p>

          <div class="eq" data-copy="Key conclusion:
s3(out, lab) = s3(in, lab)   (global phase doesn’t change Stokes parameters)

But handedness/helicity is defined relative to propagation direction:
helicity_out = − helicity_in

Therefore: RCP ↔ LCP upon reflection from a mirror.">
            <div class="label">Final conclusion (boxed)</div>
            <button class="copyBtn" aria-label="Copy final conclusion">Copy</button>
            <div style="white-space:pre-wrap; font-family:var(--mono); line-height:1.35">
s3(out, lab) = s3(in, lab)

Handedness/helicity relative to propagation direction flips:
helicity_out = − helicity_in

⇒ Mirror reflection swaps circular handedness:
RCP ↔ LCP.
            </div>
          </div>

          <div class="callout good">
            <strong>Final Answer:</strong> Circularly polarized light reverses handedness on reflection from a mirror:
            <span style="font-family:var(--mono)">RCP → LCP</span> and <span style="font-family:var(--mono)">LCP → RCP</span>.
          </div>

          <h3>Sanity checks</h3>
          <ul>
            <li><strong>Units/dimensions:</strong> Stokes parameters are built from field magnitudes (V/m) squared, and normalized <span style="font-family:var(--mono)">s3</span> is dimensionless — consistent.</li>
            <li><strong>Limiting case:</strong> If the input is perfectly circular (|s3|=1), the output remains perfectly circular in the lab ellipse shape, but the handedness label flips because <span style="font-family:var(--mono)">k</span> flips.</li>
            <li><strong>Direction reasoning:</strong> If you literally walk to the other side and look along the new propagation direction, the apparent rotation sense reverses — exactly the handedness flip.</li>
          </ul>

          <p>
            <strong>Connection to the diagram/plots:</strong>
            The diagram shows the incident and reflected propagation directions.
            The plots quantify that the circularity parameter <span style="font-family:var(--mono)">s3</span> (from the transverse state) stays the same,
            while the <em>helicity relative to propagation</em> changes sign, making RCP become LCP.
          </p>
        </section>

        <!-- PART 4 -->
        <section id="deeper">
          <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

          <h3>Re-interpreting the result</h3>
          <p>
            Think of circular polarization as “spin angular momentum” carried by the wave.
            The handedness label is essentially the sign of the projection of that spin onto the propagation direction:
            <span style="font-family:var(--mono)">h ∝ S·k̂</span>.
            Reflection reverses <span style="font-family:var(--mono)">k̂</span> but does not magically reverse the transverse field’s rotation in lab coordinates,
            so the projection changes sign.
          </p>

          <div class="callout">
            <strong>What controls the circularity?</strong><br/>
            For a general Jones state <span style="font-family:var(--mono)">J = (Ẽx, Ẽy)</span>:
            <span style="font-family:var(--mono)">s3 = 2 Im(Ẽx Ẽy*) / (|Ẽx|^2 + |Ẽy|^2)</span>.
            It is controlled by the <strong>relative phase</strong> between components (maximal at ±90°) and their <strong>amplitude balance</strong> (maximal when equal).
          </div>

          <h3>How changing parameters affects the outcome (connect to plots)</h3>
          <ul>
            <li>If the input has equal amplitudes and a ±90° phase difference, <span style="font-family:var(--mono)">|s3|=1</span> (perfectly circular).</li>
            <li>If the amplitudes are unequal or the phase difference is not ±90°, <span style="font-family:var(--mono)">|s3|&lt;1</span> (elliptical).</li>
            <li>For an ideal mirror at normal incidence, the transverse Jones state is unchanged up to a global phase, so <span style="font-family:var(--mono)">s3</span> stays the same — but the handedness relative to propagation flips: the plots show <span style="font-family:var(--mono)">helicity_out = −helicity_in</span>.</li>
          </ul>

          <h3>Alternative derivation idea (brief)</h3>
          <p>
            You can derive the flip by explicitly tracking the real-time rotation.
            Write the incident RCP as
            <span style="font-family:var(--mono)">E_i(t) ∝ x̂ cos(ωt − kz) − ŷ sin(ωt − kz)</span> (one convention),
            reflect to get a wave with phase <span style="font-family:var(--mono)">+kz</span> and compare rotation while looking along the new propagation direction.
            The observed rotation sense reverses, giving the same conclusion.
          </p>

          <h3>Concept check (quick self-test)</h3>
          <ul>
            <li><strong>Q:</strong> Does multiplying a Jones vector by <span style="font-family:var(--mono)">e^{iφ}</span> change polarization?<br/>
              <strong>A:</strong> No. It is a global phase and cancels in physical observables like Stokes parameters.</li>
            <li><strong>Q:</strong> Why can handedness flip even if the transverse ellipse in lab coordinates looks the same?<br/>
              <strong>A:</strong> Because “right/left” is defined with respect to the propagation direction, which flips at reflection.</li>
            <li><strong>Q:</strong> What parameter in the Jones vector sets the sign of <span style="font-family:var(--mono)">s3</span>?<br/>
              <strong>A:</strong> The sign of the relative phase (whether <span style="font-family:var(--mono)">Ẽy</span> leads or lags <span style="font-family:var(--mono)">Ẽx</span>).</li>
            <li><strong>Q:</strong> In the plots, why is the “helicity out vs in” line always <span style="font-family:var(--mono)">y = −x</span>?<br/>
              <strong>A:</strong> Because reflection reverses <span style="font-family:var(--mono)">k̂</span>, flipping helicity sign regardless of the input ellipticity.</li>
          </ul>
        </section>

        <!-- PART 5 -->
        <section id="vizguide">
          <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

          <p>
            Below are three live canvases:
          </p>
          <ul>
            <li><strong>Diagram canvas:</strong> Geometry of a wave reflecting from a mirror at <span style="font-family:var(--mono)">z=0</span>, showing incident <span style="font-family:var(--mono)">+z</span> and reflected <span style="font-family:var(--mono)">−z</span> directions and the idea of handedness being defined along <span style="font-family:var(--mono)">k</span>.</li>
            <li><strong>Main quantitative plot:</strong> “Helicity (handedness) out” vs “Helicity in” for a sweep of the relative phase (example sweep). It should always lie on <span style="font-family:var(--mono)">y = −x</span>.</li>
            <li><strong>Secondary plot:</strong> Polarization ellipse in the transverse plane for the incident wave and the reflected wave. The ellipse shape in lab <span style="font-family:var(--mono)">x–y</span> is the same, but the direction of propagation used to label handedness is opposite.</li>
          </ul>

          <div class="callout warn">
            <strong>Interactive controls:</strong>
            <ul style="margin:8px 0 0 20px">
              <li><strong>Amplitude ratio</strong> <span style="font-family:var(--mono)">a = |Ẽy|/|Ẽx|</span>: changes ellipticity (more/less circular).</li>
              <li><strong>Relative phase</strong> <span style="font-family:var(--mono)">φ = arg(Ẽy) − arg(Ẽx)</span> (degrees): changes rotation sense and circularity sign.</li>
              <li>All canvases update live. Watch how <span style="font-family:var(--mono)">s3</span> responds, while the “helicity out” plot remains the sign-flipped relation.</li>
            </ul>
          </div>

          <figure>
            <canvas id="diag" aria-label="Reflection geometry diagram"></canvas>
            <figcaption>
              Diagram: incident and reflected propagation directions at a planar mirror. The handedness label is defined looking along the propagation direction, so reversing that direction swaps R/L.
            </figcaption>
          </figure>

          <div class="controls">
            <div class="control">
              <label>
                <span>Amplitude ratio <span style="font-family:var(--mono)">a = |Ẽy|/|Ẽx|</span></span>
                <span id="aVal" style="font-family:var(--mono)"></span>
              </label>
              <input id="a" type="range" min="0" max="1" step="0.01" value="1">
              <div class="mini">Example parameter for plotting. <span style="font-family:var(--mono)">a=1</span> gives equal amplitudes (max circularity possible).</div>
            </div>
            <div class="control">
              <label>
                <span>Relative phase <span style="font-family:var(--mono)">φ</span> (degrees)</span>
                <span id="phiVal" style="font-family:var(--mono)"></span>
              </label>
              <input id="phi" type="range" min="-180" max="180" step="1" value="90">
              <div class="mini"><span style="font-family:var(--mono)">φ=±90°</span> with <span style="font-family:var(--mono)">a=1</span> gives circular. Sign sets handedness.</div>
            </div>
            <div class="control">
              <label>
                <span>Convention helper</span>
                <span style="font-family:var(--mono)">view along k</span>
              </label>
              <select id="conv">
                <option value="optics" selected>Optics-style: label by rotation seen looking along propagation</option>
                <option value="note">Reminder: R/L depends on convention, but mirror swaps them either way</option>
              </select>
              <div class="mini">We keep the math in terms of <span style="font-family:var(--mono)">s3</span> and “helicity,” which avoids most convention traps.</div>
            </div>
            <div class="control">
              <label>
                <span>Reset</span>
                <span style="font-family:var(--mono)">a=1, φ=90°</span>
              </label>
              <button id="reset">Reset to circular example</button>
              <div class="mini">Resets to a perfectly circular example input (for plotting).</div>
            </div>
          </div>

          <figure>
            <canvas id="plot1" aria-label="Main plot: helicity out vs helicity in"></canvas>
            <figcaption>
              Main plot: helicity (handedness) of the reflected wave vs helicity of the incident wave, using an internal sweep of phase as a demonstration.
              For an ideal mirror, the relation is always <span style="font-family:var(--mono)">helicity_out = −helicity_in</span>.
            </figcaption>
          </figure>

          <figure>
            <canvas id="plot2" aria-label="Secondary plot: polarization ellipse"></canvas>
            <figcaption>
              Secondary plot: polarization ellipse in lab <span style="font-family:var(--mono)">E_x–E_y</span> coordinates (unitless, normalized).
              The ellipse shape is unchanged by a global reflection phase, but the handedness label swaps because the propagation direction changes.
            </figcaption>
          </figure>

          <div class="eq" data-copy="FINAL RESULT:
Upon reflection from a mirror, circularly polarized light changes handedness:
RCP becomes LCP and LCP becomes RCP.

Equivalently (helicity):
helicity_out = −helicity_in.">
            <div class="label">Final answer (copyable)</div>
            <button class="copyBtn" aria-label="Copy final answer">Copy</button>
            <div style="white-space:pre-wrap; font-family:var(--mono); line-height:1.35">
FINAL RESULT:
Upon reflection from a mirror, circularly polarized light changes handedness:
RCP becomes LCP and LCP becomes RCP.

Equivalently (helicity):
helicity_out = −helicity_in.
            </div>
          </div>

        </section>
      </article>

      <!-- TOC -->
      <aside class="toc" aria-label="Table of contents">
        <h2>On this page</h2>
        <a href="#quick">Quick Summary</a>
        <a href="#primer">PART 0 — Concept Primer</a>
        <a href="#analysis">PART 1 — Problem Analysis</a>
        <a href="#strategy">PART 2 — Strategy & Tips</a>
        <a href="#solution">PART 3 — Full Solution</a>
        <a href="#deeper">PART 4 — Deeper Understanding</a>
        <a href="#vizguide">PART 5 — Visualization Guide</a>
      </aside>
    </div>
  </main>

  <footer>
    <div class="wrap">
      <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center">
        <span class="chip" style="background:rgba(52,211,153,0.12); border-color:rgba(52,211,153,0.24)">Tip</span>
        <span style="color:var(--muted)">If you later study oblique incidence, use Fresnel coefficients <span style="font-family:var(--mono)">r_s</span>, <span style="font-family:var(--mono)">r_p</span>; the ellipse can change—but the propagation reversal still flips helicity labeling.</span>
      </div>
    </div>
  </footer>

  <div class="copyToast" id="toast" role="status" aria-live="polite">Copied!</div>

  <script>
    // ---------- Copy buttons ----------
    const toast = document.getElementById('toast');
    function showToast(msg){
      toast.textContent = msg || 'Copied!';
      toast.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>toast.classList.remove('show'), 1100);
    }
    function copyText(txt){
      if(!navigator.clipboard){
        // Fallback
        const ta = document.createElement('textarea');
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        try{ document.execCommand('copy'); showToast('Copied!'); } catch(e){ showToast('Copy failed'); }
        document.body.removeChild(ta);
        return;
      }
      navigator.clipboard.writeText(txt).then(()=>showToast('Copied!')).catch(()=>showToast('Copy failed'));
    }
    document.querySelectorAll('.eq').forEach(eq=>{
      const btn = eq.querySelector('.copyBtn');
      if(!btn) return;
      btn.addEventListener('click', ()=>{
        const txt = eq.getAttribute('data-copy') || eq.innerText;
        copyText(txt.trim());
      });
    });

    // ---------- Math helpers (no external libs) ----------
    function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
    function deg2rad(d){ return d*Math.PI/180; }
    function niceTicks(min, max, n){
      // simple tick generator
      const span = max - min;
      if(span <= 0) return [min];
      const raw = span / (n-1);
      const pow = Math.pow(10, Math.floor(Math.log10(raw)));
      const candidates = [1,2,5,10].map(m=>m*pow);
      let step = candidates[0];
      for(const c of candidates){ if(Math.abs(c-raw) < Math.abs(step-raw)) step=c; }
      const start = Math.ceil(min/step)*step;
      const ticks = [];
      for(let t=start; t<=max+1e-12; t+=step) ticks.push(t);
      return ticks;
    }

    // ---------- Polarization model ----------
    // Jones vector (normalized-ish) in lab x,y:
    // Ex = 1, Ey = a * exp(i phi)
    // Stokes S0, S3:
    function stokesFromJones(a, phiRad){
      const Ex_re = 1, Ex_im = 0;
      const Ey_re = a*Math.cos(phiRad), Ey_im = a*Math.sin(phiRad);
      // |Ex|^2 + |Ey|^2
      const S0 = (Ex_re*Ex_re + Ex_im*Ex_im) + (Ey_re*Ey_re + Ey_im*Ey_im);
      // Ex * conj(Ey) = (Ex_re + iEx_im)(Ey_re - iEy_im) = Ex_re*Ey_re + Ex_im*Ey_im + i(Ex_im*Ey_re - Ex_re*Ey_im)
      const Im_ExEyStar = (Ex_im*Ey_re - Ex_re*Ey_im);
      const S3 = 2*Im_ExEyStar; // = -2*Ey_im since Ex_im=0, Ex_re=1
      return {S0, S3, s3: (S0===0?0:S3/S0)};
    }

    // Helicity sign relative to propagation direction k_z (+1 or -1):
    // We take helicity ∝ s3 * sign(kz). (This encodes that reversing k flips helicity labeling)
    function helicity(a, phiRad, kzSign){
      const {s3} = stokesFromJones(a, phiRad);
      return s3 * kzSign;
    }

    // ---------- Canvas utilities (high-DPI crisp) ----------
    function setupCanvas(canvas){
      const ctx = canvas.getContext('2d');
      function resize(){
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        const w = Math.max(320, rect.width);
        const h = Math.max(220, rect.width*0.55);
        canvas.width = Math.round(w * dpr);
        canvas.height = Math.round(h * dpr);
        canvas.style.height = h + 'px';
        ctx.setTransform(dpr,0,0,dpr,0,0);
        return {w, h, dpr};
      }
      return {ctx, resize};
    }

    function drawPanelFrame(ctx, w, h, title){
      // background
      ctx.clearRect(0,0,w,h);
      ctx.save();
      // soft gradient
      const g = ctx.createLinearGradient(0,0,w,h);
      g.addColorStop(0,'rgba(255,255,255,0.06)');
      g.addColorStop(1,'rgba(255,255,255,0.02)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);

      // title
      ctx.fillStyle = 'rgba(255,255,255,0.90)';
      ctx.font = '600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText(title, 14, 22);
      ctx.restore();
    }

    function drawAxes(ctx, box, xMin,xMax,yMin,yMax, xLabel,yLabel){
      const {x,y,w,h} = box;

      // grid
      ctx.save();
      ctx.translate(x,y);

      const xTicks = niceTicks(xMin,xMax,6);
      const yTicks = niceTicks(yMin,yMax,6);

      // gridlines
      ctx.strokeStyle = 'rgba(255,255,255,0.10)';
      ctx.lineWidth = 1;
      for(const xt of xTicks){
        const xp = (xt - xMin)/(xMax-xMin)*w;
        ctx.beginPath();
        ctx.moveTo(xp,0);
        ctx.lineTo(xp,h);
        ctx.stroke();
      }
      for(const yt of yTicks){
        const yp = h - (yt - yMin)/(yMax-yMin)*h;
        ctx.beginPath();
        ctx.moveTo(0,yp);
        ctx.lineTo(w,yp);
        ctx.stroke();
      }

      // axes border
      ctx.strokeStyle = 'rgba(255,255,255,0.20)';
      ctx.strokeRect(0,0,w,h);

      // ticks + labels
      ctx.fillStyle = 'rgba(255,255,255,0.78)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      for(const xt of xTicks){
        const xp = (xt - xMin)/(xMax-xMin)*w;
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,255,255,0.30)';
        ctx.moveTo(xp,h);
        ctx.lineTo(xp,h+5);
        ctx.stroke();
        ctx.fillText(formatTick(xt), xp, h+7);
      }
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      for(const yt of yTicks){
        const yp = h - (yt - yMin)/(yMax-yMin)*h;
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,255,255,0.30)';
        ctx.moveTo(0,yp);
        ctx.lineTo(-5,yp);
        ctx.stroke();
        ctx.fillText(formatTick(yt), -8, yp);
      }

      // axis labels
      ctx.fillStyle = 'rgba(255,255,255,0.82)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText(xLabel, w/2, h+30);

      ctx.save();
      ctx.translate(-42, h/2);
      ctx.rotate(-Math.PI/2);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();

      ctx.restore();

      function formatTick(v){
        const av = Math.abs(v);
        if(av >= 1) return (Math.round(v*10)/10).toString();
        return (Math.round(v*100)/100).toString();
      }
    }

    function mapToBox(box, xMin,xMax,yMin,yMax, xVal,yVal){
      const xp = box.x + (xVal-xMin)/(xMax-xMin)*box.w;
      const yp = box.y + box.h - (yVal-yMin)/(yMax-yMin)*box.h;
      return {xp, yp};
    }

    // ---------- Canvases ----------
    const diagC = setupCanvas(document.getElementById('diag'));
    const p1C = setupCanvas(document.getElementById('plot1'));
    const p2C = setupCanvas(document.getElementById('plot2'));

    // Controls
    const aEl = document.getElementById('a');
    const phiEl = document.getElementById('phi');
    const convEl = document.getElementById('conv');
    const resetEl = document.getElementById('reset');
    const aVal = document.getElementById('aVal');
    const phiVal = document.getElementById('phiVal');

    resetEl.addEventListener('click', ()=>{
      aEl.value = 1;
      phiEl.value = 90;
      renderAll();
    });

    [aEl, phiEl, convEl].forEach(el=>el.addEventListener('input', renderAll));
    window.addEventListener('resize', renderAll);

    function renderAll(){
      const a = parseFloat(aEl.value);
      const phiDeg = parseFloat(phiEl.value);
      aVal.textContent = a.toFixed(2);
      phiVal.textContent = phiDeg.toFixed(0) + '°';

      renderDiagram(a, phiDeg);
      renderMainPlot(a);
      renderEllipsePlot(a, phiDeg);
    }

    function renderDiagram(a, phiDeg){
      const {ctx, resize} = diagC;
      const {w, h} = resize();

      drawPanelFrame(ctx, w, h, 'Diagram — Mirror reflection reverses propagation direction');

      // Scene coordinates
      const pad = 14;
      const cx = w*0.52, cy = h*0.58;

      // Mirror plane (vertical line representing z=0 in side view)
      const mirrorX = w*0.62;
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.40)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(mirrorX, pad+30);
      ctx.lineTo(mirrorX, h-pad);
      ctx.stroke();

      // Mirror hatch
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      for(let y=pad+34; y<h-pad; y+=10){
        ctx.beginPath();
        ctx.moveTo(mirrorX, y);
        ctx.lineTo(mirrorX+10, y-10);
        ctx.stroke();
      }

      // Incident ray (from left to mirror)
      const incStart = {x: w*0.18, y: h*0.60};
      const hit = {x: mirrorX, y: h*0.60};
      arrow(ctx, incStart.x, incStart.y, hit.x-8, hit.y, 'rgba(125,211,252,0.95)', 3);
      // Reflected ray (back to left)
      const refEnd = {x: w*0.18, y: h*0.42};
      arrow(ctx, hit.x+8, hit.y, refEnd.x, refEnd.y, 'rgba(167,139,250,0.95)', 3);

      // Labels
      ctx.fillStyle = 'rgba(255,255,255,0.90)';
      ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Mirror (z = 0)', mirrorX-62, pad+46);

      ctx.fillStyle = 'rgba(125,211,252,0.95)';
      ctx.fillText('Incident: k along +z', incStart.x, incStart.y-12);

      ctx.fillStyle = 'rgba(167,139,250,0.95)';
      ctx.fillText('Reflected: k along −z', refEnd.x, refEnd.y-12);

      // Small polarization circles (rotation icons)
      const phiRad = deg2rad(phiDeg);
      const {s3} = stokesFromJones(a, phiRad);
      const hIn = helicity(a, phiRad, +1);
      const hOut = helicity(a, phiRad, -1);

      drawRotationBadge(ctx, w*0.33, h*0.73, 26, s3, +1, 'Incident view (along +k)');
      drawRotationBadge(ctx, w*0.33, h*0.30, 26, s3, -1, 'Reflected view (along −k)');

      // Text box
      const boxW = w*0.38;
      const boxH = 74;
      const boxX = w*0.56;
      const boxY = h*0.12;
      roundRect(ctx, boxX, boxY, boxW, boxH, 12);
      ctx.fillStyle = 'rgba(0,0,0,0.30)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.stroke();

      ctx.fillStyle = 'rgba(255,255,255,0.88)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText(`Example input: a=${a.toFixed(2)}, φ=${phiDeg.toFixed(0)}°`, boxX+12, boxY+22);
      ctx.fillStyle = 'rgba(255,255,255,0.76)';
      ctx.fillText(`s3 (from transverse state) = ${s3.toFixed(3)}`, boxX+12, boxY+40);
      ctx.fillText(`helicity_in = ${hIn.toFixed(3)}  →  helicity_out = ${hOut.toFixed(3)}`, boxX+12, boxY+58);

      ctx.restore();
    }

    function renderMainPlot(a){
      const {ctx, resize} = p1C;
      const {w, h} = resize();
      drawPanelFrame(ctx, w, h, 'Main plot — Helicity out vs helicity in (ideal mirror)');

      const box = {x:74, y:42, w:w-104, h:h-112};

      // axes
      drawAxes(ctx, box, -1, 1, -1, 1, 'helicity_in (dimensionless)', 'helicity_out (dimensionless)');

      // data: sweep phase phi from -180..180 for this a
      ctx.save();
      // line y = -x
      ctx.strokeStyle = 'rgba(255,255,255,0.70)';
      ctx.setLineDash([6,6]);
      ctx.lineWidth = 2;
      const pA = mapToBox(box, -1,1,-1,1, -1, 1);
      const pB = mapToBox(box, -1,1,-1,1,  1,-1);
      ctx.beginPath();
      ctx.moveTo(pA.xp, pA.yp);
      ctx.lineTo(pB.xp, pB.yp);
      ctx.stroke();
      ctx.setLineDash([]);

      // points
      ctx.fillStyle = 'rgba(125,211,252,0.95)';
      ctx.strokeStyle = 'rgba(125,211,252,0.95)';
      ctx.lineWidth = 1.5;

      const N = 181;
      for(let i=0;i<N;i++){
        const phiDeg = -180 + i*(360/(N-1));
        const phiRad = deg2rad(phiDeg);
        const hin = helicity(a, phiRad, +1);
        const hout = helicity(a, phiRad, -1);
        const p = mapToBox(box, -1,1,-1,1, hin, hout);
        ctx.beginPath();
        ctx.arc(p.xp, p.yp, 2.2, 0, Math.PI*2);
        ctx.fill();
      }

      // current point (from slider)
      const phiRadSel = deg2rad(parseFloat(phiEl.value));
      const hinSel = helicity(a, phiRadSel, +1);
      const houtSel = helicity(a, phiRadSel, -1);
      const pSel = mapToBox(box, -1,1,-1,1, hinSel, houtSel);
      ctx.fillStyle = 'rgba(251,191,36,0.95)';
      ctx.beginPath();
      ctx.arc(pSel.xp, pSel.yp, 5, 0, Math.PI*2);
      ctx.fill();

      // legend
      const lx = box.x + 10, ly = box.y + 10;
      legendItem(ctx, lx, ly, 'rgba(255,255,255,0.70)', 'Ideal mirror: y = −x', true);
      legendItem(ctx, lx, ly+18, 'rgba(125,211,252,0.95)', 'Phase sweep (example points)', false);
      legendItem(ctx, lx, ly+36, 'rgba(251,191,36,0.95)', 'Current (a, φ) selection', false);

      ctx.restore();
    }

    function renderEllipsePlot(a, phiDeg){
      const {ctx, resize} = p2C;
      const {w, h} = resize();
      drawPanelFrame(ctx, w, h, 'Secondary plot — Polarization ellipse (incident vs reflected)');

      const box = {x:74, y:42, w:w-104, h:h-112};

      // Ellipse axes: normalized Ex, Ey (unitless)
      const lim = 1.25;
      drawAxes(ctx, box, -lim, lim, -lim, lim, 'E_x / E0 (unitless)', 'E_y / E0 (unitless)');

      // Build time samples: Ex = cos(ωt), Ey = a cos(ωt - φ)
      // (This matches Jones Ex=1, Ey=a e^{iφ} under Re{... e^{-iωt}} up to convention; it's fine for visualization.)
      const phi = deg2rad(phiDeg);

      // Incident ellipse in lab (same as reflected in lab for ideal mirror)
      // We'll draw incident as cyan, reflected as purple (same curve) but add arrows indicating viewing along +k vs -k.
      const N = 480;

      // draw curve
      ctx.save();
      ctx.lineWidth = 2.6;

      // Incident curve
      ctx.strokeStyle = 'rgba(125,211,252,0.95)';
      ctx.beginPath();
      for(let i=0;i<=N;i++){
        const t = i*(2*Math.PI/N);
        const Ex = Math.cos(t);
        const Ey = a*Math.cos(t - phi);
        const p = mapToBox(box, -lim,lim,-lim,lim, Ex, Ey);
        if(i===0) ctx.moveTo(p.xp, p.yp);
        else ctx.lineTo(p.xp, p.yp);
      }
      ctx.stroke();

      // Reflected curve (same ellipse in lab)
      ctx.strokeStyle = 'rgba(167,139,250,0.95)';
      ctx.beginPath();
      for(let i=0;i<=N;i++){
        const t = i*(2*Math.PI/N);
        const Ex = Math.cos(t);
        const Ey = a*Math.cos(t - phi);
        const p = mapToBox(box, -lim,lim,-lim,lim, Ex, Ey);
        if(i===0) ctx.moveTo(p.xp, p.yp);
        else ctx.lineTo(p.xp, p.yp);
      }
      ctx.stroke();

      // rotation direction markers:
      // Determine instantaneous direction of motion at t0 based on param derivative:
      const t0 = 0.35*Math.PI;
      const Ex0 = Math.cos(t0), Ey0 = a*Math.cos(t0 - phi);
      const dEx = -Math.sin(t0);
      const dEy = -a*Math.sin(t0 - phi);

      // In the transverse plane, the param direction is (dEx, dEy) as time increases.
      // When you "look along +k", that corresponds to one handedness sign; looking along -k flips.
      // We'll draw arrows along the curve in two positions and label them.

      // Arrow along curve (incident)
      drawTangentArrow(ctx, box, -lim,lim,-lim,lim, Ex0, Ey0, dEx, dEy, 'rgba(125,211,252,0.95)');

      // For reflected, the curve is same in lab but the observer's viewing direction flips, so the same param direction corresponds to opposite handedness.
      // We'll draw a second arrow at another point but keep param direction; label explains the flip is due to viewing direction (k reversal).
      const t1 = 1.1*Math.PI;
      const Ex1 = Math.cos(t1), Ey1 = a*Math.cos(t1 - phi);
      const dEx1 = -Math.sin(t1);
      const dEy1 = -a*Math.sin(t1 - phi);
      drawTangentArrow(ctx, box, -lim,lim,-lim,lim, Ex1, Ey1, dEx1, dEy1, 'rgba(167,139,250,0.95)');

      // Legend + numeric readout
      const st = stokesFromJones(a, phi);
      const hin = helicity(a, phi, +1);
      const hout = helicity(a, phi, -1);

      legendItem(ctx, box.x+10, box.y+10, 'rgba(125,211,252,0.95)', 'Incident ellipse (lab x–y)', false);
      legendItem(ctx, box.x+10, box.y+28, 'rgba(167,139,250,0.95)', 'Reflected ellipse (same in lab)', false);

      // annotation box
      const bx = box.x + box.w - 278;
      const by = box.y + 8;
      roundRect(ctx, bx, by, 268, 62, 12);
      ctx.fillStyle = 'rgba(0,0,0,0.28)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.stroke();

      ctx.fillStyle = 'rgba(255,255,255,0.90)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText(`Example: a=${a.toFixed(2)}, φ=${phiDeg.toFixed(0)}°`, bx+12, by+22);
      ctx.fillStyle = 'rgba(255,255,255,0.78)';
      ctx.fillText(`s3 = ${st.s3.toFixed(3)} (transverse); helicity_in = ${hin.toFixed(3)}`, bx+12, by+40);
      ctx.fillText(`helicity_out = ${hout.toFixed(3)} (flip due to k reversal)`, bx+12, by+56);

      ctx.restore();
    }

    // ---------- Drawing primitives ----------
    function roundRect(ctx, x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    function arrow(ctx, x1,y1,x2,y2, color, lw){
      const dx = x2-x1, dy = y2-y1;
      const L = Math.hypot(dx,dy) || 1;
      const ux = dx/L, uy = dy/L;
      const head = 10;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = lw;
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(x2,y2);
      ctx.lineTo(x2 - head*ux + head*0.55*(-uy), y2 - head*uy + head*0.55*(ux));
      ctx.lineTo(x2 - head*ux - head*0.55*(-uy), y2 - head*uy - head*0.55*(ux));
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function legendItem(ctx, x,y, color, text, dashed){
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2.4;
      if(dashed) ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(x, y+6);
      ctx.lineTo(x+24, y+6);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = 'rgba(255,255,255,0.82)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textBaseline = 'top';
      ctx.fillText(text, x+32, y);
      ctx.restore();
    }

    function drawTangentArrow(ctx, box, xMin,xMax,yMin,yMax, xVal,yVal, dx,dy, color){
      // Normalize tangent in plot coordinates
      const len = Math.hypot(dx,dy) || 1;
      const ux = dx/len, uy = dy/len;
      const scale = 0.18; // in data units
      const x2 = xVal + ux*scale;
      const y2 = yVal + uy*scale;
      const p1 = mapToBox(box, xMin,xMax,yMin,yMax, xVal,yVal);
      const p2 = mapToBox(box, xMin,xMax,yMin,yMax, x2,y2);
      arrow(ctx, p1.xp, p1.yp, p2.xp, p2.yp, color, 2.6);
    }

    function drawRotationBadge(ctx, x,y, r, s3, kzSign, caption){
      // badge: indicates perceived handedness looking along kzSign direction
      // helicity = s3*kzSign; positive -> one sense, negative -> opposite
      const h = s3*kzSign;

      // circle
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // arc arrow showing rotation
      const dir = (h>=0) ? 1 : -1; // 1 = CCW, -1 = CW in canvas coords (y down complicates; treat as indicator)
      const start = -0.3*Math.PI;
      const end = start + dir*1.25*Math.PI;

      ctx.strokeStyle = (kzSign>0) ? 'rgba(125,211,252,0.95)' : 'rgba(167,139,250,0.95)';
      ctx.lineWidth = 2.4;
      ctx.beginPath();
      ctx.arc(x,y,r*0.62, start, end, dir<0);
      ctx.stroke();

      // arrowhead
      const ang = end;
      const hx = x + Math.cos(ang)*r*0.62;
      const hy = y + Math.sin(ang)*r*0.62;
      const t = dir*1; // orientation
      const a1 = ang + (dir<0 ? 0.9 : -0.9);
      const a2 = ang + (dir<0 ? 2.2 : -2.2);
      ctx.fillStyle = ctx.strokeStyle;
      ctx.beginPath();
      ctx.moveTo(hx,hy);
      ctx.lineTo(hx + Math.cos(a1)*6, hy + Math.sin(a1)*6);
      ctx.lineTo(hx + Math.cos(a2)*6, hy + Math.sin(a2)*6);
      ctx.closePath();
      ctx.fill();

      // label inside
      ctx.fillStyle = 'rgba(255,255,255,0.88)';
      ctx.font = '700 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(h>=0 ? 'R/L + ' : 'R/L −', x, y);

      // caption
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillStyle = 'rgba(255,255,255,0.78)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText(caption, x + r + 10, y - 14);
      ctx.fillStyle = 'rgba(255,255,255,0.68)';
      ctx.fillText(`helicity = ${h.toFixed(3)}`, x + r + 10, y + 2);

      ctx.restore();
    }

    // Initial render
    renderAll();
  </script>
</body>
</html>
