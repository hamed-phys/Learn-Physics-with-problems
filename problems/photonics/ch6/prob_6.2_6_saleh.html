<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Goos–Hänchen Shift (TE) from Total Internal Reflection — Phase Derivative and Lateral Displacement</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#101a33;
      --card2:#0f1730;
      --text:#e8ecff;
      --muted:#b8c0ff;
      --soft:#93a0ff;
      --line:rgba(255,255,255,.12);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 12px 40px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family: var(--sans);
      background: radial-gradient(1200px 700px at 20% 5%, rgba(125,211,252,.18), transparent 55%),
                  radial-gradient(1000px 650px at 90% 10%, rgba(167,139,250,.16), transparent 55%),
                  linear-gradient(180deg, #070a14, var(--bg));
      color: var(--text);
      line-height: 1.55;
    }
    header{
      padding: 28px 18px 10px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .titleWrap{
      display:grid;
      gap:10px;
      align-items:start;
    }
    h1{
      margin:0;
      font-size: clamp(1.35rem, 2.3vw, 2.05rem);
      letter-spacing: .2px;
    }
    .subtitle{
      margin:0;
      color: var(--muted);
      font-size: .98rem;
      max-width: 85ch;
    }
    .metaRow{
      margin-top: 12px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      color: var(--muted);
      font-size:.92rem;
    }
    .pill{
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      padding: 6px 10px;
      border-radius: 999px;
      box-shadow: 0 8px 22px rgba(0,0,0,.18);
      backdrop-filter: blur(8px);
    }

    main{
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px 18px 60px;
      display:grid;
      grid-template-columns: 300px 1fr;
      gap: 16px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
    }

    nav.toc{
      position: sticky;
      top: 12px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid var(--line);
      border-radius: 18px;
      padding: 14px 12px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .toc h2{
      font-size: .95rem;
      margin: 0 0 8px;
      color: var(--text);
      letter-spacing:.2px;
    }
    .toc a{
      display:block;
      color: var(--muted);
      text-decoration:none;
      padding: 7px 10px;
      border-radius: 12px;
      border: 1px solid transparent;
      transition: transform .12s ease, background .12s ease, color .12s ease;
      font-size: .92rem;
    }
    .toc a:hover{
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.22);
      color: var(--text);
      transform: translateX(2px);
    }
    .toc .miniNote{
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--line);
      color: var(--muted);
      font-size: .86rem;
    }

    article{
      display:grid;
      gap: 14px;
    }

    section{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.025));
      border: 1px solid var(--line);
      border-radius: 18px;
      padding: 16px 16px 18px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    section h2{
      margin: 0 0 8px;
      font-size: 1.15rem;
      letter-spacing:.2px;
    }
    section h3{
      margin: 14px 0 8px;
      font-size: 1.02rem;
      color: var(--text);
    }
    p{margin: 8px 0; color: var(--text)}
    ul{margin: 8px 0 0 20px; color: var(--text)}
    li{margin: 6px 0; color: var(--text)}
    .muted{color: var(--muted)}
    .grid2{
      display:grid;
      gap: 12px;
      grid-template-columns: 1.15fr .85fr;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid2{grid-template-columns: 1fr}
    }

    .callouts{
      display:grid;
      gap: 10px;
      grid-template-columns: repeat(12, 1fr);
    }
    .box{
      grid-column: span 12;
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px 12px;
      background: rgba(0,0,0,.18);
      box-shadow: 0 10px 26px rgba(0,0,0,.22);
    }
    .box.good{border-color: rgba(52,211,153,.35); background: rgba(52,211,153,.07)}
    .box.warn{border-color: rgba(251,191,36,.35); background: rgba(251,191,36,.06)}
    .box.bad{border-color: rgba(251,113,133,.35); background: rgba(251,113,133,.06)}
    .box .label{
      display:flex;
      align-items:center;
      gap:8px;
      font-weight: 700;
      letter-spacing:.2px;
      margin-bottom: 6px;
      color: var(--text);
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(125,211,252,.12);
    }
    .good .dot{background: var(--good); box-shadow: 0 0 0 3px rgba(52,211,153,.14)}
    .warn .dot{background: var(--warn); box-shadow: 0 0 0 3px rgba(251,191,36,.14)}
    .bad .dot{background: var(--bad); box-shadow: 0 0 0 3px rgba(251,113,133,.14)}

    .eqCard{
      border: 1px solid rgba(125,211,252,.26);
      background: rgba(125,211,252,.06);
      border-radius: 16px;
      padding: 12px 12px;
      overflow:auto;
    }
    .eqRow{
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 10px;
    }
    pre.eq, code{
      font-family: var(--mono);
      font-size: .93rem;
      margin:0;
      white-space: pre-wrap;
      word-break: break-word;
      color: #eaf7ff;
    }

    .btn{
      appearance:none;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-weight:600;
      font-size:.9rem;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.09);
      border-color: rgba(125,211,252,.30);
    }
    .btn:active{transform: translateY(0px)}
    .btn.small{padding: 6px 9px; font-size:.86rem}
    .btn.accent{border-color: rgba(125,211,252,.35); background: rgba(125,211,252,.08)}
    .btn.accent2{border-color: rgba(167,139,250,.35); background: rgba(167,139,250,.08)}

    .vizGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 980px){
      .vizGrid{grid-template-columns: 1fr}
    }
    figure{
      margin:0;
      border:1px solid var(--line);
      border-radius: 16px;
      overflow:hidden;
      background: rgba(0,0,0,.20);
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .figHead{
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .figTitle{
      margin:0;
      font-size: .98rem;
      color: var(--text);
      letter-spacing:.2px;
      font-weight: 750;
    }
    .figSub{
      margin:0;
      color: var(--muted);
      font-size: .86rem;
    }
    .canvasWrap{
      padding: 10px 12px 12px;
    }
    canvas{
      width:100%;
      height: 300px;
      display:block;
      border-radius: 12px;
      background: rgba(6,10,22,.65);
      border: 1px solid rgba(255,255,255,.10);
    }
    .tall canvas{height: 360px}

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 8px;
    }
    @media (max-width: 720px){
      .controls{grid-template-columns: 1fr}
    }
    .ctrl{
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 10px 10px;
      background: rgba(255,255,255,.04);
    }
    .ctrl label{
      display:flex;
      justify-content: space-between;
      gap: 10px;
      font-size: .9rem;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .ctrl .val{
      color: var(--text);
      font-weight: 700;
      font-family: var(--mono);
      font-size: .9rem;
    }
    input[type="range"]{
      width: 100%;
      accent-color: var(--accent);
    }
    .rowBtns{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      margin-top: 8px;
      align-items:center;
    }

    .hr{
      height:1px;background: var(--line); margin: 10px 0;
    }

    .kpiGrid{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    @media (max-width: 980px){
      .kpiGrid{grid-template-columns: 1fr}
    }
    .kpi{
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 10px 10px;
      background: rgba(0,0,0,.16);
    }
    .kpi .k{
      color: var(--muted);
      font-size:.84rem;
      margin:0 0 4px;
    }
    .kpi .v{
      margin:0;
      font-family: var(--mono);
      font-size: 1.02rem;
      font-weight: 800;
      color: var(--text);
    }

    footer{
      max-width: 1200px;
      margin: 0 auto;
      padding: 16px 18px 40px;
      color: var(--muted);
      font-size: .9rem;
    }

    @media print{
      body{background:#fff; color:#000}
      header, main, footer{max-width: 100%; padding: 0}
      nav.toc{display:none}
      section, figure{box-shadow:none; background:#fff; border-color:#ccc}
      canvas{border-color:#999}
      .btn{display:none}
      .pill{box-shadow:none}
      .eqCard{background:#f7fbff}
      a{color:#000}
    }

    /* subtle entrance */
    @keyframes pop {
      from{transform: translateY(6px); opacity:0}
      to{transform: translateY(0); opacity:1}
    }
    section, nav.toc, figure{animation: pop .35s ease both}
  </style>
</head>
<body>
  <header>
    <div class="titleWrap">
      <h1>6.2-6 — Goos–Hänchen Shift (TE): phase derivative in TIR and the lateral displacement</h1>
      <p class="subtitle">
        Two TE (s-polarized) plane waves undergo total internal reflection at angles <span class="muted">θ</span> and <span class="muted">θ + dθ</span>.
        Their reflected phases differ by <span class="muted">dφ = ξ dθ</span>. We derive <span class="muted">ξ</span>, then connect it to a measurable lateral shift
        (the Goos–Hänchen effect) via interference/fringe translation and the beam (angular spectrum) viewpoint.
      </p>
      <div class="metaRow">
        <span class="pill">Topic: Fresnel reflection • TIR phase • stationary phase</span>
        <span class="pill">Polarization: TE (s)</span>
        <span class="pill">Result: symbolic + plotted example (glass–air)</span>
      </div>
    </div>
  </header>

  <main>
    <nav class="toc" aria-label="Table of contents">
      <h2>Table of Contents</h2>
      <a href="#quick">Quick Summary</a>
      <a href="#primer">PART 0 — Concept Primer</a>
      <a href="#analysis">PART 1 — Problem Analysis</a>
      <a href="#strategy">PART 2 — Strategy & Tips</a>
      <a href="#solution">PART 3 — Full Solution</a>
      <a href="#deeper">PART 4 — Deeper Understanding</a>
      <a href="#vizguide">PART 5 — Visualization Guide</a>
      <div class="miniNote">
        <div><span class="muted">Tip:</span> Use the sliders to see how the phase slope and GH shift explode near the critical angle.</div>
      </div>
    </nav>

    <article>
      <section id="quick">
        <h2>Quick Summary</h2>
        <ul>
          <li><b>What this is about:</b> Total internal reflection (TIR) has unit magnitude reflection but a <b>nontrivial phase</b> that depends on incidence angle.</li>
          <li><b>Key idea:</b> A small angular change <span class="muted">dθ</span> changes the reflection phase by <span class="muted">dφ = (dφ/dθ) dθ</span>, and that phase slope causes a <b>lateral shift</b> of interference fringes and of reflected beams (Goos–Hänchen shift).</li>
          <li><b>Governing equation (TE Fresnel):</b> <span class="muted">r<sub>TE</sub> = (n₁ cosθ − n₂ cosθ<sub>t</sub>)/(n₁ cosθ + n₂ cosθ<sub>t</sub>)</span> with <span class="muted">|r|=1</span> in TIR.</li>
          <li><b>In TIR:</b> <span class="muted">cosθ<sub>t</sub> = i κ</span> is imaginary (evanescent transmission), so <span class="muted">r = e^{iφ(θ)}</span>.</li>
          <li><b>Main derived result (symbolic):</b> For <span class="muted">n = n₂/n₁ &lt; 1</span> and <span class="muted">θ &gt; θ<sub>c</sub> = arcsin(n)</span>,</li>
        </ul>
        <div class="eqCard">
          <div class="eqRow">
            <pre class="eq" id="eq_xi">ξ = dφ/dθ = - 2 sinθ / sqrt( sin^2θ - n^2 )     (TE, TIR)</pre>
            <button class="btn small accent" data-copy="#eq_xi" aria-label="Copy xi equation">Copy</button>
          </div>
        </div>
        <ul>
          <li><b>Shift verification (fringes):</b> Two reflected waves produce the same fringe spacing as incident waves but shifted by <span class="muted">Δx = dφ / Δk<sub>x</sub></span>.</li>
          <li><b>Goos–Hänchen beam shift:</b> <span class="muted">D = - dφ/dk<sub>x</sub> = - ξ/(k₁ cosθ)</span> (with <span class="muted">k₁ = 2πn₁/λ₀</span>).</li>
        </ul>

        <div class="callouts">
          <div class="box good">
            <div class="label"><span class="dot"></span>Final answer type</div>
            <div class="muted">Symbolic expression for <b>ξ</b> (phase slope), plus derived lateral shift formulas for fringes and beams.</div>
          </div>
        </div>
      </section>

      <section id="primer">
        <h2>PART 0 — Concept Primer (theory before solving)</h2>

        <div class="grid2">
          <div>
            <h3>Core definitions (symbols & units)</h3>
            <ul>
              <li><b>Refractive indices:</b> <span class="muted">n₁</span> (incident medium), <span class="muted">n₂</span> (transmitted medium). Dimensionless.</li>
              <li><b>Incident angle:</b> <span class="muted">θ</span> measured from the normal. Units: radians (for calculus), degrees (for plots).</li>
              <li><b>Critical angle:</b> <span class="muted">θ<sub>c</sub> = arcsin(n₂/n₁)</span> (only if <span class="muted">n₁ &gt; n₂</span>).</li>
              <li><b>Wave number in medium 1:</b> <span class="muted">k₁ = 2π n₁/λ₀</span> (units: 1/m), where <span class="muted">λ₀</span> is vacuum wavelength.</li>
              <li><b>Parallel (tangential) wavevector component:</b> <span class="muted">k<sub>x</sub> = k₁ sinθ</span> (units: 1/m). Conserved across the interface.</li>
              <li><b>TE polarization:</b> “s-polarized” electric field perpendicular to the plane of incidence.</li>
            </ul>

            <h3>Physical meaning of key quantities</h3>
            <ul>
              <li><b>Reflection coefficient</b> <span class="muted">r</span> relates reflected and incident field amplitudes at the interface: <span class="muted">E<sub>r</sub> = r E<sub>i</sub></span>.</li>
              <li>In TIR, <span class="muted">|r|=1</span> (no net transmitted power), but the <b>phase</b> <span class="muted">φ(θ)</span> varies with angle: <span class="muted">r = e^{iφ(θ)}</span>.</li>
              <li>The <b>phase slope</b> with respect to angle or <span class="muted">k<sub>x</sub></span> controls where interference maxima land. A phase offset can mimic a <b>spatial shift</b>.</li>
              <li>The Goos–Hänchen shift is a <b>lateral displacement</b> of a reflected beam’s peak along the interface, linked to <span class="muted">dφ/dk<sub>x</sub></span>.</li>
            </ul>
          </div>

          <div>
            <div class="callouts">
              <div class="box warn">
                <div class="label"><span class="dot"></span>Validity conditions</div>
                <ul class="muted">
                  <li>Planar, lossless dielectric interface (no absorption).</li>
                  <li>Monochromatic steady-state fields.</li>
                  <li>Total internal reflection: <span>n₁ &gt; n₂</span> and <span>θ &gt; θ<sub>c</sub></span>.</li>
                  <li>Small increment: <span>dθ</span> is infinitesimal (linearization).</li>
                </ul>
              </div>
              <div class="box">
                <div class="label"><span class="dot"></span>Common models/approximations</div>
                <ul class="muted">
                  <li><b>Angular spectrum (beam)</b>: a beam is a superposition of plane waves with nearby angles; the reflected beam shift comes from how <span>dφ</span> varies across that spectrum.</li>
                  <li><b>Interference method</b>: compare fringe patterns produced by two close angles; a phase difference equals a fringe translation.</li>
                  <li><b>Stationary phase</b>: beam peak shift <span>D</span> equals <span>-dφ/dk<sub>x</sub></span>.</li>
                </ul>
              </div>
            </div>

            <h3>Mini intuition examples</h3>
            <ul>
              <li><b>Example A (fringes):</b> Two plane waves with close <span class="muted">k<sub>x</sub></span> create fringes along <span class="muted">x</span>. Adding a constant phase <span class="muted">δ</span> shifts the whole fringe pattern by <span class="muted">Δx = -δ/Δk<sub>x</sub></span>.</li>
              <li><b>Example B (near critical angle):</b> In TIR, the evanescent field penetrates farther as <span class="muted">θ → θ<sub>c</sub>+</span>, producing a rapidly varying reflection phase. Rapid phase variation implies a large lateral shift.</li>
            </ul>

            <div class="box bad" style="margin-top:10px;">
              <div class="label"><span class="dot"></span>What to watch for (pitfalls)</div>
              <ul class="muted">
                <li>Mixing degrees and radians in derivatives (<span>dφ/dθ</span> assumes radians).</li>
                <li>Forgetting <span>k<sub>x</sub> = k₁ sinθ</span> ⇒ <span>dk<sub>x</sub>/dθ = k₁ cosθ</span>.</li>
                <li>Sign conventions: whether the “shift” is defined as where the reflected pattern appears relative to incident, or vice versa.</li>
                <li>Using the wrong polarization (TM has a different phase).</li>
              </ul>
            </div>
          </div>
        </div>
      </section>

      <section id="analysis">
        <h2>PART 1 — Problem Analysis (no solving yet)</h2>

        <h3>Problem restatement (in plain words)</h3>
        <p>
          Two TE plane waves hit a dielectric interface from the higher-index side at angles <span class="muted">θ</span> and <span class="muted">θ+dθ</span>,
          both above the critical angle so the reflection is total. Even though the reflected amplitudes have unit magnitude, their reflection
          phases differ. If the differential phase retardation between the two reflected waves is <span class="muted">dφ = ξ dθ</span>,
          find <span class="muted">ξ</span>. Then interpret this phase difference by sketching the interference patterns of the two incident waves and the two reflected waves, and show that the reflected pattern is laterally shifted by an amount proportional to <span class="muted">ξ</span>. Finally connect this to the Goos–Hänchen effect for beams (many plane-wave components).
        </p>

        <h3>Given quantities</h3>
        <ul>
          <li>Two angles: <span class="muted">θ</span> and <span class="muted">θ + dθ</span>, with <span class="muted">dθ</span> infinitesimal.</li>
          <li>TE polarization (s-polarized).</li>
          <li>Total internal reflection at a planar interface: <span class="muted">n₁ &gt; n₂</span> and <span class="muted">θ &gt; θ<sub>c</sub></span>.</li>
        </ul>

        <h3>Unknowns / what must be found or shown</h3>
        <ul>
          <li>Find <span class="muted">ξ = dφ/dθ</span> for TE reflection phase in TIR.</li>
          <li>Show interference pattern shift: <span class="muted">Δx ∝ ξ</span>.</li>
          <li>Connect to the beam Goos–Hänchen shift: <span class="muted">D = - dφ/dk<sub>x</sub></span>.</li>
        </ul>

        <h3>Relevant principles (and why they apply)</h3>
        <ul>
          <li><b>Fresnel reflection coefficients</b> apply because we have a planar interface and plane waves.</li>
          <li><b>Snell’s law</b> fixes the transmitted angle; under TIR it implies an imaginary normal component (evanescent field).</li>
          <li><b>Interference</b>: superposition of two waves gives intensity fringes; a phase offset translates fringes.</li>
          <li><b>Angular spectrum / stationary phase</b>: a beam peak shift is governed by derivative of phase with respect to transverse wavevector.</li>
        </ul>
        <p class="muted">
          We do <b>not</b> need energy conservation beyond using lossless media (to ensure <span>|r|=1</span>), and we do not need full Maxwell boundary derivations—Fresnel forms are sufficient.
        </p>

        <div class="callouts">
          <div class="box warn">
            <div class="label"><span class="dot"></span>Assumptions (explicit)</div>
            <ul class="muted">
              <li>Lossless, isotropic dielectrics; no absorption and no surface roughness.</li>
              <li>Monochromatic waves; time dependence <span>e^{-iωt}</span> (or equivalent) is implicit.</li>
              <li>Small-angle increment: keep only first order in <span>dθ</span>.</li>
              <li>Interface coordinate: <span>x</span> along the interface, <span>z</span> normal.</li>
            </ul>
          </div>
        </div>

        <h3>Possible approaches (compare)</h3>
        <ul>
          <li><b>(A) Direct Fresnel-phase differentiation</b>: write TE reflection coefficient in TIR as <span class="muted">r=e^{iφ(θ)}</span>, then compute <span class="muted">dφ/dθ</span>. <span class="muted">Pros:</span> shortest, transparent. <span class="muted">Cons:</span> requires careful algebra simplification.</li>
          <li><b>(B) Complex angle method</b>: express transmitted angle as complex and derive phase from boundary conditions. <span class="muted">Pros:</span> physically rich. <span class="muted">Cons:</span> longer than needed.</li>
          <li><b>(C) Stationary-phase beam derivation first</b>: derive shift <span class="muted">D=-dφ/dk<sub>x</sub></span> then back out <span class="muted">dφ/dθ</span>. <span class="muted">Pros:</span> connects immediately to GH. <span class="muted">Cons:</span> still needs φ(θ).</li>
        </ul>
        <p><b>Chosen approach:</b> (A) for <span class="muted">ξ</span> plus a clean interference argument for fringe translation, then a short beam connection via <span class="muted">k<sub>x</sub></span> and stationary phase.</p>
      </section>

      <section id="strategy">
        <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

        <ol>
          <li><b>Goal:</b> Write TE Fresnel reflection coefficient. <b>Tool:</b> Fresnel formulas. <b>Meaning:</b> encodes amplitude & phase on reflection.</li>
          <li><b>Goal:</b> Enforce TIR. <b>Tool:</b> Snell’s law and imaginary <span class="muted">cosθ<sub>t</sub></span>. <b>Meaning:</b> transmitted wave is evanescent; reflection magnitude becomes 1.</li>
          <li><b>Goal:</b> Extract reflection phase <span class="muted">φ(θ)</span>. <b>Tool:</b> express ratio as <span class="muted">(a-ib)/(a+ib)=e^{iφ}</span>. <b>Meaning:</b> identify angle-dependent phase.</li>
          <li><b>Goal:</b> Differentiate <span class="muted">φ(θ)</span>. <b>Tool:</b> calculus + algebraic simplification (key trick: simplify <span class="muted">1+u²</span>). <b>Meaning:</b> obtain <span class="muted">ξ=dφ/dθ</span>.</li>
          <li><b>Goal:</b> Build interference phase along interface. <b>Tool:</b> <span class="muted">k<sub>x</sub>=k₁ sinθ</span> and small-angle difference. <b>Meaning:</b> fringe spacing depends on <span class="muted">Δk<sub>x</sub></span>.</li>
          <li><b>Goal:</b> Show shift for reflected fringes. <b>Tool:</b> equate <span class="muted">cos(Δk<sub>x</sub>x)</span> vs <span class="muted">cos(Δk<sub>x</sub>x + dφ)</span>. <b>Meaning:</b> phase offset equals spatial translation.</li>
          <li><b>Goal:</b> Convert to beam shift. <b>Tool:</b> <span class="muted">D=-dφ/dk<sub>x</sub></span> and chain rule. <b>Meaning:</b> GH shift is group-delay-like in transverse direction.</li>
        </ol>

        <div class="callouts">
          <div class="box warn">
            <div class="label"><span class="dot"></span>Common mistakes & quick tips</div>
            <ul class="muted">
              <li><b>Radians:</b> Use radians in <span>dφ/dθ</span>. If you slide θ in degrees, convert internally.</li>
              <li><b>Critical angle behavior:</b> Expect divergence as <span>θ→θ<sub>c</sub>+</span>. If your expression stays finite, something is off.</li>
              <li><b>Use the simplification:</b> in TE, <span>1+u² = (1-n²)/cos²θ</span> makes the derivative collapse nicely.</li>
              <li><b>Shift sign:</b> Decide what “positive x” means and whether you compare incident-to-reflected or reflected-to-incident fringe maxima.</li>
            </ul>
          </div>
        </div>
      </section>

      <section id="solution">
        <h2>PART 3 — Full Solution (detailed + teaching)</h2>

        <h3>Qualitative intuition first</h3>
        <p>
          In total internal reflection, the transmitted field does not propagate away; it becomes an evanescent wave that “leans” along the interface.
          That evanescent coupling causes the reflection to acquire an angle-dependent phase. If you slightly change the incident angle, the phase changes.
          When two nearby angles interfere, that extra phase can be reinterpreted as a <b>shift of the entire fringe pattern</b> along the interface.
          For a beam (many nearby angles), this becomes a <b>lateral displacement of the reflected beam peak</b>: the Goos–Hänchen shift.
        </p>

        <div class="grid2">
          <div>
            <h3>Step 1 — TE Fresnel coefficient and TIR condition</h3>
            <p>
              Consider an interface at <span class="muted">z=0</span>, with medium 1 (<span class="muted">n₁</span>) for <span class="muted">z&gt;0</span> and medium 2 (<span class="muted">n₂</span>) for <span class="muted">z&lt;0</span>.
              A plane wave in medium 1 is incident at angle <span class="muted">θ</span> (from the normal).
            </p>

            <div class="eqCard">
              <div class="eqRow">
                <pre class="eq" id="eq_fresnel_te">r_TE(θ) = (n1 cosθ - n2 cosθt) / (n1 cosθ + n2 cosθt)</pre>
                <button class="btn small accent" data-copy="#eq_fresnel_te">Copy</button>
              </div>
            </div>

            <p>
              Snell’s law gives <span class="muted">n₁ sinθ = n₂ sinθ<sub>t</sub></span>. For TIR, <span class="muted">n₁&gt;n₂</span> and <span class="muted">θ&gt;θ<sub>c</sub></span> with
              <span class="muted">θ<sub>c</sub>=arcsin(n₂/n₁)</span>. Then <span class="muted">sinθ<sub>t</sub> = (n₁/n₂) sinθ &gt; 1</span>, so <span class="muted">cosθ<sub>t</sub></span> becomes imaginary:
            </p>

            <div class="eqCard">
              <div class="eqRow">
                <pre class="eq" id="eq_cost">Let n = n2/n1 &lt; 1.
For θ &gt; θc:  cosθt = i κ,  where κ = sqrt( (sinθ/n)^2 - 1 ) = sqrt( sin^2θ - n^2 ) / n</pre>
                <button class="btn small accent" data-copy="#eq_cost">Copy</button>
              </div>
            </div>

            <p>
              Substitute into <span class="muted">r<sub>TE</sub></span>:
            </p>
            <div class="eqCard">
              <div class="eqRow">
                <pre class="eq" id="eq_r_tir">r_TE = (n1 cosθ - i n2 κ)/(n1 cosθ + i n2 κ)
     = (cosθ - i n κ)/(cosθ + i n κ)  (after dividing by n1)
with  n κ = sqrt(sin^2θ - n^2).</pre>
                <button class="btn small accent" data-copy="#eq_r_tir">Copy</button>
              </div>
            </div>

            <p>
              A ratio of the form <span class="muted">(a-ib)/(a+ib)</span> has unit magnitude and phase <span class="muted">-2 arctan(b/a)</span>.
              Therefore the TE reflection phase in TIR is:
            </p>
            <div class="eqCard">
              <div class="eqRow">
                <pre class="eq" id="eq_phi">Define  a = cosθ,  b = sqrt(sin^2θ - n^2).
Then r_TE = (a - i b)/(a + i b) = exp(i φ_TE),
so φ_TE(θ) = -2 arctan( b/a )
          = -2 arctan( sqrt(sin^2θ - n^2) / cosθ ).</pre>
                <button class="btn small accent" data-copy="#eq_phi">Copy</button>
              </div>
            </div>
          </div>

          <div>
            <h3>Step 2 — Differentiate to get ξ = dφ/dθ</h3>
            <p>
              We are told the differential phase retardation between reflections at <span class="muted">θ</span> and <span class="muted">θ+dθ</span> is
              <span class="muted">dφ = ξ dθ</span>, so <span class="muted">ξ = dφ/dθ</span>.
              Use the compact substitution:
            </p>

            <div class="eqCard">
              <div class="eqRow">
                <pre class="eq" id="eq_u">Let u(θ) = sqrt(sin^2θ - n^2) / cosθ.
Then φ(θ) = -2 arctan u.</pre>
                <button class="btn small accent" data-copy="#eq_u">Copy</button>
              </div>
            </div>

            <p>
              Differentiate:
            </p>
            <div class="eqCard">
              <div class="eqRow">
                <pre class="eq" id="eq_dphi">dφ/dθ = -2 * (1/(1+u^2)) * du/dθ.</pre>
                <button class="btn small accent" data-copy="#eq_dphi">Copy</button>
              </div>
            </div>

            <p>
              Now compute the two pieces carefully.
            </p>

            <p class="muted"><b>Piece A: simplify 1+u²</b></p>
            <div class="eqCard">
              <div class="eqRow">
                <pre class="eq" id="eq_1pu2">u^2 = (sin^2θ - n^2)/cos^2θ
1 + u^2 = (cos^2θ + sin^2θ - n^2)/cos^2θ
       = (1 - n^2)/cos^2θ</pre>
                <button class="btn small accent" data-copy="#eq_1pu2">Copy</button>
              </div>
            </div>

            <p class="muted"><b>Piece B: compute du/dθ</b></p>
            <p>
              Let <span class="muted">a(θ)=sqrt(sin²θ - n²)</span>, so <span class="muted">u=a/cosθ</span>.
            </p>
            <div class="eqCard">
              <div class="eqRow">
                <pre class="eq" id="eq_du">a = sqrt(sin^2θ - n^2)
da/dθ = (1/(2a)) * 2 sinθ cosθ = (sinθ cosθ)/a

u = a/cosθ
du/dθ = (da/dθ)(1/cosθ) + a * d(1/cosθ)/dθ
      = (sinθ cosθ)/(a cosθ) + a*(sinθ/cos^2θ)
      = sinθ/a + (a sinθ)/cos^2θ
      = sinθ (cos^2θ + a^2)/(a cos^2θ)
But cos^2θ + a^2 = cos^2θ + (sin^2θ - n^2) = 1 - n^2
So du/dθ = sinθ (1 - n^2)/(a cos^2θ).</pre>
                <button class="btn small accent" data-copy="#eq_du">Copy</button>
              </div>
            </div>

            <p class="muted"><b>Combine A and B</b></p>
            <div class="eqCard">
              <div class="eqRow">
                <pre class="eq" id="eq_xi_full">dφ/dθ = -2 * [cos^2θ/(1 - n^2)] * [ sinθ (1 - n^2)/(a cos^2θ) ]
      = -2 sinθ / a
      = -2 sinθ / sqrt(sin^2θ - n^2).</pre>
                <button class="btn small accent2" data-copy="#eq_xi_full">Copy</button>
              </div>
            </div>

            <div class="callouts" style="margin-top:10px;">
              <div class="box good">
                <div class="label"><span class="dot"></span>Key result (boxed)</div>
                <div class="eqCard" style="margin-top:8px;">
                  <div class="eqRow">
                    <pre class="eq" id="final_answer">TE (s) polarization, TIR (θ &gt; θc), with n = n2/n1:

ξ = dφ/dθ = - 2 sinθ / sqrt( sin^2θ - n^2 )   (θ in radians)</pre>
                    <button class="btn small accent2" data-copy="#final_answer">Copy</button>
                  </div>
                </div>
                <p class="muted" style="margin-top:8px;">
                  The negative sign reflects the chosen phase convention (here φ is negative and becomes more negative as θ increases).
                  The magnitude grows large near the critical angle where the denominator approaches zero.
                </p>
              </div>
            </div>

            <h3>Step 3 — Interference patterns and lateral shift ∝ ξ</h3>
            <p>
              Consider two incident plane waves in medium 1 with angles <span class="muted">θ</span> and <span class="muted">θ+dθ</span>.
              Along the interface (x-direction), each has tangential wavevector
              <span class="muted">k<sub>x</sub>=k₁ sinθ</span>.
              For a small angle difference,
            </p>
            <div class="eqCard">
              <div class="eqRow">
                <pre class="eq" id="eq_dkx">Δk_x = k1 sin(θ+dθ) - k1 sinθ ≈ k1 cosθ · dθ.</pre>
                <button class="btn small accent" data-copy="#eq_dkx">Copy</button>
              </div>
            </div>

            <p>
              The incident interference intensity along x (at fixed z near the interface) contains a term like:
            </p>
            <div class="eqCard">
              <div class="eqRow">
                <pre class="eq" id="eq_Iinc">I_inc(x) ∝ 1 + cos(Δk_x x)   (up to an overall constant).</pre>
                <button class="btn small accent" data-copy="#eq_Iinc">Copy</button>
              </div>
            </div>

            <p>
              After reflection, both waves acquire reflection phases <span class="muted">φ(θ)</span> and <span class="muted">φ(θ+dθ)=φ(θ)+dφ</span>.
              Their reflected interference becomes:
            </p>
            <div class="eqCard">
              <div class="eqRow">
                <pre class="eq" id="eq_Iref">I_ref(x) ∝ 1 + cos(Δk_x x + dφ).</pre>
                <button class="btn small accent" data-copy="#eq_Iref">Copy</button>
              </div>
            </div>

            <p>
              A cosine with an added phase is just a shifted cosine:
              <span class="muted">cos(Δk_x x + dφ) = cos[Δk_x (x + Δx)]</span> if
              <span class="muted">Δk_x Δx = dφ</span>. Therefore the reflected fringe pattern is translated by
            </p>

            <div class="eqCard">
              <div class="eqRow">
                <pre class="eq" id="eq_shift_fringes">Δx = dφ / Δk_x ≈ (ξ dθ)/(k1 cosθ dθ) = ξ/(k1 cosθ).</pre>
                <button class="btn small accent2" data-copy="#eq_shift_fringes">Copy</button>
              </div>
            </div>

            <p class="muted">
              This directly “verifies” that the lateral displacement is proportional to <span>ξ</span>.
              The sign tells which direction the maxima shift for your chosen x-axis.
            </p>

            <h3>Step 4 — Beam (Goos–Hänchen) shift</h3>
            <p>
              A real beam is a superposition of many plane waves with slightly different <span class="muted">k<sub>x</sub></span>.
              The reflected field includes the phase factor <span class="muted">e^{iφ(k_x)}</span>.
              A standard stationary-phase (or wave-packet) argument gives the lateral shift of the reflected beam peak:
            </p>

            <div class="eqCard">
              <div class="eqRow">
                <pre class="eq" id="eq_GH">D = - dφ/dk_x.</pre>
                <button class="btn small accent2" data-copy="#eq_GH">Copy</button>
              </div>
            </div>

            <p>
              Using <span class="muted">k_x = k1 sinθ</span> ⇒ <span class="muted">dk_x/dθ = k1 cosθ</span>, we get:
            </p>

            <div class="eqCard">
              <div class="eqRow">
                <pre class="eq" id="eq_D_chain">D = - (dφ/dθ)/(dk_x/dθ) = - ξ/(k1 cosθ).</pre>
                <button class="btn small accent2" data-copy="#eq_D_chain">Copy</button>
              </div>
            </div>

            <div class="callouts" style="margin-top:10px;">
              <div class="box">
                <div class="label"><span class="dot"></span>Sanity checks</div>
                <ul class="muted">
                  <li><b>Units:</b> ξ is dimensionless (phase per radian). <span>D</span> has units of length because <span>k1</span> is 1/length.</li>
                  <li><b>Limiting case:</b> as <span>θ→θc+</span>, <span>sin²θ - n² → 0+</span> so <span>|ξ|→∞</span> and shifts become large (as expected near critical angle).</li>
                  <li><b>Deep TIR:</b> as <span>θ→90°</span>, <span>sinθ→1</span>, denominator → <span>sqrt(1-n²)</span>, so ξ approaches a finite value.</li>
                  <li><b>Direction:</b> the sign depends on phase convention; the physically measured shift is typically reported as a positive magnitude with direction specified separately.</li>
                </ul>
              </div>
            </div>

          </div>
        </div>

        <div class="hr"></div>

        <h3>Connect to the diagram & what you should “see”</h3>
        <p>
          In the diagram below, the evanescent field in medium 2 (below the interface) indicates energy does not propagate away, but the boundary conditions still allow a
          nonzero tangential field and phase evolution. That angle-dependent phase is what you differentiate to get <span class="muted">ξ</span>.
          The plots show (i) <span class="muted">ξ(θ)</span>, (ii) the beam shift <span class="muted">D(θ)</span>, and (iii) a direct interference-fringe comparison where the reflected fringes are the incident fringes shifted by an amount proportional to <span class="muted">ξ</span>.
        </p>
      </section>

      <section id="deeper">
        <h2>PART 4 — Deeper Understanding (theory around the result)</h2>

        <h3>Re-interpret the final formula</h3>
        <p>
          The TE phase slope
          <span class="muted">ξ = -2 sinθ / sqrt(sin²θ - n²)</span>
          is controlled by two competing factors:
        </p>
        <ul>
          <li><b>Numerator sinθ:</b> grows with angle, representing stronger tangential momentum along the interface.</li>
          <li><b>Denominator sqrt(sin²θ − n²):</b> measures how far above critical you are. Near <span class="muted">θc</span>, this becomes tiny, so the phase is extremely sensitive to angle.</li>
          <li><b>Index ratio n = n₂/n₁:</b> smaller n (bigger index contrast) increases <span class="muted">sqrt(1-n²)</span> and generally reduces the blow-up region width, but the critical angle moves and the overall behavior shifts.</li>
        </ul>

        <h3>How parameter changes affect outcomes (connect to plots)</h3>
        <ul>
          <li>Increasing <span class="muted">θ</span> from just above <span class="muted">θc</span> to larger angles decreases the “critical enhancement” and makes <span class="muted">|ξ|</span> settle to a finite value.</li>
          <li>Increasing <span class="muted">n = n₂/n₁</span> (reducing index contrast) pushes <span class="muted">θc</span> higher and makes the divergence occur closer to grazing incidence.</li>
          <li>The GH shift magnitude follows <span class="muted">|D| ∝ |ξ|/(k₁ cosθ)</span>, so it tends to grow both near <span class="muted">θc</span> and near <span class="muted">90°</span> because <span class="muted">cosθ</span> becomes small.</li>
        </ul>

        <h3>Alternative derivation idea (brief)</h3>
        <p class="muted">
          Instead of differentiating <span>φ(θ)</span> directly, you can derive the beam shift by writing the reflected field as an angular spectrum
          <span>E_r(x) = ∫ A(k_x) e^{i(k_x x + φ(k_x))} dk_x</span> and applying stationary phase.
          The peak occurs where <span>d/dk_x(k_x x + φ)=0</span>, giving <span>x = -dφ/dk_x</span> immediately.
          Then convert to <span>dφ/dθ</span> using <span>k_x = k₁ sinθ</span>.
        </p>

        <h3>Concept checks (self-test)</h3>
        <ul>
          <li><b>Q:</b> Why can there be a beam shift if <span>|r|=1</span> in TIR? <b>A:</b> Because shifting comes from <b>phase variation</b> across the beam’s angular spectrum, not from amplitude loss.</li>
          <li><b>Q:</b> What quantity is “conserved” across the interface that makes interference along x simple? <b>A:</b> The tangential wavevector component <span>k_x</span>.</li>
          <li><b>Q:</b> What happens to <span>ξ</span> near the critical angle? <b>A:</b> It diverges like <span>1/√(sin²θ-n²)</span>, meaning the phase becomes extremely sensitive to angle.</li>
          <li><b>Q:</b> Would TM polarization have the same ξ? <b>A:</b> No—TM has a different Fresnel phase in TIR; the shift differs quantitatively.</li>
        </ul>
      </section>

      <section id="vizguide">
        <h2>PART 5 — Visualization Guide (how to read the plots)</h2>

        <div class="vizGrid">
          <figure class="tall">
            <div class="figHead">
              <div>
                <p class="figTitle">Diagram: TIR geometry and phase-driven shift</p>
                <p class="figSub">Interface, incident/reflected rays, evanescent wave, and lateral shift</p>
              </div>
              <div class="rowBtns">
                <button class="btn small" id="btnReset">Reset</button>
              </div>
            </div>
            <div class="canvasWrap">
              <canvas id="cDiagram" aria-label="TIR diagram"></canvas>
            </div>
          </figure>

          <figure class="tall">
            <div class="figHead">
              <div>
                <p class="figTitle">Main Plot: ξ(θ) = dφ/dθ (TE, TIR)</p>
                <p class="figSub">Angle sensitivity of TIR phase (dimensionless, per radian)</p>
              </div>
              <div class="rowBtns">
                <button class="btn small accent" data-copy="#eq_xi_full">Copy ξ</button>
              </div>
            </div>
            <div class="canvasWrap">
              <canvas id="cXi" aria-label="Plot of xi versus theta"></canvas>
            </div>
          </figure>

          <figure>
            <div class="figHead">
              <div>
                <p class="figTitle">Secondary Plot: Beam GH shift D(θ)</p>
                <p class="figSub">Example uses λ₀ = 633 nm; output shown in µm and in λ₀</p>
              </div>
              <div class="rowBtns">
                <button class="btn small accent2" data-copy="#eq_D_chain">Copy D</button>
              </div>
            </div>
            <div class="canvasWrap">
              <canvas id="cD" aria-label="Plot of Goos-Hanchen shift versus theta"></canvas>
            </div>
          </figure>

          <figure>
            <div class="figHead">
              <div>
                <p class="figTitle">Fringe Check: incident vs reflected interference along x</p>
                <p class="figSub">Reflected fringes are shifted by Δx ≈ ξ/(k₁ cosθ)</p>
              </div>
              <div class="rowBtns">
                <button class="btn small" id="btnToggleUnits">x units: µm</button>
              </div>
            </div>
            <div class="canvasWrap">
              <canvas id="cFringe" aria-label="Interference fringes plot"></canvas>
            </div>
          </figure>
        </div>

        <div class="controls" style="margin-top:12px;">
          <div class="ctrl">
            <label>
              <span>Incidence angle θ (above critical)</span>
              <span class="val" id="valTheta">—</span>
            </label>
            <input type="range" id="slTheta" min="0" max="1" step="0.001" value="0.55"/>
            <p class="muted" style="margin:8px 0 0;">
              Slider runs from <span class="muted">θ = θc + 0.2°</span> to <span class="muted">89.5°</span>.
              Watch how ξ spikes near θc.
            </p>
          </div>

          <div class="ctrl">
            <label>
              <span>Index ratio n = n₂/n₁</span>
              <span class="val" id="valN">—</span>
            </label>
            <input type="range" id="slN" min="0.20" max="0.99" step="0.001" value="0.667"/>
            <p class="muted" style="margin:8px 0 0;">
              Example: glass–air is roughly <span class="muted">n₂/n₁ ≈ 1/1.5 ≈ 0.667</span>.
            </p>
          </div>

          <div class="ctrl">
            <label>
              <span>Vacuum wavelength λ₀ (for D plot)</span>
              <span class="val" id="valLam">633 nm</span>
            </label>
            <input type="range" id="slLam" min="400" max="1550" step="1" value="633"/>
            <p class="muted" style="margin:8px 0 0;">
              Only affects the numeric scale of <span class="muted">D</span>; <span class="muted">ξ</span> is purely geometric.
            </p>
          </div>

          <div class="ctrl">
            <label>
              <span>Small angular separation dθ (for fringes)</span>
              <span class="val" id="valDtheta">0.50°</span>
            </label>
            <input type="range" id="slDtheta" min="0.05" max="2.0" step="0.01" value="0.50"/>
            <p class="muted" style="margin:8px 0 0;">
              Controls fringe spacing (via <span class="muted">Δk<sub>x</sub> ≈ k₁ cosθ dθ</span>) but the predicted shift still tracks <span class="muted">ξ</span>.
            </p>
          </div>
        </div>

        <div class="kpiGrid" aria-label="Live computed values">
          <div class="kpi">
            <p class="k">Critical angle θc</p>
            <p class="v" id="kpiTc">—</p>
          </div>
          <div class="kpi">
            <p class="k">Phase slope ξ = dφ/dθ</p>
            <p class="v" id="kpiXi">—</p>
          </div>
          <div class="kpi">
            <p class="k">GH shift D = - ξ/(k₁ cosθ)</p>
            <p class="v" id="kpiD">—</p>
          </div>
        </div>

        <div class="callouts" style="margin-top:12px;">
          <div class="box">
            <div class="label"><span class="dot"></span>What the interactive controls change</div>
            <ul class="muted">
              <li><b>θ slider:</b> updates the marker on all plots, the diagram ray angles, ξ and D values, and the fringe translation.</li>
              <li><b>n slider:</b> changes θc and the strength/location of the ξ divergence; updates all plots and the diagram.</li>
              <li><b>λ₀ slider:</b> rescales <span>D</span> numerically (since <span>k₁ = 2πn₁/λ₀</span>) and updates the D plot and fringe x-scale.</li>
              <li><b>dθ slider:</b> changes interference fringe spacing and the visibility of the shift (the shift itself is set by ξ and k₁, but the plotted curves depend on dθ).</li>
            </ul>
          </div>
        </div>
      </section>
    </article>
  </main>

  <footer>
    <div class="muted">
      Built as a self-contained learning article: Fresnel phase in TIR → phase derivative ξ → interference translation → Goos–Hänchen beam shift.
      (TE polarization.) No external libraries.
    </div>
  </footer>

  <script>
    // ---------- Utilities ----------
    const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
    const rad = (deg)=>deg*Math.PI/180;
    const deg = (rad)=>rad*180/Math.PI;

    function fmt(x, digits=4){
      if(!isFinite(x)) return "∞";
      const ax = Math.abs(x);
      if(ax !== 0 && (ax < 1e-3 || ax > 1e4)) return x.toExponential(3);
      return x.toFixed(digits);
    }
    function fmtDeg(x){ return fmt(x,2) + "°"; }

    async function copyText(text){
      try{
        await navigator.clipboard.writeText(text);
        return true;
      }catch(e){
        // fallback
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        let ok=false;
        try{ ok = document.execCommand('copy'); }catch(err){}
        document.body.removeChild(ta);
        return ok;
      }
    }
    function bindCopyButtons(){
      document.querySelectorAll("[data-copy]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const sel = btn.getAttribute("data-copy");
          const el = document.querySelector(sel);
          if(!el) return;
          const ok = await copyText(el.textContent.trim());
          const old = btn.textContent;
          btn.textContent = ok ? "Copied ✓" : "Copy failed";
          setTimeout(()=>btn.textContent = old, 900);
        });
      });
    }

    // HiDPI canvas setup
    function fitCanvas(canvas){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect.width * dpr));
      const h = Math.max(2, Math.floor(rect.height * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {ctx, w: rect.width, h: rect.height, dpr};
    }

    function drawPanelBG(ctx, w, h){
      ctx.clearRect(0,0,w,h);
      // soft vignette
      const g = ctx.createRadialGradient(w*0.35,h*0.25, 10, w*0.55,h*0.55, Math.max(w,h));
      g.addColorStop(0, "rgba(125,211,252,0.12)");
      g.addColorStop(0.45, "rgba(167,139,250,0.06)");
      g.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = "rgba(6,10,22,0.85)";
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);
    }

    // Simple plotting with axes/ticks/gridlines
    function niceTicks(min, max, target=6){
      const span = max-min;
      if(span<=0 || !isFinite(span)) return {step:1, start:min, end:max};
      const raw = span/target;
      const pow = Math.pow(10, Math.floor(Math.log10(raw)));
      const frac = raw/pow;
      let niceFrac = 1;
      if(frac<1.5) niceFrac = 1;
      else if(frac<3) niceFrac = 2;
      else if(frac<7) niceFrac = 5;
      else niceFrac = 10;
      const step = niceFrac*pow;
      const start = Math.floor(min/step)*step;
      const end = Math.ceil(max/step)*step;
      return {step, start, end};
    }

    function plotAxes(ctx, w, h, box, xlim, ylim, labels, title){
      const {x,y,ww,hh} = box;
      // panel
      ctx.save();
      ctx.translate(x,y);

      // background inside plot
      ctx.fillStyle = "rgba(0,0,0,0.18)";
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      roundRect(ctx, 0, 0, ww, hh, 10);
      ctx.fill(); ctx.stroke();

      const padL = 48, padR = 14, padT = 28, padB = 42;
      const px0 = padL, py0 = hh-padB;
      const px1 = ww-padR, py1 = padT;

      // Title
      ctx.fillStyle = "rgba(232,236,255,0.95)";
      ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(title, padL, 18);

      // Grid + ticks
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;

      const xt = niceTicks(xlim.min, xlim.max, 6);
      const yt = niceTicks(ylim.min, ylim.max, 6);

      // x grid
      for(let xv=xt.start; xv<=xt.end+1e-12; xv+=xt.step){
        const X = map(xv, xlim.min, xlim.max, px0, px1);
        ctx.beginPath();
        ctx.moveTo(X, py0);
        ctx.lineTo(X, py1);
        ctx.stroke();
      }
      // y grid
      for(let yv=yt.start; yv<=yt.end+1e-12; yv+=yt.step){
        const Y = map(yv, ylim.min, ylim.max, py0, py1);
        ctx.beginPath();
        ctx.moveTo(px0, Y);
        ctx.lineTo(px1, Y);
        ctx.stroke();
      }

      // Axes
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.beginPath();
      ctx.moveTo(px0, py0); ctx.lineTo(px1, py0);
      ctx.moveTo(px0, py0); ctx.lineTo(px0, py1);
      ctx.stroke();

      // Tick labels
      ctx.fillStyle = "rgba(184,192,255,0.95)";
      ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";

      for(let xv=xt.start; xv<=xt.end+1e-12; xv+=xt.step){
        const X = map(xv, xlim.min, xlim.max, px0, px1);
        ctx.beginPath();
        ctx.moveTo(X, py0); ctx.lineTo(X, py0+4);
        ctx.strokeStyle = "rgba(255,255,255,0.25)";
        ctx.stroke();
        ctx.fillText(trimNum(xv), X-10, py0+18);
      }
      for(let yv=yt.start; yv<=yt.end+1e-12; yv+=yt.step){
        const Y = map(yv, ylim.min, ylim.max, py0, py1);
        ctx.beginPath();
        ctx.moveTo(px0-4, Y); ctx.lineTo(px0, Y);
        ctx.strokeStyle = "rgba(255,255,255,0.25)";
        ctx.stroke();
        ctx.fillText(trimNum(yv), 4, Y+4);
      }

      // Axis labels
      ctx.fillStyle = "rgba(232,236,255,0.92)";
      ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(labels.x, (px0+px1)/2 - ctx.measureText(labels.x).width/2, hh-10);

      ctx.save();
      ctx.translate(14, (py0+py1)/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(labels.y, -ctx.measureText(labels.y).width/2, 0);
      ctx.restore();

      ctx.restore();

      // Return plot area mapping
      return {
        plotRect: {x: box.x+48, y: box.y+28, w: box.ww-48-14, h: box.hh-28-42},
        pads: {padL:48,padR:14,padT:28,padB:42}
      };
    }

    function map(v, a,b, c,d){
      if(b===a) return (c+d)/2;
      return c + (v-a)*(d-c)/(b-a);
    }
    function trimNum(x){
      if(!isFinite(x)) return "∞";
      const ax = Math.abs(x);
      if(ax>9999 || (ax>0 && ax<0.001)) return x.toExponential(1);
      const s = x.toFixed(2);
      return s.replace(/\.00$/,"").replace(/(\.\d)0$/,"$1");
    }
    function roundRect(ctx, x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    function polyline(ctx, pts){
      ctx.beginPath();
      for(let i=0;i<pts.length;i++){
        const p=pts[i];
        if(i===0) ctx.moveTo(p.x,p.y);
        else ctx.lineTo(p.x,p.y);
      }
      ctx.stroke();
    }

    // ---------- Physics model ----------
    // Use n = n2/n1; choose n1 example for k1 scale (for D plot).
    // TE phase in TIR: φ = -2 atan( sqrt(sin^2θ - n^2) / cosθ )
    // ξ = dφ/dθ = -2 sinθ / sqrt(sin^2θ - n^2)
    function thetaCritical(n){ return Math.asin(clamp(n, 0, 1)); }

    function phiTE(theta, n){
      const s = Math.sin(theta);
      const c = Math.cos(theta);
      const under = s*s - n*n;
      if(under <= 0) return NaN; // not in TIR
      const b = Math.sqrt(under);
      const u = b / c;
      return -2*Math.atan(u);
    }

    function xiTE(theta, n){
      const s = Math.sin(theta);
      const under = s*s - n*n;
      if(under <= 0) return NaN;
      return -2*s/Math.sqrt(under);
    }

    // GH shift: D = - dφ/dkx = - ξ / (k1 cosθ), with k1 = 2π n1 / λ0
    function ghShift(theta, n, n1, lambda0){
      const xi = xiTE(theta, n);
      const c = Math.cos(theta);
      const k1 = 2*Math.PI*n1/lambda0;
      if(!isFinite(xi) || c===0) return NaN;
      return -xi/(k1*c);
    }

    // Fringe phase difference between angles θ and θ+dθ:
    function deltaKx(theta, dtheta, n1, lambda0){
      const k1 = 2*Math.PI*n1/lambda0;
      return k1*Math.cos(theta)*dtheta;
    }

    // ---------- State + DOM ----------
    const cDiagram = document.getElementById("cDiagram");
    const cXi = document.getElementById("cXi");
    const cD = document.getElementById("cD");
    const cFringe = document.getElementById("cFringe");

    const slTheta = document.getElementById("slTheta");
    const slN = document.getElementById("slN");
    const slLam = document.getElementById("slLam");
    const slDtheta = document.getElementById("slDtheta");

    const valTheta = document.getElementById("valTheta");
    const valN = document.getElementById("valN");
    const valLam = document.getElementById("valLam");
    const valDtheta = document.getElementById("valDtheta");

    const kpiTc = document.getElementById("kpiTc");
    const kpiXi = document.getElementById("kpiXi");
    const kpiD = document.getElementById("kpiD");

    const btnReset = document.getElementById("btnReset");
    const btnToggleUnits = document.getElementById("btnToggleUnits");

    let state = {
      n: parseFloat(slN.value),
      // theta is mapped from slider [0,1] to [theta_c+0.2deg, 89.5deg]
      theta: 0,
      lambda0_nm: parseFloat(slLam.value),
      dtheta_deg: parseFloat(slDtheta.value),
      n1: 1.50,           // example for plotting numeric shifts (can be considered "example value")
      xUnits: "um"        // toggle between um and lambda0
    };

    function updateThetaFromSlider(){
      const n = state.n;
      const tc = thetaCritical(n);
      const thMin = tc + rad(0.2);
      const thMax = rad(89.5);
      const t = parseFloat(slTheta.value);
      state.theta = thMin + t*(thMax - thMin);
    }

    function updateUI(){
      const n = state.n;
      const tc = thetaCritical(n);
      const th = state.theta;
      const lam_m = state.lambda0_nm * 1e-9;
      const xi = xiTE(th, n);
      const D = ghShift(th, n, state.n1, lam_m);

      valN.textContent = fmt(n,3);
      valLam.textContent = `${Math.round(state.lambda0_nm)} nm`;
      valDtheta.textContent = `${fmt(state.dtheta_deg,2)}°`;

      valTheta.textContent = `${fmtDeg(deg(th))} (θc=${fmtDeg(deg(tc))})`;

      kpiTc.textContent = `${fmtDeg(deg(tc))}`;
      kpiXi.textContent = isFinite(xi) ? `${fmt(xi,5)}  (per rad)` : "—";
      if(isFinite(D)){
        const D_um = D*1e6;
        const D_lam0 = D/lam_m;
        kpiD.textContent = `${fmt(D_um,4)} µm  (${fmt(D_lam0,4)} λ₀)`;
      }else{
        kpiD.textContent = "—";
      }

      btnToggleUnits.textContent = state.xUnits === "um" ? "x units: µm" : "x units: λ₀";
    }

    // ---------- Drawing: Diagram ----------
    function drawDiagram(){
      const {ctx, w, h} = fitCanvas(cDiagram);
      drawPanelBG(ctx, w, h);

      const n = state.n;
      const n1 = state.n1;
      const n2 = n* n1;
      const th = state.theta;
      const tc = thetaCritical(n);

      // Coordinate frame
      const margin = 18;
      const cx = w*0.52;
      const cy = h*0.55;
      const ifaceY = cy;
      const left = margin, right = w-margin, top = margin, bottom = h-margin;

      // Interface
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(left, ifaceY);
      ctx.lineTo(right, ifaceY);
      ctx.stroke();

      // Media labels
      ctx.fillStyle = "rgba(184,192,255,0.92)";
      ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(`Medium 1 (n₁=${fmt(n1,2)})`, left+8, ifaceY-10);
      ctx.fillText(`Medium 2 (n₂=${fmt(n2,2)})`, left+8, ifaceY+18);

      // Normal
      ctx.strokeStyle = "rgba(125,211,252,0.55)";
      ctx.lineWidth = 1.5;
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(cx, top+10);
      ctx.lineTo(cx, bottom-10);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(125,211,252,0.9)";
      ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("normal", cx+6, top+22);

      // Rays
      const rayLen = Math.min(w,h)*0.42;
      const incAngle = th; // from normal
      const incDir = {x: -Math.sin(incAngle), y: Math.cos(incAngle)}; // pointing toward interface from above (downwards positive y)
      // Incident ray start
      const pHit = {x: cx, y: ifaceY};
      const pInc = {x: pHit.x + incDir.x*rayLen, y: pHit.y - incDir.y*rayLen}; // go backward (up-left)
      // Reflected ray
      const refDir = {x: -Math.sin(incAngle), y: -Math.cos(incAngle)}; // reflect across interface (up-left)
      const pRef = {x: pHit.x + refDir.x*rayLen, y: pHit.y + refDir.y*rayLen};

      // Draw incident
      arrow(ctx, pInc.x, pInc.y, pHit.x, pHit.y, "rgba(125,211,252,0.95)", 2.5);
      labelNear(ctx, "incident", (pInc.x+pHit.x)/2, (pInc.y+pHit.y)/2 - 8, "rgba(125,211,252,0.95)");
      // Draw reflected
      arrow(ctx, pHit.x, pHit.y, pRef.x, pRef.y, "rgba(167,139,250,0.95)", 2.5);
      labelNear(ctx, "reflected", (pRef.x+pHit.x)/2, (pRef.y+pHit.y)/2 + 8, "rgba(167,139,250,0.95)");

      // Angle arc (theta)
      drawAngleArc(ctx, cx, ifaceY, incAngle, 36, "θ", "rgba(232,236,255,0.9)");

      // Critical angle marker on arc
      drawAngleArc(ctx, cx, ifaceY, tc, 54, "θc", "rgba(251,191,36,0.95)");

      // Evanescent wave indication in medium 2 (below)
      const evX0 = cx + 20, evY0 = ifaceY + 30;
      ctx.strokeStyle = "rgba(52,211,153,0.70)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      const evLen = Math.min(w,h)*0.34;
      for(let i=0;i<90;i++){
        const t = i/89;
        const x = evX0 + t*evLen;
        const amp = Math.exp(-4*t);
        const y = evY0 + Math.sin(10*Math.PI*t)*10*amp;
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.stroke();
      labelNear(ctx, "evanescent (decays)", evX0+evLen*0.35, evY0+22, "rgba(52,211,153,0.9)");

      // Lateral shift hint along interface
      const xi = xiTE(th, n);
      const lam_m = state.lambda0_nm*1e-9;
      const D = ghShift(th, n, state.n1, lam_m);
      const shiftPx = isFinite(D) ? clamp(Math.abs(D)*1e6 * 55, 12, 90) : 30; // scaled for visualization
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.lineWidth = 2;
      ctx.setLineDash([4,5]);
      ctx.beginPath();
      ctx.moveTo(cx+20, ifaceY-2);
      ctx.lineTo(cx+20+shiftPx, ifaceY-2);
      ctx.stroke();
      ctx.setLineDash([]);
      arrow(ctx, cx+20, ifaceY-2, cx+20+shiftPx, ifaceY-2, "rgba(255,255,255,0.55)", 1.5, true);
      labelNear(ctx, "GH shift ~ D", cx+20+shiftPx/2, ifaceY-14, "rgba(232,236,255,0.85)");

      // Info corner
      ctx.fillStyle = "rgba(184,192,255,0.92)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      const info = [
        `θ = ${fmt(deg(th),2)}°`,
        `θc = ${fmt(deg(tc),2)}°`,
        `ξ = ${isFinite(xi)?fmt(xi,4):"—"}`,
        `D = ${isFinite(D)?fmt(D*1e6,4)+" µm":"—"}`
      ];
      const bx = left+8, by = top+10;
      ctx.fillText(info[0], bx, by+0);
      ctx.fillText(info[1], bx, by+16);
      ctx.fillText(info[2], bx, by+32);
      ctx.fillText(info[3], bx, by+48);
    }

    function arrow(ctx, x1,y1,x2,y2, color, width=2, headOnly=false){
      const dx = x2-x1, dy=y2-y1;
      const L = Math.hypot(dx,dy) || 1;
      const ux = dx/L, uy = dy/L;
      const head = 10;
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = width;
      if(!headOnly){
        ctx.beginPath();
        ctx.moveTo(x1,y1);
        ctx.lineTo(x2,y2);
        ctx.stroke();
      }
      // head
      const hx = x2 - ux*head;
      const hy = y2 - uy*head;
      ctx.beginPath();
      ctx.moveTo(x2,y2);
      ctx.lineTo(hx - uy*5, hy + ux*5);
      ctx.lineTo(hx + uy*5, hy - ux*5);
      ctx.closePath();
      ctx.fill();
    }

    function labelNear(ctx, text, x,y, color){
      ctx.fillStyle = color;
      ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(text, x - ctx.measureText(text).width/2, y);
    }

    function drawAngleArc(ctx, cx, cy, thetaFromNormal, r, label, color){
      // normal is vertical; angle measured from normal toward left (x negative)
      const a0 = -Math.PI/2;             // up direction (normal)
      const a1 = a0 + thetaFromNormal;   // rotate toward left (clockwise in canvas? actually y down)
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, r, a0, a1, false);
      ctx.stroke();
      // label near arc end
      const lx = cx + Math.cos((a0+a1)/2)* (r+14);
      const ly = cy + Math.sin((a0+a1)/2)* (r+14);
      ctx.fillStyle = color;
      ctx.font = "800 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(label, lx-6, ly+4);
    }

    // ---------- Drawing: Xi plot ----------
    function drawXiPlot(){
      const {ctx, w, h} = fitCanvas(cXi);
      drawPanelBG(ctx, w, h);

      const box = {x: 12, y: 12, ww: w-24, hh: h-24};

      const n = state.n;
      const tc = thetaCritical(n);
      const thMin = tc + rad(0.2);
      const thMax = rad(89.5);

      // compute samples
      const N = 500;
      let xs = [];
      let ys = [];
      let yMin = Infinity, yMax = -Infinity;

      for(let i=0;i<N;i++){
        const t = i/(N-1);
        const th = thMin + t*(thMax-thMin);
        const xdeg = deg(th);
        const y = xiTE(th, n);
        if(isFinite(y)){
          xs.push(xdeg); ys.push(y);
          yMin = Math.min(yMin, y);
          yMax = Math.max(yMax, y);
        }
      }
      // For visual stability: clamp y-range
      const lim = 30; // show meaningful range; still indicates divergence
      yMin = clamp(yMin, -lim, lim);
      yMax = clamp(yMax, -lim, lim);
      if(!(yMin<yMax)){
        yMin = -5; yMax = 5;
      }
      // Expand slightly
      const pad = 0.08*(yMax-yMin);
      yMin -= pad; yMax += pad;

      const xlim = {min: deg(thMin), max: deg(thMax)};
      const ylim = {min: yMin, max: yMax};

      const axes = plotAxes(ctx, w, h, box, xlim, ylim,
        {x:"θ (deg)", y:"ξ = dφ/dθ (per rad)"},
        "ξ(θ) for TE in Total Internal Reflection"
      );
      const pr = axes.plotRect;

      // polyline
      ctx.save();
      ctx.strokeStyle = "rgba(125,211,252,0.95)";
      ctx.lineWidth = 2.2;
      const pts = [];
      for(let i=0;i<xs.length;i++){
        const X = map(xs[i], xlim.min, xlim.max, pr.x, pr.x+pr.w);
        const Y = map(clamp(ys[i], ylim.min, ylim.max), ylim.min, ylim.max, pr.y+pr.h, pr.y);
        pts.push({x:X,y:Y});
      }
      polyline(ctx, pts);

      // marker at current theta
      const th = state.theta;
      const x0 = deg(th);
      const y0 = xiTE(th, n);
      const Xm = map(x0, xlim.min, xlim.max, pr.x, pr.x+pr.w);
      const Ym = map(clamp(y0, ylim.min, ylim.max), ylim.min, ylim.max, pr.y+pr.h, pr.y);
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.beginPath(); ctx.arc(Xm,Ym,4.5,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(Xm, pr.y); ctx.lineTo(Xm, pr.y+pr.h); ctx.stroke();
      ctx.restore();

      // critical angle line
      const Xc = map(deg(tc), xlim.min, xlim.max, pr.x, pr.x+pr.w);
      ctx.strokeStyle = "rgba(251,191,36,0.85)";
      ctx.lineWidth = 2;
      ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(Xc, pr.y); ctx.lineTo(Xc, pr.y+pr.h); ctx.stroke();
      ctx.setLineDash([]);

      // legend
      ctx.fillStyle = "rgba(184,192,255,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      const leg = `n=n₂/n₁=${fmt(n,3)}   θc=${fmt(deg(tc),2)}°`;
      ctx.fillText(leg, box.x+56, box.y+box.hh-16);
    }

    // ---------- Drawing: D plot ----------
    function drawDPlot(){
      const {ctx, w, h} = fitCanvas(cD);
      drawPanelBG(ctx, w, h);

      const box = {x: 12, y: 12, ww: w-24, hh: h-24};

      const n = state.n;
      const tc = thetaCritical(n);
      const thMin = tc + rad(0.2);
      const thMax = rad(89.5);

      const lam_m = state.lambda0_nm*1e-9;
      const n1 = state.n1;

      const N = 500;
      let xs=[], ys=[], yMin=Infinity, yMax=-Infinity;
      for(let i=0;i<N;i++){
        const t=i/(N-1);
        const th= thMin + t*(thMax-thMin);
        const xdeg = deg(th);
        const D = ghShift(th, n, n1, lam_m);
        if(isFinite(D)){
          const Dum = D*1e6;
          xs.push(xdeg); ys.push(Dum);
          yMin=Math.min(yMin, Dum);
          yMax=Math.max(yMax, Dum);
        }
      }
      // clamp range to show structure
      const lim = 25;
      yMin = clamp(yMin, -lim, lim);
      yMax = clamp(yMax, -lim, lim);
      if(!(yMin<yMax)){ yMin=-1; yMax=1; }
      const pad = 0.08*(yMax-yMin);
      yMin -= pad; yMax += pad;

      const xlim = {min: deg(thMin), max: deg(thMax)};
      const ylim = {min: yMin, max: yMax};

      const axes = plotAxes(ctx, w, h, box, xlim, ylim,
        {x:"θ (deg)", y:"D (µm)"},
        "Goos–Hänchen shift D(θ) = - dφ/dkx (example scale)"
      );
      const pr = axes.plotRect;

      // curve
      ctx.save();
      ctx.strokeStyle = "rgba(167,139,250,0.95)";
      ctx.lineWidth = 2.2;
      const pts=[];
      for(let i=0;i<xs.length;i++){
        const X = map(xs[i], xlim.min, xlim.max, pr.x, pr.x+pr.w);
        const Y = map(clamp(ys[i], ylim.min, ylim.max), ylim.min, ylim.max, pr.y+pr.h, pr.y);
        pts.push({x:X,y:Y});
      }
      polyline(ctx, pts);

      // marker
      const th = state.theta;
      const x0 = deg(th);
      const D0 = ghShift(th, n, n1, lam_m)*1e6;
      const Xm = map(x0, xlim.min, xlim.max, pr.x, pr.x+pr.w);
      const Ym = map(clamp(D0, ylim.min, ylim.max), ylim.min, ylim.max, pr.y+pr.h, pr.y);
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.beginPath(); ctx.arc(Xm,Ym,4.5,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(Xm, pr.y); ctx.lineTo(Xm, pr.y+pr.h); ctx.stroke();
      ctx.restore();

      // critical angle line
      const Xc = map(deg(tc), xlim.min, xlim.max, pr.x, pr.x+pr.w);
      ctx.strokeStyle = "rgba(251,191,36,0.85)";
      ctx.lineWidth = 2;
      ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(Xc, pr.y); ctx.lineTo(Xc, pr.y+pr.h); ctx.stroke();
      ctx.setLineDash([]);

      // note
      ctx.fillStyle = "rgba(184,192,255,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      const note = `Example: n₁=${fmt(n1,2)}, λ₀=${Math.round(state.lambda0_nm)} nm`;
      ctx.fillText(note, box.x+56, box.y+box.hh-16);
    }

    // ---------- Drawing: Fringe comparison ----------
    function drawFringes(){
      const {ctx, w, h} = fitCanvas(cFringe);
      drawPanelBG(ctx, w, h);

      const box = {x: 12, y: 12, ww: w-24, hh: h-24};

      const n = state.n;
      const th = state.theta;
      const dth = rad(state.dtheta_deg);
      const lam_m = state.lambda0_nm*1e-9;
      const n1 = state.n1;

      const xi = xiTE(th, n);
      const dphi = xi * dth;
      const dkx = deltaKx(th, dth, n1, lam_m);

      // Choose x-range to show ~3-4 fringes
      // Fringe period: 2π/Δkx
      const period = (dkx!==0 && isFinite(dkx)) ? (2*Math.PI/Math.abs(dkx)) : 10e-6;
      const span = 3.2*period;
      const xMin = -span/2;
      const xMax = span/2;

      // Map x to display units
      const xScale = (state.xUnits === "um") ? 1e6 : (1/lam_m);
      const xUnitLabel = (state.xUnits === "um") ? "x (µm)" : "x (λ₀)";
      const xMinU = xMin*xScale, xMaxU = xMax*xScale;

      // Intensity functions (normalized)
      // I ~ 2 + 2 cos(Δkx x + phaseOffset)
      const N = 600;
      let xs=[], iInc=[], iRef=[];
      let yMin=0, yMax=4;
      for(let i=0;i<N;i++){
        const t=i/(N-1);
        const x = xMin + t*(xMax-xMin);
        const XU = x*xScale;
        const ph = dkx*x;
        const Ii = 2 + 2*Math.cos(ph);
        const Ir = 2 + 2*Math.cos(ph + dphi);
        xs.push(XU); iInc.push(Ii); iRef.push(Ir);
      }

      const xlim = {min: xMinU, max: xMaxU};
      const ylim = {min: yMin, max: yMax};

      plotAxes(ctx, w, h, box, xlim, ylim,
        {x:xUnitLabel, y:"Relative intensity (a.u.)"},
        "Incident vs Reflected fringes along the interface"
      );

      // plot area (recompute same as plotAxes)
      const pr = {x: box.x+48, y: box.y+28, w: box.ww-48-14, h: box.hh-28-42};

      // draw curves
      // incident
      ctx.save();
      ctx.strokeStyle = "rgba(125,211,252,0.95)";
      ctx.lineWidth = 2;
      let pts=[];
      for(let i=0;i<N;i++){
        const X = map(xs[i], xlim.min, xlim.max, pr.x, pr.x+pr.w);
        const Y = map(iInc[i], ylim.min, ylim.max, pr.y+pr.h, pr.y);
        pts.push({x:X,y:Y});
      }
      polyline(ctx, pts);

      // reflected
      ctx.strokeStyle = "rgba(167,139,250,0.95)";
      pts=[];
      for(let i=0;i<N;i++){
        const X = map(xs[i], xlim.min, xlim.max, pr.x, pr.x+pr.w);
        const Y = map(iRef[i], ylim.min, ylim.max, pr.y+pr.h, pr.y);
        pts.push({x:X,y:Y});
      }
      polyline(ctx, pts);

      // Legend
      ctx.fillStyle = "rgba(232,236,255,0.92)";
      ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      // swatches
      const lx = box.x+58, ly = box.y+18;
      ctx.fillStyle = "rgba(125,211,252,0.95)";
      ctx.fillRect(lx, ly+6, 18, 3);
      ctx.fillStyle = "rgba(232,236,255,0.92)";
      ctx.fillText("Incident", lx+24, ly+10);

      ctx.fillStyle = "rgba(167,139,250,0.95)";
      ctx.fillRect(lx+100, ly+6, 18, 3);
      ctx.fillStyle = "rgba(232,236,255,0.92)";
      ctx.fillText("Reflected", lx+124, ly+10);

      // Annotate predicted shift
      const dx = (dkx!==0 && isFinite(dkx)) ? (dphi/dkx) : NaN;
      const dxU = dx*xScale;
      ctx.fillStyle = "rgba(184,192,255,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      const s1 = `dφ = ξ dθ = ${isFinite(dphi)?fmt(dphi,4):"—"} rad`;
      const s2 = `Δkx ≈ k1 cosθ dθ = ${isFinite(dkx)?fmt(dkx,4):"—"} 1/m`;
      const s3 = `Predicted shift Δx = dφ/Δkx = ${isFinite(dxU)?fmt(dxU,4):"—"} ${state.xUnits==="um"?"µm":"λ₀"}`;
      ctx.fillText(s1, box.x+58, box.y+box.hh-46);
      ctx.fillText(s2, box.x+58, box.y+box.hh-30);
      ctx.fillText(s3, box.x+58, box.y+box.hh-14);

      ctx.restore();
    }

    // ---------- Render all ----------
    function renderAll(){
      updateThetaFromSlider();
      updateUI();
      drawDiagram();
      drawXiPlot();
      drawDPlot();
      drawFringes();
    }

    // ---------- Events ----------
    function attachEvents(){
      const onAny = ()=>{
        state.n = parseFloat(slN.value);
        state.lambda0_nm = parseFloat(slLam.value);
        state.dtheta_deg = parseFloat(slDtheta.value);
        renderAll();
      };
      slTheta.addEventListener("input", renderAll);
      slN.addEventListener("input", onAny);
      slLam.addEventListener("input", onAny);
      slDtheta.addEventListener("input", onAny);

      btnReset.addEventListener("click", ()=>{
        slN.value = "0.667";
        slLam.value = "633";
        slDtheta.value = "0.50";
        slTheta.value = "0.55";
        state.xUnits = "um";
        onAny();
      });

      btnToggleUnits.addEventListener("click", ()=>{
        state.xUnits = (state.xUnits === "um") ? "lam0" : "um";
        renderAll();
      });

      window.addEventListener("resize", ()=>{
        renderAll();
      });
    }

    // ---------- Init ----------
    bindCopyButtons();
    attachEvents();
    renderAll();
  </script>
</body>
</html>
