<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Reflectance of Glass at Oblique Incidence (TE/TM Fresnel Coefficients)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --card:#101b3a;
      --text:#e9eefc;
      --muted:#b9c3e6;
      --faint:#7f8ab3;
      --accent:#76a7ff;
      --accent2:#7dffcd;
      --warn:#ffd37d;
      --ok:#8dff9e;
      --danger:#ff7d9a;
      --border:rgba(255,255,255,.10);
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(900px 600px at 15% 10%, rgba(118,167,255,.15), transparent 55%),
        radial-gradient(900px 600px at 85% 30%, rgba(125,255,205,.10), transparent 55%),
        radial-gradient(700px 500px at 50% 90%, rgba(255,125,154,.08), transparent 55%),
        var(--bg);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:28px 18px 12px;
      max-width:1180px;
      margin:0 auto;
    }
    .titlebar{
      display:flex;
      gap:16px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-size: clamp(1.25rem, 2.2vw, 2.05rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:.45rem 0 0;
      color:var(--muted);
      max-width:74ch;
    }
    .pillrow{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px}
    .pill{
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      padding:7px 10px;
      border-radius:999px;
      color:var(--muted);
      font-size:.9rem;
    }

    main{
      max-width:1180px;
      margin:0 auto;
      padding:0 18px 42px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }

    nav.toc{
      position:sticky;
      top:14px;
      align-self:start;
      border:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:14px 14px 10px;
      overflow:hidden;
    }
    .toc h2{
      margin:0 0 10px;
      font-size:1rem;
      color:var(--text);
      letter-spacing:.2px;
    }
    .toc a{
      display:block;
      padding:7px 10px;
      border-radius:12px;
      color:var(--muted);
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:.95rem;
    }
    .toc a:hover{
      background:rgba(118,167,255,.10);
      border-color:rgba(118,167,255,.20);
      transform: translateX(2px);
      text-decoration:none;
      color:var(--text);
    }

    .content{
      display:flex;
      flex-direction:column;
      gap:18px;
      min-width:0;
    }

    section, article{
      border:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:18px;
      overflow:hidden;
      min-width:0;
    }
    section h2{
      margin:0 0 10px;
      font-size:1.25rem;
    }
    section h3{
      margin:18px 0 10px;
      font-size:1.05rem;
      color:var(--text);
    }
    p{margin:10px 0; color:var(--muted)}
    ul{margin:10px 0 0 1.15rem; color:var(--muted)}
    li{margin:6px 0}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      margin-top:12px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:14px;
      margin-top:12px;
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
      nav.toc{position:relative}
      .grid2, .grid3{grid-template-columns: 1fr}
    }

    .callout{
      border:1px solid var(--border);
      background:rgba(0,0,0,.18);
      border-radius:16px;
      padding:12px 12px;
    }
    .callout strong{color:var(--text)}
    .callout.assumptions{border-color: rgba(255,211,125,.25)}
    .callout.keyeq{border-color: rgba(118,167,255,.25)}
    .callout.mistakes{border-color: rgba(255,125,154,.22)}
    .callout.final{border-color: rgba(125,255,205,.25)}
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:4px 10px;
      border-radius:999px;
      font-size:.86rem;
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      color:var(--muted);
      margin-bottom:10px;
    }
    .badge i{
      width:8px;height:8px;border-radius:50%;
      display:inline-block;background:var(--accent);
      box-shadow:0 0 0 4px rgba(118,167,255,.12);
    }
    .kbd{
      font-family:var(--mono);
      font-size:.9rem;
      padding:2px 6px;
      border-radius:8px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      color:var(--text);
    }

    .eqwrap{
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
      margin:10px 0;
    }
    pre, code{
      font-family:var(--mono);
      color:#eaf2ff;
    }
    pre{
      margin:0;
      padding:12px 12px;
      border-radius:14px;
      background:rgba(0,0,0,.26);
      border:1px solid var(--border);
      overflow:auto;
      min-width:min(100%, 65ch);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    .copybtn{
      border:1px solid var(--border);
      background:rgba(255,255,255,.05);
      color:var(--text);
      padding:8px 10px;
      border-radius:12px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-size:.92rem;
      user-select:none;
      white-space:nowrap;
    }
    .copybtn:hover{
      background:rgba(118,167,255,.10);
      border-color:rgba(118,167,255,.25);
      transform: translateY(-1px);
    }
    .copybtn:active{transform:translateY(0)}
    .copyhint{
      color:var(--faint);
      font-size:.88rem;
      margin-top:8px;
    }

    figure{
      margin:12px 0 0;
      padding:12px;
      border-radius:16px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.20);
    }
    figure figcaption{
      margin-top:10px;
      color:var(--faint);
      font-size:.92rem;
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius:14px;
      background:rgba(8,12,25,.75);
      border:1px solid rgba(255,255,255,.08);
    }
    .canvasTall canvas{height:360px;}
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    @media (max-width: 680px){
      .controls{grid-template-columns:1fr}
    }
    .control{
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      border-radius:16px;
      padding:12px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      color:var(--muted);
      font-size:.95rem;
      margin-bottom:6px;
    }
    input[type="range"]{width:100%}
    input[type="number"]{
      width:100%;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.25);
      color:var(--text);
      padding:10px 10px;
      font-family:var(--mono);
    }
    .readout{
      font-family:var(--mono);
      color:var(--text);
      font-size:.92rem;
    }
    .hr{
      height:1px;
      background:rgba(255,255,255,.10);
      margin:14px 0;
    }

    .miniTable{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      overflow:hidden;
      border-radius:14px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.18);
      margin-top:10px;
    }
    .miniTable th, .miniTable td{
      padding:10px 10px;
      border-bottom:1px solid rgba(255,255,255,.08);
      color:var(--muted);
      text-align:left;
      font-size:.95rem;
    }
    .miniTable th{
      color:var(--text);
      background:rgba(255,255,255,.04);
      font-weight:650;
    }
    .miniTable tr:last-child td{border-bottom:none}

    footer{
      max-width:1180px;
      margin:0 auto;
      padding:0 18px 32px;
      color:var(--faint);
      font-size:.92rem;
    }

    @media print{
      body{background:#fff; color:#000}
      header, main, footer{max-width:unset}
      nav.toc{display:none}
      section, article, figure{
        box-shadow:none !important;
        background:#fff !important;
        border:1px solid #ddd !important;
      }
      canvas{border:1px solid #ddd !important; background:#fff !important}
      .copybtn{display:none}
      p, li, .toc a, .badge, .copyhint{color:#222 !important}
    }
  </style>
</head>

<body>
<header>
  <div class="titlebar">
    <div>
      <h1>6.2-3 — Reflectance of Glass (TE/TM Fresnel Reflectance at 45°)</h1>
      <p class="subtitle">
        A plane wave hits a glass plate from air at an oblique angle. We compute the <b>power reflectance</b> for
        <b>TE (s)</b> and <b>TM (p)</b> polarizations using Fresnel equations, then average for unpolarized light.
      </p>
      <div class="pillrow">
        <span class="pill">Optics · Fresnel coefficients</span>
        <span class="pill">Polarization: TE/TM</span>
        <span class="pill">Snell’s law</span>
        <span class="pill">Power reflectance R</span>
      </div>
    </div>
  </div>
</header>

<main>
  <nav class="toc" aria-label="Table of Contents">
    <h2>Table of Contents</h2>
    <a href="#quick">Quick Summary</a>
    <a href="#part0">PART 0 — Concept Primer</a>
    <a href="#part1">PART 1 — Problem Analysis</a>
    <a href="#part2">PART 2 — Strategy &amp; Tips</a>
    <a href="#part3">PART 3 — Full Solution</a>
    <a href="#part4">PART 4 — Deeper Understanding</a>
    <a href="#part5">PART 5 — Visualization Guide</a>
  </nav>

  <div class="content">

    <section id="quick">
      <span class="badge"><i></i>Quick Summary</span>
      <ul>
        <li><b>What this is about:</b> reflection of an EM plane wave at an <b>air–glass</b> interface at <b>45°</b> incidence.</li>
        <li><b>Key physics idea:</b> boundary conditions on <b>E</b> and <b>H</b> fields give different reflection for <b>TE (s)</b> and <b>TM (p)</b> polarizations.</li>
        <li><b>Governing laws:</b> Snell’s law <code>n1 sinθi = n2 sinθt</code> and Fresnel amplitude coefficients <code>rs</code>, <code>rp</code>.</li>
        <li><b>Power reflectance:</b> <code>R = |r|^2</code> (for lossless dielectrics, coefficients are real for subcritical angles).</li>
        <li><b>Numerical results (air n1=1 to glass n2=1.5 at θi=45°):</b>
          <b>R_TE ≈ 0.0920</b> (9.20%), <b>R_TM ≈ 0.00847</b> (0.847%).</li>
        <li><b>Unpolarized average:</b> <code>R_avg = (R_TE + R_TM)/2 ≈ 0.0502</code> (5.02%).</li>
        <li><b>Final result type:</b> symbolic Fresnel formulas + numeric evaluation at the given parameters.</li>
      </ul>

      <div class="grid2">
        <div class="callout keyeq">
          <strong>Key equations to remember</strong>
          <div class="eqwrap">
            <pre id="eqKey1">Snell: n1 sin(θi) = n2 sin(θt)

TE (s):  rs = (n1 cosθi − n2 cosθt) / (n1 cosθi + n2 cosθt)

TM (p):  rp = (n2 cosθi − n1 cosθt) / (n2 cosθi + n1 cosθt)

Power reflectance:  R = |r|^2</pre>
            <button class="copybtn" data-copy-target="eqKey1">Copy equations</button>
          </div>
          <div class="copyhint">Copied text is plain and can be pasted into notes.</div>
        </div>

        <div class="callout final">
          <strong>Final numeric answer at 45° (n1=1, n2=1.5)</strong>
          <div class="eqwrap">
            <pre id="finalAnswerText">Given: n1 = 1.0 (air), n2 = 1.5 (glass), θi = 45°

θt = arcsin((n1/n2) sinθi) ≈ 28.13°

TE (s):  R_TE = |rs|^2 ≈ 0.0920  (9.20%)
TM (p):  R_TM = |rp|^2 ≈ 0.00847 (0.847%)

Unpolarized average: R_avg = (R_TE + R_TM)/2 ≈ 0.0502 (5.02%)</pre>
            <button class="copybtn" data-copy-target="finalAnswerText">Copy final answer</button>
          </div>
        </div>
      </div>
    </section>

    <section id="part0">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <h3>0.1 Core definitions (symbols &amp; units)</h3>
      <ul>
        <li><b>Refractive index</b> <code>n</code> (dimensionless): in non-magnetic dielectrics, <code>n ≈ sqrt(εr)</code>.</li>
        <li><b>Angles</b> <code>θi, θt</code> (radians or degrees): incidence and transmission angles measured from the <b>surface normal</b>.</li>
        <li><b>Fresnel amplitude reflection coefficients</b> <code>rs, rp</code> (dimensionless):
          ratios of reflected-to-incident <b>electric-field amplitudes</b>.</li>
        <li><b>Power reflectance</b> <code>R</code> (dimensionless): fraction of incident time-averaged power reflected.
          For each polarization: <code>R_s = |rs|^2</code>, <code>R_p = |rp|^2</code>.</li>
      </ul>

      <h3>0.2 Physical meaning: what TE/TM really mean</h3>
      <p>
        At oblique incidence, the electric field can be decomposed into two orthogonal polarizations relative to the
        <b>plane of incidence</b> (the plane containing the incident ray and the surface normal):
      </p>
      <ul>
        <li><b>TE (s-polarized)</b>: <b>E</b> is perpendicular to the plane of incidence (often labeled “s”).</li>
        <li><b>TM (p-polarized)</b>: <b>E</b> lies in the plane of incidence (often labeled “p”).</li>
      </ul>
      <p>
        Because boundary conditions treat tangential components differently, TE and TM generally reflect differently.
        A famous special case is <b>Brewster’s angle</b>, where <b>TM reflection vanishes</b> for lossless media.
      </p>

      <h3>0.3 Key laws/principles and validity</h3>
      <div class="grid2">
        <div class="callout assumptions">
          <strong>Assumptions behind Fresnel equations</strong>
          <ul>
            <li>Planar interface between <b>homogeneous, isotropic</b> media.</li>
            <li>Linear optics; steady-state sinusoidal fields.</li>
            <li>Non-magnetic media (typically <code>μ1 ≈ μ2 ≈ μ0</code>), unless stated otherwise.</li>
            <li>Lossless (no absorption) so indices are real; then <code>R = |r|^2</code> is straightforward.</li>
            <li>We compute reflectance at a <b>single interface</b> (not multi-pass interference in a finite-thickness plate).</li>
          </ul>
        </div>
        <div class="callout keyeq">
          <strong>Why these laws apply</strong>
          <ul>
            <li><b>Snell’s law</b> comes from phase matching of the tangential wavevector across the boundary.</li>
            <li><b>Fresnel coefficients</b> come from Maxwell boundary conditions: continuity of tangential <b>E</b> and <b>H</b>.</li>
            <li>Energy reflection is the squared magnitude of field reflection <b>for these lossless cases</b>.</li>
          </ul>
        </div>
      </div>

      <h3>0.4 Common models/approximations (and why)</h3>
      <ul>
        <li><b>Single-interface model</b>: appropriate when the problem says “incident onto a glass plate” but asks only TE/TM reflectance at the boundary.
          (If thickness and wavelength were emphasized, we’d include thin-film interference.)</li>
        <li><b>Non-magnetic approximation</b> (<code>μr≈1</code>): valid for most dielectrics in optics.</li>
      </ul>

      <h3>0.5 Mini intuition examples (no long algebra)</h3>
      <ul>
        <li><b>Normal incidence</b> (<code>θi=0</code>): TE and TM are identical; reflectance reduces to
          <code>R = ((n1 − n2)/(n1 + n2))^2</code>.</li>
        <li><b>Near Brewster angle</b> (for air→glass, around 56°): TM reflectance dips toward zero while TE generally increases.</li>
      </ul>

      <h3>0.6 What to watch for (pitfalls)</h3>
      <div class="callout mistakes">
        <strong>Typical mistakes</strong>
        <ul>
          <li>Using angles measured from the <b>surface</b> instead of from the <b>normal</b>.</li>
          <li>Swapping TE/TM formulas (remember: TE uses <code>n cosθ</code> symmetrically; TM swaps the <code>n</code> placements).</li>
          <li>Forgetting to compute <code>θt</code> with Snell before using Fresnel.</li>
          <li>Mixing amplitude coefficient <code>r</code> with power reflectance <code>R</code> (they are not the same!).</li>
          <li>Assuming “glass plate” implies interference—only do that if thickness is relevant.</li>
        </ul>
      </div>
    </section>

    <section id="part1">
      <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

      <h3>1.1 Restate the problem</h3>
      <p>
        A plane wave travels in air (<code>n1 = 1</code>) and hits a glass plate (<code>n2 = 1.5</code>) at an incidence angle
        <code>θi = 45°</code> (from the normal). Find the <b>power reflectance</b> for:
        <b>TE (s)</b> polarization and <b>TM (p)</b> polarization. Then compute the <b>average reflectance</b> for
        <b>unpolarized light</b> (equal TE and TM intensities).
      </p>

      <h3>1.2 Given quantities</h3>
      <table class="miniTable" aria-label="Given quantities">
        <thead>
          <tr><th>Quantity</th><th>Symbol</th><th>Value</th></tr>
        </thead>
        <tbody>
          <tr><td>Incident medium index</td><td><code>n1</code></td><td>1.0</td></tr>
          <tr><td>Transmitting medium index</td><td><code>n2</code></td><td>1.5</td></tr>
          <tr><td>Incidence angle (from normal)</td><td><code>θi</code></td><td>45°</td></tr>
        </tbody>
      </table>

      <h3>1.3 Unknowns (what we must find)</h3>
      <ul>
        <li><b>TE reflectance</b> <code>R_TE = R_s</code></li>
        <li><b>TM reflectance</b> <code>R_TM = R_p</code></li>
        <li><b>Unpolarized average reflectance</b> <code>R_avg = (R_TE + R_TM)/2</code></li>
      </ul>

      <h3>1.4 Relevant physical principles (and why)</h3>
      <ul>
        <li><b>Snell’s law</b>: determines transmitted angle <code>θt</code> needed in Fresnel formulas.</li>
        <li><b>Fresnel reflection coefficients</b>: directly give reflection amplitude for TE/TM at a planar boundary.</li>
      </ul>
      <p>
        We do <b>not</b> use thin-film interference formulas because the problem provides no thickness or wavelength,
        and it asks for TE/TM reflectances as if at a single interface.
      </p>

      <h3>1.5 Assumptions (explicit)</h3>
      <div class="callout assumptions">
        <ul>
          <li>Plane wave, steady-state sinusoidal fields.</li>
          <li>Lossless, non-magnetic media: indices real, <code>μr≈1</code>.</li>
          <li>Single interface reflectance (ignore multiple internal reflections in the plate).</li>
        </ul>
      </div>

      <h3>1.6 Possible approaches (compare briefly)</h3>
      <ul>
        <li><b>Approach A (best):</b> Use Snell + Fresnel formulas → fastest and standard for TE/TM reflectance.</li>
        <li><b>Approach B:</b> Derive Fresnel coefficients from Maxwell boundary conditions → great for learning, slower.</li>
        <li><b>Approach C:</b> Use impedance/admittance form of Fresnel equations → compact, useful in multilayers.</li>
      </ul>
      <p>
        We choose <b>Approach A</b> because it is direct, rigorous, and exactly matched to the requested quantities.
        We will still explain the theory meaningfully as we go.
      </p>
    </section>

    <section id="part2">
      <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>

      <ol style="color:var(--muted); margin:10px 0 0 1.25rem;">
        <li>
          <b>Goal:</b> Compute transmitted angle <code>θt</code>. <br/>
          <b>Tool:</b> Snell’s law <code>n1 sinθi = n2 sinθt</code>. <br/>
          <b>Meaning:</b> Ensures phase matching along the interface.
        </li>
        <li>
          <b>Goal:</b> Compute cosines <code>cosθi</code> and <code>cosθt</code>. <br/>
          <b>Tool:</b> Geometry/trig. <br/>
          <b>Meaning:</b> Fresnel coefficients depend on normal field components via these cosines.
        </li>
        <li>
          <b>Goal:</b> Compute amplitude reflection coefficients <code>rs</code> (TE) and <code>rp</code> (TM). <br/>
          <b>Tool:</b> Fresnel formulas (lossless dielectrics). <br/>
          <b>Meaning:</b> Field amplitude reflection; sign indicates phase flip.
        </li>
        <li>
          <b>Goal:</b> Convert amplitude to power reflectance. <br/>
          <b>Tool:</b> <code>R = |r|^2</code>. <br/>
          <b>Meaning:</b> Fraction of incident energy flux reflected.
        </li>
        <li>
          <b>Goal:</b> Average for unpolarized light. <br/>
          <b>Tool:</b> <code>R_avg = (R_TE + R_TM)/2</code>. <br/>
          <b>Meaning:</b> Equal mixture of independent orthogonal polarizations.
        </li>
      </ol>

      <div class="hr"></div>

      <div class="callout mistakes">
        <strong>Quick tips &amp; common mistakes</strong>
        <ul>
          <li><b>Always compute θt first</b>; don’t plug θi into both sides.</li>
          <li>Use <b>degrees consistently</b> (or convert to radians in code).</li>
          <li>Don’t confuse TE/TM with “parallel/perpendicular to surface” — it’s relative to the <b>plane of incidence</b>.</li>
          <li>If you ever get <code>R&gt;1</code> for a lossless interface at subcritical angles, re-check algebra.</li>
        </ul>
      </div>
    </section>

    <section id="part3">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>3.1 Qualitative expectation before calculating</h3>
      <p>
        For air → glass (<code>n2 &gt; n1</code>), reflection is modest at small angles. At oblique incidence,
        TE and TM split: TE reflectance tends to be larger, while TM reflectance can become very small near Brewster’s angle.
        Since <code>45°</code> is below Brewster’s angle for air→glass, we expect <b>TM reflectance smaller than TE</b>.
      </p>

      <h3>3.2 Step 1: Find the transmitted angle θt using Snell’s law</h3>
      <div class="callout keyeq">
        <strong>Snell’s law</strong>
        <div class="eqwrap">
          <pre id="eqSnell">n1 sin(θi) = n2 sin(θt)

⇒ sin(θt) = (n1/n2) sin(θi)</pre>
          <button class="copybtn" data-copy-target="eqSnell">Copy</button>
        </div>
      </div>

      <p>
        With <code>n1 = 1</code>, <code>n2 = 1.5</code>, <code>θi = 45°</code>:
      </p>
      <div class="eqwrap">
        <pre id="calc1">sin(θt) = (1/1.5) sin(45°)
        = (2/3) · (√2/2)
        ≈ (2/3) · 0.7071
        ≈ 0.4714

θt = arcsin(0.4714) ≈ 28.13°</pre>
        <button class="copybtn" data-copy-target="calc1">Copy</button>
      </div>
      <p>
        <b>What we did:</b> enforced refraction geometry. <b>Why:</b> Fresnel coefficients depend on both angles.
      </p>

      <h3>3.3 Step 2: Compute cosines needed in Fresnel coefficients</h3>
      <div class="eqwrap">
        <pre id="calc2">cos(θi) = cos(45°) = 0.7071
cos(θt) = cos(28.13°) ≈ 0.8819</pre>
        <button class="copybtn" data-copy-target="calc2">Copy</button>
      </div>
      <p>
        <b>Meaning:</b> These encode how strongly the wave points “into” the surface normal direction in each medium.
      </p>

      <h3>3.4 Step 3: Fresnel amplitude reflection coefficients (TE and TM)</h3>
      <div class="callout keyeq">
        <strong>Fresnel amplitude reflection coefficients (non-magnetic, lossless)</strong>
        <div class="eqwrap">
          <pre id="eqFresnel">TE (s):  rs = (n1 cosθi − n2 cosθt) / (n1 cosθi + n2 cosθt)

TM (p):  rp = (n2 cosθi − n1 cosθt) / (n2 cosθi + n1 cosθt)</pre>
          <button class="copybtn" data-copy-target="eqFresnel">Copy</button>
        </div>
      </div>

      <p><b>Compute TE (s):</b></p>
      <div class="eqwrap">
        <pre id="calc3s">rs = (n1 cosθi − n2 cosθt) / (n1 cosθi + n2 cosθt)
   = (1·0.7071 − 1.5·0.8819) / (1·0.7071 + 1.5·0.8819)
   = (0.7071 − 1.3229) / (0.7071 + 1.3229)
   = (−0.6158) / (2.0300)
   ≈ −0.3034</pre>
        <button class="copybtn" data-copy-target="calc3s">Copy</button>
      </div>
      <p>
        <b>Interpretation:</b> the negative sign indicates a <b>π phase flip</b> of the reflected TE electric field
        relative to the incident field (for this configuration).
      </p>

      <p><b>Compute TM (p):</b></p>
      <div class="eqwrap">
        <pre id="calc3p">rp = (n2 cosθi − n1 cosθt) / (n2 cosθi + n1 cosθt)
   = (1.5·0.7071 − 1·0.8819) / (1.5·0.7071 + 1·0.8819)
   = (1.0607 − 0.8819) / (1.0607 + 0.8819)
   = (0.1788) / (1.9426)
   ≈ 0.0920</pre>
        <button class="copybtn" data-copy-target="calc3p">Copy</button>
      </div>
      <p>
        <b>Interpretation:</b> TM reflects much less here because we are moving toward the Brewster-angle behavior.
      </p>

      <h3>3.5 Step 4: Convert amplitude reflection to power reflectance</h3>
      <div class="callout keyeq">
        <strong>Power reflectance</strong>
        <div class="eqwrap">
          <pre id="eqR">R_TE = |rs|^2
R_TM = |rp|^2</pre>
          <button class="copybtn" data-copy-target="eqR">Copy</button>
        </div>
      </div>

      <div class="eqwrap">
        <pre id="calc4">R_TE = (−0.3034)^2 ≈ 0.0920  → 9.20%
R_TM = ( 0.0920)^2 ≈ 0.00847 → 0.847%</pre>
        <button class="copybtn" data-copy-target="calc4">Copy</button>
      </div>

      <h3>3.6 Step 5: Average reflectance for unpolarized light</h3>
      <p>
        Unpolarized light can be modeled as an equal-intensity incoherent mixture of orthogonal TE and TM components, so the
        average reflected power fraction is the arithmetic mean:
      </p>
      <div class="eqwrap">
        <pre id="calc5">R_avg = (R_TE + R_TM)/2
      = (0.0920 + 0.00847)/2
      = 0.050235
      ≈ 0.0502  → 5.02%</pre>
        <button class="copybtn" data-copy-target="calc5">Copy</button>
      </div>

      <div class="callout final">
        <strong>Final Answer (boxed)</strong>
        <div class="eqwrap">
          <pre id="boxedFinal">At n1=1, n2=1.5, θi=45°:

R_TE ≈ 0.0920  (9.20%)
R_TM ≈ 0.00847 (0.847%)

Unpolarized average: R_avg ≈ 0.0502 (5.02%)</pre>
          <button class="copybtn" data-copy-target="boxedFinal">Copy</button>
        </div>
      </div>

      <h3>3.7 Sanity checks</h3>
      <ul>
        <li><b>Units:</b> reflectance is dimensionless (a fraction of power).</li>
        <li><b>Bounds:</b> <code>0 ≤ R ≤ 1</code> satisfied.</li>
        <li><b>Limiting case:</b> if <code>θi→0</code>, TE and TM should match; our plots (below) show the curves merge near 0°.</li>
        <li><b>Physical interpretation:</b> TE reflects more than TM at 45° for air→glass because TM approaches a Brewster minimum at a higher angle.</li>
      </ul>

      <p>
        <b>Connection to the diagram and plots:</b> the diagram shows the three rays and angles <code>θi</code>, <code>θt</code>.
        The plots show how <code>R_TE(θi)</code> and <code>R_TM(θi)</code> differ with angle; your chosen angle is marked on the curves.
      </p>
    </section>

    <section id="part4">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>4.1 Re-interpreting the formulas: what controls reflectance</h3>
      <ul>
        <li><b>Index contrast</b> (<code>n2/n1</code>): larger mismatch generally increases reflectance.</li>
        <li><b>Angle</b> (<code>θi</code>): changes both <code>cosθi</code> and <code>cosθt</code> and affects TE/TM differently.</li>
        <li><b>Polarization:</b> TE and TM boundary conditions produce distinct coefficients.</li>
      </ul>

      <div class="callout keyeq">
        <strong>Brewster angle (TM zero-reflection condition)</strong>
        <div class="eqwrap">
          <pre id="eqBrewster">For lossless dielectrics (μ1≈μ2):
tan(θB) = n2/n1

At θi = θB, rp = 0 ⇒ R_TM = 0</pre>
          <button class="copybtn" data-copy-target="eqBrewster">Copy</button>
        </div>
        <p class="copyhint">For air→glass (n2/n1=1.5), θB ≈ arctan(1.5) ≈ 56.3°.</p>
      </div>

      <h3>4.2 How changing parameters affects the outcome (use the interactive plots)</h3>
      <ul>
        <li>Increase <code>θi</code> toward <code>θB</code> (≈56.3° for 1→1.5): <b>TM reflectance drops toward zero</b>.</li>
        <li>Increase <code>n2</code> (keeping <code>n1</code> fixed): both TE and TM generally reflect more; <code>θB</code> shifts because <code>tanθB=n2/n1</code>.</li>
        <li>At small angles: <b>TE ≈ TM</b> (polarization dependence fades at normal incidence).</li>
      </ul>

      <h3>4.3 Alternative derivation idea (brief)</h3>
      <p>
        Instead of quoting Fresnel formulas, you can derive them by writing incident, reflected, and transmitted plane waves,
        then applying Maxwell boundary conditions at the interface:
        continuity of tangential <b>E</b> and <b>H</b>. Doing this separately for TE and TM yields the two reflection coefficients.
      </p>

      <h3>4.4 Concept checks (self-test)</h3>
      <ul>
        <li><b>Q:</b> Why do TE and TM reflect differently at oblique incidence? <br/>
            <b>A:</b> Because the relevant tangential field components and their coupling to <b>H</b> differ for the two polarizations at the boundary.</li>
        <li><b>Q:</b> What happens to TM reflection at Brewster’s angle (lossless case)? <br/>
            <b>A:</b> It goes to zero: <code>R_TM = 0</code>.</li>
        <li><b>Q:</b> At normal incidence, do TE and TM differ? <br/>
            <b>A:</b> No—there’s no special plane-of-incidence distinction, so they coincide.</li>
        <li><b>Q:</b> If the medium were absorbing (complex n), would <code>R=|r|^2</code> still be used? <br/>
            <b>A:</b> The relationship becomes more subtle and coefficients become complex; power flow needs careful handling (still often uses |r|^2 with appropriate definitions, but interpretation changes).</li>
      </ul>
    </section>

    <section id="part5">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <div class="controls" aria-label="Interactive controls">
        <div class="control">
          <label for="thetaSlider">
            <span>Incidence angle <code>θi</code> (degrees)</span>
            <span class="readout" id="thetaReadout">45.0°</span>
          </label>
          <input id="thetaSlider" type="range" min="0" max="89" step="0.1" value="45"/>
          <div class="copyhint">Moves the marker on both plots and updates the diagram angles and numeric reflectances.</div>
        </div>

        <div class="control">
          <label for="n2Slider">
            <span>Glass index <code>n2</code> (dimensionless)</span>
            <span class="readout" id="n2Readout">1.50</span>
          </label>
          <input id="n2Slider" type="range" min="1.00" max="2.20" step="0.01" value="1.50"/>
          <div class="copyhint">Parameter sweep: watch Brewster angle shift and the TE/TM curves reshape.</div>
        </div>
      </div>

      <div class="grid2">
        <figure class="canvasTall">
          <canvas id="diagramCanvas" aria-label="Ray diagram canvas"></canvas>
          <figcaption>
            <b>Diagram:</b> Air–glass interface with incident, reflected, and transmitted rays. Angles are measured from the normal.
            Labels show <code>n1</code>, <code>n2</code>, <code>θi</code>, <code>θt</code>.
          </figcaption>
        </figure>

        <figure class="canvasTall">
          <canvas id="mainPlotCanvas" aria-label="Main plot canvas"></canvas>
          <figcaption>
            <b>Main plot:</b> <code>R_TE(θi)</code> and <code>R_TM(θi)</code> vs incidence angle. Marker shows current <code>θi</code>.
          </figcaption>
        </figure>
      </div>

      <figure>
        <canvas id="secondaryPlotCanvas" aria-label="Secondary plot canvas"></canvas>
        <figcaption>
          <b>Secondary plot:</b> Polarization contrast <code>C(θi) = (R_TE − R_TM)/(R_TE + R_TM)</code> vs angle, plus a marker at the current <code>θi</code>.
          This emphasizes how strongly polarization matters.
        </figcaption>
      </figure>

      <h3>5.1 What should change when you move the controls?</h3>
      <ul>
        <li>Changing <code>θi</code> updates <code>θt</code> by Snell’s law and moves the marker on both plots.</li>
        <li>Changing <code>n2</code> changes the entire reflectance-vs-angle curves and shifts Brewster angle (where TM dips).</li>
        <li>The diagram updates the geometry and prints the live numeric <code>R_TE</code>, <code>R_TM</code>, and <code>R_avg</code>.</li>
      </ul>
    </section>

  </div>
</main>

<footer>
  <div class="hr"></div>
  <p>
    Notes: This page models a single planar interface (air→glass). A real “plate” has two interfaces; if thickness and wavelength matter,
    multiple reflections can interfere (thin-film effects). Those are intentionally excluded because the problem statement does not specify them.
  </p>
</footer>

<script>
/* ---------------------------
   Clipboard helpers
---------------------------- */
(function(){
  function copyText(text){
    if (navigator.clipboard && navigator.clipboard.writeText){
      return navigator.clipboard.writeText(text);
    }
    // Fallback
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.position = 'fixed';
    ta.style.left = '-9999px';
    document.body.appendChild(ta);
    ta.select();
    try { document.execCommand('copy'); } catch(e){}
    document.body.removeChild(ta);
    return Promise.resolve();
  }

  document.addEventListener('click', (e)=>{
    const btn = e.target.closest('.copybtn');
    if(!btn) return;
    const id = btn.getAttribute('data-copy-target');
    const el = document.getElementById(id);
    if(!el) return;
    const txt = el.innerText.replace(/\u00A0/g,' ');
    const old = btn.textContent;
    btn.textContent = "Copied!";
    btn.style.borderColor = "rgba(125,255,205,.35)";
    btn.style.background = "rgba(125,255,205,.10)";
    copyText(txt).finally(()=>{
      setTimeout(()=>{
        btn.textContent = old;
        btn.style.borderColor = "";
        btn.style.background = "";
      }, 800);
    });
  });
})();

/* ---------------------------
   Fresnel physics utilities
---------------------------- */
function degToRad(d){ return d*Math.PI/180; }
function radToDeg(r){ return r*180/Math.PI; }

function snellThetaT(n1, n2, thetaI){
  // thetaI in radians; returns thetaT in radians (real if no TIR)
  const s = (n1/n2)*Math.sin(thetaI);
  // clamp for numerical stability
  const sc = Math.max(-1, Math.min(1, s));
  return Math.asin(sc);
}

function fresnel(n1, n2, thetaI){
  const thetaT = snellThetaT(n1, n2, thetaI);
  const ci = Math.cos(thetaI);
  const ct = Math.cos(thetaT);

  // TE (s)
  const rs = (n1*ci - n2*ct)/(n1*ci + n2*ct);

  // TM (p)
  const rp = (n2*ci - n1*ct)/(n2*ci + n1*ct);

  const R_TE = rs*rs;
  const R_TM = rp*rp;
  const R_avg = 0.5*(R_TE + R_TM);
  return {thetaT, rs, rp, R_TE, R_TM, R_avg};
}

function brewsterAngle(n1, n2){
  // tan θB = n2/n1, for non-magnetic, lossless
  return Math.atan2(n2, n1);
}

/* ---------------------------
   Canvas drawing helpers
---------------------------- */
function setupHiDPICanvas(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(1, Math.floor(rect.width * dpr));
  const h = Math.max(1, Math.floor(rect.height * dpr));
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h;
  }
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  return {ctx, wCSS: rect.width, hCSS: rect.height, dpr};
}

function clearPanel(ctx, w, h){
  ctx.clearRect(0,0,w,h);
  // subtle vignette
  const g = ctx.createRadialGradient(w*0.35, h*0.25, 20, w*0.5, h*0.5, Math.max(w,h));
  g.addColorStop(0, "rgba(255,255,255,0.05)");
  g.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle = "rgba(8,12,25,0.85)";
  ctx.fillRect(0,0,w,h);
  ctx.fillStyle = g;
  ctx.fillRect(0,0,w,h);
}

function drawText(ctx, x, y, text, color="rgba(233,238,252,.92)", size=12, align="left"){
  ctx.save();
  ctx.fillStyle = color;
  ctx.font = `${size}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
  ctx.textAlign = align;
  ctx.textBaseline = "alphabetic";
  ctx.fillText(text, x, y);
  ctx.restore();
}

function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
  const {x, y, w, h} = box;
  // panel border
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth = 1;
  ctx.strokeRect(x, y, w, h);

  // title
  drawText(ctx, x + 10, y + 18, title, "rgba(233,238,252,.95)", 13, "left");

  // grid + ticks
  const leftPad = 50, rightPad=14, topPad=30, bottomPad=42;
  const px0 = x + leftPad, py0 = y + h - bottomPad;
  const px1 = x + w - rightPad, py1 = y + topPad;

  // gridlines
  ctx.strokeStyle = "rgba(255,255,255,0.07)";
  ctx.lineWidth = 1;

  const xTicks = 6;
  for(let i=0;i<=xTicks;i++){
    const t = i/xTicks;
    const xx = px0 + t*(px1-px0);
    ctx.beginPath(); ctx.moveTo(xx, py0); ctx.lineTo(xx, py1); ctx.stroke();
  }
  const yTicks = 5;
  for(let j=0;j<=yTicks;j++){
    const t = j/yTicks;
    const yy = py0 - t*(py0-py1);
    ctx.beginPath(); ctx.moveTo(px0, yy); ctx.lineTo(px1, yy); ctx.stroke();
  }

  // axes
  ctx.strokeStyle = "rgba(233,238,252,0.35)";
  ctx.lineWidth = 1.2;
  ctx.beginPath(); ctx.moveTo(px0, py0); ctx.lineTo(px1, py0); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(px0, py0); ctx.lineTo(px0, py1); ctx.stroke();

  // tick labels
  ctx.fillStyle = "rgba(185,195,230,.95)";
  ctx.font = `11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace`;

  for(let i=0;i<=xTicks;i++){
    const t = i/xTicks;
    const val = xMin + t*(xMax-xMin);
    const xx = px0 + t*(px1-px0);
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText(val.toFixed(0), xx, py0 + 6);
  }
  for(let j=0;j<=yTicks;j++){
    const t = j/yTicks;
    const val = yMin + t*(yMax-yMin);
    const yy = py0 - t*(py0-py1);
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    ctx.fillText(val.toFixed(2), px0 - 6, yy);
  }

  // labels
  drawText(ctx, (px0+px1)/2, y + h - 12, xLabel, "rgba(185,195,230,.95)", 12, "center");
  // rotated y label
  ctx.save();
  ctx.translate(x + 14, (py0+py1)/2);
  ctx.rotate(-Math.PI/2);
  drawText(ctx, 0, 0, yLabel, "rgba(185,195,230,.95)", 12, "center");
  ctx.restore();

  ctx.restore();

  function xToPx(xv){ return px0 + (xv-xMin)/(xMax-xMin)*(px1-px0); }
  function yToPx(yv){ return py0 - (yv-yMin)/(yMax-yMin)*(py0-py1); }

  return {px0, py0, px1, py1, xToPx, yToPx};
}

function drawPolyline(ctx, pts, strokeStyle="rgba(118,167,255,.95)", width=2){
  if(pts.length<2) return;
  ctx.save();
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = width;
  ctx.lineJoin = "round";
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.stroke();
  ctx.restore();
}

function drawLegend(ctx, x, y, items){
  const pad=10, lineH=18;
  const w = 220, h = pad*2 + items.length*lineH;
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth=1;
  ctx.beginPath();
  roundRect(ctx, x, y, w, h, 12);
  ctx.fill();
  ctx.stroke();
  for(let i=0;i<items.length;i++){
    const it = items[i];
    const yy = y + pad + (i+0.65)*lineH;
    ctx.strokeStyle = it.color;
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(x+12, yy-4); ctx.lineTo(x+34, yy-4); ctx.stroke();
    drawText(ctx, x+42, yy, it.label, "rgba(233,238,252,.92)", 12, "left");
  }
  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}

/* ---------------------------
   Renderers
---------------------------- */
const state = {
  n1: 1.0,
  n2: 1.5,
  thetaDeg: 45.0
};

const diagramCanvas = document.getElementById('diagramCanvas');
const mainPlotCanvas = document.getElementById('mainPlotCanvas');
const secondaryPlotCanvas = document.getElementById('secondaryPlotCanvas');

function renderAll(){
  renderDiagram();
  renderMainPlot();
  renderSecondaryPlot();
  updateReadouts();
}

function updateReadouts(){
  document.getElementById('thetaReadout').textContent = state.thetaDeg.toFixed(1) + "°";
  document.getElementById('n2Readout').textContent = state.n2.toFixed(2);
}

function renderDiagram(){
  const {ctx, wCSS:w, hCSS:h} = setupHiDPICanvas(diagramCanvas);
  clearPanel(ctx, w, h);

  const n1 = state.n1, n2 = state.n2;
  const thetaI = degToRad(state.thetaDeg);
  const fr = fresnel(n1, n2, thetaI);
  const thetaT = fr.thetaT;

  // Coordinate system
  const cx = w*0.52, cy = h*0.55;
  const interfaceY = cy;
  const normalLen = Math.min(w,h)*0.34;

  // Draw interface
  ctx.save();
  ctx.strokeStyle = "rgba(233,238,252,0.25)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(w*0.12, interfaceY);
  ctx.lineTo(w*0.92, interfaceY);
  ctx.stroke();

  // Media labels
  drawText(ctx, w*0.14, interfaceY-14, `Medium 1 (air): n1 = ${n1.toFixed(2)}`, "rgba(185,195,230,.95)", 12, "left");
  drawText(ctx, w*0.14, interfaceY+26, `Medium 2 (glass): n2 = ${n2.toFixed(2)}`, "rgba(185,195,230,.95)", 12, "left");

  // Normal
  ctx.strokeStyle = "rgba(118,167,255,0.55)";
  ctx.lineWidth = 2;
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.moveTo(cx, interfaceY - normalLen);
  ctx.lineTo(cx, interfaceY + normalLen);
  ctx.stroke();
  ctx.setLineDash([]);
  drawText(ctx, cx+10, interfaceY - normalLen + 14, "normal", "rgba(118,167,255,.85)", 12, "left");

  // Rays
  const rayLen = Math.min(w,h)*0.42;

  // incident direction: coming from above to interface
  const incAngleFromNormal = thetaI;
  // Direction vector pointing toward interface:
  const incDx = Math.sin(incAngleFromNormal);
  const incDy = Math.cos(incAngleFromNormal);
  const incStartX = cx - incDx*rayLen;
  const incStartY = interfaceY - incDy*rayLen;

  // reflected: symmetric in medium 1
  const refDx = Math.sin(incAngleFromNormal);
  const refDy = -Math.cos(incAngleFromNormal);
  const refEndX = cx + refDx*rayLen*0.85;
  const refEndY = interfaceY + refDy*rayLen*0.85;

  // transmitted in medium 2
  const trAngleFromNormal = thetaT;
  const trDx = Math.sin(trAngleFromNormal);
  const trDy = Math.cos(trAngleFromNormal);
  const trEndX = cx + trDx*rayLen*0.9;
  const trEndY = interfaceY + trDy*rayLen*0.9;

  // draw incident
  drawArrow(ctx, incStartX, incStartY, cx, interfaceY, "rgba(255,211,125,.95)", 2.6);
  drawText(ctx, incStartX+10, incStartY+10, "incident", "rgba(255,211,125,.95)", 12, "left");

  // reflected
  drawArrow(ctx, cx, interfaceY, refEndX, refEndY, "rgba(118,167,255,.95)", 2.6);
  drawText(ctx, refEndX-10, refEndY-8, "reflected", "rgba(118,167,255,.95)", 12, "right");

  // transmitted
  drawArrow(ctx, cx, interfaceY, trEndX, trEndY, "rgba(125,255,205,.90)", 2.6);
  drawText(ctx, trEndX-10, trEndY+16, "transmitted", "rgba(125,255,205,.90)", 12, "right");

  // angle arcs
  drawAngleArc(ctx, cx, interfaceY, normalLen*0.35, -Math.PI/2, -Math.PI/2 + incAngleFromNormal, "rgba(255,211,125,.9)");
  drawText(ctx, cx+normalLen*0.19, interfaceY-normalLen*0.20, `θi=${state.thetaDeg.toFixed(1)}°`, "rgba(255,211,125,.95)", 12, "left");

  drawAngleArc(ctx, cx, interfaceY, normalLen*0.35, Math.PI/2, Math.PI/2 - trAngleFromNormal, "rgba(125,255,205,.85)");
  drawText(ctx, cx+normalLen*0.20, interfaceY+normalLen*0.28, `θt=${radToDeg(thetaT).toFixed(2)}°`, "rgba(125,255,205,.90)", 12, "left");

  // live numeric box
  const bx = w*0.12, by = h*0.10, bw = w*0.76, bh = 86;
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth=1;
  ctx.beginPath(); roundRect(ctx, bx, by, bw, bh, 14); ctx.fill(); ctx.stroke();

  const Rte = fr.R_TE, Rtm = fr.R_TM, Rav = fr.R_avg;
  const line1 = `R_TE = ${Rte.toFixed(4)} (${(Rte*100).toFixed(2)}%)   |   R_TM = ${Rtm.toFixed(5)} (${(Rtm*100).toFixed(3)}%)`;
  const line2 = `R_avg (unpolarized) = ${(Rav).toFixed(4)} (${(Rav*100).toFixed(2)}%)`;
  const line3 = `Amplitude: rs=${fr.rs.toFixed(4)}, rp=${fr.rp.toFixed(4)} (sign indicates phase flip)`;
  drawText(ctx, bx+12, by+26, "Live reflectance at current settings", "rgba(233,238,252,.95)", 13, "left");
  drawText(ctx, bx+12, by+48, line1, "rgba(185,195,230,.95)", 12, "left");
  drawText(ctx, bx+12, by+66, line2, "rgba(185,195,230,.95)", 12, "left");
  drawText(ctx, bx+12, by+84, line3, "rgba(127,138,179,.95)", 11, "left");

  ctx.restore();
}

function drawArrow(ctx, x0,y0,x1,y1, color, width){
  const dx=x1-x0, dy=y1-y0;
  const L=Math.hypot(dx,dy) || 1;
  const ux=dx/L, uy=dy/L;
  const head=10;
  const hx=x1-ux*head, hy=y1-uy*head;
  const px=-uy, py=ux;

  ctx.save();
  ctx.strokeStyle=color;
  ctx.fillStyle=color;
  ctx.lineWidth=width;
  ctx.lineCap="round";
  ctx.beginPath();
  ctx.moveTo(x0,y0);
  ctx.lineTo(hx,hy);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.lineTo(hx + px*6, hy + py*6);
  ctx.lineTo(hx - px*6, hy - py*6);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawAngleArc(ctx, cx, cy, r, a0, a1, color){
  ctx.save();
  ctx.strokeStyle=color;
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.arc(cx, cy, r, a0, a1, false);
  ctx.stroke();
  ctx.restore();
}

function renderMainPlot(){
  const {ctx, wCSS:w, hCSS:h} = setupHiDPICanvas(mainPlotCanvas);
  clearPanel(ctx, w, h);

  const n1=state.n1, n2=state.n2;
  const xMin=0, xMax=89, yMin=0, yMax=1.00;

  const axes = drawAxes(
    ctx,
    {x:10, y:10, w:w-20, h:h-20},
    xMin, xMax, yMin, yMax,
    "Incidence angle θi (deg)",
    "Reflectance R (unitless)",
    "Reflectance vs Angle (TE and TM)"
  );

  // curves
  const ptsTE=[], ptsTM=[];
  for(let a=xMin; a<=xMax; a+=0.5){
    const fr = fresnel(n1,n2,degToRad(a));
    ptsTE.push({x: axes.xToPx(a), y: axes.yToPx(fr.R_TE)});
    ptsTM.push({x: axes.xToPx(a), y: axes.yToPx(fr.R_TM)});
  }
  drawPolyline(ctx, ptsTE, "rgba(118,167,255,.95)", 2.4);
  drawPolyline(ctx, ptsTM, "rgba(125,255,205,.92)", 2.4);

  // Brewster angle line
  const thB = radToDeg(brewsterAngle(n1,n2));
  const xB = axes.xToPx(Math.min(xMax, Math.max(xMin, thB)));
  ctx.save();
  ctx.strokeStyle = "rgba(255,211,125,.55)";
  ctx.setLineDash([6,6]);
  ctx.lineWidth = 1.6;
  ctx.beginPath();
  ctx.moveTo(xB, axes.py0);
  ctx.lineTo(xB, axes.py1);
  ctx.stroke();
  ctx.setLineDash([]);
  drawText(ctx, xB+6, axes.py1+16, `Brewster θB≈${thB.toFixed(1)}°`, "rgba(255,211,125,.85)", 11, "left");
  ctx.restore();

  // marker at current angle
  const a0 = state.thetaDeg;
  const fr0 = fresnel(n1,n2,degToRad(a0));
  const mx = axes.xToPx(a0);
  const myTE = axes.yToPx(fr0.R_TE);
  const myTM = axes.yToPx(fr0.R_TM);

  // vertical marker line
  ctx.save();
  ctx.strokeStyle = "rgba(233,238,252,0.22)";
  ctx.lineWidth=1.2;
  ctx.beginPath(); ctx.moveTo(mx, axes.py0); ctx.lineTo(mx, axes.py1); ctx.stroke();
  ctx.restore();

  // points
  drawDot(ctx, mx, myTE, "rgba(118,167,255,.95)");
  drawDot(ctx, mx, myTM, "rgba(125,255,205,.95)");

  // legend
  drawLegend(ctx, 20, 44, [
    {label:"TE (s): R_TE", color:"rgba(118,167,255,.95)"},
    {label:"TM (p): R_TM", color:"rgba(125,255,205,.92)"}
  ]);

  // small annotation box
  const bx= w-320, by= 44, bw=290, bh=70;
  ctx.save();
  ctx.fillStyle="rgba(0,0,0,0.35)";
  ctx.strokeStyle="rgba(255,255,255,0.10)";
  ctx.lineWidth=1;
  ctx.beginPath(); roundRect(ctx, bx, by, bw, bh, 12); ctx.fill(); ctx.stroke();
  drawText(ctx, bx+10, by+24, `θi = ${a0.toFixed(1)}°`, "rgba(233,238,252,.95)", 12, "left");
  drawText(ctx, bx+10, by+44, `R_TE = ${fr0.R_TE.toFixed(4)}   R_TM = ${fr0.R_TM.toFixed(5)}`, "rgba(185,195,230,.95)", 11, "left");
  drawText(ctx, bx+10, by+62, `R_avg = ${fr0.R_avg.toFixed(4)}`, "rgba(127,138,179,.95)", 11, "left");
  ctx.restore();
}

function drawDot(ctx, x,y, color){
  ctx.save();
  ctx.fillStyle=color;
  ctx.beginPath(); ctx.arc(x,y,4.5,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle="rgba(0,0,0,0.35)";
  ctx.lineWidth=1;
  ctx.beginPath(); ctx.arc(x,y,4.5,0,Math.PI*2); ctx.stroke();
  ctx.restore();
}

function renderSecondaryPlot(){
  const {ctx, wCSS:w, hCSS:h} = setupHiDPICanvas(secondaryPlotCanvas);
  clearPanel(ctx, w, h);

  const n1=state.n1, n2=state.n2;
  const xMin=0, xMax=89, yMin=-1, yMax=1;

  const axes = drawAxes(
    ctx,
    {x:10, y:10, w:w-20, h:h-20},
    xMin, xMax, yMin, yMax,
    "Incidence angle θi (deg)",
    "Contrast C (unitless)",
    "Polarization Contrast vs Angle"
  );

  // Contrast curve: C = (R_TE - R_TM)/(R_TE + R_TM)
  const pts=[];
  for(let a=xMin; a<=xMax; a+=0.5){
    const fr = fresnel(n1,n2,degToRad(a));
    const denom = fr.R_TE + fr.R_TM;
    const C = (denom > 1e-12) ? (fr.R_TE - fr.R_TM)/denom : 0;
    pts.push({x: axes.xToPx(a), y: axes.yToPx(C)});
  }
  drawPolyline(ctx, pts, "rgba(255,125,154,.85)", 2.4);

  // zero line
  ctx.save();
  ctx.strokeStyle="rgba(233,238,252,0.18)";
  ctx.lineWidth=1.2;
  ctx.beginPath();
  ctx.moveTo(axes.px0, axes.yToPx(0));
  ctx.lineTo(axes.px1, axes.yToPx(0));
  ctx.stroke();
  ctx.restore();

  // marker
  const a0=state.thetaDeg;
  const fr0=fresnel(n1,n2,degToRad(a0));
  const denom=fr0.R_TE+fr0.R_TM;
  const C0=(denom>1e-12)? (fr0.R_TE-fr0.R_TM)/denom : 0;
  const mx=axes.xToPx(a0);
  const my=axes.yToPx(C0);

  ctx.save();
  ctx.strokeStyle = "rgba(233,238,252,0.22)";
  ctx.lineWidth=1.2;
  ctx.beginPath(); ctx.moveTo(mx, axes.py0); ctx.lineTo(mx, axes.py1); ctx.stroke();
  ctx.restore();

  drawDot(ctx, mx, my, "rgba(255,125,154,.95)");

  // legend + annotation
  drawLegend(ctx, 20, 44, [
    {label:"Contrast C", color:"rgba(255,125,154,.85)"}
  ]);

  const bx= w-330, by=44, bw=300, bh=72;
  ctx.save();
  ctx.fillStyle="rgba(0,0,0,0.35)";
  ctx.strokeStyle="rgba(255,255,255,0.10)";
  ctx.lineWidth=1;
  ctx.beginPath(); roundRect(ctx, bx, by, bw, bh, 12); ctx.fill(); ctx.stroke();
  drawText(ctx, bx+10, by+24, `θi = ${a0.toFixed(1)}°`, "rgba(233,238,252,.95)", 12, "left");
  drawText(ctx, bx+10, by+44, `C = ${C0.toFixed(3)} (TE dominates if C>0)`, "rgba(185,195,230,.95)", 11, "left");
  drawText(ctx, bx+10, by+62, `n2 = ${n2.toFixed(2)}  (n1=${n1.toFixed(2)})`, "rgba(127,138,179,.95)", 11, "left");
  ctx.restore();
}

/* ---------------------------
   Interaction + resize
---------------------------- */
const thetaSlider = document.getElementById('thetaSlider');
const n2Slider = document.getElementById('n2Slider');

thetaSlider.addEventListener('input', ()=>{
  state.thetaDeg = parseFloat(thetaSlider.value);
  renderAll();
});
n2Slider.addEventListener('input', ()=>{
  state.n2 = parseFloat(n2Slider.value);
  renderAll();
});

let resizeTimer=null;
window.addEventListener('resize', ()=>{
  clearTimeout(resizeTimer);
  resizeTimer=setTimeout(renderAll, 120);
});

// initial render
renderAll();
</script>
</body>
</html>
