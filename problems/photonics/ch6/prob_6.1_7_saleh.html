<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jones Matrix of a Rotated Linear Polarizer (Derivation + Interactive Visuals)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101a33;
      --panel2:#0f1730;
      --text:#eaf0ff;
      --muted:#b8c3e6;
      --faint:#7f8ab3;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --ok:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --border: rgba(255,255,255,.10);
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 700px at 20% 10%, rgba(125,211,252,.18), transparent 60%),
                  radial-gradient(900px 600px at 80% 20%, rgba(167,139,250,.16), transparent 60%),
                  radial-gradient(900px 600px at 50% 90%, rgba(52,211,153,.10), transparent 60%),
                  var(--bg);
      color:var(--text);
      line-height:1.55;
    }

    header{
      padding: 28px 18px 10px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 16px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .hero{grid-template-columns:1fr}
    }

    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 18px 16px;
      position:relative;
      overflow:hidden;
    }
    .titleCard:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(600px 220px at 20% 0%, rgba(125,211,252,.22), transparent 60%),
                  radial-gradient(600px 220px at 80% 0%, rgba(167,139,250,.20), transparent 60%);
      pointer-events:none;
      filter: blur(0px);
      opacity:.85;
    }
    .titleCard > *{position:relative}
    h1{
      font-size: clamp(1.5rem, 2.4vw, 2.1rem);
      margin: 0 0 6px;
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      max-width: 70ch;
    }

    .tocCard{
      background: rgba(16,26,51,.85);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
      position: sticky;
      top: 12px;
      align-self:start;
      backdrop-filter: blur(10px);
    }
    .tocCard h2{
      font-size: 1rem;
      margin: 0 0 10px;
      color: var(--text);
      letter-spacing:.3px;
    }
    .toc{
      display:flex;
      flex-direction:column;
      gap:6px;
      margin:0;
      padding:0;
      list-style:none;
    }
    .toc a{
      display:block;
      padding: 7px 9px;
      border-radius: 10px;
      color: var(--muted);
      text-decoration:none;
      border:1px solid transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      font-size:.95rem;
    }
    .toc a:hover{
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.22);
      transform: translateY(-1px);
      color: var(--text);
    }

    main{
      max-width:1200px;
      margin: 0 auto;
      padding: 0 18px 40px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    section{
      background: rgba(16,26,51,.70);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px 16px 12px;
      overflow:hidden;
    }

    section h2{
      margin: 0 0 10px;
      font-size: 1.18rem;
      letter-spacing:.25px;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 980px){
      .grid2{grid-template-columns:1fr}
    }

    .callout{
      border: 1px solid var(--border);
      background: rgba(15,23,48,.75);
      border-radius: 14px;
      padding: 12px;
      position:relative;
    }
    .callout strong{color:var(--text)}
    .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size:.85rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .dot{
      width:10px; height:10px;
      border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(125,211,252,.12);
    }
    .dot.purple{background: var(--accent2); box-shadow:0 0 0 4px rgba(167,139,250,.12)}
    .dot.green{background: var(--ok); box-shadow:0 0 0 4px rgba(52,211,153,.12)}
    .dot.warn{background: var(--warn); box-shadow:0 0 0 4px rgba(251,191,36,.12)}

    .eqWrap{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:start;
      margin: 8px 0;
    }
    pre.eq{
      margin:0;
      padding: 10px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      color: #f2f6ff;
      font-family: var(--mono);
      font-size: .95rem;
      overflow:auto;
      white-space: pre;
    }
    button.copyBtn{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(125,211,252,.12);
      color: var(--text);
      border-radius: 12px;
      padding: 9px 10px;
      cursor:pointer;
      font-weight:600;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      min-width: 88px;
    }
    button.copyBtn:hover{
      transform: translateY(-1px);
      background: rgba(125,211,252,.18);
      border-color: rgba(125,211,252,.30);
    }
    button.copyBtn:active{transform: translateY(0px) scale(.99)}
    .copied{
      background: rgba(52,211,153,.16) !important;
      border-color: rgba(52,211,153,.35) !important;
    }

    ul{margin: 8px 0 0 18px; color: var(--muted)}
    li{margin: 6px 0}
    p{margin: 8px 0; color: var(--muted)}
    .muted{color: var(--muted)}
    .small{font-size:.95rem}
    .note{color: var(--faint)}
    .kicker{color: var(--text); font-weight:700}
    .hr{height:1px; background: var(--border); margin: 12px 0}

    /* Visualization area */
    .viz{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    .vizTop{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap: 12px;
      align-items: stretch;
    }
    @media (max-width: 980px){
      .vizTop{grid-template-columns:1fr}
    }
    .canvasCard{
      border: 1px solid var(--border);
      background: rgba(15,23,48,.70);
      border-radius: 14px;
      padding: 10px;
      overflow:hidden;
    }
    .canvasHeader{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap: 10px;
      margin-bottom: 8px;
    }
    .canvasHeader h3{
      margin:0;
      font-size: 1rem;
      letter-spacing:.2px;
      color: var(--text);
    }
    .canvasHeader .mini{
      color: var(--faint);
      font-size:.86rem;
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
      border-radius: 12px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.08);
    }
    .shortCanvas canvas{height: 260px;}
    .controls{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .ctrl{
      border:1px solid var(--border);
      background: rgba(0,0,0,.18);
      border-radius: 14px;
      padding: 10px 12px;
    }
    .ctrl label{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      color: var(--text);
      font-weight:650;
      margin-bottom: 6px;
    }
    .ctrl .val{
      color: var(--accent);
      font-family: var(--mono);
      font-weight:700;
      font-size:.92rem;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    select{
      width:100%;
      padding: 10px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(15,23,48,.65);
      color: var(--text);
      outline:none;
    }

    .pillRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top: 6px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 7px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(125,211,252,.10);
      color: var(--muted);
      font-size:.88rem;
    }
    .pill b{color: var(--text); font-family: var(--mono); font-size:.88rem}

    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 18px 18px 36px;
      color: var(--faint);
      font-size:.92rem;
    }

    /* Print-friendly */
    @media print{
      body{background:#fff; color:#000}
      section, .titleCard, .tocCard, .canvasCard, .callout, .ctrl{box-shadow:none; background:#fff; border:1px solid #ddd}
      .tocCard{position:static}
      button.copyBtn{display:none}
      canvas{border:1px solid #ccc}
      p, li{color:#111}
      .note, .muted{color:#222}
    }

    /* Subtle entrance */
    @keyframes rise{
      from{transform: translateY(6px); opacity:0}
      to{transform: translateY(0); opacity:1}
    }
    section, .titleCard, .tocCard{animation: rise .35s ease both}
    section:nth-of-type(2){animation-delay:.05s}
    section:nth-of-type(3){animation-delay:.08s}
    section:nth-of-type(4){animation-delay:.11s}
  </style>
</head>

<body>
<header>
  <div class="hero">
    <div class="titleCard">
      <h1>6.1-7 — Jones Matrix of a Rotated Linear Polarizer</h1>
      <p class="subtitle">
        We derive the Jones matrix of an <span class="kicker">ideal linear polarizer</span> whose transmission axis makes an angle
        <span class="kicker">θ</span> with the x-axis, using coordinate-rotation matrices and similarity transforms.
        Then we connect the matrix to Malus’ law and visualize how the matrix acts on an input polarization.
      </p>
    </div>

    <aside class="tocCard" aria-label="Table of contents">
      <h2>Mini Table of Contents</h2>
      <ul class="toc">
        <li><a href="#quick">Quick Summary</a></li>
        <li><a href="#part0">PART 0 — Concept Primer</a></li>
        <li><a href="#part1">PART 1 — Problem Analysis</a></li>
        <li><a href="#part2">PART 2 — Strategy & Tips</a></li>
        <li><a href="#part3">PART 3 — Full Solution</a></li>
        <li><a href="#part4">PART 4 — Deeper Understanding</a></li>
        <li><a href="#part5">PART 5 — Visualization Guide</a></li>
      </ul>
    </aside>
  </div>
</header>

<main>
  <!-- Quick Summary -->
  <section id="quick">
    <h2>Quick Summary</h2>
    <ul>
      <li><span class="kicker">What this is about:</span> finding the Jones matrix of a linear polarizer rotated by angle <b>θ</b> from the x-axis.</li>
      <li><span class="kicker">Key physics idea:</span> a rotated optical element is represented by a <b>similarity transform</b> using rotation matrices.</li>
      <li><span class="kicker">Core model:</span> Jones calculus (fully polarized, monochromatic, coherent light; linear optics).</li>
      <li><span class="kicker">Governing tool:</span> coordinate-rotation matrix <b>R(θ)</b> and matrix transform <b>T(θ)=R(-θ) T₀ R(θ)</b>.</li>
      <li><span class="kicker">Reference element:</span> x-axis polarizer has <b>T₀ = [[1,0],[0,0]]</b>.</li>
      <li><span class="kicker">Final result type:</span> symbolic 2×2 matrix with trigonometric entries (projection operator onto the axis at θ).</li>
      <li><span class="kicker">Physical consequence:</span> transmitted intensity follows <b>Malus’ law</b>: <b>Iout/Iin = cos²(φ−θ)</b> for input linear polarization at angle φ.</li>
    </ul>
  </section>

  <!-- PART 0 -->
  <section id="part0">
    <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

    <div class="grid2">
      <article class="callout">
        <div class="tag"><span class="dot"></span><strong>Core definitions</strong></div>
        <p class="small">
          In Jones calculus, the transverse electric field (complex amplitude) is written as a 2-component vector:
        </p>
        <div class="eqWrap">
          <pre class="eq" id="eq-jonesvec">J = [Ex; Ey]</pre>
          <button class="copyBtn" data-copy="#eq-jonesvec">Copy</button>
        </div>
        <p class="small note">
          Here Ex and Ey are complex (they carry phase). Units are field units (e.g., V/m), but Jones calculus often works with normalized amplitudes.
        </p>
      </article>

      <article class="callout">
        <div class="tag"><span class="dot purple"></span><strong>Optical elements as matrices</strong></div>
        <p class="small">
          Any linear, polarization-transforming optical device is modeled by a 2×2 complex matrix <b>T</b> such that:
        </p>
        <div class="eqWrap">
          <pre class="eq" id="eq-linear">J_out = T J_in</pre>
          <button class="copyBtn" data-copy="#eq-linear">Copy</button>
        </div>
        <p class="small note">
          Valid when the system is linear and the wave remains fully polarized (no depolarization).
        </p>
      </article>
    </div>

    <div class="grid2" style="margin-top:12px">
      <article class="callout">
        <div class="tag"><span class="dot green"></span><strong>Physical meaning (polarizer)</strong></div>
        <p class="small">
          An <b>ideal linear polarizer</b> transmits only the component of the field along its transmission axis and blocks the orthogonal component.
          Mathematically, it acts like a <b>projection</b> onto a direction in the transverse plane.
        </p>
        <p class="small">
          If the transmission axis is the unit vector <b>u</b>, then the polarizer acts as:
          <span class="note">(projection operator)</span>
        </p>
        <div class="eqWrap">
          <pre class="eq" id="eq-proj">T = u u^T   (for an ideal lossless polarizer in a real basis)</pre>
          <button class="copyBtn" data-copy="#eq-proj">Copy</button>
        </div>
        <p class="small note">
          In the x–y basis, u = (cosθ, sinθ). This alone already hints at the final matrix entries.
        </p>
      </article>

      <article class="callout">
        <div class="tag"><span class="dot warn"></span><strong>Rotation matrices & when they apply</strong></div>
        <p class="small">
          Rotating the coordinate axes (or equivalently describing the same field in a rotated basis) uses a rotation matrix <b>R(θ)</b>.
          This is purely geometric—no physics changes, only the coordinate description.
        </p>
        <div class="eqWrap">
          <pre class="eq" id="eq-rot">R(θ) = [[ cosθ,  sinθ],
        [ -sinθ, cosθ]]</pre>
          <button class="copyBtn" data-copy="#eq-rot">Copy</button>
        </div>
        <p class="small note">
          This matches the convention shown in your provided equations (6.1-22).
        </p>
      </article>
    </div>

    <article class="callout" style="margin-top:12px">
      <div class="tag"><span class="dot"></span><strong>Common models/approximations + mini intuition</strong></div>
      <ul>
        <li><b>Assume ideal polarizer:</b> blocks one component completely; transmits the other without phase delay.</li>
        <li><b>Assume monochromatic, fully polarized light:</b> Jones calculus does not handle partial polarization (that would use Stokes/Mueller).</li>
        <li><b>Mini intuition example 1:</b> If the polarizer axis is along x (θ=0), it should pass Ex and kill Ey → matrix should be diag(1,0).</li>
        <li><b>Mini intuition example 2:</b> If θ=45°, it should pass the component along (x+y)/√2, so output should have equal x and y components proportional to the input projection.</li>
      </ul>
      <div class="hr"></div>
      <p class="small kicker">What to watch for (pitfalls)</p>
      <ul>
        <li>Mixing up <b>rotating the element</b> vs <b>rotating the coordinate axes</b> (signs on θ matter).</li>
        <li>Using the wrong similarity transform order (e.g., R(θ)TR(-θ) vs R(-θ)TR(θ)).</li>
        <li>For ideal polarizers, the matrix is a <b>projector</b>: it should be symmetric and satisfy T² = T.</li>
      </ul>
    </article>
  </section>

  <!-- PART 1 -->
  <section id="part1">
    <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

    <article class="callout">
      <div class="tag"><span class="dot purple"></span><strong>Problem restated</strong></div>
      <p class="small">
        We know the Jones matrix of an ideal linear polarizer whose transmission axis is aligned with the x-axis:
        <b>T₀ = [[1,0],[0,0]]</b> (your Eq. 6.1-18).
        We must show that when the polarizer’s transmission axis is rotated by an angle <b>θ</b> relative to x,
        the Jones matrix in the original x–y basis becomes:
      </p>
      <div class="eqWrap">
        <pre class="eq" id="eq-target">T(θ) = [[ cos^2θ,  sinθ cosθ],
        [ sinθ cosθ, sin^2θ ]]</pre>
        <button class="copyBtn" data-copy="#eq-target">Copy</button>
      </div>
      <p class="small note">
        We are instructed to derive it using equations (6.1-18), (6.1-22), and (6.1-24) (the rotation matrix and the transform rule).
      </p>
    </article>

    <div class="grid2" style="margin-top:12px">
      <article class="callout">
        <div class="tag"><span class="dot"></span><strong>Given</strong></div>
        <ul>
          <li>Ideal x-polarizer matrix (6.1-18): <b>T₀ = [[1,0],[0,0]]</b>.</li>
          <li>Rotation matrix (6.1-22): <b>R(θ)</b> as shown in the primer.</li>
          <li>Matrix transformation rule (6.1-24): <b>T = R(-θ) T' R(θ)</b> (with conventions consistent with your excerpt).</li>
        </ul>
      </article>

      <article class="callout">
        <div class="tag"><span class="dot green"></span><strong>Unknown / must prove</strong></div>
        <ul>
          <li>Find the Jones matrix <b>T(θ)</b> of the polarizer whose transmission axis is at angle θ to x.</li>
          <li>Show it equals the stated matrix with entries cos²θ, sin²θ, and sinθ cosθ.</li>
        </ul>
      </article>
    </div>

    <article class="callout" style="margin-top:12px">
      <div class="tag"><span class="dot warn"></span><strong>Which principles apply — and why</strong></div>
      <ul>
        <li><b>Jones linearity:</b> polarizer is a linear optical element → matrix multiplication is valid.</li>
        <li><b>Coordinate transformation:</b> rotating the polarizer relative to the lab basis is handled by rotating into the element’s “natural basis,” applying T₀, then rotating back → similarity transform.</li>
        <li><b>Why not Mueller/Stokes:</b> problem explicitly uses Jones matrices (fully polarized light), so we stay in Jones calculus.</li>
      </ul>
      <p class="small kicker">Assumptions</p>
      <ul>
        <li>Ideal polarizer: perfect extinction of the orthogonal component; no extra phase delay.</li>
        <li>Same transverse plane basis (x,y), time-harmonic monochromatic field, no depolarization.</li>
      </ul>
      <p class="small kicker">Possible approaches (compare)</p>
      <ul>
        <li><b>Approach A (requested):</b> Use the similarity transform with R(θ). <span class="note">Clean, systematic, matches the textbook equations.</span></li>
        <li><b>Approach B:</b> Use projector form <b>T = u uᵀ</b> with u = (cosθ, sinθ). <span class="note">Fast, highly intuitive, but may skip the specific referenced equations.</span></li>
        <li><b>Approach C:</b> Apply the polarizer to a general Jones vector and deduce matrix entries by matching coefficients. <span class="note">Educational but longer.</span></li>
      </ul>
      <p class="small"><b>Chosen approach:</b> Approach A, because the problem explicitly requests using (6.1-18), (6.1-22), and (6.1-24).</p>
    </article>
  </section>

  <!-- PART 2 -->
  <section id="part2">
    <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

    <article class="callout">
      <div class="tag"><span class="dot"></span><strong>Plan (no full algebra yet)</strong></div>
      <ol class="muted" style="margin:8px 0 0 18px">
        <li><b>Goal:</b> identify the “reference” polarizer matrix. <b>Tool:</b> Eq. (6.1-18). <b>Meaning:</b> passes x, blocks y.</li>
        <li><b>Goal:</b> write the rotation matrix. <b>Tool:</b> Eq. (6.1-22). <b>Meaning:</b> changes coordinates between lab (x,y) and rotated (x′,y′).</li>
        <li><b>Goal:</b> express the rotated polarizer in lab coordinates. <b>Tool:</b> similarity transform. <b>Meaning:</b> rotate into element axes → apply T₀ → rotate back.</li>
        <li><b>Goal:</b> multiply matrices explicitly and simplify trig terms. <b>Tool:</b> matrix multiplication + identities. <b>Meaning:</b> get explicit entries.</li>
        <li><b>Goal:</b> sanity-check the result. <b>Tool:</b> limiting angles θ=0°, 90°, 45°; projector property T²=T. <b>Meaning:</b> confirms physical correctness.</li>
      </ol>

      <div class="hr"></div>
      <p class="small kicker">Common mistakes + quick tips</p>
      <ul>
        <li>Tip: keep track of whether you’re transforming the <b>field</b> (J) or the <b>matrix</b> (T). The matrix transforms by similarity.</li>
        <li>Mistake: swapping R(θ) and R(-θ). Quick check: at θ=0 you must recover T₀.</li>
        <li>Tip: for an ideal polarizer, the final matrix should be <b>symmetric</b> and have rank 1 (one eigenvalue 1, one eigenvalue 0).</li>
      </ul>
    </article>
  </section>

  <!-- PART 3 -->
  <section id="part3">
    <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

    <article class="callout">
      <div class="tag"><span class="dot green"></span><strong>Qualitative expectation (before calculating)</strong></div>
      <p class="small">
        A linear polarizer at angle θ should output a field that points along the transmission axis.
        That means the output should equal the <b>projection</b> of the input field onto the axis at angle θ, written back in x–y components.
        Therefore we expect a matrix that looks like a projector onto the direction (cosθ, sinθ):
        entries should involve cos²θ, sin²θ, and sinθ cosθ.
      </p>
    </article>

    <article class="callout" style="margin-top:12px">
      <div class="tag"><span class="dot"></span><strong>Step 1 — Start from the known x-axis polarizer (Eq. 6.1-18)</strong></div>
      <p class="small">
        Let <b>T₀</b> denote the Jones matrix of an ideal polarizer whose transmission axis is aligned with x:
        it transmits Ex and blocks Ey.
      </p>
      <div class="eqWrap">
        <pre class="eq" id="eq-t0">T₀ = [[1, 0],
      [0, 0]]</pre>
        <button class="copyBtn" data-copy="#eq-t0">Copy</button>
      </div>
      <p class="small note">
        Interpretation: J_out = (Ex, 0)ᵀ when J_in = (Ex, Ey)ᵀ.
      </p>
    </article>

    <article class="callout" style="margin-top:12px">
      <div class="tag"><span class="dot purple"></span><strong>Step 2 — Use the rotation matrix (Eq. 6.1-22)</strong></div>
      <p class="small">
        The coordinate transformation between (x,y) and a rotated coordinate system (x′,y′) by angle θ is:
      </p>
      <div class="eqWrap">
        <pre class="eq" id="eq-rtheta">R(θ) = [[ cosθ,  sinθ],
        [ -sinθ, cosθ]]</pre>
        <button class="copyBtn" data-copy="#eq-rtheta">Copy</button>
      </div>
      <p class="small">
        Using the book’s convention, the Jones vector transforms as (see Eq. 6.1-21 in your excerpt):
      </p>
      <div class="eqWrap">
        <pre class="eq" id="eq-jprime">J' = R(θ) J</pre>
        <button class="copyBtn" data-copy="#eq-jprime">Copy</button>
      </div>
      <p class="small note">
        Here J is expressed in (x,y), while J′ is the same physical field expressed in the rotated basis (x′,y′).
      </p>
    </article>

    <article class="callout" style="margin-top:12px">
      <div class="tag"><span class="dot"></span><strong>Step 3 — Transform the optical system (Eq. 6.1-24)</strong></div>
      <p class="small">
        If an optical system has Jones matrix <b>T</b> in the (x,y) basis and <b>T′</b> in the rotated (x′,y′) basis,
        your excerpt gives (Eq. 6.1-24):
      </p>
      <div class="eqWrap">
        <pre class="eq" id="eq-sim">T = R(-θ) T' R(θ)</pre>
        <button class="copyBtn" data-copy="#eq-sim">Copy</button>
      </div>
      <p class="small">
        <b>What this means physically:</b> to apply the rotated element in the lab basis,
        we (i) rotate the field into the element’s basis, (ii) apply the simple reference matrix there,
        then (iii) rotate back to lab coordinates.
      </p>
    </article>

    <article class="callout" style="margin-top:12px">
      <div class="tag"><span class="dot green"></span><strong>Step 4 — Identify T′ for the polarizer aligned with x′</strong></div>
      <p class="small">
        In the rotated coordinate system (x′, y′), the polarizer’s transmission axis is aligned with x′,
        so its matrix is the same as the x-aligned reference matrix:
      </p>
      <div class="eqWrap">
        <pre class="eq" id="eq-tprime">T' = [[1, 0],
      [0, 0]] = T₀</pre>
        <button class="copyBtn" data-copy="#eq-tprime">Copy</button>
      </div>
      <p class="small note">
        This is the key simplification: in the element’s own axis system, the polarizer is “easy.”
      </p>
    </article>

    <article class="callout" style="margin-top:12px">
      <div class="tag"><span class="dot"></span><strong>Step 5 — Compute T(θ) = R(-θ) T₀ R(θ) explicitly</strong></div>
      <p class="small">
        First write <b>R(-θ)</b>. Replace θ→−θ in R(θ):
      </p>
      <div class="eqWrap">
        <pre class="eq" id="eq-rminus">R(-θ) = [[ cosθ, -sinθ],
         [ sinθ,  cosθ]]</pre>
        <button class="copyBtn" data-copy="#eq-rminus">Copy</button>
      </div>

      <p class="small">Now multiply step-by-step. Start with <b>T₀ R(θ)</b>:</p>
      <div class="eqWrap">
        <pre class="eq" id="eq-mid1">T₀ R(θ)
= [[1,0],[0,0]] [[cosθ, sinθ],[-sinθ, cosθ]]
= [[cosθ, sinθ],
   [  0 ,   0 ]]</pre>
        <button class="copyBtn" data-copy="#eq-mid1">Copy</button>
      </div>

      <p class="small">Then multiply by <b>R(-θ)</b> on the left:</p>
      <div class="eqWrap">
        <pre class="eq" id="eq-mid2">T(θ) = R(-θ) (T₀ R(θ))
= [[cosθ, -sinθ],[sinθ, cosθ]] [[cosθ, sinθ],[0,0]]</pre>
        <button class="copyBtn" data-copy="#eq-mid2">Copy</button>
      </div>

      <p class="small">Compute each entry (row × column):</p>
      <div class="eqWrap">
        <pre class="eq" id="eq-entries">T11 = cosθ·cosθ + (-sinθ)·0 = cos^2θ
T12 = cosθ·sinθ + (-sinθ)·0 = sinθ cosθ
T21 = sinθ·cosθ + ( cosθ)·0 = sinθ cosθ
T22 = sinθ·sinθ + ( cosθ)·0 = sin^2θ</pre>
        <button class="copyBtn" data-copy="#eq-entries">Copy</button>
      </div>

      <div class="hr"></div>
      <p class="small kicker">Final derived matrix (boxed)</p>
      <div class="eqWrap">
        <pre class="eq" id="eq-final">T(θ) = [[ cos^2θ,  sinθ cosθ],
        [ sinθ cosθ, sin^2θ ]]</pre>
        <button class="copyBtn" data-copy="#eq-final">Copy</button>
      </div>
    </article>

    <article class="callout" style="margin-top:12px">
      <div class="tag"><span class="dot warn"></span><strong>Sanity checks</strong></div>
      <ul>
        <li><b>Units/dimensions:</b> matrix entries are trigonometric, dimensionless → correct for an amplitude mapping.</li>
        <li><b>Limiting case θ=0:</b> cosθ=1, sinθ=0 ⇒ T(0) = [[1,0],[0,0]] = T₀.</li>
        <li><b>Limiting case θ=90°:</b> cosθ=0, sinθ=1 ⇒ T(90°) = [[0,0],[0,1]] (a y-polarizer).</li>
        <li><b>Projector property:</b> T(θ) is symmetric and one can verify T(θ)² = T(θ) → it projects onto the axis at θ.</li>
        <li><b>Physical meaning:</b> output field is always parallel to (cosθ, sinθ); its magnitude equals the input projection onto that axis.</li>
      </ul>
      <p class="small note">
        Connection to Malus’ law: for an input linear polarization at angle φ (J_in = [cosφ, sinφ]ᵀ),
        the transmitted amplitude is cos(φ−θ) and intensity scales as cos²(φ−θ).
      </p>
    </article>
  </section>

  <!-- Visualization -->
  <section aria-label="Interactive visualizations">
    <h2>Interactive Visualizations (Diagram + Two Plots)</h2>

    <div class="viz">
      <div class="vizTop">
        <div class="canvasCard">
          <div class="canvasHeader">
            <h3>Diagram: Input polarization (φ) and polarizer axis (θ)</h3>
            <div class="mini">Units: angles in degrees</div>
          </div>
          <canvas id="cDiagram" aria-label="Polarization diagram"></canvas>
          <div class="pillRow" aria-label="Live readouts">
            <div class="pill">θ = <b id="readTheta">0.0°</b></div>
            <div class="pill">φ = <b id="readPhi">25.0°</b></div>
            <div class="pill">Iout/Iin = <b id="readMalus">0.000</b></div>
            <div class="pill">Jout ∥ axis θ</div>
          </div>
        </div>

        <div class="controls" aria-label="Controls">
          <div class="ctrl">
            <label for="theta">
              Polarizer angle θ (deg)
              <span class="val" id="thetaVal">0.0°</span>
            </label>
            <input id="theta" type="range" min="-90" max="90" value="0" step="0.1" />
            <p class="note small">Rotates the transmission axis of the polarizer. Updates diagram and both plots.</p>
          </div>

          <div class="ctrl">
            <label for="phi">
              Input linear polarization angle φ (deg)
              <span class="val" id="phiVal">25.0°</span>
            </label>
            <input id="phi" type="range" min="-90" max="90" value="25" step="0.1" />
            <p class="note small">Sets input Jones vector J_in = [cosφ, sinφ]ᵀ (example input for plotting).</p>
          </div>

          <div class="ctrl">
            <label for="mode">
              Secondary plot shows
              <span class="val" id="modeVal">Output components</span>
            </label>
            <select id="mode">
              <option value="out">Output components Ex_out(θ), Ey_out(θ)</option>
              <option value="mat">Matrix elements T11(θ), T12(θ), T22(θ)</option>
            </select>
            <p class="note small">Choose a parameter sweep view: how the matrix acts on the input, or how the matrix entries vary with θ.</p>
          </div>
        </div>
      </div>

      <div class="grid2">
        <div class="canvasCard">
          <div class="canvasHeader">
            <h3>Main Plot: Malus’ law — transmitted intensity vs θ</h3>
            <div class="mini">Iout/Iin = cos²(φ−θ)</div>
          </div>
          <canvas id="cMain" aria-label="Main plot of Malus law"></canvas>
        </div>

        <div class="canvasCard shortCanvas">
          <div class="canvasHeader">
            <h3>Secondary Plot: Parameter sweep</h3>
            <div class="mini" id="secSub">Ex_out, Ey_out vs θ (example input)</div>
          </div>
          <canvas id="cSec" aria-label="Secondary plot sweep"></canvas>
        </div>
      </div>
    </div>
  </section>

  <!-- PART 4 -->
  <section id="part4">
    <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

    <div class="grid2">
      <article class="callout">
        <div class="tag"><span class="dot"></span><strong>Re-interpreting the matrix</strong></div>
        <p class="small">
          The derived matrix can be read as a <b>projection operator</b> onto the unit axis vector
          <b>u = (cosθ, sinθ)</b>:
        </p>
        <div class="eqWrap">
          <pre class="eq" id="eq-uuT">T(θ) = u u^T
with u = [cosθ; sinθ]</pre>
          <button class="copyBtn" data-copy="#eq-uuT">Copy</button>
        </div>
        <p class="small note">
          Each term tells you “how much x and y contribute” after projecting onto the axis.
          The off-diagonal term sinθ cosθ mixes x and y because a rotated axis is not aligned with either basis direction.
        </p>
      </article>

      <article class="callout">
        <div class="tag"><span class="dot green"></span><strong>How parameters affect outcomes</strong></div>
        <ul>
          <li>Changing <b>θ</b> rotates the transmission axis, changing the projection of the input field onto that axis.</li>
          <li>For linear input at <b>φ</b>, intensity depends only on the difference <b>(φ−θ)</b>.</li>
          <li>When θ ≈ φ, transmission is maximal (Iout ≈ Iin). When θ differs by 90°, transmission goes to zero.</li>
          <li>On the secondary plot, the output components vary smoothly with θ because you’re expressing a fixed axis-aligned output back in x–y coordinates.</li>
        </ul>
      </article>
    </div>

    <article class="callout" style="margin-top:12px">
      <div class="tag"><span class="dot purple"></span><strong>Alternative derivation idea (quick)</strong></div>
      <p class="small">
        Without any similarity transforms, you can argue directly:
        an ideal polarizer outputs <b>J_out = (u·J_in) u</b>.
        Writing u = (cosθ, sinθ) and expanding yields the same matrix entries.
        This is the “projector” viewpoint and is often the fastest conceptual route.
      </p>

      <div class="hr"></div>
      <p class="small kicker">Concept checks (self-test)</p>
      <ul>
        <li><b>Q:</b> Why is T(θ) symmetric? <b>A:</b> It’s a projector u uᵀ in a real x–y basis, so Tᵀ=T.</li>
        <li><b>Q:</b> What are the eigenvalues of T(θ)? <b>A:</b> 1 along u (transmitted axis) and 0 orthogonal to u (blocked axis).</li>
        <li><b>Q:</b> If the input is already aligned with θ, what happens? <b>A:</b> J_out = J_in (up to ideal transmission), and Iout/Iin = 1.</li>
        <li><b>Q:</b> What breaks Jones calculus here? <b>A:</b> Partial polarization or depolarizing elements (need Stokes/Mueller instead).</li>
      </ul>
    </article>

    <article class="callout" style="margin-top:12px">
      <div class="tag"><span class="dot warn"></span><strong>Final Answer (copy-ready)</strong></div>
      <div class="eqWrap">
        <pre class="eq" id="eq-finalAnswer">Jones matrix of a linear polarizer with transmission axis at angle θ to x:

T(θ) = R(-θ) [[1,0],[0,0]] R(θ)
     = [[cos^2θ,  sinθ cosθ],
        [sinθ cosθ, sin^2θ]]</pre>
        <button class="copyBtn" data-copy="#eq-finalAnswer">Copy</button>
      </div>
    </article>
  </section>

  <!-- PART 5 -->
  <section id="part5">
    <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

    <article class="callout">
      <div class="tag"><span class="dot"></span><strong>What each canvas shows</strong></div>
      <ul>
        <li><b>Diagram canvas:</b> x–y axes, the polarizer transmission axis at angle <b>θ</b>, the input linear polarization direction at angle <b>φ</b>, and the projected (transmitted) component along θ.</li>
        <li><b>Main plot:</b> transmitted intensity ratio <b>Iout/Iin = cos²(φ−θ)</b> vs θ. A marker indicates your current θ.</li>
        <li><b>Secondary plot:</b> either (i) output field components <b>Ex_out(θ)</b>, <b>Ey_out(θ)</b> for the example input J_in = [cosφ, sinφ]ᵀ, or (ii) matrix elements <b>T11(θ)</b>, <b>T12(θ)</b>, <b>T22(θ)</b> vs θ.</li>
      </ul>
    </article>

    <article class="callout" style="margin-top:12px">
      <div class="tag"><span class="dot green"></span><strong>Interactive controls</strong></div>
      <ul>
        <li><b>θ slider:</b> rotates the polarizer axis. You should see the transmitted intensity curve marker move and the diagram axis rotate. The secondary plot updates because both T(θ) and J_out depend on θ.</li>
        <li><b>φ slider:</b> rotates the input polarization. The entire Malus curve changes because it depends on (φ−θ). The output components also change because the projection changes.</li>
        <li><b>Secondary plot selector:</b> switches between viewing the element’s <b>matrix entries</b> and the resulting <b>output components</b>.</li>
      </ul>
      <p class="small note">
        The math in the plots uses the same symbols as the text: θ is the polarizer angle, φ is the input linear polarization angle.
        Numerical values are <b>example values</b> for visualization only; the final derived Jones matrix remains symbolic.
      </p>
    </article>
  </section>
</main>

<footer>
  <div class="hr"></div>
  <p>
    Built as a self-contained learning article: Jones calculus + rotations + projection interpretation.
    Tip: use the copy buttons to paste equations into your notes.
  </p>
</footer>

<script>
/* =========================
   Utility: Copy buttons
========================= */
(function(){
  const buttons = document.querySelectorAll('button.copyBtn');
  function setTempState(btn){
    btn.classList.add('copied');
    const old = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(()=>{ btn.textContent = old; btn.classList.remove('copied'); }, 900);
  }
  buttons.forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const sel = btn.getAttribute('data-copy');
      const el = document.querySelector(sel);
      if(!el) return;
      const txt = el.textContent.replace(/\r/g,'').trim();
      try{
        await navigator.clipboard.writeText(txt);
        setTempState(btn);
      }catch(e){
        // Fallback
        const ta = document.createElement('textarea');
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        try{ document.execCommand('copy'); setTempState(btn); }catch(_){}
        document.body.removeChild(ta);
      }
    });
  });
})();

/* =========================
   Math helpers
========================= */
const DEG = Math.PI / 180;
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

/* Jones matrices per the problem convention:
   R(θ) = [[cosθ, sinθ],[-sinθ, cosθ]]
   T(θ) = R(-θ) T0 R(θ), with T0 = [[1,0],[0,0]]
*/
function R(theta){
  const c = Math.cos(theta), s = Math.sin(theta);
  return [[c, s],[-s, c]];
}
function matMul(A,B){
  return [
    [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],
    [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]
  ];
}
function matVec(A,v){
  return [
    A[0][0]*v[0] + A[0][1]*v[1],
    A[1][0]*v[0] + A[1][1]*v[1]
  ];
}
const T0 = [[1,0],[0,0]];
function Ttheta(theta){
  const Rp = R(theta);
  const Rm = R(-theta);
  return matMul(matMul(Rm, T0), Rp);
}
function linInput(phi){
  return [Math.cos(phi), Math.sin(phi)];
}
function malus(phi,theta){
  const d = phi - theta;
  const c = Math.cos(d);
  return c*c;
}

/* =========================
   Canvas rendering engine
========================= */
function makeHiDPICanvas(canvas){
  const ctx = canvas.getContext('2d');
  function resize(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width * dpr));
    const h = Math.max(1, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
    }
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  }
  return {canvas, ctx, resize};
}

function drawAxes2D(ctx, box, xMin, xMax, yMin, yMax, opts){
  const {x, y, w, h} = box;
  const padL = opts.padL ?? 52;
  const padR = opts.padR ?? 16;
  const padT = opts.padT ?? 20;
  const padB = opts.padB ?? 42;

  const ix = x + padL, iy = y + padT;
  const iw = w - padL - padR, ih = h - padT - padB;

  // Background
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.10)';
  ctx.fillRect(x,y,w,h);

  // Grid
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  const nx = opts.nx ?? 6;
  const ny = opts.ny ?? 5;
  for(let i=0;i<=nx;i++){
    const gx = ix + (iw*i/nx);
    ctx.beginPath(); ctx.moveTo(gx, iy); ctx.lineTo(gx, iy+ih); ctx.stroke();
  }
  for(let j=0;j<=ny;j++){
    const gy = iy + (ih*j/ny);
    ctx.beginPath(); ctx.moveTo(ix, gy); ctx.lineTo(ix+iw, gy); ctx.stroke();
  }

  // Axes border
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.strokeRect(ix,iy,iw,ih);

  // Ticks and labels
  ctx.fillStyle = 'rgba(234,240,255,0.85)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

  function xToPx(v){ return ix + (v-xMin)*iw/(xMax-xMin); }
  function yToPx(v){ return iy + ih - (v-yMin)*ih/(yMax-yMin); }

  const xticks = opts.xticks ?? 6;
  for(let i=0;i<=xticks;i++){
    const xv = xMin + (xMax-xMin)*i/xticks;
    const px = xToPx(xv);
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.beginPath(); ctx.moveTo(px, iy+ih); ctx.lineTo(px, iy+ih+6); ctx.stroke();
    const txt = (opts.xFmt ? opts.xFmt(xv) : xv.toFixed(0));
    ctx.fillText(txt, px-10, iy+ih+20);
  }
  const yticks = opts.yticks ?? 5;
  for(let j=0;j<=yticks;j++){
    const yv = yMin + (yMax-yMin)*j/yticks;
    const py = yToPx(yv);
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.beginPath(); ctx.moveTo(ix-6, py); ctx.lineTo(ix, py); ctx.stroke();
    const txt = (opts.yFmt ? opts.yFmt(yv) : yv.toFixed(2));
    ctx.fillText(txt, ix-46, py+4);
  }

  // Axis labels
  ctx.fillStyle = 'rgba(234,240,255,0.9)';
  ctx.font = '12.5px ' + getComputedStyle(document.body).fontFamily;
  if(opts.xLabel) ctx.fillText(opts.xLabel, ix + iw/2 - ctx.measureText(opts.xLabel).width/2, y + h - 10);
  if(opts.yLabel){
    ctx.save();
    ctx.translate(x + 14, iy + ih/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(opts.yLabel, -ctx.measureText(opts.yLabel).width/2, 0);
    ctx.restore();
  }

  // Title (inside plot)
  if(opts.title){
    ctx.fillStyle = 'rgba(234,240,255,0.95)';
    ctx.font = '13px ' + getComputedStyle(document.body).fontFamily;
    ctx.fillText(opts.title, ix, y + 16);
  }

  ctx.restore();
  return {plot:{x:ix,y:iy,w:iw,h:ih}, xToPx, yToPx};
}

function strokeLine(ctx, pts, strokeStyle, lineWidth){
  if(pts.length<2) return;
  ctx.save();
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = lineWidth ?? 2;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.stroke();
  ctx.restore();
}

function drawLegend(ctx, x, y, items){
  ctx.save();
  ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;
  let w = 0;
  items.forEach(it => {
    w = Math.max(w, 18 + ctx.measureText(it.label).width);
  });
  const h = 18*items.length + 10;
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(x, y, w+14, h, 10);
  ctx.fill(); ctx.stroke();

  items.forEach((it, i)=>{
    const yy = y + 8 + i*18 + 8;
    ctx.strokeStyle = it.color;
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(x+10, yy); ctx.lineTo(x+26, yy); ctx.stroke();
    ctx.fillStyle = 'rgba(234,240,255,0.92)';
    ctx.fillText(it.label, x+32, yy+4);
  });
  ctx.restore();
}

/* Polyfill for roundRect on older browsers */
if(!CanvasRenderingContext2D.prototype.roundRect){
  CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    this.beginPath();
    this.moveTo(x+rr, y);
    this.arcTo(x+w, y, x+w, y+h, rr);
    this.arcTo(x+w, y+h, x, y+h, rr);
    this.arcTo(x, y+h, x, y, rr);
    this.arcTo(x, y, x+w, y, rr);
    this.closePath();
    return this;
  };
}

/* =========================
   Drawing: Diagram
========================= */
function drawDiagram(ctx, W, H, theta, phi){
  ctx.clearRect(0,0,W,H);

  const box = {x:0,y:0,w:W,h:H};
  // Create a nice coordinate plane in the center
  const cx = W*0.52, cy = H*0.55;
  const Rpix = Math.min(W,H)*0.32;

  // Background subtle
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.10)';
  ctx.fillRect(0,0,W,H);
  ctx.restore();

  // Grid (polar-ish)
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 1;
  for(let k=1;k<=4;k++){
    ctx.beginPath();
    ctx.arc(cx,cy,Rpix*k/4,0,Math.PI*2);
    ctx.stroke();
  }
  for(let a=0;a<12;a++){
    const ang = a*Math.PI/6;
    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.lineTo(cx + Rpix*Math.cos(ang), cy - Rpix*Math.sin(ang));
    ctx.stroke();
  }
  ctx.restore();

  // Axes
  ctx.save();
  ctx.strokeStyle = 'rgba(234,240,255,0.22)';
  ctx.lineWidth = 2;
  // x axis
  ctx.beginPath();
  ctx.moveTo(cx-Rpix*1.05, cy);
  ctx.lineTo(cx+Rpix*1.05, cy);
  ctx.stroke();
  // y axis
  ctx.beginPath();
  ctx.moveTo(cx, cy+Rpix*1.05);
  ctx.lineTo(cx, cy-Rpix*1.05);
  ctx.stroke();
  ctx.fillStyle = 'rgba(234,240,255,0.85)';
  ctx.font = '13px ' + getComputedStyle(document.body).fontFamily;
  ctx.fillText('x', cx+Rpix*1.06, cy+14);
  ctx.fillText('y', cx-14, cy-Rpix*1.06);
  ctx.restore();

  // Polarizer axis (theta)
  const axX = Math.cos(theta), axY = Math.sin(theta);
  ctx.save();
  ctx.strokeStyle = 'rgba(125,211,252,0.95)';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(cx - Rpix*axX, cy + Rpix*axY);
  ctx.lineTo(cx + Rpix*axX, cy - Rpix*axY);
  ctx.stroke();

  // Small "polarizer plate" marker
  ctx.strokeStyle = 'rgba(125,211,252,0.55)';
  ctx.lineWidth = 8;
  ctx.beginPath();
  ctx.moveTo(cx + 0.55*Rpix*axX - 0.12*Rpix*axY, cy - 0.55*Rpix*axY - 0.12*Rpix*axX);
  ctx.lineTo(cx + 0.55*Rpix*axX + 0.12*Rpix*axY, cy - 0.55*Rpix*axY + 0.12*Rpix*axX);
  ctx.stroke();

  ctx.fillStyle = 'rgba(125,211,252,0.95)';
  ctx.font = '13px ' + getComputedStyle(document.body).fontFamily;
  ctx.fillText('Transmission axis (θ)', cx + Rpix*axX*0.62 + 6, cy - Rpix*axY*0.62 - 6);
  ctx.restore();

  // Input polarization direction (phi)
  const inX = Math.cos(phi), inY = Math.sin(phi);
  const inLen = Rpix*0.95;
  ctx.save();
  ctx.strokeStyle = 'rgba(167,139,250,0.95)';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx + inLen*inX, cy - inLen*inY);
  ctx.stroke();

  // Arrowhead
  const ah = 10;
  const ang = Math.atan2(-inY, inX);
  ctx.beginPath();
  ctx.moveTo(cx + inLen*inX, cy - inLen*inY);
  ctx.lineTo(cx + inLen*inX - ah*Math.cos(ang-0.45), cy - inLen*inY - ah*Math.sin(ang-0.45));
  ctx.lineTo(cx + inLen*inX - ah*Math.cos(ang+0.45), cy - inLen*inY - ah*Math.sin(ang+0.45));
  ctx.closePath();
  ctx.fillStyle = 'rgba(167,139,250,0.95)';
  ctx.fill();

  ctx.fillStyle = 'rgba(167,139,250,0.95)';
  ctx.font = '13px ' + getComputedStyle(document.body).fontFamily;
  ctx.fillText('Input E (φ)', cx + inLen*inX*0.55 + 6, cy - inLen*inY*0.55 - 6);
  ctx.restore();

  // Projected component along theta (output)
  const proj = Math.cos(phi-theta); // amplitude projection for unit input
  const outLen = Rpix*0.95*Math.abs(proj);
  const outSign = (proj >= 0) ? 1 : -1;
  ctx.save();
  ctx.strokeStyle = 'rgba(52,211,153,0.95)';
  ctx.lineWidth = 5;
  ctx.setLineDash([8,6]);
  ctx.beginPath();
  ctx.moveTo(cx,cy);
  ctx.lineTo(cx + outSign*outLen*axX, cy - outSign*outLen*axY);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = 'rgba(52,211,153,0.95)';
  ctx.font = '13px ' + getComputedStyle(document.body).fontFamily;
  ctx.fillText('Transmitted component', cx + outSign*outLen*axX*0.55 + 6, cy - outSign*outLen*axY*0.55 + 14);
  ctx.restore();

  // Angle annotations
  ctx.save();
  const rAng = Rpix*0.22;
  // theta arc from x axis
  ctx.strokeStyle = 'rgba(125,211,252,0.65)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  const t0 = 0; // along +x
  const t1 = -theta; // canvas y inverted => angle sign flip in drawing arcs
  ctx.arc(cx,cy,rAng, t0, t1, theta>0);
  ctx.stroke();
  ctx.fillStyle = 'rgba(125,211,252,0.85)';
  ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;
  ctx.fillText('θ', cx + rAng*0.95*Math.cos(-theta/2), cy + rAng*0.95*Math.sin(-theta/2) + 12);

  // phi arc (optional)
  ctx.strokeStyle = 'rgba(167,139,250,0.55)';
  ctx.beginPath();
  const p1 = -phi;
  ctx.arc(cx,cy,rAng*1.3, 0, p1, phi>0);
  ctx.stroke();
  ctx.fillStyle = 'rgba(167,139,250,0.85)';
  ctx.fillText('φ', cx + rAng*1.25*Math.cos(-phi/2), cy + rAng*1.25*Math.sin(-phi/2) + 12);

  ctx.restore();
}

/* =========================
   Plot: Malus' law
========================= */
function drawMainPlot(ctx, W, H, theta, phi){
  ctx.clearRect(0,0,W,H);

  const degMin=-90, degMax=90;
  const xMin=degMin, xMax=degMax;
  const yMin=0, yMax=1;

  const axes = drawAxes2D(ctx, {x:0,y:0,w:W,h:H}, xMin,xMax,yMin,yMax, {
    title: "Transmitted intensity ratio vs θ",
    xLabel: "Polarizer angle θ (deg)",
    yLabel: "Iout / Iin (dimensionless)",
    nx: 6, ny: 5,
    xticks: 6, yticks: 5,
    xFmt: v => v.toFixed(0),
    yFmt: v => v.toFixed(2)
  });

  // Curve
  const pts=[];
  for(let d=degMin; d<=degMax; d+=0.5){
    const th = d*DEG;
    const y = malus(phi, th);
    pts.push({x: axes.xToPx(d), y: axes.yToPx(y)});
  }
  strokeLine(ctx, pts, 'rgba(125,211,252,0.95)', 2.6);

  // Marker at current theta
  const thDeg = theta/DEG;
  const yNow = malus(phi, theta);
  const mx = axes.xToPx(thDeg);
  const my = axes.yToPx(yNow);

  ctx.save();
  ctx.fillStyle = 'rgba(251,191,36,0.95)';
  ctx.strokeStyle = 'rgba(251,191,36,0.35)';
  ctx.lineWidth = 10;
  ctx.beginPath(); ctx.arc(mx,my,4.8,0,Math.PI*2); ctx.fill();

  // Vertical line
  ctx.strokeStyle = 'rgba(251,191,36,0.25)';
  ctx.lineWidth = 1.6;
  ctx.beginPath(); ctx.moveTo(mx, axes.plot.y); ctx.lineTo(mx, axes.plot.y+axes.plot.h); ctx.stroke();

  // Annotate
  ctx.fillStyle = 'rgba(234,240,255,0.92)';
  ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;
  const label = `θ=${thDeg.toFixed(1)}°, I=${yNow.toFixed(3)}`;
  const tw = ctx.measureText(label).width;
  const lx = clamp(mx+10, axes.plot.x, axes.plot.x+axes.plot.w - tw - 6);
  const ly = clamp(my-14, axes.plot.y+14, axes.plot.y+axes.plot.h-10);

  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.strokeStyle = 'rgba(255,255,255,0.16)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.roundRect(lx-6, ly-14, tw+12, 20, 8); ctx.fill(); ctx.stroke();

  ctx.fillStyle = 'rgba(234,240,255,0.92)';
  ctx.fillText(label, lx, ly);
  ctx.restore();

  // Legend
  drawLegend(ctx, axes.plot.x + axes.plot.w - 190, axes.plot.y + 10, [
    {label:'Iout/Iin = cos²(φ−θ)', color:'rgba(125,211,252,0.95)'},
    {label:'Current θ', color:'rgba(251,191,36,0.95)'}
  ]);
}

/* =========================
   Secondary plot: output components or matrix elements
========================= */
function drawSecondaryPlot(ctx, W, H, theta, phi, mode){
  ctx.clearRect(0,0,W,H);

  const degMin=-90, degMax=90;
  const xMin=degMin, xMax=degMax;

  // Determine y-range based on mode
  let yMin, yMax, title, yLabel, legendItems;
  if(mode === 'out'){
    yMin = -1; yMax = 1;
    title = "Output field components vs θ (example input)";
    yLabel = "Amplitude (normalized)";
    legendItems = [
      {label:'Ex_out(θ)', color:'rgba(167,139,250,0.95)'},
      {label:'Ey_out(θ)', color:'rgba(52,211,153,0.95)'},
      {label:'Current θ', color:'rgba(251,191,36,0.95)'}
    ];
  }else{
    yMin = 0; yMax = 1;
    title = "Jones matrix elements vs θ";
    yLabel = "Value (dimensionless)";
    legendItems = [
      {label:'T11 = cos²θ', color:'rgba(167,139,250,0.95)'},
      {label:'T12 = sinθ cosθ', color:'rgba(52,211,153,0.95)'},
      {label:'T22 = sin²θ', color:'rgba(125,211,252,0.95)'},
      {label:'Current θ', color:'rgba(251,191,36,0.95)'}
    ];
  }

  const axes = drawAxes2D(ctx, {x:0,y:0,w:W,h:H}, xMin,xMax,yMin,yMax, {
    title,
    xLabel: "Polarizer angle θ (deg)",
    yLabel,
    nx: 6, ny: 5,
    xticks: 6, yticks: 5,
    xFmt: v => v.toFixed(0),
    yFmt: v => (mode==='out' ? v.toFixed(2) : v.toFixed(2))
  });

  // Curves
  const ptsA=[], ptsB=[], ptsC=[];
  for(let d=degMin; d<=degMax; d+=0.5){
    const th = d*DEG;

    if(mode === 'out'){
      const T = Ttheta(th);
      const Jin = linInput(phi);
      const Jout = matVec(T, Jin);
      ptsA.push({x: axes.xToPx(d), y: axes.yToPx(Jout[0])});
      ptsB.push({x: axes.xToPx(d), y: axes.yToPx(Jout[1])});
    }else{
      const c = Math.cos(th), s = Math.sin(th);
      const t11 = c*c;
      const t12 = s*c;
      const t22 = s*s;
      ptsA.push({x: axes.xToPx(d), y: axes.yToPx(t11)});
      ptsB.push({x: axes.xToPx(d), y: axes.yToPx(t12)});
      ptsC.push({x: axes.xToPx(d), y: axes.yToPx(t22)});
    }
  }

  // Draw lines
  if(mode === 'out'){
    strokeLine(ctx, ptsA, 'rgba(167,139,250,0.95)', 2.4);
    strokeLine(ctx, ptsB, 'rgba(52,211,153,0.95)', 2.4);
  }else{
    strokeLine(ctx, ptsA, 'rgba(167,139,250,0.95)', 2.2);
    strokeLine(ctx, ptsB, 'rgba(52,211,153,0.95)', 2.2);
    strokeLine(ctx, ptsC, 'rgba(125,211,252,0.95)', 2.2);
  }

  // Current theta marker (vertical + points)
  const thDeg = theta/DEG;
  const mx = axes.xToPx(thDeg);
  ctx.save();
  ctx.strokeStyle = 'rgba(251,191,36,0.25)';
  ctx.lineWidth = 1.6;
  ctx.beginPath(); ctx.moveTo(mx, axes.plot.y); ctx.lineTo(mx, axes.plot.y+axes.plot.h); ctx.stroke();

  function drawMarker(yVal){
    const my = axes.yToPx(yVal);
    ctx.fillStyle = 'rgba(251,191,36,0.95)';
    ctx.beginPath(); ctx.arc(mx,my,4.2,0,Math.PI*2); ctx.fill();
  }

  if(mode === 'out'){
    const T = Ttheta(theta);
    const Jin = linInput(phi);
    const Jout = matVec(T, Jin);
    drawMarker(Jout[0]);
    drawMarker(Jout[1]);
  }else{
    const c = Math.cos(theta), s = Math.sin(theta);
    drawMarker(c*c);
    drawMarker(s*c);
    drawMarker(s*s);
  }
  ctx.restore();

  // Legend
  drawLegend(ctx, axes.plot.x + axes.plot.w - 210, axes.plot.y + 10, legendItems);
}

/* =========================
   State + rendering loop
========================= */
const cDiagram = makeHiDPICanvas(document.getElementById('cDiagram'));
const cMain    = makeHiDPICanvas(document.getElementById('cMain'));
const cSec     = makeHiDPICanvas(document.getElementById('cSec'));

const elTheta = document.getElementById('theta');
const elPhi   = document.getElementById('phi');
const elMode  = document.getElementById('mode');

const thetaVal = document.getElementById('thetaVal');
const phiVal   = document.getElementById('phiVal');
const modeVal  = document.getElementById('modeVal');

const readTheta = document.getElementById('readTheta');
const readPhi   = document.getElementById('readPhi');
const readMalus = document.getElementById('readMalus');
const secSub    = document.getElementById('secSub');

function render(){
  // Resize all canvases to remain crisp
  cDiagram.resize(); cMain.resize(); cSec.resize();

  const thetaDeg = parseFloat(elTheta.value);
  const phiDeg   = parseFloat(elPhi.value);
  const theta = thetaDeg * DEG;
  const phi   = phiDeg * DEG;
  const mode  = elMode.value;

  // UI readouts
  thetaVal.textContent = thetaDeg.toFixed(1) + "°";
  phiVal.textContent   = phiDeg.toFixed(1) + "°";
  readTheta.textContent = thetaDeg.toFixed(1) + "°";
  readPhi.textContent   = phiDeg.toFixed(1) + "°";
  const I = malus(phi, theta);
  readMalus.textContent = I.toFixed(3);

  if(mode === 'out'){
    modeVal.textContent = "Output components";
    secSub.textContent = "Ex_out, Ey_out vs θ (example input)";
  }else{
    modeVal.textContent = "Matrix elements";
    secSub.textContent = "T11, T12, T22 vs θ";
  }

  // Draw
  const dRect = cDiagram.canvas.getBoundingClientRect();
  drawDiagram(cDiagram.ctx, dRect.width, dRect.height, theta, phi);

  const mRect = cMain.canvas.getBoundingClientRect();
  drawMainPlot(cMain.ctx, mRect.width, mRect.height, theta, phi);

  const sRect = cSec.canvas.getBoundingClientRect();
  drawSecondaryPlot(cSec.ctx, sRect.width, sRect.height, theta, phi, mode);
}

['input','change'].forEach(evt=>{
  elTheta.addEventListener(evt, render);
  elPhi.addEventListener(evt, render);
  elMode.addEventListener(evt, render);
});
window.addEventListener('resize', render);

// Initial
render();
</script>
</body>
</html>
