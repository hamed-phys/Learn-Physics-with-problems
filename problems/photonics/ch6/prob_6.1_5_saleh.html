<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Orthogonal Elliptical Polarizations: Perpendicular Major Axes & Opposite Rotation</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#101827;
      --card:#0f172a;
      --text:#e6edf7;
      --muted:#a8b3c7;
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.16);
      --accent:#6ee7ff;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 20% 10%, rgba(110,231,255,.10), transparent 60%),
        radial-gradient(1000px 600px at 80% 20%, rgba(167,139,250,.10), transparent 60%),
        linear-gradient(180deg, #070a10, var(--bg));
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      position:relative;
      padding: 28px 18px 18px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(16,24,39,.80), rgba(16,24,39,.25));
      backdrop-filter: blur(10px);
    }
    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding: 0 14px;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.4fr .9fr;
      gap:16px;
      align-items:stretch;
    }
    .title{
      padding:18px 18px 16px;
      background: rgba(15,23,42,.55);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .title:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(500px 260px at 15% 20%, rgba(110,231,255,.14), transparent 60%),
                  radial-gradient(500px 260px at 85% 60%, rgba(167,139,250,.12), transparent 60%);
      pointer-events:none;
      filter:saturate(1.05);
    }
    .title > *{position:relative}
    h1{
      margin:0 0 8px;
      font-size: clamp(22px, 2.2vw, 34px);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size: 14.5px;
    }
    .meta{
      margin-top:12px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      color:var(--muted);
      font-size: 12.5px;
    }
    .pill{
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      padding:6px 10px;
      border-radius:999px;
    }

    .toc{
      position:sticky;
      top:10px;
      align-self:start;
      background: rgba(15,23,42,.60);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:14px 14px 10px;
      backdrop-filter: blur(10px);
      max-height: calc(100vh - 22px);
      overflow:auto;
    }
    .toc h2{
      margin:0 0 10px;
      font-size: 13px;
      letter-spacing:.14em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .toc a{
      display:block;
      padding:7px 9px;
      border-radius: 10px;
      color: var(--text);
      border:1px solid transparent;
      font-size: 13.5px;
    }
    .toc a:hover{
      background: rgba(255,255,255,.04);
      border-color: var(--line);
      text-decoration:none;
    }

    main{padding: 18px 0 34px}
    section{
      margin: 14px 0 18px;
      padding: 18px;
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(15,23,42,.55);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    section h2{
      margin:0 0 10px;
      font-size: 18px;
    }
    section h3{
      margin:16px 0 8px;
      font-size: 15.5px;
      color: #dbe6ff;
    }
    p{margin: 10px 0}
    ul{margin: 10px 0 10px 22px}
    li{margin: 6px 0}
    .grid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
    }
    .grid2{
      display:grid;
      grid-template-columns: repeat(2, 1fr);
      gap:14px;
    }
    .card{
      border:1px solid var(--line);
      background: rgba(16,24,39,.55);
      border-radius: 16px;
      padding: 14px;
    }
    .callouts{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:12px;
      margin-top: 10px;
    }
    .callout{
      grid-column: span 6;
      border-radius: 16px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      padding: 12px 12px 10px;
      position:relative;
      overflow:hidden;
    }
    .callout:before{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(420px 220px at 15% 20%, rgba(110,231,255,.10), transparent 55%),
                  radial-gradient(420px 220px at 85% 65%, rgba(167,139,250,.08), transparent 60%);
      pointer-events:none;
      opacity:.9;
    }
    .callout > *{position:relative}
    .callout h4{
      margin:0 0 8px;
      font-size: 13px;
      letter-spacing:.12em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .callout.good{border-color: rgba(52,211,153,.30)}
    .callout.warn{border-color: rgba(251,191,36,.30)}
    .callout.bad{border-color: rgba(251,113,133,.30)}
    .kbd{
      font-family: var(--mono);
      font-size: 12.5px;
      padding: 2px 6px;
      border:1px solid var(--line2);
      border-radius: 8px;
      background: rgba(0,0,0,.25);
    }

    .eq{
      font-family: var(--mono);
      background: rgba(0,0,0,.25);
      border:1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
      overflow:auto;
      margin: 10px 0;
      position:relative;
    }
    .eq pre{
      margin:0;
      white-space:pre-wrap;
      word-break:break-word;
      font-size: 13px;
      line-height:1.45;
      color:#f3f7ff;
    }
    .eq .copyBtn{
      position:absolute;
      top:10px; right:10px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 12px;
      padding: 7px 10px;
      font-size: 12px;
      cursor:pointer;
      transition: transform .15s ease, background .15s ease;
    }
    .eq .copyBtn:hover{transform: translateY(-1px); background: rgba(255,255,255,.10)}
    .eq .copyBtn:active{transform: translateY(0px) scale(.98)}

    .viz{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    figure{
      margin:0;
      border:1px solid var(--line);
      border-radius: 16px;
      background: rgba(0,0,0,.20);
      overflow:hidden;
    }
    figcaption{
      padding: 10px 12px;
      border-top: 1px solid var(--line);
      color: var(--muted);
      font-size: 12.5px;
    }
    canvas{
      width:100%;
      height: 360px;
      display:block;
      background: rgba(0,0,0,.18);
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
      align-items: end;
    }
    .ctrl{
      border:1px solid var(--line);
      background: rgba(16,24,39,.55);
      border-radius: 16px;
      padding: 12px;
    }
    .ctrl label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 8px;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    select, button{
      width:100%;
      padding:10px 10px;
      border-radius: 14px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      color: var(--text);
      font-size: 13px;
    }
    button{
      cursor:pointer;
      transition: transform .15s ease, background .15s ease;
    }
    button:hover{transform: translateY(-1px); background: rgba(255,255,255,.10)}
    button:active{transform: translateY(0px) scale(.99)}
    .small{
      font-size: 12.5px;
      color: var(--muted);
    }

    footer{
      padding: 18px 0 26px;
      color: var(--muted);
      font-size: 12.5px;
      border-top: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(16,24,39,.05), rgba(16,24,39,.30));
    }

    /* subtle motion, respects reduced-motion */
    @media (prefers-reduced-motion: no-preference){
      section{animation: pop .35s ease both}
      @keyframes pop{from{opacity:0; transform: translateY(6px)} to{opacity:1; transform: translateY(0)}}
    }

    @media (max-width: 980px){
      .hero{grid-template-columns: 1fr}
      .toc{position:relative; top:0}
      .grid{grid-template-columns:1fr}
      .grid2{grid-template-columns:1fr}
      .controls{grid-template-columns:1fr}
      canvas{height: 320px}
      .callout{grid-column: span 12}
    }

    @media print{
      body{background:#fff; color:#000}
      header, footer{background:#fff}
      section, .title, .toc, .card, .ctrl, figure{box-shadow:none}
      .toc{position:relative; max-height:none}
      .eq .copyBtn, button{display:none !important}
      canvas{height: 260px}
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="hero">
        <div class="title">
          <h1>6.1-5 Orthogonal Polarizations</h1>
          <p class="subtitle">
            Show that if two <b>elliptically polarized</b> states are <b>orthogonal</b>, then their polarization ellipses have
            <b>perpendicular major axes</b> and <b>opposite senses of rotation</b>.
          </p>
          <div class="meta">
            <span class="pill">Tools: Jones vectors • Stokes parameters • Poincaré sphere</span>
            <span class="pill">Result: symbolic proof (with interactive visuals)</span>
            <span class="pill">Assumptions: monochromatic, fully polarized, same basis</span>
          </div>
        </div>

        <nav class="toc" aria-label="Table of contents">
          <h2>Contents</h2>
          <a href="#quick" data-scroll>Quick Summary</a>
          <a href="#part0" data-scroll>PART 0 — Concept Primer</a>
          <a href="#part1" data-scroll>PART 1 — Problem Analysis</a>
          <a href="#part2" data-scroll>PART 2 — Strategy & Tips</a>
          <a href="#part3" data-scroll>PART 3 — Full Solution</a>
          <a href="#part4" data-scroll>PART 4 — Deeper Understanding</a>
          <a href="#part5" data-scroll>PART 5 — Visualization Guide</a>
          <a href="#viz" data-scroll>Interactive Visualizations</a>
        </nav>
      </div>
    </div>
  </header>

  <main>
    <div class="wrap">

      <section id="quick">
        <h2>Quick Summary</h2>
        <ul>
          <li>We model a fully polarized monochromatic field by a <b>Jones vector</b> <span class="kbd">|E⟩</span> (complex 2-vector).</li>
          <li><b>Orthogonality</b> means <span class="kbd">⟨E₁|E₂⟩ = 0</span> (complex inner product in the same transverse basis).</li>
          <li>Polarization ellipse is captured by <b>azimuth</b> (orientation) <span class="kbd">ψ</span> and <b>ellipticity angle</b> <span class="kbd">χ</span>.</li>
          <li>Stokes (normalized) satisfy: <span class="kbd">S₁ = cos(2χ)cos(2ψ)</span>, <span class="kbd">S₂ = cos(2χ)sin(2ψ)</span>, <span class="kbd">S₃ = sin(2χ)</span>.</li>
          <li>Key physics idea: on the <b>Poincaré sphere</b>, <b>orthogonal states are antipodes</b> (their Stokes vectors differ by a minus sign).</li>
          <li>Antipodes imply <span class="kbd">ψ₂ = ψ₁ + 90°</span> (major axes perpendicular) and <span class="kbd">χ₂ = −χ₁</span> (opposite handedness / rotation sense).</li>
          <li>Final result type: <b>symbolic proof</b> with a geometric interpretation + numerical checks in the plots.</li>
        </ul>
      </section>

      <section id="part0">
        <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

        <article class="grid">
          <div class="card">
            <h3>Core definitions (symbols & meaning)</h3>
            <p>
              Consider a monochromatic transverse electric field (propagating along +z):
              <span class="kbd">E(t) = Re{ (E<sub>x</sub> x̂ + E<sub>y</sub> ŷ) e<sup>iωt</sup> }</span>,
              where <span class="kbd">E<sub>x</sub>, E<sub>y</sub></span> are complex amplitudes.
            </p>
            <ul>
              <li><b>Jones vector</b> (units: field amplitude, often normalized):
                <span class="kbd">|E⟩ = [E<sub>x</sub>, E<sub>y</sub>]<sup>T</sup></span>.
              </li>
              <li><b>Orthogonality</b> (same basis): <span class="kbd">⟨E₁|E₂⟩ = E<sub>1x</sub>*E<sub>2x</sub> + E<sub>1y</sub>*E<sub>2y</sub> = 0</span>.</li>
              <li><b>Polarization ellipse</b>: the tip of <span class="kbd">E(t)</span> traces an ellipse in the x–y plane.</li>
              <li><b>Azimuth</b> <span class="kbd">ψ</span> (radians or degrees): orientation of the ellipse’s <b>major axis</b> measured from +x.</li>
              <li><b>Ellipticity angle</b> <span class="kbd">χ</span> (radians or degrees): defined by <span class="kbd">tan χ = b/a</span> where <span class="kbd">a</span>, <span class="kbd">b</span> are semi-major/minor axes magnitudes; sign encodes handedness (rotation sense).</li>
            </ul>

            <div class="callouts">
              <div class="callout good">
                <h4>Physical meaning</h4>
                <p>
                  <span class="kbd">ψ</span> tells you <b>which way the ellipse is tilted</b>.
                  <span class="kbd">χ</span> tells you <b>how circular vs linear</b> the polarization is and <b>which direction the field rotates</b> in time.
                </p>
              </div>
              <div class="callout warn">
                <h4>When valid</h4>
                <p>
                  Jones calculus assumes <b>fully polarized</b>, <b>monochromatic</b> light (well-defined phase relation between x and y).
                  For partially polarized light you need Mueller/Stokes coherence theory.
                </p>
              </div>
            </div>
          </div>

          <div class="card">
            <h3>Stokes parameters & Poincaré sphere</h3>
            <p>
              For a normalized Jones vector (so total intensity is 1), the <b>normalized Stokes vector</b>
              <span class="kbd">S = (S₁,S₂,S₃)</span> lies on the unit sphere.
            </p>

            <div class="eq" data-copy="S0 = |Ex|^2 + |Ey|^2
S1 = |Ex|^2 - |Ey|^2
S2 = 2 Re(Ex Ey*)
S3 = 2 Im(Ex Ey*)
(normalized: divide by S0)">
              <button class="copyBtn" type="button">Copy</button>
              <pre><b>Stokes (from Jones):</b>
S0 = |Ex|^2 + |Ey|^2
S1 = |Ex|^2 - |Ey|^2
S2 = 2 Re(Ex Ey*)
S3 = 2 Im(Ex Ey*)
(normalized: divide by S0)</pre>
            </div>

            <p>
              A convenient parameterization of any pure polarization state uses ellipse angles <span class="kbd">ψ</span> and <span class="kbd">χ</span>:
            </p>
            <div class="eq" data-copy="S1 = cos(2χ) cos(2ψ)
S2 = cos(2χ) sin(2ψ)
S3 = sin(2χ)">
              <button class="copyBtn" type="button">Copy</button>
              <pre><b>Ellipse angles → Stokes:</b>
S1 = cos(2χ) cos(2ψ)
S2 = cos(2χ) sin(2ψ)
S3 = sin(2χ)</pre>
            </div>

            <h3>Mini intuition examples</h3>
            <ul>
              <li><b>Linear polarization</b>: <span class="kbd">χ = 0</span> ⇒ <span class="kbd">S3=0</span> (equator). Angle <span class="kbd">ψ</span> is just the line direction.</li>
              <li><b>Circular polarization</b>: <span class="kbd">|χ| = 45°</span> ⇒ <span class="kbd">S1=S2=0</span>, <span class="kbd">S3=±1</span> (north/south poles). Major axis is undefined (circle).</li>
            </ul>

            <div class="callouts">
              <div class="callout bad">
                <h4>What to watch for</h4>
                <ul>
                  <li>Orthogonality depends on using the <b>same transverse basis</b> and inner product.</li>
                  <li>Handedness depends on a <b>sign convention</b> (time dependence and viewing direction). Be consistent.</li>
                  <li>For nearly circular states, “major axis” becomes ill-conditioned; treat as a limit.</li>
                </ul>
              </div>
              <div class="callout">
                <h4>Why Poincaré helps</h4>
                <p>
                  Many ellipse statements become simple geometry: orthogonality ↔ antipodal points on a sphere.
                </p>
              </div>
            </div>
          </div>
        </article>
      </section>

      <section id="part1">
        <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

        <article class="card">
          <h3>Restate the problem</h3>
          <p>
            We have two fully polarized <b>elliptically polarized</b> states (two Jones vectors).
            We are told they are <b>orthogonal</b> as polarization states. We must <b>prove</b> that:
          </p>
          <ul>
            <li>The <b>major axes</b> of their polarization ellipses are <b>perpendicular</b>.</li>
            <li>Their <b>senses of rotation</b> (handedness) are <b>opposite</b>.</li>
          </ul>

          <h3>Given / Unknowns</h3>
          <ul>
            <li><b>Given:</b> Two elliptically polarized states with Jones vectors <span class="kbd">|E₁⟩</span>, <span class="kbd">|E₂⟩</span>, and <span class="kbd">⟨E₁|E₂⟩=0</span>.</li>
            <li><b>Unknowns:</b> Relationship between ellipse parameters <span class="kbd">(ψ₁, χ₁)</span> and <span class="kbd">(ψ₂, χ₂)</span>.</li>
            <li><b>Must show/prove:</b> <span class="kbd">ψ₂ = ψ₁ + 90°</span> and <span class="kbd">χ₂ = −χ₁</span> (modulo conventional periodicities).</li>
          </ul>

          <h3>Relevant principles (and why)</h3>
          <ul>
            <li><b>Jones inner product</b> defines orthogonality of coherent polarization states (valid because we assume fully polarized monochromatic light).</li>
            <li><b>Stokes/Poincaré representation</b> gives a geometric mapping from a Jones state to a point on the unit sphere (valid for pure states).</li>
            <li>Ellipse geometry: major-axis orientation is <span class="kbd">ψ</span>; rotation sense is encoded by the sign of <span class="kbd">χ</span> (or equivalently <span class="kbd">S₃</span>).</li>
          </ul>

          <div class="callouts">
            <div class="callout warn">
              <h4>Assumptions</h4>
              <ul>
                <li>Monochromatic field with time dependence <span class="kbd">e^{iωt}</span>.</li>
                <li>Fully polarized (pure state), so a single Jones vector applies.</li>
                <li>Same propagation direction and same transverse axes (x̂, ŷ) for both states.</li>
                <li>Normalization allowed (overall amplitude and global phase do not change polarization).</li>
              </ul>
            </div>
            <div class="callout">
              <h4>What we do NOT need</h4>
              <p>
                No material interaction, no Fresnel coefficients, no spatial propagation—this is a <b>state geometry</b> proof.
              </p>
            </div>
          </div>

          <h3>Possible approaches (compare & choose)</h3>
          <ol>
            <li>
              <b>Direct Jones algebra</b>: write general elliptical Jones vectors and solve <span class="kbd">⟨E₁|E₂⟩=0</span>.
              <span class="small">Pros: explicit. Cons: messy; easy to lose physical meaning.</span>
            </li>
            <li>
              <b>Stokes/Poincaré sphere</b>: use the fact that orthogonal pure states are antipodal on the sphere, then translate antipode condition into <span class="kbd">ψ,χ</span>.
              <span class="small">Pros: clean and conceptual. Cons: requires knowing the mapping.</span>
            </li>
            <li>
              <b>Ellipse matrix method</b>: use polarization ellipse quadratic form and show orthogonality implies perpendicular principal axes.
              <span class="small">Pros: geometric. Cons: heavier linear algebra.</span>
            </li>
          </ol>
          <p>
            <b>Best choice:</b> the <b>Poincaré sphere</b> method is shortest and most instructive, and it directly connects to “major axis” and “handedness”.
            We will still provide a brief Jones-based consistency check.
          </p>
        </article>
      </section>

      <section id="part2">
        <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

        <article class="card">
          <ol>
            <li>
              <b>Normalize</b> the Jones vectors (remove global amplitude and phase).<br/>
              <span class="small">Tool: normalization; note polarization is unchanged.</span>
            </li>
            <li>
              Map each state to a <b>normalized Stokes vector</b> <span class="kbd">S = (S₁,S₂,S₃)</span> on the unit sphere.<br/>
              <span class="small">Tool: Stokes-from-Jones formulas.</span>
            </li>
            <li>
              Use the key pure-state fact: <b>orthogonality ⇔ antipodes</b>: <span class="kbd">S₂ = −S₁</span> (vector negation).<br/>
              <span class="small">Tool: Bloch-sphere analogy / SU(2) geometry.</span>
            </li>
            <li>
              Convert the antipode relation <span class="kbd">S' = −S</span> into relations between <span class="kbd">ψ</span> and <span class="kbd">χ</span> using
              <span class="kbd">S₁,S₂,S₃</span> in terms of <span class="kbd">ψ,χ</span>.<br/>
              <span class="small">Physical meaning: how ellipse tilt and handedness change.</span>
            </li>
            <li>
              Interpret: <span class="kbd">ψ → ψ+90°</span> means perpendicular major axes; <span class="kbd">χ → −χ</span> means opposite rotation sense.<br/>
              <span class="small">Check limiting cases (linear, circular).</span>
            </li>
            <li>
              Do a quick sanity check with a representative Jones vector: compute the orthogonal partner and read off its ellipse parameters.
            </li>
          </ol>

          <div class="callouts">
            <div class="callout bad">
              <h4>Common mistakes</h4>
              <ul>
                <li>Confusing <b>orthogonal polarization states</b> with <b>perpendicular electric fields at one instant</b>.</li>
                <li>Forgetting the complex conjugate in the inner product <span class="kbd">⟨E₁|E₂⟩</span>.</li>
                <li>Mixing sign conventions for <span class="kbd">S₃</span> (handedness) and time dependence.</li>
              </ul>
            </div>
            <div class="callout good">
              <h4>Quick tips</h4>
              <ul>
                <li>Think “<b>Bloch sphere</b>”: orthogonal qubit states are antipodal; polarization is the same math.</li>
                <li>Use <span class="kbd">S₃</span> to track handedness: opposite rotation means <span class="kbd">S₃</span> flips sign.</li>
              </ul>
            </div>
          </div>
        </article>
      </section>

      <section id="part3">
        <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

        <article class="card">
          <h3>Physical intuition before math</h3>
          <p>
            Orthogonal polarization states are the polarization analog of perpendicular vectors in a complex 2D space:
            they carry <b>no mutual coherent overlap</b> (a perfect polarizer for one blocks the other).
            On the Poincaré sphere, “no overlap” becomes the most separated possibility: <b>antipodal points</b>.
            Antipodes reverse the “ellipse descriptor”:
            the ellipse tilt must rotate by 90° (to flip the equatorial components), and the handedness must flip (to reverse <span class="kbd">S₃</span>).
          </p>

          <h3>Step 1 — Represent polarization as a normalized Jones state</h3>
          <p>
            Let the two polarization states be described by Jones vectors (in the same x–y basis):
          </p>
          <div class="eq" data-copy="|E1⟩ = [E1x, E1y]^T ,  |E2⟩ = [E2x, E2y]^T
Orthogonality: ⟨E1|E2⟩ = E1x* E2x + E1y* E2y = 0">
            <button class="copyBtn" type="button">Copy</button>
            <pre><b>Jones vectors & orthogonality:</b>
|E1⟩ = [E1x, E1y]^T ,  |E2⟩ = [E2x, E2y]^T
Orthogonality: ⟨E1|E2⟩ = E1x* E2x + E1y* E2y = 0</pre>
          </div>
          <p>
            We may normalize so that <span class="kbd">⟨E|E⟩ = 1</span>, because overall amplitude does not change polarization.
            Global phase also does not change the polarization ellipse.
          </p>

          <h3>Step 2 — Map to the (normalized) Stokes vector</h3>
          <p>
            For a normalized Jones state <span class="kbd">|E⟩</span>, define normalized Stokes parameters:
          </p>
          <div class="eq" data-copy="S1 = |Ex|^2 - |Ey|^2
S2 = 2 Re(Ex Ey*)
S3 = 2 Im(Ex Ey*)
For normalized |E|^2=|Ex|^2+|Ey|^2=1, we have S1^2+S2^2+S3^2=1">
            <button class="copyBtn" type="button">Copy</button>
            <pre><b>Normalized Stokes (pure state):</b>
S1 = |Ex|^2 - |Ey|^2
S2 = 2 Re(Ex Ey*)
S3 = 2 Im(Ex Ey*)
For |Ex|^2+|Ey|^2=1 ⇒ S1^2+S2^2+S3^2=1</pre>
          </div>
          <p>
            So each polarization state corresponds to a point on the unit Poincaré sphere.
          </p>

          <h3>Step 3 — Use the key theorem: orthogonal pure states are antipodal</h3>
          <p>
            Polarization states are mathematically equivalent to qubit states (both are 2D complex normalized vectors modulo global phase).
            For pure states, the mapping to the sphere has the property:
          </p>
          <div class="eq" data-copy="If ⟨E1|E2⟩ = 0 (orthogonal pure states),
then their Stokes vectors satisfy S2 = -S1 (vector negation):
(S1,S2,S3)_2 = -(S1,S2,S3)_1">
            <button class="copyBtn" type="button">Copy</button>
            <pre><b>Orthogonality ⇔ antipodes (pure states):</b>
If ⟨E1|E2⟩ = 0,
then S(E2) = - S(E1),
i.e. (S1,S2,S3)_2 = -(S1,S2,S3)_1</pre>
          </div>
          <p>
            <b>What did we do and why?</b><br/>
            Instead of solving a complex inner-product equation directly, we use the geometry of the state space:
            the only way two pure states can be perfectly orthogonal is to be maximally separated on the sphere—antipodal.
          </p>

          <h3>Step 4 — Express Stokes in terms of ellipse angles (ψ, χ)</h3>
          <p>
            For an ellipse with azimuth <span class="kbd">ψ</span> and ellipticity angle <span class="kbd">χ</span>, the normalized Stokes parameters are:
          </p>
          <div class="eq" data-copy="S1 = cos(2χ) cos(2ψ)
S2 = cos(2χ) sin(2ψ)
S3 = sin(2χ)">
            <button class="copyBtn" type="button">Copy</button>
            <pre><b>Ellipse parameters:</b>
S1 = cos(2χ) cos(2ψ)
S2 = cos(2χ) sin(2ψ)
S3 = sin(2χ)</pre>
          </div>

          <h3>Step 5 — Impose antipode condition and solve for ψ₂, χ₂</h3>
          <p>
            Let state 1 have angles <span class="kbd">(ψ₁, χ₁)</span> and state 2 have <span class="kbd">(ψ₂, χ₂)</span>.
            Antipodes mean:
          </p>
          <div class="eq" data-copy="cos(2χ2) cos(2ψ2) = - cos(2χ1) cos(2ψ1)
cos(2χ2) sin(2ψ2) = - cos(2χ1) sin(2ψ1)
sin(2χ2)          = - sin(2χ1)">
            <button class="copyBtn" type="button">Copy</button>
            <pre><b>Antipode equations:</b>
cos(2χ2) cos(2ψ2) = - cos(2χ1) cos(2ψ1)
cos(2χ2) sin(2ψ2) = - cos(2χ1) sin(2ψ1)
sin(2χ2)          = - sin(2χ1)</pre>
          </div>

          <p>
            From the third line:
            <span class="kbd">sin(2χ₂) = −sin(2χ₁)</span> ⇒ one consistent choice is
            <span class="kbd">χ₂ = −χ₁</span> (modulo periodicities).
          </p>
          <p>
            With <span class="kbd">χ₂ = −χ₁</span>, we have <span class="kbd">cos(2χ₂) = cos(2χ₁)</span>.
            Then the first two lines become:
            <span class="kbd">cos(2ψ₂)=−cos(2ψ₁)</span> and <span class="kbd">sin(2ψ₂)=−sin(2ψ₁)</span>,
            which is exactly:
            <span class="kbd">2ψ₂ = 2ψ₁ + 180°</span> ⇒ <span class="kbd">ψ₂ = ψ₁ + 90°</span>.
          </p>

          <div class="eq" data-copy="Orthogonal elliptical states:
ψ2 = ψ1 + 90°  (major axes perpendicular)
χ2 = -χ1       (opposite handedness / rotation sense)">
            <button class="copyBtn" type="button">Copy</button>
            <pre><b>Result (boxed):</b>
Orthogonal elliptical states satisfy
ψ2 = ψ1 + 90°   (major axes perpendicular)
χ2 = -χ1        (opposite handedness / rotation sense)</pre>
          </div>

          <h3>Interpretation in plain language</h3>
          <p>
            The polarization ellipse of the orthogonal partner is the “same shape” (same |χ|, hence same axis ratio),
            but its tilt is rotated by 90° and the field rotates the other way in time.
          </p>

          <h3>Sanity checks</h3>
          <ul>
            <li><b>Units/dimensions:</b> <span class="kbd">ψ</span>, <span class="kbd">χ</span> are angles (dimensionless). Consistent.</li>
            <li><b>Limiting case (linear):</b> If <span class="kbd">χ₁=0</span>, both are linear; result gives <span class="kbd">χ₂=0</span> and <span class="kbd">ψ₂=ψ₁+90°</span>, i.e. orthogonal linear polarizations—correct.</li>
            <li><b>Limiting case (circular):</b> If <span class="kbd">χ₁=+45°</span>, then <span class="kbd">χ₂=-45°</span>: opposite circular handedness. Major axis is undefined, but the “perpendicular axis” statement is approached as a limit—acceptable.</li>
            <li><b>Sign/rotation:</b> Handedness is controlled by <span class="kbd">S₃=sin(2χ)</span>; flipping χ flips <span class="kbd">S₃</span> ⇒ opposite rotation sense.</li>
          </ul>

          <p>
            <b>Connection to the diagram/plots:</b><br/>
            In the interactive visualizations below, you can pick <span class="kbd">ψ₁</span> and <span class="kbd">χ₁</span>.
            The page automatically constructs the orthogonal state using <span class="kbd">ψ₂=ψ₁+90°</span>, <span class="kbd">χ₂=-χ₁</span>,
            and shows: (i) two ellipses with perpendicular major axes, (ii) antipodal Stokes points on the Poincaré sphere,
            and (iii) time traces and rotation direction.
          </p>
        </article>

        <article class="card">
          <h3>Optional quick Jones consistency check (short)</h3>
          <p>
            A convenient Jones parameterization consistent with the Stokes mapping is:
          </p>
          <div class="eq" data-copy="For azimuth ψ and ellipticity χ (normalized):
Ex =  cosχ cosψ  - i sinχ sinψ
Ey =  cosχ sinψ  + i sinχ cosψ">
            <button class="copyBtn" type="button">Copy</button>
            <pre><b>Jones from (ψ,χ):</b>
Ex =  cosχ cosψ  - i sinχ sinψ
Ey =  cosχ sinψ  + i sinχ cosψ</pre>
          </div>
          <p>
            If we set <span class="kbd">ψ₂=ψ₁+90°</span>, <span class="kbd">χ₂=-χ₁</span>, the resulting <span class="kbd">|E₂⟩</span>
            is orthogonal to <span class="kbd">|E₁⟩</span> up to a global phase (the inner product is zero).
            The interactive panel numerically verifies <span class="kbd">⟨E₁|E₂⟩≈0</span>.
          </p>
        </article>
      </section>

      <section id="part4">
        <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

        <article class="grid2">
          <div class="card">
            <h3>Re-interpreting the final relations</h3>
            <ul>
              <li><span class="kbd">ψ₂ = ψ₁ + 90°</span>: the ellipse’s <b>principal direction</b> rotates by a right angle, so major axes are perpendicular.</li>
              <li><span class="kbd">χ₂ = −χ₁</span>: the magnitude <span class="kbd">|χ|</span> (axis ratio) is the same, but the sign flips, so <span class="kbd">S₃</span> flips and the <b>rotation sense reverses</b>.</li>
              <li>On the sphere: <span class="kbd">S → −S</span> flips all components. The equatorial projection flips by 180°, equivalent to <span class="kbd">ψ → ψ+90°</span> because Stokes uses <span class="kbd">2ψ</span>.</li>
            </ul>

            <div class="callouts">
              <div class="callout good">
                <h4>Parameter effects</h4>
                <p>
                  Increase <span class="kbd">|χ₁|</span> toward 45° → ellipse becomes more circular and the antipode moves toward the opposite pole.
                  Change <span class="kbd">ψ₁</span> → both points rotate around the sphere’s vertical axis together, staying antipodal.
                </p>
              </div>
              <div class="callout warn">
                <h4>Near-circular nuance</h4>
                <p>
                  When <span class="kbd">|χ| → 45°</span>, the ellipse becomes a circle; the “major axis” is not unique.
                  The formula <span class="kbd">ψ₂=ψ₁+90°</span> is still consistent as a limiting statement about how the equatorial components flip.
                </p>
              </div>
            </div>
          </div>

          <div class="card">
            <h3>Alternative derivation idea (brief)</h3>
            <p>
              Another route is purely Jones-algebraic:
              if <span class="kbd">|E₁⟩ = [a, b]^T</span> (normalized), a guaranteed orthogonal vector is
              <span class="kbd">|E₂⟩ = [-b*, a*]^T</span>.
              One can then compute Stokes parameters of both and show they differ by a minus sign, recovering the same <span class="kbd">(ψ,χ)</span> relations.
            </p>

            <h3>Concept checks (self-test)</h3>
            <ul>
              <li><b>Q:</b> If state 1 is linear at <span class="kbd">ψ₁=20°</span>, what is the orthogonal partner?<br/>
                  <b>A:</b> Linear (<span class="kbd">χ₂=0</span>) at <span class="kbd">ψ₂=110°</span>.</li>
              <li><b>Q:</b> What changes sign when switching to the orthogonal state on the Poincaré sphere?<br/>
                  <b>A:</b> All Stokes components: <span class="kbd">(S₁,S₂,S₃) → (−S₁,−S₂,−S₃)</span>.</li>
              <li><b>Q:</b> Which Stokes component tracks handedness most directly?<br/>
                  <b>A:</b> <span class="kbd">S₃</span> (it flips sign for opposite rotation).</li>
              <li><b>Q:</b> Why does a 90° change in <span class="kbd">ψ</span> correspond to a 180° change on the sphere?<br/>
                  <b>A:</b> Because Stokes uses <span class="kbd">2ψ</span> in <span class="kbd">cos(2ψ), sin(2ψ)</span>.</li>
            </ul>
          </div>
        </article>

        <article class="card">
          <h3>Final Answer (copyable)</h3>
          <div class="eq" data-copy="If two fully polarized elliptically polarized states |E1⟩ and |E2⟩ are orthogonal (⟨E1|E2⟩=0),
then their normalized Stokes vectors satisfy S(E2) = −S(E1).
Writing S1 = cos(2χ)cos(2ψ), S2 = cos(2χ)sin(2ψ), S3 = sin(2χ),
the antipode condition implies χ2 = −χ1 and ψ2 = ψ1 + 90°.
Therefore the polarization ellipses have perpendicular major axes and opposite senses of rotation.">
            <button class="copyBtn" type="button">Copy</button>
            <pre><b>Final result:</b>
If two fully polarized elliptically polarized states |E1⟩ and |E2⟩ are orthogonal (⟨E1|E2⟩=0),
then their normalized Stokes vectors satisfy S(E2) = −S(E1).
With S1 = cos(2χ)cos(2ψ), S2 = cos(2χ)sin(2ψ), S3 = sin(2χ),
this implies χ2 = −χ1 and ψ2 = ψ1 + 90°.
Hence the ellipses have perpendicular major axes and opposite rotation sense.</pre>
          </div>
        </article>
      </section>

      <section id="part5">
        <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

        <article class="card">
          <h3>What each canvas shows</h3>
          <ul>
            <li><b>Canvas A (Diagram):</b> Two polarization ellipses in the x–y plane. The drawn major axes (thicker lines) should be perpendicular when states are orthogonal.</li>
            <li><b>Canvas B (Main quantitative plot):</b> A Poincaré sphere view (orthographic projection). Point <span class="kbd">S₁</span> represents state 1; point <span class="kbd">S₂</span> represents the orthogonal state and should appear exactly opposite (antipodal).</li>
            <li><b>Canvas C (Secondary plot):</b> Time traces <span class="kbd">E_x(t)</span> and <span class="kbd">E_y(t)</span> for both states over one period (normalized units). This helps you see the phase relationship and rotation sense.</li>
          </ul>

          <h3>Interactive controls</h3>
          <ul>
            <li><b>Azimuth ψ₁ (deg):</b> Rotates the ellipse of state 1. The orthogonal ellipse rotates with it but stays 90° away.</li>
            <li><b>Ellipticity χ₁ (deg):</b> Changes how circular the polarization is and the handedness (sign). The orthogonal partner flips the sign (opposite handedness).</li>
            <li><b>View angle:</b> Rotates the displayed Poincaré sphere projection (purely for visualization). Physics does not change.</li>
          </ul>

          <p class="small">
            Note: Numerical values here are “example values” only—this problem’s final result is symbolic. The plots simply illustrate the symbolic relationships.
          </p>
        </article>
      </section>

      <section id="viz">
        <h2>Interactive Visualizations</h2>

        <div class="controls" aria-label="Interactive controls">
          <div class="ctrl">
            <label for="psi">
              <span>Azimuth ψ₁ (deg)</span>
              <span class="kbd" id="psiVal">20.0°</span>
            </label>
            <input id="psi" type="range" min="-90" max="90" value="20" step="0.1" />
            <div class="small">Ellipse tilt angle of state 1. Orthogonal: ψ₂ = ψ₁ + 90°.</div>
          </div>

          <div class="ctrl">
            <label for="chi">
              <span>Ellipticity χ₁ (deg)</span>
              <span class="kbd" id="chiVal">15.0°</span>
            </label>
            <input id="chi" type="range" min="-44" max="44" value="15" step="0.1" />
            <div class="small">Shape/handedness of state 1. Orthogonal: χ₂ = −χ₁.</div>
          </div>

          <div class="ctrl">
            <label for="view">
              <span>Poincaré view angle</span>
              <span class="kbd" id="viewVal">25°</span>
            </label>
            <input id="view" type="range" min="-60" max="60" value="25" step="1" />
            <button id="randomBtn" type="button" style="margin-top:10px">Random example state</button>
            <div class="small" id="innerProdLine">⟨E₁|E₂⟩ = (0.0000 + 0.0000 i)</div>
          </div>
        </div>

        <div class="viz" style="margin-top:12px">
          <figure>
            <canvas id="cDiagram" aria-label="Diagram: polarization ellipses"></canvas>
            <figcaption><b>Canvas A.</b> Polarization ellipses (state 1 and its orthogonal partner). Major axes are drawn and labeled.</figcaption>
          </figure>

          <figure>
            <canvas id="cSphere" aria-label="Main plot: Poincare sphere"></canvas>
            <figcaption><b>Canvas B.</b> Poincaré sphere view (unitless Stokes axes). Orthogonal states appear as antipodes: S₂ = −S₁.</figcaption>
          </figure>

          <figure>
            <canvas id="cTime" aria-label="Secondary plot: time traces"></canvas>
            <figcaption><b>Canvas C.</b> Time traces Ex(t), Ey(t) (normalized amplitude units) for both states. Handedness flips between them.</figcaption>
          </figure>
        </div>
      </section>

    </div>
  </main>

  <footer>
    <div class="wrap">
      <p style="margin:0">
        Built as a self-contained learning article (vanilla HTML/CSS/JS). Tip: use the sliders to confirm perpendicular axes and opposite handedness visually.
      </p>
    </div>
  </footer>

  <script>
    // ---------- Smooth scrolling for TOC ----------
    document.querySelectorAll('[data-scroll]').forEach(a=>{
      a.addEventListener('click', (e)=>{
        e.preventDefault();
        const id = a.getAttribute('href');
        const el = document.querySelector(id);
        if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
      });
    });

    // ---------- Copy buttons ----------
    function flash(btn, msg){
      const old = btn.textContent;
      btn.textContent = msg;
      btn.style.borderColor = "rgba(52,211,153,.45)";
      setTimeout(()=>{ btn.textContent = old; btn.style.borderColor = ""; }, 900);
    }
    document.querySelectorAll('.eq').forEach(eq=>{
      const btn = eq.querySelector('.copyBtn');
      if(!btn) return;
      btn.addEventListener('click', async ()=>{
        const text = eq.getAttribute('data-copy') || eq.innerText;
        try{
          await navigator.clipboard.writeText(text.trim());
          flash(btn, "Copied!");
        }catch(err){
          // fallback
          const ta = document.createElement('textarea');
          ta.value = text.trim();
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
          flash(btn, "Copied!");
        }
      });
    });

    // ---------- Math helpers ----------
    const DEG = Math.PI/180;
    function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

    // Complex number utilities
    function C(re, im){ return {re, im}; }
    function cAdd(a,b){ return C(a.re+b.re, a.im+b.im); }
    function cSub(a,b){ return C(a.re-b.re, a.im-b.im); }
    function cMul(a,b){ return C(a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re); }
    function cConj(a){ return C(a.re, -a.im); }
    function cAbs2(a){ return a.re*a.re + a.im*a.im; }

    // ---------- Polarization state parameterization ----------
    // Jones from (psi, chi) consistent with normalized Stokes mapping in the article:
    // Ex = cosχ cosψ  - i sinχ sinψ
    // Ey = cosχ sinψ  + i sinχ cosψ
    function jonesFromPsiChi(psi, chi){
      const cchi = Math.cos(chi), schi = Math.sin(chi);
      const cpsi = Math.cos(psi), spsi = Math.sin(psi);
      const Ex = C(cchi*cpsi, -schi*spsi);
      const Ey = C(cchi*spsi,  schi*cpsi);
      // already normalized: |Ex|^2 + |Ey|^2 = cos^2χ + sin^2χ = 1
      return {Ex, Ey};
    }

    // Inner product <E1|E2> = Ex1* Ex2 + Ey1* Ey2
    function innerProduct(j1, j2){
      const term1 = cMul(cConj(j1.Ex), j2.Ex);
      const term2 = cMul(cConj(j1.Ey), j2.Ey);
      return cAdd(term1, term2);
    }

    // Stokes from Jones (normalized if jones is normalized)
    function stokesFromJones(j){
      const Ex = j.Ex, Ey = j.Ey;
      const S0 = cAbs2(Ex) + cAbs2(Ey);
      const S1 = cAbs2(Ex) - cAbs2(Ey);
      const ExEyConj = cMul(Ex, cConj(Ey));
      const S2 = 2*ExEyConj.re;
      const S3 = 2*ExEyConj.im;
      return {S0, S1:S1/S0, S2:S2/S0, S3:S3/S0};
    }

    // ---------- HiDPI canvas setup ----------
    function setupCanvas(canvas, desiredCssHeight){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const cssW = rect.width;
      const cssH = desiredCssHeight || rect.height;
      canvas.style.height = cssH + "px";
      const rect2 = canvas.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect2.width * dpr));
      const h = Math.max(2, Math.floor(rect2.height * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {ctx, wCss: rect2.width, hCss: rect2.height, dpr};
    }

    // ---------- Drawing primitives ----------
    function clear(ctx, w, h){
      ctx.clearRect(0,0,w,h);
      // subtle vignette
      const g = ctx.createRadialGradient(w*0.5,h*0.3, 20, w*0.5,h*0.5, Math.max(w,h)*0.7);
      g.addColorStop(0, "rgba(255,255,255,0.06)");
      g.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);
    }

    function drawAxes(ctx, plot){
      const {x0,y0,w,h, xMin,xMax,yMin,yMax, xLabel,yLabel,title, unitX, unitY} = plot;
      // frame
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 1;
      ctx.strokeRect(x0,y0,w,h);

      // grid
      const n = 5;
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      for(let i=1;i<n;i++){
        const x = x0 + w*i/n;
        const y = y0 + h*i/n;
        ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+h); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+w,y); ctx.stroke();
      }

      // ticks & labels
      ctx.fillStyle = "rgba(230,237,247,0.85)";
      ctx.font = "12px ui-sans-serif, system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      for(let i=0;i<=n;i++){
        const x = x0 + w*i/n;
        const val = xMin + (xMax-xMin)*i/n;
        ctx.beginPath();
        ctx.strokeStyle="rgba(255,255,255,0.14)";
        ctx.moveTo(x,y0+h); ctx.lineTo(x,y0+h+6); ctx.stroke();
        ctx.fillText(val.toFixed(1), x, y0+h+8);
      }
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      for(let i=0;i<=n;i++){
        const y = y0 + h*(1-i/n);
        const val = yMin + (yMax-yMin)*i/n;
        ctx.beginPath();
        ctx.strokeStyle="rgba(255,255,255,0.14)";
        ctx.moveTo(x0-6,y); ctx.lineTo(x0,y); ctx.stroke();
        ctx.fillText(val.toFixed(1), x0-8, y);
      }

      // title
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillStyle = "rgba(230,237,247,0.95)";
      ctx.font = "600 13px ui-sans-serif, system-ui";
      ctx.fillText(title, x0, y0-18);

      // axis labels
      ctx.fillStyle = "rgba(168,179,199,0.95)";
      ctx.font = "12px ui-sans-serif, system-ui";
      ctx.textAlign = "center";
      ctx.fillText(xLabel + (unitX?` (${unitX})`:""), x0+w*0.5, y0+h+30);

      ctx.save();
      ctx.translate(x0-44, y0+h*0.5);
      ctx.rotate(-Math.PI/2);
      ctx.textAlign = "center";
      ctx.fillText(yLabel + (unitY?` (${unitY})`:""), 0, 0);
      ctx.restore();

      ctx.restore();
    }

    function mapXY(plot, x, y){
      const {x0,y0,w,h, xMin,xMax,yMin,yMax} = plot;
      const px = x0 + (x-xMin)/(xMax-xMin)*w;
      const py = y0 + (1-(y-yMin)/(yMax-yMin))*h;
      return {px, py};
    }

    function drawLegend(ctx, items, x, y){
      ctx.save();
      ctx.font = "12px ui-sans-serif, system-ui";
      ctx.textAlign="left"; ctx.textBaseline="middle";
      let yy = y;
      items.forEach(it=>{
        ctx.fillStyle = it.color;
        ctx.fillRect(x, yy-6, 12, 12);
        ctx.fillStyle = "rgba(230,237,247,0.9)";
        ctx.fillText(it.label, x+18, yy);
        yy += 18;
      });
      ctx.restore();
    }

    // ---------- Canvases ----------
    const cDiagram = document.getElementById('cDiagram');
    const cSphere  = document.getElementById('cSphere');
    const cTime    = document.getElementById('cTime');

    // Controls
    const psiEl = document.getElementById('psi');
    const chiEl = document.getElementById('chi');
    const viewEl = document.getElementById('view');
    const psiVal = document.getElementById('psiVal');
    const chiVal = document.getElementById('chiVal');
    const viewVal = document.getElementById('viewVal');
    const innerLine = document.getElementById('innerProdLine');
    const randomBtn = document.getElementById('randomBtn');

    function updateLabels(){
      psiVal.textContent = (+psiEl.value).toFixed(1) + "°";
      chiVal.textContent = (+chiEl.value).toFixed(1) + "°";
      viewVal.textContent = (+viewEl.value).toFixed(0) + "°";
    }

    // ---------- Diagram: ellipses in x-y plane ----------
    function drawDiagram(state){
      const {psi1, chi1, psi2, chi2, j1, j2} = state;
      const {ctx, wCss:w, hCss:h} = setupCanvas(cDiagram, 360);
      clear(ctx, w, h);

      // coordinate transform
      const pad = 48;
      const cx = w*0.5, cy = h*0.55;
      const scale = Math.min(w, h)*0.30;

      // draw axes
      ctx.save();
      ctx.strokeStyle="rgba(255,255,255,0.18)";
      ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(cx-scale*1.2, cy); ctx.lineTo(cx+scale*1.2, cy);
      ctx.moveTo(cx, cy+scale*1.2); ctx.lineTo(cx, cy-scale*1.2);
      ctx.stroke();
      ctx.fillStyle="rgba(168,179,199,0.95)";
      ctx.font="12px ui-sans-serif, system-ui";
      ctx.fillText("x", cx+scale*1.2+6, cy+4);
      ctx.fillText("y", cx+4, cy-scale*1.2-6);
      ctx.restore();

      // ellipse param: Ex(t)=Re(Ex0 e^{it}), Ey(t)=Re(Ey0 e^{it})
      function ellipsePoints(j, N=360){
        const pts=[];
        for(let k=0;k<=N;k++){
          const t = 2*Math.PI*k/N;
          const eIt = C(Math.cos(t), Math.sin(t));
          const Ex = cMul(j.Ex, eIt);
          const Ey = cMul(j.Ey, eIt);
          pts.push({x: Ex.re, y: Ey.re});
        }
        return pts;
      }

      const pts1 = ellipsePoints(j1);
      const pts2 = ellipsePoints(j2);

      // scale based on max excursion among both
      let maxR = 0;
      [pts1,pts2].forEach(arr=>{
        arr.forEach(p=>{
          maxR = Math.max(maxR, Math.abs(p.x), Math.abs(p.y));
        });
      });
      maxR = Math.max(maxR, 1e-6);

      function drawEllipse(pts, color, label){
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        pts.forEach((p,i)=>{
          const x = cx + (p.x/maxR)*scale;
          const y = cy - (p.y/maxR)*scale;
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        });
        ctx.stroke();
        ctx.restore();
      }

      drawEllipse(pts1, "rgba(110,231,255,0.90)", "State 1");
      drawEllipse(pts2, "rgba(167,139,250,0.90)", "State 2");

      // Draw major axis directions using psi and ellipse axes lengths a,b (use |tan χ|=b/a)
      function drawMajorAxis(psi, chi, color){
        const a = 1.0;
        const b = Math.abs(Math.tan(chi))*a;
        // major axis length proportional to max(a,b)
        const major = Math.max(a,b);
        const L = scale*0.95*(major/(Math.max(a,b)+1e-9));
        const dx = Math.cos(psi), dy = Math.sin(psi);
        ctx.save();
        ctx.strokeStyle=color;
        ctx.lineWidth=3;
        ctx.beginPath();
        ctx.moveTo(cx - dx*L, cy + dy*L);
        ctx.lineTo(cx + dx*L, cy - dy*L);
        ctx.stroke();
        ctx.restore();
      }

      drawMajorAxis(psi1, chi1, "rgba(110,231,255,0.55)");
      drawMajorAxis(psi2, chi2, "rgba(167,139,250,0.55)");

      // Rotation sense indicator: use sign of S3 (or chi)
      function rotationArrow(j, color, xOff){
        // arrow around a small circle indicating direction in time
        const r = 22;
        const ox = cx + xOff;
        const oy = cy - scale*1.12;
        const handed = Math.sign(stokesFromJones(j).S3) || 1;
        const dir = handed; // + => CCW (by our convention), - => CW
        ctx.save();
        ctx.strokeStyle="rgba(255,255,255,0.18)";
        ctx.beginPath(); ctx.arc(ox,oy,r,0,Math.PI*2); ctx.stroke();
        ctx.strokeStyle=color;
        ctx.lineWidth=2;
        const a0 = -Math.PI/2;
        const a1 = a0 + dir*1.3;
        ctx.beginPath(); ctx.arc(ox,oy,r,a0,a1, dir<0); ctx.stroke();
        // arrow head
        const hx = ox + r*Math.cos(a1);
        const hy = oy + r*Math.sin(a1);
        ctx.fillStyle=color;
        ctx.beginPath();
        ctx.moveTo(hx,hy);
        ctx.lineTo(hx-6*Math.cos(a1-dir*0.8)+6*Math.sin(a1-dir*0.8), hy-6*Math.sin(a1-dir*0.8)-6*Math.cos(a1-dir*0.8));
        ctx.lineTo(hx-6*Math.cos(a1-dir*0.8)-6*Math.sin(a1-dir*0.8), hy-6*Math.sin(a1-dir*0.8)+6*Math.cos(a1-dir*0.8));
        ctx.closePath(); ctx.fill();
        ctx.restore();
      }
      rotationArrow(j1, "rgba(110,231,255,0.85)", -60);
      rotationArrow(j2, "rgba(167,139,250,0.85)", +60);

      // Labels
      ctx.save();
      ctx.fillStyle="rgba(230,237,247,0.95)";
      ctx.font="600 13px ui-sans-serif, system-ui";
      ctx.fillText("Diagram: polarization ellipses in the transverse (x–y) plane", 14, 12);

      ctx.fillStyle="rgba(168,179,199,0.95)";
      ctx.font="12px ui-sans-serif, system-ui";
      const degPsi1 = (psi1/DEG).toFixed(1), degChi1=(chi1/DEG).toFixed(1);
      const degPsi2 = (psi2/DEG).toFixed(1), degChi2=(chi2/DEG).toFixed(1);
      ctx.fillText(`State 1: ψ₁=${degPsi1}°, χ₁=${degChi1}°`, 14, 32);
      ctx.fillText(`State 2 (orth): ψ₂=${degPsi2}°, χ₂=${degChi2}°`, 14, 50);
      ctx.fillText("Rotation arrows indicate sense in time (example convention).", 14, h-20);
      ctx.restore();

      // Minimal axis ticks (diagram-style)
      ctx.save();
      ctx.strokeStyle="rgba(255,255,255,0.10)";
      for(let i=-2;i<=2;i++){
        const tx = cx + i*scale*0.5;
        ctx.beginPath(); ctx.moveTo(tx, cy-5); ctx.lineTo(tx, cy+5); ctx.stroke();
        const ty = cy + i*scale*0.5;
        ctx.beginPath(); ctx.moveTo(cx-5, ty); ctx.lineTo(cx+5, ty); ctx.stroke();
      }
      ctx.restore();
    }

    // ---------- Main plot: Poincaré sphere (orthographic projection) ----------
    function drawSphere(state){
      const {S1, S2, viewAngle} = state;
      const {ctx, wCss:w, hCss:h} = setupCanvas(cSphere, 360);
      clear(ctx, w, h);

      // plot area
      const plot = {
        x0: 64, y0: 56, w: w-110, h: h-120,
        xMin:-1.2, xMax:1.2, yMin:-1.2, yMax:1.2,
        xLabel:"Projected horizontal", yLabel:"Projected vertical",
        title:"Main plot: Poincaré sphere (orthographic projection)",
        unitX:"unitless", unitY:"unitless"
      };
      drawAxes(ctx, plot);

      // sphere center in plot coords
      const cx = plot.x0 + plot.w*0.5;
      const cy = plot.y0 + plot.h*0.5;
      const R = Math.min(plot.w, plot.h)*0.45;

      // 3D rotation for view
      const yaw = viewAngle;         // rotate around y
      const pitch = 18*DEG;          // slight tilt around x
      function rot(v){
        // v = {x,y,z} with axes: x=S1, y=S2, z=S3
        let {x,y,z} = v;
        // yaw around y
        const cyaw = Math.cos(yaw), syaw = Math.sin(yaw);
        let x1 =  cyaw*x + syaw*z;
        let z1 = -syaw*x + cyaw*z;
        let y1 = y;
        // pitch around x
        const cp = Math.cos(pitch), sp = Math.sin(pitch);
        let y2 = cp*y1 - sp*z1;
        let z2 = sp*y1 + cp*z1;
        return {x:x1, y:y2, z:z2};
      }
      function proj(v){
        const vr = rot(v);
        // orthographic projection: screen x=vr.x, y=vr.y
        return {x: cx + R*vr.x, y: cy - R*vr.y, z: vr.z};
      }

      // Draw sphere outline
      ctx.save();
      ctx.strokeStyle="rgba(255,255,255,0.22)";
      ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.stroke();

      // Draw graticule (lat/long) in faint lines
      ctx.strokeStyle="rgba(255,255,255,0.08)";
      ctx.lineWidth=1;

      function drawCircle3D(type, val){
        // type="lat": z constant in original? but axis z is S3. lat means S3 fixed.
        // type="lon": angle around S3 axis (varying in S1-S2 plane) with full circle.
        const N=240;
        ctx.beginPath();
        let started=false;
        for(let k=0;k<=N;k++){
          const t = 2*Math.PI*k/N;
          let x,y,z;
          if(type==="lat"){
            z = val; // S3
            const r = Math.sqrt(Math.max(0, 1 - z*z));
            x = r*Math.cos(t);
            y = r*Math.sin(t);
          }else{ // lon
            // plane through S3 axis: rotate a great circle by angle val in S1-S2
            // parameterize great circle: for each t, point = (cos t)*u + (sin t)*w
            // pick u in equator at angle val, w = S3 axis
            const u = {x: Math.cos(val), y: Math.sin(val), z:0};
            const wv = {x:0,y:0,z:1};
            x = Math.cos(t)*u.x + Math.sin(t)*wv.x;
            y = Math.cos(t)*u.y + Math.sin(t)*wv.y;
            z = Math.cos(t)*u.z + Math.sin(t)*wv.z;
          }
          const p = proj({x,y,z});
          // draw hidden-line style: only draw if z (after rotation) is toward viewer
          if(p.z > -0.02){
            if(!started){ ctx.moveTo(p.x,p.y); started=true; }
            else ctx.lineTo(p.x,p.y);
          }else{
            if(started){ ctx.stroke(); ctx.beginPath(); started=false; }
          }
        }
        ctx.stroke();
      }
      // latitudes
      [-0.6,-0.2,0.2,0.6].forEach(v=>drawCircle3D("lat", v));
      // longitudes
      [0, Math.PI/4, Math.PI/2, 3*Math.PI/4].forEach(a=>drawCircle3D("lon", a));

      // Draw axes (S1,S2,S3) directions
      function axisLine(v, label, offsetX, offsetY){
        const p0 = proj({x:0,y:0,z:0});
        const p1 = proj(v);
        ctx.strokeStyle="rgba(255,255,255,0.16)";
        ctx.lineWidth=1.3;
        ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke();
        ctx.fillStyle="rgba(168,179,199,0.95)";
        ctx.font="12px ui-sans-serif, system-ui";
        ctx.fillText(label, p1.x + (offsetX||0), p1.y + (offsetY||0));
      }
      axisLine({x:1,y:0,z:0}, "S₁", 6, 0);
      axisLine({x:0,y:1,z:0}, "S₂", 6, 0);
      axisLine({x:0,y:0,z:1}, "S₃", 6, 0);

      // Points for state 1 and state 2
      const p1 = proj(S1);
      const p2 = proj(S2);

      function drawPoint(p, color, label){
        ctx.fillStyle=color;
        ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle="rgba(0,0,0,0.55)";
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.stroke();
        ctx.fillStyle="rgba(230,237,247,0.95)";
        ctx.font="12px ui-sans-serif, system-ui";
        ctx.fillText(label, p.x+10, p.y-10);
      }
      drawPoint(p1, "rgba(110,231,255,0.95)", "State 1");
      drawPoint(p2, "rgba(167,139,250,0.95)", "State 2 (orth)");

      // Antipode line (dashed)
      ctx.setLineDash([6,5]);
      ctx.strokeStyle="rgba(255,255,255,0.14)";
      ctx.lineWidth=1.2;
      ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
      ctx.setLineDash([]);

      // Legend
      drawLegend(ctx, [
        {color:"rgba(110,231,255,0.95)", label:"S(E₁)"},
        {color:"rgba(167,139,250,0.95)", label:"S(E₂) = −S(E₁)"}
      ], plot.x0 + plot.w - 170, plot.y0 + 16);

      // Write numeric Stokes
      ctx.fillStyle="rgba(168,179,199,0.95)";
      ctx.font="12px ui-sans-serif, system-ui";
      ctx.fillText(
        `S(E₁) = (${S1.x.toFixed(3)}, ${S1.y.toFixed(3)}, ${S1.z.toFixed(3)})`,
        plot.x0, plot.y0 + plot.h + 46
      );
      ctx.fillText(
        `S(E₂) = (${S2.x.toFixed(3)}, ${S2.y.toFixed(3)}, ${S2.z.toFixed(3)})`,
        plot.x0, plot.y0 + plot.h + 64
      );

      ctx.restore();
    }

    // ---------- Secondary plot: time traces Ex(t), Ey(t) ----------
    function drawTime(state){
      const {j1, j2} = state;
      const {ctx, wCss:w, hCss:h} = setupCanvas(cTime, 360);
      clear(ctx, w, h);

      const plot = {
        x0: 64, y0: 56, w: w-110, h: h-120,
        xMin:0, xMax:2*Math.PI, yMin:-1.1, yMax:1.1,
        xLabel:"t", yLabel:"Field component", title:"Secondary plot: time-domain components over one period", unitX:"rad", unitY:"normalized"
      };
      drawAxes(ctx, plot);

      function series(j, N=700){
        const xs=[], ex=[], ey=[];
        for(let k=0;k<=N;k++){
          const t = plot.xMin + (plot.xMax-plot.xMin)*k/N;
          const eIt = C(Math.cos(t), Math.sin(t));
          const Ex = cMul(j.Ex, eIt).re;
          const Ey = cMul(j.Ey, eIt).re;
          xs.push(t); ex.push(Ex); ey.push(Ey);
        }
        return {xs, ex, ey};
      }
      const s1 = series(j1);
      const s2 = series(j2);

      function drawLine(xs, ys, color){
        ctx.save();
        ctx.strokeStyle=color;
        ctx.lineWidth=2;
        ctx.beginPath();
        for(let i=0;i<xs.length;i++){
          const p = mapXY(plot, xs[i], ys[i]);
          if(i===0) ctx.moveTo(p.px,p.py); else ctx.lineTo(p.px,p.py);
        }
        ctx.stroke();
        ctx.restore();
      }

      // E1
      drawLine(s1.xs, s1.ex, "rgba(110,231,255,0.90)");          // Ex1
      drawLine(s1.xs, s1.ey, "rgba(110,231,255,0.55)");          // Ey1
      // E2
      drawLine(s2.xs, s2.ex, "rgba(167,139,250,0.90)");          // Ex2
      drawLine(s2.xs, s2.ey, "rgba(167,139,250,0.55)");          // Ey2

      // Legend
      drawLegend(ctx, [
        {color:"rgba(110,231,255,0.90)", label:"Ex₁(t)"},
        {color:"rgba(110,231,255,0.55)", label:"Ey₁(t)"},
        {color:"rgba(167,139,250,0.90)", label:"Ex₂(t)"},
        {color:"rgba(167,139,250,0.55)", label:"Ey₂(t)"}
      ], plot.x0 + plot.w - 170, plot.y0 + 16);

      // annotate rotation sense using S3 sign
      const S3_1 = stokesFromJones(j1).S3;
      const S3_2 = stokesFromJones(j2).S3;
      ctx.fillStyle="rgba(168,179,199,0.95)";
      ctx.font="12px ui-sans-serif, system-ui";
      ctx.fillText(`Handedness indicator (example): S₃₁=${S3_1.toFixed(3)} ; S₃₂=${S3_2.toFixed(3)} (opposite signs)`,
        plot.x0, plot.y0 + plot.h + 54);

      // highlight one time point t=0 for both states
      const t0 = 0;
      function mark(j, color, yVal){
        const p = mapXY(plot, t0, yVal);
        ctx.fillStyle=color;
        ctx.beginPath(); ctx.arc(p.px, p.py, 4.5, 0, Math.PI*2); ctx.fill();
      }
      mark(j1, "rgba(110,231,255,0.95)", j1.Ex.re);
      mark(j1, "rgba(110,231,255,0.65)", j1.Ey.re);
      mark(j2, "rgba(167,139,250,0.95)", j2.Ex.re);
      mark(j2, "rgba(167,139,250,0.65)", j2.Ey.re);

      ctx.restore();
    }

    // ---------- Main update ----------
    function computeState(){
      const psi1 = (+psiEl.value)*DEG;
      const chi1 = (+chiEl.value)*DEG;
      const psi2 = psi1 + 90*DEG;
      const chi2 = -chi1;

      const j1 = jonesFromPsiChi(psi1, chi1);
      const j2 = jonesFromPsiChi(psi2, chi2);

      const ip = innerProduct(j1, j2);
      const st1 = stokesFromJones(j1);
      const st2 = stokesFromJones(j2);

      const S1 = {x:st1.S1, y:st1.S2, z:st1.S3};
      const S2 = {x:st2.S1, y:st2.S2, z:st2.S3};

      const viewAngle = (+viewEl.value)*DEG;

      return {psi1,chi1,psi2,chi2,j1,j2, ip, S1, S2, viewAngle};
    }

    function render(){
      updateLabels();
      const state = computeState();

      innerLine.textContent = `⟨E₁|E₂⟩ = (${state.ip.re.toFixed(4)} + ${state.ip.im.toFixed(4)} i)`;

      drawDiagram(state);
      drawSphere(state);
      drawTime(state);
    }

    // ---------- Interactions ----------
    [psiEl, chiEl, viewEl].forEach(el => el.addEventListener('input', render));
    randomBtn.addEventListener('click', ()=>{
      // random example values that avoid extreme circular edge by a bit
      const psi = (Math.random()*180 - 90).toFixed(1);
      const chi = (Math.random()*70 - 35).toFixed(1);
      psiEl.value = psi;
      chiEl.value = chi;
      render();
    });

    // Resize handling (responsive)
    let resizeTimer = null;
    window.addEventListener('resize', ()=>{
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(render, 90);
    });

    // Initial render
    render();
  </script>
</body>
</html>
