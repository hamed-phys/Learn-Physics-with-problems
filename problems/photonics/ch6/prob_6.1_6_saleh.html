<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jones Matrix of a Polarization Rotator is Invariant to Coordinate Rotation</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#111827;
      --card:#0f172a;
      --muted:#94a3b8;
      --text:#e5e7eb;
      --accent:#60a5fa;
      --accent2:#34d399;
      --warn:#fbbf24;
      --danger:#fb7185;
      --border:rgba(148,163,184,.18);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 800px at 20% 10%, rgba(96,165,250,.18), transparent 60%),
                  radial-gradient(1000px 700px at 80% 20%, rgba(52,211,153,.14), transparent 55%),
                  radial-gradient(900px 700px at 50% 90%, rgba(251,191,36,.10), transparent 60%),
                  var(--bg);
      color:var(--text);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    header{
      padding:28px 18px 14px;
      border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, rgba(17,24,39,.85), rgba(11,15,23,.2));
      position:relative;
      overflow:hidden;
    }
    header .wrap{
      max-width:1120px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 1.3fr .7fr;
      gap:18px;
      align-items:start;
    }
    h1{
      margin:0 0 8px;
      font-size: clamp(1.35rem, 2.5vw, 2.05rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size: .98rem;
      max-width:68ch;
    }
    .badgeRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      justify-content:flex-end;
      align-items:center;
      margin-top:2px;
    }
    .badge{
      font-size:.78rem;
      padding:6px 10px;
      border:1px solid var(--border);
      border-radius:999px;
      background: rgba(15,23,42,.6);
      color:var(--text);
      backdrop-filter: blur(6px);
      box-shadow: 0 6px 18px rgba(0,0,0,.22);
      white-space:nowrap;
    }
    .badge strong{color:var(--accent2); font-weight:700}
    main{
      max-width:1120px;
      margin:0 auto;
      padding:16px 18px 60px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:16px;
      align-items:start;
    }
    nav#toc{
      position:sticky;
      top:12px;
      align-self:start;
      border:1px solid var(--border);
      background: rgba(15,23,42,.72);
      border-radius:16px;
      box-shadow: var(--shadow);
      padding:12px;
      backdrop-filter: blur(8px);
    }
    nav#toc .tocTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    nav#toc .tocTitle h2{
      margin:0;
      font-size:.95rem;
      color:var(--text);
      letter-spacing:.2px;
    }
    .tocHint{
      font-size:.75rem;
      color:var(--muted);
    }
    #toc a{
      display:block;
      padding:8px 10px;
      border-radius:12px;
      color:var(--text);
      border:1px solid transparent;
      font-size:.92rem;
    }
    #toc a:hover{
      background: rgba(96,165,250,.10);
      border-color: rgba(96,165,250,.25);
      text-decoration:none;
    }
    #toc .group{
      margin:10px 0 0;
      padding-top:10px;
      border-top:1px dashed rgba(148,163,184,.22);
    }
    .content{
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    section{
      border:1px solid var(--border);
      background: rgba(17,24,39,.55);
      border-radius:18px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    section .inner{
      padding:16px 16px 18px;
    }
    section h2{
      margin:0 0 10px;
      font-size:1.12rem;
      letter-spacing:.2px;
    }
    section h3{
      margin:16px 0 8px;
      font-size:1.02rem;
      color:#f1f5f9;
    }
    p{margin:0 0 10px; color:#e6edf7}
    ul,ol{margin:8px 0 10px 22px; color:#e6edf7}
    li{margin:4px 0}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .grid3{
      display:grid;
      grid-template-columns: 1.1fr .9fr .9fr;
      gap:12px;
    }
    .callout{
      border:1px solid var(--border);
      background: rgba(15,23,42,.70);
      border-radius:16px;
      padding:12px 12px 12px;
      position:relative;
      overflow:hidden;
    }
    .callout::before{
      content:"";
      position:absolute;
      inset:0;
      background: radial-gradient(700px 250px at 10% 10%, rgba(96,165,250,.12), transparent 60%);
      pointer-events:none;
    }
    .callout .title{
      display:flex;
      align-items:center;
      gap:10px;
      margin:0 0 6px;
      font-weight:700;
      letter-spacing:.2px;
    }
    .dot{
      width:10px; height:10px; border-radius:999px;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(96,165,250,.18);
      flex:0 0 auto;
    }
    .dot.warn{background: var(--warn); box-shadow: 0 0 0 4px rgba(251,191,36,.16)}
    .dot.ok{background: var(--accent2); box-shadow: 0 0 0 4px rgba(52,211,153,.16)}
    .dot.bad{background: var(--danger); box-shadow: 0 0 0 4px rgba(251,113,133,.16)}
    .kq{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    pre{
      margin:10px 0 0;
      background: rgba(2,6,23,.65);
      border:1px solid rgba(148,163,184,.22);
      border-radius:14px;
      padding:12px;
      overflow:auto;
      font-family:var(--mono);
      font-size:.92rem;
      color:#e5e7eb;
    }
    code{font-family:var(--mono)}
    .eqRow{
      display:flex;
      align-items:stretch;
      gap:10px;
      flex-wrap:wrap;
    }
    .copyBtn{
      appearance:none;
      border:1px solid rgba(148,163,184,.26);
      background: rgba(15,23,42,.7);
      color: var(--text);
      border-radius:12px;
      padding:10px 12px;
      cursor:pointer;
      font-size:.9rem;
      display:inline-flex;
      align-items:center;
      gap:8px;
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
      user-select:none;
    }
    .copyBtn:hover{
      transform: translateY(-1px);
      border-color: rgba(96,165,250,.35);
      background: rgba(96,165,250,.08);
    }
    .copyBtn:active{transform: translateY(0px) scale(.99)}
    .pill{
      font-size:.75rem;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.24);
      color:var(--muted);
      margin-left:auto;
      background: rgba(2,6,23,.28);
    }
    .vizWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .vizPanel{
      border:1px solid rgba(148,163,184,.18);
      background: rgba(2,6,23,.35);
      border-radius:16px;
      padding:10px;
      overflow:hidden;
    }
    .vizHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .vizHeader .vtitle{
      font-weight:800;
      letter-spacing:.2px;
      font-size:.95rem;
      color:#f8fafc;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius:14px;
      background: rgba(15,23,42,.45);
      border:1px solid rgba(148,163,184,.16);
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
      margin-top:8px;
    }
    .control{
      border:1px solid rgba(148,163,184,.18);
      background: rgba(15,23,42,.55);
      border-radius:14px;
      padding:10px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:.86rem;
      color:#e6edf7;
      margin-bottom:6px;
    }
    .control small{color:var(--muted); font-size:.78rem}
    input[type="range"]{width:100%}
    select{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(148,163,184,.22);
      background: rgba(2,6,23,.45);
      color:var(--text);
      outline:none;
    }
    .inlineMath{
      font-family:var(--mono);
      font-size:.95em;
      color:#eaf2ff;
      padding:2px 6px;
      border-radius:10px;
      background: rgba(96,165,250,.10);
      border:1px solid rgba(96,165,250,.18);
      white-space:nowrap;
    }
    .muted{color:var(--muted)}
    .hr{
      height:1px;
      background: rgba(148,163,184,.16);
      margin:12px 0;
    }
    footer{
      max-width:1120px;
      margin:0 auto;
      padding:20px 18px 40px;
      color:var(--muted);
      font-size:.9rem;
    }
    .fadeIn{
      animation: pop .45s ease both;
    }
    @keyframes pop{
      from{opacity:0; transform: translateY(6px)}
      to{opacity:1; transform: translateY(0)}
    }
    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
      nav#toc{position:relative; top:0}
      header .wrap{grid-template-columns: 1fr}
      .badgeRow{justify-content:flex-start}
      .controls{grid-template-columns: 1fr}
      .grid2,.grid3{grid-template-columns: 1fr}
    }
    @media print{
      body{background:#fff; color:#000}
      header, nav#toc, .copyBtn, .controls{display:none !important}
      section{box-shadow:none; background:#fff; border-color:#ddd}
      pre{background:#f6f6f6; color:#111; border-color:#ddd}
      canvas{border-color:#ddd; background:#fff}
      a{color:#000; text-decoration:none}
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div>
        <h1>6.1-6 — Rotating a Polarization Rotator: Why Its Jones Matrix Is Invariant Under Coordinate Rotation</h1>
        <p class="subtitle">
          We prove, in the Jones calculus, that an ideal polarization rotator has a matrix that does not change when you rotate the
          <em>coordinate system</em> (i.e., when you change the polarization basis by a rotation). Then we visualize the invariance and contrast it with
          non-invariant elements (e.g., a linear retarder).
        </p>
      </div>
      <div class="badgeRow">
        <div class="badge">Level: <strong>Photonics / Polarization</strong></div>
        <div class="badge">Tooling: <strong>Jones calculus</strong></div>
        <div class="badge">Key idea: <strong>similarity transform</strong></div>
      </div>
    </div>
  </header>

  <main>
    <nav id="toc" aria-label="Table of contents">
      <div class="tocTitle">
        <h2>Mini Table of Contents</h2>
        <div class="tocHint">Sticky • Click to jump</div>
      </div>
      <a href="#quick">Quick Summary</a>
      <a href="#p0">PART 0 — Concept Primer</a>
      <a href="#p1">PART 1 — Problem Analysis</a>
      <a href="#p2">PART 2 — Strategy & Tips</a>
      <a href="#p3">PART 3 — Full Solution</a>
      <a href="#p4">PART 4 — Deeper Understanding</a>
      <a href="#p5">PART 5 — Visualization Guide</a>
      <div class="group">
        <a href="#viz">Interactive Visualizations</a>
        <a href="#final">Final Answer</a>
      </div>
    </nav>

    <div class="content">
      <section id="quick" class="fadeIn">
        <div class="inner">
          <h2>Quick Summary</h2>
          <ul>
            <li><strong>What this problem is about:</strong> Show that an ideal polarization rotator’s Jones matrix is unchanged by rotating the coordinate axes (changing the linear polarization basis).</li>
            <li><strong>Key physics idea:</strong> A passive basis rotation acts as a <span class="inlineMath">similarity transform</span> on the Jones matrix: <span class="inlineMath">J' = R(-φ) J R(φ)</span>.</li>
            <li><strong>Governing tool:</strong> Jones vectors <span class="inlineMath">E</span> (complex field amplitudes) and real rotation matrices <span class="inlineMath">R(α)</span> for linear bases.</li>
            <li><strong>Model of an ideal rotator:</strong> It rotates the polarization components by an angle <span class="inlineMath">θ</span>, so <span class="inlineMath">J_rot(θ) = R(θ)</span>.</li>
            <li><strong>Main result type:</strong> Symbolic proof (no numbers needed).</li>
            <li><strong>Final claim:</strong> For a rotator, <span class="inlineMath">R(-φ) R(θ) R(φ) = R(θ)</span> (rotation matrices commute), hence the matrix is invariant to coordinate rotation.</li>
            <li><strong>Interpretation:</strong> A rotator is isotropic in the transverse plane—there is no “preferred axis” that the basis rotation could reveal.</li>
          </ul>
        </div>
      </section>

      <section id="p0" class="fadeIn">
        <div class="inner">
          <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

          <div class="grid2">
            <div class="callout">
              <div class="title"><span class="dot ok"></span>Core definitions (symbols & units)</div>
              <ul>
                <li><strong>Jones vector</strong> (complex): <span class="inlineMath">E = [E_x, E_y]^T</span>, where <span class="inlineMath">E_x, E_y</span> are complex field amplitudes (units of electric field, e.g., V/m).</li>
                <li><strong>Jones matrix</strong>: a 2×2 complex matrix <span class="inlineMath">J</span> such that <span class="inlineMath">E_out = J E_in</span>.</li>
                <li><strong>Basis (coordinate) rotation</strong> by angle <span class="inlineMath">φ</span>: represented by <span class="inlineMath">R(φ)</span>, the 2D rotation matrix (dimensionless).</li>
                <li><strong>Polarization rotator</strong> by angle <span class="inlineMath">θ</span>: an element that rotates the polarization ellipse (and in particular linear polarization) by <span class="inlineMath">θ</span> about the propagation axis.</li>
              </ul>
            </div>

            <div class="callout">
              <div class="title"><span class="dot"></span>Physical meaning (what these represent)</div>
              <ul>
                <li><span class="inlineMath">E</span> is the transverse electric field phasor: it encodes amplitude and relative phase between x and y components, which determines the polarization state.</li>
                <li><span class="inlineMath">J</span> describes how an optical element transforms polarization in the paraxial approximation (transverse fields only).</li>
                <li><span class="inlineMath">R(φ)</span> does <em>not</em> change the physics—only how you label the transverse axes.</li>
              </ul>
            </div>
          </div>

          <h3>Key laws / principles (and validity conditions)</h3>
          <ul>
            <li><strong>Linearity:</strong> Jones calculus assumes the element is linear for the field amplitudes (superposition holds).</li>
            <li><strong>Fully polarized, monochromatic (or narrowband):</strong> Jones vectors are for coherent polarization states; partial polarization needs Mueller calculus.</li>
            <li><strong>Paraxial propagation:</strong> polarization described by transverse components (no strong longitudinal field components).</li>
          </ul>

          <div class="callout">
            <div class="title"><span class="dot warn"></span>Common models / approximations (why we use them)</div>
            <ul>
              <li><strong>Ideal rotator:</strong> treats the element as rotating the transverse field components like a rigid rotation in the x–y plane.</li>
              <li><strong>Ideal linear retarder:</strong> introduces a phase difference between two orthogonal linear axes (has a preferred axis, so basis rotations matter).</li>
              <li>These idealizations isolate symmetry: “isotropic rotation” vs “anisotropic phase delay.”</li>
            </ul>
          </div>

          <h3>Mini intuition examples (no long algebra)</h3>
          <ul>
            <li><strong>Example A (vector rotation):</strong> If a 2D arrow is rotated by <span class="inlineMath">θ</span>, then relabeling the coordinate axes by <span class="inlineMath">φ</span> doesn’t change the physical rotation—only its component representation changes in a predictable way.</li>
            <li><strong>Example B (preferred axis):</strong> A waveplate “cares” about its fast axis direction. If you rotate your axes, the matrix entries change because you are expressing that axis in a new basis.</li>
          </ul>

          <h3>What to watch for (pitfalls)</h3>
          <ul>
            <li><strong>Active vs passive rotation:</strong> rotating the <em>field</em> vs rotating the <em>coordinate system</em> are opposite-sense operations.</li>
            <li><strong>Order matters:</strong> basis changes produce <span class="inlineMath">J' = R(-φ) J R(φ)</span> (a similarity transform), not <span class="inlineMath">R(φ) J R(-φ)</span>.</li>
            <li><strong>“Invariance” means:</strong> the matrix representation is unchanged for the rotator, not that every optical element is unchanged.</li>
          </ul>
        </div>
      </section>

      <section id="p1" class="fadeIn">
        <div class="inner">
          <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

          <p><strong>Problem (rewritten):</strong> In Jones calculus, an ideal polarization rotator rotates any input polarization state by an angle <span class="inlineMath">θ</span> about the propagation axis. Prove that its Jones matrix representation does not change when we rotate the transverse coordinate system (i.e., choose a new x′–y′ basis rotated by <span class="inlineMath">φ</span>).</p>

          <div class="grid2">
            <div class="callout">
              <div class="title"><span class="dot ok"></span>Given</div>
              <ul>
                <li>An ideal rotator with rotation angle <span class="inlineMath">θ</span>.</li>
                <li>A coordinate (basis) rotation by angle <span class="inlineMath">φ</span>.</li>
                <li>Jones-calculus framework: <span class="inlineMath">E_out = J E_in</span>.</li>
              </ul>
            </div>
            <div class="callout">
              <div class="title"><span class="dot"></span>Unknowns / what to prove</div>
              <ul>
                <li>How <span class="inlineMath">J</span> transforms under a coordinate rotation.</li>
                <li>That for a rotator, <span class="inlineMath">J' = J</span> (invariance).</li>
              </ul>
            </div>
          </div>

          <h3>Relevant principles and why they apply</h3>
          <ul>
            <li><strong>Basis change in linear algebra:</strong> When you express vectors and linear maps in a rotated basis, the matrix representation changes by a similarity transform.</li>
            <li><strong>2D rotations:</strong> For transverse polarization components, basis rotations are represented by <span class="inlineMath">R(φ)</span>.</li>
            <li><strong>Why not Maxwell’s equations here?</strong> The statement is about representation invariance in Jones calculus; we don’t need to re-derive the element from microscopic EM theory.</li>
          </ul>

          <div class="callout">
            <div class="title"><span class="dot warn"></span>Assumptions (explicit)</div>
            <ul>
              <li>Monochromatic, fully polarized light (Jones calculus applies).</li>
              <li>Lossless ideal rotator (no diattenuation), acting only on transverse components.</li>
              <li>Right-handed transverse coordinates with standard 2D rotation conventions.</li>
            </ul>
          </div>

          <h3>Possible approaches (compare 2–3)</h3>
          <ol>
            <li><strong>Linear-algebra basis-change proof (best):</strong> Derive <span class="inlineMath">J' = R(-φ) J R(φ)</span>, then substitute <span class="inlineMath">J = R(θ)</span> and use commutation of rotations. <span class="muted">Pros: shortest, most general, clarifies meaning of “invariance.”</span></li>
            <li><strong>Component-level (direct) proof:</strong> Write the input/output components in both bases and show the same mapping. <span class="muted">Pros: concrete; Cons: more algebra.</span></li>
            <li><strong>Symmetry argument:</strong> A rotator is isotropic in the transverse plane, so its matrix must be invariant under rotations. <span class="muted">Pros: conceptual; Cons: needs the algebra to be rigorous.</span></li>
          </ol>

          <p><strong>Chosen approach:</strong> The linear-algebra basis-change proof, because it is rigorous, compact, and teaches the general transformation rule used throughout polarization optics.</p>
        </div>
      </section>

      <section id="p2" class="fadeIn">
        <div class="inner">
          <h2>PART 2 — Strategy & Tips (Roadmap Only)</h2>

          <ol>
            <li><strong>Goal:</strong> Define the rotation matrix <span class="inlineMath">R(α)</span>. <br><span class="muted">Tool:</span> 2D rotation in the transverse plane. <br><span class="muted">Meaning:</span> Converts components between rotated coordinate axes.</li>
            <li><strong>Goal:</strong> Express how a Jones vector changes under a basis rotation by <span class="inlineMath">φ</span>. <br><span class="muted">Tool:</span> Passive coordinate rotation. <br><span class="muted">Meaning:</span> Same physical field, new coordinates.</li>
            <li><strong>Goal:</strong> Derive the general transformation rule for the Jones matrix: <span class="inlineMath">J' = R(-φ) J R(φ)</span>. <br><span class="muted">Tool:</span> Substitute <span class="inlineMath">E = R(φ)E'</span> into <span class="inlineMath">E_out = J E_in</span>. <br><span class="muted">Meaning:</span> Similarity transform for a change of basis.</li>
            <li><strong>Goal:</strong> Write the rotator’s Jones matrix as <span class="inlineMath">J_rot(θ)=R(θ)</span>. <br><span class="muted">Tool:</span> Definition of a rotator. <br><span class="muted">Meaning:</span> It “rigidly” rotates polarization components.</li>
            <li><strong>Goal:</strong> Substitute into the rule and simplify using rotation-matrix identities. <br><span class="muted">Tool:</span> <span class="inlineMath">R(a)R(b)=R(a+b)</span> and commutation. <br><span class="muted">Meaning:</span> Show invariance.</li>
            <li><strong>Goal:</strong> Sanity checks and interpretation. <br><span class="muted">Tool:</span> Limits (θ→0), physical meaning (no preferred axis). <br><span class="muted">Meaning:</span> Confirm the result is consistent.</li>
          </ol>

          <div class="grid2">
            <div class="callout">
              <div class="title"><span class="dot warn"></span>Common mistakes</div>
              <ul>
                <li>Using <span class="inlineMath">J' = R(φ) J R(-φ)</span> (wrong order for a basis change).</li>
                <li>Confusing “rotate device” with “rotate coordinates.” The problem is the latter.</li>
                <li>Assuming all Jones matrices are invariant—only special ones (like a rotator) are.</li>
              </ul>
            </div>
            <div class="callout">
              <div class="title"><span class="dot ok"></span>Quick tips</div>
              <ul>
                <li>Write <span class="inlineMath">E = R(φ)E'</span> first; the rest follows cleanly.</li>
                <li>Remember: 2D rotations commute; many other Jones matrices do not.</li>
                <li>If stuck, test with a sample vector (e.g., linear x polarization) and track components.</li>
              </ul>
            </div>
          </div>
        </div>
      </section>

      <section id="p3" class="fadeIn">
        <div class="inner">
          <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

          <h3>Physical intuition (before calculating)</h3>
          <p>
            A polarization rotator’s job is to rotate the polarization state by a fixed angle <span class="inlineMath">θ</span> around the propagation axis.
            If you merely rotate your coordinate axes by <span class="inlineMath">φ</span>, you have not changed the physical element or the physical field—only the labels (x,y) you use.
            Since a rotator has <em>no preferred transverse direction</em> (it is “equally rotatory” no matter how you name axes), we expect its matrix to look the same in any rotated linear basis.
          </p>

          <div class="hr"></div>

          <h3>Step 1 — Define the rotation matrix</h3>
          <p>
            Let <span class="inlineMath">R(α)</span> denote the standard 2D rotation matrix (dimensionless) that rotates a vector’s components by angle <span class="inlineMath">α</span> in the x–y plane:
          </p>

          <div class="eqRow">
            <button class="copyBtn" data-copy="R(α) = [[cosα, -sinα],[sinα, cosα]]">
              ⧉ Copy equation
              <span class="pill">plain text</span>
            </button>
          </div>
          <pre><code>R(α) = [ [ cosα, -sinα ],
         [ sinα,  cosα ] ]</code></pre>

          <p class="muted">
            Identity you will use: <span class="inlineMath">R(a)R(b)=R(a+b)</span> (hence rotations commute: <span class="inlineMath">R(a)R(b)=R(b)R(a)</span>).
          </p>

          <h3>Step 2 — How a Jones vector changes under a coordinate rotation</h3>
          <p>
            Let <span class="inlineMath">E</span> be the Jones vector components in the original (x,y) basis and <span class="inlineMath">E'</span> be the components in the rotated (x′,y′) basis,
            where the new axes are obtained by rotating the coordinate system by <span class="inlineMath">φ</span>.
          </p>
          <p>
            For a <strong>passive</strong> rotation (changing basis, not rotating the physical field), the same physical transverse field can be expressed as:
          </p>

          <div class="eqRow">
            <button class="copyBtn" data-copy="E = R(φ) E'   (passive basis rotation by φ)">
              ⧉ Copy equation
              <span class="pill">plain text</span>
            </button>
          </div>
          <pre><code>E = R(φ) E'   (same field, different coordinate axes)</code></pre>

          <p>
            <strong>Why this direction?</strong> If the basis rotates by <span class="inlineMath">φ</span>, the coordinates of a fixed vector transform with the inverse rotation.
            Writing <span class="inlineMath">E = R(φ)E'</span> is a consistent way to encode that inverse relationship (and will produce the correct similarity transform below).
          </p>

          <h3>Step 3 — Derive the general Jones-matrix basis-change rule</h3>
          <p>
            The optical element is a linear map on Jones vectors:
          </p>
          <pre><code>E_out = J E_in</code></pre>
          <p>
            Express both input and output in the rotated basis using <span class="inlineMath">E = R(φ)E'</span>:
          </p>
          <pre><code>E_out      = J E_in
R(φ)E'_out  = J [R(φ)E'_in]</code></pre>
          <p>
            Multiply on the left by <span class="inlineMath">R(-φ)=R(φ)^{-1}</span> to isolate <span class="inlineMath">E'_out</span>:
          </p>
          <div class="eqRow">
            <button class="copyBtn" data-copy="E'_out = [R(-φ) J R(φ)] E'_in   so   J' = R(-φ) J R(φ)">
              ⧉ Copy equation
              <span class="pill">plain text</span>
            </button>
          </div>
          <pre><code>E'_out = R(-φ) J R(φ) E'_in

Therefore the matrix in the rotated basis is:
J' = R(-φ) J R(φ)</code></pre>

          <p>
            <strong>What we did and why:</strong> This is the standard similarity transform for representing the same linear operator in a new basis.
            It’s pure linear algebra applied to polarization components.
          </p>

          <h3>Step 4 — Model the ideal polarization rotator</h3>
          <p>
            By definition, an ideal rotator rotates the polarization state by angle <span class="inlineMath">θ</span> about the propagation axis.
            In a linear polarization basis, that is exactly a 2D rotation of the transverse components:
          </p>
          <div class="eqRow">
            <button class="copyBtn" data-copy="J_rot(θ) = R(θ)">
              ⧉ Copy equation
              <span class="pill">plain text</span>
            </button>
          </div>
          <pre><code>J_rot(θ) = R(θ)</code></pre>

          <h3>Step 5 — Prove invariance under coordinate rotation</h3>
          <p>
            Substitute <span class="inlineMath">J = J_rot(θ)=R(θ)</span> into the general rule:
          </p>
          <pre><code>J' = R(-φ) J R(φ) = R(-φ) R(θ) R(φ)</code></pre>

          <p>
            Use the rotation composition identity <span class="inlineMath">R(a)R(b)=R(a+b)</span>:
          </p>
          <pre><code>R(-φ) R(θ) = R(θ - φ)
Then:
J' = R(θ - φ) R(φ) = R(θ - φ + φ) = R(θ)</code></pre>

          <div class="callout" id="final">
            <div class="title"><span class="dot ok"></span>Final Answer (boxed)</div>
            <p>
              Under a coordinate rotation by <span class="inlineMath">φ</span>, a Jones matrix transforms as
              <span class="inlineMath">J' = R(-φ) J R(φ)</span>.
              For an ideal polarization rotator <span class="inlineMath">J = R(θ)</span>, we obtain
              <span class="inlineMath">J' = R(-φ)R(θ)R(φ)=R(θ)=J</span>.
              <strong>Therefore, the Jones matrix of a polarization rotator is invariant to rotation of the coordinate system.</strong>
            </p>
            <div class="eqRow" style="margin-top:10px">
              <button class="copyBtn" data-copy="Basis rotation rule: J' = R(-φ) J R(φ)\nRotator: J = R(θ)\nTherefore: J' = R(-φ)R(θ)R(φ) = R(θ) = J (invariant).">
                ⧉ Copy final answer
                <span class="pill">plain text</span>
              </button>
            </div>
          </div>

          <h3>Sanity checks</h3>
          <ul>
            <li><strong>Units:</strong> <span class="inlineMath">R</span> is dimensionless; <span class="inlineMath">J</span> is dimensionless, consistent with mapping field amplitudes to field amplitudes.</li>
            <li><strong>Limiting case θ→0:</strong> <span class="inlineMath">R(0)=I</span>. Then <span class="inlineMath">J'=R(-φ)IR(φ)=I</span>, still invariant.</li>
            <li><strong>Physical interpretation:</strong> The rotator has no special transverse axis; rotating the coordinate system cannot change its matrix form.</li>
          </ul>

          <p>
            <strong>Connection to the diagram/plots:</strong> In the diagram you’ll see a vector (polarization direction) rotated by <span class="inlineMath">θ</span>, and separately the axes rotated by <span class="inlineMath">φ</span>.
            The invariance shows up in the plots as a near-zero “difference norm” between <span class="inlineMath">J'</span> and <span class="inlineMath">J</span> for all <span class="inlineMath">φ</span>.
          </p>
        </div>
      </section>

      <section id="p4" class="fadeIn">
        <div class="inner">
          <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

          <h3>Re-interpreting the final formula</h3>
          <ul>
            <li><span class="inlineMath">J' = R(-φ) J R(φ)</span> says: “same device, new coordinates.” This is how any Jones matrix should be re-expressed when you rotate your measurement axes.</li>
            <li>For a rotator <span class="inlineMath">J=R(θ)</span>, the transform becomes <span class="inlineMath">R(-φ)R(θ)R(φ)</span>. Because <span class="inlineMath">R</span> matrices commute, the <span class="inlineMath">φ</span> cancels out.</li>
            <li>So <span class="inlineMath">θ</span> is the only physically meaningful parameter: it controls how much the polarization is rotated, independent of how you label x and y.</li>
          </ul>

          <h3>How changing parameters affects outcomes (connect to plots)</h3>
          <ul>
            <li>Changing <span class="inlineMath">θ</span> changes the rotator matrix entries and rotates the output polarization direction in the diagram.</li>
            <li>Changing <span class="inlineMath">φ</span> (coordinate rotation) does <em>not</em> change <span class="inlineMath">J</span> for a rotator, so the plot of <span class="inlineMath">‖J'−J‖</span> stays at (numerical) zero.</li>
            <li>If you switch the comparison element to a <em>linear retarder</em> in the interactive control, <span class="inlineMath">‖J'−J‖</span> generally becomes nonzero and varies with <span class="inlineMath">φ</span>—because a retarder has a preferred axis.</li>
          </ul>

          <h3>Alternative derivation idea (brief)</h3>
          <p>
            A symmetry-based derivation: invariance under coordinate rotation implies the Jones matrix must commute with all rotation matrices <span class="inlineMath">R(φ)</span>.
            The only 2×2 matrices commuting with all <span class="inlineMath">R(φ)</span> are combinations of the identity and the generator of rotations—leading to the form of a rotator.
            The explicit Jones-calculus proof we did is the clearest for this problem.
          </p>

          <h3>Concept check (self-test)</h3>
          <ul>
            <li><strong>Q:</strong> What does “rotate the coordinate system” mean physically? <strong>A:</strong> You relabel the transverse axes; the field and device stay fixed.</li>
            <li><strong>Q:</strong> Why does a waveplate’s matrix usually change under basis rotation? <strong>A:</strong> It has a preferred fast axis direction, so its matrix depends on how that axis is expressed in your basis.</li>
            <li><strong>Q:</strong> What mathematical property guarantees invariance for the rotator? <strong>A:</strong> Rotation matrices commute and satisfy <span class="inlineMath">R(-φ)R(θ)R(φ)=R(θ)</span>.</li>
            <li><strong>Q:</strong> If <span class="inlineMath">θ=90°</span>, what does the rotator do to horizontal polarization? <strong>A:</strong> It becomes vertical polarization (a quarter-turn in the transverse plane).</li>
          </ul>
        </div>
      </section>

      <section id="p5" class="fadeIn">
        <div class="inner">
          <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

          <ul>
            <li><strong>Diagram canvas:</strong> Shows the original axes (x,y), the rotated axes (x′,y′) by <span class="inlineMath">φ</span>, an example input polarization direction, and the output direction after the rotator angle <span class="inlineMath">θ</span>.</li>
            <li><strong>Main plot:</strong> Graphs <span class="inlineMath">‖J'(φ) − J‖</span> (a matrix-difference magnitude) versus <span class="inlineMath">φ</span> in degrees. For a rotator it stays ~0 for all <span class="inlineMath">φ</span>.</li>
            <li><strong>Secondary plot:</strong> Compares the same quantity for an alternative element (e.g., linear retarder) or shows the commutator magnitude <span class="inlineMath">‖[J, R(φ)]‖</span>. Rotator yields ~0; anisotropic elements yield nonzero.</li>
            <li><strong>Interactive controls:</strong>
              <ul>
                <li><span class="inlineMath">θ</span> slider changes the rotator strength (and updates the diagram and both plots).</li>
                <li><span class="inlineMath">φ</span> slider changes the coordinate rotation displayed in the diagram and updates the highlighted point on the plots.</li>
                <li><strong>Element selector</strong> toggles between “Rotator (invariant)” and “Linear retarder (not invariant)” to see why the theorem is special.</li>
              </ul>
            </li>
          </ul>
        </div>
      </section>

      <section id="viz" class="fadeIn">
        <div class="inner">
          <h2>Interactive Visualizations</h2>

          <div class="vizWrap">
            <div class="vizPanel">
              <div class="vizHeader">
                <div class="vtitle">Diagram — Polarization rotation vs coordinate rotation</div>
                <div class="muted">Angles in degrees (example geometry)</div>
              </div>
              <canvas id="cDiagram" aria-label="Diagram canvas" height="320"></canvas>
            </div>

            <div class="vizPanel">
              <div class="vizHeader">
                <div class="vtitle">Main Plot — Invariance test: ‖J'(φ) − J‖ vs φ</div>
                <div class="muted">Frobenius norm (dimensionless)</div>
              </div>
              <canvas id="cMain" aria-label="Main plot canvas" height="320"></canvas>
            </div>

            <div class="vizPanel">
              <div class="vizHeader">
                <div class="vtitle">Secondary Plot — Commutator magnitude: ‖J R(φ) − R(φ) J‖ vs φ</div>
                <div class="muted">Zero means “commutes” → invariant under basis rotation</div>
              </div>
              <canvas id="cSecondary" aria-label="Secondary plot canvas" height="320"></canvas>
            </div>

            <div class="controls" aria-label="Interactive controls">
              <div class="control">
                <label for="theta">
                  <span>Rotator angle <span class="inlineMath">θ</span> (deg)</span>
                  <span id="thetaVal" class="muted">30°</span>
                </label>
                <input id="theta" type="range" min="-90" max="90" value="30" step="1" />
                <small>Changes the physical polarization rotation performed by the element.</small>
              </div>

              <div class="control">
                <label for="phi">
                  <span>Coordinate rotation <span class="inlineMath">φ</span> (deg)</span>
                  <span id="phiVal" class="muted">20°</span>
                </label>
                <input id="phi" type="range" min="-90" max="90" value="20" step="1" />
                <small>Rotates the x′–y′ axes (passive basis change).</small>
              </div>

              <div class="control">
                <label for="element">
                  <span>Element model</span>
                  <span id="elementVal" class="muted">Rotator</span>
                </label>
                <select id="element">
                  <option value="rotator" selected>Rotator (invariant)</option>
                  <option value="retarder">Linear retarder (generally not invariant)</option>
                </select>
                <small>Compare an isotropic rotator with an anisotropic element.</small>
              </div>
            </div>

            <div class="callout">
              <div class="title"><span class="dot"></span>Example values used for plots</div>
              <ul>
                <li>For the <strong>linear retarder</strong> option, we use an example retardance <span class="inlineMath">δ = 60°</span> with fast axis aligned to the x-axis in the unrotated basis (for demonstration only).</li>
                <li>The <strong>rotator</strong> uses the chosen <span class="inlineMath">θ</span> exactly (this is symbolic in theory; here we pick values to draw curves).</li>
              </ul>
            </div>
          </div>
        </div>
      </section>

    </div>
  </main>

  <footer>
    <div class="hr"></div>
    <p>
      Built for learning: Jones calculus • basis changes • rotational symmetry. Tip: Toggle to “Linear retarder” to see how a preferred axis breaks invariance.
    </p>
  </footer>

  <script>
    // ---------- Utilities ----------
    function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
    function deg2rad(d){ return d * Math.PI / 180; }

    function matMul(A,B){
      return [
        [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],
        [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]
      ];
    }
    function matSub(A,B){
      return [
        [A[0][0]-B[0][0], A[0][1]-B[0][1]],
        [A[1][0]-B[1][0], A[1][1]-B[1][1]]
      ];
    }
    function frobNorm(A){
      // Works for real matrices here
      return Math.sqrt(A[0][0]**2 + A[0][1]**2 + A[1][0]**2 + A[1][1]**2);
    }
    function rotationMatrix(deg){
      const a = deg2rad(deg);
      const c = Math.cos(a), s = Math.sin(a);
      return [[c,-s],[s,c]];
    }
    function retarderMatrix(deltaDeg){
      // Linear retarder with fast axis along x (in unrotated basis): diag(1, e^{iδ})
      // For plotting "difference magnitude" we use real-imag expanded magnitude proxy:
      // We'll embed complex as {re, im} pairs and compute a consistent magnitude.
      const d = deg2rad(deltaDeg);
      return [
        [{re:1, im:0}, {re:0, im:0}],
        [{re:0, im:0}, {re:Math.cos(d), im:Math.sin(d)}]
      ];
    }
    function cMatMul(A,B){
      // complex 2x2 multiply
      function cmul(x,y){ return {re:x.re*y.re - x.im*y.im, im:x.re*y.im + x.im*y.re}; }
      function cadd(x,y){ return {re:x.re+y.re, im:x.im+y.im}; }
      return [
        [
          cadd(cmul(A[0][0],B[0][0]), cmul(A[0][1],B[1][0])),
          cadd(cmul(A[0][0],B[0][1]), cmul(A[0][1],B[1][1]))
        ],
        [
          cadd(cmul(A[1][0],B[0][0]), cmul(A[1][1],B[1][0])),
          cadd(cmul(A[1][0],B[0][1]), cmul(A[1][1],B[1][1]))
        ]
      ];
    }
    function cMatSub(A,B){
      return [
        [{re:A[0][0].re-B[0][0].re, im:A[0][0].im-B[0][0].im},{re:A[0][1].re-B[0][1].re, im:A[0][1].im-B[0][1].im}],
        [{re:A[1][0].re-B[1][0].re, im:A[1][0].im-B[1][0].im},{re:A[1][1].re-B[1][1].re, im:A[1][1].im-B[1][1].im}]
      ];
    }
    function cFrobNorm(A){
      function mag2(z){ return z.re*z.re + z.im*z.im; }
      return Math.sqrt(mag2(A[0][0])+mag2(A[0][1])+mag2(A[1][0])+mag2(A[1][1]));
    }
    function realToComplexMat(R){
      return [
        [{re:R[0][0], im:0},{re:R[0][1], im:0}],
        [{re:R[1][0], im:0},{re:R[1][1], im:0}]
      ];
    }

    // ---------- Canvas helpers ----------
    function setupCanvas(canvas){
      const ctx = canvas.getContext('2d');
      function resize(){
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        const w = Math.max(280, rect.width);
        const h = canvas.getAttribute('height') ? parseInt(canvas.getAttribute('height'),10) : rect.height;
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);
        return {w, h, dpr};
      }
      return {ctx, resize};
    }

    function drawGridAxes(ctx, w, h, plot){
      // plot: {x0,y0, pw, ph, xMin,xMax,yMin,yMax, xLabel,yLabel,title}
      const {x0,y0,pw,ph} = plot;
      ctx.save();
      ctx.clearRect(0,0,w,h);

      // Background card tint
      ctx.fillStyle = 'rgba(15,23,42,0.18)';
      ctx.fillRect(0,0,w,h);

      // Title
      ctx.fillStyle = '#f8fafc';
      ctx.font = '700 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(plot.title, 12, 18);

      // Plot area
      ctx.fillStyle = 'rgba(2,6,23,0.28)';
      ctx.strokeStyle = 'rgba(148,163,184,0.22)';
      roundRect(ctx, x0, y0, pw, ph, 12, true, true);

      // Gridlines
      const nx = 6, ny = 6;
      ctx.save();
      ctx.beginPath();
      ctx.rect(x0, y0, pw, ph);
      ctx.clip();
      ctx.lineWidth = 1;

      for(let i=0;i<=nx;i++){
        const x = x0 + (pw*i/nx);
        ctx.strokeStyle = (i===0 || i===nx) ? 'rgba(148,163,184,0.35)' : 'rgba(148,163,184,0.16)';
        ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+ph); ctx.stroke();
      }
      for(let j=0;j<=ny;j++){
        const y = y0 + (ph*j/ny);
        ctx.strokeStyle = (j===0 || j===ny) ? 'rgba(148,163,184,0.35)' : 'rgba(148,163,184,0.16)';
        ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+pw,y); ctx.stroke();
      }
      ctx.restore();

      // Ticks + labels
      ctx.fillStyle = 'rgba(226,232,240,0.9)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      for(let i=0;i<=nx;i++){
        const xv = plot.xMin + (plot.xMax-plot.xMin)*i/nx;
        const x = x0 + (pw*i/nx);
        ctx.fillText(formatTick(xv), x-10, y0+ph+18);
      }
      for(let j=0;j<=ny;j++){
        const yv = plot.yMax - (plot.yMax-plot.yMin)*j/ny;
        const y = y0 + (ph*j/ny);
        ctx.fillText(formatTick(yv), 10, y+4);
      }

      // Axis labels
      ctx.fillStyle = '#cbd5e1';
      ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(plot.xLabel, x0 + pw - 6 - ctx.measureText(plot.xLabel).width, y0+ph+36);
      // y label (rotated)
      ctx.save();
      ctx.translate(14, y0 + 10);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(plot.yLabel, 0, 0);
      ctx.restore();

      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r, fill, stroke){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
      if(fill) ctx.fill();
      if(stroke) ctx.stroke();
    }

    function formatTick(v){
      // Keep concise
      const av = Math.abs(v);
      if(av >= 100) return Math.round(v).toString();
      if(av >= 10) return (Math.round(v*10)/10).toString();
      return (Math.round(v*100)/100).toString();
    }

    function mapX(x, plot){ return plot.x0 + (x-plot.xMin)/(plot.xMax-plot.xMin)*plot.pw; }
    function mapY(y, plot){ return plot.y0 + (plot.yMax-y)/(plot.yMax-plot.yMin)*plot.ph; }

    // Draw curve
    function drawCurve(ctx, plot, xs, ys, style){
      ctx.save();
      ctx.beginPath();
      ctx.rect(plot.x0, plot.y0, plot.pw, plot.ph);
      ctx.clip();
      ctx.lineWidth = style.lineWidth || 2;
      ctx.strokeStyle = style.stroke || 'rgba(96,165,250,0.95)';
      ctx.beginPath();
      for(let i=0;i<xs.length;i++){
        const X = mapX(xs[i], plot);
        const Y = mapY(ys[i], plot);
        if(i===0) ctx.moveTo(X,Y);
        else ctx.lineTo(X,Y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawLegend(ctx, items, x, y){
      ctx.save();
      ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      let yy = y;
      for(const it of items){
        ctx.fillStyle = it.color;
        ctx.fillRect(x, yy-8, 14, 3);
        ctx.fillStyle = '#e5e7eb';
        ctx.fillText(it.label, x+20, yy);
        yy += 18;
      }
      ctx.restore();
    }

    function drawMarker(ctx, plot, x, y, color){
      ctx.save();
      const X = mapX(x, plot);
      const Y = mapY(y, plot);
      ctx.beginPath();
      ctx.arc(X, Y, 4.5, 0, Math.PI*2);
      ctx.fillStyle = color || 'rgba(52,211,153,0.95)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(2,6,23,0.7)';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }

    // ---------- Physics: build J and J' ----------
    function getJ(params){
      const {thetaDeg, element} = params;
      if(element === 'rotator'){
        return {type:'real', M: rotationMatrix(thetaDeg)};
      } else {
        // retarder example: delta = 60°
        const deltaDeg = 60;
        return {type:'complex', M: retarderMatrix(deltaDeg)};
      }
    }

    function transformJ(J, phiDeg){
      const Rphi = rotationMatrix(phiDeg);
      const Rmphi = rotationMatrix(-phiDeg);
      if(J.type === 'real'){
        const Jp = matMul(matMul(Rmphi, J.M), Rphi);
        return {type:'real', M:Jp};
      } else {
        // complex similarity: R are real but treat as complex
        const RphiC = realToComplexMat(Rphi);
        const RmphiC = realToComplexMat(Rmphi);
        const Jp = cMatMul(cMatMul(RmphiC, J.M), RphiC);
        return {type:'complex', M:Jp};
      }
    }

    function diffNorm(Jp, J){
      if(J.type === 'real'){
        return frobNorm(matSub(Jp.M, J.M));
      } else {
        return cFrobNorm(cMatSub(Jp.M, J.M));
      }
    }

    function commNorm(J, phiDeg){
      const Rphi = rotationMatrix(phiDeg);
      if(J.type === 'real'){
        const JR = matMul(J.M, Rphi);
        const RJ = matMul(Rphi, J.M);
        return frobNorm(matSub(JR, RJ));
      } else {
        const RphiC = realToComplexMat(Rphi);
        const JR = cMatMul(J.M, RphiC);
        const RJ = cMatMul(RphiC, J.M);
        return cFrobNorm(cMatSub(JR, RJ));
      }
    }

    // ---------- Diagram ----------
    function drawDiagram(ctx, w, h, thetaDeg, phiDeg){
      ctx.save();
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = 'rgba(15,23,42,0.18)';
      ctx.fillRect(0,0,w,h);

      const cx = w*0.5, cy = h*0.56;
      const R = Math.min(w,h)*0.33;

      // Title
      ctx.fillStyle = '#f8fafc';
      ctx.font = '700 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('Geometry: field rotation θ and coordinate rotation φ', 12, 18);

      // A faint circle
      ctx.strokeStyle = 'rgba(148,163,184,0.22)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(cx, cy, R, 0, Math.PI*2);
      ctx.stroke();

      // Helper: draw axis
      function axis(angleDeg, color, label){
        const a = deg2rad(angleDeg);
        const x2 = cx + R*Math.cos(a), y2 = cy - R*Math.sin(a);
        const x1 = cx - R*Math.cos(a), y1 = cy + R*Math.sin(a);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
        ctx.stroke();
        // label at positive end
        ctx.fillStyle = color;
        ctx.font = '700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        ctx.fillText(label, x2 + 6, y2 + 4);
      }

      // Original axes (x,y)
      axis(0, 'rgba(96,165,250,0.95)', 'x');
      axis(90, 'rgba(96,165,250,0.95)', 'y');

      // Rotated axes (x',y') by phi
      axis(phiDeg, 'rgba(52,211,153,0.95)', "x′");
      axis(phiDeg+90, 'rgba(52,211,153,0.95)', "y′");

      // Example input polarization: choose an input angle alpha (fixed in lab)
      const alphaDeg = 25;
      const alpha = deg2rad(alphaDeg);

      function arrow(angleRad, color, label){
        const len = R*0.92;
        const x2 = cx + len*Math.cos(angleRad), y2 = cy - len*Math.sin(angleRad);
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(cx,cy); ctx.lineTo(x2,y2);
        ctx.stroke();

        // arrowhead
        const head = 10;
        const t = angleRad;
        const hx1 = x2 - head*Math.cos(t - Math.PI/7);
        const hy1 = y2 + head*Math.sin(t - Math.PI/7);
        const hx2 = x2 - head*Math.cos(t + Math.PI/7);
        const hy2 = y2 + head*Math.sin(t + Math.PI/7);
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x2,y2); ctx.lineTo(hx1,hy1); ctx.lineTo(hx2,hy2); ctx.closePath();
        ctx.fill();

        ctx.fillStyle = color;
        ctx.font = '700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        ctx.fillText(label, x2 + 8, y2 - 8);
      }

      // Input and output polarization directions
      arrow(alpha, 'rgba(251,191,36,0.95)', 'E_in');
      arrow(alpha + deg2rad(thetaDeg), 'rgba(251,113,133,0.95)', 'E_out');

      // Draw arcs for θ and φ
      function arcMark(startDeg, endDeg, radius, color, text){
        const s = deg2rad(startDeg), e = deg2rad(endDeg);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy, radius, -s, -e, startDeg<endDeg ? false : true);
        ctx.stroke();
        // label near middle
        const mid = deg2rad((startDeg+endDeg)/2);
        const tx = cx + (radius+14)*Math.cos(mid);
        const ty = cy - (radius+14)*Math.sin(mid);
        ctx.fillStyle = color;
        ctx.font = '700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        ctx.fillText(text, tx, ty);
      }

      arcMark(alphaDeg, alphaDeg + thetaDeg, R*0.55, 'rgba(251,113,133,0.92)', `θ=${thetaDeg}°`);
      arcMark(0, phiDeg, R*0.72, 'rgba(52,211,153,0.92)', `φ=${phiDeg}°`);

      // Legend
      drawLegend(ctx, [
        {color:'rgba(96,165,250,0.95)', label:'Original axes (x,y)'},
        {color:'rgba(52,211,153,0.95)', label:"Rotated axes (x′,y′)"},
        {color:'rgba(251,191,36,0.95)', label:'Input polarization'},
        {color:'rgba(251,113,133,0.95)', label:'Output after rotator'}
      ], 14, h-66);

      ctx.restore();
    }

    // ---------- Plots ----------
    function buildCurves(params){
      const {thetaDeg, element} = params;
      const J = getJ({thetaDeg, element});
      const xs = [];
      const yMain = [];
      const yComm = [];
      for(let phi=-90; phi<=90; phi+=1){
        const Jp = transformJ(J, phi);
        xs.push(phi);
        yMain.push(diffNorm(Jp, J));
        yComm.push(commNorm(J, phi));
      }
      return {xs, yMain, yComm, J};
    }

    function autoYMax(arr){
      let m = 0;
      for(const v of arr) m = Math.max(m, v);
      if(m < 1e-12) m = 1e-12;
      // add headroom
      return m * 1.12;
    }

    // ---------- Copy buttons ----------
    async function copyText(txt){
      try{
        await navigator.clipboard.writeText(txt);
        return true;
      }catch(e){
        // fallback
        const ta = document.createElement('textarea');
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        try{ document.execCommand('copy'); document.body.removeChild(ta); return true; }
        catch(err){ document.body.removeChild(ta); return false; }
      }
    }
    function wireCopyButtons(){
      document.querySelectorAll('.copyBtn[data-copy]').forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          const txt = btn.getAttribute('data-copy') || '';
          const ok = await copyText(txt);
          const prev = btn.innerHTML;
          btn.innerHTML = ok ? '✓ Copied <span class="pill">plain text</span>' : '⚠ Copy failed <span class="pill">try manually</span>';
          setTimeout(()=>{ btn.innerHTML = prev; }, 950);
        });
      });
    }

    // ---------- Main render loop ----------
    const diag = setupCanvas(document.getElementById('cDiagram'));
    const mainP = setupCanvas(document.getElementById('cMain'));
    const secP  = setupCanvas(document.getElementById('cSecondary'));

    const thetaEl = document.getElementById('theta');
    const phiEl = document.getElementById('phi');
    const elementEl = document.getElementById('element');
    const thetaVal = document.getElementById('thetaVal');
    const phiVal = document.getElementById('phiVal');
    const elementVal = document.getElementById('elementVal');

    function render(){
      const thetaDeg = parseFloat(thetaEl.value);
      const phiDeg = parseFloat(phiEl.value);
      const element = elementEl.value;

      thetaVal.textContent = `${thetaDeg}°`;
      phiVal.textContent = `${phiDeg}°`;
      elementVal.textContent = element === 'rotator' ? 'Rotator' : 'Linear retarder';

      // Resize canvases
      const rD = diag.resize();
      const rM = mainP.resize();
      const rS = secP.resize();

      // Diagram
      drawDiagram(diag.ctx, rD.w, rD.h, thetaDeg, phiDeg);

      // Curves
      const curves = buildCurves({thetaDeg, element});
      const yMaxMain = autoYMax(curves.yMain);
      const yMaxComm = autoYMax(curves.yComm);

      // Plot layouts
      const plotMain = {
        title: "‖J'(φ) − J‖ (invariance test)",
        x0: 56, y0: 34,
        pw: rM.w - 76, ph: rM.h - 84,
        xMin: -90, xMax: 90,
        yMin: 0, yMax: yMaxMain,
        xLabel: "φ (deg)",
        yLabel: "norm (dimensionless)"
      };
      const plotSec = {
        title: "‖J R(φ) − R(φ) J‖ (commutator magnitude)",
        x0: 56, y0: 34,
        pw: rS.w - 76, ph: rS.h - 84,
        xMin: -90, xMax: 90,
        yMin: 0, yMax: yMaxComm,
        xLabel: "φ (deg)",
        yLabel: "norm (dimensionless)"
      };

      // Draw grids
      drawGridAxes(mainP.ctx, rM.w, rM.h, plotMain);
      drawGridAxes(secP.ctx,  rS.w, rS.h, plotSec);

      // Draw curves
      const colorCurve = (element === 'rotator') ? 'rgba(96,165,250,0.95)' : 'rgba(251,191,36,0.95)';
      const colorComm  = (element === 'rotator') ? 'rgba(52,211,153,0.95)' : 'rgba(251,113,133,0.95)';

      drawCurve(mainP.ctx, plotMain, curves.xs, curves.yMain, {stroke: colorCurve, lineWidth: 2.5});
      drawCurve(secP.ctx,  plotSec,  curves.xs, curves.yComm, {stroke: colorComm,  lineWidth: 2.5});

      // Legend
      drawLegend(mainP.ctx, [{color: colorCurve, label: element === 'rotator' ? 'Rotator: should be ~0' : 'Retarder: varies with φ'}], 70, 28);
      drawLegend(secP.ctx,  [{color: colorComm,  label: element === 'rotator' ? 'Rotator commutes with R(φ)' : 'Retarder does not commute'}], 70, 28);

      // Highlight current φ point
      const idx = Math.round(phiDeg + 90); // since xs step 1 from -90
      const yM = curves.yMain[clamp(idx,0,curves.yMain.length-1)];
      const yC = curves.yComm[clamp(idx,0,curves.yComm.length-1)];

      drawMarker(mainP.ctx, plotMain, phiDeg, yM, 'rgba(52,211,153,0.95)');
      drawMarker(secP.ctx,  plotSec,  phiDeg, yC, 'rgba(52,211,153,0.95)');

      // Annotate numeric readout
      mainP.ctx.save();
      mainP.ctx.fillStyle = 'rgba(226,232,240,0.92)';
      mainP.ctx.font = '600 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      const t1 = `at φ=${phiDeg}°: ‖J'−J‖=${(yM<1e-9?0:yM).toExponential(2)}`;
      mainP.ctx.fillText(t1, 58, rM.h - 16);
      mainP.ctx.restore();

      secP.ctx.save();
      secP.ctx.fillStyle = 'rgba(226,232,240,0.92)';
      secP.ctx.font = '600 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      const t2 = `at φ=${phiDeg}°: ‖JR−RJ‖=${(yC<1e-9?0:yC).toExponential(2)}`;
      secP.ctx.fillText(t2, 58, rS.h - 16);
      secP.ctx.restore();
    }

    function bind(){
      const onChange = ()=>render();
      thetaEl.addEventListener('input', onChange);
      phiEl.addEventListener('input', onChange);
      elementEl.addEventListener('change', onChange);
      window.addEventListener('resize', ()=>render());
    }

    wireCopyButtons();
    bind();
    render();
  </script>
</body>
</html>
