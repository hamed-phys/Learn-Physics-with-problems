<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>6.3-4 — Lateral Shift in Double Refraction (Positive Uniaxial Crystal)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#101a33;
      --card2:#0f1730;
      --text:#e9eefc;
      --muted:#b9c4e6;
      --faint:#7f8ab3;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 12px 40px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background: radial-gradient(1200px 800px at 20% 10%, rgba(125,211,252,.18), transparent 55%),
                  radial-gradient(900px 700px at 90% 30%, rgba(167,139,250,.15), transparent 55%),
                  linear-gradient(180deg, #070a14, var(--bg));
      line-height:1.55;
    }
    header{
      padding:34px 18px 18px;
      max-width:1180px;
      margin:0 auto;
    }
    .title{
      display:grid;
      gap:10px;
    }
    h1{
      margin:0;
      font-size: clamp(1.65rem, 2.8vw, 2.55rem);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      max-width:88ch;
    }
    .metaRow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:10px;
      color:var(--faint);
      font-size:.95rem;
    }
    .pill{
      border:1px solid var(--line);
      padding:6px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.04);
      backdrop-filter: blur(6px);
    }

    main{
      max-width:1180px;
      margin:0 auto;
      padding: 14px 18px 70px;
      display:grid;
      grid-template-columns: 1fr;
      gap:18px;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid2{grid-template-columns:1fr}
    }

    section, article{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    section > .inner, article > .inner{
      padding:18px 18px 16px;
    }
    h2{
      margin:0 0 8px;
      font-size:1.35rem;
      letter-spacing:.2px;
    }
    h3{
      margin:16px 0 6px;
      font-size:1.05rem;
      color:var(--text);
      letter-spacing:.2px;
    }
    p{margin:8px 0; color:var(--muted)}
    ul{margin:10px 0 10px 20px; color:var(--muted)}
    li{margin:6px 0}

    .callouts{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:12px;
      margin-top:10px;
    }
    .callout{
      grid-column: span 12;
      padding:12px 12px;
      border-radius:16px;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(16,26,51,.7), rgba(16,26,51,.35));
      position:relative;
      overflow:hidden;
    }
    .callout::before{
      content:"";
      position:absolute;
      inset:-2px -2px auto -2px;
      height:4px;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      opacity:.85;
    }
    .callout.good::before{background: linear-gradient(90deg, var(--good), var(--accent));}
    .callout.warn::before{background: linear-gradient(90deg, var(--warn), var(--accent2));}
    .callout.bad::before{background: linear-gradient(90deg, var(--bad), var(--warn));}
    .callout h4{
      margin:0 0 6px;
      font-size:.98rem;
      letter-spacing:.2px;
      color:var(--text);
    }
    .callout p, .callout ul{color:var(--muted); margin:6px 0}
    .callout code{color:#dbeafe}

    .tocWrap{
      position:sticky;
      top:12px;
      align-self:start;
      background: linear-gradient(180deg, rgba(15,23,48,.85), rgba(15,23,48,.55));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .tocHeader{
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom:1px solid var(--line);
    }
    .tocHeader strong{letter-spacing:.25px}
    .toc{
      padding:10px 8px 12px;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .toc a{
      color:var(--muted);
      text-decoration:none;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .toc a:hover{
      background: rgba(255,255,255,.05);
      border-color: rgba(255,255,255,.10);
      transform: translateY(-1px);
      color:var(--text);
    }

    .equation{
      margin:10px 0;
      padding:12px 12px;
      border-radius:16px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      position:relative;
    }
    pre.eq{
      margin:0;
      white-space:pre-wrap;
      word-break:break-word;
      font-family:var(--mono);
      font-size:.95rem;
      color:#eaf2ff;
    }
    .copyBtn{
      position:absolute;
      top:10px;
      right:10px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color:var(--text);
      border-radius:12px;
      padding:8px 10px;
      font-size:.86rem;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease;
    }
    .copyBtn:hover{transform: translateY(-1px); background: rgba(255,255,255,.10)}
    .copyNote{
      margin-top:8px;
      font-size:.9rem;
      color:var(--faint);
    }

    .vizCard{
      padding:0;
    }
    .vizTop{
      padding:14px 16px;
      border-bottom:1px solid var(--line);
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:flex-end;
      justify-content:space-between;
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px 14px;
      width:min(720px, 100%);
    }
    @media (max-width: 780px){
      .controls{grid-template-columns:1fr}
    }
    .control{
      display:grid;
      gap:6px;
    }
    .control label{
      font-size:.92rem;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      gap:10px;
    }
    .control input[type="range"]{width:100%}
    .control .val{
      font-family:var(--mono);
      color:#eaf2ff;
      font-size:.92rem;
    }
    .btnRow{
      display:flex; gap:10px; align-items:center; justify-content:flex-end;
      flex-wrap:wrap;
    }
    .btn{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.07);
      color:var(--text);
      border-radius:14px;
      padding:10px 12px;
      font-size:.9rem;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease;
    }
    .btn:hover{transform: translateY(-1px); background: rgba(255,255,255,.11)}
    .vizBody{
      padding:14px 16px 16px;
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
    }
    .canvasWrap{
      border:1px solid var(--line);
      border-radius:16px;
      overflow:hidden;
      background: rgba(0,0,0,.22);
    }
    canvas{display:block; width:100%; height:340px}
    .small canvas{height:300px}
    .trip canvas{height:320px}

    .kpiRow{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:10px;
      margin-top:6px;
    }
    @media (max-width: 980px){
      .kpiRow{grid-template-columns: repeat(2, 1fr)}
    }
    .kpi{
      border:1px solid var(--line);
      border-radius:16px;
      padding:10px 12px;
      background: rgba(255,255,255,.04);
    }
    .kpi .k{
      font-size:.84rem;
      color:var(--faint);
      margin:0;
    }
    .kpi .v{
      margin:2px 0 0;
      font-family:var(--mono);
      font-size:1.02rem;
      color:#eef6ff;
    }

    .hr{
      height:1px;
      background: var(--line);
      margin:14px 0;
    }

    footer{
      max-width:1180px;
      margin:0 auto;
      padding: 18px 18px 40px;
      color:var(--faint);
      font-size:.95rem;
    }

    /* subtle animation */
    @media (prefers-reduced-motion: no-preference){
      section, article{animation: pop .35s ease both}
      @keyframes pop{from{transform:translateY(4px); opacity:.0} to{transform:translateY(0); opacity:1}}
    }

    /* print friendly */
    @media print{
      body{background:#fff; color:#000}
      section, article{box-shadow:none; border-color:#ccc}
      .tocWrap{display:none}
      .copyBtn, .btnRow, .controls{display:none !important}
      canvas{display:none}
      .canvasWrap{display:none}
      p, li{color:#000}
      .equation{background:#f5f5f5}
    }
  </style>
</head>
<body>
<header>
  <div class="title">
    <h1>6.3-4 — Lateral Shift in Double Refraction (Positive Uniaxial Crystal)</h1>
    <p class="subtitle">
      We want the <em>largest lateral separation</em> between the ordinary (o) and extraordinary (e) beams after they traverse a uniaxial crystal slab.
      The key is to combine (i) <strong>birefringent refraction</strong> (different phase indices) with (ii) <strong>walk-off</strong> (extraordinary energy ray not parallel to its wave normal).
    </p>
    <div class="metaRow">
      <span class="pill">Topic: crystal optics · uniaxial birefringence</span>
      <span class="pill">Crystal type: positive uniaxial (n<sub>e</sub> &gt; n<sub>o</sub>)</span>
      <span class="pill">Goal: maximize lateral shift Δ at exit face</span>
    </div>
  </div>
</header>

<main>
  <div class="grid2">
    <section class="tocWrap" aria-label="Table of contents">
      <div class="tocHeader">
        <strong>Mini TOC</strong>
        <span class="pill" style="font-size:.82rem">sticky</span>
      </div>
      <nav class="toc">
        <a href="#quick" data-jump>Quick Summary</a>
        <a href="#part0" data-jump>PART 0 — Concept Primer</a>
        <a href="#part1" data-jump>PART 1 — Problem Analysis</a>
        <a href="#part2" data-jump>PART 2 — Strategy & Tips</a>
        <a href="#part3" data-jump>PART 3 — Full Solution</a>
        <a href="#part4" data-jump>PART 4 — Deeper Understanding</a>
        <a href="#part5" data-jump>PART 5 — Visualization Guide</a>
      </nav>
    </section>

    <article class="vizCard" aria-label="Interactive visualizations">
      <div class="vizTop">
        <div>
          <h2 style="margin:0">Interactive Geometry + Plots</h2>
          <p style="margin:4px 0 0; color:var(--faint)">
            Adjust geometry and indices → diagram + both plots update live (high-DPI + responsive).
          </p>
        </div>

        <div class="btnRow">
          <button class="btn" id="btnOptimize">Set ψ = ψ<sub>opt</sub> (max walk-off)</button>
          <button class="btn" id="btnGrazing">Push incidence toward grazing</button>
        </div>

        <div class="controls" role="group" aria-label="controls">
          <div class="control">
            <label>
              <span>Thickness <span style="color:var(--faint)">(example for plots)</span> d [mm]</span>
              <span class="val" id="valD">5.00</span>
            </label>
            <input id="slD" type="range" min="0.5" max="20" step="0.1" value="5">
          </div>

          <div class="control">
            <label>
              <span>Incidence angle θ<sub>i</sub> [deg] (air → crystal)</span>
              <span class="val" id="valTi">40.0</span>
            </label>
            <input id="slTi" type="range" min="0" max="85" step="0.1" value="40">
          </div>

          <div class="control">
            <label>
              <span>Optic-axis tilt β [deg] (inside slab, from surface normal)</span>
              <span class="val" id="valBeta">35.0</span>
            </label>
            <input id="slBeta" type="range" min="0" max="90" step="0.1" value="35">
          </div>

          <div class="control">
            <label>
              <span>Extraordinary index n<sub>e</sub> (positive uniaxial: n<sub>e</sub> &gt; n<sub>o</sub>)</span>
              <span class="val" id="valNe">1.600</span>
            </label>
            <input id="slNe" type="range" min="1.55" max="1.85" step="0.001" value="1.600">
          </div>

          <div class="control" style="grid-column:1 / -1">
            <label>
              <span>Ordinary index n<sub>o</sub></span>
              <span class="val" id="valNo">1.540</span>
            </label>
            <input id="slNo" type="range" min="1.40" max="1.75" step="0.001" value="1.540">
          </div>
        </div>
      </div>

      <div class="vizBody">
        <div class="kpiRow" aria-label="computed readouts">
          <div class="kpi">
            <p class="k">Angle to optic axis</p>
            <p class="v">ψ = <span id="kPsi">—</span> deg</p>
          </div>
          <div class="kpi">
            <p class="k">Walk-off (extraordinary)</p>
            <p class="v">ρ = <span id="kRho">—</span> deg</p>
          </div>
          <div class="kpi">
            <p class="k">Separation at exit</p>
            <p class="v">Δ = <span id="kDelta">—</span> mm</p>
          </div>
          <div class="kpi">
            <p class="k">“Best” ψ for max |ρ|</p>
            <p class="v">ψ<sub>opt</sub> = <span id="kPsiOpt">—</span> deg</p>
          </div>
        </div>

        <div class="canvasWrap trip" aria-label="diagram canvas">
          <canvas id="cvDiagram"></canvas>
        </div>

        <div class="canvasWrap" aria-label="main plot canvas">
          <canvas id="cvMain"></canvas>
        </div>

        <div class="canvasWrap small" aria-label="secondary plot canvas">
          <canvas id="cvSecondary"></canvas>
        </div>

        <p class="copyNote">
          Plots use “example values” for d, n<sub>o</sub>, n<sub>e</sub> to visualize the geometry. The final optimization results below remain symbolic.
        </p>
      </div>
    </article>
  </div>

  <section id="quick">
    <div class="inner">
      <h2>Quick Summary</h2>
      <ul>
        <li><strong>What this is about:</strong> In a uniaxial crystal, an incident beam splits into an <em>ordinary</em> and <em>extraordinary</em> beam that emerge laterally separated.</li>
        <li><strong>Key physics idea:</strong> The extraordinary beam exhibits <strong>walk-off</strong>: its energy flow (Poynting vector <code>S</code>) is not parallel to its wave normal <code>k</code>.</li>
        <li><strong>Governing relations:</strong> tangential phase matching (<em>Snell for wave normals</em>), angle-dependent extraordinary index
          <code>1/n_e(ψ)^2 = cos^2ψ/n_e^2 + sin^2ψ/n_o^2</code>, and walk-off
          <code>tanρ = (n_o^2 - n_e^2) sinψ cosψ / (n_e^2 cos^2ψ + n_o^2 sin^2ψ)</code>.</li>
        <li><strong>Lateral shift:</strong> For slab thickness <code>d</code>, a practical estimate is
          <code>Δ ≈ d [tanθ_o − tan(θ_e + ρ)]</code>
          (angles measured inside the slab relative to surface normal).</li>
        <li><strong>Optimization result (most important):</strong> The extraordinary walk-off magnitude is maximized when the wave normal makes
          <strong>ψ<sub>opt</sub> such that</strong> <code>tanψ_opt = n_e/n_o</code> (positive uniaxial: <code>n_e &gt; n_o</code>).</li>
        <li><strong>Optimum geometry statement:</strong> Put the optic axis in the <em>plane of incidence</em> (principal section), and choose incidence/axis tilt so that the extraordinary wave normal satisfies <code>ψ = ψ_opt</code>. Then push internal angles as large as practical (near-grazing propagation) to amplify Δ via the tangent factors.</li>
        <li><strong>Final result type:</strong> Mainly <strong>symbolic</strong> (best angles/directions), with plotted <strong>example numerics</strong> for intuition.</li>
      </ul>
    </div>
  </section>

  <section id="part0">
    <div class="inner">
      <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

      <h3>Core definitions (symbols + units)</h3>
      <ul>
        <li><strong>Ordinary index</strong> <code>n_o</code> (dimensionless): refractive index for the ordinary wave (polarization ⟂ principal section), independent of direction.</li>
        <li><strong>Extraordinary principal index</strong> <code>n_e</code> (dimensionless): refractive index along the optic axis for the extraordinary wave (in a uniaxial crystal).</li>
        <li><strong>Positive uniaxial</strong>: <code>n_e &gt; n_o</code>.</li>
        <li><strong>Optic axis direction</strong> (unit vector) <code>â</code>; define <code>β</code> = angle between <code>â</code> and surface normal inside the slab.</li>
        <li><strong>Wave normal</strong> <code>k</code>: direction of constant phase propagation; its angle to the normal inside the crystal is <code>θ</code>.</li>
        <li><strong>Energy (ray) direction</strong> ~ Poynting vector <code>S</code>; for the ordinary wave <code>S || k</code>, for the extraordinary wave <code>S</code> is rotated by <code>ρ</code> (the walk-off angle).</li>
        <li><strong>ψ</strong> (radians or degrees): angle between extraordinary wave normal <code>k_e</code> and optic axis <code>â</code>.</li>
        <li><strong>d</strong> (m or mm): slab thickness. Lateral shift Δ has units of length.</li>
      </ul>

      <h3>Physical meaning (what these represent)</h3>
      <ul>
        <li><code>n_o</code> and <code>n_e(ψ)</code> control <em>phase</em> refraction (how the wavefront tilts).</li>
        <li><code>ρ</code> controls <em>energy drift</em> of the extraordinary beam relative to its phase direction: the beam “slides sideways” as it propagates.</li>
        <li>Δ is the transverse separation between beam centroids at the exit face: it is what you see on a screen just beyond the crystal.</li>
      </ul>

      <div class="callouts">
        <div class="callout">
          <h4>Key law: phase matching at the interface</h4>
          <p>
            At a planar boundary, the component of the wavevector parallel to the surface is conserved.
            That is why Snell’s law is properly applied to the <strong>wave normal</strong> directions (not directly to energy rays for the extraordinary wave).
          </p>
        </div>
        <div class="callout warn">
          <h4>When the theory is valid</h4>
          <ul>
            <li>Lossless, homogeneous, linear crystal (no absorption, no spatial dispersion).</li>
            <li>Geometrical optics regime (beam width ≫ wavelength), so rays/wave normals are meaningful.</li>
            <li>Single refraction event at each surface; neglect multiple internal reflections.</li>
          </ul>
        </div>
      </div>

      <h3>Models/approximations used</h3>
      <ul>
        <li><strong>Uniaxial index surface (phase):</strong> extraordinary phase index depends on direction via the well-known uniaxial relation.</li>
        <li><strong>Ray (group) direction:</strong> for the extraordinary wave, energy follows the normal to the index ellipsoid, producing walk-off <code>ρ</code>.</li>
        <li><strong>Beam separation estimate:</strong> treat o- and e-beams as straight lines inside the slab with fixed angles; then Δ is just geometry.</li>
      </ul>

      <h3>Mini intuition examples (quick)</h3>
      <ul>
        <li><strong>If optic axis is parallel to the wave normal</strong> (<code>ψ = 0</code>): the medium looks locally isotropic to the extraordinary wave; walk-off goes to zero and separation decreases.</li>
        <li><strong>If optic axis is perpendicular to the wave normal</strong> (<code>ψ = 90°</code>): symmetry again reduces walk-off; the strongest walk-off occurs between these extremes.</li>
      </ul>

      <div class="callouts">
        <div class="callout bad">
          <h4>What to watch for (typical pitfalls)</h4>
          <ul>
            <li><strong>Confusing</strong> extraordinary wave normal (phase direction) with extraordinary ray direction (energy direction).</li>
            <li>Applying ordinary Snell’s law to the extraordinary <em>ray</em> instead of to its <em>wave normal</em>.</li>
            <li>Ignoring that the “best” geometry depends on both <em>walk-off</em> and <em>internal propagation angle</em> (tangent amplification).</li>
          </ul>
        </div>
      </div>
    </div>
  </section>

  <section id="part1">
    <div class="inner">
      <h2>PART 1 — Problem Analysis (no solving yet)</h2>

      <h3>Problem restatement (in plain words)</h3>
      <p>
        A light beam enters a <strong>positive uniaxial crystal</strong> slab and splits into ordinary and extraordinary components.
        We want the <strong>optimum geometry</strong> (orientation of the optic axis and incidence direction) that gives the <strong>maximum lateral separation</strong>
        between the refracted o- and e-beams after traversing thickness <code>d</code>.
        We must specify the relevant angles and directions.
      </p>

      <h3>Given</h3>
      <ul>
        <li>Positive uniaxial crystal: <code>n_e &gt; n_o</code></li>
        <li>Plane slab of thickness <code>d</code></li>
        <li>Incident beam direction (to be chosen) and optic-axis orientation (to be chosen)</li>
      </ul>

      <h3>Unknowns / what must be found</h3>
      <ul>
        <li>Optimum relative orientation between the extraordinary wave normal and optic axis (i.e., optimum <code>ψ</code>).</li>
        <li>Optimum “principal section” geometry (which plane should contain which vectors).</li>
        <li>How to choose incidence to enhance Δ (qualitatively and with formulas).</li>
      </ul>

      <h3>Relevant physical principles (and why)</h3>
      <ul>
        <li><strong>Boundary phase matching:</strong> tangential <code>k</code> conservation determines <code>θ_o</code> and <code>θ_e</code> (why: Maxwell boundary conditions).</li>
        <li><strong>Uniaxial dispersion:</strong> extraordinary phase index depends on <code>ψ</code> (why: index ellipsoid / dielectric tensor).</li>
        <li><strong>Energy transport direction:</strong> extraordinary ray deviates by <code>ρ</code> (why: group velocity is normal to the dispersion surface).</li>
        <li><strong>Geometry:</strong> Δ across thickness is set by angular separation of the two energy rays.</li>
      </ul>

      <h3>Assumptions</h3>
      <div class="callouts">
        <div class="callout warn">
          <h4>Assumptions used in the solution</h4>
          <ul>
            <li>Lossless, homogeneous slab; no absorption or scattering.</li>
            <li>Geometrical optics (beam is well-collimated; diffraction neglected).</li>
            <li>Single pass (ignore internal reflections); small beam divergence.</li>
            <li>Optic axis lies in the plane of incidence for maximizing separation (we justify this below).</li>
          </ul>
        </div>
      </div>

      <h3>Possible approaches (2–3) and comparison</h3>
      <ul>
        <li><strong>Approach A (index ellipsoid + ray geometry):</strong> derive <code>n_e(ψ)</code> and <code>ρ(ψ)</code>, then express Δ and optimize.
          <br><span style="color:var(--faint)">Pros:</span> direct, teaches physics; <span style="color:var(--faint)">Cons:</span> some algebra.</li>
        <li><strong>Approach B (Fermat / group velocity from dispersion):</strong> compute ray direction as gradient of ω(k) surface.
          <br><span style="color:var(--faint)">Pros:</span> fundamental; <span style="color:var(--faint)">Cons:</span> heavier math for a textbook-style problem.</li>
        <li><strong>Approach C (small-birefringence approximation):</strong> approximate <code>ρ</code> and optimize approximately.
          <br><span style="color:var(--faint)">Pros:</span> simple; <span style="color:var(--faint)">Cons:</span> misses the clean exact optimum condition.</li>
      </ul>

      <p><strong>We choose Approach A</strong> because it yields a clear, compact optimum condition for <code>ψ</code> and makes the geometry interpretation straightforward.</p>
    </div>
  </section>

  <section id="part2">
    <div class="inner">
      <h2>PART 2 — Strategy & Tips (roadmap only)</h2>
      <ol style="margin:10px 0 10px 22px; color:var(--muted)">
        <li><strong>Define geometry:</strong> slab normal, plane of incidence, optic axis tilt <code>β</code>, and wave-normal angles <code>θ_o</code>, <code>θ_e</code>.</li>
        <li><strong>Apply Snell to the ordinary wave normal:</strong> <code>n_1 sinθ_i = n_o sinθ_o</code>.</li>
        <li><strong>Write extraordinary phase index vs ψ:</strong> compute <code>n_e(ψ)</code> from the uniaxial relation.</li>
        <li><strong>Apply tangential k matching for extraordinary:</strong> solve <code>n_1 sinθ_i = n_e(ψ) sinθ_e</code> with <code>ψ = |β − θ_e|</code> (principal-section geometry).</li>
        <li><strong>Compute walk-off ρ(ψ):</strong> use the index-ellipsoid ray relation (energy direction).</li>
        <li><strong>Convert to energy-ray angles:</strong> ordinary ray uses <code>θ_o</code>; extraordinary ray uses <code>θ_e + ρ</code>.</li>
        <li><strong>Write lateral shift:</strong> <code>Δ ≈ d[ tanθ_o − tan(θ_e + ρ) ]</code>.</li>
        <li><strong>Optimize for maximum separation:</strong> first maximize |ρ| w.r.t. <code>ψ</code> → get <code>tanψ_opt = n_e/n_o</code>.</li>
        <li><strong>Geometry choice:</strong> enforce principal section (optic axis in incidence plane), pick incidence/axis tilt so <code>ψ = ψ_opt</code>.</li>
        <li><strong>Amplify with propagation angle:</strong> choose as large internal angles as practical (near-grazing) to increase |Δ| through tangents.</li>
      </ol>

      <div class="callouts">
        <div class="callout">
          <h4>Common mistakes + quick tips</h4>
          <ul>
            <li>Tip: always compute <code>ψ</code> from the extraordinary <em>wave normal</em> direction, not from the ray direction.</li>
            <li>Tip: “maximum walk-off” and “maximum lateral shift” are related but not identical; Δ also grows with internal angle because of <code>tan()</code>.</li>
            <li>Mistake: orienting the optic axis out of the plane of incidence reduces splitting in the measured lateral direction (projection loss).</li>
          </ul>
        </div>
      </div>
    </div>
  </section>

  <section id="part3">
    <div class="inner">
      <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

      <h3>Qualitative expectation (before calculating)</h3>
      <p>
        The ordinary beam behaves like in an isotropic medium: its energy and phase travel together.
        The extraordinary beam is special: its phase refraction depends on direction and, additionally, the energy ray “walks off” sideways.
        So, to maximize lateral separation, we should:
      </p>
      <ul>
        <li>Make the extraordinary walk-off <code>|ρ|</code> as large as possible.</li>
        <li>Arrange the geometry so that this walk-off occurs in the same transverse direction as the ordinary/extraordinary splitting (no wasted projection).</li>
        <li>Use large internal propagation angles (when feasible), because lateral displacement across a thickness scales like <code>d tan(θ)</code>.</li>
      </ul>

      <div class="hr"></div>

      <h3>Step 1 — Define the principal-section geometry</h3>
      <p>
        Let the slab surface normal inside the crystal be the reference axis. Choose the <strong>plane of incidence</strong> as the plane that contains the incident wavevector and the normal.
        To maximize the measurable lateral separation, we place the <strong>optic axis</strong> in this same plane (this is the <strong>principal section</strong>).
      </p>
      <ul>
        <li><code>θ_i</code>: incidence angle in air (relative to surface normal)</li>
        <li><code>θ_o</code>: ordinary wave-normal angle inside</li>
        <li><code>θ_e</code>: extraordinary wave-normal angle inside</li>
        <li><code>β</code>: optic-axis tilt angle (inside) relative to the surface normal</li>
        <li><code>ψ = |β − θ_e|</code>: angle between extraordinary wave normal and optic axis (in the incidence plane)</li>
      </ul>

      <div class="callouts">
        <div class="callout warn">
          <h4>Why “optic axis in the plane of incidence” is optimal</h4>
          <p>
            The splitting direction is set by the anisotropy, which lies in the plane spanned by the optic axis and the wave normal.
            If the optic axis is out of the incidence plane, the walk-off and extraordinary refraction partly occur out of the “lateral” direction you measure,
            reducing the observed separation (it becomes a projection).
          </p>
        </div>
      </div>

      <h3>Step 2 — Ordinary refraction (simple Snell)</h3>
      <p>
        For the ordinary wave, the phase index is constant: <code>n_o</code>.
        Tangential phase matching gives:
      </p>
      <div class="equation">
        <button class="copyBtn" data-copy="#eq1">Copy</button>
        <pre class="eq" id="eq1">Ordinary (wave normal):
n1 sin(θi) = no sin(θo)</pre>
      </div>
      <p>
        Here <code>n1</code> is the incident medium index (typically air, <code>n1 ≈ 1</code>).
        The ordinary energy ray satisfies <code>S_o || k_o</code>, so its ray angle is also <code>θ_o</code>.
      </p>

      <h3>Step 3 — Extraordinary phase index as a function of ψ</h3>
      <p>
        In a uniaxial crystal, the extraordinary wave sees an angle-dependent phase index <code>n_e(ψ)</code> given by the standard uniaxial relation:
      </p>
      <div class="equation">
        <button class="copyBtn" data-copy="#eq2">Copy</button>
        <pre class="eq" id="eq2">Extraordinary phase index (uniaxial):
1 / ne(ψ)^2 = (cos^2ψ) / ne^2 + (sin^2ψ) / no^2</pre>
      </div>
      <p>
        This tells us: if the wave normal aligns with the optic axis (<code>ψ=0</code>), then <code>ne(0)=ne</code>;
        if it is perpendicular (<code>ψ=90°</code>), then <code>ne(90°)=no</code>.
      </p>

      <h3>Step 4 — Extraordinary refraction (Snell applied to the wave normal)</h3>
      <p>
        Apply tangential <code>k</code>-matching to the extraordinary wave normal:
      </p>
      <div class="equation">
        <button class="copyBtn" data-copy="#eq3">Copy</button>
        <pre class="eq" id="eq3">Extraordinary (wave normal):
n1 sin(θi) = ne(ψ) sin(θe),   with ψ = |β − θe|   (principal section)</pre>
      </div>
      <p>
        Because <code>ne(ψ)</code> depends on <code>θ_e</code> through <code>ψ</code>, this is generally an implicit relation.
        (In the interactive plots, we solve it numerically; analytically, it’s enough to know it can be solved for <code>θ_e</code> once geometry is fixed.)
      </p>

      <h3>Step 5 — Walk-off angle ρ(ψ) for the extraordinary ray</h3>
      <p>
        The extraordinary energy (ray) direction is not parallel to its wave normal. The walk-off angle <code>ρ</code> (signed) is:
      </p>
      <div class="equation">
        <button class="copyBtn" data-copy="#eq4">Copy</button>
        <pre class="eq" id="eq4">Walk-off (extraordinary ray vs wave normal):
tan(ρ) = (no^2 − ne^2) sinψ cosψ / (ne^2 cos^2ψ + no^2 sin^2ψ)</pre>
      </div>
      <p>
        For a <strong>positive uniaxial</strong> crystal (<code>ne &gt; no</code>), the numerator <code>(no^2 − ne^2)</code> is negative, so <code>ρ</code> is negative (for 0&lt;ψ&lt;90°):
        the extraordinary ray is deflected toward the optic axis compared to the wave normal (direction/sign depends on how you define angles; the magnitude is what matters for “how much separation”).
      </p>

      <h3>Step 6 — Lateral shift across thickness d</h3>
      <p>
        Inside a uniform slab, rays travel in straight lines. Measured at the exit face, the lateral displacement of a ray that travels at angle <code>θ</code>
        relative to the normal is <code>x = d tanθ</code>. Therefore the separation between ordinary and extraordinary energy rays is approximately:
      </p>
      <div class="equation">
        <button class="copyBtn" data-copy="#eq5">Copy</button>
        <pre class="eq" id="eq5">Lateral separation (exit-face shift):
Δ ≈ d [ tan(θo) − tan(θe + ρ) ]</pre>
      </div>
      <p>
        This is the clean geometric “output measure” you want to maximize by choosing incidence and optic-axis orientation.
      </p>

      <div class="hr"></div>

      <h3>Step 7 — Optimize the geometry: first maximize the walk-off magnitude |ρ|</h3>
      <p>
        The biggest “birefringent sideways drift” comes from maximizing <code>|ρ(ψ)|</code> with respect to <code>ψ</code>.
        Using the expression for <code>tanρ</code> above, one can optimize by setting <code>d|tanρ|/dψ = 0</code>.
        The maximum occurs at a remarkably simple condition:
      </p>

      <div class="equation">
        <button class="copyBtn" data-copy="#eq6">Copy</button>
        <pre class="eq" id="eq6">Maximum-walkoff condition (uniaxial):
tan(ψopt) = ne / no</pre>
      </div>

      <p>
        <strong>Interpretation:</strong> the extraordinary wave normal should be neither parallel nor perpendicular to the optic axis, but at an intermediate angle set by the ratio of principal indices.
        For weak birefringence (<code>ne ≈ no</code>), this is close to 45°.
      </p>

      <div class="callouts">
        <div class="callout good">
          <h4>Geometric prescription (core “optimum geometry” answer)</h4>
          <ul>
            <li><strong>Place the optic axis in the plane of incidence</strong> (principal section), so all separation lies in one measurable transverse direction.</li>
            <li><strong>Choose incidence and/or axis tilt</strong> such that the extraordinary <em>wave normal</em> satisfies <code>ψ = ψopt</code> where <code>tanψopt = ne/no</code>.</li>
            <li><strong>Then maximize Δ further</strong> by making the internal angles as large as practical (near-grazing propagation), because <code>Δ ∝ tan(·)</code>.</li>
          </ul>
        </div>
      </div>

      <h3>Step 8 — What “maximize internal angles” means (and why it helps)</h3>
      <p>
        Even if you have already maximized <code>|ρ|</code>, the total separation is
        <code>Δ = d [tanθ_o − tan(θ_e + ρ)]</code>. The tangent function grows rapidly as angles approach 90°.
        Therefore, for a given slab thickness, the largest Δ is achieved by choosing the largest feasible internal propagation angles
        (limited by practical coupling/beam footprint and any total-internal-reflection constraints at the exit).
      </p>

      <div class="callouts">
        <div class="callout warn">
          <h4>Sanity checks</h4>
          <ul>
            <li><strong>Units:</strong> Δ has units of length because it is <code>d × tan(·)</code>.</li>
            <li><strong>Limits:</strong> If <code>ne → no</code> (no birefringence), then <code>ρ → 0</code>, <code>θe → θo</code>, so <code>Δ → 0</code>.</li>
            <li><strong>Limits:</strong> If <code>ψ → 0</code> or <code>ψ → 90°</code>, then <code>sinψ cosψ → 0</code>, so <code>ρ → 0</code> and separation reduces.</li>
            <li><strong>Direction reasoning (positive uniaxial):</strong> the extraordinary energy ray bends toward the optic axis relative to its wave normal, enhancing separation when the optic axis is tilted toward the lateral direction.</li>
          </ul>
        </div>
      </div>

      <h3>Final answer (boxed)</h3>
      <div class="equation" style="border-color: rgba(125,211,252,.35); background: rgba(125,211,252,.08)">
        <button class="copyBtn" data-copy="#finalAns">Copy</button>
        <pre class="eq" id="finalAns">OPTIMUM GEOMETRY (positive uniaxial, ne > no):

1) Use the principal section: put the optic axis â in the plane of incidence (defined by incident k and the surface normal).
   Then the ordinary and extraordinary rays separate maximally in that plane (no projection loss).

2) Choose incidence direction and/or optic-axis tilt β so that the extraordinary WAVE NORMAL ke inside the crystal makes
   the “maximum-walkoff” angle ψopt with the optic axis:

      tan(ψopt) = ne / no     (equivalently ψopt = arctan(ne/no)).

   Here ψ = angle(ke, â) = |β − θe| in the principal-section geometry.

3) The exit-face lateral separation across thickness d is approximately

      Δ ≈ d [ tan(θo) − tan(θe + ρ) ],

   where θo obeys n1 sinθi = no sinθo, θe obeys n1 sinθi = ne(ψ) sinθe,
   and tanρ = (no^2 − ne^2) sinψ cosψ / (ne^2 cos^2ψ + no^2 sin^2ψ).

4) After enforcing ψ = ψopt (max |ρ|), maximize Δ further by taking the largest practical internal propagation angles
   (near-grazing inside the slab), since Δ scales with tan(·). </pre>
      </div>

      <p class="copyNote">
        The interactive diagram/plots above visualize exactly these symbols and show how ψ, ρ, and Δ respond to geometry choices.
      </p>
    </div>
  </section>

  <section id="part4">
    <div class="inner">
      <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

      <h3>Re-interpreting the final formulas: what controls what?</h3>
      <ul>
        <li><strong><code>ψ</code> controls walk-off:</strong> <code>ρ(ψ)</code> peaks when <code>tanψ = ne/no</code>. This is the most “anisotropic” direction for energy flow.</li>
        <li><strong><code>θ</code> controls geometric amplification:</strong> even moderate angular differences create large Δ when <code>θ</code> is large because of <code>tanθ</code>.</li>
        <li><strong>Birefringence strength:</strong> larger difference between <code>ne</code> and <code>no</code> generally increases <code>|ρ|</code> and thus separation potential.</li>
      </ul>

      <h3>How changing parameters affects Δ (connect to plots)</h3>
      <ul>
        <li>Increasing <code>ne</code> (while keeping <code>no</code> fixed) shifts <code>ψopt = arctan(ne/no)</code> upward and increases the maximum |ρ|.</li>
        <li>Increasing <code>β</code> changes which <code>ψ = |β − θe|</code> you achieve for a given incidence; you can “tune” β to hit ψopt.</li>
        <li>Increasing <code>θi</code> typically increases internal angles and can strongly increase |Δ| (up to practical limits).</li>
        <li>Δ scales linearly with thickness <code>d</code>.</li>
      </ul>

      <h3>Alternative derivation idea (brief)</h3>
      <p>
        Instead of using the known walk-off formula, you can derive the extraordinary ray direction by treating the dispersion surface
        (index ellipsoid) and computing the group velocity direction as the gradient of the frequency surface in k-space.
        This automatically yields that the ray is normal to the wave-normal surface and reproduces the same <code>ρ(ψ)</code>.
      </p>

      <h3>Concept checks (self-test)</h3>
      <ul>
        <li><strong>Q:</strong> Why doesn’t the ordinary beam have walk-off?<br><strong>A:</strong> Its index surface is spherical (direction-independent), so group and phase directions coincide.</li>
        <li><strong>Q:</strong> Why must ψ be defined using the extraordinary <em>wave normal</em> and not the ray direction?<br><strong>A:</strong> The angle-dependent refractive index comes from the phase (dispersion) relation, which is defined for the wave normal.</li>
        <li><strong>Q:</strong> What happens to Δ if <code>ne → no</code>?<br><strong>A:</strong> Birefringence vanishes; both rays coincide and Δ → 0.</li>
        <li><strong>Q:</strong> Why is placing the optic axis out of the incidence plane suboptimal for lateral shift?<br><strong>A:</strong> The separation then partially occurs out of the measured transverse direction, reducing the observed Δ (projection loss).</li>
      </ul>
    </div>
  </section>

  <section id="part5">
    <div class="inner">
      <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>

      <h3>Diagram canvas (top)</h3>
      <ul>
        <li>Shows a crystal slab of thickness <code>d</code> with surface normal.</li>
        <li>Incident ray at <code>θi</code> splits into:
          <ul>
            <li><strong>Ordinary</strong> ray at angle <code>θo</code> (energy ‖ wave normal).</li>
            <li><strong>Extraordinary</strong> wave normal at <code>θe</code>, and energy ray at <code>θe + ρ</code>.</li>
          </ul>
        </li>
        <li>The optic axis is drawn at tilt <code>β</code>. The angle between optic axis and extraordinary wave normal is <code>ψ</code>.</li>
        <li>The lateral separation at the exit face is labeled <code>Δ</code>.</li>
      </ul>

      <h3>Main plot (middle): Δ vs incidence angle</h3>
      <ul>
        <li>Horizontal axis: <code>θi</code> (deg), from normal incidence to near-grazing.</li>
        <li>Vertical axis: lateral separation <code>Δ</code> (mm) for the chosen example thickness <code>d</code>.</li>
        <li>A marker indicates the current slider value of <code>θi</code>.</li>
      </ul>

      <h3>Secondary plot (bottom): |ρ| vs ψ</h3>
      <ul>
        <li>Horizontal axis: <code>ψ</code> (deg), the angle between extraordinary wave normal and optic axis.</li>
        <li>Vertical axis: <code>|ρ|</code> (deg).</li>
        <li>Two markers:
          <ul>
            <li><strong>Current</strong> ψ from your chosen geometry.</li>
            <li><strong>ψopt</strong> where <code>tanψopt = ne/no</code> (maximum walk-off).</li>
          </ul>
        </li>
      </ul>

      <h3>Controls (what changes and why)</h3>
      <ul>
        <li><strong>θi:</strong> changes refraction angles and often amplifies Δ through the <code>tan()</code> factors.</li>
        <li><strong>β:</strong> changes ψ, letting you hit the optimum <code>ψopt</code>.</li>
        <li><strong>n<sub>o</sub>, n<sub>e</sub>:</strong> change birefringence strength and the optimum condition.</li>
        <li><strong>d:</strong> scales Δ linearly (pure geometry).</li>
      </ul>
    </div>
  </section>
</main>

<footer>
  <div class="hr"></div>
  <p>
    Built as a self-contained learning article: theory → analysis → strategy → full derivation → deeper insight → interactive visualization.
    (All visuals are vanilla HTML5 canvas; no external libraries.)
  </p>
</footer>

<script>
/* ---------------------------
   Smooth scrolling for TOC
---------------------------- */
document.querySelectorAll('[data-jump]').forEach(a=>{
  a.addEventListener('click', (e)=>{
    e.preventDefault();
    const id = a.getAttribute('href');
    const el = document.querySelector(id);
    if(!el) return;
    el.scrollIntoView({behavior:'smooth', block:'start'});
  });
});

/* ---------------------------
   Copy buttons (plain text)
---------------------------- */
async function copyTextFromSelector(sel){
  const el = document.querySelector(sel);
  if(!el) return;
  const txt = el.innerText.trim();
  try{
    await navigator.clipboard.writeText(txt);
  }catch(err){
    // fallback
    const ta=document.createElement('textarea');
    ta.value=txt;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    ta.remove();
  }
}
document.querySelectorAll('.copyBtn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const sel = btn.getAttribute('data-copy');
    copyTextFromSelector(sel);
    btn.textContent = "Copied!";
    setTimeout(()=>btn.textContent="Copy", 900);
  });
});

/* ---------------------------
   Optics math helpers (JS)
---------------------------- */
function deg2rad(d){ return d*Math.PI/180; }
function rad2deg(r){ return r*180/Math.PI; }

function neOfPsi(psi, no, ne){
  const c = Math.cos(psi), s = Math.sin(psi);
  const inv = (c*c)/(ne*ne) + (s*s)/(no*no);
  return 1/Math.sqrt(inv);
}

// Walk-off: tan(rho) = (no^2 - ne^2) sinψ cosψ / (ne^2 cos^2ψ + no^2 sin^2ψ)
function rhoOfPsi(psi, no, ne){
  const num = (no*no - ne*ne) * Math.sin(psi) * Math.cos(psi);
  const den = (ne*ne) * (Math.cos(psi)**2) + (no*no) * (Math.sin(psi)**2);
  return Math.atan2(num, den); // signed
}

// Solve for theta_e using bisection on f(theta)= ne(psi(theta))*sin(theta) - n1 sin(thetai)
function solveThetaE(thetaI, beta, n1, no, ne){
  const s = n1*Math.sin(thetaI);
  // bracket [0, pi/2)
  let lo = 0.0;
  let hi = Math.PI/2 - 1e-6;

  function f(th){
    const psi = Math.abs(beta - th);
    const neEff = neOfPsi(psi, no, ne);
    return neEff*Math.sin(th) - s;
  }

  // If s is 0, theta is 0.
  if(Math.abs(s) < 1e-12) return 0;

  // Evaluate at lo
  let flo = f(lo);
  let fhi = f(hi);

  // If the function doesn't change sign due to numeric weirdness, clamp by searching a bit
  if(flo*fhi > 0){
    // try scanning
    let best = lo;
    let bestAbs = Math.abs(flo);
    const N = 200;
    for(let i=1;i<=N;i++){
      const th = (hi-lo)*i/N;
      const val = f(th);
      const av = Math.abs(val);
      if(av < bestAbs){
        bestAbs = av;
        best = th;
      }
    }
    return best;
  }

  for(let k=0;k<70;k++){
    const mid = 0.5*(lo+hi);
    const fm = f(mid);
    if(Math.abs(fm) < 1e-12) return mid;
    if(fm*flo > 0){
      lo = mid;
      flo = fm;
    }else{
      hi = mid;
      fhi = fm;
    }
  }
  return 0.5*(lo+hi);
}

function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

/* ---------------------------
   Plotting utilities (canvas)
---------------------------- */
function setupCanvas(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(10, Math.floor(rect.width));
  const h = Math.max(10, Math.floor(rect.height));
  canvas.width = Math.floor(w*dpr);
  canvas.height = Math.floor(h*dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return {ctx, w, h, dpr};
}

function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
  const {x,y,w,h,padL,padR,padT,padB} = box;
  // background
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.10)';
  ctx.fillRect(x,y,w,h);

  // title
  ctx.fillStyle = 'rgba(233,238,252,0.95)';
  ctx.font = '600 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText(title, x+padL, y+18);

  const gx0 = x+padL, gx1 = x+w-padR;
  const gy0 = y+padT, gy1 = y+h-padB;

  // grid + ticks
  ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  ctx.lineWidth = 1;

  const nx=6, ny=5;
  for(let i=0;i<=nx;i++){
    const t=i/nx;
    const xx = gx0 + t*(gx1-gx0);
    ctx.beginPath(); ctx.moveTo(xx, gy0); ctx.lineTo(xx, gy1); ctx.stroke();
  }
  for(let j=0;j<=ny;j++){
    const t=j/ny;
    const yy = gy1 - t*(gy1-gy0);
    ctx.beginPath(); ctx.moveTo(gx0, yy); ctx.lineTo(gx1, yy); ctx.stroke();
  }

  // axes
  ctx.strokeStyle = 'rgba(255,255,255,0.35)';
  ctx.beginPath(); ctx.moveTo(gx0, gy1); ctx.lineTo(gx1, gy1); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(gx0, gy0); ctx.lineTo(gx0, gy1); ctx.stroke();

  // tick labels
  ctx.fillStyle = 'rgba(185,196,230,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';

  function fmt(v){
    const av=Math.abs(v);
    if(av>=100) return v.toFixed(0);
    if(av>=10) return v.toFixed(1);
    if(av>=1) return v.toFixed(2);
    return v.toFixed(3);
  }

  for(let i=0;i<=nx;i++){
    const t=i/nx;
    const xv = xMin + t*(xMax-xMin);
    const xx = gx0 + t*(gx1-gx0);
    ctx.fillText(fmt(xv), xx-12, gy1+18);
  }
  for(let j=0;j<=ny;j++){
    const t=j/ny;
    const yv = yMin + t*(yMax-yMin);
    const yy = gy1 - t*(gy1-gy0);
    ctx.fillText(fmt(yv), gx0-52, yy+4);
  }

  // labels
  ctx.fillStyle = 'rgba(185,196,230,0.95)';
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText(xLabel, (gx0+gx1)/2 - ctx.measureText(xLabel).width/2, y+h-8);

  ctx.save();
  ctx.translate(x+14, (gy0+gy1)/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
  ctx.restore();

  ctx.restore();

  return {gx0,gx1,gy0,gy1};
}

function xMap(x, xMin, xMax, gx0, gx1){
  return gx0 + (x - xMin)*(gx1-gx0)/(xMax-xMin);
}
function yMap(y, yMin, yMax, gy0, gy1){
  return gy1 - (y - yMin)*(gy1-gy0)/(yMax-yMin);
}

function drawLine(ctx, pts, strokeStyle, lineWidth){
  if(pts.length<2) return;
  ctx.save();
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = lineWidth;
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.stroke();
  ctx.restore();
}

function drawLegend(ctx, x, y, items){
  ctx.save();
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  let yy=y;
  for(const it of items){
    ctx.fillStyle = it.color;
    ctx.fillRect(x, yy-9, 12, 3);
    ctx.fillStyle = 'rgba(185,196,230,0.95)';
    ctx.fillText(it.label, x+18, yy);
    yy += 16;
  }
  ctx.restore();
}

function drawMarker(ctx, x, y, color){
  ctx.save();
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(x,y,4.5,0,Math.PI*2);
  ctx.fill();
  ctx.strokeStyle='rgba(255,255,255,0.65)';
  ctx.lineWidth=1;
  ctx.stroke();
  ctx.restore();
}

/* ---------------------------
   Main computation + rendering
---------------------------- */
const cvDiagram = document.getElementById('cvDiagram');
const cvMain = document.getElementById('cvMain');
const cvSecondary = document.getElementById('cvSecondary');

const slD = document.getElementById('slD');
const slTi = document.getElementById('slTi');
const slBeta = document.getElementById('slBeta');
const slNe = document.getElementById('slNe');
const slNo = document.getElementById('slNo');

const valD = document.getElementById('valD');
const valTi = document.getElementById('valTi');
const valBeta = document.getElementById('valBeta');
const valNe = document.getElementById('valNe');
const valNo = document.getElementById('valNo');

const kPsi = document.getElementById('kPsi');
const kRho = document.getElementById('kRho');
const kDelta = document.getElementById('kDelta');
const kPsiOpt = document.getElementById('kPsiOpt');

const btnOptimize = document.getElementById('btnOptimize');
const btnGrazing = document.getElementById('btnGrazing');

function getState(){
  return {
    dMm: parseFloat(slD.value),
    thetaIDeg: parseFloat(slTi.value),
    betaDeg: parseFloat(slBeta.value),
    ne: parseFloat(slNe.value),
    no: parseFloat(slNo.value),
    n1: 1.0
  };
}

function updateLabels(st){
  valD.textContent = st.dMm.toFixed(2);
  valTi.textContent = st.thetaIDeg.toFixed(1);
  valBeta.textContent = st.betaDeg.toFixed(1);
  valNe.textContent = st.ne.toFixed(3);
  valNo.textContent = st.no.toFixed(3);
}

function computeAt(st){
  const thetaI = deg2rad(st.thetaIDeg);
  const beta = deg2rad(st.betaDeg);
  const n1 = st.n1, no = st.no, ne = st.ne;

  // ordinary
  let thetaO = 0;
  const so = (n1*Math.sin(thetaI))/no;
  if(so >= 1) thetaO = Math.PI/2 - 1e-6;
  else thetaO = Math.asin(so);

  // extraordinary wave normal
  const thetaE = solveThetaE(thetaI, beta, n1, no, ne);
  const psi = Math.abs(beta - thetaE);
  const rho = rhoOfPsi(psi, no, ne);
  const thetaRayE = thetaE + rho;

  const deltaOverD = Math.tan(thetaO) - Math.tan(thetaRayE);
  const deltaMm = st.dMm * deltaOverD;

  // optimum psi
  const psiOpt = Math.atan(ne/no);

  return {thetaO, thetaE, thetaRayE, psi, rho, deltaOverD, deltaMm, psiOpt};
}

function drawDiagram(st, comp){
  const {ctx,w,h} = setupCanvas(cvDiagram);
  ctx.clearRect(0,0,w,h);

  // Layout
  const pad=18;
  const slabX0 = Math.round(w*0.52);
  const slabW = Math.round(w*0.30);
  const slabY0 = pad+24;
  const slabH = h - slabY0 - pad;

  // Background gradient
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,'rgba(255,255,255,0.03)');
  g.addColorStop(1,'rgba(0,0,0,0.18)');
  ctx.fillStyle=g;
  ctx.fillRect(0,0,w,h);

  // Slab
  ctx.save();
  ctx.fillStyle = 'rgba(125,211,252,0.08)';
  ctx.strokeStyle = 'rgba(255,255,255,0.22)';
  ctx.lineWidth = 1;
  ctx.fillRect(slabX0, slabY0, slabW, slabH);
  ctx.strokeRect(slabX0, slabY0, slabW, slabH);

  // normal line at entry face
  const entryX = slabX0;
  const midY = slabY0 + slabH*0.52;

  ctx.strokeStyle='rgba(255,255,255,0.35)';
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.moveTo(entryX, slabY0+20);
  ctx.lineTo(entryX, slabY0+slabH-20);
  ctx.stroke();
  ctx.setLineDash([]);

  // Normal arrow (pointing left)
  ctx.strokeStyle='rgba(233,238,252,0.70)';
  ctx.beginPath();
  ctx.moveTo(entryX, midY);
  ctx.lineTo(entryX-80, midY);
  ctx.stroke();
  // arrowhead
  ctx.beginPath();
  ctx.moveTo(entryX-80, midY);
  ctx.lineTo(entryX-68, midY-6);
  ctx.lineTo(entryX-68, midY+6);
  ctx.closePath();
  ctx.fillStyle='rgba(233,238,252,0.70)';
  ctx.fill();
  ctx.restore();

  // Helper to draw ray line
  function drawRay(x0,y0,angle,len,color,label){
    // angle measured from normal (x-axis pointing left), so direction inside: left-to-right is +x in our canvas?
    // We'll treat normal direction into slab as +x (to the right).
    const dx = Math.cos(angle);
    const dy = Math.sin(angle);
    const x1 = x0 + len*dx;
    const y1 = y0 + len*dy;

    ctx.save();
    ctx.strokeStyle=color;
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(x1,y1);
    ctx.stroke();
    // arrowhead
    const ah=10;
    const ang = Math.atan2(dy,dx);
    ctx.fillStyle=color;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x1 - ah*Math.cos(ang-0.35), y1 - ah*Math.sin(ang-0.35));
    ctx.lineTo(x1 - ah*Math.cos(ang+0.35), y1 - ah*Math.sin(ang+0.35));
    ctx.closePath();
    ctx.fill();

    // label
    ctx.fillStyle='rgba(233,238,252,0.92)';
    ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillText(label, x1+6, y1+4);
    ctx.restore();

    return {x1,y1};
  }

  // Incident ray (from left to entry)
  const thetaI = deg2rad(st.thetaIDeg);
  const incLen = Math.min(220, slabX0 - pad - 10);
  // incoming direction towards slab: from left to right, angle = thetaI but in canvas coordinates: y increases downward
  const startX = slabX0 - incLen;
  const startY = midY - incLen*Math.tan(thetaI)*0.2; // slight placement
  // We'll draw it to hit entry at midY
  // Compute a direction so that it ends at (entryX, midY)
  const dxIn = entryX - startX;
  const dyIn = midY - startY;
  const angIn = Math.atan2(dyIn, dxIn);

  // draw incoming line
  ctx.save();
  ctx.strokeStyle='rgba(233,238,252,0.55)';
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(startX,startY);
  ctx.lineTo(entryX,midY);
  ctx.stroke();
  // arrowhead at entry
  ctx.fillStyle='rgba(233,238,252,0.55)';
  ctx.beginPath();
  ctx.moveTo(entryX,midY);
  ctx.lineTo(entryX-10*Math.cos(angIn-0.35), midY-10*Math.sin(angIn-0.35));
  ctx.lineTo(entryX-10*Math.cos(angIn+0.35), midY-10*Math.sin(angIn+0.35));
  ctx.closePath();
  ctx.fill();
  ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillStyle='rgba(185,196,230,0.95)';
  ctx.fillText('incident', startX+6, startY-6);
  ctx.restore();

  // Draw optic axis inside slab
  const beta = deg2rad(st.betaDeg);
  const axLen = Math.min(240, slabW*0.95);
  const axX0 = slabX0 + slabW*0.15;
  const axY0 = midY;
  const axX1 = axX0 + axLen*Math.cos(beta);
  const axY1 = axY0 + axLen*Math.sin(beta);

  ctx.save();
  ctx.strokeStyle='rgba(167,139,250,0.80)';
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(axX0, axY0);
  ctx.lineTo(axX1, axY1);
  ctx.stroke();
  ctx.fillStyle='rgba(167,139,250,0.80)';
  ctx.beginPath();
  ctx.arc(axX0, axY0, 3, 0, Math.PI*2);
  ctx.fill();
  ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText('optic axis â', axX1+6, axY1+4);
  ctx.restore();

  // Rays inside
  const inLen = Math.min(340, slabW + 140);

  // Ordinary ray uses thetaO; in canvas, normal direction is +x (to right).
  const oEnd = drawRay(entryX, midY, comp.thetaO, inLen, 'rgba(125,211,252,0.95)', 'o-ray');

  // Extraordinary ray uses thetaRayE
  const eEnd = drawRay(entryX, midY, comp.thetaRayE, inLen, 'rgba(52,211,153,0.95)', 'e-ray (energy)');

  // Exit face line (right side)
  const exitX = slabX0 + slabW;
  ctx.save();
  ctx.strokeStyle='rgba(255,255,255,0.22)';
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(exitX, slabY0);
  ctx.lineTo(exitX, slabY0+slabH);
  ctx.stroke();
  ctx.restore();

  // Intersections with exit plane to show lateral separation at exit face
  function yAtX(x0,y0,angle,x){
    const dx = Math.cos(angle);
    const dy = Math.sin(angle);
    const t = (x - x0) / dx;
    return y0 + t*dy;
  }
  const yO = yAtX(entryX, midY, comp.thetaO, exitX);
  const yE = yAtX(entryX, midY, comp.thetaRayE, exitX);

  // Mark points
  ctx.save();
  ctx.fillStyle='rgba(125,211,252,0.95)';
  ctx.beginPath(); ctx.arc(exitX, yO, 4,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='rgba(52,211,153,0.95)';
  ctx.beginPath(); ctx.arc(exitX, yE, 4,0,Math.PI*2); ctx.fill();

  // Separation bracket
  ctx.strokeStyle='rgba(233,238,252,0.65)';
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(exitX+10, yO);
  ctx.lineTo(exitX+10, yE);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(exitX+6, yO); ctx.lineTo(exitX+14, yO);
  ctx.moveTo(exitX+6, yE); ctx.lineTo(exitX+14, yE);
  ctx.stroke();

  ctx.fillStyle='rgba(233,238,252,0.85)';
  ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
  const dy = (yE - yO);
  ctx.fillText('Δ (exit shift)', exitX+18, yO + dy/2);

  // small angle labels
  ctx.fillStyle='rgba(185,196,230,0.95)';
  ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText(`θi = ${st.thetaIDeg.toFixed(1)}°`, slabX0-120, midY-22);
  ctx.fillText(`θo = ${rad2deg(comp.thetaO).toFixed(1)}°`, slabX0+8, midY-22);
  ctx.fillText(`θe = ${rad2deg(comp.thetaE).toFixed(1)}°`, slabX0+8, midY-6);
  ctx.fillText(`ρ = ${rad2deg(comp.rho).toFixed(2)}°`, slabX0+8, midY+10);
  ctx.fillText(`ψ = ${rad2deg(comp.psi).toFixed(2)}°`, slabX0+8, midY+26);

  // diagram title
  ctx.fillStyle='rgba(233,238,252,0.92)';
  ctx.font='600 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText('Diagram: o- and e-rays in a uniaxial slab (principal section)', 18, 22);

  ctx.restore();
}

function drawMainPlot(st){
  const {ctx,w,h} = setupCanvas(cvMain);
  ctx.clearRect(0,0,w,h);

  const box = {x:10,y:10,w:w-20,h:h-20,padL:64,padR:16,padT:34,padB:42};
  const thetaMin=0, thetaMax=85;

  // compute curve Δ(θi)
  const N=280;
  let xs=[], ys=[];
  let yMin=Infinity, yMax=-Infinity;

  // We'll compute in mm
  for(let i=0;i<N;i++){
    const t = i/(N-1);
    const thDeg = thetaMin + t*(thetaMax-thetaMin);
    const st2 = Object.assign({}, st, {thetaIDeg: thDeg});
    const comp = computeAt(st2);
    const y = comp.deltaMm;
    xs.push(thDeg);
    ys.push(y);
    if(isFinite(y)){
      yMin = Math.min(yMin, y);
      yMax = Math.max(yMax, y);
    }
  }
  if(!isFinite(yMin) || !isFinite(yMax) || Math.abs(yMax-yMin)<1e-6){
    yMin=-1; yMax=1;
  } else {
    // padding
    const pad = 0.12*(yMax-yMin);
    yMin -= pad;
    yMax += pad;
  }

  const axes = drawAxes(ctx, box, thetaMin, thetaMax, yMin, yMax,
    'Incidence angle θi [deg]',
    'Lateral shift Δ [mm]',
    'Main plot: exit-face lateral separation Δ vs θi (example d)');

  // line points
  const pts = xs.map((x,i)=>({
    x: xMap(x,thetaMin,thetaMax,axes.gx0,axes.gx1),
    y: yMap(ys[i],yMin,yMax,axes.gy0,axes.gy1)
  }));
  drawLine(ctx, pts, 'rgba(125,211,252,0.95)', 2.2);

  // marker at current θi
  const compNow = computeAt(st);
  const xm = xMap(st.thetaIDeg,thetaMin,thetaMax,axes.gx0,axes.gx1);
  const ym = yMap(compNow.deltaMm,yMin,yMax,axes.gy0,axes.gy1);
  drawMarker(ctx, xm, ym, 'rgba(52,211,153,0.95)');

  // legend
  drawLegend(ctx, box.x+box.padL+6, box.y+box.padT+10, [
    {color:'rgba(125,211,252,0.95)', label:'Δ(θi) for chosen β, no, ne, d'},
    {color:'rgba(52,211,153,0.95)', label:'current slider point'}
  ]);
}

function drawSecondaryPlot(st){
  const {ctx,w,h} = setupCanvas(cvSecondary);
  ctx.clearRect(0,0,w,h);

  const box = {x:10,y:10,w:w-20,h:h-20,padL:64,padR:16,padT:34,padB:42};
  const psiMin=0, psiMax=90;

  const N=360;
  let xs=[], ys=[];
  let yMax=-Infinity;
  for(let i=0;i<N;i++){
    const t=i/(N-1);
    const psiDeg = psiMin + t*(psiMax-psiMin);
    const psi = deg2rad(psiDeg);
    const rho = rhoOfPsi(psi, st.no, st.ne);
    const y = Math.abs(rad2deg(rho));
    xs.push(psiDeg);
    ys.push(y);
    yMax = Math.max(yMax, y);
  }
  const yMin=0;
  yMax = Math.max(1e-3, yMax*1.12);

  const axes = drawAxes(ctx, box, psiMin, psiMax, yMin, yMax,
    'Angle ψ between ke and optic axis [deg]',
    '|ρ| [deg]',
    'Secondary plot: extraordinary walk-off magnitude |ρ(ψ)|');

  const pts = xs.map((x,i)=>({
    x: xMap(x,psiMin,psiMax,axes.gx0,axes.gx1),
    y: yMap(ys[i],yMin,yMax,axes.gy0,axes.gy1)
  }));
  drawLine(ctx, pts, 'rgba(167,139,250,0.95)', 2.2);

  const compNow = computeAt(st);
  const psiNowDeg = rad2deg(compNow.psi);
  const rhoNowDeg = Math.abs(rad2deg(compNow.rho));
  const psiOptDeg = rad2deg(compNow.psiOpt);
  const rhoOptDeg = Math.abs(rad2deg(rhoOfPsi(compNow.psiOpt, st.no, st.ne)));

  // markers
  drawMarker(ctx,
    xMap(psiNowDeg,psiMin,psiMax,axes.gx0,axes.gx1),
    yMap(rhoNowDeg,yMin,yMax,axes.gy0,axes.gy1),
    'rgba(52,211,153,0.95)'
  );
  drawMarker(ctx,
    xMap(psiOptDeg,psiMin,psiMax,axes.gx0,axes.gx1),
    yMap(rhoOptDeg,yMin,yMax,axes.gy0,axes.gy1),
    'rgba(251,191,36,0.95)'
  );

  drawLegend(ctx, box.x+box.padL+6, box.y+box.padT+10, [
    {color:'rgba(167,139,250,0.95)', label:'|ρ(ψ)| curve'},
    {color:'rgba(52,211,153,0.95)', label:'current ψ'},
    {color:'rgba(251,191,36,0.95)', label:'ψopt = arctan(ne/no)'}
  ]);
}

function updateKPIs(st, comp){
  kPsi.textContent = rad2deg(comp.psi).toFixed(2);
  kRho.textContent = rad2deg(comp.rho).toFixed(2);
  kDelta.textContent = comp.deltaMm.toFixed(3);
  kPsiOpt.textContent = rad2deg(comp.psiOpt).toFixed(2);
}

function renderAll(){
  const st = getState();
  // enforce positive uniaxial
  if(st.ne <= st.no){
    // gently nudge ne above no
    slNe.value = (st.no + 0.005).toFixed(3);
  }
  const st2 = getState();
  updateLabels(st2);
  const comp = computeAt(st2);
  updateKPIs(st2, comp);
  drawDiagram(st2, comp);
  drawMainPlot(st2);
  drawSecondaryPlot(st2);
}

// Hook controls
[slD, slTi, slBeta, slNe, slNo].forEach(el=>{
  el.addEventListener('input', renderAll);
});

btnOptimize.addEventListener('click', ()=>{
  // Try to set beta so that psi ~ psiOpt at current thetaI by adjusting beta toward thetaE +/- psiOpt
  const st = getState();
  const comp = computeAt(st);
  const thetaE = comp.thetaE;
  const betaCandidate = thetaE + comp.psiOpt; // choose one branch
  slBeta.value = clamp(rad2deg(betaCandidate), 0, 90).toFixed(1);
  renderAll();
});

btnGrazing.addEventListener('click', ()=>{
  slTi.value = 82.0;
  renderAll();
});

// Resize responsiveness
let resizeTimer=null;
window.addEventListener('resize', ()=>{
  clearTimeout(resizeTimer);
  resizeTimer=setTimeout(renderAll, 80);
});

// Initial
renderAll();
</script>
</body>
</html>
