<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>6.6-1 Circular Dichroism — Jones Matrix for a Device That Outputs Right Circular Polarization</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#121a33;
      --card2:#0f1730;
      --text:#e9ecff;
      --muted:#b8c0ff;
      --faint:#8f98d6;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --border:rgba(255,255,255,.10);
      --shadow: 0 18px 50px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 10% 10%, rgba(125,211,252,.14), transparent 55%),
        radial-gradient(900px 600px at 90% 15%, rgba(167,139,250,.14), transparent 55%),
        radial-gradient(900px 700px at 50% 100%, rgba(52,211,153,.10), transparent 55%),
        var(--bg);
      line-height:1.55;
    }
    a{ color:var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }

    header{
      padding:28px 18px 10px;
      max-width:1200px;
      margin:0 auto;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:16px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .hero{ grid-template-columns:1fr; }
    }
    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius: var(--radius);
      padding:18px 18px 14px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .titleCard:before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(500px 250px at 10% 10%, rgba(125,211,252,.18), transparent 60%),
                  radial-gradient(420px 260px at 90% 15%, rgba(167,139,250,.16), transparent 60%);
      pointer-events:none;
      filter: blur(2px);
      opacity:.9;
    }
    .titleCard > *{ position:relative; }
    h1{
      margin:0 0 8px;
      font-size: clamp(1.25rem, 2.2vw, 2.0rem);
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      margin:0 0 10px;
      font-size: 0.98rem;
    }
    .metaRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background: rgba(18,26,51,.55);
      color:var(--muted);
      font-size:.88rem;
      backdrop-filter: blur(8px);
    }
    .pill b{ color:var(--text); font-weight:600; }

    .toc{
      background: rgba(18,26,51,.65);
      border:1px solid var(--border);
      border-radius: var(--radius);
      padding:14px 14px 10px;
      box-shadow: var(--shadow);
      position: sticky;
      top: 10px;
      align-self:start;
      max-height: calc(100vh - 20px);
      overflow:auto;
    }
    .toc h2{
      margin:0 0 10px;
      font-size: 1rem;
      color:var(--text);
    }
    .toc a{
      display:block;
      padding:7px 10px;
      border-radius:12px;
      color:var(--muted);
      border:1px solid transparent;
    }
    .toc a:hover{
      background: rgba(125,211,252,.10);
      border-color: rgba(125,211,252,.20);
      text-decoration:none;
      color:var(--text);
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding: 0 18px 60px;
    }

    section{
      margin-top:18px;
      background: rgba(18,26,51,.55);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    section > header{
      padding: 14px 16px 10px;
      border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    }
    section > header h2{
      margin:0;
      font-size: 1.05rem;
      letter-spacing:.2px;
    }
    .content{
      padding: 14px 16px 18px;
      color: var(--text);
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 980px){
      .grid2{ grid-template-columns:1fr; }
    }

    .callouts{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:12px;
    }
    @media (max-width: 980px){
      .callouts{ grid-template-columns:1fr; }
    }

    .card{
      background: rgba(15,23,48,.55);
      border:1px solid var(--border);
      border-radius: 16px;
      padding:12px;
    }
    .card h3{
      margin:0 0 8px;
      font-size: .98rem;
      color: var(--text);
    }
    .muted{ color: var(--muted); }
    .small{ font-size:.92rem; }
    ul{ margin: 8px 0 0 18px; }
    li{ margin: 6px 0; }

    .eqWrap{
      margin:12px 0;
      border-radius: 16px;
      border:1px solid rgba(125,211,252,.25);
      background: linear-gradient(180deg, rgba(125,211,252,.12), rgba(125,211,252,.06));
      padding:10px 10px 8px;
      position:relative;
      overflow:hidden;
    }
    .eqWrap.warn{
      border-color: rgba(251,191,36,.28);
      background: linear-gradient(180deg, rgba(251,191,36,.12), rgba(251,191,36,.05));
    }
    .eqWrap.good{
      border-color: rgba(52,211,153,.28);
      background: linear-gradient(180deg, rgba(52,211,153,.12), rgba(52,211,153,.05));
    }
    .eqTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:6px;
    }
    .eqTitle b{
      font-size:.92rem;
      color:var(--text);
      letter-spacing:.2px;
    }
    pre.eq{
      margin:0;
      font-family: var(--mono);
      font-size: .92rem;
      color: #f2f4ff;
      overflow:auto;
      padding:8px 8px 10px;
      border-radius: 12px;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      white-space: pre;
    }
    .copyBtn{
      appearance:none;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.07);
      color: var(--text);
      border-radius: 12px;
      padding:7px 10px;
      font-size: .85rem;
      cursor:pointer;
      transition: transform .08s ease, background .2s ease;
      user-select:none;
      white-space:nowrap;
    }
    .copyBtn:hover{ background: rgba(255,255,255,.10); }
    .copyBtn:active{ transform: translateY(1px) scale(.99); }
    .toast{
      position: fixed;
      right: 16px;
      bottom: 16px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.70);
      border:1px solid rgba(255,255,255,.15);
      color: var(--text);
      font-size: .9rem;
      opacity:0;
      pointer-events:none;
      transform: translateY(10px);
      transition: opacity .25s ease, transform .25s ease;
      z-index: 1000;
      backdrop-filter: blur(8px);
    }
    .toast.show{
      opacity:1;
      transform: translateY(0);
    }

    figure{
      margin: 0;
    }
    .vizPanel{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .vizGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .vizGrid{ grid-template-columns:1fr; }
    }
    .canvasCard{
      background: rgba(15,23,48,.62);
      border:1px solid var(--border);
      border-radius: 16px;
      padding: 10px;
      overflow:hidden;
      min-height: 280px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .canvasHeader{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .canvasHeader h3{
      margin:0;
      font-size:.98rem;
    }
    .canvasHeader .small{
      margin-top:2px;
      color:var(--muted);
    }
    canvas{
      width:100%;
      height: 240px;
      border-radius: 14px;
      background: rgba(0,0,0,.20);
      border:1px solid rgba(255,255,255,.10);
      flex: 1;
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:10px;
    }
    @media (max-width: 980px){
      .controls{ grid-template-columns:1fr; }
    }
    .control{
      background: rgba(15,23,48,.62);
      border:1px solid var(--border);
      border-radius: 16px;
      padding: 10px 10px 8px;
    }
    .control label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      color: var(--muted);
      font-size:.9rem;
      margin-bottom:6px;
    }
    .control label span.value{
      color: var(--text);
      font-weight:600;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .row2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width:560px){
      .row2{ grid-template-columns:1fr; }
    }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: var(--muted);
      font-size: .9rem;
    }
    .badge b{ color: var(--text); }
    .kbd{
      font-family: var(--mono);
      font-size:.86rem;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.22);
      color: var(--text);
    }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding: 18px;
      color: var(--faint);
      font-size: .92rem;
    }

    /* subtle motion */
    @media (prefers-reduced-motion: no-preference){
      section{ animation: fadeUp .45s ease both; }
      section:nth-child(1){ animation-delay: .02s; }
      section:nth-child(2){ animation-delay: .04s; }
      section:nth-child(3){ animation-delay: .06s; }
      section:nth-child(4){ animation-delay: .08s; }
      section:nth-child(5){ animation-delay: .10s; }
      section:nth-child(6){ animation-delay: .12s; }
      section:nth-child(7){ animation-delay: .14s; }
      @keyframes fadeUp{
        from{ opacity:0; transform: translateY(10px); }
        to{ opacity:1; transform: translateY(0); }
      }
    }

    /* print friendly */
    @media print{
      body{ background:#fff; color:#000; }
      .toc{ display:none; }
      section, .titleCard{ box-shadow:none; }
      section{ border: 1px solid #ddd; background:#fff; }
      .titleCard{ border:1px solid #ddd; background:#fff; }
      .pill, .badge{ border:1px solid #ddd; background:#fff; color:#000; }
      pre.eq{ background:#f7f7f7; color:#000; border:1px solid #ddd; }
      .copyBtn{ display:none; }
      canvas{ border:1px solid #ddd; background:#fff; }
    }
  </style>
</head>
<body>
  <header>
    <div class="hero">
      <div class="titleCard">
        <h1>6.6-1 — Circular Dichroism: Jones Matrix of a Device that Outputs Right Circular Polarization</h1>
        <p class="subtitle">
          We build the Jones-matrix description of an <em>ideal circular polarizer</em> (a circular dichroic device)
          that takes <strong>any input polarization</strong> and transmits <strong>only the right-circular component</strong>.
        </p>
        <div class="metaRow">
          <div class="pill"><b>Topic</b> Polarization optics (Jones calculus)</div>
          <div class="pill"><b>Key idea</b> Projection onto |R⟩</div>
          <div class="pill"><b>Result</b> A projector matrix in (x,y) basis</div>
        </div>
      </div>

      <nav class="toc" aria-label="Table of contents">
        <h2>On this page</h2>
        <a href="#quick" data-scroll>Quick Summary</a>
        <a href="#p0" data-scroll>PART 0 — Concept Primer</a>
        <a href="#p1" data-scroll>PART 1 — Problem Analysis</a>
        <a href="#p2" data-scroll>PART 2 — Strategy & Tips</a>
        <a href="#p3" data-scroll>PART 3 — Full Solution</a>
        <a href="#p4" data-scroll>PART 4 — Deeper Understanding</a>
        <a href="#p5" data-scroll>PART 5 — Visualization Guide</a>
        <a href="#viz" data-scroll>Interactive Visualizations</a>
      </nav>
    </div>
  </header>

  <main>
    <!-- Quick Summary -->
    <section id="quick">
      <header><h2>Quick Summary</h2></header>
      <div class="content">
        <ul>
          <li><strong>What this is about:</strong> Modeling <em>circular dichroism</em>, where a material absorbs right- and left-circular polarization differently.</li>
          <li><strong>Goal:</strong> Find the <strong>Jones matrix</strong> of a device that converts any input polarization into <strong>right-circularly polarized</strong> light.</li>
          <li><strong>Key physics idea:</strong> In Jones calculus, an “only-right-circular-transmits” device acts like a <strong>projector</strong> onto the right-circular basis vector |R⟩.</li>
          <li><strong>Governing tool:</strong> Basis change between linear (x,y) and circular (R,L) polarization bases, plus linearity of the device.</li>
          <li><strong>Core equation:</strong> <span class="kbd">J = t_R |R⟩⟨R|</span> (ideal), i.e., the output is proportional to |R⟩ for any input.</li>
          <li><strong>Final result type:</strong> <strong>Symbolic</strong> 2×2 Jones matrix in the (x,y) basis.</li>
          <li><strong>Plot meaning:</strong> The transmitted intensity is the <strong>right-circular fraction</strong> of the input (a projection magnitude squared).</li>
        </ul>
      </div>
    </section>

    <!-- PART 0 -->
    <section id="p0">
      <header><h2>PART 0 — Concept Primer (Theory Before Solving)</h2></header>
      <div class="content">
        <div class="grid2">
          <div class="card">
            <h3>Core definitions</h3>
            <ul>
              <li><strong>Jones vector</strong> (fully polarized, monochromatic):<br/>
                <span class="muted">E = [E<sub>x</sub>, E<sub>y</sub>]<sup>T</sup></span> where components are complex field amplitudes (same units as electric field, e.g. V/m).</li>
              <li><strong>Jones matrix</strong> (linear optical element):<br/>
                <span class="muted">E<sub>out</sub> = J E<sub>in</sub></span>, where <span class="muted">J</span> is a 2×2 complex matrix.</li>
              <li><strong>Circular polarization basis</strong>: right and left circular states |R⟩, |L⟩ are specific Jones vectors (normalized).</li>
              <li><strong>Circular dichroism</strong>: different absorption (or transmission) for |R⟩ and |L⟩ components.</li>
            </ul>
          </div>
          <div class="card">
            <h3>Physical meaning</h3>
            <ul>
              <li><strong>Complex amplitude</strong> encodes both magnitude and phase; the relative phase between x and y sets the ellipse rotation sense.</li>
              <li><strong>Jones calculus</strong> assumes: monochromatic light, fully polarized field, and a linear time-invariant optical element.</li>
              <li><strong>Dichroism</strong> is an <em>amplitude</em> effect (loss), not just a phase delay (which would be birefringence).</li>
              <li>A device that outputs <strong>right-circular</strong> for any input must <strong>discard</strong> the left-circular component (absorb/reflect it), i.e., it cannot be lossless.</li>
            </ul>
          </div>
        </div>

        <div class="callouts">
          <div class="eqWrap">
            <div class="eqTitle">
              <b>Right/Left circular Jones vectors (convention used here)</b>
              <button class="copyBtn" data-copy="#eq_circ">Copy</button>
            </div>
            <pre class="eq" id="eq_circ">|R⟩ = (1/√2) [ 1 ; -i ]
|L⟩ = (1/√2) [ 1 ; +i ]</pre>
            <p class="small muted" style="margin:8px 2px 0;">
              Convention note: With time dependence e<sup>-iωt</sup> and propagation toward +z, this choice labels the state with y lagging x by 90° as “right-circular”.
              (Different books swap the labels; the projector form stays the same once a convention is fixed.)
            </p>
          </div>

          <div class="eqWrap warn">
            <div class="eqTitle">
              <b>What to watch for (common pitfalls)</b>
            </div>
            <ul class="small" style="margin:0 0 0 18px;">
              <li><strong>Convention confusion:</strong> “Right” vs “left” can flip depending on viewing direction and sign convention. Always define |R⟩ explicitly.</li>
              <li><strong>Jones validity:</strong> Works for fully polarized monochromatic light; partially polarized needs Stokes/Mueller.</li>
              <li><strong>“Convert” implies loss:</strong> Mapping all inputs to a single polarization is a projection → it removes information and typically reduces intensity.</li>
              <li><strong>Global phase:</strong> Multiplying a Jones vector by e^{iφ} does not change polarization; don’t over-interpret it.</li>
            </ul>
          </div>
        </div>

        <div class="card" style="margin-top:12px;">
          <h3>Mini intuition examples</h3>
          <ul class="small">
            <li><strong>Linear x-polarized input</strong> has equal R and L content → an ideal right-circular polarizer transmits <em>half</em> the intensity (because it keeps only the R half).</li>
            <li><strong>Already right-circular input</strong> passes (nearly) unchanged (up to an overall amplitude transmission factor).</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- PART 1 -->
    <section id="p1">
      <header><h2>PART 1 — Problem Analysis (No Solving Yet)</h2></header>
      <div class="content">
        <div class="card">
          <h3>Problem restatement (in plain words)</h3>
          <p class="small muted" style="margin:0;">
            Certain materials absorb right- and left-circularly polarized light differently (circular dichroism).
            Find the <strong>Jones matrix</strong> of an ideal device that takes <strong>any</strong> input polarization state and outputs
            <strong>right-circularly polarized</strong> light.
          </p>
        </div>

        <div class="grid2" style="margin-top:12px;">
          <div class="card">
            <h3>Given</h3>
            <ul class="small">
              <li>No numbers are provided.</li>
              <li>The device is described qualitatively: it outputs right-circular for any input.</li>
              <li>We may model it as an ideal circular dichroic element.</li>
            </ul>
          </div>
          <div class="card">
            <h3>Unknowns / what must be found</h3>
            <ul class="small">
              <li>The 2×2 complex <strong>Jones matrix J</strong> (typically in the linear x–y basis).</li>
              <li>Optionally: interpret how it acts on arbitrary inputs (projection onto |R⟩).</li>
            </ul>
          </div>
        </div>

        <div class="callouts">
          <div class="card">
            <h3>Relevant principles (and why)</h3>
            <ul class="small">
              <li><strong>Linearity:</strong> Jones matrices represent linear mappings between field components.</li>
              <li><strong>Basis transformations:</strong> The simplest description of circular dichroism is diagonal in the circular basis (R,L).</li>
              <li><strong>Projection:</strong> “Convert any state to right-circular” means the output direction in Jones space is fixed (|R⟩), so the device is rank-1.</li>
            </ul>
          </div>
          <div class="eqWrap warn">
            <div class="eqTitle"><b>Assumptions (explicit)</b></div>
            <ul class="small" style="margin:0 0 0 18px;">
              <li>Monochromatic, fully polarized light → Jones calculus applies.</li>
              <li>The device is linear and time-invariant (no nonlinear optics, no modulation).</li>
              <li>Ideal behavior: it transmits the right-circular component and completely suppresses the left-circular component.</li>
              <li>No depolarization or scattering is modeled (pure Jones element).</li>
            </ul>
          </div>
        </div>

        <div class="card" style="margin-top:12px;">
          <h3>Possible approaches (compare)</h3>
          <ol class="small">
            <li><strong>Work in circular basis (best):</strong> Model the element as <span class="kbd">diag(t_R, t_L)</span>; enforce <span class="kbd">t_L = 0</span>; convert back to x–y basis. <span class="muted">Fast, physically transparent.</span></li>
            <li><strong>Projector method:</strong> Use <span class="kbd">J = t_R |R⟩⟨R|</span> directly; compute its matrix in x–y basis. <span class="muted">Very clean, highlights “conversion as projection”.</span></li>
            <li><strong>Action-on-basis vectors:</strong> Require outputs for two independent inputs (e.g., x and y) both be proportional to |R⟩; solve for matrix columns. <span class="muted">Works, but less insightful.</span></li>
          </ol>
          <p class="small muted" style="margin:8px 0 0;">
            <strong>Choice:</strong> We will use the <strong>projector / circular-basis</strong> viewpoint because it directly encodes “only R survives”.
          </p>
        </div>
      </div>
    </section>

    <!-- PART 2 -->
    <section id="p2">
      <header><h2>PART 2 — Strategy & Tips (Roadmap Only)</h2></header>
      <div class="content">
        <ol class="small">
          <li><strong>Define the polarization basis:</strong> Write explicit normalized |R⟩ and |L⟩ vectors. <span class="muted">Goal: remove ambiguity about conventions.</span></li>
          <li><strong>Model circular dichroism:</strong> In the (R,L) basis, write <span class="kbd">J_circ = diag(t_R, t_L)</span>. <span class="muted">Meaning: independent transmission of R and L components.</span></li>
          <li><strong>Impose “always right-circular output”:</strong> Set <span class="kbd">t_L = 0</span> (ideal suppression). <span class="muted">Meaning: left-circular is fully absorbed/rejected.</span></li>
          <li><strong>Convert to linear x–y basis:</strong> Use the basis change matrix U whose columns are |R⟩ and |L⟩ in x–y coordinates. Compute <span class="kbd">J_xy = U J_circ U^{-1}</span>.</li>
          <li><strong>Simplify:</strong> Recognize the result as a rank-1 projector: <span class="kbd">J_xy = t_R |R⟩⟨R|</span>.</li>
          <li><strong>Sanity checks:</strong> Verify (i) J maps |R⟩ to t_R|R⟩, (ii) maps |L⟩ to 0, and (iii) J is idempotent up to scale: J² = t_R J (when t_R is scalar).</li>
          <li><strong>Connect to intensity:</strong> Transmitted intensity ∝ |⟨R|E_in⟩|² (for ideal device). <span class="muted">This becomes the key plot.</span></li>
        </ol>

        <div class="callouts">
          <div class="eqWrap warn">
            <div class="eqTitle"><b>Common mistakes & quick tips</b></div>
            <ul class="small" style="margin:0 0 0 18px;">
              <li><strong>Tip:</strong> When forming ⟨R|, remember to <em>conjugate</em> the components of |R⟩.</li>
              <li><strong>Mistake:</strong> Using a “rotation matrix” instead of a basis-change matrix; here the basis vectors are complex.</li>
              <li><strong>Tip:</strong> If your J does not send |L⟩ to zero, it is not an ideal right-circular polarizer.</li>
            </ul>
          </div>
          <div class="eqWrap">
            <div class="eqTitle">
              <b>Key tool (projector form)</b>
              <button class="copyBtn" data-copy="#eq_proj">Copy</button>
            </div>
            <pre class="eq" id="eq_proj">If a device transmits only the polarization |p⟩, then (idealized)
J = t |p⟩⟨p|
so E_out = J E_in = t |p⟩ (⟨p|E_in⟩).</pre>
          </div>
        </div>
      </div>
    </section>

    <!-- PART 3 -->
    <section id="p3">
      <header><h2>PART 3 — Full Solution (Detailed + Teaching)</h2></header>
      <div class="content">
        <div class="card">
          <h3>Physical intuition before math</h3>
          <p class="small muted" style="margin:0;">
            “Convert any polarization into right-circular” means the device must <strong>erase</strong> the input’s polarization information and output a
            fixed polarization state. In linear algebra terms, it must map the 2D input space onto a <strong>1D line</strong> spanned by |R⟩.
            That is exactly what a <strong>projection operator</strong> does. Because it discards the orthogonal component, it generally reduces intensity.
          </p>
        </div>

        <div class="eqWrap">
          <div class="eqTitle">
            <b>Step 1 — Define the polarization states (x–y basis)</b>
            <button class="copyBtn" data-copy="#eq_step1">Copy</button>
          </div>
          <pre class="eq" id="eq_step1">Use linear basis vectors:
|x⟩ = [1; 0],  |y⟩ = [0; 1].

Define (normalized) circular states:
|R⟩ = (1/√2) [ 1 ; -i ]
|L⟩ = (1/√2) [ 1 ; +i ]</pre>
          <p class="small muted" style="margin:8px 2px 0;">
            These satisfy ⟨R|R⟩ = ⟨L|L⟩ = 1 and ⟨R|L⟩ = 0 (orthonormality).
          </p>
        </div>

        <div class="eqWrap">
          <div class="eqTitle">
            <b>Step 2 — Model circular dichroism in the circular basis</b>
            <button class="copyBtn" data-copy="#eq_step2">Copy</button>
          </div>
          <pre class="eq" id="eq_step2">In the (R,L) basis, circular dichroism is diagonal:
J_circ = [ t_R   0
           0    t_L ]

t_R, t_L are complex amplitude transmission factors
(|t|^2 gives intensity transmission).</pre>
          <p class="small muted" style="margin:8px 2px 0;">
            “Different absorption coefficients” means |t_R| ≠ |t_L| in general. A perfect right-circular polarizer is the extreme case t_L = 0.
          </p>
        </div>

        <div class="eqWrap good">
          <div class="eqTitle">
            <b>Step 3 — Impose the requirement: output is always right-circular</b>
            <button class="copyBtn" data-copy="#eq_step3">Copy</button>
          </div>
          <pre class="eq" id="eq_step3">Requirement: For any E_in, E_out is proportional to |R⟩.

That is achieved by suppressing the left-circular component:
t_L = 0  (ideal)

So:
J_circ = [ t_R  0
           0    0 ]</pre>
          <p class="small muted" style="margin:8px 2px 0;">
            Physically: the device transmits R and absorbs (or rejects) L.
          </p>
        </div>

        <div class="eqWrap">
          <div class="eqTitle">
            <b>Step 4 — Convert to the linear (x,y) basis via a basis-change matrix</b>
            <button class="copyBtn" data-copy="#eq_step4">Copy</button>
          </div>
          <pre class="eq" id="eq_step4">Let U be the matrix whose columns are |R⟩ and |L⟩ written in (x,y):

U = [ |R⟩  |L⟩ ] = (1/√2) [ 1   1
                           -i  +i ].

Because {|R⟩,|L⟩} is orthonormal, U is unitary:
U^{-1} = U† (conjugate transpose).

Then:
J_xy = U J_circ U^{-1} = U J_circ U†.</pre>
          <p class="small muted" style="margin:8px 2px 0;">
            We do this because the problem usually expects a Jones matrix acting on [E_x, E_y]^T.
          </p>
        </div>

        <div class="eqWrap">
          <div class="eqTitle">
            <b>Step 5 — Recognize the projector form and compute the matrix</b>
            <button class="copyBtn" data-copy="#eq_step5">Copy</button>
          </div>
          <pre class="eq" id="eq_step5">With t_L = 0, the device keeps only the |R⟩ component, so:
J_xy = t_R |R⟩⟨R|.

Compute the outer product:

|R⟩ = (1/√2)[1; -i]
⟨R| = (1/√2)[1, +i]   (complex conjugate transpose)

|R⟩⟨R| = (1/2) [ 1     i
                 -i    1 ].

Therefore:
J_xy = (t_R/2) [ 1     i
                 -i    1 ].</pre>
          <p class="small muted" style="margin:8px 2px 0;">
            This is a rank-1 matrix: it maps every input to a vector parallel to |R⟩.
          </p>
        </div>

        <div class="eqWrap good">
          <div class="eqTitle">
            <b>FINAL ANSWER — Jones matrix (x–y basis)</b>
            <button class="copyBtn" data-copy="#eq_final">Copy</button>
          </div>
          <pre class="eq" id="eq_final">Ideal “right-circular only” device:
J = t_R |R⟩⟨R| = (t_R/2) [ 1   i
                          -i  1 ].

(Here |R⟩ = (1/√2)[1; -i].)</pre>
        </div>

        <div class="callouts">
          <div class="card">
            <h3>Sanity checks</h3>
            <ul class="small">
              <li><strong>Check 1:</strong> J|R⟩ = t_R|R⟩ (passes right-circular).</li>
              <li><strong>Check 2:</strong> J|L⟩ = 0 (kills left-circular).</li>
              <li><strong>Check 3:</strong> Up to scale, it is a projector: (|R⟩⟨R|)^2 = |R⟩⟨R|.</li>
              <li><strong>Units:</strong> Jones matrices are dimensionless (they map field amplitudes to field amplitudes).</li>
              <li><strong>Limiting case:</strong> If input is linear x (|x⟩), output intensity becomes half of input when |t_R|=1.</li>
            </ul>
          </div>
          <div class="card">
            <h3>Physical interpretation in plain language</h3>
            <p class="small muted" style="margin:0;">
              The device measures “how much right-circular” the input is (via the inner product ⟨R|E_in⟩),
              and then emits only right-circular light with that amplitude. The orthogonal (left-circular) part is removed.
              That is why the transmitted intensity depends on the input polarization.
            </p>
          </div>
        </div>
      </div>
    </section>

    <!-- PART 4 -->
    <section id="p4">
      <header><h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2></header>
      <div class="content">
        <div class="grid2">
          <div class="card">
            <h3>Re-interpreting the matrix</h3>
            <ul class="small">
              <li>The factor <span class="kbd">t_R</span> sets the <strong>complex amplitude transmission</strong> for right-circular (magnitude → loss, phase → overall phase shift).</li>
              <li>The inner structure <span class="kbd">(1/2)[[1,i],[-i,1]]</span> is the <strong>projector</strong> that extracts the right-circular component from any (x,y) field.</li>
              <li>Because J is rank-1, it has one nonzero eigenvalue (t_R) with eigenvector |R⟩, and a zero eigenvalue with eigenvector |L⟩.</li>
            </ul>
          </div>
          <div class="card">
            <h3>How parameters affect outcomes (connect to plots)</h3>
            <ul class="small">
              <li>If the input polarization becomes more right-circular, the projection magnitude |⟨R|E_in⟩| increases → <strong>higher transmitted intensity</strong>.</li>
              <li>If the device is not perfectly dichroic (small t_L ≠ 0), the output becomes a mixture of R and L components → <strong>not purely right-circular</strong>. The plots show intensity changes and reduced “purity”.</li>
              <li>Changing the input ellipse parameters (orientation ψ and ellipticity χ) shifts how much of the field lies in the R subspace.</li>
            </ul>
          </div>
        </div>

        <div class="card" style="margin-top:12px;">
          <h3>Alternative derivation idea (brief)</h3>
          <p class="small muted" style="margin:0;">
            Instead of using basis transforms, you can determine the columns of J directly:
            require J|x⟩ and J|y⟩ to both be proportional to |R⟩, since any input is a linear combination of |x⟩ and |y⟩.
            This forces J to be rank-1 with output direction |R⟩, leading again to J = t_R|R⟩⟨R| (up to scale choices).
          </p>
        </div>

        <div class="card" style="margin-top:12px;">
          <h3>Concept checks (quick self-test)</h3>
          <ul class="small">
            <li><strong>Q:</strong> Why can’t this device be lossless for arbitrary inputs?<br/>
                <strong>A:</strong> It collapses a 2D set of states to 1D (projection), which necessarily discards the orthogonal component (energy must go somewhere → absorption/reflection/scattering).</li>
            <li><strong>Q:</strong> If the input is left-circular, what is the output?<br/>
                <strong>A:</strong> Zero (ideal case), because ⟨R|L⟩ = 0.</li>
            <li><strong>Q:</strong> For linear x-polarized input and |t_R|=1, what fraction of intensity transmits?<br/>
                <strong>A:</strong> 1/2, since |x⟩ contains equal R and L components.</li>
            <li><strong>Q:</strong> What changes if your book defines |R⟩ = (1/√2)[1; +i]?<br/>
                <strong>A:</strong> The matrix entries’ signs swap accordingly; it’s still a projector onto that defined |R⟩ state.</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- PART 5 -->
    <section id="p5">
      <header><h2>PART 5 — Visualization Guide (How to Read the Plots)</h2></header>
      <div class="content">
        <div class="card">
          <h3>What each canvas shows</h3>
          <ul class="small">
            <li><strong>Diagram:</strong> A beam with an input polarization ellipse entering a “circular dichroic” block; output is right-circular.</li>
            <li><strong>Main plot:</strong> Transmitted intensity fraction <span class="kbd">I_out/I_in</span> vs input <strong>ellipticity angle</strong> χ (degrees), for your current settings of ψ, t_R, t_L.</li>
            <li><strong>Secondary plot:</strong> Transmitted intensity fraction vs <strong>relative phase</strong> δ between y and x components (radians) for a chosen amplitude ratio r = |E_y|/|E_x|.</li>
          </ul>
        </div>

        <div class="card" style="margin-top:12px;">
          <h3>Interactive controls</h3>
          <ul class="small">
            <li><strong>ψ (orientation):</strong> rotates the polarization ellipse in the lab frame; it changes how the input decomposes into R/L.</li>
            <li><strong>χ (ellipticity):</strong> sets how circular the input is: χ = +45° is one circular handedness, χ = −45° is the opposite, χ = 0° is linear.</li>
            <li><strong>t_R and t_L:</strong> amplitude transmissions of the R and L components (example parameters for visualization). Setting t_L → 0 approaches the ideal “always right-circular output” device.</li>
            <li><strong>r (amplitude ratio) for secondary plot:</strong> controls how unequal Ex and Ey magnitudes are in the phase sweep plot.</li>
            <li><strong>All controls update all canvases live</strong>, so you can see how the same physics drives each visualization.</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Visualizations -->
    <section id="viz">
      <header><h2>Interactive Visualizations</h2></header>
      <div class="content">
        <div class="vizPanel">
          <div class="controls" aria-label="Interactive controls">
            <div class="control">
              <label for="psi">
                <span>Input ellipse orientation ψ (deg)</span>
                <span class="value" id="psiVal"></span>
              </label>
              <input id="psi" type="range" min="0" max="90" step="1" value="20"/>
              <div class="row2">
                <div class="badge"><b>Meaning:</b> ellipse tilt in x–y plane</div>
                <div class="badge"><b>Hint:</b> affects R/L decomposition</div>
              </div>
            </div>

            <div class="control">
              <label for="chi">
                <span>Input ellipticity χ (deg)</span>
                <span class="value" id="chiVal"></span>
              </label>
              <input id="chi" type="range" min="-45" max="45" step="1" value="0"/>
              <div class="row2">
                <div class="badge"><b>χ = 0°</b> linear</div>
                <div class="badge"><b>|χ| = 45°</b> circular</div>
              </div>
            </div>

            <div class="control">
              <label for="tR">
                <span>Device amplitude transmission t<sub>R</sub></span>
                <span class="value" id="tRVal"></span>
              </label>
              <input id="tR" type="range" min="0" max="1" step="0.01" value="1.00"/>
              <div class="row2">
                <div class="badge"><b>Intensity</b> ≈ |t<sub>R</sub>|²</div>
                <div class="badge"><b>Example value</b> for plots</div>
              </div>
            </div>

            <div class="control">
              <label for="tL">
                <span>Device amplitude transmission t<sub>L</sub></span>
                <span class="value" id="tLVal"></span>
              </label>
              <input id="tL" type="range" min="0" max="1" step="0.01" value="0.00"/>
              <div class="row2">
                <div class="badge"><b>Ideal</b> t<sub>L</sub>=0</div>
                <div class="badge"><b>Non-ideal</b> lets L leak</div>
              </div>
            </div>

            <div class="control" style="grid-column: 1 / -1;">
              <label for="rRatio">
                <span>Secondary plot: amplitude ratio r = |E<sub>y</sub>| / |E<sub>x</sub>|</span>
                <span class="value" id="rVal"></span>
              </label>
              <input id="rRatio" type="range" min="0" max="3" step="0.01" value="1.00"/>
              <div class="row2">
                <div class="badge"><b>Used in</b> phase sweep plot</div>
                <div class="badge"><b>Try</b> r ≠ 1 for asymmetry</div>
              </div>
            </div>
          </div>

          <div class="vizGrid">
            <figure class="canvasCard">
              <div class="canvasHeader">
                <div>
                  <h3>Diagram — Circular Dichroic “Right-Circular Polarizer”</h3>
                  <div class="small">Setup sketch (input ellipse → device → right-circular output).</div>
                </div>
              </div>
              <canvas id="cDiagram" aria-label="Physical setup diagram"></canvas>
            </figure>

            <figure class="canvasCard">
              <div class="canvasHeader">
                <div>
                  <h3>Main Plot — Transmitted Intensity vs Ellipticity χ</h3>
                  <div class="small">Plots I<sub>out</sub>/I<sub>in</sub> as χ varies (ψ fixed by slider).</div>
                </div>
                <div class="badge" title="Equation behind the curve"><b>Uses:</b> I ∝ |t_R⟨R|E⟩|² + |t_L⟨L|E⟩|²</div>
              </div>
              <canvas id="cMain" aria-label="Main quantitative plot"></canvas>
            </figure>

            <figure class="canvasCard" style="grid-column:1 / -1;">
              <div class="canvasHeader">
                <div>
                  <h3>Secondary Plot — Transmitted Intensity vs Phase δ (with r fixed)</h3>
                  <div class="small">Shows how relative phase between x and y changes the right/left circular content.</div>
                </div>
                <div class="badge" title="Parameter sweep"><b>Sweep:</b> δ ∈ [−π, +π] rad</div>
              </div>
              <canvas id="cSecond" aria-label="Secondary plot"></canvas>
            </figure>
          </div>

          <div class="eqWrap" style="margin-top:14px;">
            <div class="eqTitle">
              <b>Intensity relationship used in the plots (example modeling)</b>
              <button class="copyBtn" data-copy="#eq_intensity">Copy</button>
            </div>
            <pre class="eq" id="eq_intensity">Given E_in in (x,y), compute circular components:
a_R = ⟨R|E_in⟩,  a_L = ⟨L|E_in⟩.

With circular dichroism (amplitude transmissions t_R, t_L):
E_out = t_R a_R |R⟩ + t_L a_L |L⟩.

Relative transmitted intensity (normalized):
I_out / I_in = (|t_R|^2 |a_R|^2 + |t_L|^2 |a_L|^2) / (|E_in|^2).</pre>
            <p class="small muted" style="margin:8px 2px 0;">
              In the ideal device required by the problem, set t_L = 0, so the output polarization is purely |R⟩ (up to amplitude).
            </p>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer>
    Built as a self-contained learning article: theory → analysis → strategy → full derivation → interpretation → interactive visualizations.
  </footer>

  <div class="toast" id="toast" role="status" aria-live="polite">Copied.</div>

  <script>
    // -----------------------------
    // Smooth scrolling for TOC
    // -----------------------------
    document.querySelectorAll('[data-scroll]').forEach(a=>{
      a.addEventListener('click', (e)=>{
        e.preventDefault();
        const id = a.getAttribute('href');
        const el = document.querySelector(id);
        if(!el) return;
        el.scrollIntoView({behavior:'smooth', block:'start'});
      });
    });

    // -----------------------------
    // Copy buttons
    // -----------------------------
    const toast = document.getElementById('toast');
    let toastTimer = null;
    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add('show');
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=>toast.classList.remove('show'), 1200);
    }
    async function copyText(txt){
      try{
        await navigator.clipboard.writeText(txt);
        showToast('Copied to clipboard.');
      }catch(err){
        // Fallback
        const ta = document.createElement('textarea');
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        showToast('Copied (fallback).');
      }
    }
    document.querySelectorAll('.copyBtn').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const sel = btn.getAttribute('data-copy');
        const el = document.querySelector(sel);
        if(!el) return;
        copyText(el.textContent.trim());
      });
    });

    // -----------------------------
    // Complex helpers
    // -----------------------------
    function C(re, im){ return {re, im}; }
    function cAdd(a,b){ return C(a.re+b.re, a.im+b.im); }
    function cSub(a,b){ return C(a.re-b.re, a.im-b.im); }
    function cMul(a,b){ return C(a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re); }
    function cConj(a){ return C(a.re, -a.im); }
    function cAbs2(a){ return a.re*a.re + a.im*a.im; }
    function cScale(a,s){ return C(a.re*s, a.im*s); }

    // Dot product bra-ket: <u|v> = conj(u)^T v
    function inner(u,v){
      // u and v are arrays of complex length 2
      const uc0 = cConj(u[0]);
      const uc1 = cConj(u[1]);
      return cAdd(cMul(uc0, v[0]), cMul(uc1, v[1]));
    }

    // Norm squared of Jones vector
    function norm2(v){
      return cAbs2(v[0]) + cAbs2(v[1]);
    }

    // -----------------------------
    // Polarization basis (convention)
    // |R> = (1/sqrt2)[1; -i], |L> = (1/sqrt2)[1; +i]
    // -----------------------------
    const invSqrt2 = 1/Math.sqrt(2);
    const ketR = [ C(invSqrt2,0), C(0,-invSqrt2) ]; // [1/sqrt2, -i/sqrt2]
    const ketL = [ C(invSqrt2,0), C(0, invSqrt2) ]; // [1/sqrt2, +i/sqrt2]

    // -----------------------------
    // Input Jones from ellipse parameters (ψ, χ)
    // Standard parameterization (normalized):
    // E = [ cosψ cosχ - i sinψ sinχ
    //       sinψ cosχ + i cosψ sinχ ]
    // with e^{-iωt} time convention.
    // -----------------------------
    function jonesFromPsiChi(psiDeg, chiDeg){
      const psi = psiDeg * Math.PI/180;
      const chi = chiDeg * Math.PI/180;

      const cpsi = Math.cos(psi), spsi = Math.sin(psi);
      const cchi = Math.cos(chi), schi = Math.sin(chi);

      // Ex = cpsi cchi - i spsi schi
      const Ex = cSub(C(cpsi*cchi,0), C(0, spsi*schi)); // subtract i*spsi*schi -> (0, +spsi*schi) in imag, but with minus: (0, -spsi*schi)
      // Ey = spsi cchi + i cpsi schi
      const Ey = cAdd(C(spsi*cchi,0), C(0, cpsi*schi));

      // Normalize for numerical stability
      const n = Math.sqrt(norm2([Ex,Ey]));
      return [ C(Ex.re/n, Ex.im/n), C(Ey.re/n, Ey.im/n) ];
    }

    // Jones vector from amplitude ratio r and phase delta (Ey = r e^{iδ}, Ex = 1)
    function jonesFromRatioPhase(r, delta){
      const Ex = C(1,0);
      const Ey = C(r*Math.cos(delta), r*Math.sin(delta));
      const n = Math.sqrt(norm2([Ex,Ey]));
      return [ C(Ex.re/n, Ex.im/n), C(Ey.re/n, Ey.im/n) ];
    }

    // Output under circular dichroism: E_out = tR aR |R> + tL aL |L>
    function applyCircularDichroism(Ein, tR, tL){
      const aR = inner(ketR, Ein);
      const aL = inner(ketL, Ein);

      const tRc = C(tR,0);
      const tLc = C(tL,0);

      // components in circular basis
      const coefR = cMul(tRc, aR);
      const coefL = cMul(tLc, aL);

      // back to xy: Eout = coefR*ketR + coefL*ketL
      const Eout0 = cAdd(cMul(coefR, ketR[0]), cMul(coefL, ketL[0]));
      const Eout1 = cAdd(cMul(coefR, ketR[1]), cMul(coefL, ketL[1]));
      return {Eout:[Eout0, Eout1], aR, aL, coefR, coefL};
    }

    function intensityFraction(Ein, tR, tL){
      const aR = inner(ketR, Ein);
      const aL = inner(ketL, Ein);
      const Iin = norm2(Ein);
      const Iout = (tR*tR)*cAbs2(aR) + (tL*tL)*cAbs2(aL);
      return Iout / Iin;
    }

    // -----------------------------
    // Canvas plotting utilities
    // -----------------------------
    function setupHiDPICanvas(canvas){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(320, Math.floor(rect.width));
      const h = Math.max(240, Math.floor(rect.height));
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {ctx, w, h, dpr};
    }

    function drawPanelBackground(ctx, w, h){
      // subtle gradient
      const g = ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0, "rgba(255,255,255,0.05)");
      g.addColorStop(1, "rgba(255,255,255,0.02)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);
    }

    function drawAxes(ctx, box, xMin, xMax, yMin, yMax, xLabel, yLabel, title){
      const {x,y,w,h,padL,padR,padT,padB} = box;
      // Title
      ctx.fillStyle = "rgba(233,236,255,0.95)";
      ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(title, x + padL, y + 14);

      // Plot area
      const px0 = x + padL;
      const py0 = y + padT;
      const pw = w - padL - padR;
      const ph = h - padT - padB;

      // gridlines and ticks
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;

      function xToPx(xv){ return px0 + (xv - xMin) * pw / (xMax - xMin); }
      function yToPy(yv){ return py0 + ph - (yv - yMin) * ph / (yMax - yMin); }

      // grid: 6 vertical, 6 horizontal
      const nGrid = 6;
      ctx.beginPath();
      for(let i=0;i<=nGrid;i++){
        const t = i/nGrid;
        const gx = px0 + t*pw;
        const gy = py0 + t*ph;
        ctx.moveTo(gx, py0);
        ctx.lineTo(gx, py0+ph);
        ctx.moveTo(px0, gy);
        ctx.lineTo(px0+pw, gy);
      }
      ctx.stroke();

      // axes border
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.strokeRect(px0, py0, pw, ph);

      // ticks & labels
      ctx.fillStyle = "rgba(184,192,255,0.95)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";

      // x ticks
      const xTicks = 5;
      for(let i=0;i<=xTicks;i++){
        const xv = xMin + (xMax-xMin)*(i/xTicks);
        const xp = xToPx(xv);
        ctx.strokeStyle = "rgba(255,255,255,0.18)";
        ctx.beginPath();
        ctx.moveTo(xp, py0+ph);
        ctx.lineTo(xp, py0+ph+5);
        ctx.stroke();
        const txt = formatTick(xv);
        ctx.fillText(txt, xp - ctx.measureText(txt).width/2, py0+ph+18);
      }

      // y ticks
      const yTicks = 5;
      for(let i=0;i<=yTicks;i++){
        const yv = yMin + (yMax-yMin)*(i/yTicks);
        const yp = yToPy(yv);
        ctx.strokeStyle = "rgba(255,255,255,0.18)";
        ctx.beginPath();
        ctx.moveTo(px0-5, yp);
        ctx.lineTo(px0, yp);
        ctx.stroke();
        const txt = formatTick(yv);
        ctx.fillText(txt, px0-8-ctx.measureText(txt).width, yp+4);
      }

      // axis labels
      ctx.fillStyle = "rgba(233,236,255,0.90)";
      ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(xLabel, px0 + pw/2 - ctx.measureText(xLabel).width/2, y + h - 6);

      // y label rotated
      ctx.save();
      ctx.translate(x + 12, py0 + ph/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
      ctx.restore();

      return {xToPx, yToPy, px0, py0, pw, ph};
    }

    function formatTick(v){
      const av = Math.abs(v);
      if(av >= 1000) return v.toFixed(0);
      if(av >= 10) return v.toFixed(1);
      if(av >= 1) return v.toFixed(2);
      return v.toFixed(3);
    }

    function drawCurve(ctx, map, xs, ys, strokeStyle){
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i=0;i<xs.length;i++){
        const x = map.xToPx(xs[i]);
        const y = map.yToPy(ys[i]);
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    function drawMarker(ctx, map, x, y, color){
      const px = map.xToPx(x);
      const py = map.yToPy(y);
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(px, py, 4, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // -----------------------------
    // Diagram drawing: setup + polarization ellipses
    // -----------------------------
    function drawPolarizationEllipse(ctx, cx, cy, a, b, angleRad, sense, label){
      // sense: +1 or -1 for rotation sense indicator
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(angleRad);

      // ellipse
      ctx.strokeStyle = "rgba(125,211,252,0.90)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(0, 0, a, b, 0, 0, Math.PI*2);
      ctx.stroke();

      // major/minor axes
      ctx.strokeStyle = "rgba(255,255,255,0.20)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-a,0); ctx.lineTo(a,0);
      ctx.moveTo(0,-b); ctx.lineTo(0,b);
      ctx.stroke();

      // rotation arrow
      const r = Math.max(10, Math.min(a,b)*0.9);
      ctx.strokeStyle = "rgba(52,211,153,0.90)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      const start = sense>0 ? 0.2*Math.PI : 0.8*Math.PI;
      const end   = sense>0 ? 1.2*Math.PI : -0.2*Math.PI;
      ctx.arc(0,0,r,start,end, sense<0);
      ctx.stroke();
      // arrow head
      const ah = 7;
      const t = end;
      const ex = r*Math.cos(t), ey = r*Math.sin(t);
      const dir = sense>0 ? 1 : -1;
      const tx = -Math.sin(t)*dir, ty = Math.cos(t)*dir;
      ctx.fillStyle = "rgba(52,211,153,0.95)";
      ctx.beginPath();
      ctx.moveTo(ex, ey);
      ctx.lineTo(ex - ah*tx - ah*0.6*Math.cos(t), ey - ah*ty - ah*0.6*Math.sin(t));
      ctx.lineTo(ex - ah*tx + ah*0.6*Math.cos(t), ey - ah*ty + ah*0.6*Math.sin(t));
      ctx.closePath();
      ctx.fill();

      ctx.restore();

      // label
      ctx.fillStyle = "rgba(233,236,255,0.92)";
      ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(label, cx - ctx.measureText(label).width/2, cy + a + 16);
    }

    function ellipseParamsFromJones(E){
      // E = [Ex, Ey] complex normalized
      // Use real-time trajectory: Re{E e^{-i t}} = Re{E} cos t + Im{E} sin t
      // Build 2x2 matrix A such that r(t)=A [cos t; sin t]
      const Ex = E[0], Ey = E[1];
      const A = [
        [Ex.re, Ex.im],
        [Ey.re, Ey.im]
      ];
      // Compute covariance-like M = A A^T; eigenvalues -> a^2, b^2, eigenvectors -> axes direction
      const m00 = A[0][0]*A[0][0] + A[0][1]*A[0][1];
      const m01 = A[0][0]*A[1][0] + A[0][1]*A[1][1];
      const m11 = A[1][0]*A[1][0] + A[1][1]*A[1][1];

      // eigen decomposition of symmetric 2x2
      const tr = m00 + m11;
      const det = m00*m11 - m01*m01;
      const disc = Math.max(0, tr*tr/4 - det);
      const s = Math.sqrt(disc);
      const lam1 = tr/2 + s;
      const lam2 = tr/2 - s;

      // eigenvector for lam1
      let vx = m01;
      let vy = lam1 - m00;
      const n = Math.hypot(vx,vy);
      if(n < 1e-10){
        vx = 1; vy = 0;
      }else{
        vx /= n; vy /= n;
      }
      const angle = Math.atan2(vy, vx); // angle of major axis
      const a = Math.sqrt(Math.max(lam1,0));
      const b = Math.sqrt(Math.max(lam2,0));

      // rotation sense: sign of S3 ~ 2 Im(Ex Ey*)
      const s3 = 2*(Ex.re*Ey.im - Ex.im*Ey.re); // proportional to Stokes S3
      const sense = (s3 >= 0) ? +1 : -1;

      return {a, b, angle, sense};
    }

    // -----------------------------
    // Rendering all canvases
    // -----------------------------
    const canvDiagram = document.getElementById('cDiagram');
    const canvMain = document.getElementById('cMain');
    const canvSecond = document.getElementById('cSecond');

    const sliders = {
      psi: document.getElementById('psi'),
      chi: document.getElementById('chi'),
      tR: document.getElementById('tR'),
      tL: document.getElementById('tL'),
      rRatio: document.getElementById('rRatio')
    };
    const labels = {
      psiVal: document.getElementById('psiVal'),
      chiVal: document.getElementById('chiVal'),
      tRVal: document.getElementById('tRVal'),
      tLVal: document.getElementById('tLVal'),
      rVal: document.getElementById('rVal')
    };

    function readParams(){
      const psi = parseFloat(sliders.psi.value);
      const chi = parseFloat(sliders.chi.value);
      const tR = parseFloat(sliders.tR.value);
      const tL = parseFloat(sliders.tL.value);
      const r = parseFloat(sliders.rRatio.value);
      return {psi, chi, tR, tL, r};
    }

    function updateLabels(p){
      labels.psiVal.textContent = `${p.psi.toFixed(0)}°`;
      labels.chiVal.textContent = `${p.chi.toFixed(0)}°`;
      labels.tRVal.textContent = `${p.tR.toFixed(2)}`;
      labels.tLVal.textContent = `${p.tL.toFixed(2)}`;
      labels.rVal.textContent = `${p.r.toFixed(2)}`;
    }

    function drawDiagram(p){
      const {ctx,w,h} = setupHiDPICanvas(canvDiagram);
      drawPanelBackground(ctx,w,h);

      // Layout
      const margin = 14;
      const midY = h*0.54;
      const leftX = w*0.18;
      const blockX = w*0.52;
      const rightX = w*0.84;

      // Beam line
      ctx.strokeStyle = "rgba(233,236,255,0.25)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(margin, midY);
      ctx.lineTo(w-margin, midY);
      ctx.stroke();

      // Arrowheads
      function arrow(x1,y1,x2,y2){
        const ang = Math.atan2(y2-y1, x2-x1);
        const ah = 10;
        ctx.fillStyle = "rgba(233,236,255,0.55)";
        ctx.beginPath();
        ctx.moveTo(x2,y2);
        ctx.lineTo(x2 - ah*Math.cos(ang) + ah*0.5*Math.sin(ang), y2 - ah*Math.sin(ang) - ah*0.5*Math.cos(ang));
        ctx.lineTo(x2 - ah*Math.cos(ang) - ah*0.5*Math.sin(ang), y2 - ah*Math.sin(ang) + ah*0.5*Math.cos(ang));
        ctx.closePath();
        ctx.fill();
      }
      arrow(margin, midY, margin+60, midY);
      arrow(w-margin-60, midY, w-margin, midY);

      // Device block
      const bw = w*0.18, bh = h*0.30;
      const bx = blockX - bw/2, by = midY - bh/2;
      ctx.fillStyle = "rgba(167,139,250,0.10)";
      ctx.strokeStyle = "rgba(167,139,250,0.35)";
      ctx.lineWidth = 2;
      roundRect(ctx, bx, by, bw, bh, 16, true, true);

      ctx.fillStyle = "rgba(233,236,255,0.92)";
      ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Circular", bx + 12, by + 20);
      ctx.fillText("dichroic", bx + 12, by + 36);
      ctx.font = "600 11px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillStyle = "rgba(184,192,255,0.92)";
      ctx.fillText(`tR=${p.tR.toFixed(2)}, tL=${p.tL.toFixed(2)}`, bx + 12, by + 54);

      // Input ellipse based on psi/chi
      const Ein = jonesFromPsiChi(p.psi, p.chi);
      const eInParams = ellipseParamsFromJones(Ein);
      const scale = 38;
      drawPolarizationEllipse(ctx, leftX, midY-38, Math.max(10, eInParams.a*scale), Math.max(6, eInParams.b*scale), eInParams.angle, eInParams.sense, "Input");

      // Output ellipse based on applying device
      const out = applyCircularDichroism(Ein, p.tR, p.tL);
      // If output is very small, still show right-circular target
      const EoutN = (norm2(out.Eout) > 1e-8) ? normalizeJones(out.Eout) : ketR;
      const eOutParams = ellipseParamsFromJones(EoutN);
      drawPolarizationEllipse(ctx, rightX, midY-38, Math.max(10, eOutParams.a*scale), Math.max(6, eOutParams.b*scale), eOutParams.angle, eOutParams.sense, "Output");

      // Annotation: "→ |R⟩"
      ctx.fillStyle = "rgba(52,211,153,0.95)";
      ctx.font = "700 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      const tag = "Target: |R⟩";
      ctx.fillText(tag, rightX - ctx.measureText(tag).width/2, midY + 72);

      // Show purity estimate (how R-like is the output)
      const aR = inner(ketR, out.Eout);
      const aL = inner(ketL, out.Eout);
      const denom = cAbs2(aR)+cAbs2(aL);
      const purity = denom > 1e-12 ? (cAbs2(aR)/denom) : 1;
      ctx.fillStyle = "rgba(184,192,255,0.92)";
      ctx.font = "600 11px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(`Output R-power fraction ≈ ${purity.toFixed(3)}`, rightX - 80, midY + 92);

      // Caption-like axis indicator
      ctx.fillStyle = "rgba(184,192,255,0.85)";
      ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillText("+z propagation", w - margin - 110, margin + 16);
    }

    function normalizeJones(E){
      const n = Math.sqrt(norm2(E));
      if(n < 1e-12) return [C(0,0), C(0,0)];
      return [ C(E[0].re/n, E[0].im/n), C(E[1].re/n, E[1].im/n) ];
    }

    function roundRect(ctx, x, y, w, h, r, fill, stroke){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
      if(fill) ctx.fill();
      if(stroke) ctx.stroke();
    }

    function drawMainPlot(p){
      const {ctx,w,h} = setupHiDPICanvas(canvMain);
      drawPanelBackground(ctx,w,h);

      const box = {x:0,y:0,w,h,padL:54,padR:14,padT:34,padB:40};

      // Sweep chi
      const xMin = -45, xMax = 45;
      const yMin = 0, yMax = 1.05;

      const map = drawAxes(
        ctx, box, xMin, xMax, yMin, yMax,
        "Ellipticity χ (deg)", "I_out / I_in (unitless)",
        "Transmitted intensity vs ellipticity (ψ fixed)"
      );

      const xs = [];
      const ysIdeal = [];
      const ysActual = [];

      for(let chi = xMin; chi <= xMax; chi += 1){
        const Ein = jonesFromPsiChi(p.psi, chi);
        xs.push(chi);

        // ideal curve (tL=0, tR as selected)
        ysIdeal.push(intensityFraction(Ein, p.tR, 0));

        // actual curve with selected tL
        ysActual.push(intensityFraction(Ein, p.tR, p.tL));
      }

      // Curves
      drawCurve(ctx, map, xs, ysIdeal, "rgba(125,211,252,0.95)");
      drawCurve(ctx, map, xs, ysActual, "rgba(167,139,250,0.95)");

      // Marker at current chi
      const EinNow = jonesFromPsiChi(p.psi, p.chi);
      const yNowIdeal = intensityFraction(EinNow, p.tR, 0);
      const yNowActual = intensityFraction(EinNow, p.tR, p.tL);
      drawMarker(ctx, map, p.chi, yNowIdeal, "rgba(125,211,252,0.95)");
      drawMarker(ctx, map, p.chi, yNowActual, "rgba(167,139,250,0.95)");

      // Legend
      const lx = map.px0 + 10;
      const ly = map.py0 + 10;
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      roundRect(ctx, lx-6, ly-8, 260, 52, 12, true, false);
      ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillStyle = "rgba(233,236,255,0.92)";
      ctx.fillText("Legend", lx, ly+8);

      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillStyle = "rgba(125,211,252,0.95)";
      ctx.fillText("Ideal (tL=0)", lx, ly+28);
      ctx.fillStyle = "rgba(167,139,250,0.95)";
      ctx.fillText("Selected (tL slider)", lx+120, ly+28);

      // Annotation text
      ctx.fillStyle = "rgba(184,192,255,0.92)";
      ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      const note = `ψ = ${p.psi.toFixed(0)}°,  tR=${p.tR.toFixed(2)},  tL=${p.tL.toFixed(2)}`;
      ctx.fillText(note, map.px0 + 10, map.py0 + map.ph - 10);
    }

    function drawSecondaryPlot(p){
      const {ctx,w,h} = setupHiDPICanvas(canvSecond);
      drawPanelBackground(ctx,w,h);

      const box = {x:0,y:0,w,h,padL:54,padR:14,padT:34,padB:40};

      const xMin = -Math.PI, xMax = Math.PI;
      const yMin = 0, yMax = 1.05;

      const map = drawAxes(
        ctx, box, xMin, xMax, yMin, yMax,
        "Relative phase δ (rad)", "I_out / I_in (unitless)",
        "Transmitted intensity vs phase δ (ratio r fixed)"
      );

      const xs = [];
      const ysIdeal = [];
      const ysActual = [];

      const n = 240;
      for(let i=0;i<=n;i++){
        const delta = xMin + (xMax-xMin)*(i/n);
        const Ein = jonesFromRatioPhase(p.r, delta);
        xs.push(delta);
        ysIdeal.push(intensityFraction(Ein, p.tR, 0));
        ysActual.push(intensityFraction(Ein, p.tR, p.tL));
      }

      drawCurve(ctx, map, xs, ysIdeal, "rgba(125,211,252,0.95)");
      drawCurve(ctx, map, xs, ysActual, "rgba(167,139,250,0.95)");

      // Marker at delta = +pi/2 (a canonical circular/linear relation)
      const deltaMark = Math.PI/2;
      const EinMark = jonesFromRatioPhase(p.r, deltaMark);
      drawMarker(ctx, map, deltaMark, intensityFraction(EinMark, p.tR, 0), "rgba(125,211,252,0.95)");
      drawMarker(ctx, map, deltaMark, intensityFraction(EinMark, p.tR, p.tL), "rgba(167,139,250,0.95)");

      // Legend / parameters
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      roundRect(ctx, map.px0 + 10, map.py0 + 10, 360, 58, 12, true, false);

      ctx.fillStyle = "rgba(233,236,255,0.92)";
      ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Parameters", map.px0 + 20, map.py0 + 28);

      ctx.fillStyle = "rgba(184,192,255,0.92)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillText(`r = ${p.r.toFixed(2)},  tR=${p.tR.toFixed(2)},  tL=${p.tL.toFixed(2)}`, map.px0 + 20, map.py0 + 48);

      // Helpful x tick labels -π, -π/2, 0, π/2, π
      drawPiLabels(ctx, map, yMin, yMax);
    }

    function drawPiLabels(ctx, map, yMin, yMax){
      const y = yMin; // place near bottom axis (already has ticks, this is extra contextual labeling)
      const specials = [
        {MathPI:true}
      ];
      // We'll add textual annotations at top right of plot area instead (cleaner)
      const x0 = map.px0 + map.pw - 180;
      const y0 = map.py0 + 20;
      ctx.fillStyle = "rgba(184,192,255,0.85)";
      ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Reference phases:", x0, y0);
      ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillText("−π, −π/2, 0, +π/2, +π", x0, y0+16);
    }

    function renderAll(){
      const p = readParams();
      updateLabels(p);
      drawDiagram(p);
      drawMainPlot(p);
      drawSecondaryPlot(p);
    }

    // Hook up controls
    Object.values(sliders).forEach(s=>{
      s.addEventListener('input', renderAll);
    });

    // Re-render on resize (responsive + high-DPI)
    let resizeTimer = null;
    window.addEventListener('resize', ()=>{
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(renderAll, 80);
    });

    // Initial render
    renderAll();
  </script>
</body>
</html>
