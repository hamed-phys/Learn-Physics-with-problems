<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>6.1-11 Anti-Glare Screen (Polarizer + Quarter-Wave Plate at 45°)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --card:#111c3a;
      --text:#e9eefc;
      --muted:#b9c4e6;
      --faint:rgba(233,238,252,.08);
      --fainter:rgba(233,238,252,.05);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --max: 1100px;
    }

    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1100px 700px at 15% 5%, rgba(125,211,252,.10), transparent 55%),
        radial-gradient(900px 600px at 90% 10%, rgba(167,139,250,.10), transparent 55%),
        radial-gradient(900px 700px at 50% 95%, rgba(52,211,153,.08), transparent 60%),
        linear-gradient(180deg, #070a14, var(--bg));
      line-height:1.55;
    }

    a{color:var(--accent)}
    header{
      position:relative;
      padding:42px 18px 22px;
      overflow:hidden;
    }
    .wrap{max-width:var(--max); margin:0 auto;}
    .hero{
      display:grid;
      grid-template-columns: 1.35fr .65fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 920px){
      .hero{grid-template-columns:1fr}
    }

    .titleCard{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--faint);
      border-radius: var(--radius);
      padding:18px 18px 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }
    h1{
      margin:0 0 8px;
      font-size: clamp(22px, 3.2vw, 34px);
      letter-spacing:.2px;
      line-height:1.15;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size: 14px;
      max-width: 72ch;
    }

    .toc{
      position:sticky;
      top:12px;
      align-self:start;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--faint);
      border-radius: var(--radius);
      padding:14px 14px 10px;
      box-shadow: var(--shadow);
    }
    .toc h2{
      margin:0 0 8px;
      font-size:14px;
      letter-spacing:.4px;
      text-transform:uppercase;
      color:var(--muted);
    }
    .toc a{
      display:block;
      text-decoration:none;
      padding:6px 8px;
      border-radius:12px;
      color:var(--text);
      font-size:13px;
      border:1px solid transparent;
    }
    .toc a:hover{
      background: rgba(125,211,252,.08);
      border-color: rgba(125,211,252,.18);
    }

    main{padding: 10px 18px 56px;}
    section{
      margin: 18px 0;
      padding: 0;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:16px;
    }
    @media (max-width: 860px){
      .grid2{grid-template-columns:1fr}
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.055), rgba(255,255,255,.02));
      border:1px solid var(--faint);
      border-radius: var(--radius);
      padding:16px 16px 12px;
      box-shadow: var(--shadow);
    }
    .card h3{
      margin:0 0 10px;
      font-size:16px;
      color: #f3f6ff;
    }
    .card p, .card li{color:var(--muted)}
    .card ul{margin:10px 0 0 18px}
    .kicker{
      display:inline-flex;
      gap:8px;
      align-items:center;
      font-size:12px;
      letter-spacing:.35px;
      text-transform:uppercase;
      color:var(--muted);
      margin-bottom:10px;
    }
    .pill{
      display:inline-block;
      padding:3px 10px;
      border-radius:999px;
      border:1px solid var(--faint);
      background: rgba(255,255,255,.03);
      color:var(--text);
      font-size:12px;
    }

    .callouts{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:16px;
      margin-top:16px;
    }
    @media (max-width: 900px){
      .callouts{grid-template-columns:1fr}
    }
    .callout{
      border-radius: var(--radius);
      border:1px solid var(--faint);
      padding:14px 14px 12px;
      background: rgba(255,255,255,.03);
    }
    .callout strong{color:#fff}
    .assump{border-left:4px solid var(--warn)}
    .keyeq{border-left:4px solid var(--accent)}
    .mist{border-left:4px solid var(--bad)}
    .final{border-left:4px solid var(--good)}

    .eq{
      font-family: var(--mono);
      font-size: 13px;
      background: rgba(0,0,0,.25);
      border:1px solid var(--faint);
      border-radius: 14px;
      padding:10px 10px;
      overflow:auto;
      position:relative;
      margin:10px 0 6px;
      white-space: pre;
    }
    .eqRow{
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content: space-between;
      flex-wrap:wrap;
    }
    .copyBtn{
      appearance:none;
      border:1px solid rgba(125,211,252,.28);
      background: rgba(125,211,252,.10);
      color: var(--text);
      border-radius: 999px;
      padding:6px 10px;
      font-size:12px;
      cursor:pointer;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
      user-select:none;
    }
    .copyBtn:hover{background: rgba(125,211,252,.14); border-color: rgba(125,211,252,.42)}
    .copyBtn:active{transform: translateY(1px) scale(.99)}
    .copyNote{
      font-size:12px;
      color: var(--muted);
      margin:0 0 6px;
    }

    .viz{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:16px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .viz{grid-template-columns:1fr}
    }
    figure{
      margin:0;
      padding:0;
    }
    figcaption{
      margin-top:8px;
      color:var(--muted);
      font-size:12px;
    }
    canvas{
      width:100%;
      height:360px;
      display:block;
      border-radius: var(--radius);
      border:1px solid var(--faint);
      background: rgba(0,0,0,.18);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }
    .small canvas{height:320px}
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
      margin-top:12px;
    }
    @media (max-width: 980px){
      .controls{grid-template-columns:1fr}
    }
    .ctl{
      border:1px solid var(--faint);
      border-radius: var(--radius);
      padding:12px 12px 10px;
      background: rgba(255,255,255,.03);
    }
    .ctl label{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:12px;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.3px;
      margin-bottom:8px;
    }
    input[type="range"]{width:100%}
    .val{
      font-family: var(--mono);
      color: var(--text);
      font-size:12px;
      white-space:nowrap;
    }
    .btnRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .ghost{
      border:1px solid var(--faint);
      background: rgba(255,255,255,.02);
    }

    .divider{
      height:1px;
      background: linear-gradient(90deg, transparent, rgba(233,238,252,.18), transparent);
      margin: 18px 0;
    }

    footer{
      padding: 18px;
      color: var(--muted);
      font-size: 12px;
    }

    /* subtle entrance */
    @media (prefers-reduced-motion: no-preference){
      .card, .titleCard, .toc{
        animation: fadeUp .55s ease both;
      }
      .card:nth-child(2){animation-delay:.03s}
      .card:nth-child(3){animation-delay:.06s}
      @keyframes fadeUp{
        from{opacity:0; transform: translateY(8px)}
        to{opacity:1; transform: translateY(0)}
      }
    }

    /* print friendly */
    @media print{
      body{background:#fff; color:#000}
      .toc{display:none}
      .titleCard, .card, .callout{box-shadow:none}
      canvas{border:1px solid #999; background:#fff}
      .copyBtn, .btnRow{display:none}
      .eq{background:#fff; color:#000}
      a{color:#000; text-decoration:underline}
    }
  </style>
</head>
<body>
<header>
  <div class="wrap hero">
    <div class="titleCard">
      <div class="kicker">
        <span class="pill">Photonics • Polarization</span>
        <span class="pill">Jones Calculus</span>
        <span class="pill">Anti-glare design</span>
      </div>
      <h1>Anti-Glare Screen: Why a Linear Polarizer + Quarter-Wave Plate at 45° Kills Window Glare</h1>
      <p class="subtitle">
        Problem 6.1-11: A self-luminous object is viewed through a glass window. Show that glare from reflected background light can be eliminated using a screen built from a linear polarizer and a quarter-wave retarder whose axes are at 45° to the polarizer transmission axis. Then decide whether the screen is an optical isolator.
      </p>
    </div>

    <nav class="toc" aria-label="Table of contents">
      <h2>Contents</h2>
      <a href="#quick">Quick Summary</a>
      <a href="#p0">Part 0 — Concept Primer</a>
      <a href="#p1">Part 1 — Problem Analysis</a>
      <a href="#p2">Part 2 — Strategy & Tips</a>
      <a href="#p3">Part 3 — Full Solution</a>
      <a href="#p4">Part 4 — Deeper Understanding</a>
      <a href="#p5">Part 5 — Visualization Guide</a>
      <a href="#viz">Interactive Visualizations</a>
    </nav>
  </div>
</header>

<main>
  <div class="wrap">

    <section id="quick" class="card">
      <h3>Quick Summary</h3>
      <ul>
        <li><strong>What this is about:</strong> suppressing <em>back-reflected</em> background light (“glare”) when looking through a window.</li>
        <li><strong>Key physics idea:</strong> make the forward-going background light <em>circular</em>, so the reflected light returns with <em>orthogonal linear polarization</em> and gets blocked.</li>
        <li><strong>Device:</strong> <strong>linear polarizer</strong> + <strong>quarter-wave plate (QWP)</strong> with QWP axes at <strong>45°</strong> to the polarizer axis (a “circular polarizer”).</li>
        <li><strong>Governing tool:</strong> <strong>Jones matrices</strong> for polarizer, retarder, and mirror reflection.</li>
        <li><strong>Core result (ideal):</strong> a single pass transmits the desired view; a double pass (go to window → reflect → return) rotates polarization by <strong>90°</strong>, so the polarizer blocks it → <strong>glare ≈ 0</strong>.</li>
        <li><strong>Robustness:</strong> imperfect retardance (δ ≠ π/2) or misalignment (θ ≠ 45°) leaks some glare—see plots.</li>
        <li><strong>Is it an optical isolator?</strong> <strong>No (not in the strict sense)</strong> because it is <em>reciprocal</em>; it suppresses a specific back-reflection mechanism but is not a non-reciprocal Faraday isolator.</li>
      </ul>
    </section>

    <section id="p0" class="card">
      <h3>PART 0 — Concept Primer (Theory Before Solving)</h3>

      <div class="grid2">
        <div>
          <p>
            <strong>Polarization state</strong> describes how the electric field vector <em>E</em> oscillates transverse to propagation.
            For monochromatic light we write a complex field vector (Jones vector):
          </p>
          <div class="eqRow">
            <div class="eq" data-copy="E = [Ex; Ey],  Ex,Ey complex amplitudes (relative units)">
E = [Ex; Ey],  Ex,Ey complex amplitudes (relative units)</div>
            <button class="copyBtn" data-copy-btn>Copy</button>
          </div>
          <p class="copyNote">We use relative units for field; intensity is proportional to |E|².</p>

          <p><strong>Core definitions</strong></p>
          <ul>
            <li><strong>Linear polarizer:</strong> transmits one linear component (its transmission axis). Ideal polarizer removes the orthogonal component.</li>
            <li><strong>Retarder (wave plate):</strong> introduces a <strong>phase delay</strong> δ (radians) between components along its principal axes (fast/slow).</li>
            <li><strong>Quarter-wave plate (QWP):</strong> δ = π/2 at the design wavelength → converts linear ↔ circular when oriented at 45° to the linear polarization.</li>
          </ul>

          <p><strong>Physical meaning</strong></p>
          <ul>
            <li>Polarizer = “amplitude filter in polarization space.”</li>
            <li>Retarder = “relative phase shifter,” changing ellipse shape without (ideally) absorbing power.</li>
            <li>Mirror/window reflection can flip the handedness of circular polarization (a key step here).</li>
          </ul>
        </div>

        <div>
          <div class="callout keyeq">
            <strong>Key laws/principles (validity conditions)</strong>
            <ul>
              <li><strong>Jones calculus</strong> applies to fully coherent, monochromatic light and deterministic optical elements (no depolarization).</li>
              <li>We assume <strong>near-normal incidence</strong> and treat the window reflection like a mirror in polarization behavior (good for illustrating the mechanism).</li>
              <li>We assume <strong>ideal polarizer</strong> and <strong>lossless retarder</strong> for the main proof; imperfections are explored with plots.</li>
            </ul>
          </div>

          <div class="callout">
            <strong>Common models/approximations</strong>
            <ul>
              <li><strong>Unpolarized background light</strong> → polarizer transmits ~50% before the wave plate.</li>
              <li><strong>Ideal QWP</strong> gives δ = π/2 exactly at the design wavelength; off-wavelength δ differs → imperfect cancellation.</li>
              <li>Window reflection treated as a <strong>mirror</strong> that flips one transverse component’s sign (equivalent to handedness reversal for circular states).</li>
            </ul>
          </div>

          <div class="callout mist">
            <strong>What to watch for (pitfalls)</strong>
            <ul>
              <li><strong>Order matters:</strong> polarizer → QWP (toward window) is the usual anti-glare “circular polarizer.”</li>
              <li><strong>45° is essential:</strong> QWP axes must be at 45° to the polarizer axis to make circular polarization.</li>
              <li><strong>Optical isolator confusion:</strong> this device blocks <em>reflections</em> but remains <em>reciprocal</em> (unlike Faraday isolators).</li>
            </ul>
          </div>

          <div class="callout">
            <strong>Mini intuition examples</strong>
            <ul>
              <li>If linearly polarized light enters a QWP at 45°, the two equal components pick up a π/2 phase difference → the tip of E traces a circle.</li>
              <li>A reflection reverses circular handedness; passing back through the same QWP converts it into linear polarization rotated by 90°.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section id="p1" class="card">
      <h3>PART 1 — Problem Analysis (No Solving Yet)</h3>

      <p><strong>Restated problem (in plain words):</strong><br/>
        You’re looking at a bright object through a glass window. Ambient/background light on your side reflects off the window surfaces and creates glare.
        We want a screen in front of the window that <em>prevents reflected background light from reaching your eye</em> while still letting you see the object.
        Show that a linear polarizer plus a QWP with axes at 45° to the polarizer’s axis achieves this, and decide if it counts as an optical isolator.
      </p>

      <div class="grid2">
        <div>
          <p><strong>Given</strong></p>
          <ul>
            <li>Glass window causing partial reflection from its surfaces.</li>
            <li>Background light (generally unpolarized) incident from the observer side.</li>
            <li>We may choose a screen built from polarization elements.</li>
          </ul>

          <p><strong>Unknowns / What must be shown</strong></p>
          <ul>
            <li>Prove that <strong>polarizer + QWP at 45°</strong> can eliminate glare from reflected background light.</li>
            <li>Explain whether the screen can be regarded as an <strong>optical isolator</strong>.</li>
          </ul>
        </div>

        <div>
          <p><strong>Relevant physical principles (and why they apply)</strong></p>
          <ul>
            <li><strong>Polarization transformation</strong> through linear optical elements → described cleanly by Jones matrices.</li>
            <li><strong>Double-pass behavior</strong> (forward to window, then back after reflection) is the key: the returning polarization can be made orthogonal to the polarizer axis.</li>
          </ul>

          <p><strong>Why other ideas are less direct</strong></p>
          <ul>
            <li>Anti-reflection coatings reduce reflection but require coating design; the problem specifically hints a polarization solution.</li>
            <li>Geometric blocking (baffles) doesn’t address reflection from the window surface itself.</li>
          </ul>
        </div>
      </div>

      <div class="callouts">
        <div class="callout assump">
          <strong>Assumptions (explicit)</strong>
          <ul>
            <li>Monochromatic or narrowband enough that the QWP retardance is approximately constant (δ ≈ π/2 at design λ).</li>
            <li>Near-normal incidence so we can use a simple reflection model without strong s/p mixing.</li>
            <li>Ideal polarizer (perfect extinction) and lossless retarder for the main proof; later we vary δ and misalignment to show leakage.</li>
          </ul>
        </div>
        <div class="callout">
          <strong>Possible approaches (choose & compare)</strong>
          <ul>
            <li><strong>Jones calculus (best):</strong> compact, exact for ideal elements; clearly shows 90° rotation on double pass.</li>
            <li><strong>Geometric polarization ellipse reasoning:</strong> intuitive, but can be hand-wavy without algebra.</li>
            <li><strong>Stokes/Mueller calculus:</strong> handles unpolarized light rigorously, but heavier than necessary for the “show that” proof.</li>
          </ul>
          <p style="margin:8px 0 0;color:var(--muted)"><strong>Chosen:</strong> Jones calculus + a short unpolarized-light interpretation.</p>
        </div>
      </div>
    </section>

    <section id="p2" class="card">
      <h3>PART 2 — Strategy & Tips (Roadmap Only)</h3>

      <ol style="margin:10px 0 0 18px; color:var(--muted)">
        <li><strong>Set axes:</strong> let the polarizer transmission axis be x. (Tool: coordinate definition.) Meaning: “passed” polarization is x-linear.</li>
        <li><strong>Write Jones matrices:</strong> polarizer P and QWP Q(θ,δ). (Tool: Jones calculus.) Meaning: map input field → output field.</li>
        <li><strong>Model reflection:</strong> use a simple mirror matrix M that flips one transverse component’s sign. Meaning: captures handedness reversal for circular polarization.</li>
        <li><strong>Propagate background light forward:</strong> after polarizer it becomes x-linear; after QWP at 45° it becomes circular. Meaning: equal components with ±π/2 phase shift.</li>
        <li><strong>Double pass:</strong> apply Q → M → Q to that field and show it becomes y-linear when δ=π/2 and θ=45°. Meaning: a 90° rotation in linear polarization.</li>
        <li><strong>Final blocking:</strong> apply the polarizer again (on the return) and show transmitted amplitude is zero. Meaning: glare suppressed.</li>
        <li><strong>Isolator question:</strong> discuss reciprocity: replace QWP with Faraday rotator to get true isolator; explain why QWP device is not nonreciprocal.</li>
        <li><strong>Check robustness:</strong> show how errors (δ≠π/2, θ≠45°) leak glare (plots).</li>
      </ol>

      <div class="callouts">
        <div class="callout mist">
          <strong>Common mistakes</strong>
          <ul>
            <li>Using a half-wave plate instead of a quarter-wave plate (won’t produce circular on the first pass).</li>
            <li>Setting the QWP axis parallel to the polarizer axis (no equal components → no circular state).</li>
            <li>Calling it an isolator without noting it’s reciprocal (the key distinction).</li>
          </ul>
        </div>
        <div class="callout">
          <strong>Quick tips</strong>
          <ul>
            <li>At θ=45°, the QWP “splits” x-linear into equal fast/slow components.</li>
            <li>Think: <em>linear → circular → (reflect flips handedness) → linear rotated by 90°</em>.</li>
            <li>If your algebra gets messy, plug θ=45° and δ=π/2 early for the main proof.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="p3" class="card">
      <h3>PART 3 — Full Solution (Detailed + Teaching)</h3>

      <p><strong>Qualitative expectation (before calculating):</strong><br/>
        We want the background light that reflects off the window to be “rejected” by the screen.
        A linear polarizer alone cannot do that: reflected light would come back with the same linear polarization and pass again.
        The trick is to insert a QWP so the forward-going light becomes circular; upon reflection its handedness flips; on returning through the same QWP it becomes linear but rotated by 90°, so the original polarizer blocks it.
      </p>

      <div class="divider"></div>

      <article>
        <h3 style="margin-top:0">Step 1 — Define axes and the polarizer</h3>
        <p>
          Let the polarizer transmission axis be the <strong>x-axis</strong>. In the (x,y) basis, the ideal polarizer Jones matrix is:
        </p>
        <div class="eqRow">
          <div class="eq" data-copy="P = [[1,0],[0,0]]   (passes x, blocks y)">
P = [[1,0],[0,0]]   (passes x, blocks y)</div>
          <button class="copyBtn" data-copy-btn>Copy</button>
        </div>
        <p class="copyNote">All fields below are Jones vectors in the (x,y) basis.</p>
      </article>

      <article>
        <h3>Step 2 — Quarter-wave plate at 45°</h3>
        <p>
          A linear retarder with retardance δ and its fast axis at angle θ to x has Jones matrix:
        </p>
        <div class="eqRow">
          <div class="eq" data-copy="Q(θ,δ) = R(-θ) · [[1,0],[0, e^{iδ}]] · R(θ),  R(θ)=[[cosθ,-sinθ],[sinθ,cosθ]]">
Q(θ,δ) = R(-θ) · [[1,0],[0, e^{iδ}]] · R(θ),
R(θ)=[[cosθ,-sinθ],[sinθ,cosθ]]</div>
          <button class="copyBtn" data-copy-btn>Copy</button>
        </div>

        <p>
          For an ideal quarter-wave plate, δ = π/2. The problem specifies its axes are at <strong>45°</strong> with respect to the polarizer axis, so:
          <strong>θ = 45° = π/4</strong>.
        </p>

        <p>
          If we plug θ=π/4 and δ=π/2, the QWP matrix becomes (up to a global phase):
        </p>
        <div class="eqRow">
          <div class="eq" data-copy="Q(π/4, π/2) = (1/2) * [[1+i, 1-i],[1-i, 1+i]]">
Q(π/4, π/2) = (1/2) * [[1+i, 1-i],
                       [1-i, 1+i]]</div>
          <button class="copyBtn" data-copy-btn>Copy</button>
        </div>
        <p class="copyNote">A global phase does not affect intensity; we keep a convenient form.</p>
      </article>

      <article>
        <h3>Step 3 — Model the window reflection</h3>
        <p>
          For near-normal reflection from a surface, it is convenient to represent reflection as a “mirror” that flips one transverse component’s sign
          (this captures the handedness reversal of circular polarization). A simple Jones matrix model is:
        </p>
        <div class="eqRow">
          <div class="eq" data-copy="M = [[1,0],[0,-1]]   (simple mirror model at normal incidence)">
M = [[1,0],[0,-1]]   (simple mirror model at normal incidence)</div>
          <button class="copyBtn" data-copy-btn>Copy</button>
        </div>
        <p class="copyNote">Any overall minus sign is physically irrelevant (global phase).</p>
      </article>

      <div class="divider"></div>

      <article>
        <h3>Step 4 — Track a glare ray: forward → reflect → backward</h3>
        <p>
          Background light on the observer side is typically unpolarized. After passing through the polarizer, whatever arrives at the QWP is <strong>x-linear</strong>.
          So we may take the post-polarizer field as:
        </p>
        <div class="eqRow">
          <div class="eq" data-copy="E0 = [1, 0]^T   (x-linear after the polarizer; normalized)">
E0 = [1, 0]^T   (x-linear after the polarizer; normalized)</div>
          <button class="copyBtn" data-copy-btn>Copy</button>
        </div>

        <h3>Step 4a — After the QWP (θ=45°, δ=π/2)</h3>
        <p>Apply the QWP matrix:</p>
        <div class="eqRow">
          <div class="eq" data-copy="E1 = Q(π/4, π/2) E0 = (1/2)[1+i, 1-i]^T">
E1 = Q(π/4, π/2) E0
   = (1/2) [1+i,
            1-i]^T</div>
          <button class="copyBtn" data-copy-btn>Copy</button>
        </div>
        <p>
          Notice the x and y components have equal magnitude and a ±π/2 phase difference. That is <strong>circular polarization</strong>
          (right- or left-handed depending on convention).
        </p>

        <h3>Step 4b — Reflection at the window surface</h3>
        <p>Reflect with M:</p>
        <div class="eqRow">
          <div class="eq" data-copy="E2 = M E1 = (1/2)[1+i, -(1-i)]^T = (1/2)[1+i, -1+i]^T">
E2 = M E1
   = (1/2) [1+i,
            -(1-i)]^T
   = (1/2) [1+i,
            -1+i]^T</div>
          <button class="copyBtn" data-copy-btn>Copy</button>
        </div>
        <p>
          Physically, this step flips the handedness of the circular polarization.
        </p>

        <h3>Step 4c — Back through the same QWP</h3>
        <p>Apply QWP again (double-pass through the retarder):</p>
        <div class="eqRow">
          <div class="eq" data-copy="E3 = Q(π/4, π/2) E2 = i[0, 1]^T   (up to global phase)">
E3 = Q(π/4, π/2) E2
   = i [0,
        1]^T   (up to global phase)</div>
          <button class="copyBtn" data-copy-btn>Copy</button>
        </div>
        <p>
          The returned field is purely <strong>y-linear</strong>, i.e. rotated by <strong>90°</strong> relative to the polarizer axis.
          This is the crucial effect: <strong>reflection + QWP double pass rotates linear polarization by 90°</strong>.
        </p>

        <h3>Step 4d — Return through the polarizer: glare rejection</h3>
        <p>Finally, the light must pass the polarizer again on its way to the observer:</p>
        <div class="eqRow">
          <div class="eq" data-copy="Eout = P E3 = [[1,0],[0,0]] [0,1]^T = [0,0]^T  ⇒  I_glare = 0">
Eout = P E3
     = [[1,0],[0,0]] [0,1]^T
     = [0,0]^T

⇒  I_glare = 0  (ideal case)</div>
          <button class="copyBtn" data-copy-btn>Copy</button>
        </div>
      </article>

      <div class="callouts">
        <div class="callout final">
          <strong>Final answer (what you proved)</strong>
          <div class="eqRow">
            <div class="eq" data-copy="A linear polarizer followed by a quarter-wave plate with its axes at 45° to the polarizer makes the forward-going glare light circular. After reflection, the handedness flips; passing back through the same QWP converts it to linear polarization orthogonal to the polarizer axis, so the polarizer blocks it (ideal I_glare = 0).">
A linear polarizer + QWP at 45° (a circular polarizer) makes forward glare light circular.
Reflection flips handedness; the return through the QWP becomes linear and rotated by 90°,
so the polarizer blocks it (ideal: I_glare = 0).</div>
            <button class="copyBtn" data-copy-btn>Copy</button>
          </div>
        </div>

        <div class="callout keyeq">
          <strong>Sanity checks</strong>
          <ul>
            <li><strong>Units:</strong> Jones matrices are dimensionless; intensity ratios are dimensionless.</li>
            <li><strong>Limiting case:</strong> If δ→0 (no retardance), Q→I and the return polarization is unchanged → glare is <em>not</em> rejected (plots show leakage → large).</li>
            <li><strong>Geometry/interpretation:</strong> “linear → circular → (reflect) → opposite circular → linear orthogonal.”</li>
          </ul>
        </div>
      </div>

      <div class="divider"></div>

      <article>
        <h3>Is the screen an optical isolator?</h3>
        <p>
          <strong>Not in the strict sense.</strong> A true optical isolator is a <strong>non-reciprocal</strong> device: it transmits in one direction but strongly attenuates in the reverse direction for the <em>same input polarization state</em>.
          Non-reciprocity typically requires a <strong>Faraday rotator</strong> (magneto-optic effect) that rotates polarization in the <em>same</em> direction for both propagation directions.
        </p>
        <p>
          The polarizer+QWP anti-glare screen is built from <strong>reciprocal</strong> elements (a linear polarizer and a birefringent retarder).
          It suppresses <em>reflections from a surface behind it</em> because the reflection flips circular handedness, causing a 90° rotation upon return.
          But it does <strong>not</strong> provide general one-way transmission like a Faraday isolator; its behavior depends on the reflection/double-pass geometry.
        </p>
      </article>
    </section>

    <section id="viz" class="card">
      <h3>Interactive Visualizations</h3>
      <p style="color:var(--muted); margin-top:0">
        These plots use the same symbols as the solution: QWP retardance <strong>δ</strong> and axis angle <strong>θ</strong> relative to the polarizer axis.
        We define a misalignment <strong>ε = θ − 45°</strong>.
        The plotted quantity is the <strong>normalized glare leakage</strong>:
        <span style="font-family:var(--mono)">T_glare = I_return_after_polarizer / I_after_first_polarizer</span>.
        Ideal cancellation corresponds to <strong>T_glare = 0</strong>.
      </p>

      <div class="controls" aria-label="Interactive controls">
        <div class="ctl">
          <label>
            QWP retardance δ (degrees)
            <span class="val" id="deltaVal">90.0°</span>
          </label>
          <input id="delta" type="range" min="0" max="180" step="0.1" value="90"/>
          <div class="btnRow">
            <button class="copyBtn ghost" id="btnIdeal">Set ideal (δ=90°, ε=0°)</button>
            <button class="copyBtn ghost" id="btnBad">Show failure (δ=0°, ε=0°)</button>
          </div>
        </div>

        <div class="ctl">
          <label>
            Axis misalignment ε = θ − 45° (degrees)
            <span class="val" id="epsVal">0.0°</span>
          </label>
          <input id="eps" type="range" min="-15" max="15" step="0.1" value="0"/>
          <p class="copyNote" style="margin:8px 0 0">
            ε=0 means QWP axes are exactly at 45° to the polarizer axis.
          </p>
        </div>

        <div class="ctl">
          <label>
            Reflection model
            <span class="val" id="modelVal">Mirror flip (M=diag(1,-1))</span>
          </label>
          <select id="model" style="width:100%; padding:9px 10px; border-radius:14px; border:1px solid var(--faint); background:rgba(0,0,0,.18); color:var(--text);">
            <option value="flip" selected>Mirror flip: M = diag(1, -1)</option>
            <option value="global">Global phase only: M = -I (no handedness flip)</option>
          </select>
          <p class="copyNote" style="margin:8px 0 0">
            The “flip” model produces the handedness reversal needed for anti-glare.
            The “global phase only” model demonstrates why some reflections would not be rejected if handedness does not effectively change.
          </p>
        </div>
      </div>

      <div class="viz" style="margin-top:14px">
        <figure>
          <canvas id="setup"></canvas>
          <figcaption>
            <strong>Diagram:</strong> object light comes from behind the window; background glare light comes from the observer side,
            reflects at the window, returns through the screen, and (ideally) is blocked.
          </figcaption>
        </figure>

        <figure>
          <canvas id="plot1"></canvas>
          <figcaption>
            <strong>Main plot:</strong> normalized glare leakage <span style="font-family:var(--mono)">T_glare(δ)</span> at the chosen misalignment ε.
            The ideal design occurs near δ=90° and ε=0°.
          </figcaption>
        </figure>
      </div>

      <div class="viz small" style="margin-top:16px">
        <figure>
          <canvas id="plot2"></canvas>
          <figcaption>
            <strong>Secondary plot:</strong> leakage <span style="font-family:var(--mono)">T_glare(ε)</span> at the chosen retardance δ.
            Shows sensitivity to axis alignment.
          </figcaption>
        </figure>

        <figure>
          <canvas id="plot3"></canvas>
          <figcaption>
            <strong>Parameter sweep:</strong> a compact 2D heatmap of <span style="font-family:var(--mono)">T_glare(δ, ε)</span> (example range).
            Dark/low values mean good glare rejection.
          </figcaption>
        </figure>
      </div>
    </section>

    <section id="p4" class="card">
      <h3>PART 4 — Deeper Understanding (Theory Around the Result)</h3>

      <div class="grid2">
        <div>
          <p><strong>Re-interpreting the mechanism</strong></p>
          <ul>
            <li>The polarizer ensures the forward-going “glare ray” starts as a known linear state.</li>
            <li>The QWP at 45° makes that state <strong>circular</strong> (equal components, ±π/2 phase difference).</li>
            <li>Reflection flips circular handedness; the return through the QWP converts it to <strong>orthogonal linear</strong>.</li>
            <li>The same polarizer now blocks the return → glare suppression.</li>
          </ul>

          <div class="callout keyeq">
            <strong>Key takeaway formula (conceptual)</strong>
            <div class="eqRow">
              <div class="eq" data-copy="(Polarizer → QWP@45°) makes circular; reflection flips handedness; (QWP@45° → Polarizer) makes linear orthogonal ⇒ return blocked.">
(Polarizer → QWP@45°) makes circular
reflection flips handedness
(QWP@45° → Polarizer) makes linear orthogonal
⇒ return blocked</div>
              <button class="copyBtn" data-copy-btn>Copy</button>
            </div>
          </div>
        </div>

        <div>
          <p><strong>How parameters affect performance (connect to plots)</strong></p>
          <ul>
            <li><strong>Retardance δ:</strong> If δ ≠ 90°, the polarization after QWP is not perfectly circular → return is not perfectly orthogonal → leakage increases.</li>
            <li><strong>Axis error ε:</strong> If θ ≠ 45°, the QWP does not split the linear state into equal components → ellipticity changes → cancellation degrades.</li>
            <li><strong>Reflection behavior:</strong> If the reflection does not effectively flip handedness (or mixes polarizations differently), the rejection mechanism can weaken.</li>
          </ul>

          <p><strong>Alternative derivation idea (brief)</strong></p>
          <ul>
            <li>Use <strong>Stokes/Mueller</strong> formalism: treat unpolarized background rigorously, show polarizer → deterministic state, then show double pass maps Stokes vector to orthogonal analyzer direction in the ideal case.</li>
          </ul>
        </div>
      </div>

      <div class="callout">
        <strong>Concept checks (quick Q&A)</strong>
        <ul style="margin:10px 0 0 18px; color:var(--muted)">
          <li><strong>Q:</strong> Why must the QWP be at 45°?<br/><strong>A:</strong> So the polarizer-passed linear state projects equally onto the fast and slow axes, enabling circular polarization after a π/2 phase shift.</li>
          <li><strong>Q:</strong> What happens if δ = 0° (no retardance)?<br/><strong>A:</strong> The device reduces to a polarizer only; the return polarization stays aligned and glare is not canceled.</li>
          <li><strong>Q:</strong> Why isn’t this a true isolator?<br/><strong>A:</strong> Because the elements are reciprocal; isolation in general requires non-reciprocity (e.g., Faraday rotation).</li>
          <li><strong>Q:</strong> Does it block all reflections from any surface? <br/><strong>A:</strong> It strongly suppresses back-reflections that undergo the handedness-flip/double-pass mechanism; performance depends on real reflection physics and wavelength/angle.</li>
        </ul>
      </div>
    </section>

    <section id="p5" class="card">
      <h3>PART 5 — Visualization Guide (How to Read the Plots)</h3>

      <div class="grid2">
        <div>
          <p><strong>Diagram canvas</strong></p>
          <ul>
            <li>Shows the <strong>observer</strong>, the <strong>screen</strong> (polarizer + QWP), the <strong>window</strong>, and the <strong>object</strong> behind the window.</li>
            <li>The <strong>background glare ray</strong> goes from observer side → through screen → reflects at the window → returns through screen.</li>
            <li>The screen is designed so that the returned glare becomes <strong>orthogonal</strong> to the polarizer axis and is blocked.</li>
          </ul>

          <p><strong>Main plot (T<sub>glare</sub> vs δ)</strong></p>
          <ul>
            <li>x-axis: retardance δ (degrees). 90° is an ideal QWP at its design wavelength.</li>
            <li>y-axis: normalized leakage T<sub>glare</sub> (0 to 1). Lower is better.</li>
            <li>At ε≈0°, the curve should dip near δ=90° (best cancellation).</li>
          </ul>
        </div>

        <div>
          <p><strong>Secondary plot (T<sub>glare</sub> vs ε)</strong></p>
          <ul>
            <li>x-axis: misalignment ε (degrees). 0° is perfect 45° alignment.</li>
            <li>y-axis: leakage. It rises as |ε| increases.</li>
          </ul>

          <p><strong>Heatmap sweep (δ, ε)</strong></p>
          <ul>
            <li>Horizontal axis: δ; vertical axis: ε.</li>
            <li>Darker regions mean better glare suppression (lower T<sub>glare</sub>).</li>
            <li>The “sweet spot” should cluster near (δ=90°, ε=0°).</li>
          </ul>

          <p><strong>Interactive controls</strong></p>
          <ul>
            <li><strong>δ slider:</strong> simulates wavelength error or imperfect wave plate.</li>
            <li><strong>ε slider:</strong> simulates assembly misalignment.</li>
            <li><strong>Reflection model:</strong> shows why a handedness-flipping reflection is essential to the anti-glare mechanism.</li>
            <li>All plots update live and use the same δ, ε values.</li>
          </ul>
        </div>
      </div>
    </section>

  </div>
</main>

<footer>
  <div class="wrap">
    Built as a self-contained learning article (vanilla HTML/CSS/JS). Plots use Jones-calculus simulation with ideal elements and adjustable parameters.
  </div>
</footer>

<script>
/* -------------------------
   Utilities: copy buttons
-------------------------- */
(function(){
  function copyText(txt){
    if(!navigator.clipboard){
      const ta = document.createElement('textarea');
      ta.value = txt;
      document.body.appendChild(ta);
      ta.select();
      try{ document.execCommand('copy'); }catch(e){}
      ta.remove();
      return;
    }
    navigator.clipboard.writeText(txt);
  }
  document.querySelectorAll('[data-copy-btn]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const eq = btn.parentElement.querySelector('.eq');
      const txt = eq?.getAttribute('data-copy') || eq?.innerText || '';
      copyText(txt.trim());
      const old = btn.textContent;
      btn.textContent = 'Copied ✓';
      setTimeout(()=>btn.textContent = old, 850);
    });
  });
})();

/* -------------------------
   Math: Jones calculus sim
-------------------------- */
function deg2rad(d){ return d*Math.PI/180; }
function c(re, im){ return {re, im}; }
function cAdd(a,b){ return {re:a.re+b.re, im:a.im+b.im}; }
function cSub(a,b){ return {re:a.re-b.re, im:a.im-b.im}; }
function cMul(a,b){ return {re:a.re*b.re - a.im*b.im, im:a.re*b.im + a.im*b.re}; }
function cConj(a){ return {re:a.re, im:-a.im}; }
function cAbs2(a){ return a.re*a.re + a.im*a.im; }
function cExp(iPhi){ return {re: Math.cos(iPhi), im: Math.sin(iPhi)}; } // e^{i phi}

function mat2(a00,a01,a10,a11){
  return [[a00,a01],[a10,a11]];
}
function mMul(A,B){
  return [
    [ cAdd(cMul(A[0][0],B[0][0]), cMul(A[0][1],B[1][0])),
      cAdd(cMul(A[0][0],B[0][1]), cMul(A[0][1],B[1][1])) ],
    [ cAdd(cMul(A[1][0],B[0][0]), cMul(A[1][1],B[1][0])),
      cAdd(cMul(A[1][0],B[0][1]), cMul(A[1][1],B[1][1])) ]
  ];
}
function mVmul(A,v){
  return [
    cAdd(cMul(A[0][0],v[0]), cMul(A[0][1],v[1])),
    cAdd(cMul(A[1][0],v[0]), cMul(A[1][1],v[1]))
  ];
}

function R(theta){
  const ct = Math.cos(theta), st = Math.sin(theta);
  return mat2(c(ct,0), c(-st,0), c(st,0), c(ct,0));
}
function Q(theta, delta){
  // Q = R(-θ) diag(1, e^{iδ}) R(θ)
  const Rp = R(theta);
  const Rm = R(-theta);
  const e = cExp(delta);
  const D = mat2(c(1,0), c(0,0), c(0,0), e);
  return mMul(mMul(Rm, D), Rp);
}
function P(){
  return mat2(c(1,0), c(0,0), c(0,0), c(0,0));
}
function M(model){
  if(model === 'global'){
    // -I : global phase, no handedness flip effect in this simplified representation
    return mat2(c(-1,0), c(0,0), c(0,0), c(-1,0));
  }
  // flip: diag(1,-1)
  return mat2(c(1,0), c(0,0), c(0,0), c(-1,0));
}

function glareLeakage(deltaDeg, epsDeg, model){
  // normalized to intensity right after the first polarizer
  const delta = deg2rad(deltaDeg);
  const theta = deg2rad(45 + epsDeg);
  const Ein = [c(1,0), c(0,0)]; // after first polarizer (normalized)
  const Jq = Q(theta, delta);
  const J = mMul(mMul(Jq, M(model)), Jq); // Q * M * Q
  const Eret = mVmul(J, Ein);            // return field before polarizer
  const Eout = mVmul(P(), Eret);         // after polarizer
  const I = cAbs2(Eout[0]) + cAbs2(Eout[1]);
  // Since Ein was normalized after the first polarizer, I is the leakage fraction:
  // T_glare = I_return_after_polarizer / I_after_first_polarizer
  // Clamp numeric noise
  return Math.max(0, Math.min(1, I));
}

/* -------------------------
   Canvas plotting helpers
-------------------------- */
function setupHiDPICanvas(canvas){
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(2, Math.floor(rect.width * dpr));
  const h = Math.max(2, Math.floor(rect.height * dpr));
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h;
  }
  ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  return {ctx, w: rect.width, h: rect.height, dpr};
}

function drawAxes(ctx, x0,y0,w,h, xMin,xMax,yMin,yMax, xLabel,yLabel,title, opts={}){
  const grid = opts.grid ?? true;
  const ticks = opts.ticks ?? 5;
  const tickColor = 'rgba(233,238,252,.25)';
  const gridColor = 'rgba(233,238,252,.08)';
  const axisColor = 'rgba(233,238,252,.35)';
  const textColor = 'rgba(233,238,252,.86)';
  const muted = 'rgba(233,238,252,.65)';

  // panel
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,.08)';
  ctx.fillRect(x0,y0,w,h);

  // title
  ctx.fillStyle = textColor;
  ctx.font = '600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText(title, x0+10, y0+18);

  const padL = 52, padR = 16, padT = 30, padB = 44;
  const px0 = x0+padL, py0 = y0+padT, pw = w-padL-padR, ph = h-padT-padB;

  // mapping
  const X = x => px0 + (x - xMin) * pw / (xMax - xMin);
  const Y = y => py0 + ph - (y - yMin) * ph / (yMax - yMin);

  // grid + ticks
  ctx.lineWidth = 1;

  for(let i=0;i<=ticks;i++){
    const tx = xMin + (xMax-xMin)*i/ticks;
    const x = X(tx);
    if(grid){
      ctx.strokeStyle = gridColor;
      ctx.beginPath();
      ctx.moveTo(x, py0);
      ctx.lineTo(x, py0+ph);
      ctx.stroke();
    }
    ctx.strokeStyle = tickColor;
    ctx.beginPath();
    ctx.moveTo(x, py0+ph);
    ctx.lineTo(x, py0+ph+6);
    ctx.stroke();

    ctx.fillStyle = muted;
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    const label = (opts.xTickFmt? opts.xTickFmt(tx): tx.toFixed(0));
    ctx.fillText(label, x-10, py0+ph+20);
  }

  for(let i=0;i<=ticks;i++){
    const ty = yMin + (yMax-yMin)*i/ticks;
    const y = Y(ty);
    if(grid){
      ctx.strokeStyle = gridColor;
      ctx.beginPath();
      ctx.moveTo(px0, y);
      ctx.lineTo(px0+pw, y);
      ctx.stroke();
    }
    ctx.strokeStyle = tickColor;
    ctx.beginPath();
    ctx.moveTo(px0-6, y);
    ctx.lineTo(px0, y);
    ctx.stroke();

    ctx.fillStyle = muted;
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    const label = (opts.yTickFmt? opts.yTickFmt(ty): ty.toFixed(2));
    ctx.fillText(label, px0-46, y+4);
  }

  // axes
  ctx.strokeStyle = axisColor;
  ctx.beginPath();
  ctx.moveTo(px0, py0);
  ctx.lineTo(px0, py0+ph);
  ctx.lineTo(px0+pw, py0+ph);
  ctx.stroke();

  // labels
  ctx.fillStyle = muted;
  ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText(xLabel, px0 + pw/2 - ctx.measureText(xLabel).width/2, y0+h-14);

  ctx.save();
  ctx.translate(x0+14, py0 + ph/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, -ctx.measureText(yLabel).width/2, 0);
  ctx.restore();

  ctx.restore();
  return {X,Y, px0,py0,pw,ph};
}

function drawLine(ctx, map, xs, ys, style){
  ctx.save();
  ctx.strokeStyle = style.stroke || 'rgba(125,211,252,.9)';
  ctx.lineWidth = style.width || 2;
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const x = map.X(xs[i]), y = map.Y(ys[i]);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.restore();
}

function drawLegend(ctx, x, y, items){
  ctx.save();
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  let yy = y;
  items.forEach(it=>{
    ctx.fillStyle = it.color;
    ctx.fillRect(x, yy-9, 14, 3);
    ctx.fillStyle = 'rgba(233,238,252,.8)';
    ctx.fillText(it.label, x+18, yy-2);
    yy += 16;
  });
  ctx.restore();
}

function drawMarker(ctx, map, x, y, color){
  ctx.save();
  ctx.fillStyle = color || 'rgba(52,211,153,.95)';
  ctx.beginPath();
  ctx.arc(map.X(x), map.Y(y), 4.5, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

/* -------------------------
   Diagram canvas
-------------------------- */
function drawSetup(canvas, params){
  const {ctx,w,h} = setupHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  // background gradient
  const g = ctx.createLinearGradient(0,0,w,h);
  g.addColorStop(0,'rgba(125,211,252,.08)');
  g.addColorStop(1,'rgba(167,139,250,.06)');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,w,h);

  // coordinate system
  const pad = 16;
  const cx = pad, cy = pad;

  // Draw observer
  const obsX = 70, obsY = h*0.55;
  ctx.fillStyle = 'rgba(233,238,252,.85)';
  ctx.beginPath();
  ctx.arc(obsX, obsY-18, 12, 0, Math.PI*2);
  ctx.fill();
  ctx.fillRect(obsX-10, obsY-6, 20, 44);

  // Label
  ctx.fillStyle = 'rgba(233,238,252,.9)';
  ctx.font = '600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText('Observer', obsX-28, obsY+62);

  // Screen (polarizer + QWP)
  const screenX = w*0.34;
  const yTop = h*0.16, yBot = h*0.86;
  ctx.strokeStyle = 'rgba(125,211,252,.7)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(screenX, yTop);
  ctx.lineTo(screenX, yBot);
  ctx.stroke();

  // Two layers markers
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(233,238,252,.28)';
  ctx.fillStyle = 'rgba(0,0,0,.14)';
  ctx.fillRect(screenX-18, h*0.33, 36, 28);
  ctx.fillRect(screenX-18, h*0.40, 36, 28);
  ctx.strokeRect(screenX-18, h*0.33, 36, 28);
  ctx.strokeRect(screenX-18, h*0.40, 36, 28);

  ctx.fillStyle = 'rgba(233,238,252,.85)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillText('P', screenX-6, h*0.33+18);
  ctx.fillText('Q', screenX-6, h*0.40+18);

  ctx.fillStyle = 'rgba(233,238,252,.9)';
  ctx.font = '600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText('Anti-glare screen', screenX-62, yTop-10);

  // Window
  const winX = w*0.68;
  ctx.strokeStyle = 'rgba(233,238,252,.45)';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(winX, yTop);
  ctx.lineTo(winX, yBot);
  ctx.stroke();
  ctx.fillStyle = 'rgba(233,238,252,.9)';
  ctx.font = '600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText('Glass window', winX-44, yTop-10);

  // Object behind window
  const objX = w*0.88, objY = h*0.55;
  ctx.fillStyle = 'rgba(52,211,153,.85)';
  ctx.beginPath();
  ctx.arc(objX, objY, 18, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = 'rgba(233,238,252,.9)';
  ctx.font = '600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText('Self-luminous object', objX-74, objY+42);

  // Rays: object -> observer (desired)
  ctx.strokeStyle = 'rgba(52,211,153,.85)';
  ctx.lineWidth = 2.5;
  ctx.setLineDash([8,6]);
  ctx.beginPath();
  ctx.moveTo(objX-18, objY);
  ctx.lineTo(obsX+18, obsY);
  ctx.stroke();
  ctx.setLineDash([]);

  // Rays: background -> window -> back (glare)
  const bgY = h*0.30;
  ctx.strokeStyle = 'rgba(251,191,36,.9)';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(obsX+18, bgY);
  ctx.lineTo(winX, bgY);
  ctx.stroke();

  // reflection arrow back
  ctx.beginPath();
  ctx.moveTo(winX, bgY);
  ctx.lineTo(obsX+18, bgY);
  ctx.stroke();

  // Mark reflection point
  ctx.fillStyle = 'rgba(251,191,36,.95)';
  ctx.beginPath();
  ctx.arc(winX, bgY, 4.5, 0, Math.PI*2);
  ctx.fill();

  // Annotation: polarization behavior
  const deltaDeg = params.deltaDeg.toFixed(1);
  const epsDeg = params.epsDeg.toFixed(1);
  ctx.fillStyle = 'rgba(233,238,252,.88)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillText(`δ = ${deltaDeg}°`, 18, 28);
  ctx.fillText(`ε = ${epsDeg}°`, 18, 44);
  ctx.fillText(`Model: ${params.model==='flip'?'flip':'global'}`, 18, 60);

  // small legend
  ctx.fillStyle = 'rgba(0,0,0,.18)';
  ctx.strokeStyle = 'rgba(233,238,252,.18)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(w*0.52, h*0.70, w*0.44-18, 72, 14);
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = 'rgba(233,238,252,.86)';
  ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText('Ray colors', w*0.54, h*0.72+18);

  ctx.fillStyle = 'rgba(52,211,153,.95)';
  ctx.fillRect(w*0.54, h*0.72+30, 16, 3);
  ctx.fillStyle = 'rgba(233,238,252,.78)';
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText('desired view (object → observer)', w*0.54+20, h*0.72+36);

  ctx.fillStyle = 'rgba(251,191,36,.95)';
  ctx.fillRect(w*0.54, h*0.72+50, 16, 3);
  ctx.fillStyle = 'rgba(233,238,252,.78)';
  ctx.fillText('glare path (background reflection)', w*0.54+20, h*0.72+56);
}

/* -------------------------
   Plotting
-------------------------- */
function drawPlot1(canvas, params){
  const {ctx,w,h} = setupHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  const eps = params.epsDeg;
  const model = params.model;

  const xMin=0, xMax=180, yMin=0, yMax=1;
  const map = drawAxes(ctx, 0,0,w,h, xMin,xMax,yMin,yMax,
    'Retardance δ (deg)', 'Leakage T_glare (dimensionless)',
    'Glare leakage vs retardance (at fixed misalignment ε)'
  );

  // curve
  const xs=[], ys=[];
  for(let d=0; d<=180.0001; d+=1.0){
    xs.push(d);
    ys.push(glareLeakage(d, eps, model));
  }
  drawLine(ctx, map, xs, ys, {stroke:'rgba(125,211,252,.9)', width:2.5});

  // marker at current delta
  const yNow = glareLeakage(params.deltaDeg, eps, model);
  drawMarker(ctx, map, params.deltaDeg, yNow, 'rgba(52,211,153,.95)');

  // annotate
  ctx.save();
  ctx.fillStyle = 'rgba(233,238,252,.85)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  const txt = `ε=${eps.toFixed(1)}°,  T=${yNow.toFixed(4)}`;
  ctx.fillText(txt, map.px0+10, map.py0+18);
  drawLegend(ctx, map.px0+10, map.py0+38, [
    {color:'rgba(125,211,252,.9)', label:'T_glare(δ)'},
    {color:'rgba(52,211,153,.95)', label:'current setting'}
  ]);
  ctx.restore();
}

function drawPlot2(canvas, params){
  const {ctx,w,h} = setupHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  const deltaDeg = params.deltaDeg;
  const model = params.model;

  const xMin=-15, xMax=15, yMin=0, yMax=1;
  const map = drawAxes(ctx, 0,0,w,h, xMin,xMax,yMin,yMax,
    'Misalignment ε (deg)', 'Leakage T_glare (dimensionless)',
    'Glare leakage vs misalignment (at fixed retardance δ)',
    {xTickFmt:(v)=>v.toFixed(0)}
  );

  const xs=[], ys=[];
  for(let e=-15; e<=15.0001; e+=0.25){
    xs.push(e);
    ys.push(glareLeakage(deltaDeg, e, model));
  }
  drawLine(ctx, map, xs, ys, {stroke:'rgba(167,139,250,.92)', width:2.5});

  const yNow = glareLeakage(deltaDeg, params.epsDeg, model);
  drawMarker(ctx, map, params.epsDeg, yNow, 'rgba(52,211,153,.95)');

  ctx.save();
  ctx.fillStyle = 'rgba(233,238,252,.85)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  const txt = `δ=${deltaDeg.toFixed(1)}°,  T=${yNow.toFixed(4)}`;
  ctx.fillText(txt, map.px0+10, map.py0+18);
  drawLegend(ctx, map.px0+10, map.py0+38, [
    {color:'rgba(167,139,250,.92)', label:'T_glare(ε)'},
    {color:'rgba(52,211,153,.95)', label:'current setting'}
  ]);
  ctx.restore();
}

function drawHeatmap(canvas, params){
  const {ctx,w,h} = setupHiDPICanvas(canvas);
  ctx.clearRect(0,0,w,h);

  const xMin=0, xMax=180, yMin=-15, yMax=15;
  const map = drawAxes(ctx, 0,0,w,h, xMin,xMax,yMin,yMax,
    'Retardance δ (deg)', 'Misalignment ε (deg)',
    '2D sweep: T_glare(δ, ε) heatmap (darker = better)',
    {xTickFmt:(v)=>v.toFixed(0), yTickFmt:(v)=>v.toFixed(0), ticks:5}
  );

  // Heatmap region is inside plot area
  const left = map.px0, top = map.py0, pw = map.pw, ph = map.ph;

  // render low-res grid then scale for speed
  const nx = 120, ny = 80;
  const img = ctx.createImageData(nx, ny);
  const model = params.model;

  for(let j=0;j<ny;j++){
    const eps = yMax - (yMax-yMin)*j/(ny-1);
    for(let i=0;i<nx;i++){
      const d = xMin + (xMax-xMin)*i/(nx-1);
      const T = glareLeakage(d, eps, model); // 0..1
      // Map: good (low) -> dark; bad -> bright
      const v = Math.pow(T, 0.55); // perceptual boost
      const r = Math.floor(40 + 180*v);
      const g = Math.floor(50 + 150*v);
      const b = Math.floor(70 + 165*v);
      const a = 210;
      const idx = (j*nx+i)*4;
      img.data[idx+0]=r;
      img.data[idx+1]=g;
      img.data[idx+2]=b;
      img.data[idx+3]=a;
    }
  }

  // put to offscreen then draw scaled into plot area
  const off = document.createElement('canvas');
  off.width = nx; off.height = ny;
  off.getContext('2d').putImageData(img,0,0);

  ctx.save();
  ctx.globalAlpha = 0.95;
  ctx.imageSmoothingEnabled = true;
  ctx.drawImage(off, left, top, pw, ph);
  ctx.restore();

  // current point marker
  const dNow = params.deltaDeg;
  const eNow = params.epsDeg;
  const Tnow = glareLeakage(dNow, eNow, model);

  ctx.save();
  // marker crosshair
  ctx.strokeStyle = 'rgba(233,238,252,.8)';
  ctx.lineWidth = 1;
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.moveTo(map.X(dNow), top);
  ctx.lineTo(map.X(dNow), top+ph);
  ctx.moveTo(left, map.Y(eNow));
  ctx.lineTo(left+pw, map.Y(eNow));
  ctx.stroke();
  ctx.setLineDash([]);

  // dot
  ctx.fillStyle = 'rgba(52,211,153,.95)';
  ctx.beginPath();
  ctx.arc(map.X(dNow), map.Y(eNow), 5, 0, Math.PI*2);
  ctx.fill();

  // label
  ctx.fillStyle = 'rgba(0,0,0,.45)';
  ctx.strokeStyle = 'rgba(233,238,252,.22)';
  ctx.lineWidth = 1;
  const label = `δ=${dNow.toFixed(1)}°, ε=${eNow.toFixed(1)}°, T=${Tnow.toFixed(4)}`;
  const lx = Math.min(left+pw-220, map.X(dNow)+10);
  const ly = Math.max(top+18, map.Y(eNow)-12);
  ctx.beginPath();
  ctx.roundRect(lx, ly-16, 220, 22, 10);
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = 'rgba(233,238,252,.86)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillText(label, lx+8, ly);
  ctx.restore();

  // legend bar
  ctx.save();
  const bx = left+pw-150, by = top+8;
  const bw = 140, bh = 10;
  const grad = ctx.createLinearGradient(bx,0,bx+bw,0);
  grad.addColorStop(0,'rgba(40,50,70,.9)');
  grad.addColorStop(1,'rgba(220,200,240,.9)');
  ctx.fillStyle = grad;
  ctx.fillRect(bx, by, bw, bh);
  ctx.strokeStyle = 'rgba(233,238,252,.25)';
  ctx.strokeRect(bx, by, bw, bh);
  ctx.fillStyle = 'rgba(233,238,252,.75)';
  ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.fillText('low T', bx, by+22);
  ctx.fillText('high T', bx+bw-44, by+22);
  ctx.restore();
}

/* -------------------------
   Controller
-------------------------- */
const elDelta = document.getElementById('delta');
const elEps = document.getElementById('eps');
const elModel = document.getElementById('model');
const deltaVal = document.getElementById('deltaVal');
const epsVal = document.getElementById('epsVal');
const modelVal = document.getElementById('modelVal');

const canvSetup = document.getElementById('setup');
const canvP1 = document.getElementById('plot1');
const canvP2 = document.getElementById('plot2');
const canvP3 = document.getElementById('plot3');

function readParams(){
  const deltaDeg = parseFloat(elDelta.value);
  const epsDeg = parseFloat(elEps.value);
  const model = elModel.value;
  return {deltaDeg, epsDeg, model};
}
function updateLabels(p){
  deltaVal.textContent = p.deltaDeg.toFixed(1) + '°';
  epsVal.textContent = p.epsDeg.toFixed(1) + '°';
  modelVal.textContent = (p.model==='flip') ? 'Mirror flip (M=diag(1,-1))' : 'Global phase only (M=-I)';
}
function render(){
  const p = readParams();
  updateLabels(p);
  drawSetup(canvSetup, p);
  drawPlot1(canvP1, p);
  drawPlot2(canvP2, p);
  drawHeatmap(canvP3, p);
}

['input','change'].forEach(evt=>{
  elDelta.addEventListener(evt, render);
  elEps.addEventListener(evt, render);
  elModel.addEventListener(evt, render);
});

document.getElementById('btnIdeal').addEventListener('click', ()=>{
  elDelta.value = '90';
  elEps.value = '0';
  elModel.value = 'flip';
  render();
});
document.getElementById('btnBad').addEventListener('click', ()=>{
  elDelta.value = '0';
  elEps.value = '0';
  elModel.value = 'flip';
  render();
});

window.addEventListener('resize', ()=>{
  // re-render for new sizes
  render();
});

// Initial render
render();

/* -------------------------
   Smooth TOC scrolling
-------------------------- */
document.querySelectorAll('.toc a[href^="#"]').forEach(a=>{
  a.addEventListener('click', (e)=>{
    e.preventDefault();
    const id = a.getAttribute('href').slice(1);
    const target = document.getElementById(id);
    if(!target) return;
    target.scrollIntoView({behavior:'smooth', block:'start'});
  });
});

// Canvas roundRect polyfill for older browsers
if(!CanvasRenderingContext2D.prototype.roundRect){
  CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    this.beginPath();
    this.moveTo(x+rr,y);
    this.arcTo(x+w,y,x+w,y+h,rr);
    this.arcTo(x+w,y+h,x,y+h,rr);
    this.arcTo(x,y+h,x,y,rr);
    this.arcTo(x,y,x+w,y,rr);
    this.closePath();
    return this;
  };
}
</script>
</body>
</html>
