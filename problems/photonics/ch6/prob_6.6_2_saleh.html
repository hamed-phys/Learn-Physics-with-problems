<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Polarization Rotation by a Sequence of Linear Polarizers (Jones Calculus)</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#101a33;
      --muted:#a9b4d0;
      --text:#e9eeff;
      --accent:#7aa7ff;
      --accent2:#6ef0c4;
      --warn:#ffcc66;
      --danger:#ff6b7a;
      --border:rgba(255,255,255,.10);
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html{ scroll-behavior:smooth; }
    body{
      margin:0;
      font-family: var(--sans);
      background: radial-gradient(1200px 700px at 20% 0%, rgba(122,167,255,.22), transparent 55%),
                  radial-gradient(900px 600px at 80% 20%, rgba(110,240,196,.16), transparent 55%),
                  linear-gradient(180deg, #070a14, var(--bg));
      color: var(--text);
      line-height:1.55;
    }

    header{
      padding: clamp(18px, 3vw, 34px) clamp(16px, 4vw, 44px);
      border-bottom: 1px solid var(--border);
      background: rgba(9,12,24,.6);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 30;
    }

    .title-row{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:16px;
      max-width: 1200px;
      margin: 0 auto;
    }

    h1{
      margin:0;
      font-size: clamp(20px, 2.4vw, 30px);
      letter-spacing:.2px;
    }
    .subtitle{
      margin-top:6px;
      color: var(--muted);
      max-width: 78ch;
      font-size: 0.98rem;
    }

    main{
      max-width:1200px;
      margin: 0 auto;
      padding: 22px clamp(16px, 4vw, 44px) 44px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 18px;
    }

    /* Layout: content + sticky toc on wide screens */
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:18px;
      align-items:start;
    }
    @media (min-width: 980px){
      .grid{
        grid-template-columns: 1fr 310px;
      }
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .card .content{
      padding: 18px 18px 16px;
    }

    section{
      scroll-margin-top: 92px;
    }

    h2{
      margin: 0 0 10px;
      font-size: 1.22rem;
      letter-spacing:.2px;
    }
    h3{
      margin: 14px 0 8px;
      font-size: 1.05rem;
      color: #f3f6ff;
    }
    p{ margin: 10px 0; color: rgba(233,238,255,.95); }

    ul{ margin: 10px 0 10px 18px; padding:0; }
    li{ margin:6px 0; color: rgba(233,238,255,.95); }

    .callouts{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
      margin-top: 12px;
    }
    @media (min-width: 760px){
      .callouts{
        grid-template-columns: repeat(2, 1fr);
      }
    }

    .callout{
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 12px 12px 10px;
      background: rgba(12,18,38,.65);
      position: relative;
      overflow:hidden;
      transform: translateZ(0);
    }
    .callout::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(500px 180px at 10% 0%, rgba(122,167,255,.20), transparent 60%),
                  radial-gradient(500px 180px at 90% 0%, rgba(110,240,196,.14), transparent 60%);
      opacity:.8;
      pointer-events:none;
    }
    .callout > *{ position:relative; }
    .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size:.82rem;
      color: rgba(233,238,255,.90);
      margin-bottom:6px;
      letter-spacing:.2px;
    }
    .tag .dot{
      width:9px; height:9px; border-radius:999px;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(122,167,255,.15);
    }
    .tag.warn .dot{ background: var(--warn); box-shadow: 0 0 0 3px rgba(255,204,102,.16); }
    .tag.danger .dot{ background: var(--danger); box-shadow: 0 0 0 3px rgba(255,107,122,.16); }
    .tag.good .dot{ background: var(--accent2); box-shadow: 0 0 0 3px rgba(110,240,196,.14); }

    .eq{
      margin: 10px 0;
      border: 1px dashed rgba(255,255,255,.22);
      border-radius: 14px;
      background: rgba(0,0,0,.22);
      overflow:hidden;
    }
    .eq header{
      position: static;
      padding: 10px 12px;
      background: rgba(255,255,255,.04);
      border-bottom: 1px solid rgba(255,255,255,.08);
      backdrop-filter:none;
    }
    .eq header .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .eq header strong{
      font-size:.92rem;
      letter-spacing:.2px;
      color: rgba(233,238,255,.95);
    }
    pre{
      margin:0;
      padding: 12px 12px 12px;
      font-family: var(--mono);
      font-size: 0.93rem;
      white-space: pre-wrap;
      word-break: break-word;
      color: rgba(233,238,255,.96);
    }

    .btn{
      appearance:none;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:600;
      font-size:.86rem;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.26); }
    .btn:active{ transform: translateY(0px); }
    .btn.small{ padding:6px 9px; font-size:.82rem; border-radius: 11px; }
    .btn.primary{
      background: rgba(122,167,255,.18);
      border-color: rgba(122,167,255,.40);
    }
    .btn.primary:hover{ background: rgba(122,167,255,.24); }

    .toc{
      position: relative;
    }
    @media (min-width: 980px){
      .toc{
        position: sticky;
        top: 92px;
      }
    }

    .toc .content{
      padding: 14px 14px 14px;
    }
    .toc a{
      display:block;
      padding: 8px 10px;
      border-radius: 12px;
      text-decoration:none;
      color: rgba(233,238,255,.92);
      border: 1px solid transparent;
      transition: background .12s ease, border-color .12s ease;
      font-size:.92rem;
    }
    .toc a:hover{
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.12);
    }
    .toc small{ color: var(--muted); display:block; margin: 0 0 8px 2px; }

    .viz{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      padding: 14px;
    }
    @media (min-width: 980px){
      .viz{
        grid-template-columns: 1.05fr .95fr;
      }
    }
    .vizpanel{
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      overflow:hidden;
      background: rgba(0,0,0,.18);
      position:relative;
    }
    .vizpanel header{
      position:static;
      padding: 10px 12px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .vizpanel header .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .vizpanel header .title{
      font-weight:800;
      letter-spacing:.2px;
      font-size:.92rem;
    }
    canvas{
      width:100%;
      height: 320px;
      display:block;
    }
    @media (min-width: 980px){
      #diagramCanvas{ height: 340px; }
      #mainPlotCanvas{ height: 340px; }
      #secondaryPlotCanvas{ height: 290px; }
    }

    .controls{
      display:flex;
      flex-wrap: wrap;
      gap: 10px 12px;
      align-items:center;
      padding: 12px;
      border-top: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
    }
    .control{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 220px;
      flex: 1 1 240px;
    }
    .control label{
      font-size:.86rem;
      color: rgba(233,238,255,.90);
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap: 10px;
    }
    .control label span{
      color: var(--muted);
      font-weight: 600;
      font-family: var(--mono);
      font-size:.86rem;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }

    .readout{
      padding: 12px 14px;
      border-top: 1px solid rgba(255,255,255,.10);
      font-family: var(--mono);
      font-size: .92rem;
      color: rgba(233,238,255,.92);
      background: rgba(0,0,0,.15);
    }

    footer{
      max-width:1200px;
      margin: 0 auto;
      padding: 14px clamp(16px, 4vw, 44px) 34px;
      color: var(--muted);
      border-top: 1px solid var(--border);
    }

    /* subtle motion, reduced for prefers-reduced-motion */
    @media (prefers-reduced-motion: no-preference){
      .card{ animation: floatIn .45s ease both; }
      .card:nth-child(2){ animation-delay: .04s; }
      .card:nth-child(3){ animation-delay: .08s; }
      @keyframes floatIn{
        from{ opacity:0; transform: translateY(10px); }
        to{ opacity:1; transform: translateY(0); }
      }
    }

    /* Print-friendly */
    @media print{
      header{ position:static; background:#fff; color:#000; border:none; }
      body{ background:#fff; color:#000; }
      .card{ box-shadow:none; border:1px solid #ddd; background:#fff; }
      .toc{ display:none; }
      .btn{ display:none; }
      canvas{ display:none; }
      .vizpanel{ display:none; }
      a{ color:#000; text-decoration: underline; }
      .eq{ border:1px solid #ccc; }
      pre{ color:#000; }
      .callout{ background:#fff; }
    }
  </style>
</head>

<body>
<header>
  <div class="title-row">
    <div>
      <h1>6.6-2 — Polarization Rotation by a Sequence of Linear Polarizers</h1>
      <div class="subtitle">
        We rotate linear polarization from <b>x</b> to <b>y</b> using many polarizers with slowly turning axes, then quantify the unavoidable amplitude (and intensity) reduction using <b>Jones matrices</b> and simple projection physics.
      </div>
    </div>
    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
      <button class="btn primary" id="copyFinalBtn" title="Copy the final answer (plain text)">Copy Final Answer</button>
      <button class="btn" id="scrollVizBtn" title="Jump to interactive visualizations">Go to Visuals</button>
    </div>
  </div>
</header>

<main>
  <div class="grid">
    <article class="card">
      <div class="content">
        <section id="quick-summary">
          <h2>Quick Summary</h2>
          <ul>
            <li><b>About:</b> A linearly polarized wave (initially along <b>x</b>) passes through <b>N</b> ideal linear polarizers whose axes rotate by equal steps.</li>
            <li><b>Key idea:</b> Each polarizer transmits the <i>projection</i> of the incoming polarization onto its axis → amplitudes multiply by <code>cos(Δ)</code> where Δ is the angle between consecutive axes.</li>
            <li><b>Governing tools:</b> Jones vectors &amp; Jones matrices; rotation matrix <code>R(α)</code> and ideal polarizer matrix <code>P(α)</code>.</li>
            <li><b>Angles:</b> Polarizer <i>m</i> has axis angle <code>α_m = mθ</code> with <code>θ = π/(2N)</code>, so the last axis is <code>α_N = π/2</code> (the <b>y</b>-axis).</li>
            <li><b>Main result (symbolic):</b> Output polarization is along <b>y</b>, but the <b>field amplitude</b> is reduced by <code>(cos θ)^N</code>.</li>
            <li><b>Intensity:</b> <code>I_out/I_in = (cos^2 θ)^N</code>.</li>
            <li><b>Limit:</b> As <code>N → ∞</code> with <code>θ = π/(2N)</code>, <code>(cos θ)^N → 1</code> (so the rotation becomes nearly lossless for an idealized sequence).</li>
          </ul>
        </section>

        <section id="part0">
          <h2>PART 0 — Concept Primer (Theory Before Solving)</h2>

          <h3>Core definitions (symbols &amp; units)</h3>
          <ul>
            <li><b>Jones vector</b> (complex field amplitudes): <code>E = [E_x, E_y]^T</code> (units: V/m, but often treated up to an overall scale).</li>
            <li><b>Linear polarization at angle</b> α: a unit polarization vector <code>ê(α) = [cos α, sin α]^T</code>.</li>
            <li><b>Rotation matrix</b> (coordinate basis rotation in the x–y plane):
              <code>R(α) = [[cos α, -sin α],[sin α, cos α]]</code> (dimensionless).</li>
            <li><b>Ideal linear polarizer</b> with transmission axis α (Jones matrix): it transmits only the component along <code>ê(α)</code>.</li>
          </ul>

          <div class="callouts">
            <div class="callout">
              <div class="tag good"><span class="dot"></span><b>Physical meaning</b></div>
              <p>
                A polarizer does <b>not</b> “rotate” the field by itself. It <b>filters</b> it: it keeps the component along its axis and blocks the orthogonal component. If you place many polarizers whose axes slowly turn, the surviving component “follows” the turn.
              </p>
            </div>
            <div class="callout">
              <div class="tag"><span class="dot"></span><b>When Jones calculus applies</b></div>
              <p>
                Jones matrices assume: (i) fully polarized, quasi-monochromatic light, (ii) linear optical elements, (iii) coherent field amplitudes tracked (phases possible). Depolarization and partial polarization require Stokes/Mueller methods instead.
              </p>
            </div>
          </div>

          <h3>Ideal polarizer model (why it looks like a projector)</h3>
          <p>
            In its own axis-aligned basis (axis = x′), an ideal polarizer is:
          </p>

          <div class="eq" data-copy="P0 = [[1,0],[0,0]]">
            <header>
              <div class="row">
                <strong>Key equation: axis-aligned ideal polarizer</strong>
                <button class="btn small copyBtn">Copy</button>
              </div>
            </header>
            <pre>P0 = [ [1, 0],
       [0, 0] ]</pre>
          </div>

          <p>
            If the polarizer axis is rotated by α relative to the lab x-axis, transform to the lab basis:
            rotate into the polarizer’s frame, apply <code>P0</code>, then rotate back.
          </p>

          <div class="eq" data-copy="P(α) = R(α) P0 R(-α) = R(-α)^T P0 R(-α)">
            <header>
              <div class="row">
                <strong>Key equation: rotated polarizer (lab basis)</strong>
                <button class="btn small copyBtn">Copy</button>
              </div>
            </header>
            <pre>P(α) = R(α) · P0 · R(-α)</pre>
          </div>

          <h3>Mini intuition examples (no long algebra)</h3>
          <ul>
            <li><b>Two polarizers:</b> If the second is rotated by Δ relative to the first, transmitted <i>amplitude</i> scales by <code>cos Δ</code> (and <i>intensity</i> by <code>cos² Δ</code>). This is the microscopic origin of Malus’ law.</li>
            <li><b>Many polarizers:</b> If each step is small (Δ tiny), each projection loss is tiny, and the product can approach 1 as the number of steps grows.</li>
          </ul>

          <div class="callout">
            <div class="tag warn"><span class="dot"></span><b>What to watch for (common pitfalls)</b></div>
            <ul>
              <li>Confusing <b>amplitude</b> loss <code>cos Δ</code> with <b>intensity</b> loss <code>cos² Δ</code>.</li>
              <li>Forgetting that the <b>final polarizer axis</b> sets the final polarization direction.</li>
              <li>Mixing up rotation conventions: <code>R(α)</code> rotates vectors by +α in the x–y plane (counterclockwise).</li>
              <li>Assuming “rotation without loss” for a single polarizer: impossible for ideal polarizers because they discard the orthogonal component.</li>
            </ul>
          </div>
        </section>

        <section id="part1">
          <h2>PART 1 — Problem Analysis (No Solving Yet)</h2>

          <h3>Problem rewritten clearly</h3>
          <p>
            A plane wave starts linearly polarized along the <b>x</b>-axis. It passes through <b>N</b> ideal linear polarizers.
            The m-th polarizer’s transmission axis is at angle <code>α_m = mθ</code> relative to x, where
            <code>θ = π/(2N)</code> and <code>m = 1,2,...,N</code>.
            Show that the exiting light is polarized along <b>y</b>, and that its <b>field amplitude</b> is reduced by the factor <code>(cos θ)^N</code>.
            Then evaluate what happens as <code>N → ∞</code>.
          </p>

          <h3>Given quantities</h3>
          <ul>
            <li>Input Jones vector: <code>E_in = [E0, 0]^T</code> (x-polarized).</li>
            <li>Polarizer angles: <code>α_m = mθ</code>, <code>θ = π/(2N)</code>, <code>m = 1..N</code>.</li>
            <li>Ideal polarizers (perfect extinction of orthogonal component).</li>
          </ul>

          <h3>Unknowns / what to prove</h3>
          <ul>
            <li>Output polarization direction (show it is along <b>y</b>).</li>
            <li>Output amplitude factor relative to <code>E0</code> (show it is <code>(cos θ)^N</code>).</li>
            <li>Limit behavior as <code>N → ∞</code>.</li>
          </ul>

          <h3>Relevant principles and why they apply</h3>
          <ul>
            <li><b>Jones calculus:</b> The system is a sequence of linear optical elements acting on a polarized field, so matrix multiplication gives the output field.</li>
            <li><b>Projection physics:</b> Each polarizer transmits only the component along its axis; consecutive axes differ by a constant angle <code>θ</code>, producing repeated projection factors.</li>
          </ul>

          <h3>Assumptions (explicit)</h3>
          <div class="callout">
            <div class="tag"><span class="dot"></span><b>Assumptions</b></div>
            <ul>
              <li>Polarizers are <b>ideal</b> (no absorption along axis besides filtering, infinite extinction ratio).</li>
              <li>Light is fully polarized and described by a 2D Jones vector.</li>
              <li>No multiple reflections, no depolarization, no birefringence; polarizers are thin and perfectly aligned.</li>
            </ul>
          </div>

          <h3>Possible approaches (compare)</h3>
          <ul>
            <li><b>Jones-matrix multiplication (recommended):</b> Systematic and matches the hint; cleanly shows direction and amplitude. <i>Best for teaching and generalization.</i></li>
            <li><b>Geometric projection argument:</b> Faster intuition: each step projects by <code>cos θ</code>. <i>Best for quick insight.</i></li>
            <li><b>Energy/Malus’ law chain:</b> Track intensities via <code>cos² θ</code> repeatedly, then take square root for amplitude. <i>Best if you only care about intensity.</i></li>
          </ul>

          <p><b>Choice:</b> We’ll use <b>Jones matrices</b> (aligned with the hint) and periodically connect each algebra step to the projection picture.</p>
        </section>

        <section id="part2">
          <h2>PART 2 — Strategy &amp; Tips (Roadmap Only)</h2>
          <ol style="margin-left:18px;">
            <li>
              <b>Goal:</b> Write the Jones matrix of one polarizer at angle α.<br>
              <b>Tool:</b> <code>P(α) = R(α) P0 R(-α)</code>.<br>
              <b>Meaning:</b> Rotate into polarizer frame → filter → rotate back.
            </li>
            <li>
              <b>Goal:</b> Express the input field and apply the first polarizer.<br>
              <b>Tool:</b> Matrix-vector multiplication.<br>
              <b>Meaning:</b> The field becomes aligned with the first axis (angle θ) with some amplitude loss.
            </li>
            <li>
              <b>Goal:</b> Show the recursive step from polarizer m to m+1 produces a factor <code>cos θ</code>.<br>
              <b>Tool:</b> Use the fact consecutive axes differ by θ; use either rotation identities or dot products of unit vectors.<br>
              <b>Meaning:</b> Each new polarizer “re-projects” the field onto a slightly rotated axis.
            </li>
            <li>
              <b>Goal:</b> Multiply the repeated factor across N polarizers.<br>
              <b>Tool:</b> Product rule: repeated identical factor → <code>(cos θ)^N</code>.<br>
              <b>Meaning:</b> Small loss per step accumulates multiplicatively.
            </li>
            <li>
              <b>Goal:</b> Identify final polarization direction.<br>
              <b>Tool:</b> The last polarizer’s axis is <code>α_N = Nθ = π/2</code>.<br>
              <b>Meaning:</b> Output must be along y regardless of previous steps (provided nonzero transmission).
            </li>
            <li>
              <b>Goal:</b> Take the limit <code>N → ∞</code> with <code>θ = π/(2N)</code>.<br>
              <b>Tool:</b> Small-angle expansion <code>cos x ≈ 1 - x²/2</code> and exponential limit.<br>
              <b>Meaning:</b> Infinitesimal step losses vanish → nearly lossless rotation (idealization).
            </li>
          </ol>

          <div class="callouts">
            <div class="callout">
              <div class="tag warn"><span class="dot"></span><b>Common mistakes</b></div>
              <ul>
                <li>Using <code>cos² θ</code> for amplitude instead of intensity.</li>
                <li>Forgetting the last axis is exactly y because <code>Nθ = π/2</code>.</li>
                <li>Taking <code>N → ∞</code> while incorrectly holding θ fixed (θ changes with N here!).</li>
              </ul>
            </div>
            <div class="callout">
              <div class="tag good"><span class="dot"></span><b>Quick tips</b></div>
              <ul>
                <li>Think “<b>projection chain</b>”: each step multiplies amplitude by <code>cos(Δ)</code>.</li>
                <li>For the limit, rewrite <code>(cos(π/(2N)))^N</code> using <code>ln</code> and a Taylor series.</li>
              </ul>
            </div>
          </div>
        </section>

        <section id="part3">
          <h2>PART 3 — Full Solution (Detailed + Teaching)</h2>

          <h3>Physical intuition (before calculating)</h3>
          <p>
            After the first polarizer, the field becomes aligned with angle <code>θ</code>. The next polarizer is at <code>2θ</code>, so it keeps only the component of the <code>θ</code>-polarized field along <code>2θ</code>, which is reduced by <code>cos(θ)</code>.
            This repeats: each successive polarizer is tilted by the same small angle relative to the previous one, so the <b>same projection loss</b> repeats N times. Meanwhile, because the last axis is <code>π/2</code>, the output direction must be <b>y</b>.
          </p>

          <h3>Step 1: Jones matrices for rotation and a polarizer</h3>
          <p>Define the rotation matrix (counterclockwise by α):</p>

          <div class="eq" data-copy="R(α) = [[cosα, -sinα],[sinα, cosα]]">
            <header>
              <div class="row">
                <strong>Rotation matrix</strong>
                <button class="btn small copyBtn">Copy</button>
              </div>
            </header>
            <pre>R(α) = [ [cos α, -sin α],
       [sin α,  cos α] ]</pre>
          </div>

          <p>
            An ideal polarizer that transmits the x′ component in its own frame is <code>P0</code>. A polarizer with axis α in the lab basis is:
          </p>

          <div class="eq" data-copy="P(α) = R(α) [[1,0],[0,0]] R(-α)">
            <header>
              <div class="row">
                <strong>Ideal polarizer at angle α</strong>
                <button class="btn small copyBtn">Copy</button>
              </div>
            </header>
            <pre>P(α) = R(α) · [ [1,0],
                 [0,0] ] · R(-α)</pre>
          </div>

          <p>
            <b>Explanation:</b> <code>R(-α)</code> rotates the field into the polarizer’s axis-aligned coordinates, <code>P0</code> removes the orthogonal component, then <code>R(α)</code> rotates back to the lab frame.
          </p>

          <h3>Step 2: Apply one polarizer to a field aligned with the previous axis</h3>
          <p>
            Let the unit vector along angle α be <code>ê(α) = [cos α, sin α]^T</code>.
            An ideal polarizer acts like a projector onto its axis:
          </p>

          <div class="eq" data-copy="P(α) = ê(α) ê(α)^T  (for ideal lossless projection model on field amplitudes)">
            <header>
              <div class="row">
                <strong>Projector form (useful identity)</strong>
                <button class="btn small copyBtn">Copy</button>
              </div>
            </header>
            <pre>P(α) = ê(α) · ê(α)^T,   where ê(α) = [cos α, sin α]^T</pre>
          </div>

          <p>
            Now suppose the incoming field to the (m+1)-th polarizer is already aligned with the m-th axis:
            <code>E_m = A_m ê(α_m)</code>.
            Applying the next polarizer gives:
          </p>

          <div class="eq" data-copy="E_{m+1} = P(α_{m+1}) E_m = A_m (ê(α_{m+1})^T ê(α_m)) ê(α_{m+1})">
            <header>
              <div class="row">
                <strong>One-step update</strong>
                <button class="btn small copyBtn">Copy</button>
              </div>
            </header>
            <pre>E_{m+1} = P(α_{m+1}) E_m
        = A_m ( ê(α_{m+1})ᵀ ê(α_m) ) ê(α_{m+1})</pre>
          </div>

          <p>
            The dot product of unit vectors is the cosine of the angle between them:
            <code>ê(α_{m+1})^T ê(α_m) = cos(α_{m+1}-α_m)</code>.
            Since <code>α_{m+1} - α_m = θ</code>, we get:
          </p>

          <div class="eq" data-copy="E_{m+1} = A_m cos(θ) ê(α_{m+1})  ⇒  A_{m+1} = A_m cos(θ)">
            <header>
              <div class="row">
                <strong>Consecutive polarizers differ by θ</strong>
                <button class="btn small copyBtn">Copy</button>
              </div>
            </header>
            <pre>E_{m+1} = A_m cos(θ) ê(α_{m+1})
⇒ A_{m+1} = A_m cos(θ)</pre>
          </div>

          <p>
            <b>Explanation:</b> Each polarizer transmits only the component along its axis. Because each axis is rotated by the same angle θ from the previous one, the transmitted <b>amplitude</b> is multiplied by <code>cos θ</code> at every step.
          </p>

          <h3>Step 3: Apply the recursion across N polarizers</h3>
          <p>
            The input is x-polarized:
            <code>E_in = E0 ê(0)</code>.
            After the first polarizer (axis <code>α_1 = θ</code>), the amplitude becomes:
            <code>A_1 = E0 cos(θ)</code>.
            Repeating the recursion,
          </p>

          <div class="eq" data-copy="A_N = E0 (cos θ)^N">
            <header>
              <div class="row">
                <strong>Amplitude after N polarizers</strong>
                <button class="btn small copyBtn">Copy</button>
              </div>
            </header>
            <pre>A_N = E0 (cos θ)^N</pre>
          </div>

          <p>
            Meanwhile, the polarization direction after the N-th polarizer is along its axis:
            <code>ê(α_N)</code> with <code>α_N = Nθ</code>.
            Using <code>θ = π/(2N)</code> gives:
            <code>α_N = N·π/(2N) = π/2</code>, i.e. the <b>y-axis</b>.
          </p>

          <div class="callout">
            <div class="tag good"><span class="dot"></span><b>Final field (boxed)</b></div>
            <p style="margin:8px 0 6px;">
              The transmitted field is linearly polarized in the <b>y</b> direction with reduced amplitude:
            </p>
            <div class="eq" data-copy="E_out = E0 (cos(π/(2N)))^N [0,1]^T ;  I_out/I_in = (cos^2(π/(2N)))^N">
              <header>
                <div class="row">
                  <strong>FINAL RESULT</strong>
                  <button class="btn small copyBtn">Copy</button>
                </div>
              </header>
              <pre>E_out = E0 (cos θ)^N ê(π/2) = E0 (cos θ)^N [0, 1]^T
with θ = π/(2N)

Intensity ratio:
I_out / I_in = (cos² θ)^N = (cos²(π/(2N)))^N</pre>
            </div>
          </div>

          <h3>Step 4: Limit as N → ∞</h3>
          <p>
            Here θ shrinks with N: <code>θ = π/(2N)</code>. Use the small-angle expansion <code>cos θ ≈ 1 - θ²/2</code>:
          </p>

          <div class="eq" data-copy="(cos θ)^N ≈ (1 - θ^2/2)^N ≈ exp(-N θ^2/2)">
            <header>
              <div class="row">
                <strong>Asymptotic estimate</strong>
                <button class="btn small copyBtn">Copy</button>
              </div>
            </header>
            <pre>(cos θ)^N ≈ (1 - θ²/2)^N ≈ exp( -N θ²/2 )</pre>
          </div>

          <p>
            Substitute <code>θ = π/(2N)</code>:
            <code>N θ²/2 = N (π²/(4N²))/2 = π²/(8N)</code>.
            Therefore
            <code>(cos(π/(2N)))^N ≈ exp(-π²/(8N)) → 1</code> as <code>N → ∞</code>.
          </p>

          <div class="eq" data-copy="lim_{N→∞} (cos(π/(2N)))^N = 1">
            <header>
              <div class="row">
                <strong>Limit result</strong>
                <button class="btn small copyBtn">Copy</button>
              </div>
            </header>
            <pre>lim_{N→∞} (cos(π/(2N)))^N = 1</pre>
          </div>

          <p>
            <b>Interpretation:</b> In the idealized model, using many polarizers with infinitesimally small angle steps can rotate polarization from x to y with arbitrarily small loss. (Real polarizers add absorption/scatter, so practical losses do not vanish.)
          </p>

          <h3>Sanity checks</h3>
          <ul>
            <li><b>Units:</b> <code>cos θ</code> is dimensionless, so the amplitude scaling <code>(cos θ)^N</code> is dimensionless (correct).</li>
            <li><b>Limiting case N=1:</b> θ = π/2 → <code>(cos θ)^1 = 0</code>. One polarizer at 90° blocks x-polarized light completely (correct).</li>
            <li><b>Large N:</b> θ small → each step loses little → output approaches full amplitude (matches intuition and plots).</li>
            <li><b>Direction:</b> Final axis is y, so output must be y-polarized (assuming any light transmits).</li>
          </ul>
        </section>

        <section id="part4">
          <h2>PART 4 — Deeper Understanding (Theory Around the Result)</h2>

          <h3>Re-interpreting the formula</h3>
          <p>
            The amplitude factor <code>(cos θ)^N</code> has two competing effects:
          </p>
          <ul>
            <li><b>Per-step loss:</b> smaller θ makes <code>cos θ</code> closer to 1 (less loss each time).</li>
            <li><b>More steps:</b> larger N increases how many times you multiply by <code>cos θ</code>.</li>
          </ul>
          <p>
            In this problem, θ is tied to N by <code>θ = π/(2N)</code>. That coupling makes the per-step loss shrink faster than the number of steps grows, so the total loss vanishes in the limit.
          </p>

          <h3>Parameter effects (connect to the visuals)</h3>
          <ul>
            <li>As <b>N increases</b>, θ decreases, so the curve of <code>A_N/E0 = (cos(π/(2N)))^N</code> rises toward 1.</li>
            <li>The <b>intensity</b> rises even faster toward 1 because it is the square of amplitude: <code>I_out/I_in = (A_N/E0)^2</code>.</li>
            <li>The asymptotic estimate <code>exp(-π²/(8N))</code> becomes very accurate for large N; the secondary plot shows its relative error.</li>
          </ul>

          <h3>Alternative derivation idea (brief)</h3>
          <p>
            You can derive the same result without matrices by chaining Malus’ law:
            each consecutive pair differs by θ, so <code>I_{m+1} = I_m cos² θ</code>.
            After N steps, <code>I_out/I_in = (cos² θ)^N</code> → take square root for amplitude.
            Jones calculus is richer because it preserves phase and polarization direction explicitly.
          </p>

          <h3>Concept checks (quick self-test)</h3>
          <ul>
            <li><b>Q:</b> Why does the final polarization not depend on the earlier polarizers’ details? <br><b>A:</b> The last ideal polarizer forces the field to lie along its axis (or be zero).</li>
            <li><b>Q:</b> What is the amplitude reduction for a single jump from x to y? <br><b>A:</b> <code>cos(π/2)=0</code> → zero transmission.</li>
            <li><b>Q:</b> If the step angle were fixed (θ constant) and N grew, what would happen? <br><b>A:</b> <code>(cos θ)^N → 0</code> for any θ≠0, so transmission would vanish.</li>
            <li><b>Q:</b> In real experiments, why doesn’t transmission approach 1 for huge N? <br><b>A:</b> Real polarizers have absorption/scatter even along the axis; additional components (reflections, imperfect extinction) introduce losses not captured by the ideal projector model.</li>
          </ul>
        </section>

        <section id="part5">
          <h2>PART 5 — Visualization Guide (How to Read the Plots)</h2>
          <ul>
            <li><b>Diagram canvas:</b> Shows the x–y axes, the input polarization (x), the sequence of polarizer axes at angles <code>mθ</code>, and the output axis (y). As you change <b>N</b>, the step size θ changes and the fan of axes becomes denser.</li>
            <li><b>Main plot:</b> The amplitude ratio <code>A_N/E0 = (cos(π/(2N)))^N</code> versus N. A marker highlights the current N.</li>
            <li><b>Secondary plot:</b> The relative error between the exact amplitude factor and its large-N approximation <code>exp(-π²/(8N))</code>. It should shrink as N increases.</li>
            <li><b>Interactive control:</b> The slider changes <b>N</b>. All canvases update live, including the computed θ, amplitude ratio, and intensity ratio readouts.</li>
          </ul>
        </section>
      </div>
    </article>

    <aside class="card toc" aria-label="Table of contents">
      <div class="content">
        <small><b>On this page</b> (sticky)</small>
        <a href="#quick-summary">Quick Summary</a>
        <a href="#part0">PART 0 — Concept Primer</a>
        <a href="#part1">PART 1 — Problem Analysis</a>
        <a href="#part2">PART 2 — Strategy &amp; Tips</a>
        <a href="#part3">PART 3 — Full Solution</a>
        <a href="#part4">PART 4 — Deeper Understanding</a>
        <a href="#part5">PART 5 — Visualization Guide</a>
        <a href="#visuals">Interactive Visualizations</a>
      </div>
    </aside>
  </div>

  <article class="card" id="visuals">
    <div class="viz">
      <div class="vizpanel">
        <header>
          <div class="row">
            <div class="title">Diagram — Rotating Polarizer Axes (x → y)</div>
            <button class="btn small" id="copyKeyEqBtn" title="Copy the main amplitude formula">Copy Key Formula</button>
          </div>
        </header>
        <canvas id="diagramCanvas"></canvas>
        <div class="controls">
          <div class="control">
            <label for="nSlider">Number of polarizers <b>N</b> <span id="nVal">20</span></label>
            <input id="nSlider" type="range" min="1" max="250" value="20" step="1" />
          </div>
          <div class="control" style="min-width: 240px;">
            <label>Computed step angle <span id="thetaVal">—</span></label>
            <label>Amplitude ratio <span id="ampVal">—</span></label>
          </div>
          <div class="control" style="min-width: 240px;">
            <label>Intensity ratio <span id="intVal">—</span></label>
            <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
              <button class="btn small" id="setN1Btn" title="Set N=1">N=1</button>
              <button class="btn small" id="setN10Btn" title="Set N=10">N=10</button>
              <button class="btn small" id="setN100Btn" title="Set N=100">N=100</button>
            </div>
          </div>
        </div>
        <div class="readout" id="readoutLine">—</div>
      </div>

      <div class="vizpanel">
        <header>
          <div class="row">
            <div class="title">Main Plot — Amplitude Factor vs N</div>
            <button class="btn small" id="toggleApproxBtn" title="Toggle asymptotic approximation curve">Toggle Approx</button>
          </div>
        </header>
        <canvas id="mainPlotCanvas"></canvas>
        <header style="border-top:1px solid rgba(255,255,255,.10);">
          <div class="row">
            <div class="title">Secondary Plot — Relative Error (Exact vs Approx)</div>
            <button class="btn small" id="toggleIntensityBtn" title="Toggle showing intensity in main plot readout">Toggle Intensity Readout</button>
          </div>
        </header>
        <canvas id="secondaryPlotCanvas"></canvas>
      </div>
    </div>
  </article>
</main>

<footer>
  <div>
    Built with vanilla HTML/CSS/JS. Mathematical expressions are shown in monospace text (no MathJax).
  </div>
</footer>

<script>
(() => {
  // ---------- Utilities ----------
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
  const fmt = (x, digits=6) => {
    if (!isFinite(x)) return "—";
    const ax = Math.abs(x);
    if (ax !== 0 && (ax < 1e-4 || ax >= 1e6)) return x.toExponential(3);
    return x.toFixed(digits).replace(/\.?0+$/,'');
  };
  const rad2deg = r => r * 180 / Math.PI;

  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      flashToast("Copied!");
    }catch(e){
      // Fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      flashToast("Copied!");
    }
  }

  let toastTimer = null;
  function flashToast(msg){
    let t = document.getElementById("toast");
    if(!t){
      t = document.createElement("div");
      t.id = "toast";
      t.style.position = "fixed";
      t.style.left = "50%";
      t.style.bottom = "18px";
      t.style.transform = "translateX(-50%)";
      t.style.padding = "10px 12px";
      t.style.borderRadius = "12px";
      t.style.background = "rgba(0,0,0,.70)";
      t.style.border = "1px solid rgba(255,255,255,.22)";
      t.style.color = "rgba(233,238,255,.96)";
      t.style.fontWeight = "700";
      t.style.fontSize = ".9rem";
      t.style.zIndex = 999;
      t.style.backdropFilter = "blur(8px)";
      t.style.boxShadow = "0 12px 30px rgba(0,0,0,.35)";
      t.style.opacity = "0";
      t.style.transition = "opacity .15s ease, transform .15s ease";
      document.body.appendChild(t);
    }
    t.textContent = msg;
    t.style.opacity = "1";
    t.style.transform = "translateX(-50%) translateY(-2px)";
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => {
      t.style.opacity = "0";
      t.style.transform = "translateX(-50%) translateY(0px)";
    }, 900);
  }

  // Copy buttons for equations
  document.querySelectorAll(".eq .copyBtn").forEach(btn => {
    btn.addEventListener("click", (e) => {
      const eq = e.target.closest(".eq");
      const txt = eq.getAttribute("data-copy") || eq.innerText;
      copyText(txt.trim());
    });
  });

  // Jump to visuals
  document.getElementById("scrollVizBtn").addEventListener("click", () => {
    document.getElementById("visuals").scrollIntoView({behavior:"smooth", block:"start"});
  });

  // Copy final answer (plain text)
  const FINAL_TEXT =
`For N ideal polarizers with axes α_m = mθ (m=1..N), θ = π/(2N), input E_in = [E0,0]^T:

E_out = E0 (cos θ)^N [0,1]^T  (i.e., y-polarized)

Amplitude factor: A_N/E0 = (cos θ)^N = (cos(π/(2N)))^N
Intensity ratio: I_out/I_in = (cos^2 θ)^N = (cos^2(π/(2N)))^N

Limit: lim_{N→∞} (cos(π/(2N)))^N = 1  (and intensity ratio → 1).`;

  document.getElementById("copyFinalBtn").addEventListener("click", () => copyText(FINAL_TEXT));
  document.getElementById("copyKeyEqBtn").addEventListener("click", () =>
    copyText("A_N/E0 = (cos(π/(2N)))^N ;  I_out/I_in = (cos^2(π/(2N)))^N")
  );

  // ---------- Model functions ----------
  function thetaFromN(N){ return Math.PI/(2*N); }
  function ampRatio(N){
    const th = thetaFromN(N);
    return Math.pow(Math.cos(th), N);
  }
  function intensityRatio(N){
    const a = ampRatio(N);
    return a*a;
  }
  function ampApprox(N){
    // exp(-pi^2/(8N)) from small-angle expansion
    return Math.exp(- (Math.PI*Math.PI)/(8*N));
  }
  function relErrorExactApprox(N){
    const ex = ampRatio(N);
    const ap = ampApprox(N);
    if (ex === 0) return 0;
    return (ap - ex)/ex;
  }

  // ---------- Canvas helpers ----------
  function setupCanvas(canvas){
    const ctx = canvas.getContext("2d");
    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(10, Math.floor(rect.width));
      const h = Math.max(10, Math.floor(rect.height));
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      return {w, h, dpr};
    }
    return {ctx, resize};
  }

  function drawGrid(ctx, x0, y0, w, h, xTicks, yTicks){
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,.10)";
    ctx.lineWidth = 1;
    for(let i=0;i<=xTicks;i++){
      const x = x0 + (w*i/xTicks);
      ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+h); ctx.stroke();
    }
    for(let j=0;j<=yTicks;j++){
      const y = y0 + (h*j/yTicks);
      ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+w,y); ctx.stroke();
    }
    ctx.restore();
  }

  function drawAxes(ctx, x0, y0, w, h, xlabel, ylabel){
    ctx.save();
    ctx.strokeStyle = "rgba(233,238,255,.65)";
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.rect(x0,y0,w,h);
    ctx.stroke();
    ctx.fillStyle = "rgba(233,238,255,.90)";
    ctx.font = "12px ui-sans-serif, system-ui";
    ctx.fillText(xlabel, x0 + w - 6 - ctx.measureText(xlabel).width, y0 + h + 16);
    ctx.save();
    ctx.translate(x0 - 26, y0 + 10);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(ylabel, 0, 0);
    ctx.restore();
    ctx.restore();
  }

  function niceTicks(min, max, count){
    // simple tick generator
    if (min === max) return {min, max, step:1};
    const span = max - min;
    const raw = span / count;
    const pow10 = Math.pow(10, Math.floor(Math.log10(raw)));
    const candidates = [1,2,5,10].map(m => m*pow10);
    let step = candidates[0];
    for(const c of candidates){
      if (raw <= c){ step = c; break; }
    }
    const tmin = Math.floor(min/step)*step;
    const tmax = Math.ceil(max/step)*step;
    return {min:tmin, max:tmax, step};
  }

  function plotLine(ctx, box, xs, ys, color, width=2){
    const {x0,y0,w,h,xMin,xMax,yMin,yMax} = box;
    const X = x => x0 + (x - xMin) * (w/(xMax-xMin));
    const Y = y => y0 + h - (y - yMin) * (h/(yMax-yMin));
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.beginPath();
    for(let i=0;i<xs.length;i++){
      const px = X(xs[i]);
      const py = Y(ys[i]);
      if(i===0) ctx.moveTo(px,py);
      else ctx.lineTo(px,py);
    }
    ctx.stroke();
    ctx.restore();
  }

  function plotPoints(ctx, box, x, y, color){
    const {x0,y0,w,h,xMin,xMax,yMin,yMax} = box;
    const X = x => x0 + (x - xMin) * (w/(xMax-xMin));
    const Y = y => y0 + h - (y - yMin) * (h/(yMax-yMin));
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(X(x), Y(y), 5, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function labelTicks(ctx, box, xTick, yTick){
    const {x0,y0,w,h,xMin,xMax,yMin,yMax} = box;
    const X = x => x0 + (x - xMin) * (w/(xMax-xMin));
    const Y = y => y0 + h - (y - yMin) * (h/(yMax-yMin));
    ctx.save();
    ctx.fillStyle = "rgba(233,238,255,.88)";
    ctx.font = "12px ui-sans-serif, system-ui";
    // x ticks
    for(let x = xTick.min; x <= xTick.max + 1e-12; x += xTick.step){
      const px = X(x);
      ctx.strokeStyle = "rgba(233,238,255,.45)";
      ctx.beginPath(); ctx.moveTo(px, y0+h); ctx.lineTo(px, y0+h+6); ctx.stroke();
      const s = (Math.abs(x) < 1e-10) ? "0" : (Number.isInteger(x) ? String(x) : fmt(x,2));
      const tw = ctx.measureText(s).width;
      ctx.fillText(s, px - tw/2, y0+h+18);
    }
    // y ticks
    for(let y = yTick.min; y <= yTick.max + 1e-12; y += yTick.step){
      const py = Y(y);
      ctx.strokeStyle = "rgba(233,238,255,.45)";
      ctx.beginPath(); ctx.moveTo(x0-6, py); ctx.lineTo(x0, py); ctx.stroke();
      const s = (Math.abs(y) < 1e-10) ? "0" : fmt(y,2);
      const tw = ctx.measureText(s).width;
      ctx.fillText(s, x0 - 10 - tw, py + 4);
    }
    ctx.restore();
  }

  function legend(ctx, x, y, items){
    ctx.save();
    ctx.font = "12px ui-sans-serif, system-ui";
    const pad = 10;
    let w = 0;
    for(const it of items){
      const tw = ctx.measureText(it.label).width;
      w = Math.max(w, 18 + 8 + tw);
    }
    const h = items.length * 18 + pad*2 - 2;
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(x, y, w + pad*2, h, 12);
    ctx.fill(); ctx.stroke();

    items.forEach((it, i) => {
      const yy = y + pad + i*18 + 6;
      ctx.strokeStyle = it.color;
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(x+pad, yy); ctx.lineTo(x+pad+18, yy); ctx.stroke();
      ctx.fillStyle = "rgba(233,238,255,.92)";
      ctx.fillText(it.label, x+pad+26, yy+4);
    });
    ctx.restore();
  }

  // Polyfill: roundRect for older browsers
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    };
  }

  // ---------- Canvases ----------
  const diagram = setupCanvas(document.getElementById("diagramCanvas"));
  const mainPlot = setupCanvas(document.getElementById("mainPlotCanvas"));
  const secondaryPlot = setupCanvas(document.getElementById("secondaryPlotCanvas"));

  let showApprox = true;
  let showIntensityReadout = true;

  // Controls
  const nSlider = document.getElementById("nSlider");
  const nVal = document.getElementById("nVal");
  const thetaVal = document.getElementById("thetaVal");
  const ampVal = document.getElementById("ampVal");
  const intVal = document.getElementById("intVal");
  const readoutLine = document.getElementById("readoutLine");

  document.getElementById("setN1Btn").addEventListener("click", () => { nSlider.value = 1; updateAll(); });
  document.getElementById("setN10Btn").addEventListener("click", () => { nSlider.value = 10; updateAll(); });
  document.getElementById("setN100Btn").addEventListener("click", () => { nSlider.value = 100; updateAll(); });

  document.getElementById("toggleApproxBtn").addEventListener("click", () => { showApprox = !showApprox; updateAll(); });
  document.getElementById("toggleIntensityBtn").addEventListener("click", () => { showIntensityReadout = !showIntensityReadout; updateAll(); });

  nSlider.addEventListener("input", updateAll);

  function updateReadout(N){
    const th = thetaFromN(N);
    const a = ampRatio(N);
    const I = a*a;
    nVal.textContent = String(N);
    thetaVal.textContent = `${fmt(th,6)} rad (${fmt(rad2deg(th),3)}°)`;
    ampVal.textContent = `${fmt(a,6)} (A_N/E0)`;
    intVal.textContent = `${fmt(I,6)} (I_out/I_in)`;

    const approx = ampApprox(N);
    const err = relErrorExactApprox(N);
    const extra = showIntensityReadout ? `; intensity ratio ≈ ${fmt(I,6)}` : "";
    readoutLine.textContent =
      `θ = π/(2N) = ${fmt(th,6)} rad; A_N/E0 = (cos θ)^N = ${fmt(a,6)}; approx exp(-π²/(8N)) = ${fmt(approx,6)}; rel. error = ${fmt(err,6)}${extra}`;
  }

  // ---------- Diagram drawing ----------
  function drawDiagram(N){
    const {ctx} = diagram;
    const {w,h} = diagram.resize();

    // Background
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "rgba(0,0,0,.12)";
    ctx.fillRect(0,0,w,h);

    // Margins
    const pad = 16;
    const cx = w*0.38;
    const cy = h*0.55;
    const R = Math.min(w,h)*0.34;

    // Title
    ctx.save();
    ctx.fillStyle = "rgba(233,238,255,.92)";
    ctx.font = "700 13px ui-sans-serif, system-ui";
    ctx.fillText("Polarizer axes αm = mθ (θ = π/(2N))", pad, 18);
    ctx.restore();

    // Axes
    ctx.save();
    ctx.strokeStyle = "rgba(233,238,255,.55)";
    ctx.lineWidth = 1.6;
    ctx.beginPath(); ctx.moveTo(cx-R, cy); ctx.lineTo(cx+R, cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx, cy+R); ctx.lineTo(cx, cy-R); ctx.stroke();

    // Tick marks on axes
    ctx.strokeStyle = "rgba(255,255,255,.20)";
    for(let k=-4;k<=4;k++){
      const tx = cx + (k*R/4);
      ctx.beginPath(); ctx.moveTo(tx, cy-4); ctx.lineTo(tx, cy+4); ctx.stroke();
      const ty = cy + (k*R/4);
      ctx.beginPath(); ctx.moveTo(cx-4, ty); ctx.lineTo(cx+4, ty); ctx.stroke();
    }

    // Labels
    ctx.fillStyle = "rgba(233,238,255,.85)";
    ctx.font = "12px ui-sans-serif, system-ui";
    ctx.fillText("x", cx+R+8, cy+4);
    ctx.fillText("y", cx-4, cy-R-10);
    ctx.restore();

    // Draw input polarization (x)
    function arrow(x1,y1,x2,y2,color,label){
      const dx=x2-x1, dy=y2-y1;
      const L = Math.hypot(dx,dy) || 1;
      const ux=dx/L, uy=dy/L;
      ctx.save();
      ctx.strokeStyle=color;
      ctx.fillStyle=color;
      ctx.lineWidth=3;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      // head
      const ah=10;
      const aw=6;
      ctx.beginPath();
      ctx.moveTo(x2,y2);
      ctx.lineTo(x2 - ah*ux + aw*(-uy), y2 - ah*uy + aw*(ux));
      ctx.lineTo(x2 - ah*ux - aw*(-uy), y2 - ah*uy - aw*(ux));
      ctx.closePath();
      ctx.fill();
      if(label){
        ctx.font="12px ui-sans-serif, system-ui";
        ctx.fillText(label, x2+8, y2+4);
      }
      ctx.restore();
    }

    // Input arrow
    arrow(cx- R*0.95, cy, cx- R*0.35, cy, "rgba(122,167,255,.95)", "E in (x)");

    // Output arrow (y)
    arrow(cx, cy+ R*0.35, cx, cy+ R*0.95, "rgba(110,240,196,.95)", "E out (y)");

    // Polarizer axes fan: show up to a maximum number to keep it readable
    const th = thetaFromN(N);
    const maxLines = 42;
    const step = Math.max(1, Math.floor(N / maxLines));

    ctx.save();
    // draw a faint circle
    ctx.strokeStyle = "rgba(255,255,255,.10)";
    ctx.lineWidth=1;
    ctx.beginPath(); ctx.arc(cx,cy,R*0.98,0,Math.PI*2); ctx.stroke();

    for(let m=1;m<=N;m+=step){
      const a = m*th;
      const x1 = cx - Math.cos(a)*R*0.95;
      const y1 = cy + Math.sin(a)*R*0.95;
      const x2 = cx + Math.cos(a)*R*0.95;
      const y2 = cy - Math.sin(a)*R*0.95;

      // fade from first to last
      const t = m / N;
      const alpha = 0.20 + 0.55*t;
      ctx.strokeStyle = `rgba(255,204,102,${alpha})`;
      ctx.lineWidth = (m === N ? 3.5 : 2.0);
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    }
    ctx.restore();

    // Annotate θ step
    ctx.save();
    ctx.fillStyle = "rgba(233,238,255,.86)";
    ctx.font = "12px ui-sans-serif, system-ui";
    const msg = `N=${N}, θ=π/(2N)=${fmt(th,5)} rad`;
    ctx.fillText(msg, pad, h - 12);
    ctx.restore();
  }

  // ---------- Plot drawing ----------
  function drawMainPlot(N){
    const {ctx} = mainPlot;
    const {w,h} = mainPlot.resize();
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "rgba(0,0,0,.12)";
    ctx.fillRect(0,0,w,h);

    // Plot box
    const margin = {l:58, r:18, t:30, b:44};
    const x0 = margin.l, y0 = margin.t;
    const pw = w - margin.l - margin.r;
    const ph = h - margin.t - margin.b;

    // Data
    const Nmax = 250;
    const xs = [];
    const ys = [];
    const ya = [];
    for(let k=1;k<=Nmax;k++){
      xs.push(k);
      ys.push(ampRatio(k));
      ya.push(ampApprox(k));
    }

    // y range
    let yMin = 0, yMax = 1.02;
    // box definition
    const box = {x0,y0,w:pw,h:ph,xMin:1,xMax:Nmax,yMin,yMax};

    // Grid and axes
    drawGrid(ctx, x0, y0, pw, ph, 10, 8);
    drawAxes(ctx, x0, y0, pw, ph, "N (count)", "Amplitude ratio A_N/E0 (unitless)");

    // Ticks
    const xTick = niceTicks(1, Nmax, 10);
    const yTick = niceTicks(0, 1, 8);
    labelTicks(ctx, box, xTick, yTick);

    // Title
    ctx.save();
    ctx.fillStyle = "rgba(233,238,255,.92)";
    ctx.font = "700 13px ui-sans-serif, system-ui";
    const title = "A_N/E0 = (cos(π/(2N)))^N";
    ctx.fillText(title, x0, 18);
    ctx.restore();

    // Curves
    plotLine(ctx, box, xs, ys, "rgba(122,167,255,.95)", 2.6);
    if(showApprox){
      plotLine(ctx, box, xs, ya, "rgba(110,240,196,.95)", 2.2);
      legend(ctx, x0 + 12, y0 + 12, [
        {label:"Exact", color:"rgba(122,167,255,.95)"},
        {label:"Approx exp(-π²/(8N))", color:"rgba(110,240,196,.95)"}
      ]);
    } else {
      legend(ctx, x0 + 12, y0 + 12, [
        {label:"Exact", color:"rgba(122,167,255,.95)"}
      ]);
    }

    // Current N marker
    plotPoints(ctx, box, N, ampRatio(N), "rgba(255,204,102,.95)");
  }

  function drawSecondaryPlot(N){
    const {ctx} = secondaryPlot;
    const {w,h} = secondaryPlot.resize();
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "rgba(0,0,0,.12)";
    ctx.fillRect(0,0,w,h);

    const margin = {l:58, r:18, t:30, b:44};
    const x0 = margin.l, y0 = margin.t;
    const pw = w - margin.l - margin.r;
    const ph = h - margin.t - margin.b;

    const Nmax = 250;
    const xs = [];
    const ys = [];
    let ymin = Infinity, ymax = -Infinity;
    for(let k=2;k<=Nmax;k++){ // start at 2 to avoid extreme at N=1
      const e = relErrorExactApprox(k);
      xs.push(k);
      ys.push(e);
      ymin = Math.min(ymin, e);
      ymax = Math.max(ymax, e);
    }
    // Symmetric y-limits around 0 for readability
    const A = Math.max(Math.abs(ymin), Math.abs(ymax), 1e-6);
    const yMin = -A*1.10;
    const yMax =  A*1.10;

    const box = {x0,y0,w:pw,h:ph,xMin:2,xMax:Nmax,yMin,yMax};

    drawGrid(ctx, x0, y0, pw, ph, 10, 8);
    drawAxes(ctx, x0, y0, pw, ph, "N (count)", "Relative error (unitless)");
    const xTick = niceTicks(2, Nmax, 10);
    const yTick = niceTicks(yMin, yMax, 8);
    labelTicks(ctx, box, xTick, yTick);

    // Zero line
    ctx.save();
    const Y0 = y0 + ph - (0 - yMin) * (ph/(yMax-yMin));
    ctx.strokeStyle = "rgba(233,238,255,.35)";
    ctx.lineWidth = 1.6;
    ctx.beginPath(); ctx.moveTo(x0, Y0); ctx.lineTo(x0+pw, Y0); ctx.stroke();
    ctx.restore();

    // Title
    ctx.save();
    ctx.fillStyle = "rgba(233,238,255,.92)";
    ctx.font = "700 13px ui-sans-serif, system-ui";
    ctx.fillText("Relative error: (approx − exact)/exact", x0, 18);
    ctx.restore();

    plotLine(ctx, box, xs, ys, "rgba(255,107,122,.92)", 2.2);

    // Current marker (clamp if N=1)
    const Np = Math.max(2, N);
    plotPoints(ctx, box, Np, relErrorExactApprox(Np), "rgba(255,204,102,.95)");

    legend(ctx, x0 + 12, y0 + 12, [
      {label:"Rel. error", color:"rgba(255,107,122,.92)"},
      {label:"Current N", color:"rgba(255,204,102,.95)"}
    ]);
  }

  function updateAll(){
    const N = parseInt(nSlider.value, 10);
    updateReadout(N);
    drawDiagram(N);
    drawMainPlot(N);
    drawSecondaryPlot(N);
  }

  // Handle resizing
  let resizeTimer = null;
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(updateAll, 60);
  });

  // Toggle approx curve label
  document.getElementById("toggleApproxBtn").addEventListener("click", () => {
    flashToast(showApprox ? "Approx: ON" : "Approx: OFF");
  });
  document.getElementById("toggleIntensityBtn").addEventListener("click", () => {
    flashToast(showIntensityReadout ? "Intensity readout: ON" : "Intensity readout: OFF");
  });

  // Initial draw
  updateAll();
})();
</script>
</body>
</html>
