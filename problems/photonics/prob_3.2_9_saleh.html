<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Transmission of a Gaussian Beam Through a Graded-Index (SELFOC) Slab — ABCD Solution</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#101824;
      --panel2:#0f1620;
      --text:#eaf0f7;
      --muted:#a9b6c6;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --ok:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --border:rgba(255,255,255,0.09);
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 900px at 10% 0%, rgba(125,211,252,.14), transparent 55%),
        radial-gradient(1000px 700px at 90% 10%, rgba(167,139,250,.14), transparent 55%),
        radial-gradient(900px 700px at 40% 100%, rgba(52,211,153,.08), transparent 50%),
        var(--bg);
      line-height:1.55;
    }

    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    code, .eq{
      font-family:var(--mono);
      font-size:.96em;
      background:rgba(255,255,255,0.06);
      padding:.18em .42em;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.08);
      white-space:nowrap;
    }
    pre{
      font-family:var(--mono);
      background:rgba(255,255,255,0.04);
      border:1px solid rgba(255,255,255,0.08);
      border-radius:14px;
      padding:14px 14px;
      overflow:auto;
      margin:12px 0;
    }
    .wrap{
      max-width:1180px;
      margin:0 auto;
      padding:28px 18px 70px;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      align-items:start;
    }

    header{
      grid-column: 1 / -1;
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius: var(--radius);
      padding:20px 18px;
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    header:before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(800px 250px at 20% 0%, rgba(125,211,252,.17), transparent 60%),
                  radial-gradient(700px 220px at 80% 20%, rgba(167,139,250,.14), transparent 60%);
      opacity:.9;
      pointer-events:none;
    }
    header > * {position:relative}
    .title{
      display:flex;
      flex-wrap:wrap;
      gap:10px 12px;
      align-items:baseline;
      margin:0 0 8px;
    }
    h1{
      margin:0;
      font-size:1.45rem;
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size:.98rem;
      max-width: 980px;
    }

    .pillrow{margin-top:14px; display:flex; flex-wrap:wrap; gap:10px}
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.10);
      background:rgba(16,24,36,0.55);
      color:var(--muted);
      font-size:.92rem;
      backdrop-filter: blur(6px);
    }
    .dot{width:10px;height:10px;border-radius:50%}
    .dot.a{background:var(--accent)}
    .dot.b{background:var(--accent2)}
    .dot.c{background:var(--ok)}

    /* Sticky TOC */
    nav.toc{
      position:sticky;
      top:14px;
      align-self:start;
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius: var(--radius);
      padding:14px 14px 10px;
      box-shadow: var(--shadow);
    }
    nav.toc h2{
      margin:0 0 10px;
      font-size:1.02rem;
      letter-spacing:.2px;
      display:flex; align-items:center; gap:10px;
    }
    .toc small{color:var(--muted); font-weight:500}
    .toc a{
      display:block;
      padding:8px 10px;
      margin:4px 0;
      border-radius:12px;
      border:1px solid transparent;
      color:var(--text);
      background:rgba(255,255,255,0.03);
    }
    .toc a:hover{
      border-color:rgba(125,211,252,0.35);
      background:rgba(125,211,252,0.08);
      text-decoration:none;
    }

    main{
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius: var(--radius);
      padding:18px;
      box-shadow: var(--shadow);
    }
    section{
      padding:10px 0 18px;
      border-bottom:1px solid rgba(255,255,255,0.07);
    }
    section:last-child{border-bottom:none}
    h2{
      margin:0 0 10px;
      font-size:1.18rem;
      letter-spacing:.2px;
    }
    h3{
      margin:14px 0 8px;
      font-size:1.05rem;
      letter-spacing:.15px;
    }
    p{margin:8px 0; color:rgba(234,240,247,.95)}
    ul{margin:8px 0 0 18px; color:rgba(234,240,247,.95)}
    li{margin:6px 0}
    .muted{color:var(--muted)}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr}
      nav.toc{position:relative; top:auto}
      .grid2{grid-template-columns:1fr}
    }

    .card{
      background:rgba(12,18,28,0.55);
      border:1px solid rgba(255,255,255,0.09);
      border-radius: var(--radius);
      padding:14px 14px;
      box-shadow: 0 14px 50px rgba(0,0,0,.35);
      overflow:hidden;
    }
    .callout{
      border-left: 4px solid rgba(125,211,252,0.9);
      background:rgba(125,211,252,0.07);
    }
    .callout.warn{border-left-color:rgba(251,191,36,0.95); background:rgba(251,191,36,0.08)}
    .callout.ok{border-left-color:rgba(52,211,153,0.95); background:rgba(52,211,153,0.07)}
    .callout.bad{border-left-color:rgba(251,113,133,0.95); background:rgba(251,113,133,0.07)}

    .eqrow{
      display:flex;
      gap:10px;
      align-items:flex-start;
      flex-wrap:wrap;
      margin:10px 0;
    }

    .copyBtn{
      appearance:none;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.06);
      color:var(--text);
      padding:7px 10px;
      border-radius:12px;
      cursor:pointer;
      font-weight:600;
      font-size:.9rem;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
    }
    .copyBtn:hover{
      background:rgba(125,211,252,0.10);
      border-color: rgba(125,211,252,0.40);
      transform: translateY(-1px);
    }
    .copyBtn:active{transform: translateY(0px) scale(.99)}
    .copyBtn .mini{opacity:.85; font-weight:700}
    .toast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform:translateX(-50%);
      background:rgba(16,24,36,0.92);
      border:1px solid rgba(255,255,255,0.12);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: opacity .2s ease, transform .2s ease;
      font-weight:650;
      z-index:50;
    }
    .toast.show{opacity:1; transform:translateX(-50%) translateY(-4px)}
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width: 640px){
      .controls{grid-template-columns:1fr}
    }
    .ctrl{
      background:rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.08);
      border-radius:16px;
      padding:10px 10px;
    }
    .ctrl label{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      font-weight:700;
      font-size:.92rem;
      margin-bottom:6px;
    }
    .ctrl label span.value{
      color:var(--muted);
      font-family:var(--mono);
      font-weight:700;
      font-size:.92rem;
      white-space:nowrap;
    }
    input[type="range"]{width:100%}
    select{
      width:100%;
      background:rgba(16,24,36,0.8);
      border:1px solid rgba(255,255,255,0.12);
      color:var(--text);
      border-radius:12px;
      padding:8px 10px;
      font-weight:650;
      outline:none;
    }

    figure{
      margin:12px 0 0;
      padding:0;
    }
    .canvasCard{
      padding:12px;
    }
    canvas{
      width:100%;
      height:320px;
      display:block;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.10);
      background:rgba(0,0,0,0.18);
    }
    .cap{
      margin-top:8px;
      color:var(--muted);
      font-size:.92rem;
    }

    .boxed{
      border:1px solid rgba(125,211,252,0.35);
      background: rgba(125,211,252,0.08);
      border-radius: 16px;
      padding:12px 12px;
      overflow:auto;
    }
    .boxed .lead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom:6px;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-weight:800;
      font-size:.85rem;
      padding:6px 9px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(16,24,36,0.65);
      color:var(--muted);
    }
    .kpi{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 860px){ .kpi{grid-template-columns:1fr} }
    .kpi .item{
      background:rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.08);
      border-radius:16px;
      padding:10px;
    }
    .kpi .item .t{color:var(--muted); font-size:.86rem; font-weight:750}
    .kpi .item .v{font-family:var(--mono); font-weight:850; margin-top:6px}
    footer{
      grid-column:1 / -1;
      margin-top:14px;
      color:var(--muted);
      font-size:.92rem;
      text-align:center;
      padding:14px 6px 4px;
    }

    @media print{
      body{background:#fff; color:#000}
      header, main, nav.toc{box-shadow:none}
      header, main, nav.toc{border:1px solid #ddd}
      .copyBtn, .controls{display:none !important}
      canvas{border:1px solid #bbb}
      .muted{color:#333}
      a{color:#000; text-decoration:underline}
      code{border:1px solid #ddd}
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Gaussian Beam Through a Quadratic Graded-Index (SELFOC) Slab via ABCD</h1>
      </div>
      <p class="subtitle">
        A Gaussian beam enters a graded-index slab <span class="eq">n(y) ≈ n₀(1 − ½ a² y²)</span> at its waist. Using the slab’s ABCD matrix, we derive the beam width
        <span class="eq">w(d)</span> inside the medium, and visualize how the beam “breathes” periodically.
      </p>
      <div class="pillrow">
        <span class="pill"><span class="dot a"></span>ABCD law for Gaussian beams</span>
        <span class="pill"><span class="dot b"></span>Quadratic GRIN → sinusoidal ray matrix</span>
        <span class="pill"><span class="dot c"></span>Periodic beam-width oscillation (“breathing”)</span>
      </div>
    </header>

    <nav class="toc" aria-label="Table of contents">
      <h2>Contents <small>(sticky)</small></h2>
      <a href="#quick" data-scroll>Quick Summary</a>
      <a href="#part1" data-scroll>PART 1 — Problem Analysis</a>
      <a href="#part2" data-scroll>PART 2 — Strategy & Tips</a>
      <a href="#part3" data-scroll>PART 3 — Full Solution</a>
      <a href="#viz" data-scroll>Interactive Visualizations</a>
      <a href="#shape" data-scroll>Beam Shape Sketch & Interpretation</a>
    </nav>

    <main>
      <section id="quick">
        <h2>Quick Summary</h2>
        <div class="card callout ok">
          <ul>
            <li>The SELFOC slab has ABCD matrix: <span class="eq">A=D=cos(ad)</span>, <span class="eq">B=(1/a)sin(ad)</span>, <span class="eq">C=−a sin(ad)</span>.</li>
            <li>At the entrance plane, the beam is at a waist: <span class="eq">R=∞</span>, <span class="eq">w=W₀</span>, so <span class="eq">q₁ = i z<sub>R</sub></span>.</li>
            <li>Inside a medium of on-axis index <span class="eq">n₀</span>, use <span class="eq">z<sub>R</sub> = π n₀ W₀² / λ₀</span> (λ₀ = free-space wavelength).</li>
            <li>ABCD law: <span class="eq">q(d) = (A q₁ + B)/(C q₁ + D)</span>.</li>
            <li><b>Result:</b> <span class="eq">w(d) = W₀ √( cos²(ad) + [sin²(ad)]/(a² z<sub>R</sub>²) )</span> (periodic breathing with period <span class="eq">π/a</span>).</li>
          </ul>
        </div>
      </section>

      <section id="part1">
        <h2>PART 1 — Problem Analysis (no solving yet)</h2>

        <h3>1) Restate the problem</h3>
        <p>
          A Gaussian beam (free-space wavelength <span class="eq">λ₀</span>) propagates along the <span class="eq">z</span>-axis and enters a graded-index slab of length <span class="eq">d</span>.
          The slab has a quadratic refractive-index profile in the transverse coordinate <span class="eq">y</span>:
          <span class="eq">n(y) ≈ n₀(1 − ½ a² y²)</span>.
          The beam enters exactly at its waist (so the wavefront is planar at the entrance plane).
          Using the provided ABCD matrix for paraxial propagation in this SELFOC slab, we must find the beam width <span class="eq">w(d)</span> in the <span class="eq">y</span>-direction as a function of the slab length <span class="eq">d</span>, and sketch how the beam size evolves as it travels through the medium.
        </p>

        <h3>2) Given quantities</h3>
        <ul>
          <li>Index profile: <span class="eq">n(y) ≈ n₀(1 − ½ a² y²)</span></li>
          <li>Slab length: <span class="eq">d</span></li>
          <li>ABCD matrix elements:
            <span class="eq">A = cos(ad)</span>,
            <span class="eq">B = (1/a) sin(ad)</span>,
            <span class="eq">C = −a sin(ad)</span>,
            <span class="eq">D = cos(ad)</span>
          </li>
          <li>Beam wavelength in free space: <span class="eq">λ₀</span></li>
          <li>Beam waist radius at entrance: <span class="eq">W₀</span></li>
          <li>Beam enters at its waist: <span class="eq">R(0)=∞</span>, <span class="eq">w(0)=W₀</span></li>
        </ul>

        <h3>3) Unknowns</h3>
        <ul>
          <li>Beam radius (1/e field radius) inside the slab as a function of propagation distance: <span class="eq">w(d)</span></li>
          <li>Qualitative shape (“sketch”) of beam envelope through the GRIN medium</li>
        </ul>

        <h3>4) What must be found</h3>
        <ul>
          <li>Symbolic expression for <span class="eq">w(d)</span> using the ABCD law for Gaussian beams</li>
          <li>Sketch/description of the beam’s periodic focusing/defocusing inside the slab</li>
        </ul>

        <h3>5) Relevant physical principles (and why they apply)</h3>
        <div class="grid2">
          <div class="card">
            <h3 style="margin-top:0">Paraxial optics in GRIN media</h3>
            <p class="muted">
              A quadratic index profile produces harmonic-oscillator-like ray trajectories.
              In paraxial form, propagation through such a medium is represented by a simple sinusoidal ABCD matrix.
            </p>
          </div>
          <div class="card">
            <h3 style="margin-top:0">ABCD law for Gaussian beams</h3>
            <p class="muted">
              A Gaussian beam is fully characterized (paraxially) by its complex beam parameter <span class="eq">q</span>.
              Under any first-order optical system (ABCD), <span class="eq">q</span> transforms via a Möbius map.
              From <span class="eq">q(d)</span> we extract the spot size <span class="eq">w(d)</span>.
            </p>
          </div>
        </div>

        <h3>6) Possible approaches (compare 2–3)</h3>
        <ol>
          <li><b>ABCD + q-parameter (best):</b> Use <span class="eq">q(d)=(Aq₀+B)/(Cq₀+D)</span>, then compute <span class="eq">w(d)</span> from <span class="eq">q(d)</span>. Fast, standard, directly matches the problem statement.</li>
          <li><b>Wave equation / paraxial Helmholtz:</b> Solve the paraxial equation with a quadratic potential (GRIN), giving a “breathing Gaussian” solution. Elegant but longer and not what the prompt asks for.</li>
          <li><b>Second-moment (ABCD for moments):</b> Propagate beam moments (like <span class="eq">⟨y²⟩</span>) through an equivalent linear canonical transform. Works but still effectively re-derives the q-law.</li>
        </ol>

        <h3>Chosen approach</h3>
        <div class="card callout">
          <p>
            We will use the <b>ABCD law for Gaussian beams</b> because the slab’s ABCD matrix is explicitly given, and the beam enters at a waist (simple initial condition). This yields a clean symbolic expression for <span class="eq">w(d)</span> with minimal overhead.
          </p>
        </div>
      </section>

      <section id="part2">
        <h2>PART 2 — Strategy & Tips (roadmap only)</h2>

        <div class="card">
          <h3 style="margin-top:0">Step-by-step plan (5–10 steps)</h3>
          <ol>
            <li><b>Define the Gaussian beam parameter:</b> use <span class="eq">1/q = 1/R − i (λ₀)/(π n₀ w²)</span> (inside the medium). Goal: relate <span class="eq">q</span> to <span class="eq">w</span>.</li>
            <li><b>Set initial condition at waist:</b> at the entrance plane, <span class="eq">R=∞</span>, <span class="eq">w=W₀</span> ⇒ <span class="eq">q₁ = i z_R</span>. Goal: get <span class="eq">z_R</span> in terms of <span class="eq">λ₀, n₀, W₀</span>.</li>
            <li><b>Use the given ABCD matrix:</b> write <span class="eq">A,B,C,D</span> for distance <span class="eq">d</span>. Goal: set up the transform.</li>
            <li><b>Apply ABCD law:</b> compute <span class="eq">q(d)=(Aq₁+B)/(Cq₁+D)</span>. Goal: express <span class="eq">q(d)</span> explicitly.</li>
            <li><b>Invert to get 1/q(d):</b> because <span class="eq">w(d)</span> depends on <span class="eq">Im(1/q)</span>. Goal: isolate the imaginary part.</li>
            <li><b>Extract w(d):</b> use <span class="eq">w²(d)= − (λ₀)/(π n₀) / Im(1/q(d))</span>. Goal: simplify the result using <span class="eq">z_R = π n₀ W₀²/λ₀</span>.</li>
            <li><b>Interpret:</b> show periodicity and limiting cases (<span class="eq">a→0</span>, <span class="eq">d→0</span>, strong/weak guiding). Goal: sanity checks.</li>
          </ol>
        </div>

        <div class="grid2" style="margin-top:12px;">
          <div class="card callout warn">
            <h3 style="margin-top:0">Common mistakes</h3>
            <ul>
              <li>Forgetting that inside a medium the diffraction term uses <span class="eq">λ₀/n₀</span>, which is why <span class="eq">z_R ∝ n₀</span>.</li>
              <li>Using <span class="eq">w</span> where the problem uses <span class="eq">W₀</span>; keep notation consistent: <span class="eq">W₀</span> is the input waist.</li>
              <li>Dropping the imaginary unit when setting <span class="eq">q</span> at the waist; at a waist, <span class="eq">q</span> is purely imaginary.</li>
            </ul>
          </div>
          <div class="card callout ok">
            <h3 style="margin-top:0">Quick tips</h3>
            <ul>
              <li>At waist: <span class="eq">q=i z_R</span> and <span class="eq">z_R = π n₀ W₀²/λ₀</span>.</li>
              <li>To get <span class="eq">w(d)</span> you only need <span class="eq">Im(1/q(d))</span>, not the full curvature.</li>
              <li>The result should “breathe” with frequency <span class="eq">a</span>; expect trigonometric dependence in <span class="eq">w(d)</span>.</li>
            </ul>
          </div>
        </div>
      </section>

      <section id="part3">
        <h2>PART 3 — Full Solution</h2>

        <h3>Physical intuition first</h3>
        <p>
          A quadratic graded-index medium acts like a continuous focusing system: rays oscillate sinusoidally about the axis.
          A Gaussian beam in such a medium remains Gaussian (paraxial regime) but its spot size typically <b>oscillates</b>—it
          periodically focuses and defocuses. The oscillation period is set by the GRIN strength parameter <span class="eq">a</span>.
        </p>

        <h3>1) Gaussian beam parameter in a medium</h3>
        <p>
          In a medium of (on-axis) refractive index <span class="eq">n₀</span>, the complex beam parameter <span class="eq">q</span> can be written as:
        </p>
        <div class="eqrow">
          <span class="eq" id="eq-qdef">1/q = 1/R − i (λ₀)/(π n₀ w²)</span>
          <button class="copyBtn" data-copy-target="eq-qdef" aria-label="Copy equation 1/q definition">Copy</button>
        </div>
        <p class="muted">
          Here <span class="eq">R</span> is the wavefront radius of curvature, and <span class="eq">w</span> is the 1/e field radius (spot size).
        </p>

        <h3>2) Initial condition: beam enters at its waist</h3>
        <p>
          At a waist, <span class="eq">R → ∞</span> so <span class="eq">1/R = 0</span>. Setting <span class="eq">w(0)=W₀</span> in the definition above gives:
        </p>
        <div class="eqrow">
          <span class="eq" id="eq-q0">q₁ = i z_R,  where  z_R = π n₀ W₀² / λ₀</span>
          <button class="copyBtn" data-copy-target="eq-q0" aria-label="Copy Rayleigh range equation">Copy</button>
        </div>
        <p class="muted">
          This <span class="eq">z_R</span> is the Rayleigh range <em>inside the medium</em> (because diffraction depends on the reduced wavelength <span class="eq">λ₀/n₀</span>).
        </p>

        <h3>3) ABCD law for Gaussian beams</h3>
        <p>
          For any paraxial first-order system with ray matrix
          <span class="eq">[[A,B],[C,D]]</span>, the beam parameter transforms as:
        </p>
        <div class="eqrow">
          <span class="eq" id="eq-abcd">q(d) = (A q₁ + B) / (C q₁ + D)</span>
          <button class="copyBtn" data-copy-target="eq-abcd" aria-label="Copy ABCD law equation">Copy</button>
        </div>

        <h3>4) Insert the SELFOC slab ABCD elements</h3>
        <p>
          The problem gives:
          <span class="eq">A=D=cos(ad)</span>,
          <span class="eq">B=(1/a)sin(ad)</span>,
          <span class="eq">C=−a sin(ad)</span>.
          Using <span class="eq">q₁=i z_R</span>, we obtain:
        </p>

        <div class="card boxed">
          <div class="lead">
            <span class="badge">Derivation core</span>
            <button class="copyBtn" data-copy-text="q(d) = (cos(ad)·i z_R + (1/a)sin(ad)) / (−a sin(ad)·i z_R + cos(ad))">Copy q(d)</button>
          </div>
          <pre aria-label="q(d) expression">q(d) = ( cos(ad)·(i z_R) + (1/a) sin(ad) ) / ( −a sin(ad)·(i z_R) + cos(ad) )</pre>
        </div>

        <h3>5) Extract the spot size w(d) from Im(1/q)</h3>
        <p>
          From <span class="eq">1/q = 1/R − i (λ₀)/(π n₀ w²)</span>, the imaginary part is:
        </p>
        <div class="eqrow">
          <span class="eq" id="eq-im">Im(1/q) = − (λ₀)/(π n₀ w²)</span>
          <button class="copyBtn" data-copy-target="eq-im" aria-label="Copy Im(1/q) relation">Copy</button>
        </div>
        <p>
          Therefore,
          <span class="eq">w²(d) = − (λ₀)/(π n₀) / Im(1/q(d))</span>.
          So we compute <span class="eq">Im(1/q(d))</span>. A straightforward algebraic simplification yields:
        </p>

        <div class="eqrow">
          <span class="eq" id="eq-imq">Im(1/q(d)) = − a² z_R / ( a² z_R² cos²(ad) + sin²(ad) )</span>
          <button class="copyBtn" data-copy-target="eq-imq" aria-label="Copy Im(1/q(d)) expression">Copy</button>
        </div>

        <p>
          Plug this into the formula for <span class="eq">w²(d)</span>:
        </p>
        <pre aria-label="w squared derivation">w²(d) = − (λ₀)/(π n₀)  / Im(1/q(d))
      = − (λ₀)/(π n₀)  / [ − a² z_R / ( a² z_R² cos²(ad) + sin²(ad) ) ]
      = (λ₀)/(π n₀) · ( a² z_R² cos²(ad) + sin²(ad) ) / (a² z_R)</pre>

        <p>
          Now use <span class="eq">z_R = π n₀ W₀²/λ₀</span> ⇒ <span class="eq">(λ₀)/(π n₀) · z_R = W₀²</span>. This collapses the expression neatly:
        </p>

        <div class="card boxed" style="margin-top:10px;">
          <div class="lead">
            <span class="badge">Final result (boxed)</span>
            <button class="copyBtn" data-copy-text="w(d) = W0 * sqrt( cos^2(a d) + sin^2(a d) / (a^2 zR^2) ),   zR = pi n0 W0^2 / lambda0">Copy final (plain text)</button>
          </div>
          <p style="margin:8px 0 6px;">
            <span class="eq" id="eq-final">
              w(d) = W₀ √( cos²(ad) + sin²(ad)/(a² z_R²) ),  with  z_R = π n₀ W₀²/λ₀
            </span>
          </p>
          <p class="muted" style="margin:0;">
            Often it’s useful to define the dimensionless strength <span class="eq">g = a z_R</span>, so
            <span class="eq">w(d) = W₀ √( cos²(ad) + sin²(ad)/g² )</span>.
          </p>
        </div>

        <h3>6) Sanity checks</h3>
        <div class="kpi">
          <div class="item">
            <div class="t">Units</div>
            <div class="v">✅ w has units of length</div>
            <p class="muted" style="margin:6px 0 0">
              The square-root is dimensionless: <span class="eq">ad</span> is dimensionless and <span class="eq">a z_R</span> is dimensionless.
            </p>
          </div>
          <div class="item">
            <div class="t">Limiting case: d → 0</div>
            <div class="v">✅ w(0) = W₀</div>
            <p class="muted" style="margin:6px 0 0">
              Because <span class="eq">cos(0)=1</span> and <span class="eq">sin(0)=0</span>.
            </p>
          </div>
          <div class="item">
            <div class="t">Limiting case: weak GRIN (a → 0)</div>
            <div class="v">✅ recovers free-space spreading (small-ad expansion)</div>
            <p class="muted" style="margin:6px 0 0">
              For small <span class="eq">ad</span>, <span class="eq">sin(ad)≈ad</span>, <span class="eq">cos(ad)≈1</span>, giving
              <span class="eq">w²(d)≈W₀²(1 + d²/z_R²)</span>.
            </p>
          </div>
        </div>

        <h3>7) Physical interpretation</h3>
        <p>
          The width oscillates with angular spatial frequency <span class="eq">a</span>, so the “breathing period” is
          <span class="eq">T = π/a</span> for <span class="eq">w(d)</span> (since it depends on squares of sine/cosine),
          while the underlying ray phase has period <span class="eq">2π/a</span>.
        </p>
        <p>
          The minimum width occurs near <span class="eq">ad = π/2</span> (where <span class="eq">cos=0</span>), giving:
          <span class="eq">w_min = W₀/(a z_R) = W₀/g</span>.
          Large <span class="eq">g=a z_R</span> (strong guiding and/or large Rayleigh range) means tight oscillations around <span class="eq">W₀</span>.
        </p>
      </section>

      <section id="viz">
        <h2>Interactive Visualizations</h2>

        <div class="card callout">
          <p style="margin:0">
            The controls below use <b>example values</b> for plotting (since the problem is symbolic).
            They update <b>all</b> visuals live: the setup diagram, the main plot <span class="eq">w(d)</span>, and the propagation intensity map.
          </p>
        </div>

        <div class="card" style="margin-top:12px;">
          <h3 style="margin-top:0">Controls (example values for visualization)</h3>
          <div class="controls" role="group" aria-label="Interactive controls">
            <div class="ctrl">
              <label for="W0"><span>Waist radius W₀ (µm)</span><span class="value" id="W0v">10.0</span></label>
              <input id="W0" type="range" min="2" max="40" step="0.1" value="10"/>
            </div>
            <div class="ctrl">
              <label for="lambda0"><span>Wavelength λ₀ (nm)</span><span class="value" id="lambda0v">1550</span></label>
              <input id="lambda0" type="range" min="400" max="2000" step="10" value="1550"/>
            </div>
            <div class="ctrl">
              <label for="n0"><span>On-axis index n₀</span><span class="value" id="n0v">1.50</span></label>
              <input id="n0" type="range" min="1.0" max="2.2" step="0.01" value="1.50"/>
            </div>
            <div class="ctrl">
              <label for="a"><span>GRIN strength a (1/mm)</span><span class="value" id="av">2.00</span></label>
              <input id="a" type="range" min="0.1" max="8" step="0.01" value="2.00"/>
            </div>
            <div class="ctrl">
              <label for="L"><span>Plot length d<sub>max</sub> (mm)</span><span class="value" id="Lv">6.0</span></label>
              <input id="L" type="range" min="1" max="20" step="0.1" value="6.0"/>
            </div>
            <div class="ctrl">
              <label for="view"><span>Secondary view</span><span class="value" id="viewv">Intensity map</span></label>
              <select id="view">
                <option value="intensity" selected>Intensity map I(y,d)</option>
                <option value="parameter">Parameter sweep (a vs d)</option>
              </select>
            </div>
          </div>

          <div class="kpi" style="margin-top:12px;">
            <div class="item">
              <div class="t">Computed Rayleigh range (in medium)</div>
              <div class="v" id="zRkpi">—</div>
            </div>
            <div class="item">
              <div class="t">Dimensionless strength g = a z<sub>R</sub></div>
              <div class="v" id="gkpi">—</div>
            </div>
            <div class="item">
              <div class="t">Breathing period T = π/a</div>
              <div class="v" id="Tkpi">—</div>
            </div>
          </div>
        </div>

        <div class="grid2" style="margin-top:12px;">
          <figure class="card canvasCard">
            <canvas id="cSetup" aria-label="Diagram of GRIN slab and Gaussian beam"></canvas>
            <figcaption class="cap">Diagram: beam enters the graded-index slab at its waist; the GRIN focuses it continuously.</figcaption>
          </figure>

          <figure class="card canvasCard">
            <canvas id="cMain" aria-label="Main plot of beam width versus distance"></canvas>
            <figcaption class="cap">Main plot: <span class="eq">w(d)</span> predicted by the boxed formula. Drag sliders to see breathing behavior.</figcaption>
          </figure>
        </div>

        <figure class="card canvasCard" style="margin-top:12px;">
          <canvas id="cSecond" aria-label="Secondary visualization: intensity map or parameter sweep"></canvas>
          <figcaption class="cap" id="secondCap">
            Secondary: intensity map <span class="eq">I(y,d) ∝ exp(−2y²/w(d)²)</span> (or switch to a-parameter sweep).
          </figcaption>
        </figure>
      </section>

      <section id="shape">
        <h2>Beam Shape Sketch & Interpretation</h2>
        <div class="card callout">
          <p style="margin:0">
            The beam envelope inside the slab is not a one-way diffraction expansion like in free space.
            Instead, the GRIN acts like a distributed lens: the radius <span class="eq">w(d)</span> <b>oscillates</b>.
            The “sketch” is a symmetric breathing envelope around the axis: narrow → wide → narrow → …
          </p>
        </div>

        <h3>Qualitative sketch description</h3>
        <ul>
          <li>At <span class="eq">d=0</span>, the beam is at a waist: <span class="eq">w=W₀</span>.</li>
          <li>As <span class="eq">d</span> increases, the GRIN focusing competes with diffraction, producing a periodic change in width.</li>
          <li>The breathing period in <span class="eq">w(d)</span> is <span class="eq">π/a</span>.</li>
          <li>When <span class="eq">a z_R</span> is large (strong guiding / long Rayleigh range), the oscillation amplitude is small.</li>
        </ul>
      </section>
    </main>

    <footer>
      Built with vanilla HTML/CSS/JS • High-DPI canvas rendering • Copy buttons included • Print-friendly layout
    </footer>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite">Copied!</div>

  <script>
    // ---------- Smooth scroll (mini TOC) ----------
    document.querySelectorAll('[data-scroll]').forEach(a=>{
      a.addEventListener('click', (e)=>{
        e.preventDefault();
        const id = a.getAttribute('href');
        const el = document.querySelector(id);
        if(!el) return;
        el.scrollIntoView({behavior:'smooth', block:'start'});
      });
    });

    // ---------- Copy helpers ----------
    const toast = document.getElementById('toast');
    let toastTimer = null;
    function showToast(msg){
      toast.textContent = msg || "Copied!";
      toast.classList.add('show');
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=>toast.classList.remove('show'), 1200);
    }

    async function copyText(text){
      try{
        await navigator.clipboard.writeText(text);
        showToast("Copied!");
      }catch(err){
        // fallback
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        showToast("Copied!");
      }
    }

    document.querySelectorAll('.copyBtn').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const targetId = btn.getAttribute('data-copy-target');
        const directText = btn.getAttribute('data-copy-text');
        if(directText){
          copyText(directText);
          return;
        }
        if(targetId){
          const el = document.getElementById(targetId);
          if(!el) return;
          copyText(el.textContent.replace(/\s+/g,' ').trim());
        }
      });
    });

    // ---------- Math model ----------
    // Units used internally:
    // W0 in meters; lambda0 in meters; a in 1/m; d in m; n0 dimensionless
    function zRayleigh(n0, W0, lambda0){
      // z_R = pi n0 W0^2 / lambda0
      return Math.PI * n0 * W0 * W0 / lambda0;
    }
    function wOfD(W0, a, zR, d){
      // w(d) = W0 * sqrt( cos^2(a d) + sin^2(a d) / (a^2 zR^2) )
      const x = a * d;
      const c = Math.cos(x), s = Math.sin(x);
      const g = a * zR;
      const term = c*c + (s*s)/(g*g);
      return W0 * Math.sqrt(term);
    }

    // ---------- Canvas utilities ----------
    function fitCanvas(canvas, cssHeight){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(320, rect.width);
      const h = cssHeight || rect.height || 320;
      canvas.style.height = (cssHeight ? cssHeight + "px" : "320px");
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {ctx, w, h, dpr};
    }

    function clear(ctx, w, h){
      ctx.clearRect(0,0,w,h);
      // subtle vignette
      const g = ctx.createRadialGradient(w*0.5,h*0.35, 10, w*0.5,h*0.5, Math.max(w,h)*0.8);
      g.addColorStop(0,'rgba(255,255,255,0.02)');
      g.addColorStop(1,'rgba(0,0,0,0.10)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);
    }

    function drawPanelTitle(ctx, w, title){
      ctx.save();
      ctx.fillStyle = 'rgba(234,240,247,0.95)';
      ctx.font = '700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(title, 14, 20);
      ctx.restore();
    }

    function drawAxes(ctx, box, xLabel, yLabel, xTicks, yTicks){
      const {x,y,w,h} = box;
      ctx.save();
      // grid
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;

      for(let i=0;i<=xTicks;i++){
        const xx = x + (w*i/xTicks);
        ctx.beginPath();
        ctx.moveTo(xx, y);
        ctx.lineTo(xx, y+h);
        ctx.stroke();
      }
      for(let j=0;j<=yTicks;j++){
        const yy = y + (h*j/yTicks);
        ctx.beginPath();
        ctx.moveTo(x, yy);
        ctx.lineTo(x+w, yy);
        ctx.stroke();
      }

      // axes border
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 1.2;
      ctx.strokeRect(x,y,w,h);

      // labels
      ctx.fillStyle = 'rgba(234,240,247,0.9)';
      ctx.font = '650 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText(xLabel, x + w - ctx.measureText(xLabel).width, y + h + 22);

      ctx.save();
      ctx.translate(x - 32, y + 10);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();
      ctx.restore();
    }

    function drawTicks(ctx, box, xMin, xMax, yMin, yMax, xTicks, yTicks){
      const {x,y,w,h} = box;
      ctx.save();
      ctx.fillStyle = 'rgba(169,182,198,0.95)';
      ctx.font = '600 11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';

      // x
      for(let i=0;i<=xTicks;i++){
        const t = i/xTicks;
        const val = xMin + t*(xMax-xMin);
        const xx = x + t*w;
        const label = formatNumber(val);
        ctx.fillText(label, xx - ctx.measureText(label).width/2, y + h + 14);
        // tick
        ctx.strokeStyle = 'rgba(255,255,255,0.18)';
        ctx.beginPath(); ctx.moveTo(xx, y+h); ctx.lineTo(xx, y+h+4); ctx.stroke();
      }
      // y
      for(let j=0;j<=yTicks;j++){
        const t = 1 - j/yTicks;
        const val = yMin + t*(yMax-yMin);
        const yy = y + j*(h/yTicks);
        const label = formatNumber(val);
        ctx.fillText(label, x - 8 - ctx.measureText(label).width, yy + 4);
        ctx.strokeStyle = 'rgba(255,255,255,0.18)';
        ctx.beginPath(); ctx.moveTo(x-4, yy); ctx.lineTo(x, yy); ctx.stroke();
      }
      ctx.restore();
    }

    function formatNumber(v){
      const av = Math.abs(v);
      if(av >= 100) return v.toFixed(0);
      if(av >= 10) return v.toFixed(1);
      if(av >= 1) return v.toFixed(2);
      if(av >= 0.1) return v.toFixed(3);
      return v.toExponential(2);
    }

    function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

    // ---------- Draw: Setup diagram ----------
    function drawSetup(canvas, params){
      const {ctx,w,h} = fitCanvas(canvas, 320);
      clear(ctx,w,h);
      drawPanelTitle(ctx,w,"Setup Diagram: Gaussian beam entering a GRIN slab at a waist");

      const margin = 18;
      const yMid = h*0.56;
      const x0 = margin;
      const x1 = w - margin;

      // slab region
      const slabX = w*0.36;
      const slabW = w*0.42;
      const slabY = h*0.18;
      const slabH = h*0.64;

      ctx.save();
      // axis
      ctx.strokeStyle = 'rgba(255,255,255,0.16)';
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(x0, yMid);
      ctx.lineTo(x1, yMid);
      ctx.stroke();

      // labels axis
      ctx.fillStyle = 'rgba(169,182,198,0.95)';
      ctx.font = '650 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('z (propagation)', x1-120, yMid-8);
      ctx.fillText('y', slabX-18, slabY+18);

      // slab
      const grad = ctx.createLinearGradient(slabX,0, slabX+slabW,0);
      grad.addColorStop(0,'rgba(125,211,252,0.10)');
      grad.addColorStop(0.5,'rgba(167,139,250,0.10)');
      grad.addColorStop(1,'rgba(125,211,252,0.10)');
      ctx.fillStyle = grad;
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      roundRect(ctx, slabX, slabY, slabW, slabH, 16);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle='rgba(234,240,247,0.92)';
      ctx.font='750 12.5px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('GRIN slab', slabX+12, slabY+22);
      ctx.fillStyle='rgba(169,182,198,0.95)';
      ctx.font='650 11.5px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';
      ctx.fillText('n(y) ≈ n₀(1 − ½ a² y²)', slabX+12, slabY+42);

      // beam envelope (simple schematic)
      const L = params.L; // meters
      const a = params.a; // 1/m
      const zR = params.zR;
      const W0 = params.W0;

      function zToX(zm){
        // map 0..L to slab region extended
        const left = x0 + 10;
        const right = x1 - 10;
        return left + (zm/L) * (right-left);
      }
      function wToY(wm){
        // map W0*1.4 to pixels
        const maxW = W0*1.6;
        return (wm/maxW) * (slabH*0.35);
      }

      // draw beam boundaries
      ctx.strokeStyle = 'rgba(125,211,252,0.85)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i=0;i<=220;i++){
        const z = (L*i/220);
        const ww = wOfD(W0,a,zR,z);
        const xx = zToX(z);
        const yy = yMid - wToY(ww);
        if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
      }
      ctx.stroke();

      ctx.strokeStyle = 'rgba(125,211,252,0.45)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i=0;i<=220;i++){
        const z = (L*i/220);
        const ww = wOfD(W0,a,zR,z);
        const xx = zToX(z);
        const yy = yMid + wToY(ww);
        if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
      }
      ctx.stroke();

      // waist marker at z=0
      ctx.strokeStyle='rgba(52,211,153,0.85)';
      ctx.lineWidth=2;
      const xWaist = zToX(0);
      ctx.beginPath();
      ctx.moveTo(xWaist, yMid - wToY(W0));
      ctx.lineTo(xWaist, yMid + wToY(W0));
      ctx.stroke();
      ctx.fillStyle='rgba(52,211,153,0.95)';
      ctx.font='750 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('waist (w = W₀)', xWaist+6, yMid - wToY(W0) - 10);

      // slab length marker
      const xSlabL = slabX;
      const xSlabR = slabX+slabW;
      ctx.strokeStyle='rgba(251,191,36,0.85)';
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(xSlabL, slabY+slabH+14);
      ctx.lineTo(xSlabR, slabY+slabH+14);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(xSlabL, slabY+slabH+10); ctx.lineTo(xSlabL, slabY+slabH+18);
      ctx.moveTo(xSlabR, slabY+slabH+10); ctx.lineTo(xSlabR, slabY+slabH+18);
      ctx.stroke();
      ctx.fillStyle='rgba(251,191,36,0.95)';
      ctx.font='750 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('slab length d', (xSlabL+xSlabR)/2 - 42, slabY+slabH+34);

      // legend
      ctx.fillStyle='rgba(234,240,247,0.92)';
      ctx.font='650 11.8px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('Beam envelope ~ ±w(d)', x0+12, slabY+slabH-10);

      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    // ---------- Draw: Main plot w(d) ----------
    function drawMain(canvas, params){
      const {ctx,w,h} = fitCanvas(canvas, 320);
      clear(ctx,w,h);
      drawPanelTitle(ctx,w,"Main Plot: beam width w(d) inside the GRIN slab");

      const box = {x:64, y:40, w:w-90, h:h-88};
      const xMin = 0, xMax = params.Lmm; // mm
      // compute curve for y range
      let wMin=1e9, wMax=0;
      const N=600;
      for(let i=0;i<=N;i++){
        const dmm = xMin + (xMax-xMin)*i/N;
        const dm = dmm*1e-3;
        const ww = wOfD(params.W0, params.a, params.zR, dm);
        wMin = Math.min(wMin, ww);
        wMax = Math.max(wMax, ww);
      }
      // display in microns
      let yMin = (wMin*1e6)*0.92;
      let yMax = (wMax*1e6)*1.08;
      if(yMax - yMin < 0.5){ yMax = yMin + 0.5; }

      drawAxes(ctx, box, "d (mm)", "w(d) (µm)", 6, 5);
      drawTicks(ctx, box, xMin, xMax, yMin, yMax, 6, 5);

      function xToPx(dmm){ return box.x + (dmm-xMin)/(xMax-xMin)*box.w; }
      function yToPx(wum){ return box.y + (yMax-wum)/(yMax-yMin)*box.h; }

      // curve
      ctx.save();
      ctx.strokeStyle='rgba(125,211,252,0.95)';
      ctx.lineWidth=2.4;
      ctx.beginPath();
      for(let i=0;i<=N;i++){
        const dmm = xMin + (xMax-xMin)*i/N;
        const dm = dmm*1e-3;
        const wum = wOfD(params.W0, params.a, params.zR, dm)*1e6;
        const xx = xToPx(dmm), yy=yToPx(wum);
        if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
      }
      ctx.stroke();

      // reference line W0
      const W0um = params.W0*1e6;
      ctx.strokeStyle='rgba(52,211,153,0.55)';
      ctx.lineWidth=1.6;
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(box.x, yToPx(W0um));
      ctx.lineTo(box.x+box.w, yToPx(W0um));
      ctx.stroke();
      ctx.setLineDash([]);

      // annotation
      ctx.fillStyle='rgba(52,211,153,0.9)';
      ctx.font='700 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('W₀', box.x+8, yToPx(W0um)-6);

      // legend
      const lx = box.x + 10, ly = box.y + 10;
      ctx.fillStyle='rgba(16,24,36,0.70)';
      ctx.strokeStyle='rgba(255,255,255,0.12)';
      ctx.lineWidth=1.2;
      roundRect(ctx, lx, ly, 170, 56, 12);
      ctx.fill(); ctx.stroke();

      ctx.strokeStyle='rgba(125,211,252,0.95)';
      ctx.lineWidth=2.4;
      ctx.beginPath(); ctx.moveTo(lx+12, ly+18); ctx.lineTo(lx+42, ly+18); ctx.stroke();
      ctx.fillStyle='rgba(234,240,247,0.92)';
      ctx.font='650 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('w(d)', lx+52, ly+22);

      ctx.strokeStyle='rgba(52,211,153,0.55)';
      ctx.lineWidth=1.6;
      ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(lx+12, ly+40); ctx.lineTo(lx+42, ly+40); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle='rgba(234,240,247,0.92)';
      ctx.fillText('W₀ reference', lx+52, ly+44);

      ctx.restore();
    }

    // ---------- Draw: Secondary view ----------
    function drawSecond(canvas, params){
      const mode = params.view;
      const {ctx,w,h} = fitCanvas(canvas, 360);
      clear(ctx,w,h);

      if(mode === 'parameter'){
        drawPanelTitle(ctx,w,"Secondary: parameter sweep — w(d) vs d for varying a");
        drawParameterSweep(ctx,w,h,params);
      }else{
        drawPanelTitle(ctx,w,"Secondary: intensity map I(y,d) ∝ exp(−2y²/w(d)²)");
        drawIntensityMap(ctx,w,h,params);
      }
    }

    function drawIntensityMap(ctx, w, h, params){
      // plot box: d along x, y along vertical
      const box = {x:70, y:42, w:w-96, h:h-96};
      const dMin = 0, dMax = params.Lmm; // mm
      // y range: +- yMax = k * max(w)
      let wMax=0;
      const Ns=450;
      for(let i=0;i<=Ns;i++){
        const dmm = dMin + (dMax-dMin)*i/Ns;
        const ww = wOfD(params.W0, params.a, params.zR, dmm*1e-3);
        wMax = Math.max(wMax, ww);
      }
      const yMax = 2.6 * wMax; // meters
      const yMin = -yMax;

      // draw axes
      drawAxes(ctx, box, "d (mm)", "y (µm)", 6, 6);
      drawTicks(ctx, box, dMin, dMax, yMin*1e6, yMax*1e6, 6, 6);

      // heatmap render (coarse but crisp)
      const nx = 280, ny = 180;
      const img = ctx.createImageData(nx, ny);

      function dAt(ix){ return dMin + (dMax-dMin)*ix/(nx-1); } // mm
      function yAt(iy){ return yMax - (2*yMax)*iy/(ny-1); } // meters (top to bottom)

      // intensity scaling
      for(let iy=0; iy<ny; iy++){
        const y = yAt(iy);
        for(let ix=0; ix<nx; ix++){
          const dmm = dAt(ix);
          const ww = wOfD(params.W0, params.a, params.zR, dmm*1e-3);
          const I = Math.exp(-2*(y*y)/(ww*ww)); // normalized
          const idx = (iy*nx + ix)*4;

          // map I to a nice monochrome-with-tint using simple ramp
          const base = clamp(I,0,1);
          // lightness
          const L = 0.10 + 0.90*base;
          // RGB with slight cyan tint
          img.data[idx+0] = Math.floor(255 * (0.08 + 0.30*L));
          img.data[idx+1] = Math.floor(255 * (0.12 + 0.75*L));
          img.data[idx+2] = Math.floor(255 * (0.16 + 0.85*L));
          img.data[idx+3] = 255;
        }
      }

      // put image scaled into plot box
      ctx.save();
      ctx.globalAlpha = 0.92;
      // draw to offscreen then scale to box for speed
      const off = document.createElement('canvas');
      off.width = nx; off.height = ny;
      const octx = off.getContext('2d');
      octx.putImageData(img,0,0);

      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(off, box.x, box.y, box.w, box.h);
      ctx.restore();

      // overlay beam envelope lines y=±w(d)
      function xToPx(dmm){ return box.x + (dmm-dMin)/(dMax-dMin)*box.w; }
      function yToPx(ym){ return box.y + (yMax-ym)/(yMax-yMin)*box.h; }
      ctx.save();
      ctx.strokeStyle='rgba(251,191,36,0.95)';
      ctx.lineWidth=2;
      ctx.beginPath();
      for(let i=0;i<=Ns;i++){
        const dmm = dMin + (dMax-dMin)*i/Ns;
        const ww = wOfD(params.W0, params.a, params.zR, dmm*1e-3);
        const xx = xToPx(dmm);
        const yy = yToPx(ww);
        if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
      }
      ctx.stroke();

      ctx.globalAlpha=0.85;
      ctx.beginPath();
      for(let i=0;i<=Ns;i++){
        const dmm = dMin + (dMax-dMin)*i/Ns;
        const ww = wOfD(params.W0, params.a, params.zR, dmm*1e-3);
        const xx = xToPx(dmm);
        const yy = yToPx(-ww);
        if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
      }
      ctx.stroke();
      ctx.restore();

      // legend
      ctx.save();
      const lx = box.x + 10, ly = box.y + 10;
      ctx.fillStyle='rgba(16,24,36,0.70)';
      ctx.strokeStyle='rgba(255,255,255,0.12)';
      roundRect(ctx, lx, ly, 240, 64, 12);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle='rgba(234,240,247,0.92)';
      ctx.font='650 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('Heatmap: normalized intensity', lx+12, ly+22);
      ctx.strokeStyle='rgba(251,191,36,0.95)';
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(lx+12, ly+42); ctx.lineTo(lx+42, ly+42); ctx.stroke();
      ctx.fillStyle='rgba(234,240,247,0.92)';
      ctx.fillText('Envelope: y = ±w(d)', lx+52, ly+46);
      ctx.restore();
    }

    function drawParameterSweep(ctx, w, h, params){
      // Heatmap where x=d, y=a; color=w(d)/W0 or w(d) in um
      const box = {x:70, y:42, w:w-96, h:h-96};
      const dMin=0, dMax=params.Lmm; // mm
      const aMin=0.2, aMax=8.0; // 1/mm (display)
      drawAxes(ctx, box, "d (mm)", "a (1/mm)", 6, 6);
      drawTicks(ctx, box, dMin, dMax, aMin, aMax, 6, 6);

      const nx=300, ny=170;
      const img = ctx.createImageData(nx,ny);

      function dAt(ix){ return dMin + (dMax-dMin)*ix/(nx-1); } // mm
      function aAt(iy){ return aMax - (aMax-aMin)*iy/(ny-1); } // 1/mm top->bottom

      // Determine range for color scaling
      let vMin=1e9, vMax=-1e9;
      for(let iy=0; iy<ny; iy+=8){
        const amm = aAt(iy);
        const a = amm*1e3; // 1/m
        for(let ix=0; ix<nx; ix+=8){
          const dmm = dAt(ix);
          const ww = wOfD(params.W0, a, params.zR, dmm*1e-3);
          const val = ww/params.W0; // normalized
          vMin = Math.min(vMin,val);
          vMax = Math.max(vMax,val);
        }
      }
      if(!isFinite(vMin) || !isFinite(vMax) || vMax<=vMin){
        vMin=0.5; vMax=1.5;
      }

      for(let iy=0; iy<ny; iy++){
        const amm = aAt(iy);
        const a = amm*1e3;
        for(let ix=0; ix<nx; ix++){
          const dmm = dAt(ix);
          const ww = wOfD(params.W0, a, params.zR, dmm*1e-3);
          const val = ww/params.W0;
          const t = clamp((val - vMin)/(vMax - vMin), 0, 1);

          // ramp: purple->cyan->green-ish
          const r = 0.12 + 0.25*(1-t) + 0.10*t;
          const g = 0.10 + 0.55*t;
          const b = 0.20 + 0.65*(1-t) + 0.15*t;
          const idx=(iy*nx+ix)*4;
          img.data[idx+0]=Math.floor(255*r);
          img.data[idx+1]=Math.floor(255*g);
          img.data[idx+2]=Math.floor(255*b);
          img.data[idx+3]=255;
        }
      }

      // draw image into plot box
      const off=document.createElement('canvas');
      off.width=nx; off.height=ny;
      off.getContext('2d').putImageData(img,0,0);
      ctx.save();
      ctx.globalAlpha=0.92;
      ctx.imageSmoothingEnabled=true;
      ctx.drawImage(off, box.x, box.y, box.w, box.h);
      ctx.restore();

      // overlay current a line
      function aToPy(amm){ return box.y + (aMax-amm)/(aMax-aMin)*box.h; }
      const aNow_mm = params.a/1e3; // 1/mm
      const yLine = aToPy(clamp(aNow_mm,aMin,aMax));
      ctx.save();
      ctx.strokeStyle='rgba(251,191,36,0.95)';
      ctx.lineWidth=2;
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(box.x, yLine);
      ctx.lineTo(box.x+box.w, yLine);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle='rgba(251,191,36,0.95)';
      ctx.font='750 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('current a', box.x+10, yLine-8);
      ctx.restore();

      // legend
      ctx.save();
      const lx=box.x+10, ly=box.y+10;
      ctx.fillStyle='rgba(16,24,36,0.70)';
      ctx.strokeStyle='rgba(255,255,255,0.12)';
      roundRect(ctx, lx, ly, 280, 70, 12);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle='rgba(234,240,247,0.92)';
      ctx.font='650 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('Color: normalized width w(d)/W₀', lx+12, ly+22);
      ctx.fillStyle='rgba(169,182,198,0.95)';
      ctx.font='650 11.5px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace';
      ctx.fillText(`range ~ [${formatNumber(vMin)}, ${formatNumber(vMax)}]`, lx+12, ly+42);
      ctx.strokeStyle='rgba(251,191,36,0.95)';
      ctx.lineWidth=2;
      ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(lx+12, ly+58); ctx.lineTo(lx+42, ly+58); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle='rgba(234,240,247,0.92)';
      ctx.font='650 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillText('dashed: current a', lx+52, ly+62);
      ctx.restore();
    }

    // ---------- UI wiring ----------
    const elW0 = document.getElementById('W0');
    const elLambda0 = document.getElementById('lambda0');
    const elN0 = document.getElementById('n0');
    const elA = document.getElementById('a');
    const elL = document.getElementById('L');
    const elView = document.getElementById('view');

    const W0v = document.getElementById('W0v');
    const lambda0v = document.getElementById('lambda0v');
    const n0v = document.getElementById('n0v');
    const av = document.getElementById('av');
    const Lv = document.getElementById('Lv');
    const viewv = document.getElementById('viewv');

    const zRkpi = document.getElementById('zRkpi');
    const gkpi = document.getElementById('gkpi');
    const Tkpi = document.getElementById('Tkpi');
    const secondCap = document.getElementById('secondCap');

    const cSetup = document.getElementById('cSetup');
    const cMain = document.getElementById('cMain');
    const cSecond = document.getElementById('cSecond');

    function getParams(){
      const W0_um = parseFloat(elW0.value);
      const lambda0_nm = parseFloat(elLambda0.value);
      const n0 = parseFloat(elN0.value);
      const a_per_mm = parseFloat(elA.value);
      const L_mm = parseFloat(elL.value);
      const view = elView.value;

      const W0 = W0_um * 1e-6;
      const lambda0 = lambda0_nm * 1e-9;
      const a = a_per_mm * 1e3; // 1/m
      const zR = zRayleigh(n0, W0, lambda0);

      return {
        W0, W0_um,
        lambda0, lambda0_nm,
        n0,
        a, a_per_mm,
        zR,
        Lmm: L_mm,
        L: L_mm * 1e-3,
        view
      };
    }

    function updateLabels(p){
      W0v.textContent = p.W0_um.toFixed(1);
      lambda0v.textContent = String(Math.round(p.lambda0_nm));
      n0v.textContent = p.n0.toFixed(2);
      av.textContent = p.a_per_mm.toFixed(2);
      Lv.textContent = p.Lmm.toFixed(1);
      viewv.textContent = (p.view === 'parameter') ? 'Parameter sweep' : 'Intensity map';

      const zRmm = p.zR * 1e3;
      const g = p.a * p.zR;
      const Tmm = (Math.PI / p.a) * 1e3;
      zRkpi.textContent = `${formatNumber(zRmm)} mm`;
      gkpi.textContent = `${formatNumber(g)} (dimensionless)`;
      Tkpi.textContent = `${formatNumber(Tmm)} mm`;

      secondCap.textContent = (p.view === 'parameter')
        ? 'Secondary: parameter sweep heatmap shows normalized width w(d)/W₀ versus distance d and GRIN strength a.'
        : 'Secondary: intensity map I(y,d) ∝ exp(−2y²/w(d)²) with overlaid envelope y = ±w(d).';
    }

    function renderAll(){
      const p = getParams();
      updateLabels(p);
      drawSetup(cSetup, p);
      drawMain(cMain, p);
      drawSecond(cSecond, p);
    }

    [elW0, elLambda0, elN0, elA, elL, elView].forEach(el=>{
      el.addEventListener('input', renderAll);
      el.addEventListener('change', renderAll);
    });

    // responsive redraw
    let resizeTimer=null;
    window.addEventListener('resize', ()=>{
      clearTimeout(resizeTimer);
      resizeTimer=setTimeout(renderAll, 120);
    });

    // initial render
    renderAll();
  </script>
</body>
</html>
